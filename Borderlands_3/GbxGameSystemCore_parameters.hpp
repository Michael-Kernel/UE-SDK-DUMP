#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxGameSystemCore

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "AIModule_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function GbxGameSystemCore.GbxAction.OnBegin
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_OnBegin final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_OnBegin) == 0x000008, "Wrong alignment on GbxAction_OnBegin");
static_assert(sizeof(GbxAction_OnBegin) == 0x000008, "Wrong size on GbxAction_OnBegin");
static_assert(offsetof(GbxAction_OnBegin, Actor) == 0x000000, "Member 'GbxAction_OnBegin::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.OnEnd
// 0x0010 (0x0010 - 0x0000)
struct GbxAction_OnEnd final
{
public:
	EGbxActionEndState                            ActionEndState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_OnEnd) == 0x000008, "Wrong alignment on GbxAction_OnEnd");
static_assert(sizeof(GbxAction_OnEnd) == 0x000010, "Wrong size on GbxAction_OnEnd");
static_assert(offsetof(GbxAction_OnEnd, ActionEndState) == 0x000000, "Member 'GbxAction_OnEnd::ActionEndState' has a wrong offset!");
static_assert(offsetof(GbxAction_OnEnd, Actor) == 0x000008, "Member 'GbxAction_OnEnd::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.OnServerBegin
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_OnServerBegin final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_OnServerBegin) == 0x000008, "Wrong alignment on GbxAction_OnServerBegin");
static_assert(sizeof(GbxAction_OnServerBegin) == 0x000008, "Wrong size on GbxAction_OnServerBegin");
static_assert(offsetof(GbxAction_OnServerBegin, Actor) == 0x000000, "Member 'GbxAction_OnServerBegin::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.OnServerEnd
// 0x0010 (0x0010 - 0x0000)
struct GbxAction_OnServerEnd final
{
public:
	EGbxActionEndState                            ActionEndState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_OnServerEnd) == 0x000008, "Wrong alignment on GbxAction_OnServerEnd");
static_assert(sizeof(GbxAction_OnServerEnd) == 0x000010, "Wrong size on GbxAction_OnServerEnd");
static_assert(offsetof(GbxAction_OnServerEnd, ActionEndState) == 0x000000, "Member 'GbxAction_OnServerEnd::ActionEndState' has a wrong offset!");
static_assert(offsetof(GbxAction_OnServerEnd, Actor) == 0x000008, "Member 'GbxAction_OnServerEnd::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetActor
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_K2_GetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_K2_GetActor) == 0x000008, "Wrong alignment on GbxAction_K2_GetActor");
static_assert(sizeof(GbxAction_K2_GetActor) == 0x000008, "Wrong size on GbxAction_K2_GetActor");
static_assert(offsetof(GbxAction_K2_GetActor, ReturnValue) == 0x000000, "Member 'GbxAction_K2_GetActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetCurrentNormalizedTime
// 0x0004 (0x0004 - 0x0000)
struct GbxAction_K2_GetCurrentNormalizedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_K2_GetCurrentNormalizedTime) == 0x000004, "Wrong alignment on GbxAction_K2_GetCurrentNormalizedTime");
static_assert(sizeof(GbxAction_K2_GetCurrentNormalizedTime) == 0x000004, "Wrong size on GbxAction_K2_GetCurrentNormalizedTime");
static_assert(offsetof(GbxAction_K2_GetCurrentNormalizedTime, ReturnValue) == 0x000000, "Member 'GbxAction_K2_GetCurrentNormalizedTime::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetCurrentTime
// 0x0004 (0x0004 - 0x0000)
struct GbxAction_K2_GetCurrentTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_K2_GetCurrentTime) == 0x000004, "Wrong alignment on GbxAction_K2_GetCurrentTime");
static_assert(sizeof(GbxAction_K2_GetCurrentTime) == 0x000004, "Wrong size on GbxAction_K2_GetCurrentTime");
static_assert(offsetof(GbxAction_K2_GetCurrentTime, ReturnValue) == 0x000000, "Member 'GbxAction_K2_GetCurrentTime::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetFloatRegisterValue
// 0x0010 (0x0010 - 0x0000)
struct GbxAction_K2_GetFloatRegisterValue final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutFloat;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAction_K2_GetFloatRegisterValue) == 0x000004, "Wrong alignment on GbxAction_K2_GetFloatRegisterValue");
static_assert(sizeof(GbxAction_K2_GetFloatRegisterValue) == 0x000010, "Wrong size on GbxAction_K2_GetFloatRegisterValue");
static_assert(offsetof(GbxAction_K2_GetFloatRegisterValue, InName) == 0x000000, "Member 'GbxAction_K2_GetFloatRegisterValue::InName' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetFloatRegisterValue, OutFloat) == 0x000008, "Member 'GbxAction_K2_GetFloatRegisterValue::OutFloat' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetFloatRegisterValue, ReturnValue) == 0x00000C, "Member 'GbxAction_K2_GetFloatRegisterValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetIntRegisterValue
// 0x0010 (0x0010 - 0x0000)
struct GbxAction_K2_GetIntRegisterValue final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutInt;                                            // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAction_K2_GetIntRegisterValue) == 0x000004, "Wrong alignment on GbxAction_K2_GetIntRegisterValue");
static_assert(sizeof(GbxAction_K2_GetIntRegisterValue) == 0x000010, "Wrong size on GbxAction_K2_GetIntRegisterValue");
static_assert(offsetof(GbxAction_K2_GetIntRegisterValue, InName) == 0x000000, "Member 'GbxAction_K2_GetIntRegisterValue::InName' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetIntRegisterValue, OutInt) == 0x000008, "Member 'GbxAction_K2_GetIntRegisterValue::OutInt' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetIntRegisterValue, ReturnValue) == 0x00000C, "Member 'GbxAction_K2_GetIntRegisterValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetMaxCurrentTime
// 0x0004 (0x0004 - 0x0000)
struct GbxAction_K2_GetMaxCurrentTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_K2_GetMaxCurrentTime) == 0x000004, "Wrong alignment on GbxAction_K2_GetMaxCurrentTime");
static_assert(sizeof(GbxAction_K2_GetMaxCurrentTime) == 0x000004, "Wrong size on GbxAction_K2_GetMaxCurrentTime");
static_assert(offsetof(GbxAction_K2_GetMaxCurrentTime, ReturnValue) == 0x000000, "Member 'GbxAction_K2_GetMaxCurrentTime::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetNameRegisterValue
// 0x0018 (0x0018 - 0x0000)
struct GbxAction_K2_GetNameRegisterValue final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutName;                                           // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAction_K2_GetNameRegisterValue) == 0x000004, "Wrong alignment on GbxAction_K2_GetNameRegisterValue");
static_assert(sizeof(GbxAction_K2_GetNameRegisterValue) == 0x000018, "Wrong size on GbxAction_K2_GetNameRegisterValue");
static_assert(offsetof(GbxAction_K2_GetNameRegisterValue, InName) == 0x000000, "Member 'GbxAction_K2_GetNameRegisterValue::InName' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetNameRegisterValue, OutName) == 0x000008, "Member 'GbxAction_K2_GetNameRegisterValue::OutName' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetNameRegisterValue, ReturnValue) == 0x000010, "Member 'GbxAction_K2_GetNameRegisterValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetObjectRegisterValue
// 0x0018 (0x0018 - 0x0000)
struct GbxAction_K2_GetObjectRegisterValue final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OutObject;                                         // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAction_K2_GetObjectRegisterValue) == 0x000008, "Wrong alignment on GbxAction_K2_GetObjectRegisterValue");
static_assert(sizeof(GbxAction_K2_GetObjectRegisterValue) == 0x000018, "Wrong size on GbxAction_K2_GetObjectRegisterValue");
static_assert(offsetof(GbxAction_K2_GetObjectRegisterValue, InName) == 0x000000, "Member 'GbxAction_K2_GetObjectRegisterValue::InName' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetObjectRegisterValue, OutObject) == 0x000008, "Member 'GbxAction_K2_GetObjectRegisterValue::OutObject' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetObjectRegisterValue, ReturnValue) == 0x000010, "Member 'GbxAction_K2_GetObjectRegisterValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetTimeRemaining
// 0x0004 (0x0004 - 0x0000)
struct GbxAction_K2_GetTimeRemaining final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_K2_GetTimeRemaining) == 0x000004, "Wrong alignment on GbxAction_K2_GetTimeRemaining");
static_assert(sizeof(GbxAction_K2_GetTimeRemaining) == 0x000004, "Wrong size on GbxAction_K2_GetTimeRemaining");
static_assert(offsetof(GbxAction_K2_GetTimeRemaining, ReturnValue) == 0x000000, "Member 'GbxAction_K2_GetTimeRemaining::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction.K2_GetVectorRegisterValue
// 0x0018 (0x0018 - 0x0000)
struct GbxAction_K2_GetVectorRegisterValue final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutVector;                                         // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAction_K2_GetVectorRegisterValue) == 0x000004, "Wrong alignment on GbxAction_K2_GetVectorRegisterValue");
static_assert(sizeof(GbxAction_K2_GetVectorRegisterValue) == 0x000018, "Wrong size on GbxAction_K2_GetVectorRegisterValue");
static_assert(offsetof(GbxAction_K2_GetVectorRegisterValue, InName) == 0x000000, "Member 'GbxAction_K2_GetVectorRegisterValue::InName' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetVectorRegisterValue, OutVector) == 0x000008, "Member 'GbxAction_K2_GetVectorRegisterValue::OutVector' has a wrong offset!");
static_assert(offsetof(GbxAction_K2_GetVectorRegisterValue, ReturnValue) == 0x000014, "Member 'GbxAction_K2_GetVectorRegisterValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtActorSocketMulticast
// 0x0030 (0x0030 - 0x0000)
struct GbxGameState_SpawnEmitterAtActorSocketMulticast final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EmitterTemplate;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ParameterEvaluationContext;                        // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameState_SpawnEmitterAtActorSocketMulticast) == 0x000008, "Wrong alignment on GbxGameState_SpawnEmitterAtActorSocketMulticast");
static_assert(sizeof(GbxGameState_SpawnEmitterAtActorSocketMulticast) == 0x000030, "Wrong size on GbxGameState_SpawnEmitterAtActorSocketMulticast");
static_assert(offsetof(GbxGameState_SpawnEmitterAtActorSocketMulticast, WorldContextObject) == 0x000000, "Member 'GbxGameState_SpawnEmitterAtActorSocketMulticast::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtActorSocketMulticast, EmitterTemplate) == 0x000008, "Member 'GbxGameState_SpawnEmitterAtActorSocketMulticast::EmitterTemplate' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtActorSocketMulticast, Actor) == 0x000010, "Member 'GbxGameState_SpawnEmitterAtActorSocketMulticast::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtActorSocketMulticast, Socket) == 0x000018, "Member 'GbxGameState_SpawnEmitterAtActorSocketMulticast::Socket' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtActorSocketMulticast, bAutoDestroy) == 0x000020, "Member 'GbxGameState_SpawnEmitterAtActorSocketMulticast::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtActorSocketMulticast, ParameterEvaluationContext) == 0x000028, "Member 'GbxGameState_SpawnEmitterAtActorSocketMulticast::ParameterEvaluationContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtComponentSocketMulticast
// 0x0030 (0x0030 - 0x0000)
struct GbxGameState_SpawnEmitterAtComponentSocketMulticast final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EmitterTemplate;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Component;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ParameterEvaluationContext;                        // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameState_SpawnEmitterAtComponentSocketMulticast) == 0x000008, "Wrong alignment on GbxGameState_SpawnEmitterAtComponentSocketMulticast");
static_assert(sizeof(GbxGameState_SpawnEmitterAtComponentSocketMulticast) == 0x000030, "Wrong size on GbxGameState_SpawnEmitterAtComponentSocketMulticast");
static_assert(offsetof(GbxGameState_SpawnEmitterAtComponentSocketMulticast, WorldContextObject) == 0x000000, "Member 'GbxGameState_SpawnEmitterAtComponentSocketMulticast::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtComponentSocketMulticast, EmitterTemplate) == 0x000008, "Member 'GbxGameState_SpawnEmitterAtComponentSocketMulticast::EmitterTemplate' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtComponentSocketMulticast, Component) == 0x000010, "Member 'GbxGameState_SpawnEmitterAtComponentSocketMulticast::Component' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtComponentSocketMulticast, Socket) == 0x000018, "Member 'GbxGameState_SpawnEmitterAtComponentSocketMulticast::Socket' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtComponentSocketMulticast, bAutoDestroy) == 0x000020, "Member 'GbxGameState_SpawnEmitterAtComponentSocketMulticast::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtComponentSocketMulticast, ParameterEvaluationContext) == 0x000028, "Member 'GbxGameState_SpawnEmitterAtComponentSocketMulticast::ParameterEvaluationContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtLocationMulticast
// 0x0040 (0x0040 - 0x0000)
struct GbxGameState_SpawnEmitterAtLocationMulticast final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EmitterTemplate;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ParameterEvaluationContext;                        // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameState_SpawnEmitterAtLocationMulticast) == 0x000008, "Wrong alignment on GbxGameState_SpawnEmitterAtLocationMulticast");
static_assert(sizeof(GbxGameState_SpawnEmitterAtLocationMulticast) == 0x000040, "Wrong size on GbxGameState_SpawnEmitterAtLocationMulticast");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, WorldContextObject) == 0x000000, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, EmitterTemplate) == 0x000008, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::EmitterTemplate' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, Location) == 0x000010, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::Location' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, Rotation) == 0x00001C, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::Rotation' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, Scale) == 0x000028, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::Scale' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, bAutoDestroy) == 0x000034, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticast, ParameterEvaluationContext) == 0x000038, "Member 'GbxGameState_SpawnEmitterAtLocationMulticast::ParameterEvaluationContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameState.PlayHitRegionImpactMulticast
// 0x0050 (0x0050 - 0x0000)
struct GbxGameState_PlayHitRegionImpactMulticast final
{
public:
	const class UHitRegionData*                   HitRegion;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ImpactInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FReplicatedImpactHitResult             HitResult;                                         // 0x0010(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameState_PlayHitRegionImpactMulticast) == 0x000008, "Wrong alignment on GbxGameState_PlayHitRegionImpactMulticast");
static_assert(sizeof(GbxGameState_PlayHitRegionImpactMulticast) == 0x000050, "Wrong size on GbxGameState_PlayHitRegionImpactMulticast");
static_assert(offsetof(GbxGameState_PlayHitRegionImpactMulticast, HitRegion) == 0x000000, "Member 'GbxGameState_PlayHitRegionImpactMulticast::HitRegion' has a wrong offset!");
static_assert(offsetof(GbxGameState_PlayHitRegionImpactMulticast, ImpactInstigator) == 0x000008, "Member 'GbxGameState_PlayHitRegionImpactMulticast::ImpactInstigator' has a wrong offset!");
static_assert(offsetof(GbxGameState_PlayHitRegionImpactMulticast, HitResult) == 0x000010, "Member 'GbxGameState_PlayHitRegionImpactMulticast::HitResult' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameState.PlayImpactMulticast
// 0x0100 (0x0100 - 0x0000)
struct GbxGameState_PlayImpactMulticast final
{
public:
	const class UImpactData*                      ImpactData;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ImpactInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FReplicatedImpactHitResult             HitResult;                                         // 0x0010(0x0040)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FImpactResponseParams                  ResponseParams;                                    // 0x0050(0x00B0)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameState_PlayImpactMulticast) == 0x000010, "Wrong alignment on GbxGameState_PlayImpactMulticast");
static_assert(sizeof(GbxGameState_PlayImpactMulticast) == 0x000100, "Wrong size on GbxGameState_PlayImpactMulticast");
static_assert(offsetof(GbxGameState_PlayImpactMulticast, ImpactData) == 0x000000, "Member 'GbxGameState_PlayImpactMulticast::ImpactData' has a wrong offset!");
static_assert(offsetof(GbxGameState_PlayImpactMulticast, ImpactInstigator) == 0x000008, "Member 'GbxGameState_PlayImpactMulticast::ImpactInstigator' has a wrong offset!");
static_assert(offsetof(GbxGameState_PlayImpactMulticast, HitResult) == 0x000010, "Member 'GbxGameState_PlayImpactMulticast::HitResult' has a wrong offset!");
static_assert(offsetof(GbxGameState_PlayImpactMulticast, ResponseParams) == 0x000050, "Member 'GbxGameState_PlayImpactMulticast::ResponseParams' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtLocationMulticastImpl
// 0x0038 (0x0038 - 0x0000)
struct GbxGameState_SpawnEmitterAtLocationMulticastImpl final
{
public:
	class UParticleSystem*                        EmitterTemplate;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ParameterEvaluationContext;                        // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameState_SpawnEmitterAtLocationMulticastImpl) == 0x000008, "Wrong alignment on GbxGameState_SpawnEmitterAtLocationMulticastImpl");
static_assert(sizeof(GbxGameState_SpawnEmitterAtLocationMulticastImpl) == 0x000038, "Wrong size on GbxGameState_SpawnEmitterAtLocationMulticastImpl");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticastImpl, EmitterTemplate) == 0x000000, "Member 'GbxGameState_SpawnEmitterAtLocationMulticastImpl::EmitterTemplate' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticastImpl, Location) == 0x000008, "Member 'GbxGameState_SpawnEmitterAtLocationMulticastImpl::Location' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticastImpl, Rotation) == 0x000014, "Member 'GbxGameState_SpawnEmitterAtLocationMulticastImpl::Rotation' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticastImpl, Scale) == 0x000020, "Member 'GbxGameState_SpawnEmitterAtLocationMulticastImpl::Scale' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticastImpl, bAutoDestroy) == 0x00002C, "Member 'GbxGameState_SpawnEmitterAtLocationMulticastImpl::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GbxGameState_SpawnEmitterAtLocationMulticastImpl, ParameterEvaluationContext) == 0x000030, "Member 'GbxGameState_SpawnEmitterAtLocationMulticastImpl::ParameterEvaluationContext' has a wrong offset!");

// Function GbxGameSystemCore.UsableComponent.SetInteractionHeader
// 0x0018 (0x0018 - 0x0000)
struct UsableComponent_SetInteractionHeader final
{
public:
	class FText                                   NewHeaderName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UsableComponent_SetInteractionHeader) == 0x000008, "Wrong alignment on UsableComponent_SetInteractionHeader");
static_assert(sizeof(UsableComponent_SetInteractionHeader) == 0x000018, "Wrong size on UsableComponent_SetInteractionHeader");
static_assert(offsetof(UsableComponent_SetInteractionHeader, NewHeaderName) == 0x000000, "Member 'UsableComponent_SetInteractionHeader::NewHeaderName' has a wrong offset!");

// Function GbxGameSystemCore.UsableComponent.SetUsableLocked
// 0x0010 (0x0010 - 0x0000)
struct UsableComponent_SetUsableLocked final
{
public:
	bool                                          bLocked;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UsableComponent_SetUsableLocked) == 0x000004, "Wrong alignment on UsableComponent_SetUsableLocked");
static_assert(sizeof(UsableComponent_SetUsableLocked) == 0x000010, "Wrong size on UsableComponent_SetUsableLocked");
static_assert(offsetof(UsableComponent_SetUsableLocked, bLocked) == 0x000000, "Member 'UsableComponent_SetUsableLocked::bLocked' has a wrong offset!");
static_assert(offsetof(UsableComponent_SetUsableLocked, Reason) == 0x000008, "Member 'UsableComponent_SetUsableLocked::Reason' has a wrong offset!");

// Function GbxGameSystemCore.UsableComponent.GetInteractionHeader
// 0x0018 (0x0018 - 0x0000)
struct UsableComponent_GetInteractionHeader final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UsableComponent_GetInteractionHeader) == 0x000008, "Wrong alignment on UsableComponent_GetInteractionHeader");
static_assert(sizeof(UsableComponent_GetInteractionHeader) == 0x000018, "Wrong size on UsableComponent_GetInteractionHeader");
static_assert(offsetof(UsableComponent_GetInteractionHeader, ReturnValue) == 0x000000, "Member 'UsableComponent_GetInteractionHeader::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UsableComponent.GetValidPrimitiveComponentNames
// 0x0010 (0x0010 - 0x0000)
struct UsableComponent_GetValidPrimitiveComponentNames final
{
public:
	TArray<class FName>                           ComponentNames;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UsableComponent_GetValidPrimitiveComponentNames) == 0x000008, "Wrong alignment on UsableComponent_GetValidPrimitiveComponentNames");
static_assert(sizeof(UsableComponent_GetValidPrimitiveComponentNames) == 0x000010, "Wrong size on UsableComponent_GetValidPrimitiveComponentNames");
static_assert(offsetof(UsableComponent_GetValidPrimitiveComponentNames, ComponentNames) == 0x000000, "Member 'UsableComponent_GetValidPrimitiveComponentNames::ComponentNames' has a wrong offset!");

// Function GbxGameSystemCore.UsableComponent.K2_CanBeUsed
// 0x0020 (0x0020 - 0x0000)
struct UsableComponent_K2_CanBeUsed final
{
public:
	struct FUsabilityQuery                        Query;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UsableComponent_K2_CanBeUsed) == 0x000008, "Wrong alignment on UsableComponent_K2_CanBeUsed");
static_assert(sizeof(UsableComponent_K2_CanBeUsed) == 0x000020, "Wrong size on UsableComponent_K2_CanBeUsed");
static_assert(offsetof(UsableComponent_K2_CanBeUsed, Query) == 0x000000, "Member 'UsableComponent_K2_CanBeUsed::Query' has a wrong offset!");
static_assert(offsetof(UsableComponent_K2_CanBeUsed, ReturnValue) == 0x000018, "Member 'UsableComponent_K2_CanBeUsed::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UsableComponent.K2_GetOptionalErrorText
// 0x0018 (0x0018 - 0x0000)
struct UsableComponent_K2_GetOptionalErrorText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UsableComponent_K2_GetOptionalErrorText) == 0x000008, "Wrong alignment on UsableComponent_K2_GetOptionalErrorText");
static_assert(sizeof(UsableComponent_K2_GetOptionalErrorText) == 0x000018, "Wrong size on UsableComponent_K2_GetOptionalErrorText");
static_assert(offsetof(UsableComponent_K2_GetOptionalErrorText, ReturnValue) == 0x000000, "Member 'UsableComponent_K2_GetOptionalErrorText::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AttributeValueResolver.GetValueForAttribute
// 0x0018 (0x0018 - 0x0000)
struct AttributeValueResolver_GetValueForAttribute final
{
public:
	const class UGbxAttributeData*                Attribute;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          Context;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeValueResolver_GetValueForAttribute) == 0x000008, "Wrong alignment on AttributeValueResolver_GetValueForAttribute");
static_assert(sizeof(AttributeValueResolver_GetValueForAttribute) == 0x000018, "Wrong size on AttributeValueResolver_GetValueForAttribute");
static_assert(offsetof(AttributeValueResolver_GetValueForAttribute, Attribute) == 0x000000, "Member 'AttributeValueResolver_GetValueForAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(AttributeValueResolver_GetValueForAttribute, Context) == 0x000008, "Member 'AttributeValueResolver_GetValueForAttribute::Context' has a wrong offset!");
static_assert(offsetof(AttributeValueResolver_GetValueForAttribute, ReturnValue) == 0x000010, "Member 'AttributeValueResolver_GetValueForAttribute::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AttributeValueResolver.SetValueForAttribute
// 0x0018 (0x0018 - 0x0000)
struct AttributeValueResolver_SetValueForAttribute final
{
public:
	const class UGbxAttributeData*                Attribute;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          Context;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeValueResolver_SetValueForAttribute) == 0x000008, "Wrong alignment on AttributeValueResolver_SetValueForAttribute");
static_assert(sizeof(AttributeValueResolver_SetValueForAttribute) == 0x000018, "Wrong size on AttributeValueResolver_SetValueForAttribute");
static_assert(offsetof(AttributeValueResolver_SetValueForAttribute, Attribute) == 0x000000, "Member 'AttributeValueResolver_SetValueForAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(AttributeValueResolver_SetValueForAttribute, Context) == 0x000008, "Member 'AttributeValueResolver_SetValueForAttribute::Context' has a wrong offset!");
static_assert(offsetof(AttributeValueResolver_SetValueForAttribute, Value) == 0x000010, "Member 'AttributeValueResolver_SetValueForAttribute::Value' has a wrong offset!");
static_assert(offsetof(AttributeValueResolver_SetValueForAttribute, ReturnValue) == 0x000014, "Member 'AttributeValueResolver_SetValueForAttribute::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.OnAnimEnd
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_SimpleAnim_OnAnimEnd final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_OnAnimEnd) == 0x000008, "Wrong alignment on GbxAction_SimpleAnim_OnAnimEnd");
static_assert(sizeof(GbxAction_SimpleAnim_OnAnimEnd) == 0x000008, "Wrong size on GbxAction_SimpleAnim_OnAnimEnd");
static_assert(offsetof(GbxAction_SimpleAnim_OnAnimEnd, Actor) == 0x000000, "Member 'GbxAction_SimpleAnim_OnAnimEnd::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAimRotation
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetAimRotation final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetAimRotation) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetAimRotation");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetAimRotation) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetAimRotation");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetAimRotation, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetAimRotation::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAIThinking
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetAIThinking final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetAIThinking) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetAIThinking");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetAIThinking) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetAIThinking");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetAIThinking, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetAIThinking::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAvoidance
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetAvoidance final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetAvoidance) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetAvoidance");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetAvoidance) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetAvoidance");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetAvoidance, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetAvoidance::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetCollision
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetCollision final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetCollision) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetCollision");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetCollision) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetCollision");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetCollision, bEnable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetCollision::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHeadLook
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetHeadLook final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetHeadLook) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetHeadLook");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetHeadLook) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetHeadLook");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetHeadLook, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetHeadLook::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHeadLookLocked
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetHeadLookLocked final
{
public:
	bool                                          bLock;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetHeadLookLocked) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetHeadLookLocked");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetHeadLookLocked) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetHeadLookLocked");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetHeadLookLocked, bLock) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetHeadLookLocked::bLock' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHitReactions
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetHitReactions final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetHitReactions) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetHitReactions");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetHitReactions) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetHitReactions");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetHitReactions, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetHitReactions::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetLook
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetLook final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetLook) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetLook");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetLook) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetLook");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetLook, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetLook::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetMovement
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetMovement final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetMovement) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetMovement");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetMovement) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetMovement");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetMovement, bDisable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetMovement::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetPhysNoneWithRootMotion
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion, bEnable) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetTickAndRefreshBones
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_SimpleAnim_K2_SetTickAndRefreshBones final
{
public:
	bool                                          bLockResource;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_SimpleAnim_K2_SetTickAndRefreshBones) == 0x000001, "Wrong alignment on GbxAction_SimpleAnim_K2_SetTickAndRefreshBones");
static_assert(sizeof(GbxAction_SimpleAnim_K2_SetTickAndRefreshBones) == 0x000001, "Wrong size on GbxAction_SimpleAnim_K2_SetTickAndRefreshBones");
static_assert(offsetof(GbxAction_SimpleAnim_K2_SetTickAndRefreshBones, bLockResource) == 0x000000, "Member 'GbxAction_SimpleAnim_K2_SetTickAndRefreshBones::bLockResource' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnHitTargetable
// 0x0018 (0x0018 - 0x0000)
struct ControlledMove_OnHitTargetable final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ControlledMove_OnHitTargetable) == 0x000008, "Wrong alignment on ControlledMove_OnHitTargetable");
static_assert(sizeof(ControlledMove_OnHitTargetable) == 0x000018, "Wrong size on ControlledMove_OnHitTargetable");
static_assert(offsetof(ControlledMove_OnHitTargetable, HitActor) == 0x000000, "Member 'ControlledMove_OnHitTargetable::HitActor' has a wrong offset!");
static_assert(offsetof(ControlledMove_OnHitTargetable, HitNormal) == 0x000008, "Member 'ControlledMove_OnHitTargetable::HitNormal' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnHitWorld
// 0x0018 (0x0018 - 0x0000)
struct ControlledMove_OnHitWorld final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ControlledMove_OnHitWorld) == 0x000008, "Wrong alignment on ControlledMove_OnHitWorld");
static_assert(sizeof(ControlledMove_OnHitWorld) == 0x000018, "Wrong size on ControlledMove_OnHitWorld");
static_assert(offsetof(ControlledMove_OnHitWorld, HitActor) == 0x000000, "Member 'ControlledMove_OnHitWorld::HitActor' has a wrong offset!");
static_assert(offsetof(ControlledMove_OnHitWorld, HitNormal) == 0x000008, "Member 'ControlledMove_OnHitWorld::HitNormal' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnServerStart
// 0x0018 (0x0018 - 0x0000)
struct ControlledMove_OnServerStart final
{
public:
	float                                         MoveDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControlledMove_OnServerStart) == 0x000008, "Wrong alignment on ControlledMove_OnServerStart");
static_assert(sizeof(ControlledMove_OnServerStart) == 0x000018, "Wrong size on ControlledMove_OnServerStart");
static_assert(offsetof(ControlledMove_OnServerStart, MoveDuration) == 0x000000, "Member 'ControlledMove_OnServerStart::MoveDuration' has a wrong offset!");
static_assert(offsetof(ControlledMove_OnServerStart, TargetActor) == 0x000008, "Member 'ControlledMove_OnServerStart::TargetActor' has a wrong offset!");
static_assert(offsetof(ControlledMove_OnServerStart, Instigator) == 0x000010, "Member 'ControlledMove_OnServerStart::Instigator' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnServerStop
// 0x0001 (0x0001 - 0x0000)
struct ControlledMove_OnServerStop final
{
public:
	bool                                          bInterrupted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControlledMove_OnServerStop) == 0x000001, "Wrong alignment on ControlledMove_OnServerStop");
static_assert(sizeof(ControlledMove_OnServerStop) == 0x000001, "Wrong size on ControlledMove_OnServerStop");
static_assert(offsetof(ControlledMove_OnServerStop, bInterrupted) == 0x000000, "Member 'ControlledMove_OnServerStop::bInterrupted' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnStart
// 0x0010 (0x0010 - 0x0000)
struct ControlledMove_OnStart final
{
public:
	float                                         MoveDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControlledMove_OnStart) == 0x000008, "Wrong alignment on ControlledMove_OnStart");
static_assert(sizeof(ControlledMove_OnStart) == 0x000010, "Wrong size on ControlledMove_OnStart");
static_assert(offsetof(ControlledMove_OnStart, MoveDuration) == 0x000000, "Member 'ControlledMove_OnStart::MoveDuration' has a wrong offset!");
static_assert(offsetof(ControlledMove_OnStart, TargetActor) == 0x000008, "Member 'ControlledMove_OnStart::TargetActor' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnStop
// 0x0001 (0x0001 - 0x0000)
struct ControlledMove_OnStop final
{
public:
	bool                                          bInterrupted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControlledMove_OnStop) == 0x000001, "Wrong alignment on ControlledMove_OnStop");
static_assert(sizeof(ControlledMove_OnStop) == 0x000001, "Wrong size on ControlledMove_OnStop");
static_assert(offsetof(ControlledMove_OnStop, bInterrupted) == 0x000000, "Member 'ControlledMove_OnStop::bInterrupted' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnTargetLocationChanged
// 0x000C (0x000C - 0x0000)
struct ControlledMove_OnTargetLocationChanged final
{
public:
	struct FVector                                NewTargetLocation;                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControlledMove_OnTargetLocationChanged) == 0x000004, "Wrong alignment on ControlledMove_OnTargetLocationChanged");
static_assert(sizeof(ControlledMove_OnTargetLocationChanged) == 0x00000C, "Wrong size on ControlledMove_OnTargetLocationChanged");
static_assert(offsetof(ControlledMove_OnTargetLocationChanged, NewTargetLocation) == 0x000000, "Member 'ControlledMove_OnTargetLocationChanged::NewTargetLocation' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMove.OnTeleported
// 0x0010 (0x0010 - 0x0000)
struct ControlledMove_OnTeleported final
{
public:
	float                                         MoveDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreTeleportLocation;                               // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControlledMove_OnTeleported) == 0x000004, "Wrong alignment on ControlledMove_OnTeleported");
static_assert(sizeof(ControlledMove_OnTeleported) == 0x000010, "Wrong size on ControlledMove_OnTeleported");
static_assert(offsetof(ControlledMove_OnTeleported, MoveDuration) == 0x000000, "Member 'ControlledMove_OnTeleported::MoveDuration' has a wrong offset!");
static_assert(offsetof(ControlledMove_OnTeleported, PreTeleportLocation) == 0x000004, "Member 'ControlledMove_OnTeleported::PreTeleportLocation' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_CoordinatedEffect.SetConstantMaterialVectorParamValue
// 0x0018 (0x0018 - 0x0000)
struct GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue) == 0x000004, "Wrong alignment on GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue");
static_assert(sizeof(GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue) == 0x000018, "Wrong size on GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue");
static_assert(offsetof(GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue, ParamName) == 0x000000, "Member 'GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue::ParamName' has a wrong offset!");
static_assert(offsetof(GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue, Color) == 0x000008, "Member 'GbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue::Color' has a wrong offset!");

// Function GbxGameSystemCore.UIStatData.ComputeAttributeModification
// 0x05A8 (0x05A8 - 0x0000)
struct UIStatData_ComputeAttributeModification final
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScale;                                            // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIStatCollector                       Collector;                                         // 0x0010(0x0590)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x05A0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIStatData_ComputeAttributeModification) == 0x000008, "Wrong alignment on UIStatData_ComputeAttributeModification");
static_assert(sizeof(UIStatData_ComputeAttributeModification) == 0x0005A8, "Wrong size on UIStatData_ComputeAttributeModification");
static_assert(offsetof(UIStatData_ComputeAttributeModification, Attribute) == 0x000000, "Member 'UIStatData_ComputeAttributeModification::Attribute' has a wrong offset!");
static_assert(offsetof(UIStatData_ComputeAttributeModification, bScale) == 0x000008, "Member 'UIStatData_ComputeAttributeModification::bScale' has a wrong offset!");
static_assert(offsetof(UIStatData_ComputeAttributeModification, Collector) == 0x000010, "Member 'UIStatData_ComputeAttributeModification::Collector' has a wrong offset!");
static_assert(offsetof(UIStatData_ComputeAttributeModification, ReturnValue) == 0x0005A0, "Member 'UIStatData_ComputeAttributeModification::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UIStatData.EnumerateSectionNames
// 0x0010 (0x0010 - 0x0000)
struct UIStatData_EnumerateSectionNames final
{
public:
	TArray<class FName>                           OutSectionNameList;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIStatData_EnumerateSectionNames) == 0x000008, "Wrong alignment on UIStatData_EnumerateSectionNames");
static_assert(sizeof(UIStatData_EnumerateSectionNames) == 0x000010, "Wrong size on UIStatData_EnumerateSectionNames");
static_assert(offsetof(UIStatData_EnumerateSectionNames, OutSectionNameList) == 0x000000, "Member 'UIStatData_EnumerateSectionNames::OutSectionNameList' has a wrong offset!");

// Function GbxGameSystemCore.UIStatData.K2_GetComparisonValue
// 0x05A0 (0x05A0 - 0x0000)
struct UIStatData_K2_GetComparisonValue final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUIStatCollector                       Collector;                                         // 0x0008(0x0590)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0598(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIStatData_K2_GetComparisonValue) == 0x000008, "Wrong alignment on UIStatData_K2_GetComparisonValue");
static_assert(sizeof(UIStatData_K2_GetComparisonValue) == 0x0005A0, "Wrong size on UIStatData_K2_GetComparisonValue");
static_assert(offsetof(UIStatData_K2_GetComparisonValue, Context) == 0x000000, "Member 'UIStatData_K2_GetComparisonValue::Context' has a wrong offset!");
static_assert(offsetof(UIStatData_K2_GetComparisonValue, Collector) == 0x000008, "Member 'UIStatData_K2_GetComparisonValue::Collector' has a wrong offset!");
static_assert(offsetof(UIStatData_K2_GetComparisonValue, ReturnValue) == 0x000598, "Member 'UIStatData_K2_GetComparisonValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UIStatData.K2_GetValueText
// 0x05B0 (0x05B0 - 0x0000)
struct UIStatData_K2_GetValueText final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUIStatCollector                       Collector;                                         // 0x0008(0x0590)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0598(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UIStatData_K2_GetValueText) == 0x000008, "Wrong alignment on UIStatData_K2_GetValueText");
static_assert(sizeof(UIStatData_K2_GetValueText) == 0x0005B0, "Wrong size on UIStatData_K2_GetValueText");
static_assert(offsetof(UIStatData_K2_GetValueText, Context) == 0x000000, "Member 'UIStatData_K2_GetValueText::Context' has a wrong offset!");
static_assert(offsetof(UIStatData_K2_GetValueText, Collector) == 0x000008, "Member 'UIStatData_K2_GetValueText::Collector' has a wrong offset!");
static_assert(offsetof(UIStatData_K2_GetValueText, ReturnValue) == 0x000598, "Member 'UIStatData_K2_GetValueText::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UIStatData.K2_ShouldDisplayStat
// 0x0010 (0x0010 - 0x0000)
struct UIStatData_K2_ShouldDisplayStat final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UIStatData_K2_ShouldDisplayStat) == 0x000008, "Wrong alignment on UIStatData_K2_ShouldDisplayStat");
static_assert(sizeof(UIStatData_K2_ShouldDisplayStat) == 0x000010, "Wrong size on UIStatData_K2_ShouldDisplayStat");
static_assert(offsetof(UIStatData_K2_ShouldDisplayStat, Context) == 0x000000, "Member 'UIStatData_K2_ShouldDisplayStat::Context' has a wrong offset!");
static_assert(offsetof(UIStatData_K2_ShouldDisplayStat, ReturnValue) == 0x000008, "Member 'UIStatData_K2_ShouldDisplayStat::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Anim.K2_SetCrouchBlocked
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_Anim_K2_SetCrouchBlocked final
{
public:
	bool                                          bBlocked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Anim_K2_SetCrouchBlocked) == 0x000001, "Wrong alignment on GbxAction_Anim_K2_SetCrouchBlocked");
static_assert(sizeof(GbxAction_Anim_K2_SetCrouchBlocked) == 0x000001, "Wrong size on GbxAction_Anim_K2_SetCrouchBlocked");
static_assert(offsetof(GbxAction_Anim_K2_SetCrouchBlocked, bBlocked) == 0x000000, "Member 'GbxAction_Anim_K2_SetCrouchBlocked::bBlocked' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Anim.K2_SetDemigodMode
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_Anim_K2_SetDemigodMode final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Anim_K2_SetDemigodMode) == 0x000001, "Wrong alignment on GbxAction_Anim_K2_SetDemigodMode");
static_assert(sizeof(GbxAction_Anim_K2_SetDemigodMode) == 0x000001, "Wrong size on GbxAction_Anim_K2_SetDemigodMode");
static_assert(offsetof(GbxAction_Anim_K2_SetDemigodMode, bEnable) == 0x000000, "Member 'GbxAction_Anim_K2_SetDemigodMode::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Anim.K2_SetFootIK
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_Anim_K2_SetFootIK final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Anim_K2_SetFootIK) == 0x000001, "Wrong alignment on GbxAction_Anim_K2_SetFootIK");
static_assert(sizeof(GbxAction_Anim_K2_SetFootIK) == 0x000001, "Wrong size on GbxAction_Anim_K2_SetFootIK");
static_assert(offsetof(GbxAction_Anim_K2_SetFootIK, bDisable) == 0x000000, "Member 'GbxAction_Anim_K2_SetFootIK::bDisable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Anim.K2_SetGodMode
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_Anim_K2_SetGodMode final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Anim_K2_SetGodMode) == 0x000001, "Wrong alignment on GbxAction_Anim_K2_SetGodMode");
static_assert(sizeof(GbxAction_Anim_K2_SetGodMode) == 0x000001, "Wrong size on GbxAction_Anim_K2_SetGodMode");
static_assert(offsetof(GbxAction_Anim_K2_SetGodMode, bEnable) == 0x000000, "Member 'GbxAction_Anim_K2_SetGodMode::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Anim.K2_SetMantlingBlocked
// 0x0001 (0x0001 - 0x0000)
struct GbxAction_Anim_K2_SetMantlingBlocked final
{
public:
	bool                                          bBlocked;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Anim_K2_SetMantlingBlocked) == 0x000001, "Wrong alignment on GbxAction_Anim_K2_SetMantlingBlocked");
static_assert(sizeof(GbxAction_Anim_K2_SetMantlingBlocked) == 0x000001, "Wrong size on GbxAction_Anim_K2_SetMantlingBlocked");
static_assert(offsetof(GbxAction_Anim_K2_SetMantlingBlocked, bBlocked) == 0x000000, "Member 'GbxAction_Anim_K2_SetMantlingBlocked::bBlocked' has a wrong offset!");

// Function GbxGameSystemCore.PreviewComponent.OnBlueprintCompiled
// 0x0008 (0x0008 - 0x0000)
struct PreviewComponent_OnBlueprintCompiled final
{
public:
	class UBlueprint*                             BP;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PreviewComponent_OnBlueprintCompiled) == 0x000008, "Wrong alignment on PreviewComponent_OnBlueprintCompiled");
static_assert(sizeof(PreviewComponent_OnBlueprintCompiled) == 0x000008, "Wrong size on PreviewComponent_OnBlueprintCompiled");
static_assert(offsetof(PreviewComponent_OnBlueprintCompiled, BP) == 0x000000, "Member 'PreviewComponent_OnBlueprintCompiled::BP' has a wrong offset!");

// Function GbxGameSystemCore.RadiusDamageReplicationManager.Multicast_ProcessRadiusRequest
// 0x0060 (0x0060 - 0x0000)
struct RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest final
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x001C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UExplosionData*                         ExplosionData;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DefaultParticles;                                  // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            DefaultAudioEvent;                                 // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            DefaultImpactData;                                 // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxSignificanceEvent                  SignificanceEvent;                                 // 0x0050(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest) == 0x000008, "Wrong alignment on RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest");
static_assert(sizeof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest) == 0x000060, "Wrong size on RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, ContextActor) == 0x000000, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::ContextActor' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, DamageData) == 0x000008, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::DamageData' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, DamageType) == 0x000010, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::DamageType' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, Radius) == 0x000018, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::Radius' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, Location) == 0x00001C, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::Location' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, Damage) == 0x000028, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::Damage' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, ExplosionData) == 0x000030, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::ExplosionData' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, DefaultParticles) == 0x000038, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::DefaultParticles' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, DefaultAudioEvent) == 0x000040, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::DefaultAudioEvent' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, DefaultImpactData) == 0x000048, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::DefaultImpactData' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, SignificanceEvent) == 0x000050, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::SignificanceEvent' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest, Force) == 0x000058, "Member 'RadiusDamageReplicationManager_Multicast_ProcessRadiusRequest::Force' has a wrong offset!");

// Function GbxGameSystemCore.RadiusDamageReplicationManager.Multicast_StopRadiusEffect
// 0x0018 (0x0018 - 0x0000)
struct RadiusDamageReplicationManager_Multicast_StopRadiusEffect final
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAllForContext;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RadiusDamageReplicationManager_Multicast_StopRadiusEffect) == 0x000008, "Wrong alignment on RadiusDamageReplicationManager_Multicast_StopRadiusEffect");
static_assert(sizeof(RadiusDamageReplicationManager_Multicast_StopRadiusEffect) == 0x000018, "Wrong size on RadiusDamageReplicationManager_Multicast_StopRadiusEffect");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_StopRadiusEffect, ContextActor) == 0x000000, "Member 'RadiusDamageReplicationManager_Multicast_StopRadiusEffect::ContextActor' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_StopRadiusEffect, DamageData) == 0x000008, "Member 'RadiusDamageReplicationManager_Multicast_StopRadiusEffect::DamageData' has a wrong offset!");
static_assert(offsetof(RadiusDamageReplicationManager_Multicast_StopRadiusEffect, bStopAllForContext) == 0x000010, "Member 'RadiusDamageReplicationManager_Multicast_StopRadiusEffect::bStopAllForContext' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.InitializeTeam
// 0x0008 (0x0008 - 0x0000)
struct TeamComponent_InitializeTeam final
{
public:
	class UTeam*                                  NewTeam;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_InitializeTeam) == 0x000008, "Wrong alignment on TeamComponent_InitializeTeam");
static_assert(sizeof(TeamComponent_InitializeTeam) == 0x000008, "Wrong size on TeamComponent_InitializeTeam");
static_assert(offsetof(TeamComponent_InitializeTeam, NewTeam) == 0x000000, "Member 'TeamComponent_InitializeTeam::NewTeam' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.OnRep_Team
// 0x0008 (0x0008 - 0x0000)
struct TeamComponent_OnRep_Team final
{
public:
	class UTeam*                                  OldTeam;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_OnRep_Team) == 0x000008, "Wrong alignment on TeamComponent_OnRep_Team");
static_assert(sizeof(TeamComponent_OnRep_Team) == 0x000008, "Wrong size on TeamComponent_OnRep_Team");
static_assert(offsetof(TeamComponent_OnRep_Team, OldTeam) == 0x000000, "Member 'TeamComponent_OnRep_Team::OldTeam' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.SetCollidesWithTeam
// 0x0001 (0x0001 - 0x0000)
struct TeamComponent_SetCollidesWithTeam final
{
public:
	bool                                          bCollidesWithTeam;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_SetCollidesWithTeam) == 0x000001, "Wrong alignment on TeamComponent_SetCollidesWithTeam");
static_assert(sizeof(TeamComponent_SetCollidesWithTeam) == 0x000001, "Wrong size on TeamComponent_SetCollidesWithTeam");
static_assert(offsetof(TeamComponent_SetCollidesWithTeam, bCollidesWithTeam) == 0x000000, "Member 'TeamComponent_SetCollidesWithTeam::bCollidesWithTeam' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.SetSourceTeamComponent
// 0x0008 (0x0008 - 0x0000)
struct TeamComponent_SetSourceTeamComponent final
{
public:
	class UTeamComponent*                         NewSourceTeamComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_SetSourceTeamComponent) == 0x000008, "Wrong alignment on TeamComponent_SetSourceTeamComponent");
static_assert(sizeof(TeamComponent_SetSourceTeamComponent) == 0x000008, "Wrong size on TeamComponent_SetSourceTeamComponent");
static_assert(offsetof(TeamComponent_SetSourceTeamComponent, NewSourceTeamComponent) == 0x000000, "Member 'TeamComponent_SetSourceTeamComponent::NewSourceTeamComponent' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.SetTeam
// 0x0008 (0x0008 - 0x0000)
struct TeamComponent_SetTeam final
{
public:
	class UTeam*                                  NewTeam;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_SetTeam) == 0x000008, "Wrong alignment on TeamComponent_SetTeam");
static_assert(sizeof(TeamComponent_SetTeam) == 0x000008, "Wrong size on TeamComponent_SetTeam");
static_assert(offsetof(TeamComponent_SetTeam, NewTeam) == 0x000000, "Member 'TeamComponent_SetTeam::NewTeam' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.SetTeamCollision
// 0x0001 (0x0001 - 0x0000)
struct TeamComponent_SetTeamCollision final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_SetTeamCollision) == 0x000001, "Wrong alignment on TeamComponent_SetTeamCollision");
static_assert(sizeof(TeamComponent_SetTeamCollision) == 0x000001, "Wrong size on TeamComponent_SetTeamCollision");
static_assert(offsetof(TeamComponent_SetTeamCollision, bOn) == 0x000000, "Member 'TeamComponent_SetTeamCollision::bOn' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.GetTeamAttitudeTowardsActor
// 0x0010 (0x0010 - 0x0000)
struct TeamComponent_GetTeamAttitudeTowardsActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TeamComponent_GetTeamAttitudeTowardsActor) == 0x000008, "Wrong alignment on TeamComponent_GetTeamAttitudeTowardsActor");
static_assert(sizeof(TeamComponent_GetTeamAttitudeTowardsActor) == 0x000010, "Wrong size on TeamComponent_GetTeamAttitudeTowardsActor");
static_assert(offsetof(TeamComponent_GetTeamAttitudeTowardsActor, Actor) == 0x000000, "Member 'TeamComponent_GetTeamAttitudeTowardsActor::Actor' has a wrong offset!");
static_assert(offsetof(TeamComponent_GetTeamAttitudeTowardsActor, ReturnValue) == 0x000008, "Member 'TeamComponent_GetTeamAttitudeTowardsActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.GetTeamAttitudeTowardsTeam
// 0x0010 (0x0010 - 0x0000)
struct TeamComponent_GetTeamAttitudeTowardsTeam final
{
public:
	const class UTeam*                            OtherTeam;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TeamComponent_GetTeamAttitudeTowardsTeam) == 0x000008, "Wrong alignment on TeamComponent_GetTeamAttitudeTowardsTeam");
static_assert(sizeof(TeamComponent_GetTeamAttitudeTowardsTeam) == 0x000010, "Wrong size on TeamComponent_GetTeamAttitudeTowardsTeam");
static_assert(offsetof(TeamComponent_GetTeamAttitudeTowardsTeam, OtherTeam) == 0x000000, "Member 'TeamComponent_GetTeamAttitudeTowardsTeam::OtherTeam' has a wrong offset!");
static_assert(offsetof(TeamComponent_GetTeamAttitudeTowardsTeam, ReturnValue) == 0x000008, "Member 'TeamComponent_GetTeamAttitudeTowardsTeam::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.GetTeamCollisionChannel
// 0x0001 (0x0001 - 0x0000)
struct TeamComponent_GetTeamCollisionChannel final
{
public:
	ETeamCollisionChannel                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamComponent_GetTeamCollisionChannel) == 0x000001, "Wrong alignment on TeamComponent_GetTeamCollisionChannel");
static_assert(sizeof(TeamComponent_GetTeamCollisionChannel) == 0x000001, "Wrong size on TeamComponent_GetTeamCollisionChannel");
static_assert(offsetof(TeamComponent_GetTeamCollisionChannel, ReturnValue) == 0x000000, "Member 'TeamComponent_GetTeamCollisionChannel::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.IsFriendly
// 0x0010 (0x0010 - 0x0000)
struct TeamComponent_IsFriendly final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TeamComponent_IsFriendly) == 0x000008, "Wrong alignment on TeamComponent_IsFriendly");
static_assert(sizeof(TeamComponent_IsFriendly) == 0x000010, "Wrong size on TeamComponent_IsFriendly");
static_assert(offsetof(TeamComponent_IsFriendly, Actor) == 0x000000, "Member 'TeamComponent_IsFriendly::Actor' has a wrong offset!");
static_assert(offsetof(TeamComponent_IsFriendly, ReturnValue) == 0x000008, "Member 'TeamComponent_IsFriendly::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.IsHostile
// 0x0010 (0x0010 - 0x0000)
struct TeamComponent_IsHostile final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TeamComponent_IsHostile) == 0x000008, "Wrong alignment on TeamComponent_IsHostile");
static_assert(sizeof(TeamComponent_IsHostile) == 0x000010, "Wrong size on TeamComponent_IsHostile");
static_assert(offsetof(TeamComponent_IsHostile, Actor) == 0x000000, "Member 'TeamComponent_IsHostile::Actor' has a wrong offset!");
static_assert(offsetof(TeamComponent_IsHostile, ReturnValue) == 0x000008, "Member 'TeamComponent_IsHostile::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TeamComponent.IsNeutral
// 0x0010 (0x0010 - 0x0000)
struct TeamComponent_IsNeutral final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TeamComponent_IsNeutral) == 0x000008, "Wrong alignment on TeamComponent_IsNeutral");
static_assert(sizeof(TeamComponent_IsNeutral) == 0x000010, "Wrong size on TeamComponent_IsNeutral");
static_assert(offsetof(TeamComponent_IsNeutral, Actor) == 0x000000, "Member 'TeamComponent_IsNeutral::Actor' has a wrong offset!");
static_assert(offsetof(TeamComponent_IsNeutral, ReturnValue) == 0x000008, "Member 'TeamComponent_IsNeutral::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.AttachCharacterToActor
// 0x0018 (0x0018 - 0x0000)
struct GbxCharacter_AttachCharacterToActor final
{
public:
	class AActor*                                 ParentActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0013(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacter_AttachCharacterToActor) == 0x000008, "Wrong alignment on GbxCharacter_AttachCharacterToActor");
static_assert(sizeof(GbxCharacter_AttachCharacterToActor) == 0x000018, "Wrong size on GbxCharacter_AttachCharacterToActor");
static_assert(offsetof(GbxCharacter_AttachCharacterToActor, ParentActor) == 0x000000, "Member 'GbxCharacter_AttachCharacterToActor::ParentActor' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToActor, SocketName) == 0x000008, "Member 'GbxCharacter_AttachCharacterToActor::SocketName' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToActor, LocationRule) == 0x000010, "Member 'GbxCharacter_AttachCharacterToActor::LocationRule' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToActor, RotationRule) == 0x000011, "Member 'GbxCharacter_AttachCharacterToActor::RotationRule' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToActor, ScaleRule) == 0x000012, "Member 'GbxCharacter_AttachCharacterToActor::ScaleRule' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToActor, bWeldSimulatedBodies) == 0x000013, "Member 'GbxCharacter_AttachCharacterToActor::bWeldSimulatedBodies' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.AttachCharacterToComponent
// 0x0018 (0x0018 - 0x0000)
struct GbxCharacter_AttachCharacterToComponent final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0013(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacter_AttachCharacterToComponent) == 0x000008, "Wrong alignment on GbxCharacter_AttachCharacterToComponent");
static_assert(sizeof(GbxCharacter_AttachCharacterToComponent) == 0x000018, "Wrong size on GbxCharacter_AttachCharacterToComponent");
static_assert(offsetof(GbxCharacter_AttachCharacterToComponent, Parent) == 0x000000, "Member 'GbxCharacter_AttachCharacterToComponent::Parent' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToComponent, SocketName) == 0x000008, "Member 'GbxCharacter_AttachCharacterToComponent::SocketName' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToComponent, LocationRule) == 0x000010, "Member 'GbxCharacter_AttachCharacterToComponent::LocationRule' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToComponent, RotationRule) == 0x000011, "Member 'GbxCharacter_AttachCharacterToComponent::RotationRule' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToComponent, ScaleRule) == 0x000012, "Member 'GbxCharacter_AttachCharacterToComponent::ScaleRule' has a wrong offset!");
static_assert(offsetof(GbxCharacter_AttachCharacterToComponent, bWeldSimulatedBodies) == 0x000013, "Member 'GbxCharacter_AttachCharacterToComponent::bWeldSimulatedBodies' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.ClientRotateCharacterTo
// 0x0014 (0x0014 - 0x0000)
struct GbxCharacter_ClientRotateCharacterTo final
{
public:
	struct FRotator                               TargetRotation;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   Easing;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacter_ClientRotateCharacterTo) == 0x000004, "Wrong alignment on GbxCharacter_ClientRotateCharacterTo");
static_assert(sizeof(GbxCharacter_ClientRotateCharacterTo) == 0x000014, "Wrong size on GbxCharacter_ClientRotateCharacterTo");
static_assert(offsetof(GbxCharacter_ClientRotateCharacterTo, TargetRotation) == 0x000000, "Member 'GbxCharacter_ClientRotateCharacterTo::TargetRotation' has a wrong offset!");
static_assert(offsetof(GbxCharacter_ClientRotateCharacterTo, Duration) == 0x00000C, "Member 'GbxCharacter_ClientRotateCharacterTo::Duration' has a wrong offset!");
static_assert(offsetof(GbxCharacter_ClientRotateCharacterTo, Easing) == 0x000010, "Member 'GbxCharacter_ClientRotateCharacterTo::Easing' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.DetachCharacter
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacter_DetachCharacter final
{
public:
	EDetachmentRule                               LocationRule;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_DetachCharacter) == 0x000001, "Wrong alignment on GbxCharacter_DetachCharacter");
static_assert(sizeof(GbxCharacter_DetachCharacter) == 0x000001, "Wrong size on GbxCharacter_DetachCharacter");
static_assert(offsetof(GbxCharacter_DetachCharacter, LocationRule) == 0x000000, "Member 'GbxCharacter_DetachCharacter::LocationRule' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.NetMulticast_PlayLanded
// 0x00A0 (0x00A0 - 0x0000)
struct GbxCharacter_NetMulticast_PlayLanded final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ImpactSpeed;                                       // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandFromJump;                                     // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandingData*                           LandingDataOverride;                               // 0x0098(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_NetMulticast_PlayLanded) == 0x000008, "Wrong alignment on GbxCharacter_NetMulticast_PlayLanded");
static_assert(sizeof(GbxCharacter_NetMulticast_PlayLanded) == 0x0000A0, "Wrong size on GbxCharacter_NetMulticast_PlayLanded");
static_assert(offsetof(GbxCharacter_NetMulticast_PlayLanded, Hit) == 0x000000, "Member 'GbxCharacter_NetMulticast_PlayLanded::Hit' has a wrong offset!");
static_assert(offsetof(GbxCharacter_NetMulticast_PlayLanded, ImpactSpeed) == 0x000090, "Member 'GbxCharacter_NetMulticast_PlayLanded::ImpactSpeed' has a wrong offset!");
static_assert(offsetof(GbxCharacter_NetMulticast_PlayLanded, bLandFromJump) == 0x000094, "Member 'GbxCharacter_NetMulticast_PlayLanded::bLandFromJump' has a wrong offset!");
static_assert(offsetof(GbxCharacter_NetMulticast_PlayLanded, LandingDataOverride) == 0x000098, "Member 'GbxCharacter_NetMulticast_PlayLanded::LandingDataOverride' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.NetMulticast_TriggerHitReactionSound
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_NetMulticast_TriggerHitReactionSound final
{
public:
	const class UCharacterSoundTag*               Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_NetMulticast_TriggerHitReactionSound) == 0x000008, "Wrong alignment on GbxCharacter_NetMulticast_TriggerHitReactionSound");
static_assert(sizeof(GbxCharacter_NetMulticast_TriggerHitReactionSound) == 0x000008, "Wrong size on GbxCharacter_NetMulticast_TriggerHitReactionSound");
static_assert(offsetof(GbxCharacter_NetMulticast_TriggerHitReactionSound, Tag) == 0x000000, "Member 'GbxCharacter_NetMulticast_TriggerHitReactionSound::Tag' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.OnLandingDataTriggered
// 0x0030 (0x0030 - 0x0000)
struct GbxCharacter_OnLandingDataTriggered final
{
public:
	struct FLandingInfo                           LandingInfo;                                       // 0x0000(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacter_OnLandingDataTriggered) == 0x000008, "Wrong alignment on GbxCharacter_OnLandingDataTriggered");
static_assert(sizeof(GbxCharacter_OnLandingDataTriggered) == 0x000030, "Wrong size on GbxCharacter_OnLandingDataTriggered");
static_assert(offsetof(GbxCharacter_OnLandingDataTriggered, LandingInfo) == 0x000000, "Member 'GbxCharacter_OnLandingDataTriggered::LandingInfo' has a wrong offset!");
static_assert(offsetof(GbxCharacter_OnLandingDataTriggered, Index_0) == 0x000028, "Member 'GbxCharacter_OnLandingDataTriggered::Index_0' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.ReceiveOwnerPlayerControllerChanged
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_ReceiveOwnerPlayerControllerChanged final
{
public:
	class AGbxPlayerController*                   NewPlayerControllerOwner;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_ReceiveOwnerPlayerControllerChanged) == 0x000008, "Wrong alignment on GbxCharacter_ReceiveOwnerPlayerControllerChanged");
static_assert(sizeof(GbxCharacter_ReceiveOwnerPlayerControllerChanged) == 0x000008, "Wrong size on GbxCharacter_ReceiveOwnerPlayerControllerChanged");
static_assert(offsetof(GbxCharacter_ReceiveOwnerPlayerControllerChanged, NewPlayerControllerOwner) == 0x000000, "Member 'GbxCharacter_ReceiveOwnerPlayerControllerChanged::NewPlayerControllerOwner' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.RotateCharacterTo
// 0x0014 (0x0014 - 0x0000)
struct GbxCharacter_RotateCharacterTo final
{
public:
	struct FRotator                               TargetRotation;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   Easing;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacter_RotateCharacterTo) == 0x000004, "Wrong alignment on GbxCharacter_RotateCharacterTo");
static_assert(sizeof(GbxCharacter_RotateCharacterTo) == 0x000014, "Wrong size on GbxCharacter_RotateCharacterTo");
static_assert(offsetof(GbxCharacter_RotateCharacterTo, TargetRotation) == 0x000000, "Member 'GbxCharacter_RotateCharacterTo::TargetRotation' has a wrong offset!");
static_assert(offsetof(GbxCharacter_RotateCharacterTo, Duration) == 0x00000C, "Member 'GbxCharacter_RotateCharacterTo::Duration' has a wrong offset!");
static_assert(offsetof(GbxCharacter_RotateCharacterTo, Easing) == 0x000010, "Member 'GbxCharacter_RotateCharacterTo::Easing' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.SetCharacterName
// 0x0018 (0x0018 - 0x0000)
struct GbxCharacter_SetCharacterName final
{
public:
	class FText                                   NewCharacterName;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_SetCharacterName) == 0x000008, "Wrong alignment on GbxCharacter_SetCharacterName");
static_assert(sizeof(GbxCharacter_SetCharacterName) == 0x000018, "Wrong size on GbxCharacter_SetCharacterName");
static_assert(offsetof(GbxCharacter_SetCharacterName, NewCharacterName) == 0x000000, "Member 'GbxCharacter_SetCharacterName::NewCharacterName' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.SetCharacterNameFromString
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacter_SetCharacterNameFromString final
{
public:
	class FString                                 NewCharacterName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_SetCharacterNameFromString) == 0x000008, "Wrong alignment on GbxCharacter_SetCharacterNameFromString");
static_assert(sizeof(GbxCharacter_SetCharacterNameFromString) == 0x000010, "Wrong size on GbxCharacter_SetCharacterNameFromString");
static_assert(offsetof(GbxCharacter_SetCharacterNameFromString, NewCharacterName) == 0x000000, "Member 'GbxCharacter_SetCharacterNameFromString::NewCharacterName' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.SetCharacterUIName
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_SetCharacterUIName final
{
public:
	const class UGbxUIName*                       NewCharacterUIName;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_SetCharacterUIName) == 0x000008, "Wrong alignment on GbxCharacter_SetCharacterUIName");
static_assert(sizeof(GbxCharacter_SetCharacterUIName) == 0x000008, "Wrong size on GbxCharacter_SetCharacterUIName");
static_assert(offsetof(GbxCharacter_SetCharacterUIName, NewCharacterUIName) == 0x000000, "Member 'GbxCharacter_SetCharacterUIName::NewCharacterUIName' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.SetPlayerMaster
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_SetPlayerMaster final
{
public:
	class AGbxCharacter*                          NewPlayerMaster;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_SetPlayerMaster) == 0x000008, "Wrong alignment on GbxCharacter_SetPlayerMaster");
static_assert(sizeof(GbxCharacter_SetPlayerMaster) == 0x000008, "Wrong size on GbxCharacter_SetPlayerMaster");
static_assert(offsetof(GbxCharacter_SetPlayerMaster, NewPlayerMaster) == 0x000000, "Member 'GbxCharacter_SetPlayerMaster::NewPlayerMaster' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.FindFirstPersonComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_FindFirstPersonComponent final
{
public:
	class UFirstPersonComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_FindFirstPersonComponent) == 0x000008, "Wrong alignment on GbxCharacter_FindFirstPersonComponent");
static_assert(sizeof(GbxCharacter_FindFirstPersonComponent) == 0x000008, "Wrong size on GbxCharacter_FindFirstPersonComponent");
static_assert(offsetof(GbxCharacter_FindFirstPersonComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_FindFirstPersonComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetAimOffset
// 0x000C (0x000C - 0x0000)
struct GbxCharacter_GetAimOffset final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetAimOffset) == 0x000004, "Wrong alignment on GbxCharacter_GetAimOffset");
static_assert(sizeof(GbxCharacter_GetAimOffset) == 0x00000C, "Wrong size on GbxCharacter_GetAimOffset");
static_assert(offsetof(GbxCharacter_GetAimOffset, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetAimOffset::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetAimVectorStartLocation
// 0x000C (0x000C - 0x0000)
struct GbxCharacter_GetAimVectorStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetAimVectorStartLocation) == 0x000004, "Wrong alignment on GbxCharacter_GetAimVectorStartLocation");
static_assert(sizeof(GbxCharacter_GetAimVectorStartLocation) == 0x00000C, "Wrong size on GbxCharacter_GetAimVectorStartLocation");
static_assert(offsetof(GbxCharacter_GetAimVectorStartLocation, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetAimVectorStartLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetAvailableSocketNames
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacter_GetAvailableSocketNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetAvailableSocketNames) == 0x000008, "Wrong alignment on GbxCharacter_GetAvailableSocketNames");
static_assert(sizeof(GbxCharacter_GetAvailableSocketNames) == 0x000010, "Wrong size on GbxCharacter_GetAvailableSocketNames");
static_assert(offsetof(GbxCharacter_GetAvailableSocketNames, Array) == 0x000000, "Member 'GbxCharacter_GetAvailableSocketNames::Array' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetBlackboardAsset
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetBlackboardAsset final
{
public:
	class UBlackboardData*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetBlackboardAsset) == 0x000008, "Wrong alignment on GbxCharacter_GetBlackboardAsset");
static_assert(sizeof(GbxCharacter_GetBlackboardAsset) == 0x000008, "Wrong size on GbxCharacter_GetBlackboardAsset");
static_assert(offsetof(GbxCharacter_GetBlackboardAsset, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetBlackboardAsset::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetBlackboardComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetBlackboardComponent final
{
public:
	class UBlackboardComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetBlackboardComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetBlackboardComponent");
static_assert(sizeof(GbxCharacter_GetBlackboardComponent) == 0x000008, "Wrong size on GbxCharacter_GetBlackboardComponent");
static_assert(offsetof(GbxCharacter_GetBlackboardComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetBlackboardComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetFirstPersonComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetFirstPersonComponent final
{
public:
	class UFirstPersonComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetFirstPersonComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetFirstPersonComponent");
static_assert(sizeof(GbxCharacter_GetFirstPersonComponent) == 0x000008, "Wrong size on GbxCharacter_GetFirstPersonComponent");
static_assert(offsetof(GbxCharacter_GetFirstPersonComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetFirstPersonComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetFirstPersonMesh
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetFirstPersonMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetFirstPersonMesh) == 0x000008, "Wrong alignment on GbxCharacter_GetFirstPersonMesh");
static_assert(sizeof(GbxCharacter_GetFirstPersonMesh) == 0x000008, "Wrong size on GbxCharacter_GetFirstPersonMesh");
static_assert(offsetof(GbxCharacter_GetFirstPersonMesh, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetFirstPersonMesh::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetLookAt
// 0x0020 (0x0020 - 0x0000)
struct GbxCharacter_GetLookAt final
{
public:
	struct FVector                                HeadLocation;                                      // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyeLocation;                                       // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadWeight;                                        // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetLookAt) == 0x000004, "Wrong alignment on GbxCharacter_GetLookAt");
static_assert(sizeof(GbxCharacter_GetLookAt) == 0x000020, "Wrong size on GbxCharacter_GetLookAt");
static_assert(offsetof(GbxCharacter_GetLookAt, HeadLocation) == 0x000000, "Member 'GbxCharacter_GetLookAt::HeadLocation' has a wrong offset!");
static_assert(offsetof(GbxCharacter_GetLookAt, EyeLocation) == 0x00000C, "Member 'GbxCharacter_GetLookAt::EyeLocation' has a wrong offset!");
static_assert(offsetof(GbxCharacter_GetLookAt, HeadWeight) == 0x000018, "Member 'GbxCharacter_GetLookAt::HeadWeight' has a wrong offset!");
static_assert(offsetof(GbxCharacter_GetLookAt, ReturnValue) == 0x00001C, "Member 'GbxCharacter_GetLookAt::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetLookAtLocation
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacter_GetLookAtLocation final
{
public:
	float                                         OutWeight;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetLookAtLocation) == 0x000004, "Wrong alignment on GbxCharacter_GetLookAtLocation");
static_assert(sizeof(GbxCharacter_GetLookAtLocation) == 0x000010, "Wrong size on GbxCharacter_GetLookAtLocation");
static_assert(offsetof(GbxCharacter_GetLookAtLocation, OutWeight) == 0x000000, "Member 'GbxCharacter_GetLookAtLocation::OutWeight' has a wrong offset!");
static_assert(offsetof(GbxCharacter_GetLookAtLocation, ReturnValue) == 0x000004, "Member 'GbxCharacter_GetLookAtLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetPawnAttachActor
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetPawnAttachActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetPawnAttachActor) == 0x000008, "Wrong alignment on GbxCharacter_GetPawnAttachActor");
static_assert(sizeof(GbxCharacter_GetPawnAttachActor) == 0x000008, "Wrong size on GbxCharacter_GetPawnAttachActor");
static_assert(offsetof(GbxCharacter_GetPawnAttachActor, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetPawnAttachActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetPawnAttachComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetPawnAttachComponent final
{
public:
	class UPawnAttachSlotComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetPawnAttachComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetPawnAttachComponent");
static_assert(sizeof(GbxCharacter_GetPawnAttachComponent) == 0x000008, "Wrong size on GbxCharacter_GetPawnAttachComponent");
static_assert(offsetof(GbxCharacter_GetPawnAttachComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetPawnAttachComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetPawnAttachStatus
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacter_GetPawnAttachStatus final
{
public:
	EPawnAttachStatus                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetPawnAttachStatus) == 0x000001, "Wrong alignment on GbxCharacter_GetPawnAttachStatus");
static_assert(sizeof(GbxCharacter_GetPawnAttachStatus) == 0x000001, "Wrong size on GbxCharacter_GetPawnAttachStatus");
static_assert(offsetof(GbxCharacter_GetPawnAttachStatus, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetPawnAttachStatus::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetPerceptionComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetPerceptionComponent final
{
public:
	class UGbxPerceptionComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetPerceptionComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetPerceptionComponent");
static_assert(sizeof(GbxCharacter_GetPerceptionComponent) == 0x000008, "Wrong size on GbxCharacter_GetPerceptionComponent");
static_assert(offsetof(GbxCharacter_GetPerceptionComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetPerceptionComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetTargetableComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetTargetableComponent final
{
public:
	class UTargetableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetTargetableComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetTargetableComponent");
static_assert(sizeof(GbxCharacter_GetTargetableComponent) == 0x000008, "Wrong size on GbxCharacter_GetTargetableComponent");
static_assert(offsetof(GbxCharacter_GetTargetableComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetTargetableComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetTargetingComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetTargetingComponent final
{
public:
	class UTargetingComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetTargetingComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetTargetingComponent");
static_assert(sizeof(GbxCharacter_GetTargetingComponent) == 0x000008, "Wrong size on GbxCharacter_GetTargetingComponent");
static_assert(offsetof(GbxCharacter_GetTargetingComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetTargetingComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetTeam
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetTeam final
{
public:
	class UTeam*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetTeam) == 0x000008, "Wrong alignment on GbxCharacter_GetTeam");
static_assert(sizeof(GbxCharacter_GetTeam) == 0x000008, "Wrong size on GbxCharacter_GetTeam");
static_assert(offsetof(GbxCharacter_GetTeam, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetTeam::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.GetTeamComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_GetTeamComponent final
{
public:
	class UTeamComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_GetTeamComponent) == 0x000008, "Wrong alignment on GbxCharacter_GetTeamComponent");
static_assert(sizeof(GbxCharacter_GetTeamComponent) == 0x000008, "Wrong size on GbxCharacter_GetTeamComponent");
static_assert(offsetof(GbxCharacter_GetTeamComponent, ReturnValue) == 0x000000, "Member 'GbxCharacter_GetTeamComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.IsZoomed
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacter_IsZoomed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_IsZoomed) == 0x000001, "Wrong alignment on GbxCharacter_IsZoomed");
static_assert(sizeof(GbxCharacter_IsZoomed) == 0x000001, "Wrong size on GbxCharacter_IsZoomed");
static_assert(offsetof(GbxCharacter_IsZoomed, ReturnValue) == 0x000000, "Member 'GbxCharacter_IsZoomed::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacter.SetTeam
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacter_SetTeam final
{
public:
	class UTeam*                                  Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacter_SetTeam) == 0x000008, "Wrong alignment on GbxCharacter_SetTeam");
static_assert(sizeof(GbxCharacter_SetTeam) == 0x000008, "Wrong size on GbxCharacter_SetTeam");
static_assert(offsetof(GbxCharacter_SetTeam, Team) == 0x000000, "Member 'GbxCharacter_SetTeam::Team' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.OnInheritedBalanceSourceLevelChanged
// 0x0010 (0x0010 - 0x0000)
struct BalanceStateComponent_OnInheritedBalanceSourceLevelChanged final
{
public:
	class UBalanceStateComponent*                 InheritedBalanceStateSource;                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldExperienceLevel;                                // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewExperienceLevel;                                // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_OnInheritedBalanceSourceLevelChanged) == 0x000008, "Wrong alignment on BalanceStateComponent_OnInheritedBalanceSourceLevelChanged");
static_assert(sizeof(BalanceStateComponent_OnInheritedBalanceSourceLevelChanged) == 0x000010, "Wrong size on BalanceStateComponent_OnInheritedBalanceSourceLevelChanged");
static_assert(offsetof(BalanceStateComponent_OnInheritedBalanceSourceLevelChanged, InheritedBalanceStateSource) == 0x000000, "Member 'BalanceStateComponent_OnInheritedBalanceSourceLevelChanged::InheritedBalanceStateSource' has a wrong offset!");
static_assert(offsetof(BalanceStateComponent_OnInheritedBalanceSourceLevelChanged, OldExperienceLevel) == 0x000008, "Member 'BalanceStateComponent_OnInheritedBalanceSourceLevelChanged::OldExperienceLevel' has a wrong offset!");
static_assert(offsetof(BalanceStateComponent_OnInheritedBalanceSourceLevelChanged, NewExperienceLevel) == 0x00000C, "Member 'BalanceStateComponent_OnInheritedBalanceSourceLevelChanged::NewExperienceLevel' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.OnRep_ExperienceLevel
// 0x0004 (0x0004 - 0x0000)
struct BalanceStateComponent_OnRep_ExperienceLevel final
{
public:
	int32                                         OldExperienceLevel;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_OnRep_ExperienceLevel) == 0x000004, "Wrong alignment on BalanceStateComponent_OnRep_ExperienceLevel");
static_assert(sizeof(BalanceStateComponent_OnRep_ExperienceLevel) == 0x000004, "Wrong size on BalanceStateComponent_OnRep_ExperienceLevel");
static_assert(offsetof(BalanceStateComponent_OnRep_ExperienceLevel, OldExperienceLevel) == 0x000000, "Member 'BalanceStateComponent_OnRep_ExperienceLevel::OldExperienceLevel' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.SetExperienceLevel
// 0x0004 (0x0004 - 0x0000)
struct BalanceStateComponent_SetExperienceLevel final
{
public:
	int32                                         NewExperienceLevel;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_SetExperienceLevel) == 0x000004, "Wrong alignment on BalanceStateComponent_SetExperienceLevel");
static_assert(sizeof(BalanceStateComponent_SetExperienceLevel) == 0x000004, "Wrong size on BalanceStateComponent_SetExperienceLevel");
static_assert(offsetof(BalanceStateComponent_SetExperienceLevel, NewExperienceLevel) == 0x000000, "Member 'BalanceStateComponent_SetExperienceLevel::NewExperienceLevel' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.SetGameStage
// 0x0004 (0x0004 - 0x0000)
struct BalanceStateComponent_SetGameStage final
{
public:
	int32                                         NewGameStage;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_SetGameStage) == 0x000004, "Wrong alignment on BalanceStateComponent_SetGameStage");
static_assert(sizeof(BalanceStateComponent_SetGameStage) == 0x000004, "Wrong size on BalanceStateComponent_SetGameStage");
static_assert(offsetof(BalanceStateComponent_SetGameStage, NewGameStage) == 0x000000, "Member 'BalanceStateComponent_SetGameStage::NewGameStage' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.GetBalanceTableRow
// 0x0010 (0x0010 - 0x0000)
struct BalanceStateComponent_GetBalanceTableRow final
{
public:
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_GetBalanceTableRow) == 0x000008, "Wrong alignment on BalanceStateComponent_GetBalanceTableRow");
static_assert(sizeof(BalanceStateComponent_GetBalanceTableRow) == 0x000010, "Wrong size on BalanceStateComponent_GetBalanceTableRow");
static_assert(offsetof(BalanceStateComponent_GetBalanceTableRow, ReturnValue) == 0x000000, "Member 'BalanceStateComponent_GetBalanceTableRow::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.GetExperienceLevel
// 0x0004 (0x0004 - 0x0000)
struct BalanceStateComponent_GetExperienceLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_GetExperienceLevel) == 0x000004, "Wrong alignment on BalanceStateComponent_GetExperienceLevel");
static_assert(sizeof(BalanceStateComponent_GetExperienceLevel) == 0x000004, "Wrong size on BalanceStateComponent_GetExperienceLevel");
static_assert(offsetof(BalanceStateComponent_GetExperienceLevel, ReturnValue) == 0x000000, "Member 'BalanceStateComponent_GetExperienceLevel::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.BalanceStateComponent.GetGameStage
// 0x0004 (0x0004 - 0x0000)
struct BalanceStateComponent_GetGameStage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BalanceStateComponent_GetGameStage) == 0x000004, "Wrong alignment on BalanceStateComponent_GetGameStage");
static_assert(sizeof(BalanceStateComponent_GetGameStage) == 0x000004, "Wrong size on BalanceStateComponent_GetGameStage");
static_assert(offsetof(BalanceStateComponent_GetGameStage, ReturnValue) == 0x000000, "Member 'BalanceStateComponent_GetGameStage::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.CopyFromCustomization
// 0x0008 (0x0008 - 0x0000)
struct GbxCustomizationComponent_CopyFromCustomization final
{
public:
	class UGbxCustomizationComponent*             SourceComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationComponent_CopyFromCustomization) == 0x000008, "Wrong alignment on GbxCustomizationComponent_CopyFromCustomization");
static_assert(sizeof(GbxCustomizationComponent_CopyFromCustomization) == 0x000008, "Wrong size on GbxCustomizationComponent_CopyFromCustomization");
static_assert(offsetof(GbxCustomizationComponent_CopyFromCustomization, SourceComponent) == 0x000000, "Member 'GbxCustomizationComponent_CopyFromCustomization::SourceComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.GetDefaultCustomColor
// 0x0018 (0x0018 - 0x0000)
struct GbxCustomizationComponent_GetDefaultCustomColor final
{
public:
	int32                                         SelectionIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x0004(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationComponent_GetDefaultCustomColor) == 0x000004, "Wrong alignment on GbxCustomizationComponent_GetDefaultCustomColor");
static_assert(sizeof(GbxCustomizationComponent_GetDefaultCustomColor) == 0x000018, "Wrong size on GbxCustomizationComponent_GetDefaultCustomColor");
static_assert(offsetof(GbxCustomizationComponent_GetDefaultCustomColor, SelectionIndex) == 0x000000, "Member 'GbxCustomizationComponent_GetDefaultCustomColor::SelectionIndex' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_GetDefaultCustomColor, DefaultColor) == 0x000004, "Member 'GbxCustomizationComponent_GetDefaultCustomColor::DefaultColor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_GetDefaultCustomColor, ReturnValue) == 0x000014, "Member 'GbxCustomizationComponent_GetDefaultCustomColor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.GetDefaultCustomSplitColor
// 0x0018 (0x0018 - 0x0000)
struct GbxCustomizationComponent_GetDefaultCustomSplitColor final
{
public:
	int32                                         SelectionIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultSplitColor;                                 // 0x0004(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationComponent_GetDefaultCustomSplitColor) == 0x000004, "Wrong alignment on GbxCustomizationComponent_GetDefaultCustomSplitColor");
static_assert(sizeof(GbxCustomizationComponent_GetDefaultCustomSplitColor) == 0x000018, "Wrong size on GbxCustomizationComponent_GetDefaultCustomSplitColor");
static_assert(offsetof(GbxCustomizationComponent_GetDefaultCustomSplitColor, SelectionIndex) == 0x000000, "Member 'GbxCustomizationComponent_GetDefaultCustomSplitColor::SelectionIndex' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_GetDefaultCustomSplitColor, DefaultSplitColor) == 0x000004, "Member 'GbxCustomizationComponent_GetDefaultCustomSplitColor::DefaultSplitColor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_GetDefaultCustomSplitColor, ReturnValue) == 0x000014, "Member 'GbxCustomizationComponent_GetDefaultCustomSplitColor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.LinkedCustomizationApplied
// 0x0008 (0x0008 - 0x0000)
struct GbxCustomizationComponent_LinkedCustomizationApplied final
{
public:
	class UGbxCustomizationData*                  Customization;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationComponent_LinkedCustomizationApplied) == 0x000008, "Wrong alignment on GbxCustomizationComponent_LinkedCustomizationApplied");
static_assert(sizeof(GbxCustomizationComponent_LinkedCustomizationApplied) == 0x000008, "Wrong size on GbxCustomizationComponent_LinkedCustomizationApplied");
static_assert(offsetof(GbxCustomizationComponent_LinkedCustomizationApplied, Customization) == 0x000000, "Member 'GbxCustomizationComponent_LinkedCustomizationApplied::Customization' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.LinkedCustomizationRemoved
// 0x0008 (0x0008 - 0x0000)
struct GbxCustomizationComponent_LinkedCustomizationRemoved final
{
public:
	class UGbxCustomizationData*                  Customization;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationComponent_LinkedCustomizationRemoved) == 0x000008, "Wrong alignment on GbxCustomizationComponent_LinkedCustomizationRemoved");
static_assert(sizeof(GbxCustomizationComponent_LinkedCustomizationRemoved) == 0x000008, "Wrong size on GbxCustomizationComponent_LinkedCustomizationRemoved");
static_assert(offsetof(GbxCustomizationComponent_LinkedCustomizationRemoved, Customization) == 0x000000, "Member 'GbxCustomizationComponent_LinkedCustomizationRemoved::Customization' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.LinkToCustomization
// 0x0008 (0x0008 - 0x0000)
struct GbxCustomizationComponent_LinkToCustomization final
{
public:
	class UGbxCustomizationComponent*             SourceComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationComponent_LinkToCustomization) == 0x000008, "Wrong alignment on GbxCustomizationComponent_LinkToCustomization");
static_assert(sizeof(GbxCustomizationComponent_LinkToCustomization) == 0x000008, "Wrong size on GbxCustomizationComponent_LinkToCustomization");
static_assert(offsetof(GbxCustomizationComponent_LinkToCustomization, SourceComponent) == 0x000000, "Member 'GbxCustomizationComponent_LinkToCustomization::SourceComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.RemoveCustomization
// 0x0010 (0x0010 - 0x0000)
struct GbxCustomizationComponent_RemoveCustomization final
{
public:
	class UGbxCustomizationData*                  Customization;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationComponent_RemoveCustomization) == 0x000008, "Wrong alignment on GbxCustomizationComponent_RemoveCustomization");
static_assert(sizeof(GbxCustomizationComponent_RemoveCustomization) == 0x000010, "Wrong size on GbxCustomizationComponent_RemoveCustomization");
static_assert(offsetof(GbxCustomizationComponent_RemoveCustomization, Customization) == 0x000000, "Member 'GbxCustomizationComponent_RemoveCustomization::Customization' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_RemoveCustomization, ReturnValue) == 0x000008, "Member 'GbxCustomizationComponent_RemoveCustomization::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.ServerApplyCustomColor
// 0x0020 (0x0020 - 0x0000)
struct GbxCustomizationComponent_ServerApplyCustomColor final
{
public:
	int32                                         CustomColorIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InAppliedColor;                                    // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InSplitColor;                                      // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InUseDefaultColor;                                 // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InUseDefaultSplitColor;                            // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationComponent_ServerApplyCustomColor) == 0x000004, "Wrong alignment on GbxCustomizationComponent_ServerApplyCustomColor");
static_assert(sizeof(GbxCustomizationComponent_ServerApplyCustomColor) == 0x000020, "Wrong size on GbxCustomizationComponent_ServerApplyCustomColor");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomColor, CustomColorIndex) == 0x000000, "Member 'GbxCustomizationComponent_ServerApplyCustomColor::CustomColorIndex' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomColor, InAppliedColor) == 0x000004, "Member 'GbxCustomizationComponent_ServerApplyCustomColor::InAppliedColor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomColor, InSplitColor) == 0x000010, "Member 'GbxCustomizationComponent_ServerApplyCustomColor::InSplitColor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomColor, InUseDefaultColor) == 0x00001C, "Member 'GbxCustomizationComponent_ServerApplyCustomColor::InUseDefaultColor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomColor, InUseDefaultSplitColor) == 0x00001D, "Member 'GbxCustomizationComponent_ServerApplyCustomColor::InUseDefaultSplitColor' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationComponent.ServerApplyCustomizationData
// 0x0010 (0x0010 - 0x0000)
struct GbxCustomizationComponent_ServerApplyCustomizationData final
{
public:
	class UGbxCustomizationData*                  CustomizationToApply;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalCustomizationId;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationComponent_ServerApplyCustomizationData) == 0x000008, "Wrong alignment on GbxCustomizationComponent_ServerApplyCustomizationData");
static_assert(sizeof(GbxCustomizationComponent_ServerApplyCustomizationData) == 0x000010, "Wrong size on GbxCustomizationComponent_ServerApplyCustomizationData");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomizationData, CustomizationToApply) == 0x000000, "Member 'GbxCustomizationComponent_ServerApplyCustomizationData::CustomizationToApply' has a wrong offset!");
static_assert(offsetof(GbxCustomizationComponent_ServerApplyCustomizationData, OptionalCustomizationId) == 0x000008, "Member 'GbxCustomizationComponent_ServerApplyCustomizationData::OptionalCustomizationId' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_PhysicalAnim.K2_FixupDynamicToKinematicIssues
// 0x0004 (0x0004 - 0x0000)
struct GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues final
{
public:
	float                                         AngularThreshold;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues) == 0x000004, "Wrong alignment on GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues");
static_assert(sizeof(GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues) == 0x000004, "Wrong size on GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues");
static_assert(offsetof(GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues, AngularThreshold) == 0x000000, "Member 'GbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues::AngularThreshold' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_PhysicalAnim.K2_GetDynamicBodyState
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_PhysicalAnim_K2_GetDynamicBodyState final
{
public:
	float                                         AngularThreshold;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxPhysicalActionDynamicBodyState            ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAction_PhysicalAnim_K2_GetDynamicBodyState) == 0x000004, "Wrong alignment on GbxAction_PhysicalAnim_K2_GetDynamicBodyState");
static_assert(sizeof(GbxAction_PhysicalAnim_K2_GetDynamicBodyState) == 0x000008, "Wrong size on GbxAction_PhysicalAnim_K2_GetDynamicBodyState");
static_assert(offsetof(GbxAction_PhysicalAnim_K2_GetDynamicBodyState, AngularThreshold) == 0x000000, "Member 'GbxAction_PhysicalAnim_K2_GetDynamicBodyState::AngularThreshold' has a wrong offset!");
static_assert(offsetof(GbxAction_PhysicalAnim_K2_GetDynamicBodyState, ReturnValue) == 0x000004, "Member 'GbxAction_PhysicalAnim_K2_GetDynamicBodyState::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AttributeContextResolver.GetContextForAttribute
// 0x0020 (0x0020 - 0x0000)
struct AttributeContextResolver_GetContextForAttribute final
{
public:
	const class UGbxAttributeData*                Attribute;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeContextResolver_GetContextForAttribute) == 0x000008, "Wrong alignment on AttributeContextResolver_GetContextForAttribute");
static_assert(sizeof(AttributeContextResolver_GetContextForAttribute) == 0x000020, "Wrong size on AttributeContextResolver_GetContextForAttribute");
static_assert(offsetof(AttributeContextResolver_GetContextForAttribute, Attribute) == 0x000000, "Member 'AttributeContextResolver_GetContextForAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(AttributeContextResolver_GetContextForAttribute, ContextSource) == 0x000008, "Member 'AttributeContextResolver_GetContextForAttribute::ContextSource' has a wrong offset!");
static_assert(offsetof(AttributeContextResolver_GetContextForAttribute, ReturnValue) == 0x000010, "Member 'AttributeContextResolver_GetContextForAttribute::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.CompletedChallenge
// 0x0008 (0x0008 - 0x0000)
struct Challenge_CompletedChallenge final
{
public:
	const class AGbxPlayerController*             CompletedPlayer;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_CompletedChallenge) == 0x000008, "Wrong alignment on Challenge_CompletedChallenge");
static_assert(sizeof(Challenge_CompletedChallenge) == 0x000008, "Wrong size on Challenge_CompletedChallenge");
static_assert(offsetof(Challenge_CompletedChallenge, CompletedPlayer) == 0x000000, "Member 'Challenge_CompletedChallenge::CompletedPlayer' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.CompletedConditional
// 0x0001 (0x0001 - 0x0000)
struct Challenge_CompletedConditional final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_CompletedConditional) == 0x000001, "Wrong alignment on Challenge_CompletedConditional");
static_assert(sizeof(Challenge_CompletedConditional) == 0x000001, "Wrong size on Challenge_CompletedConditional");
static_assert(offsetof(Challenge_CompletedConditional, ReturnValue) == 0x000000, "Member 'Challenge_CompletedConditional::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.IncrementChallengeProgressByValue
// 0x0004 (0x0004 - 0x0000)
struct Challenge_IncrementChallengeProgressByValue final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_IncrementChallengeProgressByValue) == 0x000004, "Wrong alignment on Challenge_IncrementChallengeProgressByValue");
static_assert(sizeof(Challenge_IncrementChallengeProgressByValue) == 0x000004, "Wrong size on Challenge_IncrementChallengeProgressByValue");
static_assert(offsetof(Challenge_IncrementChallengeProgressByValue, Value) == 0x000000, "Member 'Challenge_IncrementChallengeProgressByValue::Value' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.OnInitChallengeInstance
// 0x0010 (0x0010 - 0x0000)
struct Challenge_OnInitChallengeInstance final
{
public:
	class UChallengesComponent*                   OwningChallenges;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxCharacter*                          AssociatedCharacter;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_OnInitChallengeInstance) == 0x000008, "Wrong alignment on Challenge_OnInitChallengeInstance");
static_assert(sizeof(Challenge_OnInitChallengeInstance) == 0x000010, "Wrong size on Challenge_OnInitChallengeInstance");
static_assert(offsetof(Challenge_OnInitChallengeInstance, OwningChallenges) == 0x000000, "Member 'Challenge_OnInitChallengeInstance::OwningChallenges' has a wrong offset!");
static_assert(offsetof(Challenge_OnInitChallengeInstance, AssociatedCharacter) == 0x000008, "Member 'Challenge_OnInitChallengeInstance::AssociatedCharacter' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.OnLevelActorRegistered
// 0x0008 (0x0008 - 0x0000)
struct Challenge_OnLevelActorRegistered final
{
public:
	class UChallengeLevelActorComponent*          RegisteredLevelActor;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_OnLevelActorRegistered) == 0x000008, "Wrong alignment on Challenge_OnLevelActorRegistered");
static_assert(sizeof(Challenge_OnLevelActorRegistered) == 0x000008, "Wrong size on Challenge_OnLevelActorRegistered");
static_assert(offsetof(Challenge_OnLevelActorRegistered, RegisteredLevelActor) == 0x000000, "Member 'Challenge_OnLevelActorRegistered::RegisteredLevelActor' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.PlayerEnterChallengeArea
// 0x0008 (0x0008 - 0x0000)
struct Challenge_PlayerEnterChallengeArea final
{
public:
	class UChallengeLevelActorComponent*          LevelActorComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_PlayerEnterChallengeArea) == 0x000008, "Wrong alignment on Challenge_PlayerEnterChallengeArea");
static_assert(sizeof(Challenge_PlayerEnterChallengeArea) == 0x000008, "Wrong size on Challenge_PlayerEnterChallengeArea");
static_assert(offsetof(Challenge_PlayerEnterChallengeArea, LevelActorComponent) == 0x000000, "Member 'Challenge_PlayerEnterChallengeArea::LevelActorComponent' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.PlayerExitChallengeArea
// 0x0008 (0x0008 - 0x0000)
struct Challenge_PlayerExitChallengeArea final
{
public:
	class UChallengeLevelActorComponent*          LevelActorComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_PlayerExitChallengeArea) == 0x000008, "Wrong alignment on Challenge_PlayerExitChallengeArea");
static_assert(sizeof(Challenge_PlayerExitChallengeArea) == 0x000008, "Wrong size on Challenge_PlayerExitChallengeArea");
static_assert(offsetof(Challenge_PlayerExitChallengeArea, LevelActorComponent) == 0x000000, "Member 'Challenge_PlayerExitChallengeArea::LevelActorComponent' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.TestForCompleted
// 0x0028 (0x0028 - 0x0000)
struct Challenge_TestForCompleted final
{
public:
	const class AGbxPlayerController*             PlayerToTest;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          OtherObject;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         EnumTag;                                           // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Challenge_TestForCompleted) == 0x000008, "Wrong alignment on Challenge_TestForCompleted");
static_assert(sizeof(Challenge_TestForCompleted) == 0x000028, "Wrong size on Challenge_TestForCompleted");
static_assert(offsetof(Challenge_TestForCompleted, PlayerToTest) == 0x000000, "Member 'Challenge_TestForCompleted::PlayerToTest' has a wrong offset!");
static_assert(offsetof(Challenge_TestForCompleted, OtherObject) == 0x000008, "Member 'Challenge_TestForCompleted::OtherObject' has a wrong offset!");
static_assert(offsetof(Challenge_TestForCompleted, EnumTag) == 0x000010, "Member 'Challenge_TestForCompleted::EnumTag' has a wrong offset!");
static_assert(offsetof(Challenge_TestForCompleted, ReturnValue) == 0x000020, "Member 'Challenge_TestForCompleted::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.GetChallengeCompleteInfo
// 0x0008 (0x0008 - 0x0000)
struct Challenge_GetChallengeCompleteInfo final
{
public:
	int32                                         NumCompleted;                                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChallenges;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_GetChallengeCompleteInfo) == 0x000004, "Wrong alignment on Challenge_GetChallengeCompleteInfo");
static_assert(sizeof(Challenge_GetChallengeCompleteInfo) == 0x000008, "Wrong size on Challenge_GetChallengeCompleteInfo");
static_assert(offsetof(Challenge_GetChallengeCompleteInfo, NumCompleted) == 0x000000, "Member 'Challenge_GetChallengeCompleteInfo::NumCompleted' has a wrong offset!");
static_assert(offsetof(Challenge_GetChallengeCompleteInfo, NumChallenges) == 0x000004, "Member 'Challenge_GetChallengeCompleteInfo::NumChallenges' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.GetChallengeProgress
// 0x0004 (0x0004 - 0x0000)
struct Challenge_GetChallengeProgress final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_GetChallengeProgress) == 0x000004, "Wrong alignment on Challenge_GetChallengeProgress");
static_assert(sizeof(Challenge_GetChallengeProgress) == 0x000004, "Wrong size on Challenge_GetChallengeProgress");
static_assert(offsetof(Challenge_GetChallengeProgress, ReturnValue) == 0x000000, "Member 'Challenge_GetChallengeProgress::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.GetChallengeProgressGoalValue
// 0x0004 (0x0004 - 0x0000)
struct Challenge_GetChallengeProgressGoalValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_GetChallengeProgressGoalValue) == 0x000004, "Wrong alignment on Challenge_GetChallengeProgressGoalValue");
static_assert(sizeof(Challenge_GetChallengeProgressGoalValue) == 0x000004, "Wrong size on Challenge_GetChallengeProgressGoalValue");
static_assert(offsetof(Challenge_GetChallengeProgressGoalValue, ReturnValue) == 0x000000, "Member 'Challenge_GetChallengeProgressGoalValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.GetLevelActorComponents
// 0x0010 (0x0010 - 0x0000)
struct Challenge_GetLevelActorComponents final
{
public:
	TArray<class UChallengeLevelActorComponent*>  LevelActorList;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_GetLevelActorComponents) == 0x000008, "Wrong alignment on Challenge_GetLevelActorComponents");
static_assert(sizeof(Challenge_GetLevelActorComponents) == 0x000010, "Wrong size on Challenge_GetLevelActorComponents");
static_assert(offsetof(Challenge_GetLevelActorComponents, LevelActorList) == 0x000000, "Member 'Challenge_GetLevelActorComponents::LevelActorList' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.IsChallengeActive
// 0x0001 (0x0001 - 0x0000)
struct Challenge_IsChallengeActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_IsChallengeActive) == 0x000001, "Wrong alignment on Challenge_IsChallengeActive");
static_assert(sizeof(Challenge_IsChallengeActive) == 0x000001, "Wrong size on Challenge_IsChallengeActive");
static_assert(offsetof(Challenge_IsChallengeActive, ReturnValue) == 0x000000, "Member 'Challenge_IsChallengeActive::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.IsChallengeComplete
// 0x0001 (0x0001 - 0x0000)
struct Challenge_IsChallengeComplete final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_IsChallengeComplete) == 0x000001, "Wrong alignment on Challenge_IsChallengeComplete");
static_assert(sizeof(Challenge_IsChallengeComplete) == 0x000001, "Wrong size on Challenge_IsChallengeComplete");
static_assert(offsetof(Challenge_IsChallengeComplete, ReturnValue) == 0x000000, "Member 'Challenge_IsChallengeComplete::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Challenge.SetChallengeProgress
// 0x0004 (0x0004 - 0x0000)
struct Challenge_SetChallengeProgress final
{
public:
	int32                                         NewProgress;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Challenge_SetChallengeProgress) == 0x000004, "Wrong alignment on Challenge_SetChallengeProgress");
static_assert(sizeof(Challenge_SetChallengeProgress) == 0x000004, "Wrong size on Challenge_SetChallengeProgress");
static_assert(offsetof(Challenge_SetChallengeProgress, NewProgress) == 0x000000, "Member 'Challenge_SetChallengeProgress::NewProgress' has a wrong offset!");

// Function GbxGameSystemCore.SpawnPatternData.CalculateSpawnPoint
// 0x0068 (0x0068 - 0x0000)
struct SpawnPatternData_CalculateSpawnPoint final
{
public:
	struct FSpawnPatternInputs                    Inputs;                                            // 0x0000(0x0038)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpawnPatternResult                    Result;                                            // 0x0038(0x002C)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SpawnPatternData_CalculateSpawnPoint) == 0x000008, "Wrong alignment on SpawnPatternData_CalculateSpawnPoint");
static_assert(sizeof(SpawnPatternData_CalculateSpawnPoint) == 0x000068, "Wrong size on SpawnPatternData_CalculateSpawnPoint");
static_assert(offsetof(SpawnPatternData_CalculateSpawnPoint, Inputs) == 0x000000, "Member 'SpawnPatternData_CalculateSpawnPoint::Inputs' has a wrong offset!");
static_assert(offsetof(SpawnPatternData_CalculateSpawnPoint, Result) == 0x000038, "Member 'SpawnPatternData_CalculateSpawnPoint::Result' has a wrong offset!");

// Function GbxGameSystemCore.GbxAnimInstance.CanUseAnimTable
// 0x0010 (0x0010 - 0x0000)
struct GbxAnimInstance_CanUseAnimTable final
{
public:
	class UGbxAnimTable*                          AnimTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAnimInstance_CanUseAnimTable) == 0x000008, "Wrong alignment on GbxAnimInstance_CanUseAnimTable");
static_assert(sizeof(GbxAnimInstance_CanUseAnimTable) == 0x000010, "Wrong size on GbxAnimInstance_CanUseAnimTable");
static_assert(offsetof(GbxAnimInstance_CanUseAnimTable, AnimTable) == 0x000000, "Member 'GbxAnimInstance_CanUseAnimTable::AnimTable' has a wrong offset!");
static_assert(offsetof(GbxAnimInstance_CanUseAnimTable, ReturnValue) == 0x000008, "Member 'GbxAnimInstance_CanUseAnimTable::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAnimInstance.GetAnimTableSequence
// 0x0010 (0x0010 - 0x0000)
struct GbxAnimInstance_GetAnimTableSequence final
{
public:
	class UGbxAnimTable*                          AnimTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAnimInstance_GetAnimTableSequence) == 0x000008, "Wrong alignment on GbxAnimInstance_GetAnimTableSequence");
static_assert(sizeof(GbxAnimInstance_GetAnimTableSequence) == 0x000010, "Wrong size on GbxAnimInstance_GetAnimTableSequence");
static_assert(offsetof(GbxAnimInstance_GetAnimTableSequence, AnimTable) == 0x000000, "Member 'GbxAnimInstance_GetAnimTableSequence::AnimTable' has a wrong offset!");
static_assert(offsetof(GbxAnimInstance_GetAnimTableSequence, ReturnValue) == 0x000008, "Member 'GbxAnimInstance_GetAnimTableSequence::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.RigidBodyComponent.SetKinematic
// 0x0010 (0x0010 - 0x0000)
struct RigidBodyComponent_SetKinematic final
{
public:
	class UPrimitiveComponent*                    SleepingComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RigidBodyComponent_SetKinematic) == 0x000008, "Wrong alignment on RigidBodyComponent_SetKinematic");
static_assert(sizeof(RigidBodyComponent_SetKinematic) == 0x000010, "Wrong size on RigidBodyComponent_SetKinematic");
static_assert(offsetof(RigidBodyComponent_SetKinematic, SleepingComponent) == 0x000000, "Member 'RigidBodyComponent_SetKinematic::SleepingComponent' has a wrong offset!");
static_assert(offsetof(RigidBodyComponent_SetKinematic, BoneName) == 0x000008, "Member 'RigidBodyComponent_SetKinematic::BoneName' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationData.AsyncLoadCustomizationAssets
// 0x0010 (0x0010 - 0x0000)
struct GbxCustomizationData_AsyncLoadCustomizationAssets final
{
public:
	TDelegate<void(class UGbxCustomizationData* LoadedCustomization)> LoadedDelegate;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationData_AsyncLoadCustomizationAssets) == 0x000004, "Wrong alignment on GbxCustomizationData_AsyncLoadCustomizationAssets");
static_assert(sizeof(GbxCustomizationData_AsyncLoadCustomizationAssets) == 0x000010, "Wrong size on GbxCustomizationData_AsyncLoadCustomizationAssets");
static_assert(offsetof(GbxCustomizationData_AsyncLoadCustomizationAssets, LoadedDelegate) == 0x000000, "Member 'GbxCustomizationData_AsyncLoadCustomizationAssets::LoadedDelegate' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationData.IsLoading
// 0x0001 (0x0001 - 0x0000)
struct GbxCustomizationData_IsLoading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationData_IsLoading) == 0x000001, "Wrong alignment on GbxCustomizationData_IsLoading");
static_assert(sizeof(GbxCustomizationData_IsLoading) == 0x000001, "Wrong size on GbxCustomizationData_IsLoading");
static_assert(offsetof(GbxCustomizationData_IsLoading, ReturnValue) == 0x000000, "Member 'GbxCustomizationData_IsLoading::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationData.K2_PlayAction
// 0x00D8 (0x00D8 - 0x0000)
struct GbxCustomizationData_K2_PlayAction final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActionState_Base                      ActionData;                                        // 0x0008(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x00D0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCustomizationData_K2_PlayAction) == 0x000008, "Wrong alignment on GbxCustomizationData_K2_PlayAction");
static_assert(sizeof(GbxCustomizationData_K2_PlayAction) == 0x0000D8, "Wrong size on GbxCustomizationData_K2_PlayAction");
static_assert(offsetof(GbxCustomizationData_K2_PlayAction, TargetActor) == 0x000000, "Member 'GbxCustomizationData_K2_PlayAction::TargetActor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationData_K2_PlayAction, ActionData) == 0x000008, "Member 'GbxCustomizationData_K2_PlayAction::ActionData' has a wrong offset!");
static_assert(offsetof(GbxCustomizationData_K2_PlayAction, ReturnValue) == 0x0000D0, "Member 'GbxCustomizationData_K2_PlayAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationData.ApplyCustomizationToActor
// 0x0010 (0x0010 - 0x0000)
struct GbxCustomizationData_ApplyCustomizationToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalCustomizationId;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationData_ApplyCustomizationToActor) == 0x000008, "Wrong alignment on GbxCustomizationData_ApplyCustomizationToActor");
static_assert(sizeof(GbxCustomizationData_ApplyCustomizationToActor) == 0x000010, "Wrong size on GbxCustomizationData_ApplyCustomizationToActor");
static_assert(offsetof(GbxCustomizationData_ApplyCustomizationToActor, TargetActor) == 0x000000, "Member 'GbxCustomizationData_ApplyCustomizationToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationData_ApplyCustomizationToActor, OptionalCustomizationId) == 0x000008, "Member 'GbxCustomizationData_ApplyCustomizationToActor::OptionalCustomizationId' has a wrong offset!");
static_assert(offsetof(GbxCustomizationData_ApplyCustomizationToActor, ReturnValue) == 0x00000C, "Member 'GbxCustomizationData_ApplyCustomizationToActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationData.IsLoaded
// 0x0008 (0x0008 - 0x0000)
struct GbxCustomizationData_IsLoaded final
{
public:
	int32                                         OptionalCustomizationId;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationData_IsLoaded) == 0x000004, "Wrong alignment on GbxCustomizationData_IsLoaded");
static_assert(sizeof(GbxCustomizationData_IsLoaded) == 0x000008, "Wrong size on GbxCustomizationData_IsLoaded");
static_assert(offsetof(GbxCustomizationData_IsLoaded, OptionalCustomizationId) == 0x000000, "Member 'GbxCustomizationData_IsLoaded::OptionalCustomizationId' has a wrong offset!");
static_assert(offsetof(GbxCustomizationData_IsLoaded, ReturnValue) == 0x000004, "Member 'GbxCustomizationData_IsLoaded::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCustomizationData.RemoveCustomizationFromActor
// 0x0010 (0x0010 - 0x0000)
struct GbxCustomizationData_RemoveCustomizationFromActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCustomizationData_RemoveCustomizationFromActor) == 0x000008, "Wrong alignment on GbxCustomizationData_RemoveCustomizationFromActor");
static_assert(sizeof(GbxCustomizationData_RemoveCustomizationFromActor) == 0x000010, "Wrong size on GbxCustomizationData_RemoveCustomizationFromActor");
static_assert(offsetof(GbxCustomizationData_RemoveCustomizationFromActor, TargetActor) == 0x000000, "Member 'GbxCustomizationData_RemoveCustomizationFromActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GbxCustomizationData_RemoveCustomizationFromActor, ReturnValue) == 0x000008, "Member 'GbxCustomizationData_RemoveCustomizationFromActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UserStatesFunctionLibrary.HasEnableConditionsSetForSpecificUserState
// 0x0018 (0x0018 - 0x0000)
struct UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UserStateProperty;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState) == 0x000008, "Wrong alignment on UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState");
static_assert(sizeof(UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState) == 0x000018, "Wrong size on UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState");
static_assert(offsetof(UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState, Context) == 0x000000, "Member 'UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState::Context' has a wrong offset!");
static_assert(offsetof(UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState, UserStateProperty) == 0x000008, "Member 'UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState::UserStateProperty' has a wrong offset!");
static_assert(offsetof(UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState, ReturnValue) == 0x000010, "Member 'UserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.ActivateChallenge
// 0x0008 (0x0008 - 0x0000)
struct ChallengesComponent_ActivateChallenge final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_ActivateChallenge) == 0x000008, "Wrong alignment on ChallengesComponent_ActivateChallenge");
static_assert(sizeof(ChallengesComponent_ActivateChallenge) == 0x000008, "Wrong size on ChallengesComponent_ActivateChallenge");
static_assert(offsetof(ChallengesComponent_ActivateChallenge, ChalClass) == 0x000000, "Member 'ChallengesComponent_ActivateChallenge::ChalClass' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.AreGlobalChallengesRegistered
// 0x0001 (0x0001 - 0x0000)
struct ChallengesComponent_AreGlobalChallengesRegistered final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_AreGlobalChallengesRegistered) == 0x000001, "Wrong alignment on ChallengesComponent_AreGlobalChallengesRegistered");
static_assert(sizeof(ChallengesComponent_AreGlobalChallengesRegistered) == 0x000001, "Wrong size on ChallengesComponent_AreGlobalChallengesRegistered");
static_assert(offsetof(ChallengesComponent_AreGlobalChallengesRegistered, ReturnValue) == 0x000000, "Member 'ChallengesComponent_AreGlobalChallengesRegistered::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.ClientActivateChallenge
// 0x0008 (0x0008 - 0x0000)
struct ChallengesComponent_ClientActivateChallenge final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_ClientActivateChallenge) == 0x000008, "Wrong alignment on ChallengesComponent_ClientActivateChallenge");
static_assert(sizeof(ChallengesComponent_ClientActivateChallenge) == 0x000008, "Wrong size on ChallengesComponent_ClientActivateChallenge");
static_assert(offsetof(ChallengesComponent_ClientActivateChallenge, ChalClass) == 0x000000, "Member 'ChallengesComponent_ClientActivateChallenge::ChalClass' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.ClientChallengeCompleted
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_ClientChallengeCompleted final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTiersComplete;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceActive;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_ClientChallengeCompleted) == 0x000008, "Wrong alignment on ChallengesComponent_ClientChallengeCompleted");
static_assert(sizeof(ChallengesComponent_ClientChallengeCompleted) == 0x000010, "Wrong size on ChallengesComponent_ClientChallengeCompleted");
static_assert(offsetof(ChallengesComponent_ClientChallengeCompleted, ChalClass) == 0x000000, "Member 'ChallengesComponent_ClientChallengeCompleted::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_ClientChallengeCompleted, NumTiersComplete) == 0x000008, "Member 'ChallengesComponent_ClientChallengeCompleted::NumTiersComplete' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_ClientChallengeCompleted, bForceActive) == 0x00000C, "Member 'ChallengesComponent_ClientChallengeCompleted::bForceActive' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.ClientChallengeUpdateProgress
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_ClientChallengeUpdateProgress final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewProgress;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_ClientChallengeUpdateProgress) == 0x000008, "Wrong alignment on ChallengesComponent_ClientChallengeUpdateProgress");
static_assert(sizeof(ChallengesComponent_ClientChallengeUpdateProgress) == 0x000010, "Wrong size on ChallengesComponent_ClientChallengeUpdateProgress");
static_assert(offsetof(ChallengesComponent_ClientChallengeUpdateProgress, ChalClass) == 0x000000, "Member 'ChallengesComponent_ClientChallengeUpdateProgress::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_ClientChallengeUpdateProgress, NewProgress) == 0x000008, "Member 'ChallengesComponent_ClientChallengeUpdateProgress::NewProgress' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.CompleteChallenge
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_CompleteChallenge final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceActive;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_CompleteChallenge) == 0x000008, "Wrong alignment on ChallengesComponent_CompleteChallenge");
static_assert(sizeof(ChallengesComponent_CompleteChallenge) == 0x000010, "Wrong size on ChallengesComponent_CompleteChallenge");
static_assert(offsetof(ChallengesComponent_CompleteChallenge, ChalClass) == 0x000000, "Member 'ChallengesComponent_CompleteChallenge::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_CompleteChallenge, bForceActive) == 0x000008, "Member 'ChallengesComponent_CompleteChallenge::bForceActive' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.CompleteChallengeIfConditionsMet
// 0x0008 (0x0008 - 0x0000)
struct ChallengesComponent_CompleteChallengeIfConditionsMet final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_CompleteChallengeIfConditionsMet) == 0x000008, "Wrong alignment on ChallengesComponent_CompleteChallengeIfConditionsMet");
static_assert(sizeof(ChallengesComponent_CompleteChallengeIfConditionsMet) == 0x000008, "Wrong size on ChallengesComponent_CompleteChallengeIfConditionsMet");
static_assert(offsetof(ChallengesComponent_CompleteChallengeIfConditionsMet, ChalClass) == 0x000000, "Member 'ChallengesComponent_CompleteChallengeIfConditionsMet::ChalClass' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetChallengeCompleteInfo
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_GetChallengeCompleteInfo final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompleted;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChallenges;                                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_GetChallengeCompleteInfo) == 0x000008, "Wrong alignment on ChallengesComponent_GetChallengeCompleteInfo");
static_assert(sizeof(ChallengesComponent_GetChallengeCompleteInfo) == 0x000010, "Wrong size on ChallengesComponent_GetChallengeCompleteInfo");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfo, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetChallengeCompleteInfo::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfo, NumCompleted) == 0x000008, "Member 'ChallengesComponent_GetChallengeCompleteInfo::NumCompleted' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfo, NumChallenges) == 0x00000C, "Member 'ChallengesComponent_GetChallengeCompleteInfo::NumChallenges' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetChallengeCompleteInfoForLevels
// 0x0028 (0x0028 - 0x0000)
struct ChallengesComponent_GetChallengeCompleteInfoForLevels final
{
public:
	TArray<class FName>                           LevelsForChallenges;                               // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UChallengeCategoryData*                 Category;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompleted;                                      // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActive;                                         // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreHidden;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetChallengeCompleteInfoForLevels) == 0x000008, "Wrong alignment on ChallengesComponent_GetChallengeCompleteInfoForLevels");
static_assert(sizeof(ChallengesComponent_GetChallengeCompleteInfoForLevels) == 0x000028, "Wrong size on ChallengesComponent_GetChallengeCompleteInfoForLevels");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfoForLevels, LevelsForChallenges) == 0x000000, "Member 'ChallengesComponent_GetChallengeCompleteInfoForLevels::LevelsForChallenges' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfoForLevels, Category) == 0x000010, "Member 'ChallengesComponent_GetChallengeCompleteInfoForLevels::Category' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfoForLevels, NumCompleted) == 0x000018, "Member 'ChallengesComponent_GetChallengeCompleteInfoForLevels::NumCompleted' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfoForLevels, NumActive) == 0x00001C, "Member 'ChallengesComponent_GetChallengeCompleteInfoForLevels::NumActive' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeCompleteInfoForLevels, bIgnoreHidden) == 0x000020, "Member 'ChallengesComponent_GetChallengeCompleteInfoForLevels::bIgnoreHidden' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetChallengeProgress
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_GetChallengeProgress final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetChallengeProgress) == 0x000008, "Wrong alignment on ChallengesComponent_GetChallengeProgress");
static_assert(sizeof(ChallengesComponent_GetChallengeProgress) == 0x000010, "Wrong size on ChallengesComponent_GetChallengeProgress");
static_assert(offsetof(ChallengesComponent_GetChallengeProgress, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetChallengeProgress::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeProgress, ReturnValue) == 0x000008, "Member 'ChallengesComponent_GetChallengeProgress::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetChallengeProgressGoalValue
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_GetChallengeProgressGoalValue final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetChallengeProgressGoalValue) == 0x000008, "Wrong alignment on ChallengesComponent_GetChallengeProgressGoalValue");
static_assert(sizeof(ChallengesComponent_GetChallengeProgressGoalValue) == 0x000010, "Wrong size on ChallengesComponent_GetChallengeProgressGoalValue");
static_assert(offsetof(ChallengesComponent_GetChallengeProgressGoalValue, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetChallengeProgressGoalValue::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeProgressGoalValue, ReturnValue) == 0x000008, "Member 'ChallengesComponent_GetChallengeProgressGoalValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetChallengeStatGoalValue
// 0x0018 (0x0018 - 0x0000)
struct ChallengesComponent_GetChallengeStatGoalValue final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetChallengeStatGoalValue) == 0x000008, "Wrong alignment on ChallengesComponent_GetChallengeStatGoalValue");
static_assert(sizeof(ChallengesComponent_GetChallengeStatGoalValue) == 0x000018, "Wrong size on ChallengesComponent_GetChallengeStatGoalValue");
static_assert(offsetof(ChallengesComponent_GetChallengeStatGoalValue, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetChallengeStatGoalValue::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeStatGoalValue, StatId) == 0x000008, "Member 'ChallengesComponent_GetChallengeStatGoalValue::StatId' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeStatGoalValue, ReturnValue) == 0x000010, "Member 'ChallengesComponent_GetChallengeStatGoalValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetChallengeStatValue
// 0x0018 (0x0018 - 0x0000)
struct ChallengesComponent_GetChallengeStatValue final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetChallengeStatValue) == 0x000008, "Wrong alignment on ChallengesComponent_GetChallengeStatValue");
static_assert(sizeof(ChallengesComponent_GetChallengeStatValue) == 0x000018, "Wrong size on ChallengesComponent_GetChallengeStatValue");
static_assert(offsetof(ChallengesComponent_GetChallengeStatValue, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetChallengeStatValue::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeStatValue, StatId) == 0x000008, "Member 'ChallengesComponent_GetChallengeStatValue::StatId' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetChallengeStatValue, ReturnValue) == 0x000010, "Member 'ChallengesComponent_GetChallengeStatValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetCompletedChallengeTiers
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_GetCompletedChallengeTiers final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetCompletedChallengeTiers) == 0x000008, "Wrong alignment on ChallengesComponent_GetCompletedChallengeTiers");
static_assert(sizeof(ChallengesComponent_GetCompletedChallengeTiers) == 0x000010, "Wrong size on ChallengesComponent_GetCompletedChallengeTiers");
static_assert(offsetof(ChallengesComponent_GetCompletedChallengeTiers, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetCompletedChallengeTiers::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetCompletedChallengeTiers, ReturnValue) == 0x000008, "Member 'ChallengesComponent_GetCompletedChallengeTiers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetLocalChallenges
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_GetLocalChallenges final
{
public:
	TArray<struct FChallengeInstanceData>         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_GetLocalChallenges) == 0x000008, "Wrong alignment on ChallengesComponent_GetLocalChallenges");
static_assert(sizeof(ChallengesComponent_GetLocalChallenges) == 0x000010, "Wrong size on ChallengesComponent_GetLocalChallenges");
static_assert(offsetof(ChallengesComponent_GetLocalChallenges, ReturnValue) == 0x000000, "Member 'ChallengesComponent_GetLocalChallenges::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.GetMaxChallengeTiers
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_GetMaxChallengeTiers final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_GetMaxChallengeTiers) == 0x000008, "Wrong alignment on ChallengesComponent_GetMaxChallengeTiers");
static_assert(sizeof(ChallengesComponent_GetMaxChallengeTiers) == 0x000010, "Wrong size on ChallengesComponent_GetMaxChallengeTiers");
static_assert(offsetof(ChallengesComponent_GetMaxChallengeTiers, ChalClass) == 0x000000, "Member 'ChallengesComponent_GetMaxChallengeTiers::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_GetMaxChallengeTiers, ReturnValue) == 0x000008, "Member 'ChallengesComponent_GetMaxChallengeTiers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.IncrementChallengeProgress
// 0x0008 (0x0008 - 0x0000)
struct ChallengesComponent_IncrementChallengeProgress final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengesComponent_IncrementChallengeProgress) == 0x000008, "Wrong alignment on ChallengesComponent_IncrementChallengeProgress");
static_assert(sizeof(ChallengesComponent_IncrementChallengeProgress) == 0x000008, "Wrong size on ChallengesComponent_IncrementChallengeProgress");
static_assert(offsetof(ChallengesComponent_IncrementChallengeProgress, ChalClass) == 0x000000, "Member 'ChallengesComponent_IncrementChallengeProgress::ChalClass' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.IsChallengeActive
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_IsChallengeActive final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_IsChallengeActive) == 0x000008, "Wrong alignment on ChallengesComponent_IsChallengeActive");
static_assert(sizeof(ChallengesComponent_IsChallengeActive) == 0x000010, "Wrong size on ChallengesComponent_IsChallengeActive");
static_assert(offsetof(ChallengesComponent_IsChallengeActive, ChalClass) == 0x000000, "Member 'ChallengesComponent_IsChallengeActive::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_IsChallengeActive, ReturnValue) == 0x000008, "Member 'ChallengesComponent_IsChallengeActive::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.IsChallengeComplete
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_IsChallengeComplete final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_IsChallengeComplete) == 0x000008, "Wrong alignment on ChallengesComponent_IsChallengeComplete");
static_assert(sizeof(ChallengesComponent_IsChallengeComplete) == 0x000010, "Wrong size on ChallengesComponent_IsChallengeComplete");
static_assert(offsetof(ChallengesComponent_IsChallengeComplete, ChalClass) == 0x000000, "Member 'ChallengesComponent_IsChallengeComplete::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_IsChallengeComplete, ReturnValue) == 0x000008, "Member 'ChallengesComponent_IsChallengeComplete::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.SetChallengeActive
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_SetChallengeActive final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsActive;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_SetChallengeActive) == 0x000008, "Wrong alignment on ChallengesComponent_SetChallengeActive");
static_assert(sizeof(ChallengesComponent_SetChallengeActive) == 0x000010, "Wrong size on ChallengesComponent_SetChallengeActive");
static_assert(offsetof(ChallengesComponent_SetChallengeActive, ChalClass) == 0x000000, "Member 'ChallengesComponent_SetChallengeActive::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_SetChallengeActive, bInIsActive) == 0x000008, "Member 'ChallengesComponent_SetChallengeActive::bInIsActive' has a wrong offset!");

// Function GbxGameSystemCore.ChallengesComponent.SetChallengeProgress
// 0x0010 (0x0010 - 0x0000)
struct ChallengesComponent_SetChallengeProgress final
{
public:
	class UClass*                                 ChalClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewProgress;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengesComponent_SetChallengeProgress) == 0x000008, "Wrong alignment on ChallengesComponent_SetChallengeProgress");
static_assert(sizeof(ChallengesComponent_SetChallengeProgress) == 0x000010, "Wrong size on ChallengesComponent_SetChallengeProgress");
static_assert(offsetof(ChallengesComponent_SetChallengeProgress, ChalClass) == 0x000000, "Member 'ChallengesComponent_SetChallengeProgress::ChalClass' has a wrong offset!");
static_assert(offsetof(ChallengesComponent_SetChallengeProgress, NewProgress) == 0x000008, "Member 'ChallengesComponent_SetChallengeProgress::NewProgress' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterAnimInstance.SetDesiredFacialEmoteWeight
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight) == 0x000004, "Wrong alignment on GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight");
static_assert(sizeof(GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight) == 0x000008, "Wrong size on GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight");
static_assert(offsetof(GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight, Weight) == 0x000000, "Member 'GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight::Weight' has a wrong offset!");
static_assert(offsetof(GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight, BlendTime) == 0x000004, "Member 'GbxCharacterAnimInstance_SetDesiredFacialEmoteWeight::BlendTime' has a wrong offset!");

// Function GbxGameSystemCore.EffectCollectionData.StaticGetParticleEffect
// 0x0018 (0x0018 - 0x0000)
struct EffectCollectionData_StaticGetParticleEffect final
{
public:
	TSubclassOf<class UEffectCollectionData>      Collection;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextObject;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectCollectionData_StaticGetParticleEffect) == 0x000008, "Wrong alignment on EffectCollectionData_StaticGetParticleEffect");
static_assert(sizeof(EffectCollectionData_StaticGetParticleEffect) == 0x000018, "Wrong size on EffectCollectionData_StaticGetParticleEffect");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffect, Collection) == 0x000000, "Member 'EffectCollectionData_StaticGetParticleEffect::Collection' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffect, ContextObject) == 0x000008, "Member 'EffectCollectionData_StaticGetParticleEffect::ContextObject' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffect, ReturnValue) == 0x000010, "Member 'EffectCollectionData_StaticGetParticleEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EffectCollectionData.StaticGetParticleEffectAndWwiseEvent
// 0x0020 (0x0020 - 0x0000)
struct EffectCollectionData_StaticGetParticleEffectAndWwiseEvent final
{
public:
	TSubclassOf<class UEffectCollectionData>      Collection;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextObject;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleEffect;                                    // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectCollectionData_StaticGetParticleEffectAndWwiseEvent) == 0x000008, "Wrong alignment on EffectCollectionData_StaticGetParticleEffectAndWwiseEvent");
static_assert(sizeof(EffectCollectionData_StaticGetParticleEffectAndWwiseEvent) == 0x000020, "Wrong size on EffectCollectionData_StaticGetParticleEffectAndWwiseEvent");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffectAndWwiseEvent, Collection) == 0x000000, "Member 'EffectCollectionData_StaticGetParticleEffectAndWwiseEvent::Collection' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffectAndWwiseEvent, ContextObject) == 0x000008, "Member 'EffectCollectionData_StaticGetParticleEffectAndWwiseEvent::ContextObject' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffectAndWwiseEvent, ParticleEffect) == 0x000010, "Member 'EffectCollectionData_StaticGetParticleEffectAndWwiseEvent::ParticleEffect' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetParticleEffectAndWwiseEvent, WwiseEvent) == 0x000018, "Member 'EffectCollectionData_StaticGetParticleEffectAndWwiseEvent::WwiseEvent' has a wrong offset!");

// Function GbxGameSystemCore.EffectCollectionData.StaticGetWwiseEvent
// 0x0018 (0x0018 - 0x0000)
struct EffectCollectionData_StaticGetWwiseEvent final
{
public:
	TSubclassOf<class UEffectCollectionData>      Collection;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextObject;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectCollectionData_StaticGetWwiseEvent) == 0x000008, "Wrong alignment on EffectCollectionData_StaticGetWwiseEvent");
static_assert(sizeof(EffectCollectionData_StaticGetWwiseEvent) == 0x000018, "Wrong size on EffectCollectionData_StaticGetWwiseEvent");
static_assert(offsetof(EffectCollectionData_StaticGetWwiseEvent, Collection) == 0x000000, "Member 'EffectCollectionData_StaticGetWwiseEvent::Collection' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetWwiseEvent, ContextObject) == 0x000008, "Member 'EffectCollectionData_StaticGetWwiseEvent::ContextObject' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_StaticGetWwiseEvent, ReturnValue) == 0x000010, "Member 'EffectCollectionData_StaticGetWwiseEvent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EffectCollectionData.GetParticleEffect
// 0x0010 (0x0010 - 0x0000)
struct EffectCollectionData_GetParticleEffect final
{
public:
	class UObject*                                ContextObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectCollectionData_GetParticleEffect) == 0x000008, "Wrong alignment on EffectCollectionData_GetParticleEffect");
static_assert(sizeof(EffectCollectionData_GetParticleEffect) == 0x000010, "Wrong size on EffectCollectionData_GetParticleEffect");
static_assert(offsetof(EffectCollectionData_GetParticleEffect, ContextObject) == 0x000000, "Member 'EffectCollectionData_GetParticleEffect::ContextObject' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_GetParticleEffect, ReturnValue) == 0x000008, "Member 'EffectCollectionData_GetParticleEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EffectCollectionData.GetParticleEffectAndWwiseEvent
// 0x0018 (0x0018 - 0x0000)
struct EffectCollectionData_GetParticleEffectAndWwiseEvent final
{
public:
	class UObject*                                ContextObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleEffect;                                    // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectCollectionData_GetParticleEffectAndWwiseEvent) == 0x000008, "Wrong alignment on EffectCollectionData_GetParticleEffectAndWwiseEvent");
static_assert(sizeof(EffectCollectionData_GetParticleEffectAndWwiseEvent) == 0x000018, "Wrong size on EffectCollectionData_GetParticleEffectAndWwiseEvent");
static_assert(offsetof(EffectCollectionData_GetParticleEffectAndWwiseEvent, ContextObject) == 0x000000, "Member 'EffectCollectionData_GetParticleEffectAndWwiseEvent::ContextObject' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_GetParticleEffectAndWwiseEvent, ParticleEffect) == 0x000008, "Member 'EffectCollectionData_GetParticleEffectAndWwiseEvent::ParticleEffect' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_GetParticleEffectAndWwiseEvent, WwiseEvent) == 0x000010, "Member 'EffectCollectionData_GetParticleEffectAndWwiseEvent::WwiseEvent' has a wrong offset!");

// Function GbxGameSystemCore.EffectCollectionData.GetWwiseEvent
// 0x0010 (0x0010 - 0x0000)
struct EffectCollectionData_GetWwiseEvent final
{
public:
	class UObject*                                ContextObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EffectCollectionData_GetWwiseEvent) == 0x000008, "Wrong alignment on EffectCollectionData_GetWwiseEvent");
static_assert(sizeof(EffectCollectionData_GetWwiseEvent) == 0x000010, "Wrong size on EffectCollectionData_GetWwiseEvent");
static_assert(offsetof(EffectCollectionData_GetWwiseEvent, ContextObject) == 0x000000, "Member 'EffectCollectionData_GetWwiseEvent::ContextObject' has a wrong offset!");
static_assert(offsetof(EffectCollectionData_GetWwiseEvent, ReturnValue) == 0x000008, "Member 'EffectCollectionData_GetWwiseEvent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DataTableAttributeValueResolver.GetDataTableColumnNames
// 0x0010 (0x0010 - 0x0000)
struct DataTableAttributeValueResolver_GetDataTableColumnNames final
{
public:
	TArray<class FString>                         ValueNames;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DataTableAttributeValueResolver_GetDataTableColumnNames) == 0x000008, "Wrong alignment on DataTableAttributeValueResolver_GetDataTableColumnNames");
static_assert(sizeof(DataTableAttributeValueResolver_GetDataTableColumnNames) == 0x000010, "Wrong size on DataTableAttributeValueResolver_GetDataTableColumnNames");
static_assert(offsetof(DataTableAttributeValueResolver_GetDataTableColumnNames, ValueNames) == 0x000000, "Member 'DataTableAttributeValueResolver_GetDataTableColumnNames::ValueNames' has a wrong offset!");

// Function GbxGameSystemCore.DataTableFunctionAttributeValueResolver.GetDataTableRow
// 0x0018 (0x0018 - 0x0000)
struct DataTableFunctionAttributeValueResolver_GetDataTableRow final
{
public:
	const class UObject*                          Context;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DataTableFunctionAttributeValueResolver_GetDataTableRow) == 0x000008, "Wrong alignment on DataTableFunctionAttributeValueResolver_GetDataTableRow");
static_assert(sizeof(DataTableFunctionAttributeValueResolver_GetDataTableRow) == 0x000018, "Wrong size on DataTableFunctionAttributeValueResolver_GetDataTableRow");
static_assert(offsetof(DataTableFunctionAttributeValueResolver_GetDataTableRow, Context) == 0x000000, "Member 'DataTableFunctionAttributeValueResolver_GetDataTableRow::Context' has a wrong offset!");
static_assert(offsetof(DataTableFunctionAttributeValueResolver_GetDataTableRow, ReturnValue) == 0x000008, "Member 'DataTableFunctionAttributeValueResolver_GetDataTableRow::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetApplyCriticalHitModsToAoEDamage
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage");
static_assert(sizeof(DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage");
static_assert(offsetof(DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetCriticalHitDamageOverrides
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FCriticalHitDamageOverrides            ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides");
static_assert(sizeof(DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides");
static_assert(offsetof(DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetCriticalHitDamageOverrides::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamage
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetDamage final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0058(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_GetDamage) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetDamage");
static_assert(sizeof(DamageInfoFunctionLibrary_GetDamage) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetDamage");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamage, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetDamage::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamage, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetDamage::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageCauser
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetDamageCauser final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_GetDamageCauser) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetDamageCauser");
static_assert(sizeof(DamageInfoFunctionLibrary_GetDamageCauser) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetDamageCauser");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageCauser, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetDamageCauser::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageCauser, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetDamageCauser::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageModifierComponent
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetDamageModifierComponent final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDamageModifierComponent*               ReturnValue;                                       // 0x0058(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_GetDamageModifierComponent) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetDamageModifierComponent");
static_assert(sizeof(DamageInfoFunctionLibrary_GetDamageModifierComponent) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetDamageModifierComponent");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageModifierComponent, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetDamageModifierComponent::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageModifierComponent, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetDamageModifierComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageRadius
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetDamageRadius final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0058(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_GetDamageRadius) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetDamageRadius");
static_assert(sizeof(DamageInfoFunctionLibrary_GetDamageRadius) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetDamageRadius");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageRadius, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetDamageRadius::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageRadius, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetDamageRadius::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageSource
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetDamageSource final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_GetDamageSource) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetDamageSource");
static_assert(sizeof(DamageInfoFunctionLibrary_GetDamageSource) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetDamageSource");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageSource, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetDamageSource::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageSource, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetDamageSource::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageType
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetDamageType final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_GetDamageType) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetDamageType");
static_assert(sizeof(DamageInfoFunctionLibrary_GetDamageType) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetDamageType");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageType, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetDamageType::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetDamageType, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetDamageType::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetImpactForce
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_GetImpactForce final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0058(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_GetImpactForce) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_GetImpactForce");
static_assert(sizeof(DamageInfoFunctionLibrary_GetImpactForce) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_GetImpactForce");
static_assert(offsetof(DamageInfoFunctionLibrary_GetImpactForce, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_GetImpactForce::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_GetImpactForce, ReturnValue) == 0x000058, "Member 'DamageInfoFunctionLibrary_GetImpactForce::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetApplyCriticalHitModsToAoEDamage
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bApplyCriticalHitModsToAoEDamage;                  // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage");
static_assert(sizeof(DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage");
static_assert(offsetof(DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage, bApplyCriticalHitModsToAoEDamage) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage::bApplyCriticalHitModsToAoEDamage' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetCriticalHitDamageOverrides
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FCriticalHitDamageOverrides            Overrides;                                         // 0x0058(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides");
static_assert(sizeof(DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides");
static_assert(offsetof(DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides, Overrides) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetCriticalHitDamageOverrides::Overrides' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamage
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetDamage final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InDamage;                                          // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_SetDamage) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetDamage");
static_assert(sizeof(DamageInfoFunctionLibrary_SetDamage) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetDamage");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamage, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetDamage::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamage, InDamage) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetDamage::InDamage' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageCauser
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetDamageCauser final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 InDamageCauser;                                    // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_SetDamageCauser) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetDamageCauser");
static_assert(sizeof(DamageInfoFunctionLibrary_SetDamageCauser) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetDamageCauser");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageCauser, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetDamageCauser::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageCauser, InDamageCauser) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetDamageCauser::InDamageCauser' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageModifierComponent
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetDamageModifierComponent final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDamageModifierComponent*               InModifierComponent;                               // 0x0058(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_SetDamageModifierComponent) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetDamageModifierComponent");
static_assert(sizeof(DamageInfoFunctionLibrary_SetDamageModifierComponent) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetDamageModifierComponent");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageModifierComponent, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetDamageModifierComponent::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageModifierComponent, InModifierComponent) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetDamageModifierComponent::InModifierComponent' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageRadius
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetDamageRadius final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InDamageRadius;                                    // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_SetDamageRadius) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetDamageRadius");
static_assert(sizeof(DamageInfoFunctionLibrary_SetDamageRadius) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetDamageRadius");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageRadius, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetDamageRadius::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageRadius, InDamageRadius) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetDamageRadius::InDamageRadius' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageSource
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetDamageSource final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              InDamageSource;                                    // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_SetDamageSource) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetDamageSource");
static_assert(sizeof(DamageInfoFunctionLibrary_SetDamageSource) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetDamageSource");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageSource, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetDamageSource::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageSource, InDamageSource) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetDamageSource::InDamageSource' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageType
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetDamageType final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             InDamageType;                                      // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageInfoFunctionLibrary_SetDamageType) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetDamageType");
static_assert(sizeof(DamageInfoFunctionLibrary_SetDamageType) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetDamageType");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageType, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetDamageType::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetDamageType, InDamageType) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetDamageType::InDamageType' has a wrong offset!");

// Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetImpactForce
// 0x0060 (0x0060 - 0x0000)
struct DamageInfoFunctionLibrary_SetImpactForce final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InImpactForce;                                     // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageInfoFunctionLibrary_SetImpactForce) == 0x000008, "Wrong alignment on DamageInfoFunctionLibrary_SetImpactForce");
static_assert(sizeof(DamageInfoFunctionLibrary_SetImpactForce) == 0x000060, "Wrong size on DamageInfoFunctionLibrary_SetImpactForce");
static_assert(offsetof(DamageInfoFunctionLibrary_SetImpactForce, DamageInfo) == 0x000000, "Member 'DamageInfoFunctionLibrary_SetImpactForce::DamageInfo' has a wrong offset!");
static_assert(offsetof(DamageInfoFunctionLibrary_SetImpactForce, InImpactForce) == 0x000058, "Member 'DamageInfoFunctionLibrary_SetImpactForce::InImpactForce' has a wrong offset!");

// Function GbxGameSystemCore.DamageData.OnHitAnyAttitude
// 0x0060 (0x0060 - 0x0000)
struct DamageData_OnHitAnyAttitude final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageDataEventDetails                Details;                                           // 0x0018(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageData_OnHitAnyAttitude) == 0x000008, "Wrong alignment on DamageData_OnHitAnyAttitude");
static_assert(sizeof(DamageData_OnHitAnyAttitude) == 0x000060, "Wrong size on DamageData_OnHitAnyAttitude");
static_assert(offsetof(DamageData_OnHitAnyAttitude, DamageInstigator) == 0x000000, "Member 'DamageData_OnHitAnyAttitude::DamageInstigator' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitAnyAttitude, DamageCauser) == 0x000008, "Member 'DamageData_OnHitAnyAttitude::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitAnyAttitude, DamageTarget) == 0x000010, "Member 'DamageData_OnHitAnyAttitude::DamageTarget' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitAnyAttitude, Details) == 0x000018, "Member 'DamageData_OnHitAnyAttitude::Details' has a wrong offset!");

// Function GbxGameSystemCore.DamageData.OnHitEnemy
// 0x0060 (0x0060 - 0x0000)
struct DamageData_OnHitEnemy final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageDataEventDetails                Details;                                           // 0x0018(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageData_OnHitEnemy) == 0x000008, "Wrong alignment on DamageData_OnHitEnemy");
static_assert(sizeof(DamageData_OnHitEnemy) == 0x000060, "Wrong size on DamageData_OnHitEnemy");
static_assert(offsetof(DamageData_OnHitEnemy, DamageInstigator) == 0x000000, "Member 'DamageData_OnHitEnemy::DamageInstigator' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitEnemy, DamageCauser) == 0x000008, "Member 'DamageData_OnHitEnemy::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitEnemy, DamageTarget) == 0x000010, "Member 'DamageData_OnHitEnemy::DamageTarget' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitEnemy, Details) == 0x000018, "Member 'DamageData_OnHitEnemy::Details' has a wrong offset!");

// Function GbxGameSystemCore.DamageData.OnHitFriendly
// 0x0060 (0x0060 - 0x0000)
struct DamageData_OnHitFriendly final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageDataEventDetails                Details;                                           // 0x0018(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageData_OnHitFriendly) == 0x000008, "Wrong alignment on DamageData_OnHitFriendly");
static_assert(sizeof(DamageData_OnHitFriendly) == 0x000060, "Wrong size on DamageData_OnHitFriendly");
static_assert(offsetof(DamageData_OnHitFriendly, DamageInstigator) == 0x000000, "Member 'DamageData_OnHitFriendly::DamageInstigator' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitFriendly, DamageCauser) == 0x000008, "Member 'DamageData_OnHitFriendly::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitFriendly, DamageTarget) == 0x000010, "Member 'DamageData_OnHitFriendly::DamageTarget' has a wrong offset!");
static_assert(offsetof(DamageData_OnHitFriendly, Details) == 0x000018, "Member 'DamageData_OnHitFriendly::Details' has a wrong offset!");

// Function GbxGameSystemCore.DamageData.OnKilledEnemy
// 0x0060 (0x0060 - 0x0000)
struct DamageData_OnKilledEnemy final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageDataEventDetails                Details;                                           // 0x0018(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageData_OnKilledEnemy) == 0x000008, "Wrong alignment on DamageData_OnKilledEnemy");
static_assert(sizeof(DamageData_OnKilledEnemy) == 0x000060, "Wrong size on DamageData_OnKilledEnemy");
static_assert(offsetof(DamageData_OnKilledEnemy, DamageInstigator) == 0x000000, "Member 'DamageData_OnKilledEnemy::DamageInstigator' has a wrong offset!");
static_assert(offsetof(DamageData_OnKilledEnemy, DamageCauser) == 0x000008, "Member 'DamageData_OnKilledEnemy::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageData_OnKilledEnemy, DamageTarget) == 0x000010, "Member 'DamageData_OnKilledEnemy::DamageTarget' has a wrong offset!");
static_assert(offsetof(DamageData_OnKilledEnemy, Details) == 0x000018, "Member 'DamageData_OnKilledEnemy::Details' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeManager.OnStatIncrement
// 0x0018 (0x0018 - 0x0000)
struct ChallengeManager_OnStatIncrement final
{
public:
	class AActor*                                 StatContext;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengeManager_OnStatIncrement) == 0x000008, "Wrong alignment on ChallengeManager_OnStatIncrement");
static_assert(sizeof(ChallengeManager_OnStatIncrement) == 0x000018, "Wrong size on ChallengeManager_OnStatIncrement");
static_assert(offsetof(ChallengeManager_OnStatIncrement, StatContext) == 0x000000, "Member 'ChallengeManager_OnStatIncrement::StatContext' has a wrong offset!");
static_assert(offsetof(ChallengeManager_OnStatIncrement, StatId) == 0x000008, "Member 'ChallengeManager_OnStatIncrement::StatId' has a wrong offset!");
static_assert(offsetof(ChallengeManager_OnStatIncrement, Amount) == 0x000010, "Member 'ChallengeManager_OnStatIncrement::Amount' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileHomingComponent.GetHomingLocation
// 0x000C (0x000C - 0x0000)
struct ProjectileHomingComponent_GetHomingLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileHomingComponent_GetHomingLocation) == 0x000004, "Wrong alignment on ProjectileHomingComponent_GetHomingLocation");
static_assert(sizeof(ProjectileHomingComponent_GetHomingLocation) == 0x00000C, "Wrong size on ProjectileHomingComponent_GetHomingLocation");
static_assert(offsetof(ProjectileHomingComponent_GetHomingLocation, ReturnValue) == 0x000000, "Member 'ProjectileHomingComponent_GetHomingLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileHomingComponent.SetAssociatedProjectileMovement
// 0x0008 (0x0008 - 0x0000)
struct ProjectileHomingComponent_SetAssociatedProjectileMovement final
{
public:
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileHomingComponent_SetAssociatedProjectileMovement) == 0x000008, "Wrong alignment on ProjectileHomingComponent_SetAssociatedProjectileMovement");
static_assert(sizeof(ProjectileHomingComponent_SetAssociatedProjectileMovement) == 0x000008, "Wrong size on ProjectileHomingComponent_SetAssociatedProjectileMovement");
static_assert(offsetof(ProjectileHomingComponent_SetAssociatedProjectileMovement, ProjectileMovementComponent) == 0x000000, "Member 'ProjectileHomingComponent_SetAssociatedProjectileMovement::ProjectileMovementComponent' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileHomingComponent.SetHomeIn
// 0x0001 (0x0001 - 0x0000)
struct ProjectileHomingComponent_SetHomeIn final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileHomingComponent_SetHomeIn) == 0x000001, "Wrong alignment on ProjectileHomingComponent_SetHomeIn");
static_assert(sizeof(ProjectileHomingComponent_SetHomeIn) == 0x000001, "Wrong size on ProjectileHomingComponent_SetHomeIn");
static_assert(offsetof(ProjectileHomingComponent_SetHomeIn, bEnabled) == 0x000000, "Member 'ProjectileHomingComponent_SetHomeIn::bEnabled' has a wrong offset!");

// Function GbxGameSystemCore.DamageCauserComponent.RegisterConditionalDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct DamageCauserComponent_RegisterConditionalDamageModifier final
{
public:
	class UConditionalDamageModifier*             Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageCauserComponent_RegisterConditionalDamageModifier) == 0x000008, "Wrong alignment on DamageCauserComponent_RegisterConditionalDamageModifier");
static_assert(sizeof(DamageCauserComponent_RegisterConditionalDamageModifier) == 0x000008, "Wrong size on DamageCauserComponent_RegisterConditionalDamageModifier");
static_assert(offsetof(DamageCauserComponent_RegisterConditionalDamageModifier, Modifier) == 0x000000, "Member 'DamageCauserComponent_RegisterConditionalDamageModifier::Modifier' has a wrong offset!");

// Function GbxGameSystemCore.DamageCauserComponent.UnregisterConditionalDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct DamageCauserComponent_UnregisterConditionalDamageModifier final
{
public:
	class UConditionalDamageModifier*             Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageCauserComponent_UnregisterConditionalDamageModifier) == 0x000008, "Wrong alignment on DamageCauserComponent_UnregisterConditionalDamageModifier");
static_assert(sizeof(DamageCauserComponent_UnregisterConditionalDamageModifier) == 0x000008, "Wrong size on DamageCauserComponent_UnregisterConditionalDamageModifier");
static_assert(offsetof(DamageCauserComponent_UnregisterConditionalDamageModifier, Modifier) == 0x000000, "Member 'DamageCauserComponent_UnregisterConditionalDamageModifier::Modifier' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Loop.OnLoop
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_Loop_OnLoop final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Loop_OnLoop) == 0x000008, "Wrong alignment on GbxAction_Loop_OnLoop");
static_assert(sizeof(GbxAction_Loop_OnLoop) == 0x000008, "Wrong size on GbxAction_Loop_OnLoop");
static_assert(offsetof(GbxAction_Loop_OnLoop, Actor) == 0x000000, "Member 'GbxAction_Loop_OnLoop::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_Loop.OnStop
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_Loop_OnStop final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Loop_OnStop) == 0x000008, "Wrong alignment on GbxAction_Loop_OnStop");
static_assert(sizeof(GbxAction_Loop_OnStop) == 0x000008, "Wrong size on GbxAction_Loop_OnStop");
static_assert(offsetof(GbxAction_Loop_OnStop, Actor) == 0x000000, "Member 'GbxAction_Loop_OnStop::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClearAndSetCinematicMode
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_ClearAndSetCinematicMode final
{
public:
	class UCinematicModeData*                     InCinematicMode;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ClearAndSetCinematicMode) == 0x000008, "Wrong alignment on GbxPlayerController_ClearAndSetCinematicMode");
static_assert(sizeof(GbxPlayerController_ClearAndSetCinematicMode) == 0x000008, "Wrong size on GbxPlayerController_ClearAndSetCinematicMode");
static_assert(offsetof(GbxPlayerController_ClearAndSetCinematicMode, InCinematicMode) == 0x000000, "Member 'GbxPlayerController_ClearAndSetCinematicMode::InCinematicMode' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.Client_PlayGbxFeedback
// 0x0030 (0x0030 - 0x0000)
struct GbxPlayerController_Client_PlayGbxFeedback final
{
public:
	const class UGbxFeedbackData*                 Data;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIs3D;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectFalloffMinDistance;                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectFalloffMaxDistance;                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxPlayerController_Client_PlayGbxFeedback) == 0x000008, "Wrong alignment on GbxPlayerController_Client_PlayGbxFeedback");
static_assert(sizeof(GbxPlayerController_Client_PlayGbxFeedback) == 0x000030, "Wrong size on GbxPlayerController_Client_PlayGbxFeedback");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, Data) == 0x000000, "Member 'GbxPlayerController_Client_PlayGbxFeedback::Data' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, bIs3D) == 0x000008, "Member 'GbxPlayerController_Client_PlayGbxFeedback::bIs3D' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, bLoop) == 0x000009, "Member 'GbxPlayerController_Client_PlayGbxFeedback::bLoop' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, Scale) == 0x00000C, "Member 'GbxPlayerController_Client_PlayGbxFeedback::Scale' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, SourceContext) == 0x000010, "Member 'GbxPlayerController_Client_PlayGbxFeedback::SourceContext' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, SourceLocation) == 0x000018, "Member 'GbxPlayerController_Client_PlayGbxFeedback::SourceLocation' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, EffectFalloffMinDistance) == 0x000024, "Member 'GbxPlayerController_Client_PlayGbxFeedback::EffectFalloffMinDistance' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_PlayGbxFeedback, EffectFalloffMaxDistance) == 0x000028, "Member 'GbxPlayerController_Client_PlayGbxFeedback::EffectFalloffMaxDistance' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.Client_StopGbxFeedback
// 0x0010 (0x0010 - 0x0000)
struct GbxPlayerController_Client_StopGbxFeedback final
{
public:
	const class UGbxFeedbackData*                 Data;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_Client_StopGbxFeedback) == 0x000008, "Wrong alignment on GbxPlayerController_Client_StopGbxFeedback");
static_assert(sizeof(GbxPlayerController_Client_StopGbxFeedback) == 0x000010, "Wrong size on GbxPlayerController_Client_StopGbxFeedback");
static_assert(offsetof(GbxPlayerController_Client_StopGbxFeedback, Data) == 0x000000, "Member 'GbxPlayerController_Client_StopGbxFeedback::Data' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_Client_StopGbxFeedback, SourceContext) == 0x000008, "Member 'GbxPlayerController_Client_StopGbxFeedback::SourceContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientApplyDamageDataPresentation
// 0x0020 (0x0020 - 0x0000)
struct GbxPlayerController_ClientApplyDamageDataPresentation final
{
public:
	const class UDamageData*                      DamageData;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerDamageDataPresentation          PlayerPresentation;                                // 0x0008(0x0018)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ClientApplyDamageDataPresentation) == 0x000008, "Wrong alignment on GbxPlayerController_ClientApplyDamageDataPresentation");
static_assert(sizeof(GbxPlayerController_ClientApplyDamageDataPresentation) == 0x000020, "Wrong size on GbxPlayerController_ClientApplyDamageDataPresentation");
static_assert(offsetof(GbxPlayerController_ClientApplyDamageDataPresentation, DamageData) == 0x000000, "Member 'GbxPlayerController_ClientApplyDamageDataPresentation::DamageData' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientApplyDamageDataPresentation, PlayerPresentation) == 0x000008, "Member 'GbxPlayerController_ClientApplyDamageDataPresentation::PlayerPresentation' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientCanSplitscreenJoin
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_ClientCanSplitscreenJoin final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanJoin;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxPlayerController_ClientCanSplitscreenJoin) == 0x000004, "Wrong alignment on GbxPlayerController_ClientCanSplitscreenJoin");
static_assert(sizeof(GbxPlayerController_ClientCanSplitscreenJoin) == 0x000008, "Wrong size on GbxPlayerController_ClientCanSplitscreenJoin");
static_assert(offsetof(GbxPlayerController_ClientCanSplitscreenJoin, ControllerId) == 0x000000, "Member 'GbxPlayerController_ClientCanSplitscreenJoin::ControllerId' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientCanSplitscreenJoin, bCanJoin) == 0x000004, "Member 'GbxPlayerController_ClientCanSplitscreenJoin::bCanJoin' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientPerformFeedback
// 0x0010 (0x0010 - 0x0000)
struct GbxPlayerController_ClientPerformFeedback final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ClientPerformFeedback) == 0x000008, "Wrong alignment on GbxPlayerController_ClientPerformFeedback");
static_assert(sizeof(GbxPlayerController_ClientPerformFeedback) == 0x000010, "Wrong size on GbxPlayerController_ClientPerformFeedback");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedback, FeedbackData) == 0x000000, "Member 'GbxPlayerController_ClientPerformFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedback, SourceContext) == 0x000008, "Member 'GbxPlayerController_ClientPerformFeedback::SourceContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientPerformFeedbackAtLocation
// 0x0030 (0x0030 - 0x0000)
struct GbxPlayerController_ClientPerformFeedbackAtLocation final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedDistanceOverrides               RangedOverrides;                                   // 0x0020(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxPlayerController_ClientPerformFeedbackAtLocation) == 0x000008, "Wrong alignment on GbxPlayerController_ClientPerformFeedbackAtLocation");
static_assert(sizeof(GbxPlayerController_ClientPerformFeedbackAtLocation) == 0x000030, "Wrong size on GbxPlayerController_ClientPerformFeedbackAtLocation");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedbackAtLocation, FeedbackData) == 0x000000, "Member 'GbxPlayerController_ClientPerformFeedbackAtLocation::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedbackAtLocation, SourceLocation) == 0x000008, "Member 'GbxPlayerController_ClientPerformFeedbackAtLocation::SourceLocation' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedbackAtLocation, bLoop) == 0x000014, "Member 'GbxPlayerController_ClientPerformFeedbackAtLocation::bLoop' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedbackAtLocation, SourceContext) == 0x000018, "Member 'GbxPlayerController_ClientPerformFeedbackAtLocation::SourceContext' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPerformFeedbackAtLocation, RangedOverrides) == 0x000020, "Member 'GbxPlayerController_ClientPerformFeedbackAtLocation::RangedOverrides' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientPlayFeedback
// 0x0018 (0x0018 - 0x0000)
struct GbxPlayerController_ClientPlayFeedback final
{
public:
	class UFeedbackData*                          Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ClientPlayFeedback) == 0x000008, "Wrong alignment on GbxPlayerController_ClientPlayFeedback");
static_assert(sizeof(GbxPlayerController_ClientPlayFeedback) == 0x000018, "Wrong size on GbxPlayerController_ClientPlayFeedback");
static_assert(offsetof(GbxPlayerController_ClientPlayFeedback, Data) == 0x000000, "Member 'GbxPlayerController_ClientPlayFeedback::Data' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPlayFeedback, Scale) == 0x000008, "Member 'GbxPlayerController_ClientPlayFeedback::Scale' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPlayFeedback, bLoop) == 0x00000C, "Member 'GbxPlayerController_ClientPlayFeedback::bLoop' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_ClientPlayFeedback, SourceContext) == 0x000010, "Member 'GbxPlayerController_ClientPlayFeedback::SourceContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientPlayWwiseEvent
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_ClientPlayWwiseEvent final
{
public:
	class UWwiseEvent*                            Event;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ClientPlayWwiseEvent) == 0x000008, "Wrong alignment on GbxPlayerController_ClientPlayWwiseEvent");
static_assert(sizeof(GbxPlayerController_ClientPlayWwiseEvent) == 0x000008, "Wrong size on GbxPlayerController_ClientPlayWwiseEvent");
static_assert(offsetof(GbxPlayerController_ClientPlayWwiseEvent, Event) == 0x000000, "Member 'GbxPlayerController_ClientPlayWwiseEvent::Event' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ClientStopFeedback
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_ClientStopFeedback final
{
public:
	class UFeedbackData*                          Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ClientStopFeedback) == 0x000008, "Wrong alignment on GbxPlayerController_ClientStopFeedback");
static_assert(sizeof(GbxPlayerController_ClientStopFeedback) == 0x000008, "Wrong size on GbxPlayerController_ClientStopFeedback");
static_assert(offsetof(GbxPlayerController_ClientStopFeedback, Data) == 0x000000, "Member 'GbxPlayerController_ClientStopFeedback::Data' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.DebugCategory
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_DebugCategory final
{
public:
	class FName                                   CategoryName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_DebugCategory) == 0x000004, "Wrong alignment on GbxPlayerController_DebugCategory");
static_assert(sizeof(GbxPlayerController_DebugCategory) == 0x000008, "Wrong size on GbxPlayerController_DebugCategory");
static_assert(offsetof(GbxPlayerController_DebugCategory, CategoryName) == 0x000000, "Member 'GbxPlayerController_DebugCategory::CategoryName' has a wrong offset!");

// DelegateFunction GbxGameSystemCore.GbxPlayerController.OnPausedChangedDelegate__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct GbxPlayerController_OnPausedChangedDelegate__DelegateSignature final
{
public:
	bool                                          bPaused;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_OnPausedChangedDelegate__DelegateSignature) == 0x000001, "Wrong alignment on GbxPlayerController_OnPausedChangedDelegate__DelegateSignature");
static_assert(sizeof(GbxPlayerController_OnPausedChangedDelegate__DelegateSignature) == 0x000001, "Wrong size on GbxPlayerController_OnPausedChangedDelegate__DelegateSignature");
static_assert(offsetof(GbxPlayerController_OnPausedChangedDelegate__DelegateSignature, bPaused) == 0x000000, "Member 'GbxPlayerController_OnPausedChangedDelegate__DelegateSignature::bPaused' has a wrong offset!");

// DelegateFunction GbxGameSystemCore.GbxPlayerController.OnPrimaryCharacterChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature final
{
public:
	class AGbxCharacter*                          NewCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature) == 0x000008, "Wrong alignment on GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature");
static_assert(sizeof(GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature) == 0x000008, "Wrong size on GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature");
static_assert(offsetof(GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature, NewCharacter) == 0x000000, "Member 'GbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature::NewCharacter' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.PopCinematicMode
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_PopCinematicMode final
{
public:
	class UCinematicModeData*                     InCinematicMode;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_PopCinematicMode) == 0x000008, "Wrong alignment on GbxPlayerController_PopCinematicMode");
static_assert(sizeof(GbxPlayerController_PopCinematicMode) == 0x000008, "Wrong size on GbxPlayerController_PopCinematicMode");
static_assert(offsetof(GbxPlayerController_PopCinematicMode, InCinematicMode) == 0x000000, "Member 'GbxPlayerController_PopCinematicMode::InCinematicMode' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.PushCinematicMode
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_PushCinematicMode final
{
public:
	class UCinematicModeData*                     InCinematicMode;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_PushCinematicMode) == 0x000008, "Wrong alignment on GbxPlayerController_PushCinematicMode");
static_assert(sizeof(GbxPlayerController_PushCinematicMode) == 0x000008, "Wrong size on GbxPlayerController_PushCinematicMode");
static_assert(offsetof(GbxPlayerController_PushCinematicMode, InCinematicMode) == 0x000000, "Member 'GbxPlayerController_PushCinematicMode::InCinematicMode' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ServerCanSplitscreenJoin
// 0x0004 (0x0004 - 0x0000)
struct GbxPlayerController_ServerCanSplitscreenJoin final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ServerCanSplitscreenJoin) == 0x000004, "Wrong alignment on GbxPlayerController_ServerCanSplitscreenJoin");
static_assert(sizeof(GbxPlayerController_ServerCanSplitscreenJoin) == 0x000004, "Wrong size on GbxPlayerController_ServerCanSplitscreenJoin");
static_assert(offsetof(GbxPlayerController_ServerCanSplitscreenJoin, ControllerId) == 0x000000, "Member 'GbxPlayerController_ServerCanSplitscreenJoin::ControllerId' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.ServerRequestPawnSlotDetach
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_ServerRequestPawnSlotDetach final
{
public:
	class APawn*                                  Occupant;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_ServerRequestPawnSlotDetach) == 0x000008, "Wrong alignment on GbxPlayerController_ServerRequestPawnSlotDetach");
static_assert(sizeof(GbxPlayerController_ServerRequestPawnSlotDetach) == 0x000008, "Wrong size on GbxPlayerController_ServerRequestPawnSlotDetach");
static_assert(offsetof(GbxPlayerController_ServerRequestPawnSlotDetach, Occupant) == 0x000000, "Member 'GbxPlayerController_ServerRequestPawnSlotDetach::Occupant' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.DeprojectViewportPositionToWorld
// 0x0024 (0x0024 - 0x0000)
struct GbxPlayerController_DeprojectViewportPositionToWorld final
{
public:
	float                                         ViewportX;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewportY;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForegroundProjection;                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxPlayerController_DeprojectViewportPositionToWorld) == 0x000004, "Wrong alignment on GbxPlayerController_DeprojectViewportPositionToWorld");
static_assert(sizeof(GbxPlayerController_DeprojectViewportPositionToWorld) == 0x000024, "Wrong size on GbxPlayerController_DeprojectViewportPositionToWorld");
static_assert(offsetof(GbxPlayerController_DeprojectViewportPositionToWorld, ViewportX) == 0x000000, "Member 'GbxPlayerController_DeprojectViewportPositionToWorld::ViewportX' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_DeprojectViewportPositionToWorld, ViewportY) == 0x000004, "Member 'GbxPlayerController_DeprojectViewportPositionToWorld::ViewportY' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_DeprojectViewportPositionToWorld, WorldLocation) == 0x000008, "Member 'GbxPlayerController_DeprojectViewportPositionToWorld::WorldLocation' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_DeprojectViewportPositionToWorld, WorldDirection) == 0x000014, "Member 'GbxPlayerController_DeprojectViewportPositionToWorld::WorldDirection' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_DeprojectViewportPositionToWorld, bUseForegroundProjection) == 0x000020, "Member 'GbxPlayerController_DeprojectViewportPositionToWorld::bUseForegroundProjection' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_DeprojectViewportPositionToWorld, ReturnValue) == 0x000021, "Member 'GbxPlayerController_DeprojectViewportPositionToWorld::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetGbxPerceptionComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetGbxPerceptionComponent final
{
public:
	class UGbxPerceptionComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetGbxPerceptionComponent) == 0x000008, "Wrong alignment on GbxPlayerController_GetGbxPerceptionComponent");
static_assert(sizeof(GbxPlayerController_GetGbxPerceptionComponent) == 0x000008, "Wrong size on GbxPlayerController_GetGbxPerceptionComponent");
static_assert(offsetof(GbxPlayerController_GetGbxPerceptionComponent, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetGbxPerceptionComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetPlayerProfile
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetPlayerProfile final
{
public:
	class UGbxProfile*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetPlayerProfile) == 0x000008, "Wrong alignment on GbxPlayerController_GetPlayerProfile");
static_assert(sizeof(GbxPlayerController_GetPlayerProfile) == 0x000008, "Wrong size on GbxPlayerController_GetPlayerProfile");
static_assert(offsetof(GbxPlayerController_GetPlayerProfile, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetPlayerProfile::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetPlayerViewportOffset
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetPlayerViewportOffset final
{
public:
	int32                                         OffsetX;                                           // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OffsetY;                                           // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetPlayerViewportOffset) == 0x000004, "Wrong alignment on GbxPlayerController_GetPlayerViewportOffset");
static_assert(sizeof(GbxPlayerController_GetPlayerViewportOffset) == 0x000008, "Wrong size on GbxPlayerController_GetPlayerViewportOffset");
static_assert(offsetof(GbxPlayerController_GetPlayerViewportOffset, OffsetX) == 0x000000, "Member 'GbxPlayerController_GetPlayerViewportOffset::OffsetX' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_GetPlayerViewportOffset, OffsetY) == 0x000004, "Member 'GbxPlayerController_GetPlayerViewportOffset::OffsetY' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetPlayerViewportSize
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetPlayerViewportSize final
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetPlayerViewportSize) == 0x000004, "Wrong alignment on GbxPlayerController_GetPlayerViewportSize");
static_assert(sizeof(GbxPlayerController_GetPlayerViewportSize) == 0x000008, "Wrong size on GbxPlayerController_GetPlayerViewportSize");
static_assert(offsetof(GbxPlayerController_GetPlayerViewportSize, SizeX) == 0x000000, "Member 'GbxPlayerController_GetPlayerViewportSize::SizeX' has a wrong offset!");
static_assert(offsetof(GbxPlayerController_GetPlayerViewportSize, SizeY) == 0x000004, "Member 'GbxPlayerController_GetPlayerViewportSize::SizeY' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetPrimaryCharacter
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetPrimaryCharacter final
{
public:
	class AGbxCharacter*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetPrimaryCharacter) == 0x000008, "Wrong alignment on GbxPlayerController_GetPrimaryCharacter");
static_assert(sizeof(GbxPlayerController_GetPrimaryCharacter) == 0x000008, "Wrong size on GbxPlayerController_GetPrimaryCharacter");
static_assert(offsetof(GbxPlayerController_GetPrimaryCharacter, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetPrimaryCharacter::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetTargetableComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetTargetableComponent final
{
public:
	class UTargetableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetTargetableComponent) == 0x000008, "Wrong alignment on GbxPlayerController_GetTargetableComponent");
static_assert(sizeof(GbxPlayerController_GetTargetableComponent) == 0x000008, "Wrong size on GbxPlayerController_GetTargetableComponent");
static_assert(offsetof(GbxPlayerController_GetTargetableComponent, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetTargetableComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetTargetingComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetTargetingComponent final
{
public:
	class UTargetingComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetTargetingComponent) == 0x000008, "Wrong alignment on GbxPlayerController_GetTargetingComponent");
static_assert(sizeof(GbxPlayerController_GetTargetingComponent) == 0x000008, "Wrong size on GbxPlayerController_GetTargetingComponent");
static_assert(offsetof(GbxPlayerController_GetTargetingComponent, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetTargetingComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetTeam
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetTeam final
{
public:
	class UTeam*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetTeam) == 0x000008, "Wrong alignment on GbxPlayerController_GetTeam");
static_assert(sizeof(GbxPlayerController_GetTeam) == 0x000008, "Wrong size on GbxPlayerController_GetTeam");
static_assert(offsetof(GbxPlayerController_GetTeam, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetTeam::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.GetTeamComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_GetTeamComponent final
{
public:
	class UTeamComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_GetTeamComponent) == 0x000008, "Wrong alignment on GbxPlayerController_GetTeamComponent");
static_assert(sizeof(GbxPlayerController_GetTeamComponent) == 0x000008, "Wrong size on GbxPlayerController_GetTeamComponent");
static_assert(offsetof(GbxPlayerController_GetTeamComponent, ReturnValue) == 0x000000, "Member 'GbxPlayerController_GetTeamComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.IsUsingGamepad
// 0x0001 (0x0001 - 0x0000)
struct GbxPlayerController_IsUsingGamepad final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_IsUsingGamepad) == 0x000001, "Wrong alignment on GbxPlayerController_IsUsingGamepad");
static_assert(sizeof(GbxPlayerController_IsUsingGamepad) == 0x000001, "Wrong size on GbxPlayerController_IsUsingGamepad");
static_assert(offsetof(GbxPlayerController_IsUsingGamepad, ReturnValue) == 0x000000, "Member 'GbxPlayerController_IsUsingGamepad::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPlayerController.SetTeam
// 0x0008 (0x0008 - 0x0000)
struct GbxPlayerController_SetTeam final
{
public:
	class UTeam*                                  Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPlayerController_SetTeam) == 0x000008, "Wrong alignment on GbxPlayerController_SetTeam");
static_assert(sizeof(GbxPlayerController_SetTeam) == 0x000008, "Wrong size on GbxPlayerController_SetTeam");
static_assert(offsetof(GbxPlayerController_SetTeam, Team) == 0x000000, "Member 'GbxPlayerController_SetTeam::Team' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoActor
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFacingInfo                            ReturnValue;                                       // 0x0008(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoActor) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoActor");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoActor) == 0x000048, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoActor");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoActor, Actor) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoActor::Actor' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoActor, ReturnValue) == 0x000008, "Member 'GbxCharacterMovementComponent_MakeFacingInfoActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoActorEyes
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoActorEyes final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFacingInfo                            ReturnValue;                                       // 0x0008(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoActorEyes) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoActorEyes");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoActorEyes) == 0x000048, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoActorEyes");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoActorEyes, Actor) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoActorEyes::Actor' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoActorEyes, ReturnValue) == 0x000008, "Member 'GbxCharacterMovementComponent_MakeFacingInfoActorEyes::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoComponent
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoComponent final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFacingInfo                            ReturnValue;                                       // 0x0008(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoComponent) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoComponent");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoComponent) == 0x000048, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoComponent");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoComponent, Component) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoComponent::Component' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoComponent, ReturnValue) == 0x000008, "Member 'GbxCharacterMovementComponent_MakeFacingInfoComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoDirection
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoDirection final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFacingInfo                            ReturnValue;                                       // 0x000C(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoDirection) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoDirection");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoDirection) == 0x000048, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoDirection");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoDirection, Direction) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoDirection::Direction' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoDirection, ReturnValue) == 0x00000C, "Member 'GbxCharacterMovementComponent_MakeFacingInfoDirection::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoLocation
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFacingInfo                            ReturnValue;                                       // 0x000C(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoLocation) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoLocation");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoLocation) == 0x000048, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoLocation");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoLocation, Location) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoLocation::Location' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoLocation, ReturnValue) == 0x00000C, "Member 'GbxCharacterMovementComponent_MakeFacingInfoLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoNone
// 0x003C (0x003C - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoNone final
{
public:
	struct FFacingInfo                            ReturnValue;                                       // 0x0000(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoNone) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoNone");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoNone) == 0x00003C, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoNone");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoNone, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoNone::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoRotation
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_MakeFacingInfoRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FFacingInfo                            ReturnValue;                                       // 0x000C(0x003C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_MakeFacingInfoRotation) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_MakeFacingInfoRotation");
static_assert(sizeof(GbxCharacterMovementComponent_MakeFacingInfoRotation) == 0x000048, "Wrong size on GbxCharacterMovementComponent_MakeFacingInfoRotation");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoRotation, Rotation) == 0x000000, "Member 'GbxCharacterMovementComponent_MakeFacingInfoRotation::Rotation' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_MakeFacingInfoRotation, ReturnValue) == 0x00000C, "Member 'GbxCharacterMovementComponent_MakeFacingInfoRotation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.ClientAdjustControlledMovePosition
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_ClientAdjustControlledMovePosition final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlledMoveNetCorrection           ServerCMData;                                      // 0x0008(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                NewLoc;                                            // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewVel;                                            // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    NewBase;                                           // 0x0030(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewBaseBoneName;                                   // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBase;                                          // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseRelativePosition;                             // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ServerMovementMode;                                // 0x0042(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_ClientAdjustControlledMovePosition");
static_assert(sizeof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition) == 0x000048, "Wrong size on GbxCharacterMovementComponent_ClientAdjustControlledMovePosition");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, Timestamp) == 0x000000, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::Timestamp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, ServerCMData) == 0x000008, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::ServerCMData' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, NewLoc) == 0x000018, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::NewLoc' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, NewVel) == 0x000024, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::NewVel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, NewBase) == 0x000030, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::NewBase' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, NewBaseBoneName) == 0x000038, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::NewBaseBoneName' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, bHasBase) == 0x000040, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::bHasBase' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, bBaseRelativePosition) == 0x000041, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::bBaseRelativePosition' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ClientAdjustControlledMovePosition, ServerMovementMode) == 0x000042, "Member 'GbxCharacterMovementComponent_ClientAdjustControlledMovePosition::ServerMovementMode' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMove
// 0x0048 (0x0048 - 0x0000)
struct GbxCharacterMovementComponent_ControlledServerMove final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x0004(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0010(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CompressedMoveFlags;                               // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CMDir;                                             // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ClientBodyYaw;                                     // 0x0040(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_ControlledServerMove) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_ControlledServerMove");
static_assert(sizeof(GbxCharacterMovementComponent_ControlledServerMove) == 0x000048, "Wrong size on GbxCharacterMovementComponent_ControlledServerMove");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, Timestamp) == 0x000000, "Member 'GbxCharacterMovementComponent_ControlledServerMove::Timestamp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, InAccel) == 0x000004, "Member 'GbxCharacterMovementComponent_ControlledServerMove::InAccel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, ClientLoc) == 0x000010, "Member 'GbxCharacterMovementComponent_ControlledServerMove::ClientLoc' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, CompressedMoveFlags) == 0x00001C, "Member 'GbxCharacterMovementComponent_ControlledServerMove::CompressedMoveFlags' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, ClientRoll) == 0x00001D, "Member 'GbxCharacterMovementComponent_ControlledServerMove::ClientRoll' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, View) == 0x000020, "Member 'GbxCharacterMovementComponent_ControlledServerMove::View' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, ClientMovementBase) == 0x000028, "Member 'GbxCharacterMovementComponent_ControlledServerMove::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, ClientBaseBoneName) == 0x000030, "Member 'GbxCharacterMovementComponent_ControlledServerMove::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, ClientMovementMode) == 0x000038, "Member 'GbxCharacterMovementComponent_ControlledServerMove::ClientMovementMode' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, CMDir) == 0x00003C, "Member 'GbxCharacterMovementComponent_ControlledServerMove::CMDir' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMove, ClientBodyYaw) == 0x000040, "Member 'GbxCharacterMovementComponent_ControlledServerMove::ClientBodyYaw' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMoveDual
// 0x0060 (0x0060 - 0x0000)
struct GbxCharacterMovementComponent_ControlledServerMoveDual final
{
public:
	float                                         TimeStamp0;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel0;                                          // 0x0004(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PendingFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View0;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CMDir0;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x0020(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x002C(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewFlags;                                          // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0040(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CMDir;                                             // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ClientBodyYaw;                                     // 0x0058(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_ControlledServerMoveDual) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_ControlledServerMoveDual");
static_assert(sizeof(GbxCharacterMovementComponent_ControlledServerMoveDual) == 0x000060, "Wrong size on GbxCharacterMovementComponent_ControlledServerMoveDual");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, TimeStamp0) == 0x000000, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::TimeStamp0' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, InAccel0) == 0x000004, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::InAccel0' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, PendingFlags) == 0x000010, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::PendingFlags' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, View0) == 0x000014, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::View0' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, CMDir0) == 0x000018, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::CMDir0' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, Timestamp) == 0x00001C, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::Timestamp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, InAccel) == 0x000020, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::InAccel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, ClientLoc) == 0x00002C, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::ClientLoc' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, NewFlags) == 0x000038, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::NewFlags' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, ClientRoll) == 0x000039, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::ClientRoll' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, View) == 0x00003C, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::View' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, ClientMovementBase) == 0x000040, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, ClientBaseBoneName) == 0x000048, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, ClientMovementMode) == 0x000050, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::ClientMovementMode' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, CMDir) == 0x000054, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::CMDir' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveDual, ClientBodyYaw) == 0x000058, "Member 'GbxCharacterMovementComponent_ControlledServerMoveDual::ClientBodyYaw' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMoveOld
// 0x0018 (0x0018 - 0x0000)
struct GbxCharacterMovementComponent_ControlledServerMoveOld final
{
public:
	float                                         OldTimeStamp;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  OldAccel;                                          // 0x0004(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OldMoveFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CMDir;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_ControlledServerMoveOld) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_ControlledServerMoveOld");
static_assert(sizeof(GbxCharacterMovementComponent_ControlledServerMoveOld) == 0x000018, "Wrong size on GbxCharacterMovementComponent_ControlledServerMoveOld");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveOld, OldTimeStamp) == 0x000000, "Member 'GbxCharacterMovementComponent_ControlledServerMoveOld::OldTimeStamp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveOld, OldAccel) == 0x000004, "Member 'GbxCharacterMovementComponent_ControlledServerMoveOld::OldAccel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveOld, OldMoveFlags) == 0x000010, "Member 'GbxCharacterMovementComponent_ControlledServerMoveOld::OldMoveFlags' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ControlledServerMoveOld, CMDir) == 0x000014, "Member 'GbxCharacterMovementComponent_ControlledServerMoveOld::CMDir' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GbxSetAnimInstanceClass
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_GbxSetAnimInstanceClass final
{
public:
	class USkeletalMeshComponent*                 SkelMeshComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 NewClass;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GbxSetAnimInstanceClass) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_GbxSetAnimInstanceClass");
static_assert(sizeof(GbxCharacterMovementComponent_GbxSetAnimInstanceClass) == 0x000010, "Wrong size on GbxCharacterMovementComponent_GbxSetAnimInstanceClass");
static_assert(offsetof(GbxCharacterMovementComponent_GbxSetAnimInstanceClass, SkelMeshComponent) == 0x000000, "Member 'GbxCharacterMovementComponent_GbxSetAnimInstanceClass::SkelMeshComponent' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_GbxSetAnimInstanceClass, NewClass) == 0x000008, "Member 'GbxCharacterMovementComponent_GbxSetAnimInstanceClass::NewClass' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.LeaveNoneWithRootMotionMode
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode final
{
public:
	bool                                          bApplyDefault;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode");
static_assert(sizeof(GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode) == 0x000001, "Wrong size on GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode");
static_assert(offsetof(GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode, bApplyDefault) == 0x000000, "Member 'GbxCharacterMovementComponent_LeaveNoneWithRootMotionMode::bApplyDefault' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.OnCapsuleBeginOverlap
// 0x00B0 (0x00B0 - 0x0000)
struct GbxCharacterMovementComponent_OnCapsuleBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_OnCapsuleBeginOverlap");
static_assert(sizeof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap) == 0x0000B0, "Wrong size on GbxCharacterMovementComponent_OnCapsuleBeginOverlap");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap, OverlappedComp) == 0x000000, "Member 'GbxCharacterMovementComponent_OnCapsuleBeginOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap, OtherActor) == 0x000008, "Member 'GbxCharacterMovementComponent_OnCapsuleBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap, OtherComp) == 0x000010, "Member 'GbxCharacterMovementComponent_OnCapsuleBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap, OtherBodyIndex) == 0x000018, "Member 'GbxCharacterMovementComponent_OnCapsuleBeginOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap, bFromSweep) == 0x00001C, "Member 'GbxCharacterMovementComponent_OnCapsuleBeginOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleBeginOverlap, SweepResult) == 0x000020, "Member 'GbxCharacterMovementComponent_OnCapsuleBeginOverlap::SweepResult' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.OnCapsuleEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct GbxCharacterMovementComponent_OnCapsuleEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_OnCapsuleEndOverlap) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_OnCapsuleEndOverlap");
static_assert(sizeof(GbxCharacterMovementComponent_OnCapsuleEndOverlap) == 0x000020, "Wrong size on GbxCharacterMovementComponent_OnCapsuleEndOverlap");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleEndOverlap, OverlappedComp) == 0x000000, "Member 'GbxCharacterMovementComponent_OnCapsuleEndOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleEndOverlap, OtherActor) == 0x000008, "Member 'GbxCharacterMovementComponent_OnCapsuleEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleEndOverlap, OtherComp) == 0x000010, "Member 'GbxCharacterMovementComponent_OnCapsuleEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_OnCapsuleEndOverlap, OtherBodyIndex) == 0x000018, "Member 'GbxCharacterMovementComponent_OnCapsuleEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.OnStanceChanged
// 0x0030 (0x0030 - 0x0000)
struct GbxCharacterMovementComponent_OnStanceChanged final
{
public:
	struct FStanceChangedEventArgs                Args;                                              // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_OnStanceChanged) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_OnStanceChanged");
static_assert(sizeof(GbxCharacterMovementComponent_OnStanceChanged) == 0x000030, "Wrong size on GbxCharacterMovementComponent_OnStanceChanged");
static_assert(offsetof(GbxCharacterMovementComponent_OnStanceChanged, Args) == 0x000000, "Member 'GbxCharacterMovementComponent_OnStanceChanged::Args' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerAttemptMantle
// 0x0020 (0x0020 - 0x0000)
struct GbxCharacterMovementComponent_ServerAttemptMantle final
{
public:
	struct FMantleAttemptInfo                     ClientData;                                        // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_ServerAttemptMantle) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_ServerAttemptMantle");
static_assert(sizeof(GbxCharacterMovementComponent_ServerAttemptMantle) == 0x000020, "Wrong size on GbxCharacterMovementComponent_ServerAttemptMantle");
static_assert(offsetof(GbxCharacterMovementComponent_ServerAttemptMantle, ClientData) == 0x000000, "Member 'GbxCharacterMovementComponent_ServerAttemptMantle::ClientData' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_ServerAttemptMantle, Timestamp) == 0x000018, "Member 'GbxCharacterMovementComponent_ServerAttemptMantle::Timestamp' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerStartMoveTo
// 0x001C (0x001C - 0x0000)
struct GbxCharacterMovementComponent_ServerStartMoveTo final
{
public:
	struct FCharacterMoveToCommand                MoveToCommand;                                     // 0x0000(0x001C)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_ServerStartMoveTo) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_ServerStartMoveTo");
static_assert(sizeof(GbxCharacterMovementComponent_ServerStartMoveTo) == 0x00001C, "Wrong size on GbxCharacterMovementComponent_ServerStartMoveTo");
static_assert(offsetof(GbxCharacterMovementComponent_ServerStartMoveTo, MoveToCommand) == 0x000000, "Member 'GbxCharacterMovementComponent_ServerStartMoveTo::MoveToCommand' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.SetAnimationBasedTurning
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_SetAnimationBasedTurning final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_SetAnimationBasedTurning) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_SetAnimationBasedTurning");
static_assert(sizeof(GbxCharacterMovementComponent_SetAnimationBasedTurning) == 0x000001, "Wrong size on GbxCharacterMovementComponent_SetAnimationBasedTurning");
static_assert(offsetof(GbxCharacterMovementComponent_SetAnimationBasedTurning, bEnable) == 0x000000, "Member 'GbxCharacterMovementComponent_SetAnimationBasedTurning::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.SetFacingTarget
// 0x0040 (0x0040 - 0x0000)
struct GbxCharacterMovementComponent_SetFacingTarget final
{
public:
	struct FFacingInfo                            FacingTarget;                                      // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacingChannel                                Channel;                                           // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_SetFacingTarget) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_SetFacingTarget");
static_assert(sizeof(GbxCharacterMovementComponent_SetFacingTarget) == 0x000040, "Wrong size on GbxCharacterMovementComponent_SetFacingTarget");
static_assert(offsetof(GbxCharacterMovementComponent_SetFacingTarget, FacingTarget) == 0x000000, "Member 'GbxCharacterMovementComponent_SetFacingTarget::FacingTarget' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_SetFacingTarget, Channel) == 0x00003C, "Member 'GbxCharacterMovementComponent_SetFacingTarget::Channel' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.SetNoneWithRootMotionMode
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_SetNoneWithRootMotionMode final
{
public:
	bool                                          bAnimationWalking;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_SetNoneWithRootMotionMode) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_SetNoneWithRootMotionMode");
static_assert(sizeof(GbxCharacterMovementComponent_SetNoneWithRootMotionMode) == 0x000010, "Wrong size on GbxCharacterMovementComponent_SetNoneWithRootMotionMode");
static_assert(offsetof(GbxCharacterMovementComponent_SetNoneWithRootMotionMode, bAnimationWalking) == 0x000000, "Member 'GbxCharacterMovementComponent_SetNoneWithRootMotionMode::bAnimationWalking' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_SetNoneWithRootMotionMode, Reason) == 0x000008, "Member 'GbxCharacterMovementComponent_SetNoneWithRootMotionMode::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.SetPendingRawInputVector
// 0x000C (0x000C - 0x0000)
struct GbxCharacterMovementComponent_SetPendingRawInputVector final
{
public:
	struct FVector                                NewInputVector;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_SetPendingRawInputVector) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_SetPendingRawInputVector");
static_assert(sizeof(GbxCharacterMovementComponent_SetPendingRawInputVector) == 0x00000C, "Wrong size on GbxCharacterMovementComponent_SetPendingRawInputVector");
static_assert(offsetof(GbxCharacterMovementComponent_SetPendingRawInputVector, NewInputVector) == 0x000000, "Member 'GbxCharacterMovementComponent_SetPendingRawInputVector::NewInputVector' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.StartControlledMove
// 0x0038 (0x0038 - 0x0000)
struct GbxCharacterMovementComponent_StartControlledMove final
{
public:
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedOverride;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAngleOverride;                               // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_StartControlledMove) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_StartControlledMove");
static_assert(sizeof(GbxCharacterMovementComponent_StartControlledMove) == 0x000038, "Wrong size on GbxCharacterMovementComponent_StartControlledMove");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, ControlledMove) == 0x000000, "Member 'GbxCharacterMovementComponent_StartControlledMove::ControlledMove' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, Instigator) == 0x000008, "Member 'GbxCharacterMovementComponent_StartControlledMove::Instigator' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, SpeedOverride) == 0x000010, "Member 'GbxCharacterMovementComponent_StartControlledMove::SpeedOverride' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, DurationOverride) == 0x000014, "Member 'GbxCharacterMovementComponent_StartControlledMove::DurationOverride' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, LaunchAngleOverride) == 0x000018, "Member 'GbxCharacterMovementComponent_StartControlledMove::LaunchAngleOverride' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, TargetActor) == 0x000020, "Member 'GbxCharacterMovementComponent_StartControlledMove::TargetActor' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, TargetLocation) == 0x000028, "Member 'GbxCharacterMovementComponent_StartControlledMove::TargetLocation' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StartControlledMove, ReturnValue) == 0x000034, "Member 'GbxCharacterMovementComponent_StartControlledMove::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.StartMoveTo
// 0x001C (0x001C - 0x0000)
struct GbxCharacterMovementComponent_StartMoveTo final
{
public:
	struct FCharacterMoveToCommand                MoveToCommand;                                     // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_StartMoveTo) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_StartMoveTo");
static_assert(sizeof(GbxCharacterMovementComponent_StartMoveTo) == 0x00001C, "Wrong size on GbxCharacterMovementComponent_StartMoveTo");
static_assert(offsetof(GbxCharacterMovementComponent_StartMoveTo, MoveToCommand) == 0x000000, "Member 'GbxCharacterMovementComponent_StartMoveTo::MoveToCommand' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.StartRotateTo
// 0x0050 (0x0050 - 0x0000)
struct GbxCharacterMovementComponent_StartRotateTo final
{
public:
	struct FCharacterRotateToCommand              RotateToCommand;                                   // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_StartRotateTo) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_StartRotateTo");
static_assert(sizeof(GbxCharacterMovementComponent_StartRotateTo) == 0x000050, "Wrong size on GbxCharacterMovementComponent_StartRotateTo");
static_assert(offsetof(GbxCharacterMovementComponent_StartRotateTo, RotateToCommand) == 0x000000, "Member 'GbxCharacterMovementComponent_StartRotateTo::RotateToCommand' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.StopControlledMove
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_StopControlledMove final
{
public:
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZeroVelocity;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_StopControlledMove) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_StopControlledMove");
static_assert(sizeof(GbxCharacterMovementComponent_StopControlledMove) == 0x000010, "Wrong size on GbxCharacterMovementComponent_StopControlledMove");
static_assert(offsetof(GbxCharacterMovementComponent_StopControlledMove, ControlledMove) == 0x000000, "Member 'GbxCharacterMovementComponent_StopControlledMove::ControlledMove' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StopControlledMove, bZeroVelocity) == 0x000008, "Member 'GbxCharacterMovementComponent_StopControlledMove::bZeroVelocity' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StopControlledMove, bInterrupted) == 0x000009, "Member 'GbxCharacterMovementComponent_StopControlledMove::bInterrupted' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.StopMoveTo
// 0x0002 (0x0002 - 0x0000)
struct GbxCharacterMovementComponent_StopMoveTo final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateStop;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_StopMoveTo) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_StopMoveTo");
static_assert(sizeof(GbxCharacterMovementComponent_StopMoveTo) == 0x000002, "Wrong size on GbxCharacterMovementComponent_StopMoveTo");
static_assert(offsetof(GbxCharacterMovementComponent_StopMoveTo, bForce) == 0x000000, "Member 'GbxCharacterMovementComponent_StopMoveTo::bForce' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_StopMoveTo, bReplicateStop) == 0x000001, "Member 'GbxCharacterMovementComponent_StopMoveTo::bReplicateStop' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.CanStartMantle
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_CanStartMantle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_CanStartMantle) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_CanStartMantle");
static_assert(sizeof(GbxCharacterMovementComponent_CanStartMantle) == 0x000001, "Wrong size on GbxCharacterMovementComponent_CanStartMantle");
static_assert(offsetof(GbxCharacterMovementComponent_CanStartMantle, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_CanStartMantle::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.CanStartPassiveMantle
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_CanStartPassiveMantle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_CanStartPassiveMantle) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_CanStartPassiveMantle");
static_assert(sizeof(GbxCharacterMovementComponent_CanStartPassiveMantle) == 0x000001, "Wrong size on GbxCharacterMovementComponent_CanStartPassiveMantle");
static_assert(offsetof(GbxCharacterMovementComponent_CanStartPassiveMantle, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_CanStartPassiveMantle::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingLocation
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_GetCurrentFacingLocation final
{
public:
	EFacingChannel                                Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetCurrentFacingLocation) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_GetCurrentFacingLocation");
static_assert(sizeof(GbxCharacterMovementComponent_GetCurrentFacingLocation) == 0x000010, "Wrong size on GbxCharacterMovementComponent_GetCurrentFacingLocation");
static_assert(offsetof(GbxCharacterMovementComponent_GetCurrentFacingLocation, Channel) == 0x000000, "Member 'GbxCharacterMovementComponent_GetCurrentFacingLocation::Channel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_GetCurrentFacingLocation, ReturnValue) == 0x000004, "Member 'GbxCharacterMovementComponent_GetCurrentFacingLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingOrigin
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_GetCurrentFacingOrigin final
{
public:
	EFacingChannel                                Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetCurrentFacingOrigin) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_GetCurrentFacingOrigin");
static_assert(sizeof(GbxCharacterMovementComponent_GetCurrentFacingOrigin) == 0x000010, "Wrong size on GbxCharacterMovementComponent_GetCurrentFacingOrigin");
static_assert(offsetof(GbxCharacterMovementComponent_GetCurrentFacingOrigin, Channel) == 0x000000, "Member 'GbxCharacterMovementComponent_GetCurrentFacingOrigin::Channel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_GetCurrentFacingOrigin, ReturnValue) == 0x000004, "Member 'GbxCharacterMovementComponent_GetCurrentFacingOrigin::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingRotation
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_GetCurrentFacingRotation final
{
public:
	EFacingChannel                                Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetCurrentFacingRotation) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_GetCurrentFacingRotation");
static_assert(sizeof(GbxCharacterMovementComponent_GetCurrentFacingRotation) == 0x000010, "Wrong size on GbxCharacterMovementComponent_GetCurrentFacingRotation");
static_assert(offsetof(GbxCharacterMovementComponent_GetCurrentFacingRotation, Channel) == 0x000000, "Member 'GbxCharacterMovementComponent_GetCurrentFacingRotation::Channel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_GetCurrentFacingRotation, ReturnValue) == 0x000004, "Member 'GbxCharacterMovementComponent_GetCurrentFacingRotation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetDesiredFacingLocation
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_GetDesiredFacingLocation final
{
public:
	EFacingChannel                                Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetDesiredFacingLocation) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_GetDesiredFacingLocation");
static_assert(sizeof(GbxCharacterMovementComponent_GetDesiredFacingLocation) == 0x000010, "Wrong size on GbxCharacterMovementComponent_GetDesiredFacingLocation");
static_assert(offsetof(GbxCharacterMovementComponent_GetDesiredFacingLocation, Channel) == 0x000000, "Member 'GbxCharacterMovementComponent_GetDesiredFacingLocation::Channel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_GetDesiredFacingLocation, ReturnValue) == 0x000004, "Member 'GbxCharacterMovementComponent_GetDesiredFacingLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetDesiredFacingRotation
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_GetDesiredFacingRotation final
{
public:
	EFacingChannel                                Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetDesiredFacingRotation) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_GetDesiredFacingRotation");
static_assert(sizeof(GbxCharacterMovementComponent_GetDesiredFacingRotation) == 0x000010, "Wrong size on GbxCharacterMovementComponent_GetDesiredFacingRotation");
static_assert(offsetof(GbxCharacterMovementComponent_GetDesiredFacingRotation, Channel) == 0x000000, "Member 'GbxCharacterMovementComponent_GetDesiredFacingRotation::Channel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_GetDesiredFacingRotation, ReturnValue) == 0x000004, "Member 'GbxCharacterMovementComponent_GetDesiredFacingRotation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetMantleData
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacterMovementComponent_GetMantleData final
{
public:
	class UMantleData*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetMantleData) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_GetMantleData");
static_assert(sizeof(GbxCharacterMovementComponent_GetMantleData) == 0x000008, "Wrong size on GbxCharacterMovementComponent_GetMantleData");
static_assert(offsetof(GbxCharacterMovementComponent_GetMantleData, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_GetMantleData::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.GetMaxAllowedAimOffset
// 0x0004 (0x0004 - 0x0000)
struct GbxCharacterMovementComponent_GetMaxAllowedAimOffset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_GetMaxAllowedAimOffset) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_GetMaxAllowedAimOffset");
static_assert(sizeof(GbxCharacterMovementComponent_GetMaxAllowedAimOffset) == 0x000004, "Wrong size on GbxCharacterMovementComponent_GetMaxAllowedAimOffset");
static_assert(offsetof(GbxCharacterMovementComponent_GetMaxAllowedAimOffset, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_GetMaxAllowedAimOffset::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFacingTargetBP
// 0x0008 (0x0008 - 0x0000)
struct GbxCharacterMovementComponent_IsFacingTargetBP final
{
public:
	float                                         ThresholdDegrees;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacingChannel                                Channel;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_IsFacingTargetBP) == 0x000004, "Wrong alignment on GbxCharacterMovementComponent_IsFacingTargetBP");
static_assert(sizeof(GbxCharacterMovementComponent_IsFacingTargetBP) == 0x000008, "Wrong size on GbxCharacterMovementComponent_IsFacingTargetBP");
static_assert(offsetof(GbxCharacterMovementComponent_IsFacingTargetBP, ThresholdDegrees) == 0x000000, "Member 'GbxCharacterMovementComponent_IsFacingTargetBP::ThresholdDegrees' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_IsFacingTargetBP, Channel) == 0x000004, "Member 'GbxCharacterMovementComponent_IsFacingTargetBP::Channel' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_IsFacingTargetBP, ReturnValue) == 0x000005, "Member 'GbxCharacterMovementComponent_IsFacingTargetBP::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFootIkEnabled
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsFootIkEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsFootIkEnabled) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsFootIkEnabled");
static_assert(sizeof(GbxCharacterMovementComponent_IsFootIkEnabled) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsFootIkEnabled");
static_assert(offsetof(GbxCharacterMovementComponent_IsFootIkEnabled, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsFootIkEnabled::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFootIkTracingEnabled
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsFootIkTracingEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsFootIkTracingEnabled) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsFootIkTracingEnabled");
static_assert(sizeof(GbxCharacterMovementComponent_IsFootIkTracingEnabled) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsFootIkTracingEnabled");
static_assert(offsetof(GbxCharacterMovementComponent_IsFootIkTracingEnabled, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsFootIkTracingEnabled::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsHandIkEnabled
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsHandIkEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsHandIkEnabled) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsHandIkEnabled");
static_assert(sizeof(GbxCharacterMovementComponent_IsHandIkEnabled) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsHandIkEnabled");
static_assert(offsetof(GbxCharacterMovementComponent_IsHandIkEnabled, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsHandIkEnabled::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsInNoneWithRootMotionMode
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsInNoneWithRootMotionMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsInNoneWithRootMotionMode) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsInNoneWithRootMotionMode");
static_assert(sizeof(GbxCharacterMovementComponent_IsInNoneWithRootMotionMode) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsInNoneWithRootMotionMode");
static_assert(offsetof(GbxCharacterMovementComponent_IsInNoneWithRootMotionMode, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsInNoneWithRootMotionMode::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMantling
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsMantling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsMantling) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsMantling");
static_assert(sizeof(GbxCharacterMovementComponent_IsMantling) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsMantling");
static_assert(offsetof(GbxCharacterMovementComponent_IsMantling, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsMantling::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMantlingAllowed
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsMantlingAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsMantlingAllowed) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsMantlingAllowed");
static_assert(sizeof(GbxCharacterMovementComponent_IsMantlingAllowed) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsMantlingAllowed");
static_assert(offsetof(GbxCharacterMovementComponent_IsMantlingAllowed, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsMantlingAllowed::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMovingOnLadder
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsMovingOnLadder final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsMovingOnLadder) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsMovingOnLadder");
static_assert(sizeof(GbxCharacterMovementComponent_IsMovingOnLadder) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsMovingOnLadder");
static_assert(offsetof(GbxCharacterMovementComponent_IsMovingOnLadder, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsMovingOnLadder::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsPerformingControlledMove
// 0x0001 (0x0001 - 0x0000)
struct GbxCharacterMovementComponent_IsPerformingControlledMove final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCharacterMovementComponent_IsPerformingControlledMove) == 0x000001, "Wrong alignment on GbxCharacterMovementComponent_IsPerformingControlledMove");
static_assert(sizeof(GbxCharacterMovementComponent_IsPerformingControlledMove) == 0x000001, "Wrong size on GbxCharacterMovementComponent_IsPerformingControlledMove");
static_assert(offsetof(GbxCharacterMovementComponent_IsPerformingControlledMove, ReturnValue) == 0x000000, "Member 'GbxCharacterMovementComponent_IsPerformingControlledMove::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCharacterMovementComponent.IsPerformingSpecificControlledMove
// 0x0010 (0x0010 - 0x0000)
struct GbxCharacterMovementComponent_IsPerformingSpecificControlledMove final
{
public:
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCharacterMovementComponent_IsPerformingSpecificControlledMove) == 0x000008, "Wrong alignment on GbxCharacterMovementComponent_IsPerformingSpecificControlledMove");
static_assert(sizeof(GbxCharacterMovementComponent_IsPerformingSpecificControlledMove) == 0x000010, "Wrong size on GbxCharacterMovementComponent_IsPerformingSpecificControlledMove");
static_assert(offsetof(GbxCharacterMovementComponent_IsPerformingSpecificControlledMove, ControlledMove) == 0x000000, "Member 'GbxCharacterMovementComponent_IsPerformingSpecificControlledMove::ControlledMove' has a wrong offset!");
static_assert(offsetof(GbxCharacterMovementComponent_IsPerformingSpecificControlledMove, ReturnValue) == 0x000008, "Member 'GbxCharacterMovementComponent_IsPerformingSpecificControlledMove::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelActorComponent.GetAssociatedActor
// 0x0008 (0x0008 - 0x0000)
struct ChallengeLevelActorComponent_GetAssociatedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelActorComponent_GetAssociatedActor) == 0x000008, "Wrong alignment on ChallengeLevelActorComponent_GetAssociatedActor");
static_assert(sizeof(ChallengeLevelActorComponent_GetAssociatedActor) == 0x000008, "Wrong size on ChallengeLevelActorComponent_GetAssociatedActor");
static_assert(offsetof(ChallengeLevelActorComponent_GetAssociatedActor, ReturnValue) == 0x000000, "Member 'ChallengeLevelActorComponent_GetAssociatedActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_InWorldIconEnabled
// 0x0001 (0x0001 - 0x0000)
struct ChallengeLevelActorComponent_OnRep_InWorldIconEnabled final
{
public:
	bool                                          bOldEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelActorComponent_OnRep_InWorldIconEnabled) == 0x000001, "Wrong alignment on ChallengeLevelActorComponent_OnRep_InWorldIconEnabled");
static_assert(sizeof(ChallengeLevelActorComponent_OnRep_InWorldIconEnabled) == 0x000001, "Wrong size on ChallengeLevelActorComponent_OnRep_InWorldIconEnabled");
static_assert(offsetof(ChallengeLevelActorComponent_OnRep_InWorldIconEnabled, bOldEnabled) == 0x000000, "Member 'ChallengeLevelActorComponent_OnRep_InWorldIconEnabled::bOldEnabled' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_IsStationary
// 0x0001 (0x0001 - 0x0000)
struct ChallengeLevelActorComponent_OnRep_IsStationary final
{
public:
	bool                                          bOldIsStationary;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelActorComponent_OnRep_IsStationary) == 0x000001, "Wrong alignment on ChallengeLevelActorComponent_OnRep_IsStationary");
static_assert(sizeof(ChallengeLevelActorComponent_OnRep_IsStationary) == 0x000001, "Wrong size on ChallengeLevelActorComponent_OnRep_IsStationary");
static_assert(offsetof(ChallengeLevelActorComponent_OnRep_IsStationary, bOldIsStationary) == 0x000000, "Member 'ChallengeLevelActorComponent_OnRep_IsStationary::bOldIsStationary' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelActorComponent.SetInWorldIconEnabled
// 0x0001 (0x0001 - 0x0000)
struct ChallengeLevelActorComponent_SetInWorldIconEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelActorComponent_SetInWorldIconEnabled) == 0x000001, "Wrong alignment on ChallengeLevelActorComponent_SetInWorldIconEnabled");
static_assert(sizeof(ChallengeLevelActorComponent_SetInWorldIconEnabled) == 0x000001, "Wrong size on ChallengeLevelActorComponent_SetInWorldIconEnabled");
static_assert(offsetof(ChallengeLevelActorComponent_SetInWorldIconEnabled, bEnable) == 0x000000, "Member 'ChallengeLevelActorComponent_SetInWorldIconEnabled::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelActorComponent.SetIsStationary
// 0x0001 (0x0001 - 0x0000)
struct ChallengeLevelActorComponent_SetIsStationary final
{
public:
	bool                                          bInIsStationary;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelActorComponent_SetIsStationary) == 0x000001, "Wrong alignment on ChallengeLevelActorComponent_SetIsStationary");
static_assert(sizeof(ChallengeLevelActorComponent_SetIsStationary) == 0x000001, "Wrong size on ChallengeLevelActorComponent_SetIsStationary");
static_assert(offsetof(ChallengeLevelActorComponent_SetIsStationary, bInIsStationary) == 0x000000, "Member 'ChallengeLevelActorComponent_SetIsStationary::bInIsStationary' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.SetDebugActor
// 0x0010 (0x0010 - 0x0000)
struct GbxCheatManager_SetDebugActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerIndex;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCheatManager_SetDebugActor) == 0x000008, "Wrong alignment on GbxCheatManager_SetDebugActor");
static_assert(sizeof(GbxCheatManager_SetDebugActor) == 0x000010, "Wrong size on GbxCheatManager_SetDebugActor");
static_assert(offsetof(GbxCheatManager_SetDebugActor, Actor) == 0x000000, "Member 'GbxCheatManager_SetDebugActor::Actor' has a wrong offset!");
static_assert(offsetof(GbxCheatManager_SetDebugActor, ControllerIndex) == 0x000008, "Member 'GbxCheatManager_SetDebugActor::ControllerIndex' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.PlayFeedback
// 0x0018 (0x0018 - 0x0000)
struct GbxCheatManager_PlayFeedback final
{
public:
	class FString                                 FeedbackData;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCheatManager_PlayFeedback) == 0x000008, "Wrong alignment on GbxCheatManager_PlayFeedback");
static_assert(sizeof(GbxCheatManager_PlayFeedback) == 0x000018, "Wrong size on GbxCheatManager_PlayFeedback");
static_assert(offsetof(GbxCheatManager_PlayFeedback, FeedbackData) == 0x000000, "Member 'GbxCheatManager_PlayFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxCheatManager_PlayFeedback, Scale) == 0x000010, "Member 'GbxCheatManager_PlayFeedback::Scale' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.PlayFeedbackDirectional
// 0x0018 (0x0018 - 0x0000)
struct GbxCheatManager_PlayFeedbackDirectional final
{
public:
	class FString                                 FeedbackData;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionAngle;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCheatManager_PlayFeedbackDirectional) == 0x000008, "Wrong alignment on GbxCheatManager_PlayFeedbackDirectional");
static_assert(sizeof(GbxCheatManager_PlayFeedbackDirectional) == 0x000018, "Wrong size on GbxCheatManager_PlayFeedbackDirectional");
static_assert(offsetof(GbxCheatManager_PlayFeedbackDirectional, FeedbackData) == 0x000000, "Member 'GbxCheatManager_PlayFeedbackDirectional::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxCheatManager_PlayFeedbackDirectional, DirectionAngle) == 0x000010, "Member 'GbxCheatManager_PlayFeedbackDirectional::DirectionAngle' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.PlayFeedbackRangedFromThere
// 0x0010 (0x0010 - 0x0000)
struct GbxCheatManager_PlayFeedbackRangedFromThere final
{
public:
	class FString                                 FeedbackData;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCheatManager_PlayFeedbackRangedFromThere) == 0x000008, "Wrong alignment on GbxCheatManager_PlayFeedbackRangedFromThere");
static_assert(sizeof(GbxCheatManager_PlayFeedbackRangedFromThere) == 0x000010, "Wrong size on GbxCheatManager_PlayFeedbackRangedFromThere");
static_assert(offsetof(GbxCheatManager_PlayFeedbackRangedFromThere, FeedbackData) == 0x000000, "Member 'GbxCheatManager_PlayFeedbackRangedFromThere::FeedbackData' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.Server_DamageTarget
// 0x0004 (0x0004 - 0x0000)
struct GbxCheatManager_Server_DamageTarget final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCheatManager_Server_DamageTarget) == 0x000004, "Wrong alignment on GbxCheatManager_Server_DamageTarget");
static_assert(sizeof(GbxCheatManager_Server_DamageTarget) == 0x000004, "Wrong size on GbxCheatManager_Server_DamageTarget");
static_assert(offsetof(GbxCheatManager_Server_DamageTarget, DamageAmount) == 0x000000, "Member 'GbxCheatManager_Server_DamageTarget::DamageAmount' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.SetDebugActorByName
// 0x0010 (0x0010 - 0x0000)
struct GbxCheatManager_SetDebugActorByName final
{
public:
	class FString                                 ActorName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCheatManager_SetDebugActorByName) == 0x000008, "Wrong alignment on GbxCheatManager_SetDebugActorByName");
static_assert(sizeof(GbxCheatManager_SetDebugActorByName) == 0x000010, "Wrong size on GbxCheatManager_SetDebugActorByName");
static_assert(offsetof(GbxCheatManager_SetDebugActorByName, ActorName) == 0x000000, "Member 'GbxCheatManager_SetDebugActorByName::ActorName' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.ShowProjectileImpacts
// 0x0008 (0x0008 - 0x0000)
struct GbxCheatManager_ShowProjectileImpacts final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCheatManager_ShowProjectileImpacts) == 0x000004, "Wrong alignment on GbxCheatManager_ShowProjectileImpacts");
static_assert(sizeof(GbxCheatManager_ShowProjectileImpacts) == 0x000008, "Wrong size on GbxCheatManager_ShowProjectileImpacts");
static_assert(offsetof(GbxCheatManager_ShowProjectileImpacts, Size) == 0x000000, "Member 'GbxCheatManager_ShowProjectileImpacts::Size' has a wrong offset!");
static_assert(offsetof(GbxCheatManager_ShowProjectileImpacts, LifeTime) == 0x000004, "Member 'GbxCheatManager_ShowProjectileImpacts::LifeTime' has a wrong offset!");

// Function GbxGameSystemCore.GbxCheatManager.TestGameStage
// 0x0004 (0x0004 - 0x0000)
struct GbxCheatManager_TestGameStage final
{
public:
	int32                                         GameStageOverride;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCheatManager_TestGameStage) == 0x000004, "Wrong alignment on GbxCheatManager_TestGameStage");
static_assert(sizeof(GbxCheatManager_TestGameStage) == 0x000004, "Wrong size on GbxCheatManager_TestGameStage");
static_assert(offsetof(GbxCheatManager_TestGameStage, GameStageOverride) == 0x000000, "Member 'GbxCheatManager_TestGameStage::GameStageOverride' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.BroadcastPlayImpactSplatterEffect
// 0x0028 (0x0028 - 0x0000)
struct DamageComponent_BroadcastPlayImpactSplatterEffect final
{
public:
	class UImpactData*                            ImpactData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 HitLocation;                                       // 0x0008(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              HitDirection;                                      // 0x0014(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverity;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageComponent_BroadcastPlayImpactSplatterEffect) == 0x000008, "Wrong alignment on DamageComponent_BroadcastPlayImpactSplatterEffect");
static_assert(sizeof(DamageComponent_BroadcastPlayImpactSplatterEffect) == 0x000028, "Wrong size on DamageComponent_BroadcastPlayImpactSplatterEffect");
static_assert(offsetof(DamageComponent_BroadcastPlayImpactSplatterEffect, ImpactData) == 0x000000, "Member 'DamageComponent_BroadcastPlayImpactSplatterEffect::ImpactData' has a wrong offset!");
static_assert(offsetof(DamageComponent_BroadcastPlayImpactSplatterEffect, HitLocation) == 0x000008, "Member 'DamageComponent_BroadcastPlayImpactSplatterEffect::HitLocation' has a wrong offset!");
static_assert(offsetof(DamageComponent_BroadcastPlayImpactSplatterEffect, HitDirection) == 0x000014, "Member 'DamageComponent_BroadcastPlayImpactSplatterEffect::HitDirection' has a wrong offset!");
static_assert(offsetof(DamageComponent_BroadcastPlayImpactSplatterEffect, DamageSeverity) == 0x000020, "Member 'DamageComponent_BroadcastPlayImpactSplatterEffect::DamageSeverity' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.OnHealthResourceNowDepleted
// 0x0018 (0x0018 - 0x0000)
struct DamageComponent_OnHealthResourceNowDepleted final
{
public:
	struct FGameResourcePoolReference             ResourcePool;                                      // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_OnHealthResourceNowDepleted) == 0x000008, "Wrong alignment on DamageComponent_OnHealthResourceNowDepleted");
static_assert(sizeof(DamageComponent_OnHealthResourceNowDepleted) == 0x000018, "Wrong size on DamageComponent_OnHealthResourceNowDepleted");
static_assert(offsetof(DamageComponent_OnHealthResourceNowDepleted, ResourcePool) == 0x000000, "Member 'DamageComponent_OnHealthResourceNowDepleted::ResourcePool' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.OnHealthResourceNowNotDepleted
// 0x0018 (0x0018 - 0x0000)
struct DamageComponent_OnHealthResourceNowNotDepleted final
{
public:
	struct FGameResourcePoolReference             ResourcePool;                                      // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_OnHealthResourceNowNotDepleted) == 0x000008, "Wrong alignment on DamageComponent_OnHealthResourceNowNotDepleted");
static_assert(sizeof(DamageComponent_OnHealthResourceNowNotDepleted) == 0x000018, "Wrong size on DamageComponent_OnHealthResourceNowNotDepleted");
static_assert(offsetof(DamageComponent_OnHealthResourceNowNotDepleted, ResourcePool) == 0x000000, "Member 'DamageComponent_OnHealthResourceNowNotDepleted::ResourcePool' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.OnOwnerExperienceLevelChanged
// 0x0008 (0x0008 - 0x0000)
struct DamageComponent_OnOwnerExperienceLevelChanged final
{
public:
	int32                                         OldExperienceLevel;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewExperienceLevel;                                // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_OnOwnerExperienceLevelChanged) == 0x000004, "Wrong alignment on DamageComponent_OnOwnerExperienceLevelChanged");
static_assert(sizeof(DamageComponent_OnOwnerExperienceLevelChanged) == 0x000008, "Wrong size on DamageComponent_OnOwnerExperienceLevelChanged");
static_assert(offsetof(DamageComponent_OnOwnerExperienceLevelChanged, OldExperienceLevel) == 0x000000, "Member 'DamageComponent_OnOwnerExperienceLevelChanged::OldExperienceLevel' has a wrong offset!");
static_assert(offsetof(DamageComponent_OnOwnerExperienceLevelChanged, NewExperienceLevel) == 0x000004, "Member 'DamageComponent_OnOwnerExperienceLevelChanged::NewExperienceLevel' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.ReceiveAnyDamage
// 0x0080 (0x0080 - 0x0000)
struct DamageComponent_ReceiveAnyDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UGbxDamageType*                   DamageType;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageSource*                    DamageSource;                                      // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageCauserComponent*                 DamageCauser;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FReceivedDamageDetails                 Details;                                           // 0x0028(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_ReceiveAnyDamage) == 0x000008, "Wrong alignment on DamageComponent_ReceiveAnyDamage");
static_assert(sizeof(DamageComponent_ReceiveAnyDamage) == 0x000080, "Wrong size on DamageComponent_ReceiveAnyDamage");
static_assert(offsetof(DamageComponent_ReceiveAnyDamage, Damage) == 0x000000, "Member 'DamageComponent_ReceiveAnyDamage::Damage' has a wrong offset!");
static_assert(offsetof(DamageComponent_ReceiveAnyDamage, DamageType) == 0x000008, "Member 'DamageComponent_ReceiveAnyDamage::DamageType' has a wrong offset!");
static_assert(offsetof(DamageComponent_ReceiveAnyDamage, DamageSource) == 0x000010, "Member 'DamageComponent_ReceiveAnyDamage::DamageSource' has a wrong offset!");
static_assert(offsetof(DamageComponent_ReceiveAnyDamage, InstigatedBy) == 0x000018, "Member 'DamageComponent_ReceiveAnyDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(DamageComponent_ReceiveAnyDamage, DamageCauser) == 0x000020, "Member 'DamageComponent_ReceiveAnyDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageComponent_ReceiveAnyDamage, Details) == 0x000028, "Member 'DamageComponent_ReceiveAnyDamage::Details' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.ReceiveAnyHealing
// 0x0010 (0x0010 - 0x0000)
struct DamageComponent_ReceiveAnyHealing final
{
public:
	float                                         Healing;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HealInstigator;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_ReceiveAnyHealing) == 0x000008, "Wrong alignment on DamageComponent_ReceiveAnyHealing");
static_assert(sizeof(DamageComponent_ReceiveAnyHealing) == 0x000010, "Wrong size on DamageComponent_ReceiveAnyHealing");
static_assert(offsetof(DamageComponent_ReceiveAnyHealing, Healing) == 0x000000, "Member 'DamageComponent_ReceiveAnyHealing::Healing' has a wrong offset!");
static_assert(offsetof(DamageComponent_ReceiveAnyHealing, HealInstigator) == 0x000008, "Member 'DamageComponent_ReceiveAnyHealing::HealInstigator' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.ReceiveHealthDepleted
// 0x0008 (0x0008 - 0x0000)
struct DamageComponent_ReceiveHealthDepleted final
{
public:
	class UDamageCauserComponent*                 DamageCauser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_ReceiveHealthDepleted) == 0x000008, "Wrong alignment on DamageComponent_ReceiveHealthDepleted");
static_assert(sizeof(DamageComponent_ReceiveHealthDepleted) == 0x000008, "Wrong size on DamageComponent_ReceiveHealthDepleted");
static_assert(offsetof(DamageComponent_ReceiveHealthDepleted, DamageCauser) == 0x000000, "Member 'DamageComponent_ReceiveHealthDepleted::DamageCauser' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.RegisterConditionalDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct DamageComponent_RegisterConditionalDamageModifier final
{
public:
	class UConditionalDamageModifier*             Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_RegisterConditionalDamageModifier) == 0x000008, "Wrong alignment on DamageComponent_RegisterConditionalDamageModifier");
static_assert(sizeof(DamageComponent_RegisterConditionalDamageModifier) == 0x000008, "Wrong size on DamageComponent_RegisterConditionalDamageModifier");
static_assert(offsetof(DamageComponent_RegisterConditionalDamageModifier, Modifier) == 0x000000, "Member 'DamageComponent_RegisterConditionalDamageModifier::Modifier' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.SetCurrentHealth
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_SetCurrentHealth final
{
public:
	float                                         NewCurrentHealth;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_SetCurrentHealth) == 0x000004, "Wrong alignment on DamageComponent_SetCurrentHealth");
static_assert(sizeof(DamageComponent_SetCurrentHealth) == 0x000004, "Wrong size on DamageComponent_SetCurrentHealth");
static_assert(offsetof(DamageComponent_SetCurrentHealth, NewCurrentHealth) == 0x000000, "Member 'DamageComponent_SetCurrentHealth::NewCurrentHealth' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.SetCurrentShield
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_SetCurrentShield final
{
public:
	float                                         NewCurrentShield;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_SetCurrentShield) == 0x000004, "Wrong alignment on DamageComponent_SetCurrentShield");
static_assert(sizeof(DamageComponent_SetCurrentShield) == 0x000004, "Wrong size on DamageComponent_SetCurrentShield");
static_assert(offsetof(DamageComponent_SetCurrentShield, NewCurrentShield) == 0x000000, "Member 'DamageComponent_SetCurrentShield::NewCurrentShield' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.SetDemiGodMode
// 0x0001 (0x0001 - 0x0000)
struct DamageComponent_SetDemiGodMode final
{
public:
	bool                                          bInDemiGodMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_SetDemiGodMode) == 0x000001, "Wrong alignment on DamageComponent_SetDemiGodMode");
static_assert(sizeof(DamageComponent_SetDemiGodMode) == 0x000001, "Wrong size on DamageComponent_SetDemiGodMode");
static_assert(offsetof(DamageComponent_SetDemiGodMode, bInDemiGodMode) == 0x000000, "Member 'DamageComponent_SetDemiGodMode::bInDemiGodMode' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.SetGodMode
// 0x0001 (0x0001 - 0x0000)
struct DamageComponent_SetGodMode final
{
public:
	bool                                          bInGodMode;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_SetGodMode) == 0x000001, "Wrong alignment on DamageComponent_SetGodMode");
static_assert(sizeof(DamageComponent_SetGodMode) == 0x000001, "Wrong size on DamageComponent_SetGodMode");
static_assert(offsetof(DamageComponent_SetGodMode, bInGodMode) == 0x000000, "Member 'DamageComponent_SetGodMode::bInGodMode' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.SetSelfReflectedDamageType
// 0x0008 (0x0008 - 0x0000)
struct DamageComponent_SetSelfReflectedDamageType final
{
public:
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_SetSelfReflectedDamageType) == 0x000008, "Wrong alignment on DamageComponent_SetSelfReflectedDamageType");
static_assert(sizeof(DamageComponent_SetSelfReflectedDamageType) == 0x000008, "Wrong size on DamageComponent_SetSelfReflectedDamageType");
static_assert(offsetof(DamageComponent_SetSelfReflectedDamageType, DamageType) == 0x000000, "Member 'DamageComponent_SetSelfReflectedDamageType::DamageType' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.UnregisterConditionalDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct DamageComponent_UnregisterConditionalDamageModifier final
{
public:
	class UConditionalDamageModifier*             Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_UnregisterConditionalDamageModifier) == 0x000008, "Wrong alignment on DamageComponent_UnregisterConditionalDamageModifier");
static_assert(sizeof(DamageComponent_UnregisterConditionalDamageModifier) == 0x000008, "Wrong size on DamageComponent_UnregisterConditionalDamageModifier");
static_assert(offsetof(DamageComponent_UnregisterConditionalDamageModifier, Modifier) == 0x000000, "Member 'DamageComponent_UnregisterConditionalDamageModifier::Modifier' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetCurrentHealth
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_GetCurrentHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetCurrentHealth) == 0x000004, "Wrong alignment on DamageComponent_GetCurrentHealth");
static_assert(sizeof(DamageComponent_GetCurrentHealth) == 0x000004, "Wrong size on DamageComponent_GetCurrentHealth");
static_assert(offsetof(DamageComponent_GetCurrentHealth, ReturnValue) == 0x000000, "Member 'DamageComponent_GetCurrentHealth::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetCurrentHealthPercent
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_GetCurrentHealthPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetCurrentHealthPercent) == 0x000004, "Wrong alignment on DamageComponent_GetCurrentHealthPercent");
static_assert(sizeof(DamageComponent_GetCurrentHealthPercent) == 0x000004, "Wrong size on DamageComponent_GetCurrentHealthPercent");
static_assert(offsetof(DamageComponent_GetCurrentHealthPercent, ReturnValue) == 0x000000, "Member 'DamageComponent_GetCurrentHealthPercent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetCurrentShield
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_GetCurrentShield final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetCurrentShield) == 0x000004, "Wrong alignment on DamageComponent_GetCurrentShield");
static_assert(sizeof(DamageComponent_GetCurrentShield) == 0x000004, "Wrong size on DamageComponent_GetCurrentShield");
static_assert(offsetof(DamageComponent_GetCurrentShield, ReturnValue) == 0x000000, "Member 'DamageComponent_GetCurrentShield::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetMaxHealth) == 0x000004, "Wrong alignment on DamageComponent_GetMaxHealth");
static_assert(sizeof(DamageComponent_GetMaxHealth) == 0x000004, "Wrong size on DamageComponent_GetMaxHealth");
static_assert(offsetof(DamageComponent_GetMaxHealth, ReturnValue) == 0x000000, "Member 'DamageComponent_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetMaxShield
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_GetMaxShield final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetMaxShield) == 0x000004, "Wrong alignment on DamageComponent_GetMaxShield");
static_assert(sizeof(DamageComponent_GetMaxShield) == 0x000004, "Wrong size on DamageComponent_GetMaxShield");
static_assert(offsetof(DamageComponent_GetMaxShield, ReturnValue) == 0x000000, "Member 'DamageComponent_GetMaxShield::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetTotalMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct DamageComponent_GetTotalMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetTotalMaxHealth) == 0x000004, "Wrong alignment on DamageComponent_GetTotalMaxHealth");
static_assert(sizeof(DamageComponent_GetTotalMaxHealth) == 0x000004, "Wrong size on DamageComponent_GetTotalMaxHealth");
static_assert(offsetof(DamageComponent_GetTotalMaxHealth, ReturnValue) == 0x000000, "Member 'DamageComponent_GetTotalMaxHealth::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.GetValidDamageEventFunctionNames
// 0x0010 (0x0010 - 0x0000)
struct DamageComponent_GetValidDamageEventFunctionNames final
{
public:
	TArray<class FName>                           Names;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_GetValidDamageEventFunctionNames) == 0x000008, "Wrong alignment on DamageComponent_GetValidDamageEventFunctionNames");
static_assert(sizeof(DamageComponent_GetValidDamageEventFunctionNames) == 0x000010, "Wrong size on DamageComponent_GetValidDamageEventFunctionNames");
static_assert(offsetof(DamageComponent_GetValidDamageEventFunctionNames, Names) == 0x000000, "Member 'DamageComponent_GetValidDamageEventFunctionNames::Names' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.IsDamageOverkill
// 0x000C (0x000C - 0x0000)
struct DamageComponent_IsDamageOverkill final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverkillThreshold;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageComponent_IsDamageOverkill) == 0x000004, "Wrong alignment on DamageComponent_IsDamageOverkill");
static_assert(sizeof(DamageComponent_IsDamageOverkill) == 0x00000C, "Wrong size on DamageComponent_IsDamageOverkill");
static_assert(offsetof(DamageComponent_IsDamageOverkill, DamageAmount) == 0x000000, "Member 'DamageComponent_IsDamageOverkill::DamageAmount' has a wrong offset!");
static_assert(offsetof(DamageComponent_IsDamageOverkill, OverkillThreshold) == 0x000004, "Member 'DamageComponent_IsDamageOverkill::OverkillThreshold' has a wrong offset!");
static_assert(offsetof(DamageComponent_IsDamageOverkill, ReturnValue) == 0x000008, "Member 'DamageComponent_IsDamageOverkill::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.IsInDemiGodMode
// 0x0001 (0x0001 - 0x0000)
struct DamageComponent_IsInDemiGodMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_IsInDemiGodMode) == 0x000001, "Wrong alignment on DamageComponent_IsInDemiGodMode");
static_assert(sizeof(DamageComponent_IsInDemiGodMode) == 0x000001, "Wrong size on DamageComponent_IsInDemiGodMode");
static_assert(offsetof(DamageComponent_IsInDemiGodMode, ReturnValue) == 0x000000, "Member 'DamageComponent_IsInDemiGodMode::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageComponent.IsInGodMode
// 0x0001 (0x0001 - 0x0000)
struct DamageComponent_IsInGodMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageComponent_IsInGodMode) == 0x000001, "Wrong alignment on DamageComponent_IsInGodMode");
static_assert(sizeof(DamageComponent_IsInGodMode) == 0x000001, "Wrong size on DamageComponent_IsInGodMode");
static_assert(offsetof(DamageComponent_IsInGodMode, ReturnValue) == 0x000000, "Member 'DamageComponent_IsInGodMode::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageModifierComponent.RegisterConditionalDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct DamageModifierComponent_RegisterConditionalDamageModifier final
{
public:
	class UConditionalDamageModifier*             Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageModifierComponent_RegisterConditionalDamageModifier) == 0x000008, "Wrong alignment on DamageModifierComponent_RegisterConditionalDamageModifier");
static_assert(sizeof(DamageModifierComponent_RegisterConditionalDamageModifier) == 0x000008, "Wrong size on DamageModifierComponent_RegisterConditionalDamageModifier");
static_assert(offsetof(DamageModifierComponent_RegisterConditionalDamageModifier, Modifier) == 0x000000, "Member 'DamageModifierComponent_RegisterConditionalDamageModifier::Modifier' has a wrong offset!");

// Function GbxGameSystemCore.DamageModifierComponent.UnregisterConditionalDamageModifier
// 0x0008 (0x0008 - 0x0000)
struct DamageModifierComponent_UnregisterConditionalDamageModifier final
{
public:
	class UConditionalDamageModifier*             Modifier;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageModifierComponent_UnregisterConditionalDamageModifier) == 0x000008, "Wrong alignment on DamageModifierComponent_UnregisterConditionalDamageModifier");
static_assert(sizeof(DamageModifierComponent_UnregisterConditionalDamageModifier) == 0x000008, "Wrong size on DamageModifierComponent_UnregisterConditionalDamageModifier");
static_assert(offsetof(DamageModifierComponent_UnregisterConditionalDamageModifier, Modifier) == 0x000000, "Member 'DamageModifierComponent_UnregisterConditionalDamageModifier::Modifier' has a wrong offset!");

// Function GbxGameSystemCore.DamageOverTimeManager.OnParticleSystemStopped
// 0x0008 (0x0008 - 0x0000)
struct DamageOverTimeManager_OnParticleSystemStopped final
{
public:
	class UParticleSystemComponent*               ParticleSystem;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageOverTimeManager_OnParticleSystemStopped) == 0x000008, "Wrong alignment on DamageOverTimeManager_OnParticleSystemStopped");
static_assert(sizeof(DamageOverTimeManager_OnParticleSystemStopped) == 0x000008, "Wrong size on DamageOverTimeManager_OnParticleSystemStopped");
static_assert(offsetof(DamageOverTimeManager_OnParticleSystemStopped, ParticleSystem) == 0x000000, "Member 'DamageOverTimeManager_OnParticleSystemStopped::ParticleSystem' has a wrong offset!");

// Function GbxGameSystemCore.GbxDamageType.IsElementalType
// 0x0001 (0x0001 - 0x0000)
struct GbxDamageType_IsElementalType final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxDamageType_IsElementalType) == 0x000001, "Wrong alignment on GbxDamageType_IsElementalType");
static_assert(sizeof(GbxDamageType_IsElementalType) == 0x000001, "Wrong size on GbxDamageType_IsElementalType");
static_assert(offsetof(GbxDamageType_IsElementalType, ReturnValue) == 0x000000, "Member 'GbxDamageType_IsElementalType::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.FirstPersonComponent.SetBaseEyeToWeaponTransform
// 0x0030 (0x0030 - 0x0000)
struct FirstPersonComponent_SetBaseEyeToWeaponTransform final
{
public:
	struct FTransform                             NewWeaponTransform;                                // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FirstPersonComponent_SetBaseEyeToWeaponTransform) == 0x000010, "Wrong alignment on FirstPersonComponent_SetBaseEyeToWeaponTransform");
static_assert(sizeof(FirstPersonComponent_SetBaseEyeToWeaponTransform) == 0x000030, "Wrong size on FirstPersonComponent_SetBaseEyeToWeaponTransform");
static_assert(offsetof(FirstPersonComponent_SetBaseEyeToWeaponTransform, NewWeaponTransform) == 0x000000, "Member 'FirstPersonComponent_SetBaseEyeToWeaponTransform::NewWeaponTransform' has a wrong offset!");

// Function GbxGameSystemCore.FirstPersonComponent.GetFirstPersonComponentByName
// 0x0010 (0x0010 - 0x0000)
struct FirstPersonComponent_GetFirstPersonComponentByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FirstPersonComponent_GetFirstPersonComponentByName) == 0x000008, "Wrong alignment on FirstPersonComponent_GetFirstPersonComponentByName");
static_assert(sizeof(FirstPersonComponent_GetFirstPersonComponentByName) == 0x000010, "Wrong size on FirstPersonComponent_GetFirstPersonComponentByName");
static_assert(offsetof(FirstPersonComponent_GetFirstPersonComponentByName, Name_0) == 0x000000, "Member 'FirstPersonComponent_GetFirstPersonComponentByName::Name_0' has a wrong offset!");
static_assert(offsetof(FirstPersonComponent_GetFirstPersonComponentByName, ReturnValue) == 0x000008, "Member 'FirstPersonComponent_GetFirstPersonComponentByName::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionComponent.TriggerClientEvent
// 0x0060 (0x0060 - 0x0000)
struct HitRegionComponent_TriggerClientEvent final
{
public:
	struct FDamageReactionEventSummary            EventSummary;                                      // 0x0000(0x0060)(ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionComponent_TriggerClientEvent) == 0x000008, "Wrong alignment on HitRegionComponent_TriggerClientEvent");
static_assert(sizeof(HitRegionComponent_TriggerClientEvent) == 0x000060, "Wrong size on HitRegionComponent_TriggerClientEvent");
static_assert(offsetof(HitRegionComponent_TriggerClientEvent, EventSummary) == 0x000000, "Member 'HitRegionComponent_TriggerClientEvent::EventSummary' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionComponent.GetHitRegionCurrentHealth
// 0x0018 (0x0018 - 0x0000)
struct HitRegionComponent_GetHitRegionCurrentHealth final
{
public:
	class UHitRegionData*                         HitRegion;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AssociatedComponent;                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitRegionComponent_GetHitRegionCurrentHealth) == 0x000008, "Wrong alignment on HitRegionComponent_GetHitRegionCurrentHealth");
static_assert(sizeof(HitRegionComponent_GetHitRegionCurrentHealth) == 0x000018, "Wrong size on HitRegionComponent_GetHitRegionCurrentHealth");
static_assert(offsetof(HitRegionComponent_GetHitRegionCurrentHealth, HitRegion) == 0x000000, "Member 'HitRegionComponent_GetHitRegionCurrentHealth::HitRegion' has a wrong offset!");
static_assert(offsetof(HitRegionComponent_GetHitRegionCurrentHealth, AssociatedComponent) == 0x000008, "Member 'HitRegionComponent_GetHitRegionCurrentHealth::AssociatedComponent' has a wrong offset!");
static_assert(offsetof(HitRegionComponent_GetHitRegionCurrentHealth, ReturnValue) == 0x000010, "Member 'HitRegionComponent_GetHitRegionCurrentHealth::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionComponent.GetHitRegionMaxHealth
// 0x0018 (0x0018 - 0x0000)
struct HitRegionComponent_GetHitRegionMaxHealth final
{
public:
	class UHitRegionData*                         HitRegion;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AssociatedComponent;                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitRegionComponent_GetHitRegionMaxHealth) == 0x000008, "Wrong alignment on HitRegionComponent_GetHitRegionMaxHealth");
static_assert(sizeof(HitRegionComponent_GetHitRegionMaxHealth) == 0x000018, "Wrong size on HitRegionComponent_GetHitRegionMaxHealth");
static_assert(offsetof(HitRegionComponent_GetHitRegionMaxHealth, HitRegion) == 0x000000, "Member 'HitRegionComponent_GetHitRegionMaxHealth::HitRegion' has a wrong offset!");
static_assert(offsetof(HitRegionComponent_GetHitRegionMaxHealth, AssociatedComponent) == 0x000008, "Member 'HitRegionComponent_GetHitRegionMaxHealth::AssociatedComponent' has a wrong offset!");
static_assert(offsetof(HitRegionComponent_GetHitRegionMaxHealth, ReturnValue) == 0x000010, "Member 'HitRegionComponent_GetHitRegionMaxHealth::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionComponent.GetHitRegionPercentHealth
// 0x0018 (0x0018 - 0x0000)
struct HitRegionComponent_GetHitRegionPercentHealth final
{
public:
	class UHitRegionData*                         HitRegion;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AssociatedComponent;                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitRegionComponent_GetHitRegionPercentHealth) == 0x000008, "Wrong alignment on HitRegionComponent_GetHitRegionPercentHealth");
static_assert(sizeof(HitRegionComponent_GetHitRegionPercentHealth) == 0x000018, "Wrong size on HitRegionComponent_GetHitRegionPercentHealth");
static_assert(offsetof(HitRegionComponent_GetHitRegionPercentHealth, HitRegion) == 0x000000, "Member 'HitRegionComponent_GetHitRegionPercentHealth::HitRegion' has a wrong offset!");
static_assert(offsetof(HitRegionComponent_GetHitRegionPercentHealth, AssociatedComponent) == 0x000008, "Member 'HitRegionComponent_GetHitRegionPercentHealth::AssociatedComponent' has a wrong offset!");
static_assert(offsetof(HitRegionComponent_GetHitRegionPercentHealth, ReturnValue) == 0x000010, "Member 'HitRegionComponent_GetHitRegionPercentHealth::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionComponent.GetValidAssociatedComponentNames
// 0x0010 (0x0010 - 0x0000)
struct HitRegionComponent_GetValidAssociatedComponentNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionComponent_GetValidAssociatedComponentNames) == 0x000008, "Wrong alignment on HitRegionComponent_GetValidAssociatedComponentNames");
static_assert(sizeof(HitRegionComponent_GetValidAssociatedComponentNames) == 0x000010, "Wrong size on HitRegionComponent_GetValidAssociatedComponentNames");
static_assert(offsetof(HitRegionComponent_GetValidAssociatedComponentNames, Array) == 0x000000, "Member 'HitRegionComponent_GetValidAssociatedComponentNames::Array' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionComponent.GetValidDamageEventFunctionNames
// 0x0010 (0x0010 - 0x0000)
struct HitRegionComponent_GetValidDamageEventFunctionNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionComponent_GetValidDamageEventFunctionNames) == 0x000008, "Wrong alignment on HitRegionComponent_GetValidDamageEventFunctionNames");
static_assert(sizeof(HitRegionComponent_GetValidDamageEventFunctionNames) == 0x000010, "Wrong size on HitRegionComponent_GetValidDamageEventFunctionNames");
static_assert(offsetof(HitRegionComponent_GetValidDamageEventFunctionNames, Array) == 0x000000, "Member 'HitRegionComponent_GetValidDamageEventFunctionNames::Array' has a wrong offset!");

// Function GbxGameSystemCore.ActorPartData.EnumerateGestaltMeshPartNames
// 0x0010 (0x0010 - 0x0000)
struct ActorPartData_EnumerateGestaltMeshPartNames final
{
public:
	TArray<class FName>                           OutPartNameList;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorPartData_EnumerateGestaltMeshPartNames) == 0x000008, "Wrong alignment on ActorPartData_EnumerateGestaltMeshPartNames");
static_assert(sizeof(ActorPartData_EnumerateGestaltMeshPartNames) == 0x000010, "Wrong size on ActorPartData_EnumerateGestaltMeshPartNames");
static_assert(offsetof(ActorPartData_EnumerateGestaltMeshPartNames, OutPartNameList) == 0x000000, "Member 'ActorPartData_EnumerateGestaltMeshPartNames::OutPartNameList' has a wrong offset!");

// Function GbxGameSystemCore.ActorPartData.EnumerateOtherParts
// 0x0010 (0x0010 - 0x0000)
struct ActorPartData_EnumerateOtherParts final
{
public:
	TArray<class UActorPartData*>                 OutPartList;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorPartData_EnumerateOtherParts) == 0x000008, "Wrong alignment on ActorPartData_EnumerateOtherParts");
static_assert(sizeof(ActorPartData_EnumerateOtherParts) == 0x000010, "Wrong size on ActorPartData_EnumerateOtherParts");
static_assert(offsetof(ActorPartData_EnumerateOtherParts, OutPartList) == 0x000000, "Member 'ActorPartData_EnumerateOtherParts::OutPartList' has a wrong offset!");

// Function GbxGameSystemCore.ActorPartData.EnumeratePossibleDependencies
// 0x0010 (0x0010 - 0x0000)
struct ActorPartData_EnumeratePossibleDependencies final
{
public:
	TArray<class UActorPartData*>                 OutPartList;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorPartData_EnumeratePossibleDependencies) == 0x000008, "Wrong alignment on ActorPartData_EnumeratePossibleDependencies");
static_assert(sizeof(ActorPartData_EnumeratePossibleDependencies) == 0x000010, "Wrong size on ActorPartData_EnumeratePossibleDependencies");
static_assert(offsetof(ActorPartData_EnumeratePossibleDependencies, OutPartList) == 0x000000, "Member 'ActorPartData_EnumeratePossibleDependencies::OutPartList' has a wrong offset!");

// Function GbxGameSystemCore.ActorPartData.EnumeratePossibleExcluders
// 0x0010 (0x0010 - 0x0000)
struct ActorPartData_EnumeratePossibleExcluders final
{
public:
	TArray<class UActorPartData*>                 OutPartList;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorPartData_EnumeratePossibleExcluders) == 0x000008, "Wrong alignment on ActorPartData_EnumeratePossibleExcluders");
static_assert(sizeof(ActorPartData_EnumeratePossibleExcluders) == 0x000010, "Wrong size on ActorPartData_EnumeratePossibleExcluders");
static_assert(offsetof(ActorPartData_EnumeratePossibleExcluders, OutPartList) == 0x000000, "Member 'ActorPartData_EnumeratePossibleExcluders::OutPartList' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.CopyGestaltPartList
// 0x0008 (0x0008 - 0x0000)
struct GbxSkeletalMeshComponent_CopyGestaltPartList final
{
public:
	class AActor*                                 GestaltPartListSource;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_CopyGestaltPartList) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_CopyGestaltPartList");
static_assert(sizeof(GbxSkeletalMeshComponent_CopyGestaltPartList) == 0x000008, "Wrong size on GbxSkeletalMeshComponent_CopyGestaltPartList");
static_assert(offsetof(GbxSkeletalMeshComponent_CopyGestaltPartList, GestaltPartListSource) == 0x000000, "Member 'GbxSkeletalMeshComponent_CopyGestaltPartList::GestaltPartListSource' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.HideGestaltMeshPart
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_HideGestaltMeshPart final
{
public:
	const class UGestaltPartData_Mesh*            GestaltMeshPart;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOnly;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_HideGestaltMeshPart) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_HideGestaltMeshPart");
static_assert(sizeof(GbxSkeletalMeshComponent_HideGestaltMeshPart) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_HideGestaltMeshPart");
static_assert(offsetof(GbxSkeletalMeshComponent_HideGestaltMeshPart, GestaltMeshPart) == 0x000000, "Member 'GbxSkeletalMeshComponent_HideGestaltMeshPart::GestaltMeshPart' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_HideGestaltMeshPart, bLocalOnly) == 0x000008, "Member 'GbxSkeletalMeshComponent_HideGestaltMeshPart::bLocalOnly' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.HideGestaltMeshParts
// 0x0018 (0x0018 - 0x0000)
struct GbxSkeletalMeshComponent_HideGestaltMeshParts final
{
public:
	TArray<class UGestaltPartData_Mesh*>          Parts;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bLocalOnly;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_HideGestaltMeshParts) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_HideGestaltMeshParts");
static_assert(sizeof(GbxSkeletalMeshComponent_HideGestaltMeshParts) == 0x000018, "Wrong size on GbxSkeletalMeshComponent_HideGestaltMeshParts");
static_assert(offsetof(GbxSkeletalMeshComponent_HideGestaltMeshParts, Parts) == 0x000000, "Member 'GbxSkeletalMeshComponent_HideGestaltMeshParts::Parts' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_HideGestaltMeshParts, bLocalOnly) == 0x000010, "Member 'GbxSkeletalMeshComponent_HideGestaltMeshParts::bLocalOnly' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.LinkSkelMeshAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance final
{
public:
	class USkeletalMeshComponent*                 InLinkedSkelMeshComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance");
static_assert(sizeof(GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance) == 0x000008, "Wrong size on GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance");
static_assert(offsetof(GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance, InLinkedSkelMeshComponent) == 0x000000, "Member 'GbxSkeletalMeshComponent_LinkSkelMeshAnimInstance::InLinkedSkelMeshComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.LinkSkelMeshAnimInstances
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances final
{
public:
	TArray<class USkeletalMeshComponent*>         InLinkedSkelMeshComponents;                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances");
static_assert(sizeof(GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances");
static_assert(offsetof(GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances, InLinkedSkelMeshComponents) == 0x000000, "Member 'GbxSkeletalMeshComponent_LinkSkelMeshAnimInstances::InLinkedSkelMeshComponents' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetGestaltPartList
// 0x0008 (0x0008 - 0x0000)
struct GbxSkeletalMeshComponent_SetGestaltPartList final
{
public:
	class UGestaltPartListData*                   NewGestaltPartList;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_SetGestaltPartList) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_SetGestaltPartList");
static_assert(sizeof(GbxSkeletalMeshComponent_SetGestaltPartList) == 0x000008, "Wrong size on GbxSkeletalMeshComponent_SetGestaltPartList");
static_assert(offsetof(GbxSkeletalMeshComponent_SetGestaltPartList, NewGestaltPartList) == 0x000000, "Member 'GbxSkeletalMeshComponent_SetGestaltPartList::NewGestaltPartList' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetParentAnimationComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxSkeletalMeshComponent_SetParentAnimationComponent final
{
public:
	class USkeletalMeshComponent*                 ParentComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_SetParentAnimationComponent) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_SetParentAnimationComponent");
static_assert(sizeof(GbxSkeletalMeshComponent_SetParentAnimationComponent) == 0x000008, "Wrong size on GbxSkeletalMeshComponent_SetParentAnimationComponent");
static_assert(offsetof(GbxSkeletalMeshComponent_SetParentAnimationComponent, ParentComponent) == 0x000000, "Member 'GbxSkeletalMeshComponent_SetParentAnimationComponent::ParentComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetUpdateOverrideValues
// 0x0018 (0x0018 - 0x0000)
struct GbxSkeletalMeshComponent_SetUpdateOverrideValues final
{
public:
	TArray<float>                                 UpdateRateOverrides;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bEnableOverrideProperties;                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_SetUpdateOverrideValues) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_SetUpdateOverrideValues");
static_assert(sizeof(GbxSkeletalMeshComponent_SetUpdateOverrideValues) == 0x000018, "Wrong size on GbxSkeletalMeshComponent_SetUpdateOverrideValues");
static_assert(offsetof(GbxSkeletalMeshComponent_SetUpdateOverrideValues, UpdateRateOverrides) == 0x000000, "Member 'GbxSkeletalMeshComponent_SetUpdateOverrideValues::UpdateRateOverrides' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_SetUpdateOverrideValues, bEnableOverrideProperties) == 0x000010, "Member 'GbxSkeletalMeshComponent_SetUpdateOverrideValues::bEnableOverrideProperties' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.ShowGestaltMeshPart
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_ShowGestaltMeshPart final
{
public:
	const class UGestaltPartData_Mesh*            GestaltMeshPart;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOnly;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_ShowGestaltMeshPart) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_ShowGestaltMeshPart");
static_assert(sizeof(GbxSkeletalMeshComponent_ShowGestaltMeshPart) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_ShowGestaltMeshPart");
static_assert(offsetof(GbxSkeletalMeshComponent_ShowGestaltMeshPart, GestaltMeshPart) == 0x000000, "Member 'GbxSkeletalMeshComponent_ShowGestaltMeshPart::GestaltMeshPart' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_ShowGestaltMeshPart, bLocalOnly) == 0x000008, "Member 'GbxSkeletalMeshComponent_ShowGestaltMeshPart::bLocalOnly' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.ShowGestaltMeshParts
// 0x0018 (0x0018 - 0x0000)
struct GbxSkeletalMeshComponent_ShowGestaltMeshParts final
{
public:
	TArray<class UGestaltPartData_Mesh*>          Parts;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bLocalOnly;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_ShowGestaltMeshParts) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_ShowGestaltMeshParts");
static_assert(sizeof(GbxSkeletalMeshComponent_ShowGestaltMeshParts) == 0x000018, "Wrong size on GbxSkeletalMeshComponent_ShowGestaltMeshParts");
static_assert(offsetof(GbxSkeletalMeshComponent_ShowGestaltMeshParts, Parts) == 0x000000, "Member 'GbxSkeletalMeshComponent_ShowGestaltMeshParts::Parts' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_ShowGestaltMeshParts, bLocalOnly) == 0x000010, "Member 'GbxSkeletalMeshComponent_ShowGestaltMeshParts::bLocalOnly' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.GetAvailableBoneNames
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_GetAvailableBoneNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_GetAvailableBoneNames) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_GetAvailableBoneNames");
static_assert(sizeof(GbxSkeletalMeshComponent_GetAvailableBoneNames) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_GetAvailableBoneNames");
static_assert(offsetof(GbxSkeletalMeshComponent_GetAvailableBoneNames, Array) == 0x000000, "Member 'GbxSkeletalMeshComponent_GetAvailableBoneNames::Array' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.GetUpdateOverrideValues
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_GetUpdateOverrideValues final
{
public:
	TArray<float>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSkeletalMeshComponent_GetUpdateOverrideValues) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_GetUpdateOverrideValues");
static_assert(sizeof(GbxSkeletalMeshComponent_GetUpdateOverrideValues) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_GetUpdateOverrideValues");
static_assert(offsetof(GbxSkeletalMeshComponent_GetUpdateOverrideValues, ReturnValue) == 0x000000, "Member 'GbxSkeletalMeshComponent_GetUpdateOverrideValues::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.IsCustomizationTargetFor
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_IsCustomizationTargetFor final
{
public:
	class UGbxCustomizationTargetData*            TargetToTest;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_IsCustomizationTargetFor) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_IsCustomizationTargetFor");
static_assert(sizeof(GbxSkeletalMeshComponent_IsCustomizationTargetFor) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_IsCustomizationTargetFor");
static_assert(offsetof(GbxSkeletalMeshComponent_IsCustomizationTargetFor, TargetToTest) == 0x000000, "Member 'GbxSkeletalMeshComponent_IsCustomizationTargetFor::TargetToTest' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_IsCustomizationTargetFor, ReturnValue) == 0x000008, "Member 'GbxSkeletalMeshComponent_IsCustomizationTargetFor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxSkeletalMeshComponent.IsGestaltMeshPartVisible
// 0x0010 (0x0010 - 0x0000)
struct GbxSkeletalMeshComponent_IsGestaltMeshPartVisible final
{
public:
	const class UGestaltPartData_Mesh*            GestaltMeshPart;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSkeletalMeshComponent_IsGestaltMeshPartVisible) == 0x000008, "Wrong alignment on GbxSkeletalMeshComponent_IsGestaltMeshPartVisible");
static_assert(sizeof(GbxSkeletalMeshComponent_IsGestaltMeshPartVisible) == 0x000010, "Wrong size on GbxSkeletalMeshComponent_IsGestaltMeshPartVisible");
static_assert(offsetof(GbxSkeletalMeshComponent_IsGestaltMeshPartVisible, GestaltMeshPart) == 0x000000, "Member 'GbxSkeletalMeshComponent_IsGestaltMeshPartVisible::GestaltMeshPart' has a wrong offset!");
static_assert(offsetof(GbxSkeletalMeshComponent_IsGestaltMeshPartVisible, ReturnValue) == 0x000008, "Member 'GbxSkeletalMeshComponent_IsGestaltMeshPartVisible::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.AttachPawn
// 0x0010 (0x0010 - 0x0000)
struct PawnAttachSlotComponent_AttachPawn final
{
public:
	class APawn*                                  AttachingPawn;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PawnAttachSlotComponent_AttachPawn) == 0x000008, "Wrong alignment on PawnAttachSlotComponent_AttachPawn");
static_assert(sizeof(PawnAttachSlotComponent_AttachPawn) == 0x000010, "Wrong size on PawnAttachSlotComponent_AttachPawn");
static_assert(offsetof(PawnAttachSlotComponent_AttachPawn, AttachingPawn) == 0x000000, "Member 'PawnAttachSlotComponent_AttachPawn::AttachingPawn' has a wrong offset!");
static_assert(offsetof(PawnAttachSlotComponent_AttachPawn, bInstant) == 0x000008, "Member 'PawnAttachSlotComponent_AttachPawn::bInstant' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.DetachPawn
// 0x0002 (0x0002 - 0x0000)
struct PawnAttachSlotComponent_DetachPawn final
{
public:
	bool                                          bInstant;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipPlacement;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_DetachPawn) == 0x000001, "Wrong alignment on PawnAttachSlotComponent_DetachPawn");
static_assert(sizeof(PawnAttachSlotComponent_DetachPawn) == 0x000002, "Wrong size on PawnAttachSlotComponent_DetachPawn");
static_assert(offsetof(PawnAttachSlotComponent_DetachPawn, bInstant) == 0x000000, "Member 'PawnAttachSlotComponent_DetachPawn::bInstant' has a wrong offset!");
static_assert(offsetof(PawnAttachSlotComponent_DetachPawn, bSkipPlacement) == 0x000001, "Member 'PawnAttachSlotComponent_DetachPawn::bSkipPlacement' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.HandleActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct PawnAttachSlotComponent_HandleActorDestroyed final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_HandleActorDestroyed) == 0x000008, "Wrong alignment on PawnAttachSlotComponent_HandleActorDestroyed");
static_assert(sizeof(PawnAttachSlotComponent_HandleActorDestroyed) == 0x000008, "Wrong size on PawnAttachSlotComponent_HandleActorDestroyed");
static_assert(offsetof(PawnAttachSlotComponent_HandleActorDestroyed, Actor) == 0x000000, "Member 'PawnAttachSlotComponent_HandleActorDestroyed::Actor' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.SetDetachabilityLocked
// 0x0010 (0x0010 - 0x0000)
struct PawnAttachSlotComponent_SetDetachabilityLocked final
{
public:
	bool                                          bLock;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_SetDetachabilityLocked) == 0x000004, "Wrong alignment on PawnAttachSlotComponent_SetDetachabilityLocked");
static_assert(sizeof(PawnAttachSlotComponent_SetDetachabilityLocked) == 0x000010, "Wrong size on PawnAttachSlotComponent_SetDetachabilityLocked");
static_assert(offsetof(PawnAttachSlotComponent_SetDetachabilityLocked, bLock) == 0x000000, "Member 'PawnAttachSlotComponent_SetDetachabilityLocked::bLock' has a wrong offset!");
static_assert(offsetof(PawnAttachSlotComponent_SetDetachabilityLocked, Reason) == 0x000008, "Member 'PawnAttachSlotComponent_SetDetachabilityLocked::Reason' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.SetPersistentAttachSocketName
// 0x0008 (0x0008 - 0x0000)
struct PawnAttachSlotComponent_SetPersistentAttachSocketName final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_SetPersistentAttachSocketName) == 0x000004, "Wrong alignment on PawnAttachSlotComponent_SetPersistentAttachSocketName");
static_assert(sizeof(PawnAttachSlotComponent_SetPersistentAttachSocketName) == 0x000008, "Wrong size on PawnAttachSlotComponent_SetPersistentAttachSocketName");
static_assert(offsetof(PawnAttachSlotComponent_SetPersistentAttachSocketName, SocketName) == 0x000000, "Member 'PawnAttachSlotComponent_SetPersistentAttachSocketName::SocketName' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.GetAttachStatus
// 0x0001 (0x0001 - 0x0000)
struct PawnAttachSlotComponent_GetAttachStatus final
{
public:
	EPawnAttachStatus                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_GetAttachStatus) == 0x000001, "Wrong alignment on PawnAttachSlotComponent_GetAttachStatus");
static_assert(sizeof(PawnAttachSlotComponent_GetAttachStatus) == 0x000001, "Wrong size on PawnAttachSlotComponent_GetAttachStatus");
static_assert(offsetof(PawnAttachSlotComponent_GetAttachStatus, ReturnValue) == 0x000000, "Member 'PawnAttachSlotComponent_GetAttachStatus::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.GetOccupant
// 0x0010 (0x0010 - 0x0000)
struct PawnAttachSlotComponent_GetOccupant final
{
public:
	bool                                          bIncludeDetaching;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_GetOccupant) == 0x000008, "Wrong alignment on PawnAttachSlotComponent_GetOccupant");
static_assert(sizeof(PawnAttachSlotComponent_GetOccupant) == 0x000010, "Wrong size on PawnAttachSlotComponent_GetOccupant");
static_assert(offsetof(PawnAttachSlotComponent_GetOccupant, bIncludeDetaching) == 0x000000, "Member 'PawnAttachSlotComponent_GetOccupant::bIncludeDetaching' has a wrong offset!");
static_assert(offsetof(PawnAttachSlotComponent_GetOccupant, ReturnValue) == 0x000008, "Member 'PawnAttachSlotComponent_GetOccupant::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.GetPersistentAttachSocketTransform
// 0x0030 (0x0030 - 0x0000)
struct PawnAttachSlotComponent_GetPersistentAttachSocketTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_GetPersistentAttachSocketTransform) == 0x000010, "Wrong alignment on PawnAttachSlotComponent_GetPersistentAttachSocketTransform");
static_assert(sizeof(PawnAttachSlotComponent_GetPersistentAttachSocketTransform) == 0x000030, "Wrong size on PawnAttachSlotComponent_GetPersistentAttachSocketTransform");
static_assert(offsetof(PawnAttachSlotComponent_GetPersistentAttachSocketTransform, ReturnValue) == 0x000000, "Member 'PawnAttachSlotComponent_GetPersistentAttachSocketTransform::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachSlotComponent.IsOccupied
// 0x0002 (0x0002 - 0x0000)
struct PawnAttachSlotComponent_IsOccupied final
{
public:
	bool                                          bIncludeDetaching;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachSlotComponent_IsOccupied) == 0x000001, "Wrong alignment on PawnAttachSlotComponent_IsOccupied");
static_assert(sizeof(PawnAttachSlotComponent_IsOccupied) == 0x000002, "Wrong size on PawnAttachSlotComponent_IsOccupied");
static_assert(offsetof(PawnAttachSlotComponent_IsOccupied, bIncludeDetaching) == 0x000000, "Member 'PawnAttachSlotComponent_IsOccupied::bIncludeDetaching' has a wrong offset!");
static_assert(offsetof(PawnAttachSlotComponent_IsOccupied, ReturnValue) == 0x000001, "Member 'PawnAttachSlotComponent_IsOccupied::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFeedbackBase.PlayGbxFeedbackData2D
// 0x0028 (0x0028 - 0x0000)
struct GbxFeedbackBase_PlayGbxFeedbackData2D final
{
public:
	const class UGbxFeedbackBase*                 FeedbackData;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreController;                                 // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxFeedbackBase_PlayGbxFeedbackData2D) == 0x000008, "Wrong alignment on GbxFeedbackBase_PlayGbxFeedbackData2D");
static_assert(sizeof(GbxFeedbackBase_PlayGbxFeedbackData2D) == 0x000028, "Wrong size on GbxFeedbackBase_PlayGbxFeedbackData2D");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, FeedbackData) == 0x000000, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, WorldContextObject) == 0x000008, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, Controller) == 0x000010, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::Controller' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, bLoop) == 0x000018, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::bLoop' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, bIgnoreController) == 0x000019, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::bIgnoreController' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, Scale) == 0x00001C, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::Scale' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData2D, SourceContext) == 0x000020, "Member 'GbxFeedbackBase_PlayGbxFeedbackData2D::SourceContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxFeedbackBase.PlayGbxFeedbackData3D
// 0x0040 (0x0040 - 0x0000)
struct GbxFeedbackBase_PlayGbxFeedbackData3D final
{
public:
	const class UGbxFeedbackBase*                 FeedbackData;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreController;                                 // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectFalloffMinDistance;                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectFalloffMaxDistance;                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxFeedbackBase_PlayGbxFeedbackData3D) == 0x000008, "Wrong alignment on GbxFeedbackBase_PlayGbxFeedbackData3D");
static_assert(sizeof(GbxFeedbackBase_PlayGbxFeedbackData3D) == 0x000040, "Wrong size on GbxFeedbackBase_PlayGbxFeedbackData3D");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, FeedbackData) == 0x000000, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, WorldContextObject) == 0x000008, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, Controller) == 0x000010, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::Controller' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, SourceLocation) == 0x000018, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::SourceLocation' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, bLoop) == 0x000024, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::bLoop' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, bIgnoreController) == 0x000025, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::bIgnoreController' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, Scale) == 0x000028, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::Scale' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, SourceContext) == 0x000030, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::SourceContext' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, EffectFalloffMinDistance) == 0x000038, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::EffectFalloffMinDistance' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_PlayGbxFeedbackData3D, EffectFalloffMaxDistance) == 0x00003C, "Member 'GbxFeedbackBase_PlayGbxFeedbackData3D::EffectFalloffMaxDistance' has a wrong offset!");

// Function GbxGameSystemCore.GbxFeedbackBase.StopGbxFeedback
// 0x0018 (0x0018 - 0x0000)
struct GbxFeedbackBase_StopGbxFeedback final
{
public:
	const class UGbxFeedbackBase*                 FeedbackData;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxFeedbackBase_StopGbxFeedback) == 0x000008, "Wrong alignment on GbxFeedbackBase_StopGbxFeedback");
static_assert(sizeof(GbxFeedbackBase_StopGbxFeedback) == 0x000018, "Wrong size on GbxFeedbackBase_StopGbxFeedback");
static_assert(offsetof(GbxFeedbackBase_StopGbxFeedback, FeedbackData) == 0x000000, "Member 'GbxFeedbackBase_StopGbxFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_StopGbxFeedback, WorldContextObject) == 0x000008, "Member 'GbxFeedbackBase_StopGbxFeedback::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFeedbackBase_StopGbxFeedback, Controller) == 0x000010, "Member 'GbxFeedbackBase_StopGbxFeedback::Controller' has a wrong offset!");

// Function GbxGameSystemCore.Beacon.OnBeaconSourceEndPlay
// 0x0010 (0x0010 - 0x0000)
struct Beacon_OnBeaconSourceEndPlay final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Beacon_OnBeaconSourceEndPlay) == 0x000008, "Wrong alignment on Beacon_OnBeaconSourceEndPlay");
static_assert(sizeof(Beacon_OnBeaconSourceEndPlay) == 0x000010, "Wrong size on Beacon_OnBeaconSourceEndPlay");
static_assert(offsetof(Beacon_OnBeaconSourceEndPlay, Actor) == 0x000000, "Member 'Beacon_OnBeaconSourceEndPlay::Actor' has a wrong offset!");
static_assert(offsetof(Beacon_OnBeaconSourceEndPlay, EndPlayReason) == 0x000008, "Member 'Beacon_OnBeaconSourceEndPlay::EndPlayReason' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectManagerComponent.AddStatusEffect
// 0x0050 (0x0050 - 0x0000)
struct StatusEffectManagerComponent_AddStatusEffect final
{
public:
	struct FStatusEffectSpec                      Spec;                                              // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FStatusEffectInstanceReference         ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectManagerComponent_AddStatusEffect) == 0x000008, "Wrong alignment on StatusEffectManagerComponent_AddStatusEffect");
static_assert(sizeof(StatusEffectManagerComponent_AddStatusEffect) == 0x000050, "Wrong size on StatusEffectManagerComponent_AddStatusEffect");
static_assert(offsetof(StatusEffectManagerComponent_AddStatusEffect, Spec) == 0x000000, "Member 'StatusEffectManagerComponent_AddStatusEffect::Spec' has a wrong offset!");
static_assert(offsetof(StatusEffectManagerComponent_AddStatusEffect, ReturnValue) == 0x000038, "Member 'StatusEffectManagerComponent_AddStatusEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectManagerComponent.RemoveStatusEffect
// 0x0018 (0x0018 - 0x0000)
struct StatusEffectManagerComponent_RemoveStatusEffect final
{
public:
	struct FStatusEffectRemoveSpec                Spec;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatusEffectManagerComponent_RemoveStatusEffect) == 0x000008, "Wrong alignment on StatusEffectManagerComponent_RemoveStatusEffect");
static_assert(sizeof(StatusEffectManagerComponent_RemoveStatusEffect) == 0x000018, "Wrong size on StatusEffectManagerComponent_RemoveStatusEffect");
static_assert(offsetof(StatusEffectManagerComponent_RemoveStatusEffect, Spec) == 0x000000, "Member 'StatusEffectManagerComponent_RemoveStatusEffect::Spec' has a wrong offset!");
static_assert(offsetof(StatusEffectManagerComponent_RemoveStatusEffect, ReturnValue) == 0x000010, "Member 'StatusEffectManagerComponent_RemoveStatusEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectManagerComponent.RemoveStatusEffectInstance
// 0x0020 (0x0020 - 0x0000)
struct StatusEffectManagerComponent_RemoveStatusEffectInstance final
{
public:
	struct FStatusEffectInstanceReference         Reference;                                         // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatusEffectManagerComponent_RemoveStatusEffectInstance) == 0x000008, "Wrong alignment on StatusEffectManagerComponent_RemoveStatusEffectInstance");
static_assert(sizeof(StatusEffectManagerComponent_RemoveStatusEffectInstance) == 0x000020, "Wrong size on StatusEffectManagerComponent_RemoveStatusEffectInstance");
static_assert(offsetof(StatusEffectManagerComponent_RemoveStatusEffectInstance, Reference) == 0x000000, "Member 'StatusEffectManagerComponent_RemoveStatusEffectInstance::Reference' has a wrong offset!");
static_assert(offsetof(StatusEffectManagerComponent_RemoveStatusEffectInstance, ReturnValue) == 0x000018, "Member 'StatusEffectManagerComponent_RemoveStatusEffectInstance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectManagerComponent.QueryStatusEffect
// 0x0028 (0x0028 - 0x0000)
struct StatusEffectManagerComponent_QueryStatusEffect final
{
public:
	struct FStatusEffectQuery                     Query;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FStatusEffectQueryResult               ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectManagerComponent_QueryStatusEffect) == 0x000008, "Wrong alignment on StatusEffectManagerComponent_QueryStatusEffect");
static_assert(sizeof(StatusEffectManagerComponent_QueryStatusEffect) == 0x000028, "Wrong size on StatusEffectManagerComponent_QueryStatusEffect");
static_assert(offsetof(StatusEffectManagerComponent_QueryStatusEffect, Query) == 0x000000, "Member 'StatusEffectManagerComponent_QueryStatusEffect::Query' has a wrong offset!");
static_assert(offsetof(StatusEffectManagerComponent_QueryStatusEffect, ReturnValue) == 0x000018, "Member 'StatusEffectManagerComponent_QueryStatusEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.ResetMotionState
// 0x0008 (0x0008 - 0x0000)
struct GbxSimpleMotionLibrary_ResetMotionState final
{
public:
	struct FSimpleMotionInstanceState             State;                                             // 0x0000(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSimpleMotionLibrary_ResetMotionState) == 0x000004, "Wrong alignment on GbxSimpleMotionLibrary_ResetMotionState");
static_assert(sizeof(GbxSimpleMotionLibrary_ResetMotionState) == 0x000008, "Wrong size on GbxSimpleMotionLibrary_ResetMotionState");
static_assert(offsetof(GbxSimpleMotionLibrary_ResetMotionState, State) == 0x000000, "Member 'GbxSimpleMotionLibrary_ResetMotionState::State' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportFloatMotion
// 0x0038 (0x0038 - 0x0000)
struct GbxSimpleMotionLibrary_TeleportFloatMotion final
{
public:
	float                                         CurrentValue;                                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlValue;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     Data;                                              // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionInstanceState             State;                                             // 0x0030(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSimpleMotionLibrary_TeleportFloatMotion) == 0x000008, "Wrong alignment on GbxSimpleMotionLibrary_TeleportFloatMotion");
static_assert(sizeof(GbxSimpleMotionLibrary_TeleportFloatMotion) == 0x000038, "Wrong size on GbxSimpleMotionLibrary_TeleportFloatMotion");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportFloatMotion, CurrentValue) == 0x000000, "Member 'GbxSimpleMotionLibrary_TeleportFloatMotion::CurrentValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportFloatMotion, ControlValue) == 0x000004, "Member 'GbxSimpleMotionLibrary_TeleportFloatMotion::ControlValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportFloatMotion, Data) == 0x000008, "Member 'GbxSimpleMotionLibrary_TeleportFloatMotion::Data' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportFloatMotion, SpeedScale) == 0x000028, "Member 'GbxSimpleMotionLibrary_TeleportFloatMotion::SpeedScale' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportFloatMotion, TargetValue) == 0x00002C, "Member 'GbxSimpleMotionLibrary_TeleportFloatMotion::TargetValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportFloatMotion, State) == 0x000030, "Member 'GbxSimpleMotionLibrary_TeleportFloatMotion::State' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportRotatorMotion
// 0x0048 (0x0048 - 0x0000)
struct GbxSimpleMotionLibrary_TeleportRotatorMotion final
{
public:
	struct FRotator                               CurrentValue;                                      // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ControlValue;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     Data;                                              // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetValue;                                       // 0x0034(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionInstanceState             State;                                             // 0x0040(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSimpleMotionLibrary_TeleportRotatorMotion) == 0x000008, "Wrong alignment on GbxSimpleMotionLibrary_TeleportRotatorMotion");
static_assert(sizeof(GbxSimpleMotionLibrary_TeleportRotatorMotion) == 0x000048, "Wrong size on GbxSimpleMotionLibrary_TeleportRotatorMotion");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportRotatorMotion, CurrentValue) == 0x000000, "Member 'GbxSimpleMotionLibrary_TeleportRotatorMotion::CurrentValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportRotatorMotion, ControlValue) == 0x00000C, "Member 'GbxSimpleMotionLibrary_TeleportRotatorMotion::ControlValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportRotatorMotion, Data) == 0x000010, "Member 'GbxSimpleMotionLibrary_TeleportRotatorMotion::Data' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportRotatorMotion, SpeedScale) == 0x000030, "Member 'GbxSimpleMotionLibrary_TeleportRotatorMotion::SpeedScale' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportRotatorMotion, TargetValue) == 0x000034, "Member 'GbxSimpleMotionLibrary_TeleportRotatorMotion::TargetValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportRotatorMotion, State) == 0x000040, "Member 'GbxSimpleMotionLibrary_TeleportRotatorMotion::State' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportVectorMotion
// 0x0048 (0x0048 - 0x0000)
struct GbxSimpleMotionLibrary_TeleportVectorMotion final
{
public:
	struct FVector                                CurrentValue;                                      // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlValue;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     Data;                                              // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetValue;                                       // 0x0034(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionInstanceState             State;                                             // 0x0040(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSimpleMotionLibrary_TeleportVectorMotion) == 0x000008, "Wrong alignment on GbxSimpleMotionLibrary_TeleportVectorMotion");
static_assert(sizeof(GbxSimpleMotionLibrary_TeleportVectorMotion) == 0x000048, "Wrong size on GbxSimpleMotionLibrary_TeleportVectorMotion");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportVectorMotion, CurrentValue) == 0x000000, "Member 'GbxSimpleMotionLibrary_TeleportVectorMotion::CurrentValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportVectorMotion, ControlValue) == 0x00000C, "Member 'GbxSimpleMotionLibrary_TeleportVectorMotion::ControlValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportVectorMotion, Data) == 0x000010, "Member 'GbxSimpleMotionLibrary_TeleportVectorMotion::Data' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportVectorMotion, SpeedScale) == 0x000030, "Member 'GbxSimpleMotionLibrary_TeleportVectorMotion::SpeedScale' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportVectorMotion, TargetValue) == 0x000034, "Member 'GbxSimpleMotionLibrary_TeleportVectorMotion::TargetValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_TeleportVectorMotion, State) == 0x000040, "Member 'GbxSimpleMotionLibrary_TeleportVectorMotion::State' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateFloatMotion
// 0x0040 (0x0040 - 0x0000)
struct GbxSimpleMotionLibrary_UpdateFloatMotion final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     Data;                                              // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionInstanceState             State;                                             // 0x0038(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSimpleMotionLibrary_UpdateFloatMotion) == 0x000008, "Wrong alignment on GbxSimpleMotionLibrary_UpdateFloatMotion");
static_assert(sizeof(GbxSimpleMotionLibrary_UpdateFloatMotion) == 0x000040, "Wrong size on GbxSimpleMotionLibrary_UpdateFloatMotion");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, DeltaTime) == 0x000000, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::DeltaTime' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, CurrentValue) == 0x000004, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::CurrentValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, ControlValue) == 0x000008, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::ControlValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, Data) == 0x000010, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::Data' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, SpeedScale) == 0x000030, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::SpeedScale' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, TargetValue) == 0x000034, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::TargetValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateFloatMotion, State) == 0x000038, "Member 'GbxSimpleMotionLibrary_UpdateFloatMotion::State' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateRotatorMotion
// 0x0058 (0x0058 - 0x0000)
struct GbxSimpleMotionLibrary_UpdateRotatorMotion final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentValue;                                      // 0x0004(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ControlValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     Data;                                              // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetValue;                                       // 0x003C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShortestRotation;                                 // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionInstanceState             State;                                             // 0x004C(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSimpleMotionLibrary_UpdateRotatorMotion) == 0x000008, "Wrong alignment on GbxSimpleMotionLibrary_UpdateRotatorMotion");
static_assert(sizeof(GbxSimpleMotionLibrary_UpdateRotatorMotion) == 0x000058, "Wrong size on GbxSimpleMotionLibrary_UpdateRotatorMotion");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, DeltaTime) == 0x000000, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::DeltaTime' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, CurrentValue) == 0x000004, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::CurrentValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, ControlValue) == 0x000010, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::ControlValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, Data) == 0x000018, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::Data' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, SpeedScale) == 0x000038, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::SpeedScale' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, TargetValue) == 0x00003C, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::TargetValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, bShortestRotation) == 0x000048, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::bShortestRotation' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateRotatorMotion, State) == 0x00004C, "Member 'GbxSimpleMotionLibrary_UpdateRotatorMotion::State' has a wrong offset!");

// Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateVectorMotion
// 0x0050 (0x0050 - 0x0000)
struct GbxSimpleMotionLibrary_UpdateVectorMotion final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentValue;                                      // 0x0004(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     Data;                                              // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetValue;                                       // 0x003C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionInstanceState             State;                                             // 0x0048(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSimpleMotionLibrary_UpdateVectorMotion) == 0x000008, "Wrong alignment on GbxSimpleMotionLibrary_UpdateVectorMotion");
static_assert(sizeof(GbxSimpleMotionLibrary_UpdateVectorMotion) == 0x000050, "Wrong size on GbxSimpleMotionLibrary_UpdateVectorMotion");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, DeltaTime) == 0x000000, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::DeltaTime' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, CurrentValue) == 0x000004, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::CurrentValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, ControlValue) == 0x000010, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::ControlValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, Data) == 0x000018, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::Data' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, SpeedScale) == 0x000038, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::SpeedScale' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, TargetValue) == 0x00003C, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::TargetValue' has a wrong offset!");
static_assert(offsetof(GbxSimpleMotionLibrary_UpdateVectorMotion, State) == 0x000048, "Member 'GbxSimpleMotionLibrary_UpdateVectorMotion::State' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectsStatics.AddStatusEffect
// 0x0058 (0x0058 - 0x0000)
struct StatusEffectsStatics_AddStatusEffect final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectSpec                      Spec;                                              // 0x0008(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FStatusEffectInstanceReference         ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectsStatics_AddStatusEffect) == 0x000008, "Wrong alignment on StatusEffectsStatics_AddStatusEffect");
static_assert(sizeof(StatusEffectsStatics_AddStatusEffect) == 0x000058, "Wrong size on StatusEffectsStatics_AddStatusEffect");
static_assert(offsetof(StatusEffectsStatics_AddStatusEffect, Target) == 0x000000, "Member 'StatusEffectsStatics_AddStatusEffect::Target' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_AddStatusEffect, Spec) == 0x000008, "Member 'StatusEffectsStatics_AddStatusEffect::Spec' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_AddStatusEffect, ReturnValue) == 0x000040, "Member 'StatusEffectsStatics_AddStatusEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectsStatics.QueryStatusEffect
// 0x0030 (0x0030 - 0x0000)
struct StatusEffectsStatics_QueryStatusEffect final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectQuery                     Query;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FStatusEffectQueryResult               ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffectsStatics_QueryStatusEffect) == 0x000008, "Wrong alignment on StatusEffectsStatics_QueryStatusEffect");
static_assert(sizeof(StatusEffectsStatics_QueryStatusEffect) == 0x000030, "Wrong size on StatusEffectsStatics_QueryStatusEffect");
static_assert(offsetof(StatusEffectsStatics_QueryStatusEffect, Target) == 0x000000, "Member 'StatusEffectsStatics_QueryStatusEffect::Target' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_QueryStatusEffect, Query) == 0x000008, "Member 'StatusEffectsStatics_QueryStatusEffect::Query' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_QueryStatusEffect, ReturnValue) == 0x000020, "Member 'StatusEffectsStatics_QueryStatusEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectsStatics.RemoveStatusEffect
// 0x0020 (0x0020 - 0x0000)
struct StatusEffectsStatics_RemoveStatusEffect final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectRemoveSpec                RemoveSpec;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatusEffectsStatics_RemoveStatusEffect) == 0x000008, "Wrong alignment on StatusEffectsStatics_RemoveStatusEffect");
static_assert(sizeof(StatusEffectsStatics_RemoveStatusEffect) == 0x000020, "Wrong size on StatusEffectsStatics_RemoveStatusEffect");
static_assert(offsetof(StatusEffectsStatics_RemoveStatusEffect, Target) == 0x000000, "Member 'StatusEffectsStatics_RemoveStatusEffect::Target' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_RemoveStatusEffect, RemoveSpec) == 0x000008, "Member 'StatusEffectsStatics_RemoveStatusEffect::RemoveSpec' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_RemoveStatusEffect, ReturnValue) == 0x000018, "Member 'StatusEffectsStatics_RemoveStatusEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffectsStatics.RemoveStatusEffectInstance
// 0x0028 (0x0028 - 0x0000)
struct StatusEffectsStatics_RemoveStatusEffectInstance final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectInstanceReference         Reference;                                         // 0x0008(0x0018)(Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StatusEffectsStatics_RemoveStatusEffectInstance) == 0x000008, "Wrong alignment on StatusEffectsStatics_RemoveStatusEffectInstance");
static_assert(sizeof(StatusEffectsStatics_RemoveStatusEffectInstance) == 0x000028, "Wrong size on StatusEffectsStatics_RemoveStatusEffectInstance");
static_assert(offsetof(StatusEffectsStatics_RemoveStatusEffectInstance, Target) == 0x000000, "Member 'StatusEffectsStatics_RemoveStatusEffectInstance::Target' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_RemoveStatusEffectInstance, Reference) == 0x000008, "Member 'StatusEffectsStatics_RemoveStatusEffectInstance::Reference' has a wrong offset!");
static_assert(offsetof(StatusEffectsStatics_RemoveStatusEffectInstance, ReturnValue) == 0x000020, "Member 'StatusEffectsStatics_RemoveStatusEffectInstance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayHitResultImpact
// 0x00A8 (0x00A8 - 0x0000)
struct ImpactEffectFunctionLibrary_PlayHitResultImpact final
{
public:
	class UImpactData*                            ImpactData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0010(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bReplicated;                                       // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ImpactEffectFunctionLibrary_PlayHitResultImpact) == 0x000008, "Wrong alignment on ImpactEffectFunctionLibrary_PlayHitResultImpact");
static_assert(sizeof(ImpactEffectFunctionLibrary_PlayHitResultImpact) == 0x0000A8, "Wrong size on ImpactEffectFunctionLibrary_PlayHitResultImpact");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpact, ImpactData) == 0x000000, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpact::ImpactData' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpact, Instigator) == 0x000008, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpact::Instigator' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpact, HitInfo) == 0x000010, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpact::HitInfo' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpact, bReplicated) == 0x0000A0, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpact::bReplicated' has a wrong offset!");

// Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayHitResultImpactGetParticleSystemComponents
// 0x00B0 (0x00B0 - 0x0000)
struct ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents final
{
public:
	class UImpactData*                            ImpactData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0010(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       SpawnedParticleSystemComponents;                   // 0x00A0(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents) == 0x000008, "Wrong alignment on ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents");
static_assert(sizeof(ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents) == 0x0000B0, "Wrong size on ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents, ImpactData) == 0x000000, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents::ImpactData' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents, Instigator) == 0x000008, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents::Instigator' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents, HitInfo) == 0x000010, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents::HitInfo' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents, SpawnedParticleSystemComponents) == 0x0000A0, "Member 'ImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents::SpawnedParticleSystemComponents' has a wrong offset!");

// Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayTraceImpact
// 0x0030 (0x0030 - 0x0000)
struct ImpactEffectFunctionLibrary_PlayTraceImpact final
{
public:
	class UImpactData*                            ImpactData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x001C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicated;                                       // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ImpactEffectFunctionLibrary_PlayTraceImpact) == 0x000008, "Wrong alignment on ImpactEffectFunctionLibrary_PlayTraceImpact");
static_assert(sizeof(ImpactEffectFunctionLibrary_PlayTraceImpact) == 0x000030, "Wrong size on ImpactEffectFunctionLibrary_PlayTraceImpact");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpact, ImpactData) == 0x000000, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpact::ImpactData' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpact, Instigator) == 0x000008, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpact::Instigator' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpact, TraceStart) == 0x000010, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpact::TraceStart' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpact, TraceEnd) == 0x00001C, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpact::TraceEnd' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpact, TraceChannel) == 0x000028, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpact::TraceChannel' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpact, bReplicated) == 0x000029, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpact::bReplicated' has a wrong offset!");

// Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayTraceImpactAndGetParticleSystemComponents
// 0x0040 (0x0040 - 0x0000)
struct ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents final
{
public:
	class UImpactData*                            ImpactData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x001C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       SpawnedParticleSystemComponents;                   // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents) == 0x000008, "Wrong alignment on ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents");
static_assert(sizeof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents) == 0x000040, "Wrong size on ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents, ImpactData) == 0x000000, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents::ImpactData' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents, Instigator) == 0x000008, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents::Instigator' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents, TraceStart) == 0x000010, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents::TraceStart' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents, TraceEnd) == 0x00001C, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents::TraceEnd' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents, SpawnedParticleSystemComponents) == 0x000028, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents::SpawnedParticleSystemComponents' has a wrong offset!");
static_assert(offsetof(ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents, TraceChannel) == 0x000038, "Member 'ImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents::TraceChannel' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.ClientNotifyAttemptedUseCouldNotAfford
// 0x0010 (0x0010 - 0x0000)
struct UseComponent_ClientNotifyAttemptedUseCouldNotAfford final
{
public:
	class UUsableComponent*                       Usable;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHeld;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UseComponent_ClientNotifyAttemptedUseCouldNotAfford) == 0x000008, "Wrong alignment on UseComponent_ClientNotifyAttemptedUseCouldNotAfford");
static_assert(sizeof(UseComponent_ClientNotifyAttemptedUseCouldNotAfford) == 0x000010, "Wrong size on UseComponent_ClientNotifyAttemptedUseCouldNotAfford");
static_assert(offsetof(UseComponent_ClientNotifyAttemptedUseCouldNotAfford, Usable) == 0x000000, "Member 'UseComponent_ClientNotifyAttemptedUseCouldNotAfford::Usable' has a wrong offset!");
static_assert(offsetof(UseComponent_ClientNotifyAttemptedUseCouldNotAfford, UseType) == 0x000008, "Member 'UseComponent_ClientNotifyAttemptedUseCouldNotAfford::UseType' has a wrong offset!");
static_assert(offsetof(UseComponent_ClientNotifyAttemptedUseCouldNotAfford, bUseHeld) == 0x000009, "Member 'UseComponent_ClientNotifyAttemptedUseCouldNotAfford::bUseHeld' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.ForceUsingObject
// 0x0008 (0x0008 - 0x0000)
struct UseComponent_ForceUsingObject final
{
public:
	class UUsableComponent*                       UsableObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_ForceUsingObject) == 0x000008, "Wrong alignment on UseComponent_ForceUsingObject");
static_assert(sizeof(UseComponent_ForceUsingObject) == 0x000008, "Wrong size on UseComponent_ForceUsingObject");
static_assert(offsetof(UseComponent_ForceUsingObject, UsableObject) == 0x000000, "Member 'UseComponent_ForceUsingObject::UsableObject' has a wrong offset!");

// DelegateFunction GbxGameSystemCore.UseComponent.OnImpactDataChanged__DelegateSignature
// 0x0018 (0x0018 - 0x0000)
struct UseComponent_OnImpactDataChanged__DelegateSignature final
{
public:
	class UUsableComponent*                       NewUsableComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewUsableComponentImpactPoint;                     // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewUsableComponentDistanceAway;                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_OnImpactDataChanged__DelegateSignature) == 0x000008, "Wrong alignment on UseComponent_OnImpactDataChanged__DelegateSignature");
static_assert(sizeof(UseComponent_OnImpactDataChanged__DelegateSignature) == 0x000018, "Wrong size on UseComponent_OnImpactDataChanged__DelegateSignature");
static_assert(offsetof(UseComponent_OnImpactDataChanged__DelegateSignature, NewUsableComponent) == 0x000000, "Member 'UseComponent_OnImpactDataChanged__DelegateSignature::NewUsableComponent' has a wrong offset!");
static_assert(offsetof(UseComponent_OnImpactDataChanged__DelegateSignature, NewUsableComponentImpactPoint) == 0x000008, "Member 'UseComponent_OnImpactDataChanged__DelegateSignature::NewUsableComponentImpactPoint' has a wrong offset!");
static_assert(offsetof(UseComponent_OnImpactDataChanged__DelegateSignature, NewUsableComponentDistanceAway) == 0x000014, "Member 'UseComponent_OnImpactDataChanged__DelegateSignature::NewUsableComponentDistanceAway' has a wrong offset!");

// DelegateFunction GbxGameSystemCore.UseComponent.OnUnableToAffordUsableObject__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct UseComponent_OnUnableToAffordUsableObject__DelegateSignature final
{
public:
	class UUsableComponent*                       Usable;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHeld;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UseComponent_OnUnableToAffordUsableObject__DelegateSignature) == 0x000008, "Wrong alignment on UseComponent_OnUnableToAffordUsableObject__DelegateSignature");
static_assert(sizeof(UseComponent_OnUnableToAffordUsableObject__DelegateSignature) == 0x000010, "Wrong size on UseComponent_OnUnableToAffordUsableObject__DelegateSignature");
static_assert(offsetof(UseComponent_OnUnableToAffordUsableObject__DelegateSignature, Usable) == 0x000000, "Member 'UseComponent_OnUnableToAffordUsableObject__DelegateSignature::Usable' has a wrong offset!");
static_assert(offsetof(UseComponent_OnUnableToAffordUsableObject__DelegateSignature, UseType) == 0x000008, "Member 'UseComponent_OnUnableToAffordUsableObject__DelegateSignature::UseType' has a wrong offset!");
static_assert(offsetof(UseComponent_OnUnableToAffordUsableObject__DelegateSignature, bUseHeld) == 0x000009, "Member 'UseComponent_OnUnableToAffordUsableObject__DelegateSignature::bUseHeld' has a wrong offset!");

// DelegateFunction GbxGameSystemCore.UseComponent.OnUsabilityChanged__DelegateSignature
// 0x0048 (0x0048 - 0x0000)
struct UseComponent_OnUsabilityChanged__DelegateSignature final
{
public:
	class UUsableComponent*                       NewUsableComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUsabilityInfo                         InUsabilityInfo;                                   // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_OnUsabilityChanged__DelegateSignature) == 0x000008, "Wrong alignment on UseComponent_OnUsabilityChanged__DelegateSignature");
static_assert(sizeof(UseComponent_OnUsabilityChanged__DelegateSignature) == 0x000048, "Wrong size on UseComponent_OnUsabilityChanged__DelegateSignature");
static_assert(offsetof(UseComponent_OnUsabilityChanged__DelegateSignature, NewUsableComponent) == 0x000000, "Member 'UseComponent_OnUsabilityChanged__DelegateSignature::NewUsableComponent' has a wrong offset!");
static_assert(offsetof(UseComponent_OnUsabilityChanged__DelegateSignature, InUsabilityInfo) == 0x000008, "Member 'UseComponent_OnUsabilityChanged__DelegateSignature::InUsabilityInfo' has a wrong offset!");

// DelegateFunction GbxGameSystemCore.UseComponent.OnUsableChanged__DelegateSignature
// 0x0058 (0x0058 - 0x0000)
struct UseComponent_OnUsableChanged__DelegateSignature final
{
public:
	class UUsableComponent*                       NewUsableComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUsabilityInfo                         InUsabilityInfo;                                   // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                NewUsableComponentImpactPoint;                     // 0x0048(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewUsableComponentDistanceAway;                    // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_OnUsableChanged__DelegateSignature) == 0x000008, "Wrong alignment on UseComponent_OnUsableChanged__DelegateSignature");
static_assert(sizeof(UseComponent_OnUsableChanged__DelegateSignature) == 0x000058, "Wrong size on UseComponent_OnUsableChanged__DelegateSignature");
static_assert(offsetof(UseComponent_OnUsableChanged__DelegateSignature, NewUsableComponent) == 0x000000, "Member 'UseComponent_OnUsableChanged__DelegateSignature::NewUsableComponent' has a wrong offset!");
static_assert(offsetof(UseComponent_OnUsableChanged__DelegateSignature, InUsabilityInfo) == 0x000008, "Member 'UseComponent_OnUsableChanged__DelegateSignature::InUsabilityInfo' has a wrong offset!");
static_assert(offsetof(UseComponent_OnUsableChanged__DelegateSignature, NewUsableComponentImpactPoint) == 0x000048, "Member 'UseComponent_OnUsableChanged__DelegateSignature::NewUsableComponentImpactPoint' has a wrong offset!");
static_assert(offsetof(UseComponent_OnUsableChanged__DelegateSignature, NewUsableComponentDistanceAway) == 0x000054, "Member 'UseComponent_OnUsableChanged__DelegateSignature::NewUsableComponentDistanceAway' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.ServerStartUsingObject
// 0x0010 (0x0010 - 0x0000)
struct UseComponent_ServerStartUsingObject final
{
public:
	class UUsableComponent*                       UsableObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UseComponent_ServerStartUsingObject) == 0x000008, "Wrong alignment on UseComponent_ServerStartUsingObject");
static_assert(sizeof(UseComponent_ServerStartUsingObject) == 0x000010, "Wrong size on UseComponent_ServerStartUsingObject");
static_assert(offsetof(UseComponent_ServerStartUsingObject, UsableObject) == 0x000000, "Member 'UseComponent_ServerStartUsingObject::UsableObject' has a wrong offset!");
static_assert(offsetof(UseComponent_ServerStartUsingObject, UseType) == 0x000008, "Member 'UseComponent_ServerStartUsingObject::UseType' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.ServerStopUsingObject
// 0x0010 (0x0010 - 0x0000)
struct UseComponent_ServerStopUsingObject final
{
public:
	class UUsableComponent*                       UsableObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UseComponent_ServerStopUsingObject) == 0x000008, "Wrong alignment on UseComponent_ServerStopUsingObject");
static_assert(sizeof(UseComponent_ServerStopUsingObject) == 0x000010, "Wrong size on UseComponent_ServerStopUsingObject");
static_assert(offsetof(UseComponent_ServerStopUsingObject, UsableObject) == 0x000000, "Member 'UseComponent_ServerStopUsingObject::UsableObject' has a wrong offset!");
static_assert(offsetof(UseComponent_ServerStopUsingObject, UseType) == 0x000008, "Member 'UseComponent_ServerStopUsingObject::UseType' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.ServerUseObject
// 0x0010 (0x0010 - 0x0000)
struct UseComponent_ServerUseObject final
{
public:
	class UUsableComponent*                       UsableObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeld;                                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UseComponent_ServerUseObject) == 0x000008, "Wrong alignment on UseComponent_ServerUseObject");
static_assert(sizeof(UseComponent_ServerUseObject) == 0x000010, "Wrong size on UseComponent_ServerUseObject");
static_assert(offsetof(UseComponent_ServerUseObject, UsableObject) == 0x000000, "Member 'UseComponent_ServerUseObject::UsableObject' has a wrong offset!");
static_assert(offsetof(UseComponent_ServerUseObject, UseType) == 0x000008, "Member 'UseComponent_ServerUseObject::UseType' has a wrong offset!");
static_assert(offsetof(UseComponent_ServerUseObject, bHeld) == 0x000009, "Member 'UseComponent_ServerUseObject::bHeld' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.StartUsingCurrentObject
// 0x0001 (0x0001 - 0x0000)
struct UseComponent_StartUsingCurrentObject final
{
public:
	EUsabilityType                                UseType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_StartUsingCurrentObject) == 0x000001, "Wrong alignment on UseComponent_StartUsingCurrentObject");
static_assert(sizeof(UseComponent_StartUsingCurrentObject) == 0x000001, "Wrong size on UseComponent_StartUsingCurrentObject");
static_assert(offsetof(UseComponent_StartUsingCurrentObject, UseType) == 0x000000, "Member 'UseComponent_StartUsingCurrentObject::UseType' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.StopUsingCurrentObject
// 0x0001 (0x0001 - 0x0000)
struct UseComponent_StopUsingCurrentObject final
{
public:
	EUsabilityType                                UseType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_StopUsingCurrentObject) == 0x000001, "Wrong alignment on UseComponent_StopUsingCurrentObject");
static_assert(sizeof(UseComponent_StopUsingCurrentObject) == 0x000001, "Wrong size on UseComponent_StopUsingCurrentObject");
static_assert(offsetof(UseComponent_StopUsingCurrentObject, UseType) == 0x000000, "Member 'UseComponent_StopUsingCurrentObject::UseType' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.CanInteractWithCurrentUsable
// 0x0002 (0x0002 - 0x0000)
struct UseComponent_CanInteractWithCurrentUsable final
{
public:
	EUsabilityType                                Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_CanInteractWithCurrentUsable) == 0x000001, "Wrong alignment on UseComponent_CanInteractWithCurrentUsable");
static_assert(sizeof(UseComponent_CanInteractWithCurrentUsable) == 0x000002, "Wrong size on UseComponent_CanInteractWithCurrentUsable");
static_assert(offsetof(UseComponent_CanInteractWithCurrentUsable, Type) == 0x000000, "Member 'UseComponent_CanInteractWithCurrentUsable::Type' has a wrong offset!");
static_assert(offsetof(UseComponent_CanInteractWithCurrentUsable, ReturnValue) == 0x000001, "Member 'UseComponent_CanInteractWithCurrentUsable::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.CanUseCurrentUsable
// 0x0002 (0x0002 - 0x0000)
struct UseComponent_CanUseCurrentUsable final
{
public:
	EUsabilityType                                Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_CanUseCurrentUsable) == 0x000001, "Wrong alignment on UseComponent_CanUseCurrentUsable");
static_assert(sizeof(UseComponent_CanUseCurrentUsable) == 0x000002, "Wrong size on UseComponent_CanUseCurrentUsable");
static_assert(offsetof(UseComponent_CanUseCurrentUsable, Type) == 0x000000, "Member 'UseComponent_CanUseCurrentUsable::Type' has a wrong offset!");
static_assert(offsetof(UseComponent_CanUseCurrentUsable, ReturnValue) == 0x000001, "Member 'UseComponent_CanUseCurrentUsable::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UseComponent.GetCurrentUsable
// 0x0008 (0x0008 - 0x0000)
struct UseComponent_GetCurrentUsable final
{
public:
	class UUsableComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseComponent_GetCurrentUsable) == 0x000008, "Wrong alignment on UseComponent_GetCurrentUsable");
static_assert(sizeof(UseComponent_GetCurrentUsable) == 0x000008, "Wrong size on UseComponent_GetCurrentUsable");
static_assert(offsetof(UseComponent_GetCurrentUsable, ReturnValue) == 0x000000, "Member 'UseComponent_GetCurrentUsable::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EnvQueryParamsExt.GetDescription
// 0x00C8 (0x00C8 - 0x0000)
struct EnvQueryParamsExt_GetDescription final
{
public:
	struct FEnvQueryParams                        QueryParams;                                       // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x00B8(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnvQueryParamsExt_GetDescription) == 0x000008, "Wrong alignment on EnvQueryParamsExt_GetDescription");
static_assert(sizeof(EnvQueryParamsExt_GetDescription) == 0x0000C8, "Wrong size on EnvQueryParamsExt_GetDescription");
static_assert(offsetof(EnvQueryParamsExt_GetDescription, QueryParams) == 0x000000, "Member 'EnvQueryParamsExt_GetDescription::QueryParams' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_GetDescription, ReturnValue) == 0x0000B8, "Member 'EnvQueryParamsExt_GetDescription::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EnvQueryParamsExt.HasQuery
// 0x00C0 (0x00C0 - 0x0000)
struct EnvQueryParamsExt_HasQuery final
{
public:
	struct FEnvQueryParams                        QueryParams;                                       // 0x0000(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvQueryParamsExt_HasQuery) == 0x000008, "Wrong alignment on EnvQueryParamsExt_HasQuery");
static_assert(sizeof(EnvQueryParamsExt_HasQuery) == 0x0000C0, "Wrong size on EnvQueryParamsExt_HasQuery");
static_assert(offsetof(EnvQueryParamsExt_HasQuery, QueryParams) == 0x000000, "Member 'EnvQueryParamsExt_HasQuery::QueryParams' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_HasQuery, ReturnValue) == 0x0000B8, "Member 'EnvQueryParamsExt_HasQuery::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForAllActors
// 0x00D8 (0x00D8 - 0x0000)
struct EnvQueryParamsExt_RunEnvQueryForAllActors final
{
public:
	class UObject*                                QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ResultActors;                                      // 0x00C0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvQueryParamsExt_RunEnvQueryForAllActors) == 0x000008, "Wrong alignment on EnvQueryParamsExt_RunEnvQueryForAllActors");
static_assert(sizeof(EnvQueryParamsExt_RunEnvQueryForAllActors) == 0x0000D8, "Wrong size on EnvQueryParamsExt_RunEnvQueryForAllActors");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllActors, QueryOwner) == 0x000000, "Member 'EnvQueryParamsExt_RunEnvQueryForAllActors::QueryOwner' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllActors, QueryParams) == 0x000008, "Member 'EnvQueryParamsExt_RunEnvQueryForAllActors::QueryParams' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllActors, ResultActors) == 0x0000C0, "Member 'EnvQueryParamsExt_RunEnvQueryForAllActors::ResultActors' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllActors, ReturnValue) == 0x0000D0, "Member 'EnvQueryParamsExt_RunEnvQueryForAllActors::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForAllLocations
// 0x00D8 (0x00D8 - 0x0000)
struct EnvQueryParamsExt_RunEnvQueryForAllLocations final
{
public:
	class UObject*                                QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ResultLocations;                                   // 0x00C0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvQueryParamsExt_RunEnvQueryForAllLocations) == 0x000008, "Wrong alignment on EnvQueryParamsExt_RunEnvQueryForAllLocations");
static_assert(sizeof(EnvQueryParamsExt_RunEnvQueryForAllLocations) == 0x0000D8, "Wrong size on EnvQueryParamsExt_RunEnvQueryForAllLocations");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllLocations, QueryOwner) == 0x000000, "Member 'EnvQueryParamsExt_RunEnvQueryForAllLocations::QueryOwner' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllLocations, QueryParams) == 0x000008, "Member 'EnvQueryParamsExt_RunEnvQueryForAllLocations::QueryParams' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllLocations, ResultLocations) == 0x0000C0, "Member 'EnvQueryParamsExt_RunEnvQueryForAllLocations::ResultLocations' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForAllLocations, ReturnValue) == 0x0000D0, "Member 'EnvQueryParamsExt_RunEnvQueryForAllLocations::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForBestActor
// 0x00D0 (0x00D0 - 0x0000)
struct EnvQueryParamsExt_RunEnvQueryForBestActor final
{
public:
	class UObject*                                QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ResultActor;                                       // 0x00C0(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvQueryParamsExt_RunEnvQueryForBestActor) == 0x000008, "Wrong alignment on EnvQueryParamsExt_RunEnvQueryForBestActor");
static_assert(sizeof(EnvQueryParamsExt_RunEnvQueryForBestActor) == 0x0000D0, "Wrong size on EnvQueryParamsExt_RunEnvQueryForBestActor");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestActor, QueryOwner) == 0x000000, "Member 'EnvQueryParamsExt_RunEnvQueryForBestActor::QueryOwner' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestActor, QueryParams) == 0x000008, "Member 'EnvQueryParamsExt_RunEnvQueryForBestActor::QueryParams' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestActor, ResultActor) == 0x0000C0, "Member 'EnvQueryParamsExt_RunEnvQueryForBestActor::ResultActor' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestActor, ReturnValue) == 0x0000C8, "Member 'EnvQueryParamsExt_RunEnvQueryForBestActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForBestLocation
// 0x00D0 (0x00D0 - 0x0000)
struct EnvQueryParamsExt_RunEnvQueryForBestLocation final
{
public:
	class UObject*                                QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ResultLocation;                                    // 0x00C0(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00CC(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvQueryParamsExt_RunEnvQueryForBestLocation) == 0x000008, "Wrong alignment on EnvQueryParamsExt_RunEnvQueryForBestLocation");
static_assert(sizeof(EnvQueryParamsExt_RunEnvQueryForBestLocation) == 0x0000D0, "Wrong size on EnvQueryParamsExt_RunEnvQueryForBestLocation");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestLocation, QueryOwner) == 0x000000, "Member 'EnvQueryParamsExt_RunEnvQueryForBestLocation::QueryOwner' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestLocation, QueryParams) == 0x000008, "Member 'EnvQueryParamsExt_RunEnvQueryForBestLocation::QueryParams' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestLocation, ResultLocation) == 0x0000C0, "Member 'EnvQueryParamsExt_RunEnvQueryForBestLocation::ResultLocation' has a wrong offset!");
static_assert(offsetof(EnvQueryParamsExt_RunEnvQueryForBestLocation, ReturnValue) == 0x0000CC, "Member 'EnvQueryParamsExt_RunEnvQueryForBestLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.CoordinatedEffectBlueprintLibrary.GetOriginalOverrideMaterialAtIndex
// 0x0018 (0x0018 - 0x0000)
struct CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex final
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutActualIndex;                                    // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex) == 0x000008, "Wrong alignment on CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex");
static_assert(sizeof(CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex) == 0x000018, "Wrong size on CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex");
static_assert(offsetof(CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex, MeshComponent) == 0x000000, "Member 'CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex::MeshComponent' has a wrong offset!");
static_assert(offsetof(CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex, Index_0) == 0x000008, "Member 'CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex::Index_0' has a wrong offset!");
static_assert(offsetof(CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex, OutActualIndex) == 0x00000C, "Member 'CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex::OutActualIndex' has a wrong offset!");
static_assert(offsetof(CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex, ReturnValue) == 0x000010, "Member 'CoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ActorPartSetData.EnumeratePartListForPartType
// 0x0018 (0x0018 - 0x0000)
struct ActorPartSetData_EnumeratePartListForPartType final
{
public:
	uint8                                         PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorPartData*>                 OutPartList;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorPartSetData_EnumeratePartListForPartType) == 0x000008, "Wrong alignment on ActorPartSetData_EnumeratePartListForPartType");
static_assert(sizeof(ActorPartSetData_EnumeratePartListForPartType) == 0x000018, "Wrong size on ActorPartSetData_EnumeratePartListForPartType");
static_assert(offsetof(ActorPartSetData_EnumeratePartListForPartType, PartType) == 0x000000, "Member 'ActorPartSetData_EnumeratePartListForPartType::PartType' has a wrong offset!");
static_assert(offsetof(ActorPartSetData_EnumeratePartListForPartType, OutPartList) == 0x000008, "Member 'ActorPartSetData_EnumeratePartListForPartType::OutPartList' has a wrong offset!");

// Function GbxGameSystemCore.AttributeInitializer.EvaluateBalanceFormula
// 0x0014 (0x0014 - 0x0000)
struct AttributeInitializer_EvaluateBalanceFormula final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttributeInitializer_EvaluateBalanceFormula) == 0x000004, "Wrong alignment on AttributeInitializer_EvaluateBalanceFormula");
static_assert(sizeof(AttributeInitializer_EvaluateBalanceFormula) == 0x000014, "Wrong size on AttributeInitializer_EvaluateBalanceFormula");
static_assert(offsetof(AttributeInitializer_EvaluateBalanceFormula, Multiplier) == 0x000000, "Member 'AttributeInitializer_EvaluateBalanceFormula::Multiplier' has a wrong offset!");
static_assert(offsetof(AttributeInitializer_EvaluateBalanceFormula, Level) == 0x000004, "Member 'AttributeInitializer_EvaluateBalanceFormula::Level' has a wrong offset!");
static_assert(offsetof(AttributeInitializer_EvaluateBalanceFormula, Power) == 0x000008, "Member 'AttributeInitializer_EvaluateBalanceFormula::Power' has a wrong offset!");
static_assert(offsetof(AttributeInitializer_EvaluateBalanceFormula, Offset) == 0x00000C, "Member 'AttributeInitializer_EvaluateBalanceFormula::Offset' has a wrong offset!");
static_assert(offsetof(AttributeInitializer_EvaluateBalanceFormula, ReturnValue) == 0x000010, "Member 'AttributeInitializer_EvaluateBalanceFormula::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AttributeInitializer.CalculateAttributeInitialValue
// 0x0010 (0x0010 - 0x0000)
struct AttributeInitializer_CalculateAttributeInitialValue final
{
public:
	const class UObject*                          Context;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AttributeInitializer_CalculateAttributeInitialValue) == 0x000008, "Wrong alignment on AttributeInitializer_CalculateAttributeInitialValue");
static_assert(sizeof(AttributeInitializer_CalculateAttributeInitialValue) == 0x000010, "Wrong size on AttributeInitializer_CalculateAttributeInitialValue");
static_assert(offsetof(AttributeInitializer_CalculateAttributeInitialValue, Context) == 0x000000, "Member 'AttributeInitializer_CalculateAttributeInitialValue::Context' has a wrong offset!");
static_assert(offsetof(AttributeInitializer_CalculateAttributeInitialValue, ReturnValue) == 0x000008, "Member 'AttributeInitializer_CalculateAttributeInitialValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AIDodgeComponent.TriggerBulletDodge
// 0x0028 (0x0028 - 0x0000)
struct AIDodgeComponent_TriggerBulletDodge final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MuzzleLoc;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BulletVel;                                         // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIDodgeComponent_TriggerBulletDodge) == 0x000008, "Wrong alignment on AIDodgeComponent_TriggerBulletDodge");
static_assert(sizeof(AIDodgeComponent_TriggerBulletDodge) == 0x000028, "Wrong size on AIDodgeComponent_TriggerBulletDodge");
static_assert(offsetof(AIDodgeComponent_TriggerBulletDodge, WorldContextObject) == 0x000000, "Member 'AIDodgeComponent_TriggerBulletDodge::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerBulletDodge, MuzzleLoc) == 0x000008, "Member 'AIDodgeComponent_TriggerBulletDodge::MuzzleLoc' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerBulletDodge, BulletVel) == 0x000014, "Member 'AIDodgeComponent_TriggerBulletDodge::BulletVel' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerBulletDodge, Instigator) == 0x000020, "Member 'AIDodgeComponent_TriggerBulletDodge::Instigator' has a wrong offset!");

// Function GbxGameSystemCore.AIDodgeComponent.TriggerGrenadeDodge
// 0x0028 (0x0028 - 0x0000)
struct AIDodgeComponent_TriggerGrenadeDodge final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GrenadeLoc;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraDelay;                                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIDodgeComponent_TriggerGrenadeDodge) == 0x000008, "Wrong alignment on AIDodgeComponent_TriggerGrenadeDodge");
static_assert(sizeof(AIDodgeComponent_TriggerGrenadeDodge) == 0x000028, "Wrong size on AIDodgeComponent_TriggerGrenadeDodge");
static_assert(offsetof(AIDodgeComponent_TriggerGrenadeDodge, WorldContextObject) == 0x000000, "Member 'AIDodgeComponent_TriggerGrenadeDodge::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerGrenadeDodge, GrenadeLoc) == 0x000008, "Member 'AIDodgeComponent_TriggerGrenadeDodge::GrenadeLoc' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerGrenadeDodge, Instigator) == 0x000018, "Member 'AIDodgeComponent_TriggerGrenadeDodge::Instigator' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerGrenadeDodge, ExtraDelay) == 0x000020, "Member 'AIDodgeComponent_TriggerGrenadeDodge::ExtraDelay' has a wrong offset!");

// Function GbxGameSystemCore.AIDodgeComponent.TriggerZoneDodge
// 0x0030 (0x0030 - 0x0000)
struct AIDodgeComponent_TriggerZoneDodge final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoneLoc;                                           // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoneVel;                                           // 0x001C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorRef;                                          // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIDodgeComponent_TriggerZoneDodge) == 0x000008, "Wrong alignment on AIDodgeComponent_TriggerZoneDodge");
static_assert(sizeof(AIDodgeComponent_TriggerZoneDodge) == 0x000030, "Wrong size on AIDodgeComponent_TriggerZoneDodge");
static_assert(offsetof(AIDodgeComponent_TriggerZoneDodge, WorldContextObject) == 0x000000, "Member 'AIDodgeComponent_TriggerZoneDodge::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerZoneDodge, TargetActor) == 0x000008, "Member 'AIDodgeComponent_TriggerZoneDodge::TargetActor' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerZoneDodge, ZoneLoc) == 0x000010, "Member 'AIDodgeComponent_TriggerZoneDodge::ZoneLoc' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerZoneDodge, ZoneVel) == 0x00001C, "Member 'AIDodgeComponent_TriggerZoneDodge::ZoneVel' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerZoneDodge, ActorRef) == 0x000028, "Member 'AIDodgeComponent_TriggerZoneDodge::ActorRef' has a wrong offset!");

// Function GbxGameSystemCore.AIDodgeComponent.TriggerDodge
// 0x0020 (0x0020 - 0x0000)
struct AIDodgeComponent_TriggerDodge final
{
public:
	EAIDodgeType                                  Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SourceLoc;                                         // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraDelay;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIDodgeComponent_TriggerDodge) == 0x000008, "Wrong alignment on AIDodgeComponent_TriggerDodge");
static_assert(sizeof(AIDodgeComponent_TriggerDodge) == 0x000020, "Wrong size on AIDodgeComponent_TriggerDodge");
static_assert(offsetof(AIDodgeComponent_TriggerDodge, Type) == 0x000000, "Member 'AIDodgeComponent_TriggerDodge::Type' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerDodge, SourceLoc) == 0x000004, "Member 'AIDodgeComponent_TriggerDodge::SourceLoc' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerDodge, SourceActor) == 0x000010, "Member 'AIDodgeComponent_TriggerDodge::SourceActor' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerDodge, ExtraDelay) == 0x000018, "Member 'AIDodgeComponent_TriggerDodge::ExtraDelay' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerDodge, bForced) == 0x00001C, "Member 'AIDodgeComponent_TriggerDodge::bForced' has a wrong offset!");
static_assert(offsetof(AIDodgeComponent_TriggerDodge, ReturnValue) == 0x00001D, "Member 'AIDodgeComponent_TriggerDodge::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AISense_Bullet.ReportBulletEvent
// 0x0038 (0x0038 - 0x0000)
struct AISense_Bullet_ReportBulletEvent final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLoc;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLoc;                                            // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstEvent;                                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AISense_Bullet_ReportBulletEvent) == 0x000008, "Wrong alignment on AISense_Bullet_ReportBulletEvent");
static_assert(sizeof(AISense_Bullet_ReportBulletEvent) == 0x000038, "Wrong size on AISense_Bullet_ReportBulletEvent");
static_assert(offsetof(AISense_Bullet_ReportBulletEvent, WorldContext) == 0x000000, "Member 'AISense_Bullet_ReportBulletEvent::WorldContext' has a wrong offset!");
static_assert(offsetof(AISense_Bullet_ReportBulletEvent, StartLoc) == 0x000008, "Member 'AISense_Bullet_ReportBulletEvent::StartLoc' has a wrong offset!");
static_assert(offsetof(AISense_Bullet_ReportBulletEvent, EndLoc) == 0x000014, "Member 'AISense_Bullet_ReportBulletEvent::EndLoc' has a wrong offset!");
static_assert(offsetof(AISense_Bullet_ReportBulletEvent, bFirstEvent) == 0x000020, "Member 'AISense_Bullet_ReportBulletEvent::bFirstEvent' has a wrong offset!");
static_assert(offsetof(AISense_Bullet_ReportBulletEvent, Instigator) == 0x000028, "Member 'AISense_Bullet_ReportBulletEvent::Instigator' has a wrong offset!");
static_assert(offsetof(AISense_Bullet_ReportBulletEvent, Strength) == 0x000030, "Member 'AISense_Bullet_ReportBulletEvent::Strength' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsComponent.GetStatValue
// 0x0010 (0x0010 - 0x0000)
struct GameStatsComponent_GetStatValue final
{
public:
	class UGameStatData*                          GameStat;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStatsComponent_GetStatValue) == 0x000008, "Wrong alignment on GameStatsComponent_GetStatValue");
static_assert(sizeof(GameStatsComponent_GetStatValue) == 0x000010, "Wrong size on GameStatsComponent_GetStatValue");
static_assert(offsetof(GameStatsComponent_GetStatValue, GameStat) == 0x000000, "Member 'GameStatsComponent_GetStatValue::GameStat' has a wrong offset!");
static_assert(offsetof(GameStatsComponent_GetStatValue, ReturnValue) == 0x000008, "Member 'GameStatsComponent_GetStatValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsComponent.IncrementStat
// 0x0010 (0x0010 - 0x0000)
struct GameStatsComponent_IncrementStat final
{
public:
	class UGameStatData*                          GameStat;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStatsComponent_IncrementStat) == 0x000008, "Wrong alignment on GameStatsComponent_IncrementStat");
static_assert(sizeof(GameStatsComponent_IncrementStat) == 0x000010, "Wrong size on GameStatsComponent_IncrementStat");
static_assert(offsetof(GameStatsComponent_IncrementStat, GameStat) == 0x000000, "Member 'GameStatsComponent_IncrementStat::GameStat' has a wrong offset!");
static_assert(offsetof(GameStatsComponent_IncrementStat, Amount) == 0x000008, "Member 'GameStatsComponent_IncrementStat::Amount' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsComponent.UpdateStat
// 0x0010 (0x0010 - 0x0000)
struct GameStatsComponent_UpdateStat final
{
public:
	class UGameStatData*                          GameStat;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewValue;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStatsComponent_UpdateStat) == 0x000008, "Wrong alignment on GameStatsComponent_UpdateStat");
static_assert(sizeof(GameStatsComponent_UpdateStat) == 0x000010, "Wrong size on GameStatsComponent_UpdateStat");
static_assert(offsetof(GameStatsComponent_UpdateStat, GameStat) == 0x000000, "Member 'GameStatsComponent_UpdateStat::GameStat' has a wrong offset!");
static_assert(offsetof(GameStatsComponent_UpdateStat, NewValue) == 0x000008, "Member 'GameStatsComponent_UpdateStat::NewValue' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsComponent.GetGameStats
// 0x0010 (0x0010 - 0x0000)
struct GameStatsComponent_GetGameStats final
{
public:
	TArray<struct FGameStat>                      ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStatsComponent_GetGameStats) == 0x000008, "Wrong alignment on GameStatsComponent_GetGameStats");
static_assert(sizeof(GameStatsComponent_GetGameStats) == 0x000010, "Wrong size on GameStatsComponent_GetGameStats");
static_assert(offsetof(GameStatsComponent_GetGameStats, ReturnValue) == 0x000000, "Member 'GameStatsComponent_GetGameStats::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.AISense_GbxSight.ForceSightEvent
// 0x0018 (0x0018 - 0x0000)
struct AISense_GbxSight_ForceSightEvent final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SeenActor;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LookingActor;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AISense_GbxSight_ForceSightEvent) == 0x000008, "Wrong alignment on AISense_GbxSight_ForceSightEvent");
static_assert(sizeof(AISense_GbxSight_ForceSightEvent) == 0x000018, "Wrong size on AISense_GbxSight_ForceSightEvent");
static_assert(offsetof(AISense_GbxSight_ForceSightEvent, WorldContext) == 0x000000, "Member 'AISense_GbxSight_ForceSightEvent::WorldContext' has a wrong offset!");
static_assert(offsetof(AISense_GbxSight_ForceSightEvent, SeenActor) == 0x000008, "Member 'AISense_GbxSight_ForceSightEvent::SeenActor' has a wrong offset!");
static_assert(offsetof(AISense_GbxSight_ForceSightEvent, LookingActor) == 0x000010, "Member 'AISense_GbxSight_ForceSightEvent::LookingActor' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolManagerComponent.AddResourcePoolDelegate
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolManagerComponent_AddResourcePoolDelegate final
{
public:
	class UGameResourceData*                      InResourceData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DelegatePropertyName;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameResourcePoolReference& ResourcePool)> ScriptDelegate;                                    // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolManagerComponent_AddResourcePoolDelegate) == 0x000008, "Wrong alignment on GameResourcePoolManagerComponent_AddResourcePoolDelegate");
static_assert(sizeof(GameResourcePoolManagerComponent_AddResourcePoolDelegate) == 0x000020, "Wrong size on GameResourcePoolManagerComponent_AddResourcePoolDelegate");
static_assert(offsetof(GameResourcePoolManagerComponent_AddResourcePoolDelegate, InResourceData) == 0x000000, "Member 'GameResourcePoolManagerComponent_AddResourcePoolDelegate::InResourceData' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_AddResourcePoolDelegate, DelegatePropertyName) == 0x000008, "Member 'GameResourcePoolManagerComponent_AddResourcePoolDelegate::DelegatePropertyName' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_AddResourcePoolDelegate, ScriptDelegate) == 0x000010, "Member 'GameResourcePoolManagerComponent_AddResourcePoolDelegate::ScriptDelegate' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolManagerComponent.ClearResourcePoolDelegate
// 0x0010 (0x0010 - 0x0000)
struct GameResourcePoolManagerComponent_ClearResourcePoolDelegate final
{
public:
	class UGameResourceData*                      InResourceData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DelegatePropertyName;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolManagerComponent_ClearResourcePoolDelegate) == 0x000008, "Wrong alignment on GameResourcePoolManagerComponent_ClearResourcePoolDelegate");
static_assert(sizeof(GameResourcePoolManagerComponent_ClearResourcePoolDelegate) == 0x000010, "Wrong size on GameResourcePoolManagerComponent_ClearResourcePoolDelegate");
static_assert(offsetof(GameResourcePoolManagerComponent_ClearResourcePoolDelegate, InResourceData) == 0x000000, "Member 'GameResourcePoolManagerComponent_ClearResourcePoolDelegate::InResourceData' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_ClearResourcePoolDelegate, DelegatePropertyName) == 0x000008, "Member 'GameResourcePoolManagerComponent_ClearResourcePoolDelegate::DelegatePropertyName' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolManagerComponent.CreatePool
// 0x0028 (0x0028 - 0x0000)
struct GameResourcePoolManagerComponent_CreatePool final
{
public:
	class UGameResourcePoolData*                  PoolData;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReinitializeExistingPool;                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameResourcePoolReference             ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolManagerComponent_CreatePool) == 0x000008, "Wrong alignment on GameResourcePoolManagerComponent_CreatePool");
static_assert(sizeof(GameResourcePoolManagerComponent_CreatePool) == 0x000028, "Wrong size on GameResourcePoolManagerComponent_CreatePool");
static_assert(offsetof(GameResourcePoolManagerComponent_CreatePool, PoolData) == 0x000000, "Member 'GameResourcePoolManagerComponent_CreatePool::PoolData' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_CreatePool, bReinitializeExistingPool) == 0x000008, "Member 'GameResourcePoolManagerComponent_CreatePool::bReinitializeExistingPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_CreatePool, ReturnValue) == 0x000010, "Member 'GameResourcePoolManagerComponent_CreatePool::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolManagerComponent.GetResourcePoolByResource
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolManagerComponent_GetResourcePoolByResource final
{
public:
	class UGameResourceData*                      Resource;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameResourcePoolReference             ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolManagerComponent_GetResourcePoolByResource) == 0x000008, "Wrong alignment on GameResourcePoolManagerComponent_GetResourcePoolByResource");
static_assert(sizeof(GameResourcePoolManagerComponent_GetResourcePoolByResource) == 0x000020, "Wrong size on GameResourcePoolManagerComponent_GetResourcePoolByResource");
static_assert(offsetof(GameResourcePoolManagerComponent_GetResourcePoolByResource, Resource) == 0x000000, "Member 'GameResourcePoolManagerComponent_GetResourcePoolByResource::Resource' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_GetResourcePoolByResource, ReturnValue) == 0x000008, "Member 'GameResourcePoolManagerComponent_GetResourcePoolByResource::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolManagerComponent.OnOwnerExperienceLevelChanged
// 0x0004 (0x0004 - 0x0000)
struct GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged final
{
public:
	int32                                         OldExperienceLevel;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged) == 0x000004, "Wrong alignment on GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged");
static_assert(sizeof(GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged) == 0x000004, "Wrong size on GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged");
static_assert(offsetof(GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged, OldExperienceLevel) == 0x000000, "Member 'GameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged::OldExperienceLevel' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolManagerComponent.RemoveResourcePoolDelegate
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolManagerComponent_RemoveResourcePoolDelegate final
{
public:
	class UGameResourceData*                      InResourceData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DelegatePropertyName;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGameResourcePoolReference& ResourcePool)> ScriptDelegate;                                    // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolManagerComponent_RemoveResourcePoolDelegate) == 0x000008, "Wrong alignment on GameResourcePoolManagerComponent_RemoveResourcePoolDelegate");
static_assert(sizeof(GameResourcePoolManagerComponent_RemoveResourcePoolDelegate) == 0x000020, "Wrong size on GameResourcePoolManagerComponent_RemoveResourcePoolDelegate");
static_assert(offsetof(GameResourcePoolManagerComponent_RemoveResourcePoolDelegate, InResourceData) == 0x000000, "Member 'GameResourcePoolManagerComponent_RemoveResourcePoolDelegate::InResourceData' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_RemoveResourcePoolDelegate, DelegatePropertyName) == 0x000008, "Member 'GameResourcePoolManagerComponent_RemoveResourcePoolDelegate::DelegatePropertyName' has a wrong offset!");
static_assert(offsetof(GameResourcePoolManagerComponent_RemoveResourcePoolDelegate, ScriptDelegate) == 0x000010, "Member 'GameResourcePoolManagerComponent_RemoveResourcePoolDelegate::ScriptDelegate' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_AICharge.OnHitWall
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_AICharge_OnHitWall final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_AICharge_OnHitWall) == 0x000008, "Wrong alignment on GbxAction_AICharge_OnHitWall");
static_assert(sizeof(GbxAction_AICharge_OnHitWall) == 0x000008, "Wrong size on GbxAction_AICharge_OnHitWall");
static_assert(offsetof(GbxAction_AICharge_OnHitWall, Actor) == 0x000000, "Member 'GbxAction_AICharge_OnHitWall::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_AICharge.OnLoop
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_AICharge_OnLoop final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_AICharge_OnLoop) == 0x000008, "Wrong alignment on GbxAction_AICharge_OnLoop");
static_assert(sizeof(GbxAction_AICharge_OnLoop) == 0x000008, "Wrong size on GbxAction_AICharge_OnLoop");
static_assert(offsetof(GbxAction_AICharge_OnLoop, Actor) == 0x000000, "Member 'GbxAction_AICharge_OnLoop::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_AICharge.OnMiss
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_AICharge_OnMiss final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_AICharge_OnMiss) == 0x000008, "Wrong alignment on GbxAction_AICharge_OnMiss");
static_assert(sizeof(GbxAction_AICharge_OnMiss) == 0x000008, "Wrong size on GbxAction_AICharge_OnMiss");
static_assert(offsetof(GbxAction_AICharge_OnMiss, Actor) == 0x000000, "Member 'GbxAction_AICharge_OnMiss::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_AICharge.OnReachCliff
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_AICharge_OnReachCliff final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_AICharge_OnReachCliff) == 0x000008, "Wrong alignment on GbxAction_AICharge_OnReachCliff");
static_assert(sizeof(GbxAction_AICharge_OnReachCliff) == 0x000008, "Wrong size on GbxAction_AICharge_OnReachCliff");
static_assert(offsetof(GbxAction_AICharge_OnReachCliff, Actor) == 0x000000, "Member 'GbxAction_AICharge_OnReachCliff::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_AICharge.OnStopForFriendly
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_AICharge_OnStopForFriendly final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_AICharge_OnStopForFriendly) == 0x000008, "Wrong alignment on GbxAction_AICharge_OnStopForFriendly");
static_assert(sizeof(GbxAction_AICharge_OnStopForFriendly) == 0x000008, "Wrong size on GbxAction_AICharge_OnStopForFriendly");
static_assert(offsetof(GbxAction_AICharge_OnStopForFriendly, Actor) == 0x000000, "Member 'GbxAction_AICharge_OnStopForFriendly::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAction_AICharge.OnStrike
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_AICharge_OnStrike final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_AICharge_OnStrike) == 0x000008, "Wrong alignment on GbxAction_AICharge_OnStrike");
static_assert(sizeof(GbxAction_AICharge_OnStrike) == 0x000008, "Wrong size on GbxAction_AICharge_OnStrike");
static_assert(offsetof(GbxAction_AICharge_OnStrike, Actor) == 0x000000, "Member 'GbxAction_AICharge_OnStrike::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.K2_Play
// 0x0010 (0x0010 - 0x0000)
struct GbxActionComponent_K2_Play final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_K2_Play) == 0x000008, "Wrong alignment on GbxActionComponent_K2_Play");
static_assert(sizeof(GbxActionComponent_K2_Play) == 0x000010, "Wrong size on GbxActionComponent_K2_Play");
static_assert(offsetof(GbxActionComponent_K2_Play, ActionClass) == 0x000000, "Member 'GbxActionComponent_K2_Play::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_K2_Play, ReturnValue) == 0x000008, "Member 'GbxActionComponent_K2_Play::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.OnComponentAttached
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_OnComponentAttached final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_OnComponentAttached) == 0x000008, "Wrong alignment on GbxActionComponent_OnComponentAttached");
static_assert(sizeof(GbxActionComponent_OnComponentAttached) == 0x000008, "Wrong size on GbxActionComponent_OnComponentAttached");
static_assert(offsetof(GbxActionComponent_OnComponentAttached, SceneComponent) == 0x000000, "Member 'GbxActionComponent_OnComponentAttached::SceneComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.OnComponentDetached
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_OnComponentDetached final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_OnComponentDetached) == 0x000008, "Wrong alignment on GbxActionComponent_OnComponentDetached");
static_assert(sizeof(GbxActionComponent_OnComponentDetached) == 0x000008, "Wrong size on GbxActionComponent_OnComponentDetached");
static_assert(offsetof(GbxActionComponent_OnComponentDetached, SceneComponent) == 0x000000, "Member 'GbxActionComponent_OnComponentDetached::SceneComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.OnComponentUnregistered
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_OnComponentUnregistered final
{
public:
	class UActorComponent*                        ActorComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_OnComponentUnregistered) == 0x000008, "Wrong alignment on GbxActionComponent_OnComponentUnregistered");
static_assert(sizeof(GbxActionComponent_OnComponentUnregistered) == 0x000008, "Wrong size on GbxActionComponent_OnComponentUnregistered");
static_assert(offsetof(GbxActionComponent_OnComponentUnregistered, ActorComponent) == 0x000000, "Member 'GbxActionComponent_OnComponentUnregistered::ActorComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.PlayOnRemoteServer
// 0x00D0 (0x00D0 - 0x0000)
struct GbxActionComponent_PlayOnRemoteServer final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActionState_Base                      ActionData;                                        // 0x0008(0x00C8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_PlayOnRemoteServer) == 0x000008, "Wrong alignment on GbxActionComponent_PlayOnRemoteServer");
static_assert(sizeof(GbxActionComponent_PlayOnRemoteServer) == 0x0000D0, "Wrong size on GbxActionComponent_PlayOnRemoteServer");
static_assert(offsetof(GbxActionComponent_PlayOnRemoteServer, ActionClass) == 0x000000, "Member 'GbxActionComponent_PlayOnRemoteServer::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_PlayOnRemoteServer, ActionData) == 0x000008, "Member 'GbxActionComponent_PlayOnRemoteServer::ActionData' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.StopActionClass
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_StopActionClass final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_StopActionClass) == 0x000008, "Wrong alignment on GbxActionComponent_StopActionClass");
static_assert(sizeof(GbxActionComponent_StopActionClass) == 0x000008, "Wrong size on GbxActionComponent_StopActionClass");
static_assert(offsetof(GbxActionComponent_StopActionClass, ActionClass) == 0x000000, "Member 'GbxActionComponent_StopActionClass::ActionClass' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.StopActionSlot
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_StopActionSlot final
{
public:
	class FName                                   ActionSlotName;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_StopActionSlot) == 0x000004, "Wrong alignment on GbxActionComponent_StopActionSlot");
static_assert(sizeof(GbxActionComponent_StopActionSlot) == 0x000008, "Wrong size on GbxActionComponent_StopActionSlot");
static_assert(offsetof(GbxActionComponent_StopActionSlot, ActionSlotName) == 0x000000, "Member 'GbxActionComponent_StopActionSlot::ActionSlotName' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.StopLoopingActionClass
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_StopLoopingActionClass final
{
public:
	TSubclassOf<class UGbxAction_Loop>            ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_StopLoopingActionClass) == 0x000008, "Wrong alignment on GbxActionComponent_StopLoopingActionClass");
static_assert(sizeof(GbxActionComponent_StopLoopingActionClass) == 0x000008, "Wrong size on GbxActionComponent_StopLoopingActionClass");
static_assert(offsetof(GbxActionComponent_StopLoopingActionClass, ActionClass) == 0x000000, "Member 'GbxActionComponent_StopLoopingActionClass::ActionClass' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.StopOnRemoteServer
// 0x0008 (0x0008 - 0x0000)
struct GbxActionComponent_StopOnRemoteServer final
{
public:
	int32                                         ManagerRepId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxActionEndState                            EndState;                                          // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionComponent_StopOnRemoteServer) == 0x000004, "Wrong alignment on GbxActionComponent_StopOnRemoteServer");
static_assert(sizeof(GbxActionComponent_StopOnRemoteServer) == 0x000008, "Wrong size on GbxActionComponent_StopOnRemoteServer");
static_assert(offsetof(GbxActionComponent_StopOnRemoteServer, ManagerRepId) == 0x000000, "Member 'GbxActionComponent_StopOnRemoteServer::ManagerRepId' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_StopOnRemoteServer, EndState) == 0x000004, "Member 'GbxActionComponent_StopOnRemoteServer::EndState' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.UpdateActionRemoteServer
// 0x00C8 (0x00C8 - 0x0000)
struct GbxActionComponent_UpdateActionRemoteServer final
{
public:
	struct FActionState_Base                      ActionData;                                        // 0x0000(0x00C8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_UpdateActionRemoteServer) == 0x000008, "Wrong alignment on GbxActionComponent_UpdateActionRemoteServer");
static_assert(sizeof(GbxActionComponent_UpdateActionRemoteServer) == 0x0000C8, "Wrong size on GbxActionComponent_UpdateActionRemoteServer");
static_assert(offsetof(GbxActionComponent_UpdateActionRemoteServer, ActionData) == 0x000000, "Member 'GbxActionComponent_UpdateActionRemoteServer::ActionData' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.IsPlayingClass
// 0x0010 (0x0010 - 0x0000)
struct GbxActionComponent_IsPlayingClass final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionComponent_IsPlayingClass) == 0x000008, "Wrong alignment on GbxActionComponent_IsPlayingClass");
static_assert(sizeof(GbxActionComponent_IsPlayingClass) == 0x000010, "Wrong size on GbxActionComponent_IsPlayingClass");
static_assert(offsetof(GbxActionComponent_IsPlayingClass, ActionClass) == 0x000000, "Member 'GbxActionComponent_IsPlayingClass::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_IsPlayingClass, ReturnValue) == 0x000008, "Member 'GbxActionComponent_IsPlayingClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.IsPlayingSlot
// 0x0010 (0x0010 - 0x0000)
struct GbxActionComponent_IsPlayingSlot final
{
public:
	class FName                                   ActionSlotName;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionComponent_IsPlayingSlot) == 0x000004, "Wrong alignment on GbxActionComponent_IsPlayingSlot");
static_assert(sizeof(GbxActionComponent_IsPlayingSlot) == 0x000010, "Wrong size on GbxActionComponent_IsPlayingSlot");
static_assert(offsetof(GbxActionComponent_IsPlayingSlot, ActionSlotName) == 0x000000, "Member 'GbxActionComponent_IsPlayingSlot::ActionSlotName' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_IsPlayingSlot, ReturnValue) == 0x000008, "Member 'GbxActionComponent_IsPlayingSlot::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.K2_GetActionByClass
// 0x0010 (0x0010 - 0x0000)
struct GbxActionComponent_K2_GetActionByClass final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_K2_GetActionByClass) == 0x000008, "Wrong alignment on GbxActionComponent_K2_GetActionByClass");
static_assert(sizeof(GbxActionComponent_K2_GetActionByClass) == 0x000010, "Wrong size on GbxActionComponent_K2_GetActionByClass");
static_assert(offsetof(GbxActionComponent_K2_GetActionByClass, ActionClass) == 0x000000, "Member 'GbxActionComponent_K2_GetActionByClass::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_K2_GetActionByClass, ReturnValue) == 0x000008, "Member 'GbxActionComponent_K2_GetActionByClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.K2_GetActionBySlot
// 0x0010 (0x0010 - 0x0000)
struct GbxActionComponent_K2_GetActionBySlot final
{
public:
	class FName                                   ActionSlotName;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionComponent_K2_GetActionBySlot) == 0x000008, "Wrong alignment on GbxActionComponent_K2_GetActionBySlot");
static_assert(sizeof(GbxActionComponent_K2_GetActionBySlot) == 0x000010, "Wrong size on GbxActionComponent_K2_GetActionBySlot");
static_assert(offsetof(GbxActionComponent_K2_GetActionBySlot, ActionSlotName) == 0x000000, "Member 'GbxActionComponent_K2_GetActionBySlot::ActionSlotName' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_K2_GetActionBySlot, ReturnValue) == 0x000008, "Member 'GbxActionComponent_K2_GetActionBySlot::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionComponent.K2_IsPlayingObj
// 0x0010 (0x0010 - 0x0000)
struct GbxActionComponent_K2_IsPlayingObj final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionComponent_K2_IsPlayingObj) == 0x000008, "Wrong alignment on GbxActionComponent_K2_IsPlayingObj");
static_assert(sizeof(GbxActionComponent_K2_IsPlayingObj) == 0x000010, "Wrong size on GbxActionComponent_K2_IsPlayingObj");
static_assert(offsetof(GbxActionComponent_K2_IsPlayingObj, Action) == 0x000000, "Member 'GbxActionComponent_K2_IsPlayingObj::Action' has a wrong offset!");
static_assert(offsetof(GbxActionComponent_K2_IsPlayingObj, ReturnValue) == 0x000008, "Member 'GbxActionComponent_K2_IsPlayingObj::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.CreateBoneMod
// 0x0060 (0x0060 - 0x0000)
struct BoneModBlueprintLibrary_CreateBoneMod final
{
public:
	class FName                                   InBoneModName;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBoneName;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InTranslation;                                     // 0x0010(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRotation;                                        // 0x001C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InScale;                                           // 0x0028(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendTime;                                       // 0x0034(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             InBlendOption;                                     // 0x0040(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCurveFloat*                      InCustomBlendCurve;                                // 0x0048(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInUseTranslation;                                 // 0x0050(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInUseRotation;                                    // 0x0051(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInUseScale;                                       // 0x0052(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInReplaceTranslation;                             // 0x0053(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInReplaceRotation;                                // 0x0054(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInReplaceScale;                                   // 0x0055(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             InTranslationSpace;                                // 0x0056(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             InRotationSpace;                                   // 0x0057(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendIn;                                          // 0x0058(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoneModBlueprintLibrary_CreateBoneMod) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_CreateBoneMod");
static_assert(sizeof(BoneModBlueprintLibrary_CreateBoneMod) == 0x000060, "Wrong size on BoneModBlueprintLibrary_CreateBoneMod");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InBoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InBoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InBoneName) == 0x000008, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InBoneName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InTranslation) == 0x000010, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InTranslation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InRotation) == 0x00001C, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InRotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InScale) == 0x000028, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InScale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InBlendTime) == 0x000034, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InBlendTime' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, Target) == 0x000038, "Member 'BoneModBlueprintLibrary_CreateBoneMod::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InBlendOption) == 0x000040, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InBlendOption' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InCustomBlendCurve) == 0x000048, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InCustomBlendCurve' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bInUseTranslation) == 0x000050, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bInUseTranslation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bInUseRotation) == 0x000051, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bInUseRotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bInUseScale) == 0x000052, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bInUseScale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bInReplaceTranslation) == 0x000053, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bInReplaceTranslation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bInReplaceRotation) == 0x000054, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bInReplaceRotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bInReplaceScale) == 0x000055, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bInReplaceScale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InTranslationSpace) == 0x000056, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InTranslationSpace' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, InRotationSpace) == 0x000057, "Member 'BoneModBlueprintLibrary_CreateBoneMod::InRotationSpace' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_CreateBoneMod, bBlendIn) == 0x000058, "Member 'BoneModBlueprintLibrary_CreateBoneMod::bBlendIn' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.GetBoneMod
// 0x0100 (0x0100 - 0x0000)
struct BoneModBlueprintLibrary_GetBoneMod final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneModInstance                       BoneMod;                                           // 0x0008(0x00E8)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x00F0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoneModBlueprintLibrary_GetBoneMod) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_GetBoneMod");
static_assert(sizeof(BoneModBlueprintLibrary_GetBoneMod) == 0x000100, "Wrong size on BoneModBlueprintLibrary_GetBoneMod");
static_assert(offsetof(BoneModBlueprintLibrary_GetBoneMod, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_GetBoneMod::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_GetBoneMod, BoneMod) == 0x000008, "Member 'BoneModBlueprintLibrary_GetBoneMod::BoneMod' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_GetBoneMod, Target) == 0x0000F0, "Member 'BoneModBlueprintLibrary_GetBoneMod::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_GetBoneMod, ReturnValue) == 0x0000F8, "Member 'BoneModBlueprintLibrary_GetBoneMod::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.RemoveBoneMod
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_RemoveBoneMod final
{
public:
	class FName                                   BoneModToRemove;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendOut;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoneModBlueprintLibrary_RemoveBoneMod) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_RemoveBoneMod");
static_assert(sizeof(BoneModBlueprintLibrary_RemoveBoneMod) == 0x000018, "Wrong size on BoneModBlueprintLibrary_RemoveBoneMod");
static_assert(offsetof(BoneModBlueprintLibrary_RemoveBoneMod, BoneModToRemove) == 0x000000, "Member 'BoneModBlueprintLibrary_RemoveBoneMod::BoneModToRemove' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_RemoveBoneMod, Target) == 0x000008, "Member 'BoneModBlueprintLibrary_RemoveBoneMod::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_RemoveBoneMod, bBlendOut) == 0x000010, "Member 'BoneModBlueprintLibrary_RemoveBoneMod::bBlendOut' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneMod
// 0x0100 (0x0100 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneMod final
{
public:
	struct FBoneModInstance                       InBoneMod;                                         // 0x0000(0x00E8)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BoneModToSet;                                      // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x00F0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendIn;                                          // 0x00F8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneMod) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneMod");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneMod) == 0x000100, "Wrong size on BoneModBlueprintLibrary_SetBoneMod");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneMod, InBoneMod) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneMod::InBoneMod' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneMod, BoneModToSet) == 0x0000E8, "Member 'BoneModBlueprintLibrary_SetBoneMod::BoneModToSet' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneMod, Target) == 0x0000F0, "Member 'BoneModBlueprintLibrary_SetBoneMod::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneMod, bBlendIn) == 0x0000F8, "Member 'BoneModBlueprintLibrary_SetBoneMod::bBlendIn' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModActive
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModActive final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModActive) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModActive");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModActive) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModActive");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModActive, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModActive::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModActive, bActive) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModActive::bActive' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModActive, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModActive::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModAlphaBlend
// 0x0048 (0x0048 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModAlphaBlend final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            Blend;                                             // 0x0008(0x0038)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModAlphaBlend) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModAlphaBlend");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModAlphaBlend) == 0x000048, "Wrong size on BoneModBlueprintLibrary_SetBoneModAlphaBlend");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModAlphaBlend, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModAlphaBlend::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModAlphaBlend, Blend) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModAlphaBlend::Blend' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModAlphaBlend, Target) == 0x000040, "Member 'BoneModBlueprintLibrary_SetBoneModAlphaBlend::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModBlendTime
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModBlendTime final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModBlendTime) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModBlendTime");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModBlendTime) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModBlendTime");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModBlendTime, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModBlendTime::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModBlendTime, BlendTime) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModBlendTime::BlendTime' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModBlendTime, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModBlendTime::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModBoneName
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModBoneName final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneModBoneName;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModBoneName) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModBoneName");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModBoneName) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModBoneName");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModBoneName, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModBoneName::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModBoneName, BoneModBoneName) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModBoneName::BoneModBoneName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModBoneName, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModBoneName::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModifyProfile
// 0x0010 (0x0010 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModifyProfile final
{
public:
	class UGbxBoneModifyProfile*                  BoneModifyProfile;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModifyProfile) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModifyProfile");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModifyProfile) == 0x000010, "Wrong size on BoneModBlueprintLibrary_SetBoneModifyProfile");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModifyProfile, BoneModifyProfile) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModifyProfile::BoneModifyProfile' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModifyProfile, Target) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModifyProfile::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModifyProfileState
// 0x0020 (0x0020 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModifyProfileState final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModifyProfileState) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModifyProfileState");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModifyProfileState) == 0x000020, "Wrong size on BoneModBlueprintLibrary_SetBoneModifyProfileState");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModifyProfileState, StateName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModifyProfileState::StateName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModifyProfileState, bActive) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModifyProfileState::bActive' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModifyProfileState, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModifyProfileState::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModifyProfileState, BlendTime) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneModifyProfileState::BlendTime' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModName
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModName final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewBoneModName;                                    // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModName) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModName");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModName) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModName");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModName, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModName::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModName, NewBoneModName) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModName::NewBoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModName, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModName::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceRotation
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModReplaceRotation final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceRotation;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModReplaceRotation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModReplaceRotation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModReplaceRotation) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModReplaceRotation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceRotation, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceRotation::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceRotation, bReplaceRotation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceRotation::bReplaceRotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceRotation, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceRotation::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceScale
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModReplaceScale final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceScale;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModReplaceScale) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModReplaceScale");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModReplaceScale) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModReplaceScale");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceScale, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceScale::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceScale, bReplaceScale) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceScale::bReplaceScale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceScale, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceScale::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceTranslation
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModReplaceTranslation final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceTranslation;                               // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModReplaceTranslation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModReplaceTranslation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModReplaceTranslation) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModReplaceTranslation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceTranslation, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceTranslation::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceTranslation, bReplaceTranslation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceTranslation::bReplaceTranslation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModReplaceTranslation, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModReplaceTranslation::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModRotation
// 0x0020 (0x0020 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModRotation final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModRotation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModRotation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModRotation) == 0x000020, "Wrong size on BoneModBlueprintLibrary_SetBoneModRotation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModRotation, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModRotation::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModRotation, Rotation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModRotation::Rotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModRotation, Target) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneModRotation::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModRotationSpace
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModRotationSpace final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             RotationSpace;                                     // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModRotationSpace) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModRotationSpace");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModRotationSpace) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModRotationSpace");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModRotationSpace, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModRotationSpace::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModRotationSpace, RotationSpace) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModRotationSpace::RotationSpace' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModRotationSpace, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModRotationSpace::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModScale
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModScale final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModScale) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModScale");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModScale) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModScale");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModScale, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModScale::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModScale, Scale) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModScale::Scale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModScale, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModScale::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModScale3D
// 0x0020 (0x0020 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModScale3D final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModScale3D) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModScale3D");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModScale3D) == 0x000020, "Wrong size on BoneModBlueprintLibrary_SetBoneModScale3D");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModScale3D, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModScale3D::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModScale3D, Scale) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModScale3D::Scale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModScale3D, Target) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneModScale3D::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTransform
// 0x0050 (0x0050 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModTransform final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModTransform) == 0x000010, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModTransform");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModTransform) == 0x000050, "Wrong size on BoneModBlueprintLibrary_SetBoneModTransform");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTransform, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModTransform::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTransform, Transform) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModTransform::Transform' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTransform, Target) == 0x000040, "Member 'BoneModBlueprintLibrary_SetBoneModTransform::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTranslation
// 0x0020 (0x0020 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModTranslation final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModTranslation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModTranslation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModTranslation) == 0x000020, "Wrong size on BoneModBlueprintLibrary_SetBoneModTranslation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTranslation, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModTranslation::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTranslation, Translation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModTranslation::Translation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTranslation, Target) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneModTranslation::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTranslationSpace
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModTranslationSpace final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             TranslationSpace;                                  // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModTranslationSpace) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModTranslationSpace");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModTranslationSpace) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModTranslationSpace");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTranslationSpace, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModTranslationSpace::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTranslationSpace, TranslationSpace) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModTranslationSpace::TranslationSpace' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModTranslationSpace, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModTranslationSpace::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseRotation
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModUseRotation final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotation;                                      // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModUseRotation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModUseRotation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModUseRotation) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModUseRotation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseRotation, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModUseRotation::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseRotation, bUseRotation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModUseRotation::bUseRotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseRotation, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModUseRotation::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseScale
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModUseScale final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModUseScale) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModUseScale");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModUseScale) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModUseScale");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseScale, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModUseScale::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseScale, bUseScale) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModUseScale::bUseScale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseScale, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModUseScale::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseTranslation
// 0x0018 (0x0018 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneModUseTranslation final
{
public:
	class FName                                   BoneModName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTranslation;                                   // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneModUseTranslation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneModUseTranslation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneModUseTranslation) == 0x000018, "Wrong size on BoneModBlueprintLibrary_SetBoneModUseTranslation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseTranslation, BoneModName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneModUseTranslation::BoneModName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseTranslation, bUseTranslation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneModUseTranslation::bUseTranslation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneModUseTranslation, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneModUseTranslation::Target' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneRotation
// 0x0030 (0x0030 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneRotation final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendTime;                                       // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             InBlendOption;                                     // 0x0024(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCurveFloat*                      InCustomBlendCurve;                                // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneRotation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneRotation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneRotation) == 0x000030, "Wrong size on BoneModBlueprintLibrary_SetBoneRotation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneRotation, BoneName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneRotation::BoneName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneRotation, Rotation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneRotation::Rotation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneRotation, Target) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneRotation::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneRotation, InBlendTime) == 0x000020, "Member 'BoneModBlueprintLibrary_SetBoneRotation::InBlendTime' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneRotation, InBlendOption) == 0x000024, "Member 'BoneModBlueprintLibrary_SetBoneRotation::InBlendOption' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneRotation, InCustomBlendCurve) == 0x000028, "Member 'BoneModBlueprintLibrary_SetBoneRotation::InCustomBlendCurve' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneScale
// 0x0028 (0x0028 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneScale final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendTime;                                       // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             InBlendOption;                                     // 0x001C(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCurveFloat*                      InCustomBlendCurve;                                // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneScale) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneScale");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneScale) == 0x000028, "Wrong size on BoneModBlueprintLibrary_SetBoneScale");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale, BoneName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneScale::BoneName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale, Scale) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneScale::Scale' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale, Target) == 0x000010, "Member 'BoneModBlueprintLibrary_SetBoneScale::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale, InBlendTime) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneScale::InBlendTime' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale, InBlendOption) == 0x00001C, "Member 'BoneModBlueprintLibrary_SetBoneScale::InBlendOption' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale, InCustomBlendCurve) == 0x000020, "Member 'BoneModBlueprintLibrary_SetBoneScale::InCustomBlendCurve' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneScale3D
// 0x0030 (0x0030 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneScale3D final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale3D;                                           // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendTime;                                       // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             InBlendOption;                                     // 0x0024(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCurveFloat*                      InCustomBlendCurve;                                // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneScale3D) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneScale3D");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneScale3D) == 0x000030, "Wrong size on BoneModBlueprintLibrary_SetBoneScale3D");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale3D, BoneName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneScale3D::BoneName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale3D, Scale3D) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneScale3D::Scale3D' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale3D, Target) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneScale3D::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale3D, InBlendTime) == 0x000020, "Member 'BoneModBlueprintLibrary_SetBoneScale3D::InBlendTime' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale3D, InBlendOption) == 0x000024, "Member 'BoneModBlueprintLibrary_SetBoneScale3D::InBlendOption' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneScale3D, InCustomBlendCurve) == 0x000028, "Member 'BoneModBlueprintLibrary_SetBoneScale3D::InCustomBlendCurve' has a wrong offset!");

// Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneTranslation
// 0x0030 (0x0030 - 0x0000)
struct BoneModBlueprintLibrary_SetBoneTranslation final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendTime;                                       // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             InBlendOption;                                     // 0x0024(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	const class UCurveFloat*                      InCustomBlendCurve;                                // 0x0028(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoneModBlueprintLibrary_SetBoneTranslation) == 0x000008, "Wrong alignment on BoneModBlueprintLibrary_SetBoneTranslation");
static_assert(sizeof(BoneModBlueprintLibrary_SetBoneTranslation) == 0x000030, "Wrong size on BoneModBlueprintLibrary_SetBoneTranslation");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneTranslation, BoneName) == 0x000000, "Member 'BoneModBlueprintLibrary_SetBoneTranslation::BoneName' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneTranslation, Translation) == 0x000008, "Member 'BoneModBlueprintLibrary_SetBoneTranslation::Translation' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneTranslation, Target) == 0x000018, "Member 'BoneModBlueprintLibrary_SetBoneTranslation::Target' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneTranslation, InBlendTime) == 0x000020, "Member 'BoneModBlueprintLibrary_SetBoneTranslation::InBlendTime' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneTranslation, InBlendOption) == 0x000024, "Member 'BoneModBlueprintLibrary_SetBoneTranslation::InBlendOption' has a wrong offset!");
static_assert(offsetof(BoneModBlueprintLibrary_SetBoneTranslation, InCustomBlendCurve) == 0x000028, "Member 'BoneModBlueprintLibrary_SetBoneTranslation::InCustomBlendCurve' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelParentComponent.AddAssociatedActor
// 0x0020 (0x0020 - 0x0000)
struct ChallengeLevelParentComponent_AddAssociatedActor final
{
public:
	class AActor*                                 AssociatedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UChallengeLevelActorComponent> ComponentClass;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeOffset;                                    // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChallengeLevelParentComponent_AddAssociatedActor) == 0x000008, "Wrong alignment on ChallengeLevelParentComponent_AddAssociatedActor");
static_assert(sizeof(ChallengeLevelParentComponent_AddAssociatedActor) == 0x000020, "Wrong size on ChallengeLevelParentComponent_AddAssociatedActor");
static_assert(offsetof(ChallengeLevelParentComponent_AddAssociatedActor, AssociatedActor) == 0x000000, "Member 'ChallengeLevelParentComponent_AddAssociatedActor::AssociatedActor' has a wrong offset!");
static_assert(offsetof(ChallengeLevelParentComponent_AddAssociatedActor, ComponentClass) == 0x000008, "Member 'ChallengeLevelParentComponent_AddAssociatedActor::ComponentClass' has a wrong offset!");
static_assert(offsetof(ChallengeLevelParentComponent_AddAssociatedActor, RelativeOffset) == 0x000010, "Member 'ChallengeLevelParentComponent_AddAssociatedActor::RelativeOffset' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelParentComponent.RemoveAssociatedActor
// 0x0008 (0x0008 - 0x0000)
struct ChallengeLevelParentComponent_RemoveAssociatedActor final
{
public:
	class AActor*                                 AssociatedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelParentComponent_RemoveAssociatedActor) == 0x000008, "Wrong alignment on ChallengeLevelParentComponent_RemoveAssociatedActor");
static_assert(sizeof(ChallengeLevelParentComponent_RemoveAssociatedActor) == 0x000008, "Wrong size on ChallengeLevelParentComponent_RemoveAssociatedActor");
static_assert(offsetof(ChallengeLevelParentComponent_RemoveAssociatedActor, AssociatedActor) == 0x000000, "Member 'ChallengeLevelParentComponent_RemoveAssociatedActor::AssociatedActor' has a wrong offset!");

// Function GbxGameSystemCore.ChallengeLevelParentComponent.RemoveAssociatedActorComponent
// 0x0008 (0x0008 - 0x0000)
struct ChallengeLevelParentComponent_RemoveAssociatedActorComponent final
{
public:
	class UChallengeLevelActorComponent*          AssociatedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChallengeLevelParentComponent_RemoveAssociatedActorComponent) == 0x000008, "Wrong alignment on ChallengeLevelParentComponent_RemoveAssociatedActorComponent");
static_assert(sizeof(ChallengeLevelParentComponent_RemoveAssociatedActorComponent) == 0x000008, "Wrong size on ChallengeLevelParentComponent_RemoveAssociatedActorComponent");
static_assert(offsetof(ChallengeLevelParentComponent_RemoveAssociatedActorComponent, AssociatedComponent) == 0x000000, "Member 'ChallengeLevelParentComponent_RemoveAssociatedActorComponent::AssociatedComponent' has a wrong offset!");

// Function GbxGameSystemCore.CinematicModeBlueprintLibrary.ClearAndSetCinematicMode
// 0x0010 (0x0010 - 0x0000)
struct CinematicModeBlueprintLibrary_ClearAndSetCinematicMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCinematicModeData*                     InCinematicMode;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CinematicModeBlueprintLibrary_ClearAndSetCinematicMode) == 0x000008, "Wrong alignment on CinematicModeBlueprintLibrary_ClearAndSetCinematicMode");
static_assert(sizeof(CinematicModeBlueprintLibrary_ClearAndSetCinematicMode) == 0x000010, "Wrong size on CinematicModeBlueprintLibrary_ClearAndSetCinematicMode");
static_assert(offsetof(CinematicModeBlueprintLibrary_ClearAndSetCinematicMode, WorldContextObject) == 0x000000, "Member 'CinematicModeBlueprintLibrary_ClearAndSetCinematicMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CinematicModeBlueprintLibrary_ClearAndSetCinematicMode, InCinematicMode) == 0x000008, "Member 'CinematicModeBlueprintLibrary_ClearAndSetCinematicMode::InCinematicMode' has a wrong offset!");

// Function GbxGameSystemCore.CinematicModeBlueprintLibrary.ClearCinematicMode
// 0x0008 (0x0008 - 0x0000)
struct CinematicModeBlueprintLibrary_ClearCinematicMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CinematicModeBlueprintLibrary_ClearCinematicMode) == 0x000008, "Wrong alignment on CinematicModeBlueprintLibrary_ClearCinematicMode");
static_assert(sizeof(CinematicModeBlueprintLibrary_ClearCinematicMode) == 0x000008, "Wrong size on CinematicModeBlueprintLibrary_ClearCinematicMode");
static_assert(offsetof(CinematicModeBlueprintLibrary_ClearCinematicMode, WorldContextObject) == 0x000000, "Member 'CinematicModeBlueprintLibrary_ClearCinematicMode::WorldContextObject' has a wrong offset!");

// Function GbxGameSystemCore.CinematicModeBlueprintLibrary.PopCinematicMode
// 0x0010 (0x0010 - 0x0000)
struct CinematicModeBlueprintLibrary_PopCinematicMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCinematicModeData*                     InCinematicMode;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CinematicModeBlueprintLibrary_PopCinematicMode) == 0x000008, "Wrong alignment on CinematicModeBlueprintLibrary_PopCinematicMode");
static_assert(sizeof(CinematicModeBlueprintLibrary_PopCinematicMode) == 0x000010, "Wrong size on CinematicModeBlueprintLibrary_PopCinematicMode");
static_assert(offsetof(CinematicModeBlueprintLibrary_PopCinematicMode, WorldContextObject) == 0x000000, "Member 'CinematicModeBlueprintLibrary_PopCinematicMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CinematicModeBlueprintLibrary_PopCinematicMode, InCinematicMode) == 0x000008, "Member 'CinematicModeBlueprintLibrary_PopCinematicMode::InCinematicMode' has a wrong offset!");

// Function GbxGameSystemCore.CinematicModeBlueprintLibrary.PushCinematicMode
// 0x0010 (0x0010 - 0x0000)
struct CinematicModeBlueprintLibrary_PushCinematicMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCinematicModeData*                     InCinematicMode;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CinematicModeBlueprintLibrary_PushCinematicMode) == 0x000008, "Wrong alignment on CinematicModeBlueprintLibrary_PushCinematicMode");
static_assert(sizeof(CinematicModeBlueprintLibrary_PushCinematicMode) == 0x000010, "Wrong size on CinematicModeBlueprintLibrary_PushCinematicMode");
static_assert(offsetof(CinematicModeBlueprintLibrary_PushCinematicMode, WorldContextObject) == 0x000000, "Member 'CinematicModeBlueprintLibrary_PushCinematicMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CinematicModeBlueprintLibrary_PushCinematicMode, InCinematicMode) == 0x000008, "Member 'CinematicModeBlueprintLibrary_PushCinematicMode::InCinematicMode' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMoveFunctionLibrary.IsPerformingControlledMove
// 0x0010 (0x0010 - 0x0000)
struct ControlledMoveFunctionLibrary_IsPerformingControlledMove final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ControlledMoveFunctionLibrary_IsPerformingControlledMove) == 0x000008, "Wrong alignment on ControlledMoveFunctionLibrary_IsPerformingControlledMove");
static_assert(sizeof(ControlledMoveFunctionLibrary_IsPerformingControlledMove) == 0x000010, "Wrong size on ControlledMoveFunctionLibrary_IsPerformingControlledMove");
static_assert(offsetof(ControlledMoveFunctionLibrary_IsPerformingControlledMove, Actor) == 0x000000, "Member 'ControlledMoveFunctionLibrary_IsPerformingControlledMove::Actor' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_IsPerformingControlledMove, ReturnValue) == 0x000008, "Member 'ControlledMoveFunctionLibrary_IsPerformingControlledMove::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMoveFunctionLibrary.IsPerformingSpecificControlledMove
// 0x0018 (0x0018 - 0x0000)
struct ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove) == 0x000008, "Wrong alignment on ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove");
static_assert(sizeof(ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove) == 0x000018, "Wrong size on ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove");
static_assert(offsetof(ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove, Actor) == 0x000000, "Member 'ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove::Actor' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove, ControlledMove) == 0x000008, "Member 'ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove::ControlledMove' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove, ReturnValue) == 0x000010, "Member 'ControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMoveFunctionLibrary.StartControlledMove
// 0x0040 (0x0040 - 0x0000)
struct ControlledMoveFunctionLibrary_StartControlledMove final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedOverride;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOverride;                                  // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAngleOverride;                               // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ControlledMoveFunctionLibrary_StartControlledMove) == 0x000008, "Wrong alignment on ControlledMoveFunctionLibrary_StartControlledMove");
static_assert(sizeof(ControlledMoveFunctionLibrary_StartControlledMove) == 0x000040, "Wrong size on ControlledMoveFunctionLibrary_StartControlledMove");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, Actor) == 0x000000, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::Actor' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, ControlledMove) == 0x000008, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::ControlledMove' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, Instigator) == 0x000010, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::Instigator' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, SpeedOverride) == 0x000018, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::SpeedOverride' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, DurationOverride) == 0x00001C, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::DurationOverride' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, LaunchAngleOverride) == 0x000020, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::LaunchAngleOverride' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, TargetActor) == 0x000028, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::TargetActor' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, TargetLocation) == 0x000030, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::TargetLocation' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StartControlledMove, ReturnValue) == 0x00003C, "Member 'ControlledMoveFunctionLibrary_StartControlledMove::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ControlledMoveFunctionLibrary.StopControlledMove
// 0x0018 (0x0018 - 0x0000)
struct ControlledMoveFunctionLibrary_StopControlledMove final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZeroVelocity;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ControlledMoveFunctionLibrary_StopControlledMove) == 0x000008, "Wrong alignment on ControlledMoveFunctionLibrary_StopControlledMove");
static_assert(sizeof(ControlledMoveFunctionLibrary_StopControlledMove) == 0x000018, "Wrong size on ControlledMoveFunctionLibrary_StopControlledMove");
static_assert(offsetof(ControlledMoveFunctionLibrary_StopControlledMove, Actor) == 0x000000, "Member 'ControlledMoveFunctionLibrary_StopControlledMove::Actor' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StopControlledMove, ControlledMove) == 0x000008, "Member 'ControlledMoveFunctionLibrary_StopControlledMove::ControlledMove' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StopControlledMove, bZeroVelocity) == 0x000010, "Member 'ControlledMoveFunctionLibrary_StopControlledMove::bZeroVelocity' has a wrong offset!");
static_assert(offsetof(ControlledMoveFunctionLibrary_StopControlledMove, bInterrupted) == 0x000011, "Member 'ControlledMoveFunctionLibrary_StopControlledMove::bInterrupted' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.ApplyDamage
// 0x0030 (0x0030 - 0x0000)
struct DamageStatics_ApplyDamage final
{
public:
	class AActor*                                 DamageReceiver;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_ApplyDamage) == 0x000008, "Wrong alignment on DamageStatics_ApplyDamage");
static_assert(sizeof(DamageStatics_ApplyDamage) == 0x000030, "Wrong size on DamageStatics_ApplyDamage");
static_assert(offsetof(DamageStatics_ApplyDamage, DamageReceiver) == 0x000000, "Member 'DamageStatics_ApplyDamage::DamageReceiver' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamage, BaseDamage) == 0x000008, "Member 'DamageStatics_ApplyDamage::BaseDamage' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamage, DamageType) == 0x000010, "Member 'DamageStatics_ApplyDamage::DamageType' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamage, DamageSource) == 0x000018, "Member 'DamageStatics_ApplyDamage::DamageSource' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamage, EventInstigator) == 0x000020, "Member 'DamageStatics_ApplyDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamage, DamageCauser) == 0x000028, "Member 'DamageStatics_ApplyDamage::DamageCauser' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.ApplyDamageEx
// 0x01C0 (0x01C0 - 0x0000)
struct DamageStatics_ApplyDamageEx final
{
public:
	struct FPipelineDamageInput                   PipelineInput;                                     // 0x0000(0x01B0)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x01B0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0xC];                                      // 0x01B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageStatics_ApplyDamageEx) == 0x000010, "Wrong alignment on DamageStatics_ApplyDamageEx");
static_assert(sizeof(DamageStatics_ApplyDamageEx) == 0x0001C0, "Wrong size on DamageStatics_ApplyDamageEx");
static_assert(offsetof(DamageStatics_ApplyDamageEx, PipelineInput) == 0x000000, "Member 'DamageStatics_ApplyDamageEx::PipelineInput' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageEx, BaseDamage) == 0x0001B0, "Member 'DamageStatics_ApplyDamageEx::BaseDamage' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.ApplyDamageInRadius
// 0x0090 (0x0090 - 0x0000)
struct DamageStatics_ApplyDamageInRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        BaseImpactForce;                                   // 0x0050(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageFalloff;                                    // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageModifierComponent*               DamageModifierComponent;                           // 0x0078(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          InstigatorFeedback;                                // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInstigatorRadiusDamageScale;                   // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageStatics_ApplyDamageInRadius) == 0x000008, "Wrong alignment on DamageStatics_ApplyDamageInRadius");
static_assert(sizeof(DamageStatics_ApplyDamageInRadius) == 0x000090, "Wrong size on DamageStatics_ApplyDamageInRadius");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, WorldContextObject) == 0x000000, "Member 'DamageStatics_ApplyDamageInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, BaseDamage) == 0x000008, "Member 'DamageStatics_ApplyDamageInRadius::BaseDamage' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, Origin) == 0x00000C, "Member 'DamageStatics_ApplyDamageInRadius::Origin' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, Radius) == 0x000018, "Member 'DamageStatics_ApplyDamageInRadius::Radius' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, DamageType) == 0x000020, "Member 'DamageStatics_ApplyDamageInRadius::DamageType' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, DamageSource) == 0x000028, "Member 'DamageStatics_ApplyDamageInRadius::DamageSource' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, IgnoreActors) == 0x000030, "Member 'DamageStatics_ApplyDamageInRadius::IgnoreActors' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, DamageCauser) == 0x000040, "Member 'DamageStatics_ApplyDamageInRadius::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, EventInstigator) == 0x000048, "Member 'DamageStatics_ApplyDamageInRadius::EventInstigator' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, BaseImpactForce) == 0x000050, "Member 'DamageStatics_ApplyDamageInRadius::BaseImpactForce' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, DamagePreventionChannel) == 0x000070, "Member 'DamageStatics_ApplyDamageInRadius::DamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, bDamageFalloff) == 0x000071, "Member 'DamageStatics_ApplyDamageInRadius::bDamageFalloff' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, DamageModifierComponent) == 0x000078, "Member 'DamageStatics_ApplyDamageInRadius::DamageModifierComponent' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, InstigatorFeedback) == 0x000080, "Member 'DamageStatics_ApplyDamageInRadius::InstigatorFeedback' has a wrong offset!");
static_assert(offsetof(DamageStatics_ApplyDamageInRadius, bUseInstigatorRadiusDamageScale) == 0x000088, "Member 'DamageStatics_ApplyDamageInRadius::bUseInstigatorRadiusDamageScale' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.Conv_FloatToForceSelection
// 0x0028 (0x0028 - 0x0000)
struct DamageStatics_Conv_FloatToForceSelection final
{
public:
	float                                         ForceSelection;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceSelection                        ReturnValue;                                       // 0x0008(0x0020)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_Conv_FloatToForceSelection) == 0x000008, "Wrong alignment on DamageStatics_Conv_FloatToForceSelection");
static_assert(sizeof(DamageStatics_Conv_FloatToForceSelection) == 0x000028, "Wrong size on DamageStatics_Conv_FloatToForceSelection");
static_assert(offsetof(DamageStatics_Conv_FloatToForceSelection, ForceSelection) == 0x000000, "Member 'DamageStatics_Conv_FloatToForceSelection::ForceSelection' has a wrong offset!");
static_assert(offsetof(DamageStatics_Conv_FloatToForceSelection, ReturnValue) == 0x000008, "Member 'DamageStatics_Conv_FloatToForceSelection::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.Conv_ForceSelectionToFloat
// 0x0028 (0x0028 - 0x0000)
struct DamageStatics_Conv_ForceSelectionToFloat final
{
public:
	struct FForceSelection                        ForceSelection;                                    // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DamageStatics_Conv_ForceSelectionToFloat) == 0x000008, "Wrong alignment on DamageStatics_Conv_ForceSelectionToFloat");
static_assert(sizeof(DamageStatics_Conv_ForceSelectionToFloat) == 0x000028, "Wrong size on DamageStatics_Conv_ForceSelectionToFloat");
static_assert(offsetof(DamageStatics_Conv_ForceSelectionToFloat, ForceSelection) == 0x000000, "Member 'DamageStatics_Conv_ForceSelectionToFloat::ForceSelection' has a wrong offset!");
static_assert(offsetof(DamageStatics_Conv_ForceSelectionToFloat, ReturnValue) == 0x000020, "Member 'DamageStatics_Conv_ForceSelectionToFloat::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.GetDamageSourceFromClass
// 0x0010 (0x0010 - 0x0000)
struct DamageStatics_GetDamageSourceFromClass final
{
public:
	TSubclassOf<class UDamageSource>              DamageSourceClass;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageSource*                    ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_GetDamageSourceFromClass) == 0x000008, "Wrong alignment on DamageStatics_GetDamageSourceFromClass");
static_assert(sizeof(DamageStatics_GetDamageSourceFromClass) == 0x000010, "Wrong size on DamageStatics_GetDamageSourceFromClass");
static_assert(offsetof(DamageStatics_GetDamageSourceFromClass, DamageSourceClass) == 0x000000, "Member 'DamageStatics_GetDamageSourceFromClass::DamageSourceClass' has a wrong offset!");
static_assert(offsetof(DamageStatics_GetDamageSourceFromClass, ReturnValue) == 0x000008, "Member 'DamageStatics_GetDamageSourceFromClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.GetDamageTypeFromClass
// 0x0010 (0x0010 - 0x0000)
struct DamageStatics_GetDamageTypeFromClass final
{
public:
	TSubclassOf<class UGbxDamageType>             DamageTypeClass;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxDamageType*                   ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_GetDamageTypeFromClass) == 0x000008, "Wrong alignment on DamageStatics_GetDamageTypeFromClass");
static_assert(sizeof(DamageStatics_GetDamageTypeFromClass) == 0x000010, "Wrong size on DamageStatics_GetDamageTypeFromClass");
static_assert(offsetof(DamageStatics_GetDamageTypeFromClass, DamageTypeClass) == 0x000000, "Member 'DamageStatics_GetDamageTypeFromClass::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(DamageStatics_GetDamageTypeFromClass, ReturnValue) == 0x000008, "Member 'DamageStatics_GetDamageTypeFromClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.GetSummary_ForceSelection
// 0x0030 (0x0030 - 0x0000)
struct DamageStatics_GetSummary_ForceSelection final
{
public:
	struct FForceSelection                        ForceSelection;                                    // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_GetSummary_ForceSelection) == 0x000008, "Wrong alignment on DamageStatics_GetSummary_ForceSelection");
static_assert(sizeof(DamageStatics_GetSummary_ForceSelection) == 0x000030, "Wrong size on DamageStatics_GetSummary_ForceSelection");
static_assert(offsetof(DamageStatics_GetSummary_ForceSelection, ForceSelection) == 0x000000, "Member 'DamageStatics_GetSummary_ForceSelection::ForceSelection' has a wrong offset!");
static_assert(offsetof(DamageStatics_GetSummary_ForceSelection, ReturnValue) == 0x000020, "Member 'DamageStatics_GetSummary_ForceSelection::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.MakePipelineDamageInput
// 0x02B0 (0x02B0 - 0x0000)
struct DamageStatics_MakePipelineDamageInput final
{
public:
	class AActor*                                 DamageCauser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageReceiver;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x00B0(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x00BC(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitForceDirection;                                 // 0x00C8(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceSelection                        HitForceMagnitude;                                 // 0x00D8(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPipelineDamageInput                   ReturnValue;                                       // 0x0100(0x01B0)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_MakePipelineDamageInput) == 0x000010, "Wrong alignment on DamageStatics_MakePipelineDamageInput");
static_assert(sizeof(DamageStatics_MakePipelineDamageInput) == 0x0002B0, "Wrong size on DamageStatics_MakePipelineDamageInput");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, DamageCauser) == 0x000000, "Member 'DamageStatics_MakePipelineDamageInput::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, DamageReceiver) == 0x000008, "Member 'DamageStatics_MakePipelineDamageInput::DamageReceiver' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, DamageType) == 0x000010, "Member 'DamageStatics_MakePipelineDamageInput::DamageType' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, DamageSource) == 0x000018, "Member 'DamageStatics_MakePipelineDamageInput::DamageSource' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, HitInfo) == 0x000020, "Member 'DamageStatics_MakePipelineDamageInput::HitInfo' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, HitLocation) == 0x0000B0, "Member 'DamageStatics_MakePipelineDamageInput::HitLocation' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, HitDirection) == 0x0000BC, "Member 'DamageStatics_MakePipelineDamageInput::HitDirection' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, HitForceDirection) == 0x0000C8, "Member 'DamageStatics_MakePipelineDamageInput::HitForceDirection' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, HitForceMagnitude) == 0x0000D8, "Member 'DamageStatics_MakePipelineDamageInput::HitForceMagnitude' has a wrong offset!");
static_assert(offsetof(DamageStatics_MakePipelineDamageInput, ReturnValue) == 0x000100, "Member 'DamageStatics_MakePipelineDamageInput::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.StopCausingAllDamage
// 0x0008 (0x0008 - 0x0000)
struct DamageStatics_StopCausingAllDamage final
{
public:
	class AActor*                                 DamageCauser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_StopCausingAllDamage) == 0x000008, "Wrong alignment on DamageStatics_StopCausingAllDamage");
static_assert(sizeof(DamageStatics_StopCausingAllDamage) == 0x000008, "Wrong size on DamageStatics_StopCausingAllDamage");
static_assert(offsetof(DamageStatics_StopCausingAllDamage, DamageCauser) == 0x000000, "Member 'DamageStatics_StopCausingAllDamage::DamageCauser' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.StopCausingDamage
// 0x0010 (0x0010 - 0x0000)
struct DamageStatics_StopCausingDamage final
{
public:
	class AActor*                                 DamageCauser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_StopCausingDamage) == 0x000008, "Wrong alignment on DamageStatics_StopCausingDamage");
static_assert(sizeof(DamageStatics_StopCausingDamage) == 0x000010, "Wrong size on DamageStatics_StopCausingDamage");
static_assert(offsetof(DamageStatics_StopCausingDamage, DamageCauser) == 0x000000, "Member 'DamageStatics_StopCausingDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageStatics_StopCausingDamage, DamageData) == 0x000008, "Member 'DamageStatics_StopCausingDamage::DamageData' has a wrong offset!");

// Function GbxGameSystemCore.DamageStatics.StopCausingDamageToTarget
// 0x0018 (0x0018 - 0x0000)
struct DamageStatics_StopCausingDamageToTarget final
{
public:
	class AActor*                                 DamageCauser;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DamageStatics_StopCausingDamageToTarget) == 0x000008, "Wrong alignment on DamageStatics_StopCausingDamageToTarget");
static_assert(sizeof(DamageStatics_StopCausingDamageToTarget) == 0x000018, "Wrong size on DamageStatics_StopCausingDamageToTarget");
static_assert(offsetof(DamageStatics_StopCausingDamageToTarget, DamageCauser) == 0x000000, "Member 'DamageStatics_StopCausingDamageToTarget::DamageCauser' has a wrong offset!");
static_assert(offsetof(DamageStatics_StopCausingDamageToTarget, DamageTarget) == 0x000008, "Member 'DamageStatics_StopCausingDamageToTarget::DamageTarget' has a wrong offset!");
static_assert(offsetof(DamageStatics_StopCausingDamageToTarget, DamageData) == 0x000010, "Member 'DamageStatics_StopCausingDamageToTarget::DamageData' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.AttachBodyTo
// 0x0020 (0x0020 - 0x0000)
struct DynamicPhysicalAnimationComponent_AttachBodyTo final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachToBodyName;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocitySpaceBlend;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakForce;                                        // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_AttachBodyTo) == 0x000008, "Wrong alignment on DynamicPhysicalAnimationComponent_AttachBodyTo");
static_assert(sizeof(DynamicPhysicalAnimationComponent_AttachBodyTo) == 0x000020, "Wrong size on DynamicPhysicalAnimationComponent_AttachBodyTo");
static_assert(offsetof(DynamicPhysicalAnimationComponent_AttachBodyTo, BodyName) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_AttachBodyTo::BodyName' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_AttachBodyTo, AttachToComponent) == 0x000008, "Member 'DynamicPhysicalAnimationComponent_AttachBodyTo::AttachToComponent' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_AttachBodyTo, AttachToBodyName) == 0x000010, "Member 'DynamicPhysicalAnimationComponent_AttachBodyTo::AttachToBodyName' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_AttachBodyTo, VelocitySpaceBlend) == 0x000018, "Member 'DynamicPhysicalAnimationComponent_AttachBodyTo::VelocitySpaceBlend' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_AttachBodyTo, BreakForce) == 0x00001C, "Member 'DynamicPhysicalAnimationComponent_AttachBodyTo::BreakForce' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.DetachBodyFromAllExternalRigidBodies
// 0x0008 (0x0008 - 0x0000)
struct DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies) == 0x000004, "Wrong alignment on DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies");
static_assert(sizeof(DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies) == 0x000008, "Wrong size on DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies");
static_assert(offsetof(DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies, BodyName) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies::BodyName' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.GetStrengthMultiplier
// 0x0004 (0x0004 - 0x0000)
struct DynamicPhysicalAnimationComponent_GetStrengthMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_GetStrengthMultiplier) == 0x000004, "Wrong alignment on DynamicPhysicalAnimationComponent_GetStrengthMultiplier");
static_assert(sizeof(DynamicPhysicalAnimationComponent_GetStrengthMultiplier) == 0x000004, "Wrong size on DynamicPhysicalAnimationComponent_GetStrengthMultiplier");
static_assert(offsetof(DynamicPhysicalAnimationComponent_GetStrengthMultiplier, ReturnValue) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_GetStrengthMultiplier::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.OnRigidBodyOverlap
// 0x00B8 (0x00B8 - 0x0000)
struct DynamicPhysicalAnimationComponent_OnRigidBodyOverlap final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0028(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap) == 0x000008, "Wrong alignment on DynamicPhysicalAnimationComponent_OnRigidBodyOverlap");
static_assert(sizeof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap) == 0x0000B8, "Wrong size on DynamicPhysicalAnimationComponent_OnRigidBodyOverlap");
static_assert(offsetof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap, HitComponent) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_OnRigidBodyOverlap::HitComponent' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap, OtherActor) == 0x000008, "Member 'DynamicPhysicalAnimationComponent_OnRigidBodyOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap, OtherComp) == 0x000010, "Member 'DynamicPhysicalAnimationComponent_OnRigidBodyOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap, NormalImpulse) == 0x000018, "Member 'DynamicPhysicalAnimationComponent_OnRigidBodyOverlap::NormalImpulse' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_OnRigidBodyOverlap, Hit) == 0x000028, "Member 'DynamicPhysicalAnimationComponent_OnRigidBodyOverlap::Hit' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetActiveProfile
// 0x0008 (0x0008 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetActiveProfile final
{
public:
	const class UPhysicalAnimationProfileAsset*   Profile;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetActiveProfile) == 0x000008, "Wrong alignment on DynamicPhysicalAnimationComponent_SetActiveProfile");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetActiveProfile) == 0x000008, "Wrong size on DynamicPhysicalAnimationComponent_SetActiveProfile");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetActiveProfile, Profile) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetActiveProfile::Profile' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetEnablePhysicalAnimation
// 0x0010 (0x0010 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BodyName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation) == 0x000004, "Wrong alignment on DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation) == 0x000010, "Wrong size on DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation, bEnable) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation::bEnable' has a wrong offset!");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation, BodyName) == 0x000008, "Member 'DynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation::BodyName' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetEnableRagdoll
// 0x0001 (0x0001 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetEnableRagdoll final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetEnableRagdoll) == 0x000001, "Wrong alignment on DynamicPhysicalAnimationComponent_SetEnableRagdoll");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetEnableRagdoll) == 0x000001, "Wrong size on DynamicPhysicalAnimationComponent_SetEnableRagdoll");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetEnableRagdoll, bEnable) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetEnableRagdoll::bEnable' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetHasAnimationPlaying
// 0x0001 (0x0001 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetHasAnimationPlaying final
{
public:
	bool                                          bPlaying;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetHasAnimationPlaying) == 0x000001, "Wrong alignment on DynamicPhysicalAnimationComponent_SetHasAnimationPlaying");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetHasAnimationPlaying) == 0x000001, "Wrong size on DynamicPhysicalAnimationComponent_SetHasAnimationPlaying");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetHasAnimationPlaying, bPlaying) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetHasAnimationPlaying::bPlaying' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetRootMotionControl
// 0x0001 (0x0001 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetRootMotionControl final
{
public:
	EPhysicalAnimationRootMotionControl           MotionControl;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetRootMotionControl) == 0x000001, "Wrong alignment on DynamicPhysicalAnimationComponent_SetRootMotionControl");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetRootMotionControl) == 0x000001, "Wrong size on DynamicPhysicalAnimationComponent_SetRootMotionControl");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetRootMotionControl, MotionControl) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetRootMotionControl::MotionControl' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetSkeletalMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 NewSkeletalMeshComponent;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent) == 0x000008, "Wrong alignment on DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent) == 0x000008, "Wrong size on DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent, NewSkeletalMeshComponent) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetSkeletalMeshComponent::NewSkeletalMeshComponent' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetStrengthMultiplier
// 0x0004 (0x0004 - 0x0000)
struct DynamicPhysicalAnimationComponent_SetStrengthMultiplier final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_SetStrengthMultiplier) == 0x000004, "Wrong alignment on DynamicPhysicalAnimationComponent_SetStrengthMultiplier");
static_assert(sizeof(DynamicPhysicalAnimationComponent_SetStrengthMultiplier) == 0x000004, "Wrong size on DynamicPhysicalAnimationComponent_SetStrengthMultiplier");
static_assert(offsetof(DynamicPhysicalAnimationComponent_SetStrengthMultiplier, NewValue) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_SetStrengthMultiplier::NewValue' has a wrong offset!");

// Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.GetRootMotionControl
// 0x0001 (0x0001 - 0x0000)
struct DynamicPhysicalAnimationComponent_GetRootMotionControl final
{
public:
	EPhysicalAnimationRootMotionControl           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DynamicPhysicalAnimationComponent_GetRootMotionControl) == 0x000001, "Wrong alignment on DynamicPhysicalAnimationComponent_GetRootMotionControl");
static_assert(sizeof(DynamicPhysicalAnimationComponent_GetRootMotionControl) == 0x000001, "Wrong size on DynamicPhysicalAnimationComponent_GetRootMotionControl");
static_assert(offsetof(DynamicPhysicalAnimationComponent_GetRootMotionControl, ReturnValue) == 0x000000, "Member 'DynamicPhysicalAnimationComponent_GetRootMotionControl::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UseSystemFunctionLibrary.ResetUseCount
// 0x0008 (0x0008 - 0x0000)
struct UseSystemFunctionLibrary_ResetUseCount final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UseSystemFunctionLibrary_ResetUseCount) == 0x000008, "Wrong alignment on UseSystemFunctionLibrary_ResetUseCount");
static_assert(sizeof(UseSystemFunctionLibrary_ResetUseCount) == 0x000008, "Wrong size on UseSystemFunctionLibrary_ResetUseCount");
static_assert(offsetof(UseSystemFunctionLibrary_ResetUseCount, Actor) == 0x000000, "Member 'UseSystemFunctionLibrary_ResetUseCount::Actor' has a wrong offset!");

// Function GbxGameSystemCore.UseSystemFunctionLibrary.SetIsUsable
// 0x0010 (0x0010 - 0x0000)
struct UseSystemFunctionLibrary_SetIsUsable final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewIsUsable;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UseSystemFunctionLibrary_SetIsUsable) == 0x000008, "Wrong alignment on UseSystemFunctionLibrary_SetIsUsable");
static_assert(sizeof(UseSystemFunctionLibrary_SetIsUsable) == 0x000010, "Wrong size on UseSystemFunctionLibrary_SetIsUsable");
static_assert(offsetof(UseSystemFunctionLibrary_SetIsUsable, Actor) == 0x000000, "Member 'UseSystemFunctionLibrary_SetIsUsable::Actor' has a wrong offset!");
static_assert(offsetof(UseSystemFunctionLibrary_SetIsUsable, bNewIsUsable) == 0x000008, "Member 'UseSystemFunctionLibrary_SetIsUsable::bNewIsUsable' has a wrong offset!");

// Function GbxGameSystemCore.ExplosionBlueprintLibrary.PlayExplosion
// 0x0030 (0x0030 - 0x0000)
struct ExplosionBlueprintLibrary_PlayExplosion final
{
public:
	class UExplosionData*                         ExplosionData;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExplosionLocation;                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ReturnValue;                                       // 0x0028(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosionBlueprintLibrary_PlayExplosion) == 0x000008, "Wrong alignment on ExplosionBlueprintLibrary_PlayExplosion");
static_assert(sizeof(ExplosionBlueprintLibrary_PlayExplosion) == 0x000030, "Wrong size on ExplosionBlueprintLibrary_PlayExplosion");
static_assert(offsetof(ExplosionBlueprintLibrary_PlayExplosion, ExplosionData) == 0x000000, "Member 'ExplosionBlueprintLibrary_PlayExplosion::ExplosionData' has a wrong offset!");
static_assert(offsetof(ExplosionBlueprintLibrary_PlayExplosion, Size) == 0x000008, "Member 'ExplosionBlueprintLibrary_PlayExplosion::Size' has a wrong offset!");
static_assert(offsetof(ExplosionBlueprintLibrary_PlayExplosion, ExplosionLocation) == 0x00000C, "Member 'ExplosionBlueprintLibrary_PlayExplosion::ExplosionLocation' has a wrong offset!");
static_assert(offsetof(ExplosionBlueprintLibrary_PlayExplosion, Context) == 0x000018, "Member 'ExplosionBlueprintLibrary_PlayExplosion::Context' has a wrong offset!");
static_assert(offsetof(ExplosionBlueprintLibrary_PlayExplosion, DamageType) == 0x000020, "Member 'ExplosionBlueprintLibrary_PlayExplosion::DamageType' has a wrong offset!");
static_assert(offsetof(ExplosionBlueprintLibrary_PlayExplosion, ReturnValue) == 0x000028, "Member 'ExplosionBlueprintLibrary_PlayExplosion::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ExplosionComponent.Explode
// 0x0058 (0x0058 - 0x0000)
struct ExplosionComponent_Explode final
{
public:
	struct FDamageInfo                            DamageInfo;                                        // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosionComponent_Explode) == 0x000008, "Wrong alignment on ExplosionComponent_Explode");
static_assert(sizeof(ExplosionComponent_Explode) == 0x000058, "Wrong size on ExplosionComponent_Explode");
static_assert(offsetof(ExplosionComponent_Explode, DamageInfo) == 0x000000, "Member 'ExplosionComponent_Explode::DamageInfo' has a wrong offset!");

// Function GbxGameSystemCore.ExplosionComponent.SetExplosionLocation
// 0x000C (0x000C - 0x0000)
struct ExplosionComponent_SetExplosionLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosionComponent_SetExplosionLocation) == 0x000004, "Wrong alignment on ExplosionComponent_SetExplosionLocation");
static_assert(sizeof(ExplosionComponent_SetExplosionLocation) == 0x00000C, "Wrong size on ExplosionComponent_SetExplosionLocation");
static_assert(offsetof(ExplosionComponent_SetExplosionLocation, NewLocation) == 0x000000, "Member 'ExplosionComponent_SetExplosionLocation::NewLocation' has a wrong offset!");

// Function GbxGameSystemCore.ExplosionData.SelectExplosion
// 0x0060 (0x0060 - 0x0000)
struct ExplosionData_SelectExplosion final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExplosionSizeProperties               ReturnValue;                                       // 0x0010(0x0050)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosionData_SelectExplosion) == 0x000008, "Wrong alignment on ExplosionData_SelectExplosion");
static_assert(sizeof(ExplosionData_SelectExplosion) == 0x000060, "Wrong size on ExplosionData_SelectExplosion");
static_assert(offsetof(ExplosionData_SelectExplosion, Size) == 0x000000, "Member 'ExplosionData_SelectExplosion::Size' has a wrong offset!");
static_assert(offsetof(ExplosionData_SelectExplosion, DamageType) == 0x000008, "Member 'ExplosionData_SelectExplosion::DamageType' has a wrong offset!");
static_assert(offsetof(ExplosionData_SelectExplosion, ReturnValue) == 0x000010, "Member 'ExplosionData_SelectExplosion::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ExplosionSizeSelectionData.GetExplosionPropertiesBySize
// 0x0058 (0x0058 - 0x0000)
struct ExplosionSizeSelectionData_GetExplosionPropertiesBySize final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExplosionSizeProperties               ReturnValue;                                       // 0x0008(0x0050)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExplosionSizeSelectionData_GetExplosionPropertiesBySize) == 0x000008, "Wrong alignment on ExplosionSizeSelectionData_GetExplosionPropertiesBySize");
static_assert(sizeof(ExplosionSizeSelectionData_GetExplosionPropertiesBySize) == 0x000058, "Wrong size on ExplosionSizeSelectionData_GetExplosionPropertiesBySize");
static_assert(offsetof(ExplosionSizeSelectionData_GetExplosionPropertiesBySize, Size) == 0x000000, "Member 'ExplosionSizeSelectionData_GetExplosionPropertiesBySize::Size' has a wrong offset!");
static_assert(offsetof(ExplosionSizeSelectionData_GetExplosionPropertiesBySize, ReturnValue) == 0x000008, "Member 'ExplosionSizeSelectionData_GetExplosionPropertiesBySize::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.GetFeedbackDataRange
// 0x0010 (0x0010 - 0x0000)
struct FeedbackData_GetFeedbackDataRange final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_GetFeedbackDataRange) == 0x000008, "Wrong alignment on FeedbackData_GetFeedbackDataRange");
static_assert(sizeof(FeedbackData_GetFeedbackDataRange) == 0x000010, "Wrong size on FeedbackData_GetFeedbackDataRange");
static_assert(offsetof(FeedbackData_GetFeedbackDataRange, FeedbackData) == 0x000000, "Member 'FeedbackData_GetFeedbackDataRange::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_GetFeedbackDataRange, MinRange) == 0x000008, "Member 'FeedbackData_GetFeedbackDataRange::MinRange' has a wrong offset!");
static_assert(offsetof(FeedbackData_GetFeedbackDataRange, MaxRange) == 0x00000C, "Member 'FeedbackData_GetFeedbackDataRange::MaxRange' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.GetFeedbackDuration
// 0x0010 (0x0010 - 0x0000)
struct FeedbackData_GetFeedbackDuration final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FeedbackData_GetFeedbackDuration) == 0x000008, "Wrong alignment on FeedbackData_GetFeedbackDuration");
static_assert(sizeof(FeedbackData_GetFeedbackDuration) == 0x000010, "Wrong size on FeedbackData_GetFeedbackDuration");
static_assert(offsetof(FeedbackData_GetFeedbackDuration, FeedbackData) == 0x000000, "Member 'FeedbackData_GetFeedbackDuration::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_GetFeedbackDuration, ReturnValue) == 0x000008, "Member 'FeedbackData_GetFeedbackDuration::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedback
// 0x0028 (0x0028 - 0x0000)
struct FeedbackData_PerformDefaultFeedback final
{
public:
	struct FFeedbackTableRowHandle                Feedback;                                          // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformDefaultFeedback) == 0x000008, "Wrong alignment on FeedbackData_PerformDefaultFeedback");
static_assert(sizeof(FeedbackData_PerformDefaultFeedback) == 0x000028, "Wrong size on FeedbackData_PerformDefaultFeedback");
static_assert(offsetof(FeedbackData_PerformDefaultFeedback, Feedback) == 0x000000, "Member 'FeedbackData_PerformDefaultFeedback::Feedback' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedback, Controller) == 0x000010, "Member 'FeedbackData_PerformDefaultFeedback::Controller' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedback, Scale) == 0x000018, "Member 'FeedbackData_PerformDefaultFeedback::Scale' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedback, bLoop) == 0x00001C, "Member 'FeedbackData_PerformDefaultFeedback::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedback, SourceContext) == 0x000020, "Member 'FeedbackData_PerformDefaultFeedback::SourceContext' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackAtLocation
// 0x0050 (0x0050 - 0x0000)
struct FeedbackData_PerformDefaultFeedbackAtLocation final
{
public:
	struct FFeedbackTableRowHandle                Feedback;                                          // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedDistanceOverrides               RangedDistanceOverrides;                           // 0x0024(0x000C)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ControllerToIgnore;                                // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverrideControllerFeedback;                        // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformDefaultFeedbackAtLocation) == 0x000008, "Wrong alignment on FeedbackData_PerformDefaultFeedbackAtLocation");
static_assert(sizeof(FeedbackData_PerformDefaultFeedbackAtLocation) == 0x000050, "Wrong size on FeedbackData_PerformDefaultFeedbackAtLocation");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, Feedback) == 0x000000, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::Feedback' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, Controller) == 0x000010, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::Controller' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, SourceLocation) == 0x000018, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::SourceLocation' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, RangedDistanceOverrides) == 0x000024, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::RangedDistanceOverrides' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, bLoop) == 0x000030, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, SourceContext) == 0x000038, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::SourceContext' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, ControllerToIgnore) == 0x000040, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::ControllerToIgnore' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackAtLocation, OverrideControllerFeedback) == 0x000048, "Member 'FeedbackData_PerformDefaultFeedbackAtLocation::OverrideControllerFeedback' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackForAll
// 0x0038 (0x0038 - 0x0000)
struct FeedbackData_PerformDefaultFeedbackForAll final
{
public:
	struct FFeedbackTableRowHandle                Feedback;                                          // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ControllerToIgnore;                                // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverrideControllerFeedback;                        // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformDefaultFeedbackForAll) == 0x000008, "Wrong alignment on FeedbackData_PerformDefaultFeedbackForAll");
static_assert(sizeof(FeedbackData_PerformDefaultFeedbackForAll) == 0x000038, "Wrong size on FeedbackData_PerformDefaultFeedbackForAll");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, Feedback) == 0x000000, "Member 'FeedbackData_PerformDefaultFeedbackForAll::Feedback' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, Scale) == 0x000010, "Member 'FeedbackData_PerformDefaultFeedbackForAll::Scale' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, bLoop) == 0x000014, "Member 'FeedbackData_PerformDefaultFeedbackForAll::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, WorldContextObject) == 0x000018, "Member 'FeedbackData_PerformDefaultFeedbackForAll::WorldContextObject' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, SourceContext) == 0x000020, "Member 'FeedbackData_PerformDefaultFeedbackForAll::SourceContext' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, ControllerToIgnore) == 0x000028, "Member 'FeedbackData_PerformDefaultFeedbackForAll::ControllerToIgnore' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAll, OverrideControllerFeedback) == 0x000030, "Member 'FeedbackData_PerformDefaultFeedbackForAll::OverrideControllerFeedback' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackForAllAtLocation
// 0x0050 (0x0050 - 0x0000)
struct FeedbackData_PerformDefaultFeedbackForAllAtLocation final
{
public:
	struct FFeedbackTableRowHandle                Feedback;                                          // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedDistanceOverrides               RangedDistanceOverrides;                           // 0x001C(0x000C)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ControllerToIgnore;                                // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverrideControllerFeedback;                        // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformDefaultFeedbackForAllAtLocation) == 0x000008, "Wrong alignment on FeedbackData_PerformDefaultFeedbackForAllAtLocation");
static_assert(sizeof(FeedbackData_PerformDefaultFeedbackForAllAtLocation) == 0x000050, "Wrong size on FeedbackData_PerformDefaultFeedbackForAllAtLocation");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, Feedback) == 0x000000, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::Feedback' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, SourceLocation) == 0x000010, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::SourceLocation' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, RangedDistanceOverrides) == 0x00001C, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::RangedDistanceOverrides' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, bLoop) == 0x000028, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, WorldContextObject) == 0x000030, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, SourceContext) == 0x000038, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::SourceContext' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, ControllerToIgnore) == 0x000040, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::ControllerToIgnore' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformDefaultFeedbackForAllAtLocation, OverrideControllerFeedback) == 0x000048, "Member 'FeedbackData_PerformDefaultFeedbackForAllAtLocation::OverrideControllerFeedback' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformFeedback
// 0x0020 (0x0020 - 0x0000)
struct FeedbackData_PerformFeedback final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformFeedback) == 0x000008, "Wrong alignment on FeedbackData_PerformFeedback");
static_assert(sizeof(FeedbackData_PerformFeedback) == 0x000020, "Wrong size on FeedbackData_PerformFeedback");
static_assert(offsetof(FeedbackData_PerformFeedback, FeedbackData) == 0x000000, "Member 'FeedbackData_PerformFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedback, Controller) == 0x000008, "Member 'FeedbackData_PerformFeedback::Controller' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedback, Scale) == 0x000010, "Member 'FeedbackData_PerformFeedback::Scale' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedback, bLoop) == 0x000014, "Member 'FeedbackData_PerformFeedback::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedback, SourceContext) == 0x000018, "Member 'FeedbackData_PerformFeedback::SourceContext' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformFeedbackAtLocation
// 0x0048 (0x0048 - 0x0000)
struct FeedbackData_PerformFeedbackAtLocation final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedDistanceOverrides               RangedDistanceOverrides;                           // 0x001C(0x000C)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceContext;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ControllerToIgnore;                                // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverrideControllerFeedback;                        // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformFeedbackAtLocation) == 0x000008, "Wrong alignment on FeedbackData_PerformFeedbackAtLocation");
static_assert(sizeof(FeedbackData_PerformFeedbackAtLocation) == 0x000048, "Wrong size on FeedbackData_PerformFeedbackAtLocation");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, FeedbackData) == 0x000000, "Member 'FeedbackData_PerformFeedbackAtLocation::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, Controller) == 0x000008, "Member 'FeedbackData_PerformFeedbackAtLocation::Controller' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, SourceLocation) == 0x000010, "Member 'FeedbackData_PerformFeedbackAtLocation::SourceLocation' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, RangedDistanceOverrides) == 0x00001C, "Member 'FeedbackData_PerformFeedbackAtLocation::RangedDistanceOverrides' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, bLoop) == 0x000028, "Member 'FeedbackData_PerformFeedbackAtLocation::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, SourceContext) == 0x000030, "Member 'FeedbackData_PerformFeedbackAtLocation::SourceContext' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, ControllerToIgnore) == 0x000038, "Member 'FeedbackData_PerformFeedbackAtLocation::ControllerToIgnore' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackAtLocation, OverrideControllerFeedback) == 0x000040, "Member 'FeedbackData_PerformFeedbackAtLocation::OverrideControllerFeedback' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformFeedbackForAll
// 0x0030 (0x0030 - 0x0000)
struct FeedbackData_PerformFeedbackForAll final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ControllerToIgnore;                                // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverrideControllerFeedback;                        // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformFeedbackForAll) == 0x000008, "Wrong alignment on FeedbackData_PerformFeedbackForAll");
static_assert(sizeof(FeedbackData_PerformFeedbackForAll) == 0x000030, "Wrong size on FeedbackData_PerformFeedbackForAll");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, FeedbackData) == 0x000000, "Member 'FeedbackData_PerformFeedbackForAll::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, Scale) == 0x000008, "Member 'FeedbackData_PerformFeedbackForAll::Scale' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, bLoop) == 0x00000C, "Member 'FeedbackData_PerformFeedbackForAll::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, WorldContextObject) == 0x000010, "Member 'FeedbackData_PerformFeedbackForAll::WorldContextObject' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, SourceContext) == 0x000018, "Member 'FeedbackData_PerformFeedbackForAll::SourceContext' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, ControllerToIgnore) == 0x000020, "Member 'FeedbackData_PerformFeedbackForAll::ControllerToIgnore' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAll, OverrideControllerFeedback) == 0x000028, "Member 'FeedbackData_PerformFeedbackForAll::OverrideControllerFeedback' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.PerformFeedbackForAllAtLocation
// 0x0048 (0x0048 - 0x0000)
struct FeedbackData_PerformFeedbackForAllAtLocation final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedDistanceOverrides               RangedDistanceOverrides;                           // 0x0014(0x000C)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceContext;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ControllerToIgnore;                                // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverrideControllerFeedback;                        // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_PerformFeedbackForAllAtLocation) == 0x000008, "Wrong alignment on FeedbackData_PerformFeedbackForAllAtLocation");
static_assert(sizeof(FeedbackData_PerformFeedbackForAllAtLocation) == 0x000048, "Wrong size on FeedbackData_PerformFeedbackForAllAtLocation");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, FeedbackData) == 0x000000, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, SourceLocation) == 0x000008, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::SourceLocation' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, RangedDistanceOverrides) == 0x000014, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::RangedDistanceOverrides' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, bLoop) == 0x000020, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::bLoop' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, WorldContextObject) == 0x000028, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, SourceContext) == 0x000030, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::SourceContext' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, ControllerToIgnore) == 0x000038, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::ControllerToIgnore' has a wrong offset!");
static_assert(offsetof(FeedbackData_PerformFeedbackForAllAtLocation, OverrideControllerFeedback) == 0x000040, "Member 'FeedbackData_PerformFeedbackForAllAtLocation::OverrideControllerFeedback' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.StopDefaultFeedback
// 0x0018 (0x0018 - 0x0000)
struct FeedbackData_StopDefaultFeedback final
{
public:
	struct FFeedbackTableRowHandle                Feedback;                                          // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_StopDefaultFeedback) == 0x000008, "Wrong alignment on FeedbackData_StopDefaultFeedback");
static_assert(sizeof(FeedbackData_StopDefaultFeedback) == 0x000018, "Wrong size on FeedbackData_StopDefaultFeedback");
static_assert(offsetof(FeedbackData_StopDefaultFeedback, Feedback) == 0x000000, "Member 'FeedbackData_StopDefaultFeedback::Feedback' has a wrong offset!");
static_assert(offsetof(FeedbackData_StopDefaultFeedback, Controller) == 0x000010, "Member 'FeedbackData_StopDefaultFeedback::Controller' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.StopDefaultFeedbackForAll
// 0x0018 (0x0018 - 0x0000)
struct FeedbackData_StopDefaultFeedbackForAll final
{
public:
	struct FFeedbackTableRowHandle                Feedback;                                          // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_StopDefaultFeedbackForAll) == 0x000008, "Wrong alignment on FeedbackData_StopDefaultFeedbackForAll");
static_assert(sizeof(FeedbackData_StopDefaultFeedbackForAll) == 0x000018, "Wrong size on FeedbackData_StopDefaultFeedbackForAll");
static_assert(offsetof(FeedbackData_StopDefaultFeedbackForAll, Feedback) == 0x000000, "Member 'FeedbackData_StopDefaultFeedbackForAll::Feedback' has a wrong offset!");
static_assert(offsetof(FeedbackData_StopDefaultFeedbackForAll, WorldContextObject) == 0x000010, "Member 'FeedbackData_StopDefaultFeedbackForAll::WorldContextObject' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.StopFeedback
// 0x0010 (0x0010 - 0x0000)
struct FeedbackData_StopFeedback final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_StopFeedback) == 0x000008, "Wrong alignment on FeedbackData_StopFeedback");
static_assert(sizeof(FeedbackData_StopFeedback) == 0x000010, "Wrong size on FeedbackData_StopFeedback");
static_assert(offsetof(FeedbackData_StopFeedback, FeedbackData) == 0x000000, "Member 'FeedbackData_StopFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_StopFeedback, Controller) == 0x000008, "Member 'FeedbackData_StopFeedback::Controller' has a wrong offset!");

// Function GbxGameSystemCore.FeedbackData.StopFeedbackForAll
// 0x0010 (0x0010 - 0x0000)
struct FeedbackData_StopFeedbackForAll final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FeedbackData_StopFeedbackForAll) == 0x000008, "Wrong alignment on FeedbackData_StopFeedbackForAll");
static_assert(sizeof(FeedbackData_StopFeedbackForAll) == 0x000010, "Wrong size on FeedbackData_StopFeedbackForAll");
static_assert(offsetof(FeedbackData_StopFeedbackForAll, FeedbackData) == 0x000000, "Member 'FeedbackData_StopFeedbackForAll::FeedbackData' has a wrong offset!");
static_assert(offsetof(FeedbackData_StopFeedbackForAll, WorldContextObject) == 0x000008, "Member 'FeedbackData_StopFeedbackForAll::WorldContextObject' has a wrong offset!");

// Function GbxGameSystemCore.FXVolumeManager.OnPlayerDestroyed
// 0x0008 (0x0008 - 0x0000)
struct FXVolumeManager_OnPlayerDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXVolumeManager_OnPlayerDestroyed) == 0x000008, "Wrong alignment on FXVolumeManager_OnPlayerDestroyed");
static_assert(sizeof(FXVolumeManager_OnPlayerDestroyed) == 0x000008, "Wrong size on FXVolumeManager_OnPlayerDestroyed");
static_assert(offsetof(FXVolumeManager_OnPlayerDestroyed, DestroyedActor) == 0x000000, "Member 'FXVolumeManager_OnPlayerDestroyed::DestroyedActor' has a wrong offset!");

// Function GbxGameSystemCore.FXVolumeManager.OnVolumeDestroyed
// 0x0008 (0x0008 - 0x0000)
struct FXVolumeManager_OnVolumeDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXVolumeManager_OnVolumeDestroyed) == 0x000008, "Wrong alignment on FXVolumeManager_OnVolumeDestroyed");
static_assert(sizeof(FXVolumeManager_OnVolumeDestroyed) == 0x000008, "Wrong size on FXVolumeManager_OnVolumeDestroyed");
static_assert(offsetof(FXVolumeManager_OnVolumeDestroyed, DestroyedActor) == 0x000000, "Member 'FXVolumeManager_OnVolumeDestroyed::DestroyedActor' has a wrong offset!");

// Function GbxGameSystemCore.FXVolume.OnActorEnteredVolume
// 0x00B0 (0x00B0 - 0x0000)
struct FXVolume_OnActorEnteredVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXVolume_OnActorEnteredVolume) == 0x000008, "Wrong alignment on FXVolume_OnActorEnteredVolume");
static_assert(sizeof(FXVolume_OnActorEnteredVolume) == 0x0000B0, "Wrong size on FXVolume_OnActorEnteredVolume");
static_assert(offsetof(FXVolume_OnActorEnteredVolume, OverlappedComp) == 0x000000, "Member 'FXVolume_OnActorEnteredVolume::OverlappedComp' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorEnteredVolume, Other) == 0x000008, "Member 'FXVolume_OnActorEnteredVolume::Other' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorEnteredVolume, OtherComp) == 0x000010, "Member 'FXVolume_OnActorEnteredVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorEnteredVolume, OtherBodyIndex) == 0x000018, "Member 'FXVolume_OnActorEnteredVolume::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorEnteredVolume, bFromSweep) == 0x00001C, "Member 'FXVolume_OnActorEnteredVolume::bFromSweep' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorEnteredVolume, OverlapInfo) == 0x000020, "Member 'FXVolume_OnActorEnteredVolume::OverlapInfo' has a wrong offset!");

// Function GbxGameSystemCore.FXVolume.OnActorLeftVolume
// 0x0020 (0x0020 - 0x0000)
struct FXVolume_OnActorLeftVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXVolume_OnActorLeftVolume) == 0x000008, "Wrong alignment on FXVolume_OnActorLeftVolume");
static_assert(sizeof(FXVolume_OnActorLeftVolume) == 0x000020, "Wrong size on FXVolume_OnActorLeftVolume");
static_assert(offsetof(FXVolume_OnActorLeftVolume, OverlappedComponent) == 0x000000, "Member 'FXVolume_OnActorLeftVolume::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorLeftVolume, Other) == 0x000008, "Member 'FXVolume_OnActorLeftVolume::Other' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorLeftVolume, OtherComp) == 0x000010, "Member 'FXVolume_OnActorLeftVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(FXVolume_OnActorLeftVolume, OtherBodyIndex) == 0x000018, "Member 'FXVolume_OnActorLeftVolume::OtherBodyIndex' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTagContainerComponent.GetGameplayTagContainerFromActor
// 0x0018 (0x0018 - 0x0000)
struct GameplayTagContainerComponent_GetGameplayTagContainerFromActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContainsTagComponent                         Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTagContainerComponent_GetGameplayTagContainerFromActor) == 0x000008, "Wrong alignment on GameplayTagContainerComponent_GetGameplayTagContainerFromActor");
static_assert(sizeof(GameplayTagContainerComponent_GetGameplayTagContainerFromActor) == 0x000018, "Wrong size on GameplayTagContainerComponent_GetGameplayTagContainerFromActor");
static_assert(offsetof(GameplayTagContainerComponent_GetGameplayTagContainerFromActor, Actor) == 0x000000, "Member 'GameplayTagContainerComponent_GetGameplayTagContainerFromActor::Actor' has a wrong offset!");
static_assert(offsetof(GameplayTagContainerComponent_GetGameplayTagContainerFromActor, Branches) == 0x000008, "Member 'GameplayTagContainerComponent_GetGameplayTagContainerFromActor::Branches' has a wrong offset!");
static_assert(offsetof(GameplayTagContainerComponent_GetGameplayTagContainerFromActor, ReturnValue) == 0x000010, "Member 'GameplayTagContainerComponent_GetGameplayTagContainerFromActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultActor
// 0x0050 (0x0050 - 0x0000)
struct GameplayTask_RunEnvQuery_GetResultActor final
{
public:
	struct FEnvQueryResult                        QueryResult;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ResultActor;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayTask_RunEnvQuery_GetResultActor) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_GetResultActor");
static_assert(sizeof(GameplayTask_RunEnvQuery_GetResultActor) == 0x000050, "Wrong size on GameplayTask_RunEnvQuery_GetResultActor");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultActor, QueryResult) == 0x000000, "Member 'GameplayTask_RunEnvQuery_GetResultActor::QueryResult' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultActor, ResultActor) == 0x000040, "Member 'GameplayTask_RunEnvQuery_GetResultActor::ResultActor' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultActor, ReturnValue) == 0x000048, "Member 'GameplayTask_RunEnvQuery_GetResultActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultActors
// 0x0058 (0x0058 - 0x0000)
struct GameplayTask_RunEnvQuery_GetResultActors final
{
public:
	struct FEnvQueryResult                        QueryResult;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ResultActors;                                      // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayTask_RunEnvQuery_GetResultActors) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_GetResultActors");
static_assert(sizeof(GameplayTask_RunEnvQuery_GetResultActors) == 0x000058, "Wrong size on GameplayTask_RunEnvQuery_GetResultActors");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultActors, QueryResult) == 0x000000, "Member 'GameplayTask_RunEnvQuery_GetResultActors::QueryResult' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultActors, ResultActors) == 0x000040, "Member 'GameplayTask_RunEnvQuery_GetResultActors::ResultActors' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultActors, ReturnValue) == 0x000050, "Member 'GameplayTask_RunEnvQuery_GetResultActors::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultLocation
// 0x0050 (0x0050 - 0x0000)
struct GameplayTask_RunEnvQuery_GetResultLocation final
{
public:
	struct FEnvQueryResult                        QueryResult;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ResultLocation;                                    // 0x0040(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayTask_RunEnvQuery_GetResultLocation) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_GetResultLocation");
static_assert(sizeof(GameplayTask_RunEnvQuery_GetResultLocation) == 0x000050, "Wrong size on GameplayTask_RunEnvQuery_GetResultLocation");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultLocation, QueryResult) == 0x000000, "Member 'GameplayTask_RunEnvQuery_GetResultLocation::QueryResult' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultLocation, ResultLocation) == 0x000040, "Member 'GameplayTask_RunEnvQuery_GetResultLocation::ResultLocation' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultLocation, ReturnValue) == 0x00004C, "Member 'GameplayTask_RunEnvQuery_GetResultLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultLocations
// 0x0058 (0x0058 - 0x0000)
struct GameplayTask_RunEnvQuery_GetResultLocations final
{
public:
	struct FEnvQueryResult                        QueryResult;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ResultLocations;                                   // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayTask_RunEnvQuery_GetResultLocations) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_GetResultLocations");
static_assert(sizeof(GameplayTask_RunEnvQuery_GetResultLocations) == 0x000058, "Wrong size on GameplayTask_RunEnvQuery_GetResultLocations");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultLocations, QueryResult) == 0x000000, "Member 'GameplayTask_RunEnvQuery_GetResultLocations::QueryResult' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultLocations, ResultLocations) == 0x000040, "Member 'GameplayTask_RunEnvQuery_GetResultLocations::ResultLocations' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_GetResultLocations, ReturnValue) == 0x000050, "Member 'GameplayTask_RunEnvQuery_GetResultLocations::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQuery
// 0x00C8 (0x00C8 - 0x0000)
struct GameplayTask_RunEnvQuery_RunEnvQuery final
{
public:
	class AActor*                                 QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGameplayTask_RunEnvQuery*              ReturnValue;                                       // 0x00C0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunEnvQuery_RunEnvQuery) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_RunEnvQuery");
static_assert(sizeof(GameplayTask_RunEnvQuery_RunEnvQuery) == 0x0000C8, "Wrong size on GameplayTask_RunEnvQuery_RunEnvQuery");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQuery, QueryOwner) == 0x000000, "Member 'GameplayTask_RunEnvQuery_RunEnvQuery::QueryOwner' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQuery, QueryParams) == 0x000008, "Member 'GameplayTask_RunEnvQuery_RunEnvQuery::QueryParams' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQuery, ReturnValue) == 0x0000C0, "Member 'GameplayTask_RunEnvQuery_RunEnvQuery::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQueryOnActor
// 0x00D0 (0x00D0 - 0x0000)
struct GameplayTask_RunEnvQuery_RunEnvQueryOnActor final
{
public:
	class AActor*                                 QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x00C0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_RunEnvQuery*              ReturnValue;                                       // 0x00C8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunEnvQuery_RunEnvQueryOnActor) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_RunEnvQueryOnActor");
static_assert(sizeof(GameplayTask_RunEnvQuery_RunEnvQueryOnActor) == 0x0000D0, "Wrong size on GameplayTask_RunEnvQuery_RunEnvQueryOnActor");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnActor, QueryOwner) == 0x000000, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnActor::QueryOwner' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnActor, QueryParams) == 0x000008, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnActor::QueryParams' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnActor, Actor) == 0x0000C0, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnActor::Actor' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnActor, ReturnValue) == 0x0000C8, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQueryOnLocation
// 0x00D8 (0x00D8 - 0x0000)
struct GameplayTask_RunEnvQuery_RunEnvQueryOnLocation final
{
public:
	class AActor*                                 QueryOwner;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        QueryParams;                                       // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x00C0(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTask_RunEnvQuery*              ReturnValue;                                       // 0x00D0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunEnvQuery_RunEnvQueryOnLocation) == 0x000008, "Wrong alignment on GameplayTask_RunEnvQuery_RunEnvQueryOnLocation");
static_assert(sizeof(GameplayTask_RunEnvQuery_RunEnvQueryOnLocation) == 0x0000D8, "Wrong size on GameplayTask_RunEnvQuery_RunEnvQueryOnLocation");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnLocation, QueryOwner) == 0x000000, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnLocation::QueryOwner' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnLocation, QueryParams) == 0x000008, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnLocation::QueryParams' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnLocation, Location) == 0x0000C0, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunEnvQuery_RunEnvQueryOnLocation, ReturnValue) == 0x0000D0, "Member 'GameplayTask_RunEnvQuery_RunEnvQueryOnLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.AdjustResourcePoolValue
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolFunctionLibrary_AdjustResourcePoolValue final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameResourcePoolFunctionLibrary_AdjustResourcePoolValue) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_AdjustResourcePoolValue");
static_assert(sizeof(GameResourcePoolFunctionLibrary_AdjustResourcePoolValue) == 0x000020, "Wrong size on GameResourcePoolFunctionLibrary_AdjustResourcePoolValue");
static_assert(offsetof(GameResourcePoolFunctionLibrary_AdjustResourcePoolValue, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_AdjustResourcePoolValue::InPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_AdjustResourcePoolValue, InValue) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_AdjustResourcePoolValue::InValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.BreakResourcePoolReference
// 0x0028 (0x0028 - 0x0000)
struct GameResourcePoolFunctionLibrary_BreakResourcePoolReference final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentValue;                                      // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_BreakResourcePoolReference");
static_assert(sizeof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference) == 0x000028, "Wrong size on GameResourcePoolFunctionLibrary_BreakResourcePoolReference");
static_assert(offsetof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_BreakResourcePoolReference::InPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference, bValid) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_BreakResourcePoolReference::bValid' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference, CurrentValue) == 0x00001C, "Member 'GameResourcePoolFunctionLibrary_BreakResourcePoolReference::CurrentValue' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference, MinValue) == 0x000020, "Member 'GameResourcePoolFunctionLibrary_BreakResourcePoolReference::MinValue' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_BreakResourcePoolReference, MaxValue) == 0x000024, "Member 'GameResourcePoolFunctionLibrary_BreakResourcePoolReference::MaxValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelay
// 0x0018 (0x0018 - 0x0000)
struct GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay");
static_assert(sizeof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay) == 0x000018, "Wrong size on GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay");
static_assert(offsetof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay::InPool' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelayByGameResourceData
// 0x0010 (0x0010 - 0x0000)
struct GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourceData*                      Resource;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData");
static_assert(sizeof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData) == 0x000010, "Wrong size on GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData");
static_assert(offsetof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData, Actor) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData::Actor' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData, Resource) == 0x000008, "Member 'GameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData::Resource' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.DeleteResourcePool
// 0x0018 (0x0018 - 0x0000)
struct GameResourcePoolFunctionLibrary_DeleteResourcePool final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_DeleteResourcePool) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_DeleteResourcePool");
static_assert(sizeof(GameResourcePoolFunctionLibrary_DeleteResourcePool) == 0x000018, "Wrong size on GameResourcePoolFunctionLibrary_DeleteResourcePool");
static_assert(offsetof(GameResourcePoolFunctionLibrary_DeleteResourcePool, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_DeleteResourcePool::InPool' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.DrainResourcePoolByPercentage
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPercentage;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage");
static_assert(sizeof(GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage) == 0x000020, "Wrong size on GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage");
static_assert(offsetof(GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage::InPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage, Percentage) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage::Percentage' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage, MinPercentage) == 0x00001C, "Member 'GameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage::MinPercentage' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourceData
// 0x0028 (0x0028 - 0x0000)
struct GameResourcePoolFunctionLibrary_EqualEqual_ResourceData final
{
public:
	struct FGameResourcePoolReference             ResourcePoolReference;                             // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGameResourceData*                      ResourceData;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameResourcePoolFunctionLibrary_EqualEqual_ResourceData) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_EqualEqual_ResourceData");
static_assert(sizeof(GameResourcePoolFunctionLibrary_EqualEqual_ResourceData) == 0x000028, "Wrong size on GameResourcePoolFunctionLibrary_EqualEqual_ResourceData");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourceData, ResourcePoolReference) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourceData::ResourcePoolReference' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourceData, ResourceData) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourceData::ResourceData' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourceData, ReturnValue) == 0x000020, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourceData::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourcePoolData
// 0x0028 (0x0028 - 0x0000)
struct GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData final
{
public:
	struct FGameResourcePoolReference             ResourcePoolReference;                             // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGameResourcePoolData*                  ResourcePoolData;                                  // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData");
static_assert(sizeof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData) == 0x000028, "Wrong size on GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData, ResourcePoolReference) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData::ResourcePoolReference' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData, ResourcePoolData) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData::ResourcePoolData' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData, ReturnValue) == 0x000020, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourcePoolReference
// 0x0038 (0x0038 - 0x0000)
struct GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference final
{
public:
	struct FGameResourcePoolReference             A;                                                 // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameResourcePoolReference             B;                                                 // 0x0018(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference");
static_assert(sizeof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference) == 0x000038, "Wrong size on GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference, A) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference::A' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference, B) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference::B' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference, ReturnValue) == 0x000030, "Member 'GameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.GetDelegatePrefixForResourceEvent
// 0x00A0 (0x00A0 - 0x0000)
struct GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent final
{
public:
	struct FGameResourceUserEvent                 InResourceUserEvent;                               // 0x0000(0x0098)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent");
static_assert(sizeof(GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent) == 0x0000A0, "Wrong size on GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent");
static_assert(offsetof(GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent, InResourceUserEvent) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent::InResourceUserEvent' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent, ReturnValue) == 0x000098, "Member 'GameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.IsResourcePoolInState
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolFunctionLibrary_IsResourcePoolInState final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGameResourcePoolState                        InState;                                           // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameResourcePoolFunctionLibrary_IsResourcePoolInState) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_IsResourcePoolInState");
static_assert(sizeof(GameResourcePoolFunctionLibrary_IsResourcePoolInState) == 0x000020, "Wrong size on GameResourcePoolFunctionLibrary_IsResourcePoolInState");
static_assert(offsetof(GameResourcePoolFunctionLibrary_IsResourcePoolInState, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_IsResourcePoolInState::InPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_IsResourcePoolInState, InState) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_IsResourcePoolInState::InState' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_IsResourcePoolInState, ReturnValue) == 0x000019, "Member 'GameResourcePoolFunctionLibrary_IsResourcePoolInState::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.RefillResourcePoolByPercentage
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPercentage;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage");
static_assert(sizeof(GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage) == 0x000020, "Wrong size on GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage");
static_assert(offsetof(GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage::InPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage, Percentage) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage::Percentage' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage, MaxPercentage) == 0x00001C, "Member 'GameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage::MaxPercentage' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelay
// 0x0018 (0x0018 - 0x0000)
struct GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay");
static_assert(sizeof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay) == 0x000018, "Wrong size on GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay");
static_assert(offsetof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay::InPool' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelayByGameResourceData
// 0x0010 (0x0010 - 0x0000)
struct GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourceData*                      Resource;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData");
static_assert(sizeof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData) == 0x000010, "Wrong size on GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData");
static_assert(offsetof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData, Actor) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData::Actor' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData, Resource) == 0x000008, "Member 'GameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData::Resource' has a wrong offset!");

// Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.SetResourcePoolValue
// 0x0020 (0x0020 - 0x0000)
struct GameResourcePoolFunctionLibrary_SetResourcePoolValue final
{
public:
	struct FGameResourcePoolReference             InPool;                                            // 0x0000(0x0018)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameResourcePoolFunctionLibrary_SetResourcePoolValue) == 0x000008, "Wrong alignment on GameResourcePoolFunctionLibrary_SetResourcePoolValue");
static_assert(sizeof(GameResourcePoolFunctionLibrary_SetResourcePoolValue) == 0x000020, "Wrong size on GameResourcePoolFunctionLibrary_SetResourcePoolValue");
static_assert(offsetof(GameResourcePoolFunctionLibrary_SetResourcePoolValue, InPool) == 0x000000, "Member 'GameResourcePoolFunctionLibrary_SetResourcePoolValue::InPool' has a wrong offset!");
static_assert(offsetof(GameResourcePoolFunctionLibrary_SetResourcePoolValue, InValue) == 0x000018, "Member 'GameResourcePoolFunctionLibrary_SetResourcePoolValue::InValue' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsManager.GetStatValue
// 0x0018 (0x0018 - 0x0000)
struct GameStatsManager_GetStatValue final
{
public:
	class AActor*                                 StatContext;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          GameStat;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStatsManager_GetStatValue) == 0x000008, "Wrong alignment on GameStatsManager_GetStatValue");
static_assert(sizeof(GameStatsManager_GetStatValue) == 0x000018, "Wrong size on GameStatsManager_GetStatValue");
static_assert(offsetof(GameStatsManager_GetStatValue, StatContext) == 0x000000, "Member 'GameStatsManager_GetStatValue::StatContext' has a wrong offset!");
static_assert(offsetof(GameStatsManager_GetStatValue, GameStat) == 0x000008, "Member 'GameStatsManager_GetStatValue::GameStat' has a wrong offset!");
static_assert(offsetof(GameStatsManager_GetStatValue, ReturnValue) == 0x000010, "Member 'GameStatsManager_GetStatValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsManager.IncrementStat
// 0x0018 (0x0018 - 0x0000)
struct GameStatsManager_IncrementStat final
{
public:
	class AActor*                                 StatContext;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          GameStat;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncrementAmount;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStatsManager_IncrementStat) == 0x000008, "Wrong alignment on GameStatsManager_IncrementStat");
static_assert(sizeof(GameStatsManager_IncrementStat) == 0x000018, "Wrong size on GameStatsManager_IncrementStat");
static_assert(offsetof(GameStatsManager_IncrementStat, StatContext) == 0x000000, "Member 'GameStatsManager_IncrementStat::StatContext' has a wrong offset!");
static_assert(offsetof(GameStatsManager_IncrementStat, GameStat) == 0x000008, "Member 'GameStatsManager_IncrementStat::GameStat' has a wrong offset!");
static_assert(offsetof(GameStatsManager_IncrementStat, IncrementAmount) == 0x000010, "Member 'GameStatsManager_IncrementStat::IncrementAmount' has a wrong offset!");

// Function GbxGameSystemCore.GameStatsManager.UpdateStat
// 0x0018 (0x0018 - 0x0000)
struct GameStatsManager_UpdateStat final
{
public:
	class AActor*                                 StatContext;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          GameStat;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewValue;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStatsManager_UpdateStat) == 0x000008, "Wrong alignment on GameStatsManager_UpdateStat");
static_assert(sizeof(GameStatsManager_UpdateStat) == 0x000018, "Wrong size on GameStatsManager_UpdateStat");
static_assert(offsetof(GameStatsManager_UpdateStat, StatContext) == 0x000000, "Member 'GameStatsManager_UpdateStat::StatContext' has a wrong offset!");
static_assert(offsetof(GameStatsManager_UpdateStat, GameStat) == 0x000008, "Member 'GameStatsManager_UpdateStat::GameStat' has a wrong offset!");
static_assert(offsetof(GameStatsManager_UpdateStat, NewValue) == 0x000010, "Member 'GameStatsManager_UpdateStat::NewValue' has a wrong offset!");

// Function GbxGameSystemCore.StretchBonesBlueprintLibrary.SetStretchBonesDistance
// 0x0028 (0x0028 - 0x0000)
struct StretchBonesBlueprintLibrary_SetStretchBonesDistance final
{
public:
	TArray<struct FGbxActionRegister>             GbxActionRegisters;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionRegister>             ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StretchBonesBlueprintLibrary_SetStretchBonesDistance) == 0x000008, "Wrong alignment on StretchBonesBlueprintLibrary_SetStretchBonesDistance");
static_assert(sizeof(StretchBonesBlueprintLibrary_SetStretchBonesDistance) == 0x000028, "Wrong size on StretchBonesBlueprintLibrary_SetStretchBonesDistance");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesDistance, GbxActionRegisters) == 0x000000, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesDistance::GbxActionRegisters' has a wrong offset!");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesDistance, Distance) == 0x000010, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesDistance::Distance' has a wrong offset!");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesDistance, ReturnValue) == 0x000018, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesDistance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StretchBonesBlueprintLibrary.SetStretchBonesTarget
// 0x0038 (0x0038 - 0x0000)
struct StretchBonesBlueprintLibrary_SetStretchBonesTarget final
{
public:
	TArray<struct FGbxActionRegister>             GbxActionRegisters;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionRegister>             ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(StretchBonesBlueprintLibrary_SetStretchBonesTarget) == 0x000008, "Wrong alignment on StretchBonesBlueprintLibrary_SetStretchBonesTarget");
static_assert(sizeof(StretchBonesBlueprintLibrary_SetStretchBonesTarget) == 0x000038, "Wrong size on StretchBonesBlueprintLibrary_SetStretchBonesTarget");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesTarget, GbxActionRegisters) == 0x000000, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesTarget::GbxActionRegisters' has a wrong offset!");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesTarget, TargetActor) == 0x000010, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesTarget, TargetPosition) == 0x000018, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesTarget::TargetPosition' has a wrong offset!");
static_assert(offsetof(StretchBonesBlueprintLibrary_SetStretchBonesTarget, ReturnValue) == 0x000028, "Member 'StretchBonesBlueprintLibrary_SetStretchBonesTarget::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.GetKeyedActionClass
// 0x0018 (0x0018 - 0x0000)
struct GbxActionBlueprintLibrary_GetKeyedActionClass final
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_GetKeyedActionClass) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_GetKeyedActionClass");
static_assert(sizeof(GbxActionBlueprintLibrary_GetKeyedActionClass) == 0x000018, "Wrong size on GbxActionBlueprintLibrary_GetKeyedActionClass");
static_assert(offsetof(GbxActionBlueprintLibrary_GetKeyedActionClass, ActionKey) == 0x000000, "Member 'GbxActionBlueprintLibrary_GetKeyedActionClass::ActionKey' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_GetKeyedActionClass, Target) == 0x000008, "Member 'GbxActionBlueprintLibrary_GetKeyedActionClass::Target' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_GetKeyedActionClass, ReturnValue) == 0x000010, "Member 'GbxActionBlueprintLibrary_GetKeyedActionClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.GetSummary_AnimActionDef
// 0x0028 (0x0028 - 0x0000)
struct GbxActionBlueprintLibrary_GetSummary_AnimActionDef final
{
public:
	struct FAnimActionDef                         AnimActionDef;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_GetSummary_AnimActionDef) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_GetSummary_AnimActionDef");
static_assert(sizeof(GbxActionBlueprintLibrary_GetSummary_AnimActionDef) == 0x000028, "Wrong size on GbxActionBlueprintLibrary_GetSummary_AnimActionDef");
static_assert(offsetof(GbxActionBlueprintLibrary_GetSummary_AnimActionDef, AnimActionDef) == 0x000000, "Member 'GbxActionBlueprintLibrary_GetSummary_AnimActionDef::AnimActionDef' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_GetSummary_AnimActionDef, ReturnValue) == 0x000018, "Member 'GbxActionBlueprintLibrary_GetSummary_AnimActionDef::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetActionByClass
// 0x0018 (0x0018 - 0x0000)
struct GbxActionBlueprintLibrary_K2_GetActionByClass final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_GetActionByClass) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_GetActionByClass");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_GetActionByClass) == 0x000018, "Wrong size on GbxActionBlueprintLibrary_K2_GetActionByClass");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetActionByClass, ActionClass) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_GetActionByClass::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetActionByClass, Target) == 0x000008, "Member 'GbxActionBlueprintLibrary_K2_GetActionByClass::Target' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetActionByClass, ReturnValue) == 0x000010, "Member 'GbxActionBlueprintLibrary_K2_GetActionByClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetMaxCurrentTime
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_K2_GetMaxCurrentTime final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_GetMaxCurrentTime) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_GetMaxCurrentTime");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_GetMaxCurrentTime) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_K2_GetMaxCurrentTime");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetMaxCurrentTime, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_GetMaxCurrentTime::Action' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetMaxCurrentTime, ReturnValue) == 0x000008, "Member 'GbxActionBlueprintLibrary_K2_GetMaxCurrentTime::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetTimeRemaining
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_K2_GetTimeRemaining final
{
public:
	class UGbxAction*                             Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_GetTimeRemaining) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_GetTimeRemaining");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_GetTimeRemaining) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_K2_GetTimeRemaining");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetTimeRemaining, Target) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_GetTimeRemaining::Target' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_GetTimeRemaining, ReturnValue) == 0x000008, "Member 'GbxActionBlueprintLibrary_K2_GetTimeRemaining::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_JumpToNextSection
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_K2_JumpToNextSection final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_JumpToNextSection) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_JumpToNextSection");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_JumpToNextSection) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_K2_JumpToNextSection");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_JumpToNextSection, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_JumpToNextSection::Action' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_Pause
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_K2_Pause final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_Pause) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_Pause");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_Pause) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_K2_Pause");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_Pause, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_Pause::Action' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ProceedToNextSection
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_K2_ProceedToNextSection final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_ProceedToNextSection) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_ProceedToNextSection");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_ProceedToNextSection) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_K2_ProceedToNextSection");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_ProceedToNextSection, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_ProceedToNextSection::Action' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ReplicatedJumpToNextSection
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection::Action' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ReplicatedProceedToNextSection
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection::Action' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_Resume
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_K2_Resume final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_Resume) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_Resume");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_Resume) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_K2_Resume");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_Resume, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_Resume::Action' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ShowGbxActionScreenLogs
// 0x0001 (0x0001 - 0x0000)
struct GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs final
{
public:
	bool                                          bShowLogsOnScreen;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs) == 0x000001, "Wrong alignment on GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs) == 0x000001, "Wrong size on GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs, bShowLogsOnScreen) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs::bShowLogsOnScreen' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_StopActionObj
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_K2_StopActionObj final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_StopActionObj) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_StopActionObj");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_StopActionObj) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_K2_StopActionObj");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_StopActionObj, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_StopActionObj::Action' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_StopActionObj, Target) == 0x000008, "Member 'GbxActionBlueprintLibrary_K2_StopActionObj::Target' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_UpdateActionDirection
// 0x0018 (0x0018 - 0x0000)
struct GbxActionBlueprintLibrary_K2_UpdateActionDirection final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_UpdateActionDirection) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_UpdateActionDirection");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_UpdateActionDirection) == 0x000018, "Wrong size on GbxActionBlueprintLibrary_K2_UpdateActionDirection");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_UpdateActionDirection, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_UpdateActionDirection::Action' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_UpdateActionDirection, Direction) == 0x000008, "Member 'GbxActionBlueprintLibrary_K2_UpdateActionDirection::Direction' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_UpdateActionPlayRate
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_K2_UpdateActionPlayRate final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxActionBlueprintLibrary_K2_UpdateActionPlayRate) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_K2_UpdateActionPlayRate");
static_assert(sizeof(GbxActionBlueprintLibrary_K2_UpdateActionPlayRate) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_K2_UpdateActionPlayRate");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_UpdateActionPlayRate, Action) == 0x000000, "Member 'GbxActionBlueprintLibrary_K2_UpdateActionPlayRate::Action' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_K2_UpdateActionPlayRate, PlayRate) == 0x000008, "Member 'GbxActionBlueprintLibrary_K2_UpdateActionPlayRate::PlayRate' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetFloatGbxActionRegister
// 0x0030 (0x0030 - 0x0000)
struct GbxActionBlueprintLibrary_SetFloatGbxActionRegister final
{
public:
	TArray<struct FGbxActionRegister>             GbxActionRegisters;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   RegisterKey;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicates;                                       // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionRegister>             ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_SetFloatGbxActionRegister");
static_assert(sizeof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister) == 0x000030, "Wrong size on GbxActionBlueprintLibrary_SetFloatGbxActionRegister");
static_assert(offsetof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister, GbxActionRegisters) == 0x000000, "Member 'GbxActionBlueprintLibrary_SetFloatGbxActionRegister::GbxActionRegisters' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister, RegisterKey) == 0x000010, "Member 'GbxActionBlueprintLibrary_SetFloatGbxActionRegister::RegisterKey' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister, Value) == 0x000018, "Member 'GbxActionBlueprintLibrary_SetFloatGbxActionRegister::Value' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister, bReplicates) == 0x00001C, "Member 'GbxActionBlueprintLibrary_SetFloatGbxActionRegister::bReplicates' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetFloatGbxActionRegister, ReturnValue) == 0x000020, "Member 'GbxActionBlueprintLibrary_SetFloatGbxActionRegister::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetIntGbxActionRegister
// 0x0030 (0x0030 - 0x0000)
struct GbxActionBlueprintLibrary_SetIntGbxActionRegister final
{
public:
	TArray<struct FGbxActionRegister>             GbxActionRegisters;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   RegisterKey;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicates;                                       // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionRegister>             ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_SetIntGbxActionRegister) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_SetIntGbxActionRegister");
static_assert(sizeof(GbxActionBlueprintLibrary_SetIntGbxActionRegister) == 0x000030, "Wrong size on GbxActionBlueprintLibrary_SetIntGbxActionRegister");
static_assert(offsetof(GbxActionBlueprintLibrary_SetIntGbxActionRegister, GbxActionRegisters) == 0x000000, "Member 'GbxActionBlueprintLibrary_SetIntGbxActionRegister::GbxActionRegisters' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetIntGbxActionRegister, RegisterKey) == 0x000010, "Member 'GbxActionBlueprintLibrary_SetIntGbxActionRegister::RegisterKey' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetIntGbxActionRegister, Value) == 0x000018, "Member 'GbxActionBlueprintLibrary_SetIntGbxActionRegister::Value' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetIntGbxActionRegister, bReplicates) == 0x00001C, "Member 'GbxActionBlueprintLibrary_SetIntGbxActionRegister::bReplicates' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetIntGbxActionRegister, ReturnValue) == 0x000020, "Member 'GbxActionBlueprintLibrary_SetIntGbxActionRegister::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetNameGbxActionRegister
// 0x0038 (0x0038 - 0x0000)
struct GbxActionBlueprintLibrary_SetNameGbxActionRegister final
{
public:
	TArray<struct FGbxActionRegister>             GbxActionRegisters;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   RegisterKey;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicates;                                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionRegister>             ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_SetNameGbxActionRegister) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_SetNameGbxActionRegister");
static_assert(sizeof(GbxActionBlueprintLibrary_SetNameGbxActionRegister) == 0x000038, "Wrong size on GbxActionBlueprintLibrary_SetNameGbxActionRegister");
static_assert(offsetof(GbxActionBlueprintLibrary_SetNameGbxActionRegister, GbxActionRegisters) == 0x000000, "Member 'GbxActionBlueprintLibrary_SetNameGbxActionRegister::GbxActionRegisters' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetNameGbxActionRegister, RegisterKey) == 0x000010, "Member 'GbxActionBlueprintLibrary_SetNameGbxActionRegister::RegisterKey' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetNameGbxActionRegister, Value) == 0x000018, "Member 'GbxActionBlueprintLibrary_SetNameGbxActionRegister::Value' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetNameGbxActionRegister, bReplicates) == 0x000020, "Member 'GbxActionBlueprintLibrary_SetNameGbxActionRegister::bReplicates' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetNameGbxActionRegister, ReturnValue) == 0x000028, "Member 'GbxActionBlueprintLibrary_SetNameGbxActionRegister::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetObjectGbxActionRegister
// 0x0038 (0x0038 - 0x0000)
struct GbxActionBlueprintLibrary_SetObjectGbxActionRegister final
{
public:
	TArray<struct FGbxActionRegister>             GbxActionRegisters;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   RegisterKey;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Value;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicates;                                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionRegister>             ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_SetObjectGbxActionRegister");
static_assert(sizeof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister) == 0x000038, "Wrong size on GbxActionBlueprintLibrary_SetObjectGbxActionRegister");
static_assert(offsetof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister, GbxActionRegisters) == 0x000000, "Member 'GbxActionBlueprintLibrary_SetObjectGbxActionRegister::GbxActionRegisters' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister, RegisterKey) == 0x000010, "Member 'GbxActionBlueprintLibrary_SetObjectGbxActionRegister::RegisterKey' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister, Value) == 0x000018, "Member 'GbxActionBlueprintLibrary_SetObjectGbxActionRegister::Value' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister, bReplicates) == 0x000020, "Member 'GbxActionBlueprintLibrary_SetObjectGbxActionRegister::bReplicates' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_SetObjectGbxActionRegister, ReturnValue) == 0x000028, "Member 'GbxActionBlueprintLibrary_SetObjectGbxActionRegister::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActionClass
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_StopActionClass final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_StopActionClass) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_StopActionClass");
static_assert(sizeof(GbxActionBlueprintLibrary_StopActionClass) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_StopActionClass");
static_assert(offsetof(GbxActionBlueprintLibrary_StopActionClass, ActionClass) == 0x000000, "Member 'GbxActionBlueprintLibrary_StopActionClass::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_StopActionClass, Target) == 0x000008, "Member 'GbxActionBlueprintLibrary_StopActionClass::Target' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActions
// 0x0008 (0x0008 - 0x0000)
struct GbxActionBlueprintLibrary_StopActions final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_StopActions) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_StopActions");
static_assert(sizeof(GbxActionBlueprintLibrary_StopActions) == 0x000008, "Wrong size on GbxActionBlueprintLibrary_StopActions");
static_assert(offsetof(GbxActionBlueprintLibrary_StopActions, Target) == 0x000000, "Member 'GbxActionBlueprintLibrary_StopActions::Target' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActionSlot
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_StopActionSlot final
{
public:
	class FName                                   ActionSlotName;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_StopActionSlot) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_StopActionSlot");
static_assert(sizeof(GbxActionBlueprintLibrary_StopActionSlot) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_StopActionSlot");
static_assert(offsetof(GbxActionBlueprintLibrary_StopActionSlot, ActionSlotName) == 0x000000, "Member 'GbxActionBlueprintLibrary_StopActionSlot::ActionSlotName' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_StopActionSlot, Target) == 0x000008, "Member 'GbxActionBlueprintLibrary_StopActionSlot::Target' has a wrong offset!");

// Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopLoopingActionClass
// 0x0010 (0x0010 - 0x0000)
struct GbxActionBlueprintLibrary_StopLoopingActionClass final
{
public:
	TSubclassOf<class UGbxAction_Loop>            ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxActionBlueprintLibrary_StopLoopingActionClass) == 0x000008, "Wrong alignment on GbxActionBlueprintLibrary_StopLoopingActionClass");
static_assert(sizeof(GbxActionBlueprintLibrary_StopLoopingActionClass) == 0x000010, "Wrong size on GbxActionBlueprintLibrary_StopLoopingActionClass");
static_assert(offsetof(GbxActionBlueprintLibrary_StopLoopingActionClass, ActionClass) == 0x000000, "Member 'GbxActionBlueprintLibrary_StopLoopingActionClass::ActionClass' has a wrong offset!");
static_assert(offsetof(GbxActionBlueprintLibrary_StopLoopingActionClass, Target) == 0x000008, "Member 'GbxActionBlueprintLibrary_StopLoopingActionClass::Target' has a wrong offset!");

// Function GbxGameSystemCore.GbxAnimBlueprintProfile.AnimBlueprintImportFunction
// 0x0001 (0x0001 - 0x0000)
struct GbxAnimBlueprintProfile_AnimBlueprintImportFunction final
{
public:
	EAnimBPProfileImport                          ImportType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAnimBlueprintProfile_AnimBlueprintImportFunction) == 0x000001, "Wrong alignment on GbxAnimBlueprintProfile_AnimBlueprintImportFunction");
static_assert(sizeof(GbxAnimBlueprintProfile_AnimBlueprintImportFunction) == 0x000001, "Wrong size on GbxAnimBlueprintProfile_AnimBlueprintImportFunction");
static_assert(offsetof(GbxAnimBlueprintProfile_AnimBlueprintImportFunction, ImportType) == 0x000000, "Member 'GbxAnimBlueprintProfile_AnimBlueprintImportFunction::ImportType' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeData.CanAddAndRemoveModifiers
// 0x0001 (0x0001 - 0x0000)
struct GbxAttributeData_CanAddAndRemoveModifiers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeData_CanAddAndRemoveModifiers) == 0x000001, "Wrong alignment on GbxAttributeData_CanAddAndRemoveModifiers");
static_assert(sizeof(GbxAttributeData_CanAddAndRemoveModifiers) == 0x000001, "Wrong size on GbxAttributeData_CanAddAndRemoveModifiers");
static_assert(offsetof(GbxAttributeData_CanAddAndRemoveModifiers, ReturnValue) == 0x000000, "Member 'GbxAttributeData_CanAddAndRemoveModifiers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeData.CanAddModifiers
// 0x0001 (0x0001 - 0x0000)
struct GbxAttributeData_CanAddModifiers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeData_CanAddModifiers) == 0x000001, "Wrong alignment on GbxAttributeData_CanAddModifiers");
static_assert(sizeof(GbxAttributeData_CanAddModifiers) == 0x000001, "Wrong size on GbxAttributeData_CanAddModifiers");
static_assert(offsetof(GbxAttributeData_CanAddModifiers, ReturnValue) == 0x000000, "Member 'GbxAttributeData_CanAddModifiers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeData.CanBindToOnChangedEvent
// 0x0001 (0x0001 - 0x0000)
struct GbxAttributeData_CanBindToOnChangedEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeData_CanBindToOnChangedEvent) == 0x000001, "Wrong alignment on GbxAttributeData_CanBindToOnChangedEvent");
static_assert(sizeof(GbxAttributeData_CanBindToOnChangedEvent) == 0x000001, "Wrong size on GbxAttributeData_CanBindToOnChangedEvent");
static_assert(offsetof(GbxAttributeData_CanBindToOnChangedEvent, ReturnValue) == 0x000000, "Member 'GbxAttributeData_CanBindToOnChangedEvent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeData.CanSetBaseValue
// 0x0001 (0x0001 - 0x0000)
struct GbxAttributeData_CanSetBaseValue final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeData_CanSetBaseValue) == 0x000001, "Wrong alignment on GbxAttributeData_CanSetBaseValue");
static_assert(sizeof(GbxAttributeData_CanSetBaseValue) == 0x000001, "Wrong size on GbxAttributeData_CanSetBaseValue");
static_assert(offsetof(GbxAttributeData_CanSetBaseValue, ReturnValue) == 0x000000, "Member 'GbxAttributeData_CanSetBaseValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingDebugServerRpcComponent.SetInspectedActor
// 0x0008 (0x0008 - 0x0000)
struct TargetingDebugServerRpcComponent_SetInspectedActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingDebugServerRpcComponent_SetInspectedActor) == 0x000008, "Wrong alignment on TargetingDebugServerRpcComponent_SetInspectedActor");
static_assert(sizeof(TargetingDebugServerRpcComponent_SetInspectedActor) == 0x000008, "Wrong size on TargetingDebugServerRpcComponent_SetInspectedActor");
static_assert(offsetof(TargetingDebugServerRpcComponent_SetInspectedActor, Actor) == 0x000000, "Member 'TargetingDebugServerRpcComponent_SetInspectedActor::Actor' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.AddModifierToGbxAttribute
// 0x0030 (0x0030 - 0x0000)
struct GbxAttributeFunctionLibrary_AddModifierToGbxAttribute final
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifierValue;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierActionExecOutput         ModifierActionResult;                              // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeModifierHandle            ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_AddModifierToGbxAttribute");
static_assert(sizeof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute) == 0x000030, "Wrong size on GbxAttributeFunctionLibrary_AddModifierToGbxAttribute");
static_assert(offsetof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_AddModifierToGbxAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_AddModifierToGbxAttribute::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute, ModifierType) == 0x000010, "Member 'GbxAttributeFunctionLibrary_AddModifierToGbxAttribute::ModifierType' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute, ModifierValue) == 0x000014, "Member 'GbxAttributeFunctionLibrary_AddModifierToGbxAttribute::ModifierValue' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute, ModifierActionResult) == 0x000018, "Member 'GbxAttributeFunctionLibrary_AddModifierToGbxAttribute::ModifierActionResult' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_AddModifierToGbxAttribute, ReturnValue) == 0x000020, "Member 'GbxAttributeFunctionLibrary_AddModifierToGbxAttribute::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyAttributeBaseValueData
// 0x0058 (0x0058 - 0x0000)
struct GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData final
{
public:
	struct FAttributeBaseValueData                BaseValueData;                                     // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                AttributeToSetContextSource;                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ValueContext;                                      // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierActionExecOutput         ModifierActionResult;                              // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData");
static_assert(sizeof(GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData) == 0x000058, "Wrong size on GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData, BaseValueData) == 0x000000, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData::BaseValueData' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData, AttributeToSetContextSource) == 0x000040, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData::AttributeToSetContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData, ValueContext) == 0x000048, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData::ValueContext' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData, ModifierActionResult) == 0x000050, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeBaseValueData::ModifierActionResult' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyAttributeEffect
// 0x0070 (0x0070 - 0x0000)
struct GbxAttributeFunctionLibrary_ApplyAttributeEffect final
{
public:
	struct FAttributeEffectData                   Effect;                                            // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                ModifierValueContext;                              // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                AttributeToModifyContextSource;                    // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierActionExecOutput         ModifierActionResult;                              // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeModifierHandle            ReturnValue;                                       // 0x0060(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_ApplyAttributeEffect) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_ApplyAttributeEffect");
static_assert(sizeof(GbxAttributeFunctionLibrary_ApplyAttributeEffect) == 0x000070, "Wrong size on GbxAttributeFunctionLibrary_ApplyAttributeEffect");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeEffect, Effect) == 0x000000, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeEffect::Effect' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeEffect, ModifierValueContext) == 0x000048, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeEffect::ModifierValueContext' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeEffect, AttributeToModifyContextSource) == 0x000050, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeEffect::AttributeToModifyContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeEffect, ModifierActionResult) == 0x000058, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeEffect::ModifierActionResult' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyAttributeEffect, ReturnValue) == 0x000060, "Member 'GbxAttributeFunctionLibrary_ApplyAttributeEffect::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyMultipleAttributeBaseValueData
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData final
{
public:
	TArray<struct FAttributeBaseValueData>        BaseValueData;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                AttributeToSetContextSource;                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ValueContext;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData");
static_assert(sizeof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData, BaseValueData) == 0x000000, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData::BaseValueData' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData, AttributeToSetContextSource) == 0x000010, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData::AttributeToSetContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData, ValueContext) == 0x000018, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData::ValueContext' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyMultipleAttributeEffects
// 0x0030 (0x0030 - 0x0000)
struct GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects final
{
public:
	TArray<struct FAttributeEffectData>           Effects;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                ModifierValueContext;                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                AttributeToModifyContextSource;                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxAttributeModifierHandle>    ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects");
static_assert(sizeof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects) == 0x000030, "Wrong size on GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects, Effects) == 0x000000, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects::Effects' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects, ModifierValueContext) == 0x000010, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects::ModifierValueContext' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects, AttributeToModifyContextSource) == 0x000018, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects::AttributeToModifyContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects, ReturnValue) == 0x000020, "Member 'GbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnAttributeChanged
// 0x0050 (0x0050 - 0x0000)
struct GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged final
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float OldValue, float NewValue)> Delegate;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxAttributeDelegateBindingHandle     ReturnValue;                                       // 0x0020(0x0030)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged) == 0x000050, "Wrong size on GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged, Delegate) == 0x000010, "Member 'GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged::Delegate' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged, ReturnValue) == 0x000020, "Member 'GbxAttributeFunctionLibrary_BindEventToOnAttributeChanged::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnFloatAttributeChanged
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged final
{
public:
	struct FGbxAttributeFloat                     Attribute;                                         // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float OldValue, float NewValue)> Delegate;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged, Delegate) == 0x000010, "Member 'GbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged::Delegate' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnIntegerAttributeChanged
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged final
{
public:
	struct FGbxAttributeInteger                   Attribute;                                         // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float OldValue, float NewValue)> Delegate;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged, Delegate) == 0x000010, "Member 'GbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged::Delegate' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BreakGbxAttributeFloat
// 0x0014 (0x0014 - 0x0000)
struct GbxAttributeFunctionLibrary_BreakGbxAttributeFloat final
{
public:
	struct FGbxAttributeFloat                     Attribute;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseValue;                                         // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_BreakGbxAttributeFloat) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_BreakGbxAttributeFloat");
static_assert(sizeof(GbxAttributeFunctionLibrary_BreakGbxAttributeFloat) == 0x000014, "Wrong size on GbxAttributeFunctionLibrary_BreakGbxAttributeFloat");
static_assert(offsetof(GbxAttributeFunctionLibrary_BreakGbxAttributeFloat, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_BreakGbxAttributeFloat::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BreakGbxAttributeFloat, Value) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_BreakGbxAttributeFloat::Value' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BreakGbxAttributeFloat, BaseValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_BreakGbxAttributeFloat::BaseValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BreakGbxAttributeInteger
// 0x0014 (0x0014 - 0x0000)
struct GbxAttributeFunctionLibrary_BreakGbxAttributeInteger final
{
public:
	struct FGbxAttributeInteger                   Attribute;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseValue;                                         // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_BreakGbxAttributeInteger) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_BreakGbxAttributeInteger");
static_assert(sizeof(GbxAttributeFunctionLibrary_BreakGbxAttributeInteger) == 0x000014, "Wrong size on GbxAttributeFunctionLibrary_BreakGbxAttributeInteger");
static_assert(offsetof(GbxAttributeFunctionLibrary_BreakGbxAttributeInteger, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_BreakGbxAttributeInteger::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BreakGbxAttributeInteger, Value) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_BreakGbxAttributeInteger::Value' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_BreakGbxAttributeInteger, BaseValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_BreakGbxAttributeInteger::BaseValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_AttributeInitializationDataToString
// 0x0048 (0x0048 - 0x0000)
struct GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString final
{
public:
	struct FAttributeInitializationData           InitData;                                          // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString");
static_assert(sizeof(GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString) == 0x000048, "Wrong size on GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString, InitData) == 0x000000, "Member 'GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString::InitData' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString, ReturnValue) == 0x000038, "Member 'GbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeFloatToFloat
// 0x0010 (0x0010 - 0x0000)
struct GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat final
{
public:
	struct FGbxAttributeFloat                     Attribute;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat");
static_assert(sizeof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat) == 0x000010, "Wrong size on GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat, ReturnValue) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeFloatToString
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString final
{
public:
	struct FGbxAttributeFloat                     Attribute;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString");
static_assert(sizeof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeIntegerToInteger
// 0x0010 (0x0010 - 0x0000)
struct GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger final
{
public:
	struct FGbxAttributeInteger                   Attribute;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger");
static_assert(sizeof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger) == 0x000010, "Wrong size on GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger, ReturnValue) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeIntegerToString
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString final
{
public:
	struct FGbxAttributeInteger                   Attribute;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString");
static_assert(sizeof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeModifierHandleToString
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString final
{
public:
	struct FGbxAttributeModifierHandle            Attribute;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString");
static_assert(sizeof(GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeFloat
// 0x001C (0x001C - 0x0000)
struct GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat final
{
public:
	struct FGbxAttributeFloat                     A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     B;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat");
static_assert(sizeof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat) == 0x00001C, "Wrong size on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat, A) == 0x000000, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat::A' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat, B) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat::B' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat, ReturnValue) == 0x000018, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeFloatValue
// 0x0014 (0x0014 - 0x0000)
struct GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue final
{
public:
	struct FGbxAttributeFloat                     A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue");
static_assert(sizeof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue) == 0x000014, "Wrong size on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue, A) == 0x000000, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue::A' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue, B) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue::B' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeInteger
// 0x001C (0x001C - 0x0000)
struct GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger final
{
public:
	struct FGbxAttributeInteger                   A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeInteger                   B;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger");
static_assert(sizeof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger) == 0x00001C, "Wrong size on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger, A) == 0x000000, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger::A' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger, B) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger::B' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger, ReturnValue) == 0x000018, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeIntegerValue
// 0x0014 (0x0014 - 0x0000)
struct GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue final
{
public:
	struct FGbxAttributeInteger                   A;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue");
static_assert(sizeof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue) == 0x000014, "Wrong size on GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue, A) == 0x000000, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue::A' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue, B) == 0x00000C, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue::B' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EvaluateAttributeInitializationData
// 0x0048 (0x0048 - 0x0000)
struct GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData final
{
public:
	struct FAttributeInitializationData           InitializationData;                                // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData");
static_assert(sizeof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData) == 0x000048, "Wrong size on GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData");
static_assert(offsetof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData, InitializationData) == 0x000000, "Member 'GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData::InitializationData' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData, ContextSource) == 0x000038, "Member 'GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData, ReturnValue) == 0x000040, "Member 'GbxAttributeFunctionLibrary_EvaluateAttributeInitializationData::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EvaluateAttributeInitializer
// 0x0018 (0x0018 - 0x0000)
struct GbxAttributeFunctionLibrary_EvaluateAttributeInitializer final
{
public:
	TSubclassOf<class UAttributeInitializer>      Initializer;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializer) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_EvaluateAttributeInitializer");
static_assert(sizeof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializer) == 0x000018, "Wrong size on GbxAttributeFunctionLibrary_EvaluateAttributeInitializer");
static_assert(offsetof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializer, Initializer) == 0x000000, "Member 'GbxAttributeFunctionLibrary_EvaluateAttributeInitializer::Initializer' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializer, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_EvaluateAttributeInitializer::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_EvaluateAttributeInitializer, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_EvaluateAttributeInitializer::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueFromAttributeDefinedRow
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow final
{
public:
	struct FDataTableRowHandle                    RowHandle;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow");
static_assert(sizeof(GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow, RowHandle) == 0x000000, "Member 'GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow::RowHandle' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow, ContextSource) == 0x000010, "Member 'GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow, ReturnValue) == 0x000018, "Member 'GbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttribute
// 0x0018 (0x0018 - 0x0000)
struct GbxAttributeFunctionLibrary_GetValueOfAttribute final
{
public:
	const class UGbxAttributeData*                Attribute;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_GetValueOfAttribute) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_GetValueOfAttribute");
static_assert(sizeof(GbxAttributeFunctionLibrary_GetValueOfAttribute) == 0x000018, "Wrong size on GbxAttributeFunctionLibrary_GetValueOfAttribute");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttribute, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttribute, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttribute::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttribute, DefaultValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttribute::DefaultValue' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttribute, ReturnValue) == 0x000014, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttribute::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttributeAsBoolean
// 0x0018 (0x0018 - 0x0000)
struct GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean final
{
public:
	const class UGbxAttributeData*                Attribute;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultValue;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean");
static_assert(sizeof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean) == 0x000018, "Wrong size on GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean, DefaultValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean::DefaultValue' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean, ReturnValue) == 0x000011, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttributeAsInteger
// 0x0018 (0x0018 - 0x0000)
struct GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger final
{
public:
	const class UGbxAttributeData*                Attribute;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger");
static_assert(sizeof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger) == 0x000018, "Wrong size on GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger, DefaultValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger::DefaultValue' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger, ReturnValue) == 0x000014, "Member 'GbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.MakeGbxAttributeFloat
// 0x0010 (0x0010 - 0x0000)
struct GbxAttributeFunctionLibrary_MakeGbxAttributeFloat final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_MakeGbxAttributeFloat) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_MakeGbxAttributeFloat");
static_assert(sizeof(GbxAttributeFunctionLibrary_MakeGbxAttributeFloat) == 0x000010, "Wrong size on GbxAttributeFunctionLibrary_MakeGbxAttributeFloat");
static_assert(offsetof(GbxAttributeFunctionLibrary_MakeGbxAttributeFloat, BaseValue) == 0x000000, "Member 'GbxAttributeFunctionLibrary_MakeGbxAttributeFloat::BaseValue' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_MakeGbxAttributeFloat, ReturnValue) == 0x000004, "Member 'GbxAttributeFunctionLibrary_MakeGbxAttributeFloat::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.MakeGbxAttributeInteger
// 0x0010 (0x0010 - 0x0000)
struct GbxAttributeFunctionLibrary_MakeGbxAttributeInteger final
{
public:
	int32                                         BaseValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeInteger                   ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_MakeGbxAttributeInteger) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_MakeGbxAttributeInteger");
static_assert(sizeof(GbxAttributeFunctionLibrary_MakeGbxAttributeInteger) == 0x000010, "Wrong size on GbxAttributeFunctionLibrary_MakeGbxAttributeInteger");
static_assert(offsetof(GbxAttributeFunctionLibrary_MakeGbxAttributeInteger, BaseValue) == 0x000000, "Member 'GbxAttributeFunctionLibrary_MakeGbxAttributeInteger::BaseValue' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_MakeGbxAttributeInteger, ReturnValue) == 0x000004, "Member 'GbxAttributeFunctionLibrary_MakeGbxAttributeInteger::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RefreshBindingToOnAttributeChangedEvent
// 0x0068 (0x0068 - 0x0000)
struct GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent final
{
public:
	struct FGbxAttributeDelegateBindingHandle     BindingHandle;                                     // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeDelegateBindingHandle     ReturnValue;                                       // 0x0038(0x0030)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent");
static_assert(sizeof(GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent) == 0x000068, "Wrong size on GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent");
static_assert(offsetof(GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent, BindingHandle) == 0x000000, "Member 'GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent::BindingHandle' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent, ContextSource) == 0x000030, "Member 'GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent, ReturnValue) == 0x000038, "Member 'GbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveAttributeModifier
// 0x0018 (0x0018 - 0x0000)
struct GbxAttributeFunctionLibrary_RemoveAttributeModifier final
{
public:
	struct FGbxAttributeModifierHandle            ModifierHandle;                                    // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_RemoveAttributeModifier) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_RemoveAttributeModifier");
static_assert(sizeof(GbxAttributeFunctionLibrary_RemoveAttributeModifier) == 0x000018, "Wrong size on GbxAttributeFunctionLibrary_RemoveAttributeModifier");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveAttributeModifier, ModifierHandle) == 0x000000, "Member 'GbxAttributeFunctionLibrary_RemoveAttributeModifier::ModifierHandle' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveAttributeModifier, ReturnValue) == 0x000010, "Member 'GbxAttributeFunctionLibrary_RemoveAttributeModifier::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveModifierFromGbxAttribute
// 0x0028 (0x0028 - 0x0000)
struct GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute final
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeModifierHandle            ModifierHandle;                                    // 0x0010(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EGbxAttributeModifierActionExecOutput         ModifierActionResult;                              // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute");
static_assert(sizeof(GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute) == 0x000028, "Wrong size on GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute, ContextSource) == 0x000008, "Member 'GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute, ModifierHandle) == 0x000010, "Member 'GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute::ModifierHandle' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute, ModifierActionResult) == 0x000020, "Member 'GbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute::ModifierActionResult' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveMultipleAttributeModifiers
// 0x0010 (0x0010 - 0x0000)
struct GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers final
{
public:
	TArray<struct FGbxAttributeModifierHandle>    ModifierHandles;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers");
static_assert(sizeof(GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers) == 0x000010, "Wrong size on GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers");
static_assert(offsetof(GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers, ModifierHandles) == 0x000000, "Member 'GbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers::ModifierHandles' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindAllEventsFromOnFloatAttributeChanged
// 0x000C (0x000C - 0x0000)
struct GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged final
{
public:
	struct FGbxAttributeFloat                     Attribute;                                         // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged) == 0x00000C, "Wrong size on GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged::Attribute' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindAllEventsFromOnIntegerAttributeChanged
// 0x000C (0x000C - 0x0000)
struct GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged final
{
public:
	struct FGbxAttributeInteger                   Attribute;                                         // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged) == 0x00000C, "Wrong size on GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged::Attribute' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindEventFromOnFloatAttributeChanged
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged final
{
public:
	struct FGbxAttributeFloat                     Attribute;                                         // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float OldValue, float NewValue)> Delegate;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged, Delegate) == 0x000010, "Member 'GbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged::Delegate' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindEventFromOnIntegerAttributeChanged
// 0x0020 (0x0020 - 0x0000)
struct GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged final
{
public:
	struct FGbxAttributeInteger                   Attribute;                                         // 0x0000(0x000C)(Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float OldValue, float NewValue)> Delegate;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged) == 0x000004, "Wrong alignment on GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged) == 0x000020, "Wrong size on GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged, Attribute) == 0x000000, "Member 'GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged::Attribute' has a wrong offset!");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged, Delegate) == 0x000010, "Member 'GbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged::Delegate' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindFromOnAttributeChanged
// 0x0030 (0x0030 - 0x0000)
struct GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged final
{
public:
	struct FGbxAttributeDelegateBindingHandle     BindingHandle;                                     // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged) == 0x000008, "Wrong alignment on GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged");
static_assert(sizeof(GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged) == 0x000030, "Wrong size on GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged");
static_assert(offsetof(GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged, BindingHandle) == 0x000000, "Member 'GbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged::BindingHandle' has a wrong offset!");

// Function GbxGameSystemCore.GbxAttributesComponent.IsAttributeSetClassUnrelatedToExistingSet
// 0x0010 (0x0010 - 0x0000)
struct GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet final
{
public:
	const class UClass*                           AttributeSetClass;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet) == 0x000008, "Wrong alignment on GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet");
static_assert(sizeof(GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet) == 0x000010, "Wrong size on GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet");
static_assert(offsetof(GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet, AttributeSetClass) == 0x000000, "Member 'GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet::AttributeSetClass' has a wrong offset!");
static_assert(offsetof(GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet, ReturnValue) == 0x000008, "Member 'GbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffect.OnBeginEffect
// 0x0008 (0x0008 - 0x0000)
struct StatusEffect_OnBeginEffect final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffect_OnBeginEffect) == 0x000008, "Wrong alignment on StatusEffect_OnBeginEffect");
static_assert(sizeof(StatusEffect_OnBeginEffect) == 0x000008, "Wrong size on StatusEffect_OnBeginEffect");
static_assert(offsetof(StatusEffect_OnBeginEffect, Target) == 0x000000, "Member 'StatusEffect_OnBeginEffect::Target' has a wrong offset!");

// Function GbxGameSystemCore.StatusEffect.OnEndEffect
// 0x0008 (0x0008 - 0x0000)
struct StatusEffect_OnEndEffect final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatusEffect_OnEndEffect) == 0x000008, "Wrong alignment on StatusEffect_OnEndEffect");
static_assert(sizeof(StatusEffect_OnEndEffect) == 0x000008, "Wrong size on StatusEffect_OnEndEffect");
static_assert(offsetof(StatusEffect_OnEndEffect, Target) == 0x000000, "Member 'StatusEffect_OnEndEffect::Target' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.ClearValue
// 0x0018 (0x0018 - 0x0000)
struct GbxBlackboardKeySelectorExt_ClearValue final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_ClearValue) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_ClearValue");
static_assert(sizeof(GbxBlackboardKeySelectorExt_ClearValue) == 0x000018, "Wrong size on GbxBlackboardKeySelectorExt_ClearValue");
static_assert(offsetof(GbxBlackboardKeySelectorExt_ClearValue, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_ClearValue::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_ClearValue, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_ClearValue::BlackboardComponent' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetPropertyDescription
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetPropertyDescription final
{
public:
	struct FGbxBlackboardKeySelector              BBKey;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetPropertyDescription) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetPropertyDescription");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetPropertyDescription) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_GetPropertyDescription");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetPropertyDescription, BBKey) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetPropertyDescription::BBKey' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetPropertyDescription, Property) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetPropertyDescription::Property' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetPropertyDescription, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetPropertyDescription::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsActor
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsActor final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsActor) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsActor");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsActor) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsActor");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsActor, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsActor::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsActor, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsActor::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsActor, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsBool
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsBool final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsBool) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsBool");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsBool) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsBool");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsBool, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsBool::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsBool, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsBool::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsBool, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsBool::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsClass
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsClass final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsClass) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsClass");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsClass) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsClass");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsClass, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsClass::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsClass, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsClass::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsClass, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsEnum
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsEnum final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsEnum) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsEnum");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsEnum) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsEnum");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsEnum, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsEnum::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsEnum, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsEnum::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsEnum, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsEnum::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsFloat
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsFloat final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsFloat) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsFloat");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsFloat) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsFloat");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsFloat, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsFloat::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsFloat, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsFloat::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsFloat, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsFloat::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsInt
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsInt final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsInt) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsInt");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsInt) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsInt");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsInt, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsInt::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsInt, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsInt::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsInt, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsInt::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsName
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsName final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsName) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsName");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsName) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsName");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsName, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsName::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsName, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsName::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsName, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsName::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsObject
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsObject final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsObject) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsObject");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsObject) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsObject");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsObject, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsObject::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsObject, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsObject::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsObject, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsObject::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsRotator
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsRotator final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsRotator) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsRotator");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsRotator) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsRotator");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsRotator, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsRotator::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsRotator, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsRotator::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsRotator, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsRotator::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsString
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsString final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsString) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsString");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsString) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsString");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsString, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsString::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsString, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsString::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsString, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsTargetActorInfo
// 0x03A8 (0x03A8 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTargetActorInfo                       ReturnValue;                                       // 0x0018(0x0390)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo) == 0x0003A8, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsVector
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_GetValueAsVector final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_GetValueAsVector) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_GetValueAsVector");
static_assert(sizeof(GbxBlackboardKeySelectorExt_GetValueAsVector) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_GetValueAsVector");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsVector, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_GetValueAsVector::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsVector, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_GetValueAsVector::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_GetValueAsVector, ReturnValue) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_GetValueAsVector::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsBool
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsBool final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsBool) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsBool");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsBool) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsBool");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsBool, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsBool::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsBool, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsBool::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsBool, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsBool::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsClass
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsClass final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Value;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsClass) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsClass");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsClass) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsClass");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsClass, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsClass::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsClass, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsClass::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsClass, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsClass::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsEnum
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsEnum final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsEnum) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsEnum");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsEnum) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsEnum");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsEnum, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsEnum::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsEnum, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsEnum::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsEnum, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsEnum::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsFlag
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsFlag final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsFlag) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsFlag");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsFlag) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsFlag");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFlag, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFlag::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFlag, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFlag::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFlag, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFlag::Value' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFlag, Duration) == 0x00001C, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFlag::Duration' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsFloat
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsFloat final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsFloat) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsFloat");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsFloat) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsFloat");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFloat, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFloat::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFloat, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFloat::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsFloat, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsFloat::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsInt
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsInt final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsInt) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsInt");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsInt) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsInt");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsInt, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsInt::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsInt, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsInt::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsInt, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsInt::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsName
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsName final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsName) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsName");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsName) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsName");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsName, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsName::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsName, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsName::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsName, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsName::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsObject
// 0x0020 (0x0020 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsObject final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Value;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsObject) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsObject");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsObject) == 0x000020, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsObject");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsObject, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsObject::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsObject, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsObject::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsObject, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsObject::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsRotator
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsRotator final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Value;                                             // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsRotator) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsRotator");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsRotator) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsRotator");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsRotator, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsRotator::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsRotator, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsRotator::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsRotator, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsRotator::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsString
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsString final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsString) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsString");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsString) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsString");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsString, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsString::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsString, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsString::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsString, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsString::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsTargetActorInfo
// 0x03A8 (0x03A8 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTargetActorInfo                       Value;                                             // 0x0018(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo) == 0x0003A8, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo::Value' has a wrong offset!");

// Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsVector
// 0x0028 (0x0028 - 0x0000)
struct GbxBlackboardKeySelectorExt_SetValueAsVector final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxBlackboardKeySelectorExt_SetValueAsVector) == 0x000008, "Wrong alignment on GbxBlackboardKeySelectorExt_SetValueAsVector");
static_assert(sizeof(GbxBlackboardKeySelectorExt_SetValueAsVector) == 0x000028, "Wrong size on GbxBlackboardKeySelectorExt_SetValueAsVector");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsVector, Key) == 0x000000, "Member 'GbxBlackboardKeySelectorExt_SetValueAsVector::Key' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsVector, BlackboardComponent) == 0x000010, "Member 'GbxBlackboardKeySelectorExt_SetValueAsVector::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(GbxBlackboardKeySelectorExt_SetValueAsVector, Value) == 0x000018, "Member 'GbxBlackboardKeySelectorExt_SetValueAsVector::Value' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.ChangeSwitch
// 0x0018 (0x0018 - 0x0000)
struct SceneBodySwitchFunctionLibrary_ChangeSwitch final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwitchName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchFunctionLibrary_ChangeSwitch) == 0x000008, "Wrong alignment on SceneBodySwitchFunctionLibrary_ChangeSwitch");
static_assert(sizeof(SceneBodySwitchFunctionLibrary_ChangeSwitch) == 0x000018, "Wrong size on SceneBodySwitchFunctionLibrary_ChangeSwitch");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_ChangeSwitch, Context) == 0x000000, "Member 'SceneBodySwitchFunctionLibrary_ChangeSwitch::Context' has a wrong offset!");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_ChangeSwitch, SwitchName) == 0x000008, "Member 'SceneBodySwitchFunctionLibrary_ChangeSwitch::SwitchName' has a wrong offset!");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_ChangeSwitch, StateName) == 0x000010, "Member 'SceneBodySwitchFunctionLibrary_ChangeSwitch::StateName' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.ChangeSwitchExternal
// 0x0018 (0x0018 - 0x0000)
struct SceneBodySwitchFunctionLibrary_ChangeSwitchExternal final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwitchName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchFunctionLibrary_ChangeSwitchExternal) == 0x000008, "Wrong alignment on SceneBodySwitchFunctionLibrary_ChangeSwitchExternal");
static_assert(sizeof(SceneBodySwitchFunctionLibrary_ChangeSwitchExternal) == 0x000018, "Wrong size on SceneBodySwitchFunctionLibrary_ChangeSwitchExternal");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_ChangeSwitchExternal, Actor) == 0x000000, "Member 'SceneBodySwitchFunctionLibrary_ChangeSwitchExternal::Actor' has a wrong offset!");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_ChangeSwitchExternal, SwitchName) == 0x000008, "Member 'SceneBodySwitchFunctionLibrary_ChangeSwitchExternal::SwitchName' has a wrong offset!");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_ChangeSwitchExternal, StateName) == 0x000010, "Member 'SceneBodySwitchFunctionLibrary_ChangeSwitchExternal::StateName' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.EnumerateValidSwitchNames
// 0x0010 (0x0010 - 0x0000)
struct SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames final
{
public:
	TArray<class FName>                           Names;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames) == 0x000008, "Wrong alignment on SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames");
static_assert(sizeof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames) == 0x000010, "Wrong size on SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames, Names) == 0x000000, "Member 'SceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames::Names' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.EnumerateValidSwitchStateNames
// 0x0018 (0x0018 - 0x0000)
struct SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames final
{
public:
	class FName                                   SwitchName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Names;                                             // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames) == 0x000008, "Wrong alignment on SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames");
static_assert(sizeof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames) == 0x000018, "Wrong size on SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames, SwitchName) == 0x000000, "Member 'SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames::SwitchName' has a wrong offset!");
static_assert(offsetof(SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames, Names) == 0x000008, "Member 'SceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames::Names' has a wrong offset!");

// Function GbxGameSystemCore.GbxCondition_Blueprint.EvaluateCondition
// 0x0018 (0x0018 - 0x0000)
struct GbxCondition_Blueprint_EvaluateCondition final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalContext;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxCondition_Blueprint_EvaluateCondition) == 0x000008, "Wrong alignment on GbxCondition_Blueprint_EvaluateCondition");
static_assert(sizeof(GbxCondition_Blueprint_EvaluateCondition) == 0x000018, "Wrong size on GbxCondition_Blueprint_EvaluateCondition");
static_assert(offsetof(GbxCondition_Blueprint_EvaluateCondition, Context) == 0x000000, "Member 'GbxCondition_Blueprint_EvaluateCondition::Context' has a wrong offset!");
static_assert(offsetof(GbxCondition_Blueprint_EvaluateCondition, OptionalContext) == 0x000008, "Member 'GbxCondition_Blueprint_EvaluateCondition::OptionalContext' has a wrong offset!");
static_assert(offsetof(GbxCondition_Blueprint_EvaluateCondition, ReturnValue) == 0x000010, "Member 'GbxCondition_Blueprint_EvaluateCondition::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.UserStatesInterface.BlueprintStateHandler
// 0x0001 (0x0001 - 0x0000)
struct UserStatesInterface_BlueprintStateHandler final
{
public:
	bool                                          bFromLoad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserStatesInterface_BlueprintStateHandler) == 0x000001, "Wrong alignment on UserStatesInterface_BlueprintStateHandler");
static_assert(sizeof(UserStatesInterface_BlueprintStateHandler) == 0x000001, "Wrong size on UserStatesInterface_BlueprintStateHandler");
static_assert(offsetof(UserStatesInterface_BlueprintStateHandler, bFromLoad) == 0x000000, "Member 'UserStatesInterface_BlueprintStateHandler::bFromLoad' has a wrong offset!");

// Function GbxGameSystemCore.UserStatesInterface.HasEnableConditionsSetForAnyUserState
// 0x0001 (0x0001 - 0x0000)
struct UserStatesInterface_HasEnableConditionsSetForAnyUserState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UserStatesInterface_HasEnableConditionsSetForAnyUserState) == 0x000001, "Wrong alignment on UserStatesInterface_HasEnableConditionsSetForAnyUserState");
static_assert(sizeof(UserStatesInterface_HasEnableConditionsSetForAnyUserState) == 0x000001, "Wrong size on UserStatesInterface_HasEnableConditionsSetForAnyUserState");
static_assert(offsetof(UserStatesInterface_HasEnableConditionsSetForAnyUserState, ReturnValue) == 0x000000, "Member 'UserStatesInterface_HasEnableConditionsSetForAnyUserState::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCondition_List.GetRequiredInterface
// 0x0008 (0x0008 - 0x0000)
struct GbxCondition_List_GetRequiredInterface final
{
public:
	class UClass*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCondition_List_GetRequiredInterface) == 0x000008, "Wrong alignment on GbxCondition_List_GetRequiredInterface");
static_assert(sizeof(GbxCondition_List_GetRequiredInterface) == 0x000008, "Wrong size on GbxCondition_List_GetRequiredInterface");
static_assert(offsetof(GbxCondition_List_GetRequiredInterface, ReturnValue) == 0x000000, "Member 'GbxCondition_List_GetRequiredInterface::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxCondition_List.RequiresNativeClass
// 0x0001 (0x0001 - 0x0000)
struct GbxCondition_List_RequiresNativeClass final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxCondition_List_RequiresNativeClass) == 0x000001, "Wrong alignment on GbxCondition_List_RequiresNativeClass");
static_assert(sizeof(GbxCondition_List_RequiresNativeClass) == 0x000001, "Wrong size on GbxCondition_List_RequiresNativeClass");
static_assert(offsetof(GbxCondition_List_RequiresNativeClass, ReturnValue) == 0x000000, "Member 'GbxCondition_List_RequiresNativeClass::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.FindActorTargetingComponent
// 0x0010 (0x0010 - 0x0000)
struct TargetActorInfoLibrary_FindActorTargetingComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetingComponent*                    ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetActorInfoLibrary_FindActorTargetingComponent) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_FindActorTargetingComponent");
static_assert(sizeof(TargetActorInfoLibrary_FindActorTargetingComponent) == 0x000010, "Wrong size on TargetActorInfoLibrary_FindActorTargetingComponent");
static_assert(offsetof(TargetActorInfoLibrary_FindActorTargetingComponent, Actor) == 0x000000, "Member 'TargetActorInfoLibrary_FindActorTargetingComponent::Actor' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_FindActorTargetingComponent, ReturnValue) == 0x000008, "Member 'TargetActorInfoLibrary_FindActorTargetingComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestAttackLocation
// 0x03A8 (0x03A8 - 0x0000)
struct TargetActorInfoLibrary_GetBestAttackLocation final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                OutTargetVelocity;                                 // 0x0390(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x039C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetActorInfoLibrary_GetBestAttackLocation) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_GetBestAttackLocation");
static_assert(sizeof(TargetActorInfoLibrary_GetBestAttackLocation) == 0x0003A8, "Wrong size on TargetActorInfoLibrary_GetBestAttackLocation");
static_assert(offsetof(TargetActorInfoLibrary_GetBestAttackLocation, Info) == 0x000000, "Member 'TargetActorInfoLibrary_GetBestAttackLocation::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetBestAttackLocation, OutTargetVelocity) == 0x000390, "Member 'TargetActorInfoLibrary_GetBestAttackLocation::OutTargetVelocity' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetBestAttackLocation, ReturnValue) == 0x00039C, "Member 'TargetActorInfoLibrary_GetBestAttackLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestStimulus
// 0x0400 (0x0400 - 0x0000)
struct TargetActorInfoLibrary_GetBestStimulus final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIStimulus                            Stimulus;                                          // 0x0390(0x0068)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x03F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_GetBestStimulus) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_GetBestStimulus");
static_assert(sizeof(TargetActorInfoLibrary_GetBestStimulus) == 0x000400, "Wrong size on TargetActorInfoLibrary_GetBestStimulus");
static_assert(offsetof(TargetActorInfoLibrary_GetBestStimulus, Info) == 0x000000, "Member 'TargetActorInfoLibrary_GetBestStimulus::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetBestStimulus, Stimulus) == 0x000390, "Member 'TargetActorInfoLibrary_GetBestStimulus::Stimulus' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetBestStimulus, ReturnValue) == 0x0003F8, "Member 'TargetActorInfoLibrary_GetBestStimulus::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestStimulusLocation
// 0x03A0 (0x03A0 - 0x0000)
struct TargetActorInfoLibrary_GetBestStimulusLocation final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Age;                                               // 0x0390(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0394(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetActorInfoLibrary_GetBestStimulusLocation) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_GetBestStimulusLocation");
static_assert(sizeof(TargetActorInfoLibrary_GetBestStimulusLocation) == 0x0003A0, "Wrong size on TargetActorInfoLibrary_GetBestStimulusLocation");
static_assert(offsetof(TargetActorInfoLibrary_GetBestStimulusLocation, Info) == 0x000000, "Member 'TargetActorInfoLibrary_GetBestStimulusLocation::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetBestStimulusLocation, Age) == 0x000390, "Member 'TargetActorInfoLibrary_GetBestStimulusLocation::Age' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetBestStimulusLocation, ReturnValue) == 0x000394, "Member 'TargetActorInfoLibrary_GetBestStimulusLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.GetReceiverLocation
// 0x03A8 (0x03A8 - 0x0000)
struct TargetActorInfoLibrary_GetReceiverLocation final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0390(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0398(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_GetReceiverLocation) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_GetReceiverLocation");
static_assert(sizeof(TargetActorInfoLibrary_GetReceiverLocation) == 0x0003A8, "Wrong size on TargetActorInfoLibrary_GetReceiverLocation");
static_assert(offsetof(TargetActorInfoLibrary_GetReceiverLocation, Info) == 0x000000, "Member 'TargetActorInfoLibrary_GetReceiverLocation::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetReceiverLocation, Sense) == 0x000390, "Member 'TargetActorInfoLibrary_GetReceiverLocation::Sense' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetReceiverLocation, ReturnValue) == 0x000398, "Member 'TargetActorInfoLibrary_GetReceiverLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.GetStimulusForSense
// 0x0408 (0x0408 - 0x0000)
struct TargetActorInfoLibrary_GetStimulusForSense final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0390(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIStimulus                            Stimulus;                                          // 0x0398(0x0068)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0400(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_GetStimulusForSense) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_GetStimulusForSense");
static_assert(sizeof(TargetActorInfoLibrary_GetStimulusForSense) == 0x000408, "Wrong size on TargetActorInfoLibrary_GetStimulusForSense");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusForSense, Info) == 0x000000, "Member 'TargetActorInfoLibrary_GetStimulusForSense::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusForSense, Sense) == 0x000390, "Member 'TargetActorInfoLibrary_GetStimulusForSense::Sense' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusForSense, Stimulus) == 0x000398, "Member 'TargetActorInfoLibrary_GetStimulusForSense::Stimulus' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusForSense, ReturnValue) == 0x000400, "Member 'TargetActorInfoLibrary_GetStimulusForSense::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.GetStimulusLocation
// 0x03A8 (0x03A8 - 0x0000)
struct TargetActorInfoLibrary_GetStimulusLocation final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0390(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0398(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_GetStimulusLocation) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_GetStimulusLocation");
static_assert(sizeof(TargetActorInfoLibrary_GetStimulusLocation) == 0x0003A8, "Wrong size on TargetActorInfoLibrary_GetStimulusLocation");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusLocation, Info) == 0x000000, "Member 'TargetActorInfoLibrary_GetStimulusLocation::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusLocation, Sense) == 0x000390, "Member 'TargetActorInfoLibrary_GetStimulusLocation::Sense' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_GetStimulusLocation, ReturnValue) == 0x000398, "Member 'TargetActorInfoLibrary_GetStimulusLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.HasAnyKnownStimuli
// 0x0398 (0x0398 - 0x0000)
struct TargetActorInfoLibrary_HasAnyKnownStimuli final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0390(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_HasAnyKnownStimuli) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_HasAnyKnownStimuli");
static_assert(sizeof(TargetActorInfoLibrary_HasAnyKnownStimuli) == 0x000398, "Wrong size on TargetActorInfoLibrary_HasAnyKnownStimuli");
static_assert(offsetof(TargetActorInfoLibrary_HasAnyKnownStimuli, Info) == 0x000000, "Member 'TargetActorInfoLibrary_HasAnyKnownStimuli::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_HasAnyKnownStimuli, ReturnValue) == 0x000390, "Member 'TargetActorInfoLibrary_HasAnyKnownStimuli::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.HasStimulusForSense
// 0x03A0 (0x03A0 - 0x0000)
struct TargetActorInfoLibrary_HasStimulusForSense final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0390(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0398(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_HasStimulusForSense) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_HasStimulusForSense");
static_assert(sizeof(TargetActorInfoLibrary_HasStimulusForSense) == 0x0003A0, "Wrong size on TargetActorInfoLibrary_HasStimulusForSense");
static_assert(offsetof(TargetActorInfoLibrary_HasStimulusForSense, Info) == 0x000000, "Member 'TargetActorInfoLibrary_HasStimulusForSense::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_HasStimulusForSense, Sense) == 0x000390, "Member 'TargetActorInfoLibrary_HasStimulusForSense::Sense' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_HasStimulusForSense, ReturnValue) == 0x000398, "Member 'TargetActorInfoLibrary_HasStimulusForSense::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.IsDirectlySensed
// 0x0398 (0x0398 - 0x0000)
struct TargetActorInfoLibrary_IsDirectlySensed final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0390(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_IsDirectlySensed) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_IsDirectlySensed");
static_assert(sizeof(TargetActorInfoLibrary_IsDirectlySensed) == 0x000398, "Wrong size on TargetActorInfoLibrary_IsDirectlySensed");
static_assert(offsetof(TargetActorInfoLibrary_IsDirectlySensed, Info) == 0x000000, "Member 'TargetActorInfoLibrary_IsDirectlySensed::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_IsDirectlySensed, ReturnValue) == 0x000390, "Member 'TargetActorInfoLibrary_IsDirectlySensed::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.IsExistingTarget
// 0x0398 (0x0398 - 0x0000)
struct TargetActorInfoLibrary_IsExistingTarget final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0390(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_IsExistingTarget) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_IsExistingTarget");
static_assert(sizeof(TargetActorInfoLibrary_IsExistingTarget) == 0x000398, "Wrong size on TargetActorInfoLibrary_IsExistingTarget");
static_assert(offsetof(TargetActorInfoLibrary_IsExistingTarget, Info) == 0x000000, "Member 'TargetActorInfoLibrary_IsExistingTarget::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_IsExistingTarget, ReturnValue) == 0x000390, "Member 'TargetActorInfoLibrary_IsExistingTarget::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetActorInfoLibrary.IsSenseActive
// 0x03A0 (0x03A0 - 0x0000)
struct TargetActorInfoLibrary_IsSenseActive final
{
public:
	struct FTargetActorInfo                       Info;                                              // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0390(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0398(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetActorInfoLibrary_IsSenseActive) == 0x000008, "Wrong alignment on TargetActorInfoLibrary_IsSenseActive");
static_assert(sizeof(TargetActorInfoLibrary_IsSenseActive) == 0x0003A0, "Wrong size on TargetActorInfoLibrary_IsSenseActive");
static_assert(offsetof(TargetActorInfoLibrary_IsSenseActive, Info) == 0x000000, "Member 'TargetActorInfoLibrary_IsSenseActive::Info' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_IsSenseActive, Sense) == 0x000390, "Member 'TargetActorInfoLibrary_IsSenseActive::Sense' has a wrong offset!");
static_assert(offsetof(TargetActorInfoLibrary_IsSenseActive, ReturnValue) == 0x000398, "Member 'TargetActorInfoLibrary_IsSenseActive::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxDataTableFunctionLibrary.Conv_DataTableValueHandleToString
// 0x0028 (0x0028 - 0x0000)
struct GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString final
{
public:
	struct FDataTableValueHandle                  ValueHandle;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString) == 0x000008, "Wrong alignment on GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString");
static_assert(sizeof(GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString) == 0x000028, "Wrong size on GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString");
static_assert(offsetof(GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString, ValueHandle) == 0x000000, "Member 'GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString::ValueHandle' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString, ReturnValue) == 0x000018, "Member 'GbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxDataTableFunctionLibrary.GetDataTableValue
// 0x0028 (0x0028 - 0x0000)
struct GbxDataTableFunctionLibrary_GetDataTableValue final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ValueName;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptStruct*                          ValueInStructType;                                 // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutValue;                                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxDataTableFunctionLibrary_GetDataTableValue) == 0x000008, "Wrong alignment on GbxDataTableFunctionLibrary_GetDataTableValue");
static_assert(sizeof(GbxDataTableFunctionLibrary_GetDataTableValue) == 0x000028, "Wrong size on GbxDataTableFunctionLibrary_GetDataTableValue");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValue, Table) == 0x000000, "Member 'GbxDataTableFunctionLibrary_GetDataTableValue::Table' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValue, RowName) == 0x000008, "Member 'GbxDataTableFunctionLibrary_GetDataTableValue::RowName' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValue, ValueName) == 0x000010, "Member 'GbxDataTableFunctionLibrary_GetDataTableValue::ValueName' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValue, ValueInStructType) == 0x000018, "Member 'GbxDataTableFunctionLibrary_GetDataTableValue::ValueInStructType' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValue, OutValue) == 0x000020, "Member 'GbxDataTableFunctionLibrary_GetDataTableValue::OutValue' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValue, ReturnValue) == 0x000024, "Member 'GbxDataTableFunctionLibrary_GetDataTableValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxDataTableFunctionLibrary.GetDataTableValueFromHandle
// 0x0028 (0x0028 - 0x0000)
struct GbxDataTableFunctionLibrary_GetDataTableValueFromHandle final
{
public:
	struct FDataTableValueHandle                  ValueHandle;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxDataTableFunctionLibrary_GetDataTableValueFromHandle) == 0x000008, "Wrong alignment on GbxDataTableFunctionLibrary_GetDataTableValueFromHandle");
static_assert(sizeof(GbxDataTableFunctionLibrary_GetDataTableValueFromHandle) == 0x000028, "Wrong size on GbxDataTableFunctionLibrary_GetDataTableValueFromHandle");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValueFromHandle, ValueHandle) == 0x000000, "Member 'GbxDataTableFunctionLibrary_GetDataTableValueFromHandle::ValueHandle' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValueFromHandle, ContextSource) == 0x000018, "Member 'GbxDataTableFunctionLibrary_GetDataTableValueFromHandle::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValueFromHandle, DefaultValue) == 0x000020, "Member 'GbxDataTableFunctionLibrary_GetDataTableValueFromHandle::DefaultValue' has a wrong offset!");
static_assert(offsetof(GbxDataTableFunctionLibrary_GetDataTableValueFromHandle, ReturnValue) == 0x000024, "Member 'GbxDataTableFunctionLibrary_GetDataTableValueFromHandle::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxEqsRenderingComponent.GetAvailableEnvQueryParamRefNames
// 0x0010 (0x0010 - 0x0000)
struct GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames final
{
public:
	TArray<class FString>                         Names;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames) == 0x000008, "Wrong alignment on GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames");
static_assert(sizeof(GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames) == 0x000010, "Wrong size on GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames");
static_assert(offsetof(GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames, Names) == 0x000000, "Member 'GbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames::Names' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataFalseFor
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagDataFalseFor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagDataFalseFor) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagDataFalseFor");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagDataFalseFor) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagDataFalseFor");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseFor, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagDataFalseFor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseFor, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagDataFalseFor::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseFor, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_FlagDataFalseFor::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseFor, CheckTime) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagDataFalseFor::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseFor, ReturnValue) == 0x00001C, "Member 'GbxFlagFunctionLibrary_FlagDataFalseFor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataFalseWithin
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagDataFalseWithin final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagDataFalseWithin) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagDataFalseWithin");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagDataFalseWithin) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagDataFalseWithin");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseWithin, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagDataFalseWithin::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseWithin, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagDataFalseWithin::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseWithin, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_FlagDataFalseWithin::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseWithin, CheckTime) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagDataFalseWithin::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataFalseWithin, ReturnValue) == 0x00001C, "Member 'GbxFlagFunctionLibrary_FlagDataFalseWithin::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataTrueFor
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagDataTrueFor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagDataTrueFor) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagDataTrueFor");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagDataTrueFor) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagDataTrueFor");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueFor, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagDataTrueFor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueFor, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagDataTrueFor::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueFor, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_FlagDataTrueFor::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueFor, CheckTime) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagDataTrueFor::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueFor, ReturnValue) == 0x00001C, "Member 'GbxFlagFunctionLibrary_FlagDataTrueFor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataTrueWithin
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagDataTrueWithin final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagDataTrueWithin) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagDataTrueWithin");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagDataTrueWithin) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagDataTrueWithin");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueWithin, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagDataTrueWithin::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueWithin, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagDataTrueWithin::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueWithin, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_FlagDataTrueWithin::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueWithin, CheckTime) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagDataTrueWithin::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagDataTrueWithin, ReturnValue) == 0x00001C, "Member 'GbxFlagFunctionLibrary_FlagDataTrueWithin::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagFalseFor
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagFalseFor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagFalseFor) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagFalseFor");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagFalseFor) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagFalseFor");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseFor, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagFalseFor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseFor, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagFalseFor::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseFor, CheckTime) == 0x000014, "Member 'GbxFlagFunctionLibrary_FlagFalseFor::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseFor, ReturnValue) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagFalseFor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagFalseWithin
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagFalseWithin final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagFalseWithin) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagFalseWithin");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagFalseWithin) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagFalseWithin");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseWithin, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagFalseWithin::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseWithin, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagFalseWithin::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseWithin, CheckTime) == 0x000014, "Member 'GbxFlagFunctionLibrary_FlagFalseWithin::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagFalseWithin, ReturnValue) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagFalseWithin::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagTrueFor
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagTrueFor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagTrueFor) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagTrueFor");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagTrueFor) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagTrueFor");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueFor, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagTrueFor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueFor, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagTrueFor::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueFor, CheckTime) == 0x000014, "Member 'GbxFlagFunctionLibrary_FlagTrueFor::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueFor, ReturnValue) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagTrueFor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagTrueWithin
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_FlagTrueWithin final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CheckTime;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_FlagTrueWithin) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_FlagTrueWithin");
static_assert(sizeof(GbxFlagFunctionLibrary_FlagTrueWithin) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_FlagTrueWithin");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueWithin, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_FlagTrueWithin::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueWithin, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_FlagTrueWithin::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueWithin, CheckTime) == 0x000014, "Member 'GbxFlagFunctionLibrary_FlagTrueWithin::CheckTime' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_FlagTrueWithin, ReturnValue) == 0x000018, "Member 'GbxFlagFunctionLibrary_FlagTrueWithin::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.GetFlagDataValue
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_GetFlagDataValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_GetFlagDataValue) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_GetFlagDataValue");
static_assert(sizeof(GbxFlagFunctionLibrary_GetFlagDataValue) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_GetFlagDataValue");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagDataValue, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_GetFlagDataValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagDataValue, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_GetFlagDataValue::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagDataValue, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_GetFlagDataValue::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagDataValue, ReturnValue) == 0x000018, "Member 'GbxFlagFunctionLibrary_GetFlagDataValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.GetFlagValue
// 0x0018 (0x0018 - 0x0000)
struct GbxFlagFunctionLibrary_GetFlagValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_GetFlagValue) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_GetFlagValue");
static_assert(sizeof(GbxFlagFunctionLibrary_GetFlagValue) == 0x000018, "Wrong size on GbxFlagFunctionLibrary_GetFlagValue");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagValue, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_GetFlagValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagValue, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_GetFlagValue::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_GetFlagValue, ReturnValue) == 0x000014, "Member 'GbxFlagFunctionLibrary_GetFlagValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagDataTrueTimed
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_SetFlagDataTrueTimed final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_SetFlagDataTrueTimed) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_SetFlagDataTrueTimed");
static_assert(sizeof(GbxFlagFunctionLibrary_SetFlagDataTrueTimed) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_SetFlagDataTrueTimed");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataTrueTimed, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_SetFlagDataTrueTimed::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataTrueTimed, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_SetFlagDataTrueTimed::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataTrueTimed, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_SetFlagDataTrueTimed::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataTrueTimed, Duration) == 0x000018, "Member 'GbxFlagFunctionLibrary_SetFlagDataTrueTimed::Duration' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagDataValue
// 0x0020 (0x0020 - 0x0000)
struct GbxFlagFunctionLibrary_SetFlagDataValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UGbxFlagData*                     FlagData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextSource;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewValue;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_SetFlagDataValue) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_SetFlagDataValue");
static_assert(sizeof(GbxFlagFunctionLibrary_SetFlagDataValue) == 0x000020, "Wrong size on GbxFlagFunctionLibrary_SetFlagDataValue");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataValue, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_SetFlagDataValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataValue, FlagData) == 0x000008, "Member 'GbxFlagFunctionLibrary_SetFlagDataValue::FlagData' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataValue, ContextSource) == 0x000010, "Member 'GbxFlagFunctionLibrary_SetFlagDataValue::ContextSource' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagDataValue, bNewValue) == 0x000018, "Member 'GbxFlagFunctionLibrary_SetFlagDataValue::bNewValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagTrueTimed
// 0x0018 (0x0018 - 0x0000)
struct GbxFlagFunctionLibrary_SetFlagTrueTimed final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxFlagFunctionLibrary_SetFlagTrueTimed) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_SetFlagTrueTimed");
static_assert(sizeof(GbxFlagFunctionLibrary_SetFlagTrueTimed) == 0x000018, "Wrong size on GbxFlagFunctionLibrary_SetFlagTrueTimed");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagTrueTimed, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_SetFlagTrueTimed::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagTrueTimed, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_SetFlagTrueTimed::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagTrueTimed, Duration) == 0x000014, "Member 'GbxFlagFunctionLibrary_SetFlagTrueTimed::Duration' has a wrong offset!");

// Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagValue
// 0x0018 (0x0018 - 0x0000)
struct GbxFlagFunctionLibrary_SetFlagValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFlag                               Flag;                                              // 0x0008(0x000C)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNewValue;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxFlagFunctionLibrary_SetFlagValue) == 0x000008, "Wrong alignment on GbxFlagFunctionLibrary_SetFlagValue");
static_assert(sizeof(GbxFlagFunctionLibrary_SetFlagValue) == 0x000018, "Wrong size on GbxFlagFunctionLibrary_SetFlagValue");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagValue, WorldContextObject) == 0x000000, "Member 'GbxFlagFunctionLibrary_SetFlagValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagValue, Flag) == 0x000008, "Member 'GbxFlagFunctionLibrary_SetFlagValue::Flag' has a wrong offset!");
static_assert(offsetof(GbxFlagFunctionLibrary_SetFlagValue, bNewValue) == 0x000014, "Member 'GbxFlagFunctionLibrary_SetFlagValue::bNewValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.AlignTransformToSurface
// 0x0070 (0x0070 - 0x0000)
struct GbxGameplayStatics_AlignTransformToSurface final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SurfaceNormal;                                     // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0040(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameplayStatics_AlignTransformToSurface) == 0x000010, "Wrong alignment on GbxGameplayStatics_AlignTransformToSurface");
static_assert(sizeof(GbxGameplayStatics_AlignTransformToSurface) == 0x000070, "Wrong size on GbxGameplayStatics_AlignTransformToSurface");
static_assert(offsetof(GbxGameplayStatics_AlignTransformToSurface, Transform) == 0x000000, "Member 'GbxGameplayStatics_AlignTransformToSurface::Transform' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_AlignTransformToSurface, SurfaceNormal) == 0x000030, "Member 'GbxGameplayStatics_AlignTransformToSurface::SurfaceNormal' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_AlignTransformToSurface, ReturnValue) == 0x000040, "Member 'GbxGameplayStatics_AlignTransformToSurface::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.GetAssociatedPrimaryCharacter
// 0x0010 (0x0010 - 0x0000)
struct GbxGameplayStatics_GetAssociatedPrimaryCharacter final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxCharacter*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameplayStatics_GetAssociatedPrimaryCharacter) == 0x000008, "Wrong alignment on GbxGameplayStatics_GetAssociatedPrimaryCharacter");
static_assert(sizeof(GbxGameplayStatics_GetAssociatedPrimaryCharacter) == 0x000010, "Wrong size on GbxGameplayStatics_GetAssociatedPrimaryCharacter");
static_assert(offsetof(GbxGameplayStatics_GetAssociatedPrimaryCharacter, Actor) == 0x000000, "Member 'GbxGameplayStatics_GetAssociatedPrimaryCharacter::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_GetAssociatedPrimaryCharacter, ReturnValue) == 0x000008, "Member 'GbxGameplayStatics_GetAssociatedPrimaryCharacter::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.GetPrimaryPlayerController
// 0x0010 (0x0010 - 0x0000)
struct GbxGameplayStatics_GetPrimaryPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameplayStatics_GetPrimaryPlayerController) == 0x000008, "Wrong alignment on GbxGameplayStatics_GetPrimaryPlayerController");
static_assert(sizeof(GbxGameplayStatics_GetPrimaryPlayerController) == 0x000010, "Wrong size on GbxGameplayStatics_GetPrimaryPlayerController");
static_assert(offsetof(GbxGameplayStatics_GetPrimaryPlayerController, WorldContextObject) == 0x000000, "Member 'GbxGameplayStatics_GetPrimaryPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_GetPrimaryPlayerController, ReturnValue) == 0x000008, "Member 'GbxGameplayStatics_GetPrimaryPlayerController::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.ProjectFromQueryToSimulation
// 0x0028 (0x0028 - 0x0000)
struct GbxGameplayStatics_ProjectFromQueryToSimulation final
{
public:
	const class UGbxSkeletalMeshComponent*        Component;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyName;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InOutHitPoint;                                     // 0x0010(0x000C)(Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InOutHitNormal;                                    // 0x001C(0x000C)(Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameplayStatics_ProjectFromQueryToSimulation) == 0x000008, "Wrong alignment on GbxGameplayStatics_ProjectFromQueryToSimulation");
static_assert(sizeof(GbxGameplayStatics_ProjectFromQueryToSimulation) == 0x000028, "Wrong size on GbxGameplayStatics_ProjectFromQueryToSimulation");
static_assert(offsetof(GbxGameplayStatics_ProjectFromQueryToSimulation, Component) == 0x000000, "Member 'GbxGameplayStatics_ProjectFromQueryToSimulation::Component' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_ProjectFromQueryToSimulation, BodyName) == 0x000008, "Member 'GbxGameplayStatics_ProjectFromQueryToSimulation::BodyName' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_ProjectFromQueryToSimulation, InOutHitPoint) == 0x000010, "Member 'GbxGameplayStatics_ProjectFromQueryToSimulation::InOutHitPoint' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_ProjectFromQueryToSimulation, InOutHitNormal) == 0x00001C, "Member 'GbxGameplayStatics_ProjectFromQueryToSimulation::InOutHitNormal' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionChannel
// 0x0010 (0x0010 - 0x0000)
struct GbxGameplayStatics_SetComponentTeamCollisionChannel final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamCollisionChannel                         Channel;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOn;                                               // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetComponentTeamCollisionChannel) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetComponentTeamCollisionChannel");
static_assert(sizeof(GbxGameplayStatics_SetComponentTeamCollisionChannel) == 0x000010, "Wrong size on GbxGameplayStatics_SetComponentTeamCollisionChannel");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionChannel, Component) == 0x000000, "Member 'GbxGameplayStatics_SetComponentTeamCollisionChannel::Component' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionChannel, Channel) == 0x000008, "Member 'GbxGameplayStatics_SetComponentTeamCollisionChannel::Channel' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionChannel, bOn) == 0x000009, "Member 'GbxGameplayStatics_SetComponentTeamCollisionChannel::bOn' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionChannel, bPropagateToChildren) == 0x00000A, "Member 'GbxGameplayStatics_SetComponentTeamCollisionChannel::bPropagateToChildren' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionResponseToChannel
// 0x0010 (0x0010 - 0x0000)
struct GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamCollisionChannel                         Channel;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnore;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel");
static_assert(sizeof(GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel) == 0x000010, "Wrong size on GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel, Component) == 0x000000, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel::Component' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel, Channel) == 0x000008, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel::Channel' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel, bIgnore) == 0x000009, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel::bIgnore' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel, bPropagateToChildren) == 0x00000A, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseToChannel::bPropagateToChildren' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionResponseWith
// 0x0018 (0x0018 - 0x0000)
struct GbxGameplayStatics_SetComponentTeamCollisionResponseWith final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TeamActor;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnore;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetComponentTeamCollisionResponseWith) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetComponentTeamCollisionResponseWith");
static_assert(sizeof(GbxGameplayStatics_SetComponentTeamCollisionResponseWith) == 0x000018, "Wrong size on GbxGameplayStatics_SetComponentTeamCollisionResponseWith");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseWith, Component) == 0x000000, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseWith::Component' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseWith, TeamActor) == 0x000008, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseWith::TeamActor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseWith, bIgnore) == 0x000010, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseWith::bIgnore' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetComponentTeamCollisionResponseWith, bPropagateToChildren) == 0x000011, "Member 'GbxGameplayStatics_SetComponentTeamCollisionResponseWith::bPropagateToChildren' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetPlayerMaster
// 0x0018 (0x0018 - 0x0000)
struct GbxGameplayStatics_SetPlayerMaster final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PlayerMaster;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetPlayerMaster) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetPlayerMaster");
static_assert(sizeof(GbxGameplayStatics_SetPlayerMaster) == 0x000018, "Wrong size on GbxGameplayStatics_SetPlayerMaster");
static_assert(offsetof(GbxGameplayStatics_SetPlayerMaster, AIActor) == 0x000000, "Member 'GbxGameplayStatics_SetPlayerMaster::AIActor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetPlayerMaster, PlayerMaster) == 0x000008, "Member 'GbxGameplayStatics_SetPlayerMaster::PlayerMaster' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetPlayerMaster, ReturnValue) == 0x000010, "Member 'GbxGameplayStatics_SetPlayerMaster::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionChannel
// 0x0010 (0x0010 - 0x0000)
struct GbxGameplayStatics_SetTeamCollisionChannel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamCollisionChannel                         Channel;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOn;                                               // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetTeamCollisionChannel) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetTeamCollisionChannel");
static_assert(sizeof(GbxGameplayStatics_SetTeamCollisionChannel) == 0x000010, "Wrong size on GbxGameplayStatics_SetTeamCollisionChannel");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionChannel, Actor) == 0x000000, "Member 'GbxGameplayStatics_SetTeamCollisionChannel::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionChannel, Channel) == 0x000008, "Member 'GbxGameplayStatics_SetTeamCollisionChannel::Channel' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionChannel, bOn) == 0x000009, "Member 'GbxGameplayStatics_SetTeamCollisionChannel::bOn' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionChannelFrom
// 0x0018 (0x0018 - 0x0000)
struct GbxGameplayStatics_SetTeamCollisionChannelFrom final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TeamActor;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOn;                                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetTeamCollisionChannelFrom) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetTeamCollisionChannelFrom");
static_assert(sizeof(GbxGameplayStatics_SetTeamCollisionChannelFrom) == 0x000018, "Wrong size on GbxGameplayStatics_SetTeamCollisionChannelFrom");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionChannelFrom, Actor) == 0x000000, "Member 'GbxGameplayStatics_SetTeamCollisionChannelFrom::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionChannelFrom, TeamActor) == 0x000008, "Member 'GbxGameplayStatics_SetTeamCollisionChannelFrom::TeamActor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionChannelFrom, bOn) == 0x000010, "Member 'GbxGameplayStatics_SetTeamCollisionChannelFrom::bOn' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionResponseToChannel
// 0x0010 (0x0010 - 0x0000)
struct GbxGameplayStatics_SetTeamCollisionResponseToChannel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamCollisionChannel                         Channel;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnore;                                           // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetTeamCollisionResponseToChannel) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetTeamCollisionResponseToChannel");
static_assert(sizeof(GbxGameplayStatics_SetTeamCollisionResponseToChannel) == 0x000010, "Wrong size on GbxGameplayStatics_SetTeamCollisionResponseToChannel");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionResponseToChannel, Actor) == 0x000000, "Member 'GbxGameplayStatics_SetTeamCollisionResponseToChannel::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionResponseToChannel, Channel) == 0x000008, "Member 'GbxGameplayStatics_SetTeamCollisionResponseToChannel::Channel' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionResponseToChannel, bIgnore) == 0x000009, "Member 'GbxGameplayStatics_SetTeamCollisionResponseToChannel::bIgnore' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionResponseWith
// 0x0018 (0x0018 - 0x0000)
struct GbxGameplayStatics_SetTeamCollisionResponseWith final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TeamActor;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnore;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameplayStatics_SetTeamCollisionResponseWith) == 0x000008, "Wrong alignment on GbxGameplayStatics_SetTeamCollisionResponseWith");
static_assert(sizeof(GbxGameplayStatics_SetTeamCollisionResponseWith) == 0x000018, "Wrong size on GbxGameplayStatics_SetTeamCollisionResponseWith");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionResponseWith, Actor) == 0x000000, "Member 'GbxGameplayStatics_SetTeamCollisionResponseWith::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionResponseWith, TeamActor) == 0x000008, "Member 'GbxGameplayStatics_SetTeamCollisionResponseWith::TeamActor' has a wrong offset!");
static_assert(offsetof(GbxGameplayStatics_SetTeamCollisionResponseWith, bIgnore) == 0x000010, "Member 'GbxGameplayStatics_SetTeamCollisionResponseWith::bIgnore' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.DecrementStat
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_DecrementStat final
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_DecrementStat) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_DecrementStat");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_DecrementStat) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_DecrementStat");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_DecrementStat, ContextActor) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_DecrementStat::ContextActor' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_DecrementStat, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_DecrementStat::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_DecrementStat, Amount) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_DecrementStat::Amount' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.DecrementStatForParty
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_DecrementStatForParty final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_DecrementStatForParty) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_DecrementStatForParty");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_DecrementStatForParty) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_DecrementStatForParty");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_DecrementStatForParty, WorldContextObject) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_DecrementStatForParty::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_DecrementStatForParty, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_DecrementStatForParty::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_DecrementStatForParty, Amount) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_DecrementStatForParty::Amount' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.GetStatValue
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_GetStatValue final
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_GetStatValue) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_GetStatValue");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_GetStatValue) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_GetStatValue");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_GetStatValue, ContextActor) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_GetStatValue::ContextActor' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_GetStatValue, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_GetStatValue::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_GetStatValue, ReturnValue) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_GetStatValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.IncrementStat
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_IncrementStat final
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_IncrementStat) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_IncrementStat");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_IncrementStat) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_IncrementStat");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_IncrementStat, ContextActor) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_IncrementStat::ContextActor' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_IncrementStat, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_IncrementStat::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_IncrementStat, Amount) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_IncrementStat::Amount' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.IncrementStatForParty
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_IncrementStatForParty final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_IncrementStatForParty) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_IncrementStatForParty");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_IncrementStatForParty) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_IncrementStatForParty");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_IncrementStatForParty, WorldContextObject) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_IncrementStatForParty::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_IncrementStatForParty, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_IncrementStatForParty::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_IncrementStatForParty, Amount) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_IncrementStatForParty::Amount' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.UpdateStat
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_UpdateStat final
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewValue;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_UpdateStat) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_UpdateStat");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_UpdateStat) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_UpdateStat");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_UpdateStat, ContextActor) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_UpdateStat::ContextActor' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_UpdateStat, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_UpdateStat::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_UpdateStat, NewValue) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_UpdateStat::NewValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.UpdateStatForParty
// 0x0018 (0x0018 - 0x0000)
struct GbxGameStatsBlueprintLibrary_UpdateStatForParty final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatData;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewValue;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameStatsBlueprintLibrary_UpdateStatForParty) == 0x000008, "Wrong alignment on GbxGameStatsBlueprintLibrary_UpdateStatForParty");
static_assert(sizeof(GbxGameStatsBlueprintLibrary_UpdateStatForParty) == 0x000018, "Wrong size on GbxGameStatsBlueprintLibrary_UpdateStatForParty");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_UpdateStatForParty, WorldContextObject) == 0x000000, "Member 'GbxGameStatsBlueprintLibrary_UpdateStatForParty::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_UpdateStatForParty, StatData) == 0x000008, "Member 'GbxGameStatsBlueprintLibrary_UpdateStatForParty::StatData' has a wrong offset!");
static_assert(offsetof(GbxGameStatsBlueprintLibrary_UpdateStatForParty, NewValue) == 0x000010, "Member 'GbxGameStatsBlueprintLibrary_UpdateStatForParty::NewValue' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.HideScreenParticleForActor
// 0x0020 (0x0020 - 0x0000)
struct ScreenParticleManagerComponent_HideScreenParticleForActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Template;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowParticleToFinish;                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerAuthority;                                  // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreenParticleManagerComponent_HideScreenParticleForActor) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_HideScreenParticleForActor");
static_assert(sizeof(ScreenParticleManagerComponent_HideScreenParticleForActor) == 0x000020, "Wrong size on ScreenParticleManagerComponent_HideScreenParticleForActor");
static_assert(offsetof(ScreenParticleManagerComponent_HideScreenParticleForActor, Actor) == 0x000000, "Member 'ScreenParticleManagerComponent_HideScreenParticleForActor::Actor' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_HideScreenParticleForActor, Template) == 0x000008, "Member 'ScreenParticleManagerComponent_HideScreenParticleForActor::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_HideScreenParticleForActor, Tag) == 0x000010, "Member 'ScreenParticleManagerComponent_HideScreenParticleForActor::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_HideScreenParticleForActor, bAllowParticleToFinish) == 0x000018, "Member 'ScreenParticleManagerComponent_HideScreenParticleForActor::bAllowParticleToFinish' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_HideScreenParticleForActor, bServerAuthority) == 0x000019, "Member 'ScreenParticleManagerComponent_HideScreenParticleForActor::bServerAuthority' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ShowScreenParticleForActor
// 0x0038 (0x0038 - 0x0000)
struct ScreenParticleManagerComponent_ShowScreenParticleForActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Template;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWhenFinished;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ContentDims;                                       // 0x0014(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenParticleScalingMode                    ScalingMode;                                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysVisible;                                    // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleInstances;                           // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerAuthority;                                  // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickEvenWhenPaused;                               // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDuringInGameMenu;                             // 0x0033(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreenParticleManagerComponent_ShowScreenParticleForActor) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ShowScreenParticleForActor");
static_assert(sizeof(ScreenParticleManagerComponent_ShowScreenParticleForActor) == 0x000038, "Wrong size on ScreenParticleManagerComponent_ShowScreenParticleForActor");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, Actor) == 0x000000, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::Actor' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, Template) == 0x000008, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bHideWhenFinished) == 0x000010, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bHideWhenFinished' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, ContentDims) == 0x000014, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::ContentDims' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, ParticleDepth) == 0x00001C, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::ParticleDepth' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, ScalingMode) == 0x000020, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::ScalingMode' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bOnlyOwnerSee) == 0x000021, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bAlwaysVisible) == 0x000022, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bAlwaysVisible' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, Tag) == 0x000028, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bAllowMultipleInstances) == 0x000030, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bAllowMultipleInstances' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bServerAuthority) == 0x000031, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bServerAuthority' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bTickEvenWhenPaused) == 0x000032, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bTickEvenWhenPaused' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ShowScreenParticleForActor, bHideDuringInGameMenu) == 0x000033, "Member 'ScreenParticleManagerComponent_ShowScreenParticleForActor::bHideDuringInGameMenu' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientHideScreenParticle
// 0x0018 (0x0018 - 0x0000)
struct ScreenParticleManagerComponent_ClientHideScreenParticle final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowParticleToFinish;                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreenParticleManagerComponent_ClientHideScreenParticle) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientHideScreenParticle");
static_assert(sizeof(ScreenParticleManagerComponent_ClientHideScreenParticle) == 0x000018, "Wrong size on ScreenParticleManagerComponent_ClientHideScreenParticle");
static_assert(offsetof(ScreenParticleManagerComponent_ClientHideScreenParticle, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientHideScreenParticle::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientHideScreenParticle, Tag) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientHideScreenParticle::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientHideScreenParticle, bAllowParticleToFinish) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientHideScreenParticle::bAllowParticleToFinish' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleActorParameter
// 0x0020 (0x0020 - 0x0000)
struct ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Param;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter");
static_assert(sizeof(ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter) == 0x000020, "Wrong size on ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter, Tag) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter, ParameterName) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter, Param) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleActorParameter::Param' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleColorParameter
// 0x0028 (0x0028 - 0x0000)
struct ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Param;                                             // 0x0018(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter");
static_assert(sizeof(ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter) == 0x000028, "Wrong size on ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter, Tag) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter, ParameterName) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter, Param) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleColorParameter::Param' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleFloatParameter
// 0x0020 (0x0020 - 0x0000)
struct ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter");
static_assert(sizeof(ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter) == 0x000020, "Wrong size on ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter, Tag) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter, ParameterName) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter, Param) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter::Param' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleMaterialParameter
// 0x0020 (0x0020 - 0x0000)
struct ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Param;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter");
static_assert(sizeof(ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter) == 0x000020, "Wrong size on ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter, Tag) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter, ParameterName) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter, Param) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter::Param' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleVectorParameter
// 0x0028 (0x0028 - 0x0000)
struct ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Param;                                             // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter");
static_assert(sizeof(ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter) == 0x000028, "Wrong size on ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter, Tag) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter, ParameterName) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter, Param) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter::Param' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientShowScreenParticle
// 0x0030 (0x0030 - 0x0000)
struct ScreenParticleManagerComponent_ClientShowScreenParticle final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWhenFinished;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ContentDims;                                       // 0x000C(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenParticleScalingMode                    ScalingMode;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysVisible;                                    // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleInstances;                           // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickEvenWhenPaused;                               // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDuringInGameMenu;                             // 0x002A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDepthPriorityWorld;                               // 0x002B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScreenParticleManagerComponent_ClientShowScreenParticle) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientShowScreenParticle");
static_assert(sizeof(ScreenParticleManagerComponent_ClientShowScreenParticle) == 0x000030, "Wrong size on ScreenParticleManagerComponent_ClientShowScreenParticle");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bHideWhenFinished) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bHideWhenFinished' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, ContentDims) == 0x00000C, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::ContentDims' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, ParticleDepth) == 0x000014, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::ParticleDepth' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, ScalingMode) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::ScalingMode' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bOnlyOwnerSee) == 0x000019, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bAlwaysVisible) == 0x00001A, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bAlwaysVisible' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, Tag) == 0x000020, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bAllowMultipleInstances) == 0x000028, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bAllowMultipleInstances' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bTickEvenWhenPaused) == 0x000029, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bTickEvenWhenPaused' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bHideDuringInGameMenu) == 0x00002A, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bHideDuringInGameMenu' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticle, bDepthPriorityWorld) == 0x00002B, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticle::bDepthPriorityWorld' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientShowScreenParticleEx
// 0x0028 (0x0028 - 0x0000)
struct ScreenParticleManagerComponent_ClientShowScreenParticleEx final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InitFlags;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ContentDims;                                       // 0x000C(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenParticleScalingMode                    ScalingMode;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenParticleManagerComponent_ClientShowScreenParticleEx) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientShowScreenParticleEx");
static_assert(sizeof(ScreenParticleManagerComponent_ClientShowScreenParticleEx) == 0x000028, "Wrong size on ScreenParticleManagerComponent_ClientShowScreenParticleEx");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticleEx, Template) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticleEx::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticleEx, InitFlags) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticleEx::InitFlags' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticleEx, ContentDims) == 0x00000C, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticleEx::ContentDims' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticleEx, ParticleDepth) == 0x000014, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticleEx::ParticleDepth' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticleEx, ScalingMode) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticleEx::ScalingMode' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientShowScreenParticleEx, Tag) == 0x000020, "Member 'ScreenParticleManagerComponent_ClientShowScreenParticleEx::Tag' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientTrackParticleProperty
// 0x0038 (0x0038 - 0x0000)
struct ScreenParticleManagerComponent_ClientTrackParticleProperty final
{
public:
	class UParticlePropertyTrackingData*          TrackingData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Template;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PropertyValue;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToValue;                                       // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     UsedMaterialProperty;                              // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialPropertyName;                              // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenParticleManagerComponent_ClientTrackParticleProperty) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_ClientTrackParticleProperty");
static_assert(sizeof(ScreenParticleManagerComponent_ClientTrackParticleProperty) == 0x000038, "Wrong size on ScreenParticleManagerComponent_ClientTrackParticleProperty");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, TrackingData) == 0x000000, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::TrackingData' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, Template) == 0x000008, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::Template' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, Tag) == 0x000010, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::Tag' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, PropertyName) == 0x000018, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, PropertyValue) == 0x000020, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::PropertyValue' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, bAddToValue) == 0x000024, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::bAddToValue' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, UsedMaterialProperty) == 0x000028, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::UsedMaterialProperty' has a wrong offset!");
static_assert(offsetof(ScreenParticleManagerComponent_ClientTrackParticleProperty, MaterialPropertyName) == 0x000030, "Member 'ScreenParticleManagerComponent_ClientTrackParticleProperty::MaterialPropertyName' has a wrong offset!");

// Function GbxGameSystemCore.ScreenParticleManagerComponent.OnScreenParticleFinished
// 0x0008 (0x0008 - 0x0000)
struct ScreenParticleManagerComponent_OnScreenParticleFinished final
{
public:
	class UParticleSystemComponent*               Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScreenParticleManagerComponent_OnScreenParticleFinished) == 0x000008, "Wrong alignment on ScreenParticleManagerComponent_OnScreenParticleFinished");
static_assert(sizeof(ScreenParticleManagerComponent_OnScreenParticleFinished) == 0x000008, "Wrong size on ScreenParticleManagerComponent_OnScreenParticleFinished");
static_assert(offsetof(ScreenParticleManagerComponent_OnScreenParticleFinished, Component) == 0x000000, "Member 'ScreenParticleManagerComponent_OnScreenParticleFinished::Component' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersInVolume
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AVolume*>                        Volumes;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EPlayersInVolumeOutput                        Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume, Volumes) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume::Volumes' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume, Branches) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersOverlappingActor
// 0x0018 (0x0018 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayersOverlappingActorOutput                Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor) == 0x000018, "Wrong size on GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor, Actor) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor, Branches) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersOverlappingActors
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EPlayersOverlappingActorOutput                Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors, Actors) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors::Actors' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors, Branches) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersInVolume
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AVolume*>                        Volumes;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EPlayersInVolumeOutput                        Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume, Volumes) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume::Volumes' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume, Branches) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersOverlappingActor
// 0x0018 (0x0018 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayersOverlappingActorOutput                Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor) == 0x000018, "Wrong size on GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor, Actor) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor, Branches) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersOverlappingActors
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EPlayersOverlappingActorOutput                Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors, Actors) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors::Actors' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors, Branches) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.BranchOnIsAutonomous
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIsAutonomousOuput                            Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous, Branches) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.BranchOnIsPlayer
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIsPlayerExecOutput                           Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer, Branches) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer::Branches' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetActorListTrimmedToBestCluster
// 0x0040 (0x0040 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster final
{
public:
	TArray<class AActor*>                         OutputActors;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ClusterMidpoint;                                   // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         InputActors;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClusterRadius;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreferClusterContainingCurrentTarget;             // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster) == 0x000040, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster, OutputActors) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster::OutputActors' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster, ClusterMidpoint) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster::ClusterMidpoint' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster, InputActors) == 0x000020, "Member 'GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster::InputActors' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster, SourceActor) == 0x000030, "Member 'GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster::SourceActor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster, ClusterRadius) == 0x000038, "Member 'GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster::ClusterRadius' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster, bPreferClusterContainingCurrentTarget) == 0x00003C, "Member 'GbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster::bPreferClusterContainingCurrentTarget' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAllPlayersOverlappingActor
// 0x0018 (0x0018 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor) == 0x000018, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor, Actor) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor, ReturnValue) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAllPlayersOverlappingActors
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors, Actors) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors::Actors' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors, ReturnValue) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAnyPlayersOverlappingActor
// 0x0018 (0x0018 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor) == 0x000018, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor, Actor) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor, ReturnValue) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAnyPlayersOverlappingActors
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors, Actors) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors::Actors' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors, ReturnValue) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetCurveFloatValue
// 0x0080 (0x0080 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue final
{
public:
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x007C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue) == 0x000080, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue, Curve) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue::Curve' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue, InTime) == 0x000078, "Member 'GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue::InTime' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue, ReturnValue) == 0x00007C, "Member 'GbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetRelativeDirection
// 0x0088 (0x0088 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection final
{
public:
	struct FRelativeDirectionData                 RelativeDirectionData;                             // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DefaultDirection;                                  // 0x0050(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceActor;                                       // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceSocketName;                                  // 0x0068(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0070(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0078(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection) == 0x000088, "Wrong size on GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection, RelativeDirectionData) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection::RelativeDirectionData' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection, DefaultDirection) == 0x000050, "Member 'GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection::DefaultDirection' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection, SourceActor) == 0x000060, "Member 'GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection::SourceActor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection, SourceSocketName) == 0x000068, "Member 'GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection::SourceSocketName' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection, TargetActor) == 0x000070, "Member 'GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection::TargetActor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection, ReturnValue) == 0x000078, "Member 'GbxGameSystemCoreBlueprintLibrary_GetRelativeDirection::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.HoverComponentAtActor
// 0x0040 (0x0040 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Altitude;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0028(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor) == 0x000040, "Wrong size on GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, Component) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::Component' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, TargetActor) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::TargetActor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, Altitude) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::Altitude' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, Radius) == 0x000014, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::Radius' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, AccelerationTime) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::AccelerationTime' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, Speed) == 0x00001C, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::Speed' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, Duration) == 0x000020, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::Duration' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor, LatentInfo) == 0x000028, "Member 'GbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor::LatentInfo' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsContentCensored
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_IsContentCensored final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_IsContentCensored) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_IsContentCensored");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_IsContentCensored) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_IsContentCensored");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_IsContentCensored, WorldContextObject) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_IsContentCensored::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_IsContentCensored, ReturnValue) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_IsContentCensored::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsPlayer
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_IsPlayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_IsPlayer) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_IsPlayer");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_IsPlayer) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_IsPlayer");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_IsPlayer, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_IsPlayer::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_IsPlayer, ReturnValue) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_IsPlayer::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsSplitScreen
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_IsSplitScreen final
{
public:
	class UGameInstance*                          GameInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_IsSplitScreen) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_IsSplitScreen");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_IsSplitScreen) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_IsSplitScreen");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_IsSplitScreen, GameInstance) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_IsSplitScreen::GameInstance' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_IsSplitScreen, ReturnValue) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_IsSplitScreen::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockAiming
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockAiming::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockAIThinking
// 0x0018 (0x0018 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbort;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking) == 0x000018, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking::Reason' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking, bAbort) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking::bAbort' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockCrouching
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockDemigod
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockDodging
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockDodging::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockFootIk
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockFootIkTracing
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockGod
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockGod final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockGod) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockGod");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockGod) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockGod");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockGod, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockGod::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockGod, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockGod::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockHandIk
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockJumping
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockJumping::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockLookAt
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockLookAtTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMantling
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockMantling::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMomentum
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMovement
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockMovement::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockPhysicsRotation
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockRotation
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockRotation::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTargetable
// 0x0018 (0x0018 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetable;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable) == 0x000018, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable::Reason' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable, bTargetable) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable::bTargetable' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTickAndRefreshBones
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTurns
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceLockTurns::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockAiming
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockAIThinking
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockCrouching
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockDemigod
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockDodging
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockFootIk
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockFootIkTracing
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockGod
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockHandIk
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockJumping
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockLookAt
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockLookAtTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMantling
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMomentum
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMovement
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockRotation
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockTickAndRefreshBones
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockTurns
// 0x0010 (0x0010 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns) == 0x000010, "Wrong size on GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns, Actor) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns::Actor' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns, Reason) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns::Reason' has a wrong offset!");

// Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.SetComponentPhysicalRotation
// 0x0020 (0x0020 - 0x0000)
struct GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation final
{
public:
	class UPrimitiveComponent*                    Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotation;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotation;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollRotation;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation) == 0x000008, "Wrong alignment on GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation");
static_assert(sizeof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation) == 0x000020, "Wrong size on GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation, Target) == 0x000000, "Member 'GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation::Target' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation, PitchRotation) == 0x000008, "Member 'GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation::PitchRotation' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation, YawRotation) == 0x00000C, "Member 'GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation::YawRotation' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation, RollRotation) == 0x000010, "Member 'GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation::RollRotation' has a wrong offset!");
static_assert(offsetof(GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation, BoneName) == 0x000018, "Member 'GbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation::BoneName' has a wrong offset!");

// Function GbxGameSystemCore.GbxMediaManager.GbxPlayMovie
// 0x0018 (0x0018 - 0x0000)
struct GbxMediaManager_GbxPlayMovie final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxMediaData*                          InMediaData;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaPlayer*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxMediaManager_GbxPlayMovie) == 0x000008, "Wrong alignment on GbxMediaManager_GbxPlayMovie");
static_assert(sizeof(GbxMediaManager_GbxPlayMovie) == 0x000018, "Wrong size on GbxMediaManager_GbxPlayMovie");
static_assert(offsetof(GbxMediaManager_GbxPlayMovie, WorldContextObject) == 0x000000, "Member 'GbxMediaManager_GbxPlayMovie::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GbxMediaManager_GbxPlayMovie, InMediaData) == 0x000008, "Member 'GbxMediaManager_GbxPlayMovie::InMediaData' has a wrong offset!");
static_assert(offsetof(GbxMediaManager_GbxPlayMovie, ReturnValue) == 0x000010, "Member 'GbxMediaManager_GbxPlayMovie::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxMediaManager.OnMovieMediaOpenFailed
// 0x0010 (0x0010 - 0x0000)
struct GbxMediaManager_OnMovieMediaOpenFailed final
{
public:
	class FString                                 DeviceUrl;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxMediaManager_OnMovieMediaOpenFailed) == 0x000008, "Wrong alignment on GbxMediaManager_OnMovieMediaOpenFailed");
static_assert(sizeof(GbxMediaManager_OnMovieMediaOpenFailed) == 0x000010, "Wrong size on GbxMediaManager_OnMovieMediaOpenFailed");
static_assert(offsetof(GbxMediaManager_OnMovieMediaOpenFailed, DeviceUrl) == 0x000000, "Member 'GbxMediaManager_OnMovieMediaOpenFailed::DeviceUrl' has a wrong offset!");

// Function GbxGameSystemCore.GbxNavAvoidanceInterface.SetObstacleAvoidanceLock
// 0x0010 (0x0010 - 0x0000)
struct GbxNavAvoidanceInterface_SetObstacleAvoidanceLock final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxNavAvoidanceInterface_SetObstacleAvoidanceLock) == 0x000004, "Wrong alignment on GbxNavAvoidanceInterface_SetObstacleAvoidanceLock");
static_assert(sizeof(GbxNavAvoidanceInterface_SetObstacleAvoidanceLock) == 0x000010, "Wrong size on GbxNavAvoidanceInterface_SetObstacleAvoidanceLock");
static_assert(offsetof(GbxNavAvoidanceInterface_SetObstacleAvoidanceLock, bDisable) == 0x000000, "Member 'GbxNavAvoidanceInterface_SetObstacleAvoidanceLock::bDisable' has a wrong offset!");
static_assert(offsetof(GbxNavAvoidanceInterface_SetObstacleAvoidanceLock, Reason) == 0x000008, "Member 'GbxNavAvoidanceInterface_SetObstacleAvoidanceLock::Reason' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.ClearStanceLayer
// 0x0001 (0x0001 - 0x0000)
struct StanceComponent_ClearStanceLayer final
{
public:
	EStanceStackLayer                             Layer;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_ClearStanceLayer) == 0x000001, "Wrong alignment on StanceComponent_ClearStanceLayer");
static_assert(sizeof(StanceComponent_ClearStanceLayer) == 0x000001, "Wrong size on StanceComponent_ClearStanceLayer");
static_assert(offsetof(StanceComponent_ClearStanceLayer, Layer) == 0x000000, "Member 'StanceComponent_ClearStanceLayer::Layer' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.SetBlueprintStance
// 0x0008 (0x0008 - 0x0000)
struct StanceComponent_SetBlueprintStance final
{
public:
	class UStanceDataProvider*                    NewStance;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_SetBlueprintStance) == 0x000008, "Wrong alignment on StanceComponent_SetBlueprintStance");
static_assert(sizeof(StanceComponent_SetBlueprintStance) == 0x000008, "Wrong size on StanceComponent_SetBlueprintStance");
static_assert(offsetof(StanceComponent_SetBlueprintStance, NewStance) == 0x000000, "Member 'StanceComponent_SetBlueprintStance::NewStance' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.SetStanceLayer
// 0x0010 (0x0010 - 0x0000)
struct StanceComponent_SetStanceLayer final
{
public:
	EStanceStackLayer                             Layer;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    NewStance;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_SetStanceLayer) == 0x000008, "Wrong alignment on StanceComponent_SetStanceLayer");
static_assert(sizeof(StanceComponent_SetStanceLayer) == 0x000010, "Wrong size on StanceComponent_SetStanceLayer");
static_assert(offsetof(StanceComponent_SetStanceLayer, Layer) == 0x000000, "Member 'StanceComponent_SetStanceLayer::Layer' has a wrong offset!");
static_assert(offsetof(StanceComponent_SetStanceLayer, NewStance) == 0x000008, "Member 'StanceComponent_SetStanceLayer::NewStance' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.StackStanceChangedCallback
// 0x0020 (0x0020 - 0x0000)
struct StanceComponent_StackStanceChangedCallback final
{
public:
	EStanceStackLayer                             PreviousLayer;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceData*                            PreviousStance;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStanceStackLayer                             NextLayer;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceData*                            NextStance;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_StackStanceChangedCallback) == 0x000008, "Wrong alignment on StanceComponent_StackStanceChangedCallback");
static_assert(sizeof(StanceComponent_StackStanceChangedCallback) == 0x000020, "Wrong size on StanceComponent_StackStanceChangedCallback");
static_assert(offsetof(StanceComponent_StackStanceChangedCallback, PreviousLayer) == 0x000000, "Member 'StanceComponent_StackStanceChangedCallback::PreviousLayer' has a wrong offset!");
static_assert(offsetof(StanceComponent_StackStanceChangedCallback, PreviousStance) == 0x000008, "Member 'StanceComponent_StackStanceChangedCallback::PreviousStance' has a wrong offset!");
static_assert(offsetof(StanceComponent_StackStanceChangedCallback, NextLayer) == 0x000010, "Member 'StanceComponent_StackStanceChangedCallback::NextLayer' has a wrong offset!");
static_assert(offsetof(StanceComponent_StackStanceChangedCallback, NextStance) == 0x000018, "Member 'StanceComponent_StackStanceChangedCallback::NextStance' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.FindStanceForType
// 0x0010 (0x0010 - 0x0000)
struct StanceComponent_FindStanceForType final
{
public:
	class UStanceType*                            Type;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceData*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_FindStanceForType) == 0x000008, "Wrong alignment on StanceComponent_FindStanceForType");
static_assert(sizeof(StanceComponent_FindStanceForType) == 0x000010, "Wrong size on StanceComponent_FindStanceForType");
static_assert(offsetof(StanceComponent_FindStanceForType, Type) == 0x000000, "Member 'StanceComponent_FindStanceForType::Type' has a wrong offset!");
static_assert(offsetof(StanceComponent_FindStanceForType, ReturnValue) == 0x000008, "Member 'StanceComponent_FindStanceForType::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.FindTypeForStance
// 0x0010 (0x0010 - 0x0000)
struct StanceComponent_FindTypeForStance final
{
public:
	class UStanceData*                            Stance;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceType*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_FindTypeForStance) == 0x000008, "Wrong alignment on StanceComponent_FindTypeForStance");
static_assert(sizeof(StanceComponent_FindTypeForStance) == 0x000010, "Wrong size on StanceComponent_FindTypeForStance");
static_assert(offsetof(StanceComponent_FindTypeForStance, Stance) == 0x000000, "Member 'StanceComponent_FindTypeForStance::Stance' has a wrong offset!");
static_assert(offsetof(StanceComponent_FindTypeForStance, ReturnValue) == 0x000008, "Member 'StanceComponent_FindTypeForStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.GetStance
// 0x0008 (0x0008 - 0x0000)
struct StanceComponent_GetStance final
{
public:
	class UStanceData*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_GetStance) == 0x000008, "Wrong alignment on StanceComponent_GetStance");
static_assert(sizeof(StanceComponent_GetStance) == 0x000008, "Wrong size on StanceComponent_GetStance");
static_assert(offsetof(StanceComponent_GetStance, ReturnValue) == 0x000000, "Member 'StanceComponent_GetStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.GetStanceLayer
// 0x0001 (0x0001 - 0x0000)
struct StanceComponent_GetStanceLayer final
{
public:
	EStanceStackLayer                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_GetStanceLayer) == 0x000001, "Wrong alignment on StanceComponent_GetStanceLayer");
static_assert(sizeof(StanceComponent_GetStanceLayer) == 0x000001, "Wrong size on StanceComponent_GetStanceLayer");
static_assert(offsetof(StanceComponent_GetStanceLayer, ReturnValue) == 0x000000, "Member 'StanceComponent_GetStanceLayer::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.GetTimeSpentInCurrentStance
// 0x0004 (0x0004 - 0x0000)
struct StanceComponent_GetTimeSpentInCurrentStance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_GetTimeSpentInCurrentStance) == 0x000004, "Wrong alignment on StanceComponent_GetTimeSpentInCurrentStance");
static_assert(sizeof(StanceComponent_GetTimeSpentInCurrentStance) == 0x000004, "Wrong size on StanceComponent_GetTimeSpentInCurrentStance");
static_assert(offsetof(StanceComponent_GetTimeSpentInCurrentStance, ReturnValue) == 0x000000, "Member 'StanceComponent_GetTimeSpentInCurrentStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.IsInAnimStance
// 0x0010 (0x0010 - 0x0000)
struct StanceComponent_IsInAnimStance final
{
public:
	class UStanceDataProvider*                    Stance;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceComponent_IsInAnimStance) == 0x000008, "Wrong alignment on StanceComponent_IsInAnimStance");
static_assert(sizeof(StanceComponent_IsInAnimStance) == 0x000010, "Wrong size on StanceComponent_IsInAnimStance");
static_assert(offsetof(StanceComponent_IsInAnimStance, Stance) == 0x000000, "Member 'StanceComponent_IsInAnimStance::Stance' has a wrong offset!");
static_assert(offsetof(StanceComponent_IsInAnimStance, ReturnValue) == 0x000008, "Member 'StanceComponent_IsInAnimStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.IsInStance
// 0x0010 (0x0010 - 0x0000)
struct StanceComponent_IsInStance final
{
public:
	class UStanceDataProvider*                    Stance;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceComponent_IsInStance) == 0x000008, "Wrong alignment on StanceComponent_IsInStance");
static_assert(sizeof(StanceComponent_IsInStance) == 0x000010, "Wrong size on StanceComponent_IsInStance");
static_assert(offsetof(StanceComponent_IsInStance, Stance) == 0x000000, "Member 'StanceComponent_IsInStance::Stance' has a wrong offset!");
static_assert(offsetof(StanceComponent_IsInStance, ReturnValue) == 0x000008, "Member 'StanceComponent_IsInStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.IsInStanceLayer
// 0x0002 (0x0002 - 0x0000)
struct StanceComponent_IsInStanceLayer final
{
public:
	EStanceStackLayer                             Layer;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceComponent_IsInStanceLayer) == 0x000001, "Wrong alignment on StanceComponent_IsInStanceLayer");
static_assert(sizeof(StanceComponent_IsInStanceLayer) == 0x000002, "Wrong size on StanceComponent_IsInStanceLayer");
static_assert(offsetof(StanceComponent_IsInStanceLayer, Layer) == 0x000000, "Member 'StanceComponent_IsInStanceLayer::Layer' has a wrong offset!");
static_assert(offsetof(StanceComponent_IsInStanceLayer, ReturnValue) == 0x000001, "Member 'StanceComponent_IsInStanceLayer::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceComponent.IsInStanceType
// 0x0010 (0x0010 - 0x0000)
struct StanceComponent_IsInStanceType final
{
public:
	class UStanceType*                            Type;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceComponent_IsInStanceType) == 0x000008, "Wrong alignment on StanceComponent_IsInStanceType");
static_assert(sizeof(StanceComponent_IsInStanceType) == 0x000010, "Wrong size on StanceComponent_IsInStanceType");
static_assert(offsetof(StanceComponent_IsInStanceType, Type) == 0x000000, "Member 'StanceComponent_IsInStanceType::Type' has a wrong offset!");
static_assert(offsetof(StanceComponent_IsInStanceType, ReturnValue) == 0x000008, "Member 'StanceComponent_IsInStanceType::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.Evaluate
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_Evaluate final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0088(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_Evaluate) == 0x000008, "Wrong alignment on GbxParamExt_Evaluate");
static_assert(sizeof(GbxParamExt_Evaluate) == 0x000090, "Wrong size on GbxParamExt_Evaluate");
static_assert(offsetof(GbxParamExt_Evaluate, Param) == 0x000000, "Member 'GbxParamExt_Evaluate::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_Evaluate, Context) == 0x000080, "Member 'GbxParamExt_Evaluate::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_Evaluate, ReturnValue) == 0x000088, "Member 'GbxParamExt_Evaluate::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.EvaluateBool
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_EvaluateBool final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_EvaluateBool) == 0x000008, "Wrong alignment on GbxParamExt_EvaluateBool");
static_assert(sizeof(GbxParamExt_EvaluateBool) == 0x000090, "Wrong size on GbxParamExt_EvaluateBool");
static_assert(offsetof(GbxParamExt_EvaluateBool, Param) == 0x000000, "Member 'GbxParamExt_EvaluateBool::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateBool, Context) == 0x000080, "Member 'GbxParamExt_EvaluateBool::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateBool, ReturnValue) == 0x000088, "Member 'GbxParamExt_EvaluateBool::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.EvaluateBoolPure
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_EvaluateBoolPure final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_EvaluateBoolPure) == 0x000008, "Wrong alignment on GbxParamExt_EvaluateBoolPure");
static_assert(sizeof(GbxParamExt_EvaluateBoolPure) == 0x000090, "Wrong size on GbxParamExt_EvaluateBoolPure");
static_assert(offsetof(GbxParamExt_EvaluateBoolPure, Param) == 0x000000, "Member 'GbxParamExt_EvaluateBoolPure::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateBoolPure, Context) == 0x000080, "Member 'GbxParamExt_EvaluateBoolPure::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateBoolPure, ReturnValue) == 0x000088, "Member 'GbxParamExt_EvaluateBoolPure::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.EvaluateInt
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_EvaluateInt final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0088(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_EvaluateInt) == 0x000008, "Wrong alignment on GbxParamExt_EvaluateInt");
static_assert(sizeof(GbxParamExt_EvaluateInt) == 0x000090, "Wrong size on GbxParamExt_EvaluateInt");
static_assert(offsetof(GbxParamExt_EvaluateInt, Param) == 0x000000, "Member 'GbxParamExt_EvaluateInt::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateInt, Context) == 0x000080, "Member 'GbxParamExt_EvaluateInt::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateInt, ReturnValue) == 0x000088, "Member 'GbxParamExt_EvaluateInt::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.EvaluateIntPure
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_EvaluateIntPure final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0088(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_EvaluateIntPure) == 0x000008, "Wrong alignment on GbxParamExt_EvaluateIntPure");
static_assert(sizeof(GbxParamExt_EvaluateIntPure) == 0x000090, "Wrong size on GbxParamExt_EvaluateIntPure");
static_assert(offsetof(GbxParamExt_EvaluateIntPure, Param) == 0x000000, "Member 'GbxParamExt_EvaluateIntPure::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateIntPure, Context) == 0x000080, "Member 'GbxParamExt_EvaluateIntPure::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluateIntPure, ReturnValue) == 0x000088, "Member 'GbxParamExt_EvaluateIntPure::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.EvaluatePure
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_EvaluatePure final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Context;                                           // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0088(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_EvaluatePure) == 0x000008, "Wrong alignment on GbxParamExt_EvaluatePure");
static_assert(sizeof(GbxParamExt_EvaluatePure) == 0x000090, "Wrong size on GbxParamExt_EvaluatePure");
static_assert(offsetof(GbxParamExt_EvaluatePure, Param) == 0x000000, "Member 'GbxParamExt_EvaluatePure::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluatePure, Context) == 0x000080, "Member 'GbxParamExt_EvaluatePure::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_EvaluatePure, ReturnValue) == 0x000088, "Member 'GbxParamExt_EvaluatePure::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.GetNamedParamDescription
// 0x0098 (0x0098 - 0x0000)
struct GbxParamExt_GetNamedParamDescription final
{
public:
	struct FGbxNamedParam                         Param;                                             // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxParamExt_GetNamedParamDescription) == 0x000008, "Wrong alignment on GbxParamExt_GetNamedParamDescription");
static_assert(sizeof(GbxParamExt_GetNamedParamDescription) == 0x000098, "Wrong size on GbxParamExt_GetNamedParamDescription");
static_assert(offsetof(GbxParamExt_GetNamedParamDescription, Param) == 0x000000, "Member 'GbxParamExt_GetNamedParamDescription::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_GetNamedParamDescription, ReturnValue) == 0x000088, "Member 'GbxParamExt_GetNamedParamDescription::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.GetNamedParamDescriptionText
// 0x00A0 (0x00A0 - 0x0000)
struct GbxParamExt_GetNamedParamDescriptionText final
{
public:
	struct FGbxNamedParam                         Param;                                             // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0088(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxParamExt_GetNamedParamDescriptionText) == 0x000008, "Wrong alignment on GbxParamExt_GetNamedParamDescriptionText");
static_assert(sizeof(GbxParamExt_GetNamedParamDescriptionText) == 0x0000A0, "Wrong size on GbxParamExt_GetNamedParamDescriptionText");
static_assert(offsetof(GbxParamExt_GetNamedParamDescriptionText, Param) == 0x000000, "Member 'GbxParamExt_GetNamedParamDescriptionText::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_GetNamedParamDescriptionText, ReturnValue) == 0x000088, "Member 'GbxParamExt_GetNamedParamDescriptionText::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.GetParamDescription
// 0x0090 (0x0090 - 0x0000)
struct GbxParamExt_GetParamDescription final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0080(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxParamExt_GetParamDescription) == 0x000008, "Wrong alignment on GbxParamExt_GetParamDescription");
static_assert(sizeof(GbxParamExt_GetParamDescription) == 0x000090, "Wrong size on GbxParamExt_GetParamDescription");
static_assert(offsetof(GbxParamExt_GetParamDescription, Param) == 0x000000, "Member 'GbxParamExt_GetParamDescription::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_GetParamDescription, ReturnValue) == 0x000080, "Member 'GbxParamExt_GetParamDescription::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.GetParamDescriptionText
// 0x0098 (0x0098 - 0x0000)
struct GbxParamExt_GetParamDescriptionText final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0080(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxParamExt_GetParamDescriptionText) == 0x000008, "Wrong alignment on GbxParamExt_GetParamDescriptionText");
static_assert(sizeof(GbxParamExt_GetParamDescriptionText) == 0x000098, "Wrong size on GbxParamExt_GetParamDescriptionText");
static_assert(offsetof(GbxParamExt_GetParamDescriptionText, Param) == 0x000000, "Member 'GbxParamExt_GetParamDescriptionText::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_GetParamDescriptionText, ReturnValue) == 0x000080, "Member 'GbxParamExt_GetParamDescriptionText::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.GetParamPropertyDescription
// 0x0098 (0x0098 - 0x0000)
struct GbxParamExt_GetParamPropertyDescription final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxParamExt_GetParamPropertyDescription) == 0x000008, "Wrong alignment on GbxParamExt_GetParamPropertyDescription");
static_assert(sizeof(GbxParamExt_GetParamPropertyDescription) == 0x000098, "Wrong size on GbxParamExt_GetParamPropertyDescription");
static_assert(offsetof(GbxParamExt_GetParamPropertyDescription, Param) == 0x000000, "Member 'GbxParamExt_GetParamPropertyDescription::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_GetParamPropertyDescription, Property) == 0x000080, "Member 'GbxParamExt_GetParamPropertyDescription::Property' has a wrong offset!");
static_assert(offsetof(GbxParamExt_GetParamPropertyDescription, ReturnValue) == 0x000088, "Member 'GbxParamExt_GetParamPropertyDescription::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.IsValueInRange
// 0x0098 (0x0098 - 0x0000)
struct GbxParamExt_IsValueInRange final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Context;                                           // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_IsValueInRange) == 0x000008, "Wrong alignment on GbxParamExt_IsValueInRange");
static_assert(sizeof(GbxParamExt_IsValueInRange) == 0x000098, "Wrong size on GbxParamExt_IsValueInRange");
static_assert(offsetof(GbxParamExt_IsValueInRange, Param) == 0x000000, "Member 'GbxParamExt_IsValueInRange::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_IsValueInRange, Value) == 0x000080, "Member 'GbxParamExt_IsValueInRange::Value' has a wrong offset!");
static_assert(offsetof(GbxParamExt_IsValueInRange, Context) == 0x000088, "Member 'GbxParamExt_IsValueInRange::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_IsValueInRange, ReturnValue) == 0x000090, "Member 'GbxParamExt_IsValueInRange::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxParamExt.IsValueInRangePure
// 0x0098 (0x0098 - 0x0000)
struct GbxParamExt_IsValueInRangePure final
{
public:
	struct FGbxParam                              Param;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Context;                                           // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxParamExt_IsValueInRangePure) == 0x000008, "Wrong alignment on GbxParamExt_IsValueInRangePure");
static_assert(sizeof(GbxParamExt_IsValueInRangePure) == 0x000098, "Wrong size on GbxParamExt_IsValueInRangePure");
static_assert(offsetof(GbxParamExt_IsValueInRangePure, Param) == 0x000000, "Member 'GbxParamExt_IsValueInRangePure::Param' has a wrong offset!");
static_assert(offsetof(GbxParamExt_IsValueInRangePure, Value) == 0x000080, "Member 'GbxParamExt_IsValueInRangePure::Value' has a wrong offset!");
static_assert(offsetof(GbxParamExt_IsValueInRangePure, Context) == 0x000088, "Member 'GbxParamExt_IsValueInRangePure::Context' has a wrong offset!");
static_assert(offsetof(GbxParamExt_IsValueInRangePure, ReturnValue) == 0x000090, "Member 'GbxParamExt_IsValueInRangePure::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GbxPhysicsSettings.StaticSetRigidBodySimulationInteractability
// 0x0018 (0x0018 - 0x0000)
struct GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability final
{
public:
	class USkeletalMeshComponent*                 Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAesthetic;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BodyName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability) == 0x000008, "Wrong alignment on GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability");
static_assert(sizeof(GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability) == 0x000018, "Wrong size on GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability");
static_assert(offsetof(GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability, Comp) == 0x000000, "Member 'GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability::Comp' has a wrong offset!");
static_assert(offsetof(GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability, bAesthetic) == 0x000008, "Member 'GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability::bAesthetic' has a wrong offset!");
static_assert(offsetof(GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability, BodyName) == 0x000010, "Member 'GbxPhysicsSettings_StaticSetRigidBodySimulationInteractability::BodyName' has a wrong offset!");

// Function GbxGameSystemCore.GbxQueryManager.NotifyAIHotSpotListChangedFor
// 0x0008 (0x0008 - 0x0000)
struct GbxQueryManager_NotifyAIHotSpotListChangedFor final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxQueryManager_NotifyAIHotSpotListChangedFor) == 0x000008, "Wrong alignment on GbxQueryManager_NotifyAIHotSpotListChangedFor");
static_assert(sizeof(GbxQueryManager_NotifyAIHotSpotListChangedFor) == 0x000008, "Wrong size on GbxQueryManager_NotifyAIHotSpotListChangedFor");
static_assert(offsetof(GbxQueryManager_NotifyAIHotSpotListChangedFor, OwnerActor) == 0x000000, "Member 'GbxQueryManager_NotifyAIHotSpotListChangedFor::OwnerActor' has a wrong offset!");

// Function GbxGameSystemCore.GbxSignificanceSettings.EnumerateSignificanceEvents
// 0x0010 (0x0010 - 0x0000)
struct GbxSignificanceSettings_EnumerateSignificanceEvents final
{
public:
	TArray<class FName>                           OutEvents;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSignificanceSettings_EnumerateSignificanceEvents) == 0x000008, "Wrong alignment on GbxSignificanceSettings_EnumerateSignificanceEvents");
static_assert(sizeof(GbxSignificanceSettings_EnumerateSignificanceEvents) == 0x000010, "Wrong size on GbxSignificanceSettings_EnumerateSignificanceEvents");
static_assert(offsetof(GbxSignificanceSettings_EnumerateSignificanceEvents, OutEvents) == 0x000000, "Member 'GbxSignificanceSettings_EnumerateSignificanceEvents::OutEvents' has a wrong offset!");

// Function GbxGameSystemCore.GbxUIName.GetFormattedText
// 0x0018 (0x0018 - 0x0000)
struct GbxUIName_GetFormattedText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxUIName_GetFormattedText) == 0x000008, "Wrong alignment on GbxUIName_GetFormattedText");
static_assert(sizeof(GbxUIName_GetFormattedText) == 0x000018, "Wrong size on GbxUIName_GetFormattedText");
static_assert(offsetof(GbxUIName_GetFormattedText, ReturnValue) == 0x000000, "Member 'GbxUIName_GetFormattedText::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.GestaltPartData_Mesh.EnumerateGestaltMeshPartNames
// 0x0010 (0x0010 - 0x0000)
struct GestaltPartData_Mesh_EnumerateGestaltMeshPartNames final
{
public:
	TArray<class FName>                           OutPartNameList;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GestaltPartData_Mesh_EnumerateGestaltMeshPartNames) == 0x000008, "Wrong alignment on GestaltPartData_Mesh_EnumerateGestaltMeshPartNames");
static_assert(sizeof(GestaltPartData_Mesh_EnumerateGestaltMeshPartNames) == 0x000010, "Wrong size on GestaltPartData_Mesh_EnumerateGestaltMeshPartNames");
static_assert(offsetof(GestaltPartData_Mesh_EnumerateGestaltMeshPartNames, OutPartNameList) == 0x000000, "Member 'GestaltPartData_Mesh_EnumerateGestaltMeshPartNames::OutPartNameList' has a wrong offset!");

// Function GbxGameSystemCore.GlobalBoneModBlueprintLibrary.K2_SetGBMP
// 0x0010 (0x0010 - 0x0000)
struct GlobalBoneModBlueprintLibrary_K2_SetGBMP final
{
public:
	const class UGlobalBoneModifyProfileState*    State;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GlobalBoneModBlueprintLibrary_K2_SetGBMP) == 0x000008, "Wrong alignment on GlobalBoneModBlueprintLibrary_K2_SetGBMP");
static_assert(sizeof(GlobalBoneModBlueprintLibrary_K2_SetGBMP) == 0x000010, "Wrong size on GlobalBoneModBlueprintLibrary_K2_SetGBMP");
static_assert(offsetof(GlobalBoneModBlueprintLibrary_K2_SetGBMP, State) == 0x000000, "Member 'GlobalBoneModBlueprintLibrary_K2_SetGBMP::State' has a wrong offset!");
static_assert(offsetof(GlobalBoneModBlueprintLibrary_K2_SetGBMP, bEnabled) == 0x000008, "Member 'GlobalBoneModBlueprintLibrary_K2_SetGBMP::bEnabled' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.AddHitReactionDeathLayer
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_AddHitReactionDeathLayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHitReactionLayer>          Layer;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_AddHitReactionDeathLayer) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_AddHitReactionDeathLayer");
static_assert(sizeof(HitReactionBlueprintLibrary_AddHitReactionDeathLayer) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_AddHitReactionDeathLayer");
static_assert(offsetof(HitReactionBlueprintLibrary_AddHitReactionDeathLayer, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_AddHitReactionDeathLayer::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_AddHitReactionDeathLayer, Layer) == 0x000008, "Member 'HitReactionBlueprintLibrary_AddHitReactionDeathLayer::Layer' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.AddHitReactionLiveLayer
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_AddHitReactionLiveLayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHitReactionLayer>          Layer;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_AddHitReactionLiveLayer) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_AddHitReactionLiveLayer");
static_assert(sizeof(HitReactionBlueprintLibrary_AddHitReactionLiveLayer) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_AddHitReactionLiveLayer");
static_assert(offsetof(HitReactionBlueprintLibrary_AddHitReactionLiveLayer, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_AddHitReactionLiveLayer::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_AddHitReactionLiveLayer, Layer) == 0x000008, "Member 'HitReactionBlueprintLibrary_AddHitReactionLiveLayer::Layer' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.IsHitReactionTagActive
// 0x0018 (0x0018 - 0x0000)
struct HitReactionBlueprintLibrary_IsHitReactionTagActive final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitReactionBlueprintLibrary_IsHitReactionTagActive) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_IsHitReactionTagActive");
static_assert(sizeof(HitReactionBlueprintLibrary_IsHitReactionTagActive) == 0x000018, "Wrong size on HitReactionBlueprintLibrary_IsHitReactionTagActive");
static_assert(offsetof(HitReactionBlueprintLibrary_IsHitReactionTagActive, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_IsHitReactionTagActive::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_IsHitReactionTagActive, Tag) == 0x000008, "Member 'HitReactionBlueprintLibrary_IsHitReactionTagActive::Tag' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_IsHitReactionTagActive, ReturnValue) == 0x000010, "Member 'HitReactionBlueprintLibrary_IsHitReactionTagActive::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetBoneIndexFromAction
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction");
static_assert(sizeof(HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction, Action) == 0x000000, "Member 'HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction::Action' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction, ReturnValue) == 0x000008, "Member 'HitReactionBlueprintLibrary_K2_GetBoneIndexFromAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetForceFromAction
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_K2_GetForceFromAction final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitReactionBlueprintLibrary_K2_GetForceFromAction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_K2_GetForceFromAction");
static_assert(sizeof(HitReactionBlueprintLibrary_K2_GetForceFromAction) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_K2_GetForceFromAction");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetForceFromAction, Action) == 0x000000, "Member 'HitReactionBlueprintLibrary_K2_GetForceFromAction::Action' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetForceFromAction, ReturnValue) == 0x000008, "Member 'HitReactionBlueprintLibrary_K2_GetForceFromAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHealthPercentFromAction
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction");
static_assert(sizeof(HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction, Action) == 0x000000, "Member 'HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction::Action' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction, ReturnValue) == 0x000008, "Member 'HitReactionBlueprintLibrary_K2_GetHealthPercentFromAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitCauserFromAction
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_K2_GetHitCauserFromAction final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_K2_GetHitCauserFromAction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_K2_GetHitCauserFromAction");
static_assert(sizeof(HitReactionBlueprintLibrary_K2_GetHitCauserFromAction) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_K2_GetHitCauserFromAction");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitCauserFromAction, Action) == 0x000000, "Member 'HitReactionBlueprintLibrary_K2_GetHitCauserFromAction::Action' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitCauserFromAction, ReturnValue) == 0x000008, "Member 'HitReactionBlueprintLibrary_K2_GetHitCauserFromAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitDirectionFromAction
// 0x0018 (0x0018 - 0x0000)
struct HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalSpace;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction");
static_assert(sizeof(HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction) == 0x000018, "Wrong size on HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction, Action) == 0x000000, "Member 'HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction::Action' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction, bLocalSpace) == 0x000008, "Member 'HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction::bLocalSpace' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction, ReturnValue) == 0x00000C, "Member 'HitReactionBlueprintLibrary_K2_GetHitDirectionFromAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitLocationFromAction
// 0x0018 (0x0018 - 0x0000)
struct HitReactionBlueprintLibrary_K2_GetHitLocationFromAction final
{
public:
	class UGbxAction*                             Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HitReactionBlueprintLibrary_K2_GetHitLocationFromAction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_K2_GetHitLocationFromAction");
static_assert(sizeof(HitReactionBlueprintLibrary_K2_GetHitLocationFromAction) == 0x000018, "Wrong size on HitReactionBlueprintLibrary_K2_GetHitLocationFromAction");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitLocationFromAction, Action) == 0x000000, "Member 'HitReactionBlueprintLibrary_K2_GetHitLocationFromAction::Action' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_K2_GetHitLocationFromAction, ReturnValue) == 0x000008, "Member 'HitReactionBlueprintLibrary_K2_GetHitLocationFromAction::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.RemoveHitReactionDeathLayer
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHitReactionLayer>          Layer;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer");
static_assert(sizeof(HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer");
static_assert(offsetof(HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer, Layer) == 0x000008, "Member 'HitReactionBlueprintLibrary_RemoveHitReactionDeathLayer::Layer' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.RemoveHitReactionLiveLayer
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHitReactionLayer>          Layer;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer");
static_assert(sizeof(HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer");
static_assert(offsetof(HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer, Layer) == 0x000008, "Member 'HitReactionBlueprintLibrary_RemoveHitReactionLiveLayer::Layer' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.ResourceLockHitReactions
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_ResourceLockHitReactions final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_ResourceLockHitReactions) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_ResourceLockHitReactions");
static_assert(sizeof(HitReactionBlueprintLibrary_ResourceLockHitReactions) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_ResourceLockHitReactions");
static_assert(offsetof(HitReactionBlueprintLibrary_ResourceLockHitReactions, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_ResourceLockHitReactions::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ResourceLockHitReactions, Reason) == 0x000008, "Member 'HitReactionBlueprintLibrary_ResourceLockHitReactions::Reason' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.ResourceUnlockHitReactions
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_ResourceUnlockHitReactions final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_ResourceUnlockHitReactions) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_ResourceUnlockHitReactions");
static_assert(sizeof(HitReactionBlueprintLibrary_ResourceUnlockHitReactions) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_ResourceUnlockHitReactions");
static_assert(offsetof(HitReactionBlueprintLibrary_ResourceUnlockHitReactions, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_ResourceUnlockHitReactions::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ResourceUnlockHitReactions, Reason) == 0x000008, "Member 'HitReactionBlueprintLibrary_ResourceUnlockHitReactions::Reason' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.ScriptDeath
// 0x0050 (0x0050 - 0x0000)
struct HitReactionBlueprintLibrary_ScriptDeath final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Causer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalHitDirection;                                 // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        Force;                                             // 0x0030(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_ScriptDeath) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_ScriptDeath");
static_assert(sizeof(HitReactionBlueprintLibrary_ScriptDeath) == 0x000050, "Wrong size on HitReactionBlueprintLibrary_ScriptDeath");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptDeath, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_ScriptDeath::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptDeath, Causer) == 0x000008, "Member 'HitReactionBlueprintLibrary_ScriptDeath::Causer' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptDeath, Tag) == 0x000010, "Member 'HitReactionBlueprintLibrary_ScriptDeath::Tag' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptDeath, LocalHitDirection) == 0x000018, "Member 'HitReactionBlueprintLibrary_ScriptDeath::LocalHitDirection' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptDeath, BoneName) == 0x000028, "Member 'HitReactionBlueprintLibrary_ScriptDeath::BoneName' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptDeath, Force) == 0x000030, "Member 'HitReactionBlueprintLibrary_ScriptDeath::Force' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.ScriptHitReaction
// 0x0050 (0x0050 - 0x0000)
struct HitReactionBlueprintLibrary_ScriptHitReaction final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Causer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalHitDirection;                                 // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        Force;                                             // 0x0030(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_ScriptHitReaction) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_ScriptHitReaction");
static_assert(sizeof(HitReactionBlueprintLibrary_ScriptHitReaction) == 0x000050, "Wrong size on HitReactionBlueprintLibrary_ScriptHitReaction");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptHitReaction, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_ScriptHitReaction::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptHitReaction, Causer) == 0x000008, "Member 'HitReactionBlueprintLibrary_ScriptHitReaction::Causer' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptHitReaction, Tag) == 0x000010, "Member 'HitReactionBlueprintLibrary_ScriptHitReaction::Tag' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptHitReaction, LocalHitDirection) == 0x000018, "Member 'HitReactionBlueprintLibrary_ScriptHitReaction::LocalHitDirection' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptHitReaction, BoneName) == 0x000028, "Member 'HitReactionBlueprintLibrary_ScriptHitReaction::BoneName' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_ScriptHitReaction, Force) == 0x000030, "Member 'HitReactionBlueprintLibrary_ScriptHitReaction::Force' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionBlueprintLibrary.SetHitReactionData
// 0x0010 (0x0010 - 0x0000)
struct HitReactionBlueprintLibrary_SetHitReactionData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionData*                       HitReactionData;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionBlueprintLibrary_SetHitReactionData) == 0x000008, "Wrong alignment on HitReactionBlueprintLibrary_SetHitReactionData");
static_assert(sizeof(HitReactionBlueprintLibrary_SetHitReactionData) == 0x000010, "Wrong size on HitReactionBlueprintLibrary_SetHitReactionData");
static_assert(offsetof(HitReactionBlueprintLibrary_SetHitReactionData, Actor) == 0x000000, "Member 'HitReactionBlueprintLibrary_SetHitReactionData::Actor' has a wrong offset!");
static_assert(offsetof(HitReactionBlueprintLibrary_SetHitReactionData, HitReactionData) == 0x000008, "Member 'HitReactionBlueprintLibrary_SetHitReactionData::HitReactionData' has a wrong offset!");

// Function GbxGameSystemCore.HitReactionLayer_Blueprint.EvaluateTag
// 0x0048 (0x0048 - 0x0000)
struct HitReactionLayer_Blueprint_EvaluateTag final
{
public:
	class UDamageComponent*                       Receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageCauserComponent*                 Causer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UGbxDamageType*                   DamageType;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDamageSource*                    DamageSource;                                      // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitReactionTag*                        PreviousTag;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitReactionLayer_Blueprint_EvaluateTag) == 0x000008, "Wrong alignment on HitReactionLayer_Blueprint_EvaluateTag");
static_assert(sizeof(HitReactionLayer_Blueprint_EvaluateTag) == 0x000048, "Wrong size on HitReactionLayer_Blueprint_EvaluateTag");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, Receiver) == 0x000000, "Member 'HitReactionLayer_Blueprint_EvaluateTag::Receiver' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, Causer) == 0x000008, "Member 'HitReactionLayer_Blueprint_EvaluateTag::Causer' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, DamageAmount) == 0x000010, "Member 'HitReactionLayer_Blueprint_EvaluateTag::DamageAmount' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, DamageType) == 0x000018, "Member 'HitReactionLayer_Blueprint_EvaluateTag::DamageType' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, DamageSource) == 0x000020, "Member 'HitReactionLayer_Blueprint_EvaluateTag::DamageSource' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, HitRegion) == 0x000028, "Member 'HitReactionLayer_Blueprint_EvaluateTag::HitRegion' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, Force) == 0x000030, "Member 'HitReactionLayer_Blueprint_EvaluateTag::Force' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, PreviousTag) == 0x000038, "Member 'HitReactionLayer_Blueprint_EvaluateTag::PreviousTag' has a wrong offset!");
static_assert(offsetof(HitReactionLayer_Blueprint_EvaluateTag, ReturnValue) == 0x000040, "Member 'HitReactionLayer_Blueprint_EvaluateTag::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionFunctionLibrary.AssociateComponentWithHitRegion
// 0x0018 (0x0018 - 0x0000)
struct HitRegionFunctionLibrary_AssociateComponentWithHitRegion final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    ComponentToAssociate;                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionFunctionLibrary_AssociateComponentWithHitRegion) == 0x000008, "Wrong alignment on HitRegionFunctionLibrary_AssociateComponentWithHitRegion");
static_assert(sizeof(HitRegionFunctionLibrary_AssociateComponentWithHitRegion) == 0x000018, "Wrong size on HitRegionFunctionLibrary_AssociateComponentWithHitRegion");
static_assert(offsetof(HitRegionFunctionLibrary_AssociateComponentWithHitRegion, Actor) == 0x000000, "Member 'HitRegionFunctionLibrary_AssociateComponentWithHitRegion::Actor' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_AssociateComponentWithHitRegion, ComponentToAssociate) == 0x000008, "Member 'HitRegionFunctionLibrary_AssociateComponentWithHitRegion::ComponentToAssociate' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_AssociateComponentWithHitRegion, HitRegion) == 0x000010, "Member 'HitRegionFunctionLibrary_AssociateComponentWithHitRegion::HitRegion' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionFunctionLibrary.RefillHitRegionHealthByAmount
// 0x0020 (0x0020 - 0x0000)
struct HitRegionFunctionLibrary_RefillHitRegionHealthByAmount final
{
public:
	float                                         RefillAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AssociatedComponent;                               // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionFunctionLibrary_RefillHitRegionHealthByAmount) == 0x000008, "Wrong alignment on HitRegionFunctionLibrary_RefillHitRegionHealthByAmount");
static_assert(sizeof(HitRegionFunctionLibrary_RefillHitRegionHealthByAmount) == 0x000020, "Wrong size on HitRegionFunctionLibrary_RefillHitRegionHealthByAmount");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByAmount, RefillAmount) == 0x000000, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByAmount::RefillAmount' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByAmount, Actor) == 0x000008, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByAmount::Actor' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByAmount, HitRegion) == 0x000010, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByAmount::HitRegion' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByAmount, AssociatedComponent) == 0x000018, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByAmount::AssociatedComponent' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionFunctionLibrary.RefillHitRegionHealthByPercent
// 0x0020 (0x0020 - 0x0000)
struct HitRegionFunctionLibrary_RefillHitRegionHealthByPercent final
{
public:
	float                                         RefillPercent;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AssociatedComponent;                               // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionFunctionLibrary_RefillHitRegionHealthByPercent) == 0x000008, "Wrong alignment on HitRegionFunctionLibrary_RefillHitRegionHealthByPercent");
static_assert(sizeof(HitRegionFunctionLibrary_RefillHitRegionHealthByPercent) == 0x000020, "Wrong size on HitRegionFunctionLibrary_RefillHitRegionHealthByPercent");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByPercent, RefillPercent) == 0x000000, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByPercent::RefillPercent' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByPercent, Actor) == 0x000008, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByPercent::Actor' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByPercent, HitRegion) == 0x000010, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByPercent::HitRegion' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_RefillHitRegionHealthByPercent, AssociatedComponent) == 0x000018, "Member 'HitRegionFunctionLibrary_RefillHitRegionHealthByPercent::AssociatedComponent' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionFunctionLibrary.ResetAllHitRegionHealth
// 0x0008 (0x0008 - 0x0000)
struct HitRegionFunctionLibrary_ResetAllHitRegionHealth final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionFunctionLibrary_ResetAllHitRegionHealth) == 0x000008, "Wrong alignment on HitRegionFunctionLibrary_ResetAllHitRegionHealth");
static_assert(sizeof(HitRegionFunctionLibrary_ResetAllHitRegionHealth) == 0x000008, "Wrong size on HitRegionFunctionLibrary_ResetAllHitRegionHealth");
static_assert(offsetof(HitRegionFunctionLibrary_ResetAllHitRegionHealth, Actor) == 0x000000, "Member 'HitRegionFunctionLibrary_ResetAllHitRegionHealth::Actor' has a wrong offset!");

// Function GbxGameSystemCore.HitRegionFunctionLibrary.ResetHitRegionHealth
// 0x0018 (0x0018 - 0x0000)
struct HitRegionFunctionLibrary_ResetHitRegionHealth final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AssociatedComponent;                               // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HitRegionFunctionLibrary_ResetHitRegionHealth) == 0x000008, "Wrong alignment on HitRegionFunctionLibrary_ResetHitRegionHealth");
static_assert(sizeof(HitRegionFunctionLibrary_ResetHitRegionHealth) == 0x000018, "Wrong size on HitRegionFunctionLibrary_ResetHitRegionHealth");
static_assert(offsetof(HitRegionFunctionLibrary_ResetHitRegionHealth, Actor) == 0x000000, "Member 'HitRegionFunctionLibrary_ResetHitRegionHealth::Actor' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_ResetHitRegionHealth, HitRegion) == 0x000008, "Member 'HitRegionFunctionLibrary_ResetHitRegionHealth::HitRegion' has a wrong offset!");
static_assert(offsetof(HitRegionFunctionLibrary_ResetHitRegionHealth, AssociatedComponent) == 0x000010, "Member 'HitRegionFunctionLibrary_ResetHitRegionHealth::AssociatedComponent' has a wrong offset!");

// Function GbxGameSystemCore.InspectionInfoProvider.GetInspectionInfo
// 0x0020 (0x0020 - 0x0000)
struct InspectionInfoProvider_GetInspectionInfo final
{
public:
	struct FInspectionInfo                        InspectionInfo;                                    // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InspectionInfoProvider_GetInspectionInfo) == 0x000008, "Wrong alignment on InspectionInfoProvider_GetInspectionInfo");
static_assert(sizeof(InspectionInfoProvider_GetInspectionInfo) == 0x000020, "Wrong size on InspectionInfoProvider_GetInspectionInfo");
static_assert(offsetof(InspectionInfoProvider_GetInspectionInfo, InspectionInfo) == 0x000000, "Member 'InspectionInfoProvider_GetInspectionInfo::InspectionInfo' has a wrong offset!");

// Function GbxGameSystemCore.ImpactFXManagerComponent.OnHit
// 0x00B0 (0x00B0 - 0x0000)
struct ImpactFXManagerComponent_OnHit final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactFXManagerComponent_OnHit) == 0x000008, "Wrong alignment on ImpactFXManagerComponent_OnHit");
static_assert(sizeof(ImpactFXManagerComponent_OnHit) == 0x0000B0, "Wrong size on ImpactFXManagerComponent_OnHit");
static_assert(offsetof(ImpactFXManagerComponent_OnHit, SelfActor) == 0x000000, "Member 'ImpactFXManagerComponent_OnHit::SelfActor' has a wrong offset!");
static_assert(offsetof(ImpactFXManagerComponent_OnHit, OtherActor) == 0x000008, "Member 'ImpactFXManagerComponent_OnHit::OtherActor' has a wrong offset!");
static_assert(offsetof(ImpactFXManagerComponent_OnHit, NormalImpulse) == 0x000010, "Member 'ImpactFXManagerComponent_OnHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(ImpactFXManagerComponent_OnHit, Hit) == 0x000020, "Member 'ImpactFXManagerComponent_OnHit::Hit' has a wrong offset!");

// Function GbxGameSystemCore.ImpactFXManagerComponent.OnTrackedComponentDeactivated
// 0x0008 (0x0008 - 0x0000)
struct ImpactFXManagerComponent_OnTrackedComponentDeactivated final
{
public:
	class UActorComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactFXManagerComponent_OnTrackedComponentDeactivated) == 0x000008, "Wrong alignment on ImpactFXManagerComponent_OnTrackedComponentDeactivated");
static_assert(sizeof(ImpactFXManagerComponent_OnTrackedComponentDeactivated) == 0x000008, "Wrong size on ImpactFXManagerComponent_OnTrackedComponentDeactivated");
static_assert(offsetof(ImpactFXManagerComponent_OnTrackedComponentDeactivated, Component) == 0x000000, "Member 'ImpactFXManagerComponent_OnTrackedComponentDeactivated::Component' has a wrong offset!");

// Function GbxGameSystemCore.ImpactFXManagerComponent.OnTrackedParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct ImpactFXManagerComponent_OnTrackedParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactFXManagerComponent_OnTrackedParticleSystemFinished) == 0x000008, "Wrong alignment on ImpactFXManagerComponent_OnTrackedParticleSystemFinished");
static_assert(sizeof(ImpactFXManagerComponent_OnTrackedParticleSystemFinished) == 0x000008, "Wrong size on ImpactFXManagerComponent_OnTrackedParticleSystemFinished");
static_assert(offsetof(ImpactFXManagerComponent_OnTrackedParticleSystemFinished, PSC) == 0x000000, "Member 'ImpactFXManagerComponent_OnTrackedParticleSystemFinished::PSC' has a wrong offset!");

// Function GbxGameSystemCore.ImpactFXManagerComponent.SetEffectsEnabled
// 0x0001 (0x0001 - 0x0000)
struct ImpactFXManagerComponent_SetEffectsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactFXManagerComponent_SetEffectsEnabled) == 0x000001, "Wrong alignment on ImpactFXManagerComponent_SetEffectsEnabled");
static_assert(sizeof(ImpactFXManagerComponent_SetEffectsEnabled) == 0x000001, "Wrong size on ImpactFXManagerComponent_SetEffectsEnabled");
static_assert(offsetof(ImpactFXManagerComponent_SetEffectsEnabled, bEnabled) == 0x000000, "Member 'ImpactFXManagerComponent_SetEffectsEnabled::bEnabled' has a wrong offset!");

// Function GbxGameSystemCore.InspectionInfoFunctionLibrary.AddAboveActorOutput
// 0x0038 (0x0038 - 0x0000)
struct InspectionInfoFunctionLibrary_AddAboveActorOutput final
{
public:
	struct FInspectionInfo                        InspectionInfo;                                    // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDebugDisplayVerbosityLevel                   Verbosity;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InspectionInfoFunctionLibrary_AddAboveActorOutput) == 0x000008, "Wrong alignment on InspectionInfoFunctionLibrary_AddAboveActorOutput");
static_assert(sizeof(InspectionInfoFunctionLibrary_AddAboveActorOutput) == 0x000038, "Wrong size on InspectionInfoFunctionLibrary_AddAboveActorOutput");
static_assert(offsetof(InspectionInfoFunctionLibrary_AddAboveActorOutput, InspectionInfo) == 0x000000, "Member 'InspectionInfoFunctionLibrary_AddAboveActorOutput::InspectionInfo' has a wrong offset!");
static_assert(offsetof(InspectionInfoFunctionLibrary_AddAboveActorOutput, String) == 0x000020, "Member 'InspectionInfoFunctionLibrary_AddAboveActorOutput::String' has a wrong offset!");
static_assert(offsetof(InspectionInfoFunctionLibrary_AddAboveActorOutput, Verbosity) == 0x000030, "Member 'InspectionInfoFunctionLibrary_AddAboveActorOutput::Verbosity' has a wrong offset!");

// Function GbxGameSystemCore.InspectionInfoFunctionLibrary.AddScreenOutput
// 0x0038 (0x0038 - 0x0000)
struct InspectionInfoFunctionLibrary_AddScreenOutput final
{
public:
	struct FInspectionInfo                        InspectionInfo;                                    // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDebugDisplayVerbosityLevel                   Verbosity;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InspectionInfoFunctionLibrary_AddScreenOutput) == 0x000008, "Wrong alignment on InspectionInfoFunctionLibrary_AddScreenOutput");
static_assert(sizeof(InspectionInfoFunctionLibrary_AddScreenOutput) == 0x000038, "Wrong size on InspectionInfoFunctionLibrary_AddScreenOutput");
static_assert(offsetof(InspectionInfoFunctionLibrary_AddScreenOutput, InspectionInfo) == 0x000000, "Member 'InspectionInfoFunctionLibrary_AddScreenOutput::InspectionInfo' has a wrong offset!");
static_assert(offsetof(InspectionInfoFunctionLibrary_AddScreenOutput, String) == 0x000020, "Member 'InspectionInfoFunctionLibrary_AddScreenOutput::String' has a wrong offset!");
static_assert(offsetof(InspectionInfoFunctionLibrary_AddScreenOutput, Verbosity) == 0x000030, "Member 'InspectionInfoFunctionLibrary_AddScreenOutput::Verbosity' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.InterpBallistics
// 0x0024 (0x0024 - 0x0000)
struct InterpComponent_InterpBallistics final
{
public:
	struct FVector                                StartLoc;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLoc;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeapSpeed;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeapAngle;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_InterpBallistics) == 0x000004, "Wrong alignment on InterpComponent_InterpBallistics");
static_assert(sizeof(InterpComponent_InterpBallistics) == 0x000024, "Wrong size on InterpComponent_InterpBallistics");
static_assert(offsetof(InterpComponent_InterpBallistics, StartLoc) == 0x000000, "Member 'InterpComponent_InterpBallistics::StartLoc' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallistics, EndLoc) == 0x00000C, "Member 'InterpComponent_InterpBallistics::EndLoc' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallistics, LeapSpeed) == 0x000018, "Member 'InterpComponent_InterpBallistics::LeapSpeed' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallistics, LeapAngle) == 0x00001C, "Member 'InterpComponent_InterpBallistics::LeapAngle' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallistics, ReturnValue) == 0x000020, "Member 'InterpComponent_InterpBallistics::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.InterpBallisticsByTime
// 0x002C (0x002C - 0x0000)
struct InterpComponent_InterpBallisticsByTime final
{
public:
	struct FVector                                StartLoc;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLoc;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeapTime;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeapGravity;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_InterpBallisticsByTime) == 0x000004, "Wrong alignment on InterpComponent_InterpBallisticsByTime");
static_assert(sizeof(InterpComponent_InterpBallisticsByTime) == 0x00002C, "Wrong size on InterpComponent_InterpBallisticsByTime");
static_assert(offsetof(InterpComponent_InterpBallisticsByTime, StartLoc) == 0x000000, "Member 'InterpComponent_InterpBallisticsByTime::StartLoc' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallisticsByTime, EndLoc) == 0x00000C, "Member 'InterpComponent_InterpBallisticsByTime::EndLoc' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallisticsByTime, LeapTime) == 0x000018, "Member 'InterpComponent_InterpBallisticsByTime::LeapTime' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallisticsByTime, LeapGravity) == 0x00001C, "Member 'InterpComponent_InterpBallisticsByTime::LeapGravity' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpBallisticsByTime, ReturnValue) == 0x000020, "Member 'InterpComponent_InterpBallisticsByTime::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.InterpDeltaLocation
// 0x0014 (0x0014 - 0x0000)
struct InterpComponent_InterpDeltaLocation final
{
public:
	struct FVector                                DeltaLoc;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinear;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoZ;                                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRelative;                                       // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpComponent_InterpDeltaLocation) == 0x000004, "Wrong alignment on InterpComponent_InterpDeltaLocation");
static_assert(sizeof(InterpComponent_InterpDeltaLocation) == 0x000014, "Wrong size on InterpComponent_InterpDeltaLocation");
static_assert(offsetof(InterpComponent_InterpDeltaLocation, DeltaLoc) == 0x000000, "Member 'InterpComponent_InterpDeltaLocation::DeltaLoc' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaLocation, InterpTime) == 0x00000C, "Member 'InterpComponent_InterpDeltaLocation::InterpTime' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaLocation, bLinear) == 0x000010, "Member 'InterpComponent_InterpDeltaLocation::bLinear' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaLocation, bNoZ) == 0x000011, "Member 'InterpComponent_InterpDeltaLocation::bNoZ' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaLocation, bInRelative) == 0x000012, "Member 'InterpComponent_InterpDeltaLocation::bInRelative' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.InterpDeltaRotation
// 0x0014 (0x0014 - 0x0000)
struct InterpComponent_InterpDeltaRotation final
{
public:
	struct FRotator                               DeltaRot;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinear;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bYawOnly;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRelative;                                       // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpComponent_InterpDeltaRotation) == 0x000004, "Wrong alignment on InterpComponent_InterpDeltaRotation");
static_assert(sizeof(InterpComponent_InterpDeltaRotation) == 0x000014, "Wrong size on InterpComponent_InterpDeltaRotation");
static_assert(offsetof(InterpComponent_InterpDeltaRotation, DeltaRot) == 0x000000, "Member 'InterpComponent_InterpDeltaRotation::DeltaRot' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaRotation, InterpTime) == 0x00000C, "Member 'InterpComponent_InterpDeltaRotation::InterpTime' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaRotation, bLinear) == 0x000010, "Member 'InterpComponent_InterpDeltaRotation::bLinear' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaRotation, bYawOnly) == 0x000011, "Member 'InterpComponent_InterpDeltaRotation::bYawOnly' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpDeltaRotation, bInRelative) == 0x000012, "Member 'InterpComponent_InterpDeltaRotation::bInRelative' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.InterpLocation
// 0x0014 (0x0014 - 0x0000)
struct InterpComponent_InterpLocation final
{
public:
	struct FVector                                NewLoc;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinear;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoZ;                                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRelative;                                       // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpComponent_InterpLocation) == 0x000004, "Wrong alignment on InterpComponent_InterpLocation");
static_assert(sizeof(InterpComponent_InterpLocation) == 0x000014, "Wrong size on InterpComponent_InterpLocation");
static_assert(offsetof(InterpComponent_InterpLocation, NewLoc) == 0x000000, "Member 'InterpComponent_InterpLocation::NewLoc' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpLocation, InterpTime) == 0x00000C, "Member 'InterpComponent_InterpLocation::InterpTime' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpLocation, bLinear) == 0x000010, "Member 'InterpComponent_InterpLocation::bLinear' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpLocation, bNoZ) == 0x000011, "Member 'InterpComponent_InterpLocation::bNoZ' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpLocation, bInRelative) == 0x000012, "Member 'InterpComponent_InterpLocation::bInRelative' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.InterpRotation
// 0x0014 (0x0014 - 0x0000)
struct InterpComponent_InterpRotation final
{
public:
	struct FRotator                               NewRot;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinear;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bYawOnly;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRelative;                                       // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpComponent_InterpRotation) == 0x000004, "Wrong alignment on InterpComponent_InterpRotation");
static_assert(sizeof(InterpComponent_InterpRotation) == 0x000014, "Wrong size on InterpComponent_InterpRotation");
static_assert(offsetof(InterpComponent_InterpRotation, NewRot) == 0x000000, "Member 'InterpComponent_InterpRotation::NewRot' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpRotation, InterpTime) == 0x00000C, "Member 'InterpComponent_InterpRotation::InterpTime' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpRotation, bLinear) == 0x000010, "Member 'InterpComponent_InterpRotation::bLinear' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpRotation, bYawOnly) == 0x000011, "Member 'InterpComponent_InterpRotation::bYawOnly' has a wrong offset!");
static_assert(offsetof(InterpComponent_InterpRotation, bInRelative) == 0x000012, "Member 'InterpComponent_InterpRotation::bInRelative' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.ManualTick
// 0x0004 (0x0004 - 0x0000)
struct InterpComponent_ManualTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_ManualTick) == 0x000004, "Wrong alignment on InterpComponent_ManualTick");
static_assert(sizeof(InterpComponent_ManualTick) == 0x000004, "Wrong size on InterpComponent_ManualTick");
static_assert(offsetof(InterpComponent_ManualTick, DeltaTime) == 0x000000, "Member 'InterpComponent_ManualTick::DeltaTime' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.MatchRotationToVelocity
// 0x0001 (0x0001 - 0x0000)
struct InterpComponent_MatchRotationToVelocity final
{
public:
	bool                                          bInSetToInitialWhenFinished;                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_MatchRotationToVelocity) == 0x000001, "Wrong alignment on InterpComponent_MatchRotationToVelocity");
static_assert(sizeof(InterpComponent_MatchRotationToVelocity) == 0x000001, "Wrong size on InterpComponent_MatchRotationToVelocity");
static_assert(offsetof(InterpComponent_MatchRotationToVelocity, bInSetToInitialWhenFinished) == 0x000000, "Member 'InterpComponent_MatchRotationToVelocity::bInSetToInitialWhenFinished' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.SetClearVelocity
// 0x0001 (0x0001 - 0x0000)
struct InterpComponent_SetClearVelocity final
{
public:
	bool                                          bNewClearVelocity;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_SetClearVelocity) == 0x000001, "Wrong alignment on InterpComponent_SetClearVelocity");
static_assert(sizeof(InterpComponent_SetClearVelocity) == 0x000001, "Wrong size on InterpComponent_SetClearVelocity");
static_assert(offsetof(InterpComponent_SetClearVelocity, bNewClearVelocity) == 0x000000, "Member 'InterpComponent_SetClearVelocity::bNewClearVelocity' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.SetManualTick
// 0x0001 (0x0001 - 0x0000)
struct InterpComponent_SetManualTick final
{
public:
	bool                                          bManual;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_SetManualTick) == 0x000001, "Wrong alignment on InterpComponent_SetManualTick");
static_assert(sizeof(InterpComponent_SetManualTick) == 0x000001, "Wrong size on InterpComponent_SetManualTick");
static_assert(offsetof(InterpComponent_SetManualTick, bManual) == 0x000000, "Member 'InterpComponent_SetManualTick::bManual' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.SetRemoveOnCompletion
// 0x0001 (0x0001 - 0x0000)
struct InterpComponent_SetRemoveOnCompletion final
{
public:
	bool                                          bRemove;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_SetRemoveOnCompletion) == 0x000001, "Wrong alignment on InterpComponent_SetRemoveOnCompletion");
static_assert(sizeof(InterpComponent_SetRemoveOnCompletion) == 0x000001, "Wrong size on InterpComponent_SetRemoveOnCompletion");
static_assert(offsetof(InterpComponent_SetRemoveOnCompletion, bRemove) == 0x000000, "Member 'InterpComponent_SetRemoveOnCompletion::bRemove' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.SetUpdateVelocity
// 0x0001 (0x0001 - 0x0000)
struct InterpComponent_SetUpdateVelocity final
{
public:
	bool                                          bNewUpdateVelocity;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_SetUpdateVelocity) == 0x000001, "Wrong alignment on InterpComponent_SetUpdateVelocity");
static_assert(sizeof(InterpComponent_SetUpdateVelocity) == 0x000001, "Wrong size on InterpComponent_SetUpdateVelocity");
static_assert(offsetof(InterpComponent_SetUpdateVelocity, bNewUpdateVelocity) == 0x000000, "Member 'InterpComponent_SetUpdateVelocity::bNewUpdateVelocity' has a wrong offset!");

// Function GbxGameSystemCore.InterpComponent.IsFinished
// 0x0001 (0x0001 - 0x0000)
struct InterpComponent_IsFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpComponent_IsFinished) == 0x000001, "Wrong alignment on InterpComponent_IsFinished");
static_assert(sizeof(InterpComponent_IsFinished) == 0x000001, "Wrong size on InterpComponent_IsFinished");
static_assert(offsetof(InterpComponent_IsFinished, ReturnValue) == 0x000000, "Member 'InterpComponent_IsFinished::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.MotionControlLibrary.Spin
// 0x002C (0x002C - 0x0000)
struct MotionControlLibrary_Spin final
{
public:
	struct FRotator                               CurrentRotation;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationRate;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationAxis;                                      // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotionControlLibrary_Spin) == 0x000004, "Wrong alignment on MotionControlLibrary_Spin");
static_assert(sizeof(MotionControlLibrary_Spin) == 0x00002C, "Wrong size on MotionControlLibrary_Spin");
static_assert(offsetof(MotionControlLibrary_Spin, CurrentRotation) == 0x000000, "Member 'MotionControlLibrary_Spin::CurrentRotation' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_Spin, RotationRate) == 0x00000C, "Member 'MotionControlLibrary_Spin::RotationRate' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_Spin, RotationAxis) == 0x000010, "Member 'MotionControlLibrary_Spin::RotationAxis' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_Spin, DeltaTime) == 0x00001C, "Member 'MotionControlLibrary_Spin::DeltaTime' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_Spin, ReturnValue) == 0x000020, "Member 'MotionControlLibrary_Spin::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.MotionControlLibrary.UpdateSpeed
// 0x0014 (0x0014 - 0x0000)
struct MotionControlLibrary_UpdateSpeed final
{
public:
	float                                         CurrentSpeed;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSpeed;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotionControlLibrary_UpdateSpeed) == 0x000004, "Wrong alignment on MotionControlLibrary_UpdateSpeed");
static_assert(sizeof(MotionControlLibrary_UpdateSpeed) == 0x000014, "Wrong size on MotionControlLibrary_UpdateSpeed");
static_assert(offsetof(MotionControlLibrary_UpdateSpeed, CurrentSpeed) == 0x000000, "Member 'MotionControlLibrary_UpdateSpeed::CurrentSpeed' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_UpdateSpeed, TargetSpeed) == 0x000004, "Member 'MotionControlLibrary_UpdateSpeed::TargetSpeed' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_UpdateSpeed, Acceleration) == 0x000008, "Member 'MotionControlLibrary_UpdateSpeed::Acceleration' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_UpdateSpeed, DeltaTime) == 0x00000C, "Member 'MotionControlLibrary_UpdateSpeed::DeltaTime' has a wrong offset!");
static_assert(offsetof(MotionControlLibrary_UpdateSpeed, ReturnValue) == 0x000010, "Member 'MotionControlLibrary_UpdateSpeed::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.OrbitingActorComponent.OnRep_TargetActor
// 0x0008 (0x0008 - 0x0000)
struct OrbitingActorComponent_OnRep_TargetActor final
{
public:
	class AActor*                                 LastTarget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrbitingActorComponent_OnRep_TargetActor) == 0x000008, "Wrong alignment on OrbitingActorComponent_OnRep_TargetActor");
static_assert(sizeof(OrbitingActorComponent_OnRep_TargetActor) == 0x000008, "Wrong size on OrbitingActorComponent_OnRep_TargetActor");
static_assert(offsetof(OrbitingActorComponent_OnRep_TargetActor, LastTarget) == 0x000000, "Member 'OrbitingActorComponent_OnRep_TargetActor::LastTarget' has a wrong offset!");

// Function GbxGameSystemCore.OrbitingActorComponent.SetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct OrbitingActorComponent_SetTargetActor final
{
public:
	class AActor*                                 NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrbitingActorComponent_SetTargetActor) == 0x000008, "Wrong alignment on OrbitingActorComponent_SetTargetActor");
static_assert(sizeof(OrbitingActorComponent_SetTargetActor) == 0x000008, "Wrong size on OrbitingActorComponent_SetTargetActor");
static_assert(offsetof(OrbitingActorComponent_SetTargetActor, NewTarget) == 0x000000, "Member 'OrbitingActorComponent_SetTargetActor::NewTarget' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.AttachPawnToSlot
// 0x0020 (0x0020 - 0x0000)
struct PawnAttachmentFunctionLibrary_AttachPawnToSlot final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PawnAttachmentFunctionLibrary_AttachPawnToSlot) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_AttachPawnToSlot");
static_assert(sizeof(PawnAttachmentFunctionLibrary_AttachPawnToSlot) == 0x000020, "Wrong size on PawnAttachmentFunctionLibrary_AttachPawnToSlot");
static_assert(offsetof(PawnAttachmentFunctionLibrary_AttachPawnToSlot, Actor) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_AttachPawnToSlot::Actor' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_AttachPawnToSlot, SlotName) == 0x000008, "Member 'PawnAttachmentFunctionLibrary_AttachPawnToSlot::SlotName' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_AttachPawnToSlot, Pawn) == 0x000010, "Member 'PawnAttachmentFunctionLibrary_AttachPawnToSlot::Pawn' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_AttachPawnToSlot, bInstant) == 0x000018, "Member 'PawnAttachmentFunctionLibrary_AttachPawnToSlot::bInstant' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.DetachPawnFromActor
// 0x0010 (0x0010 - 0x0000)
struct PawnAttachmentFunctionLibrary_DetachPawnFromActor final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PawnAttachmentFunctionLibrary_DetachPawnFromActor) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_DetachPawnFromActor");
static_assert(sizeof(PawnAttachmentFunctionLibrary_DetachPawnFromActor) == 0x000010, "Wrong size on PawnAttachmentFunctionLibrary_DetachPawnFromActor");
static_assert(offsetof(PawnAttachmentFunctionLibrary_DetachPawnFromActor, Pawn) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_DetachPawnFromActor::Pawn' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_DetachPawnFromActor, bInstant) == 0x000008, "Member 'PawnAttachmentFunctionLibrary_DetachPawnFromActor::bInstant' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.DetachPawnFromSlot
// 0x0018 (0x0018 - 0x0000)
struct PawnAttachmentFunctionLibrary_DetachPawnFromSlot final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PawnAttachmentFunctionLibrary_DetachPawnFromSlot) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_DetachPawnFromSlot");
static_assert(sizeof(PawnAttachmentFunctionLibrary_DetachPawnFromSlot) == 0x000018, "Wrong size on PawnAttachmentFunctionLibrary_DetachPawnFromSlot");
static_assert(offsetof(PawnAttachmentFunctionLibrary_DetachPawnFromSlot, Actor) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_DetachPawnFromSlot::Actor' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_DetachPawnFromSlot, SlotName) == 0x000008, "Member 'PawnAttachmentFunctionLibrary_DetachPawnFromSlot::SlotName' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_DetachPawnFromSlot, bInstant) == 0x000010, "Member 'PawnAttachmentFunctionLibrary_DetachPawnFromSlot::bInstant' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.FindPawnAttachSlotComponent
// 0x0010 (0x0010 - 0x0000)
struct PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnAttachSlotComponent*               ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent");
static_assert(sizeof(PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent) == 0x000010, "Wrong size on PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent");
static_assert(offsetof(PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent, Pawn) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent::Pawn' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent, ReturnValue) == 0x000008, "Member 'PawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.QueryPawnAttachment
// 0x0020 (0x0020 - 0x0000)
struct PawnAttachmentFunctionLibrary_QueryPawnAttachment final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPawnAttachmentQueryResult             ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachmentFunctionLibrary_QueryPawnAttachment) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_QueryPawnAttachment");
static_assert(sizeof(PawnAttachmentFunctionLibrary_QueryPawnAttachment) == 0x000020, "Wrong size on PawnAttachmentFunctionLibrary_QueryPawnAttachment");
static_assert(offsetof(PawnAttachmentFunctionLibrary_QueryPawnAttachment, Pawn) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_QueryPawnAttachment::Pawn' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_QueryPawnAttachment, ReturnValue) == 0x000008, "Member 'PawnAttachmentFunctionLibrary_QueryPawnAttachment::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.RequestDetachPawnFromActor
// 0x0008 (0x0008 - 0x0000)
struct PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor");
static_assert(sizeof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor) == 0x000008, "Wrong size on PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor");
static_assert(offsetof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor, Pawn) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_RequestDetachPawnFromActor::Pawn' has a wrong offset!");

// Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.RequestDetachPawnFromSlot
// 0x0010 (0x0010 - 0x0000)
struct PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot) == 0x000008, "Wrong alignment on PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot");
static_assert(sizeof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot) == 0x000010, "Wrong size on PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot");
static_assert(offsetof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot, Actor) == 0x000000, "Member 'PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot::Actor' has a wrong offset!");
static_assert(offsetof(PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot, SlotName) == 0x000008, "Member 'PawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot::SlotName' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.SetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct ProjectileAimViewPointHomingTargetComponent_SetTargetActor final
{
public:
	class AActor*                                 InTargetActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileAimViewPointHomingTargetComponent_SetTargetActor) == 0x000008, "Wrong alignment on ProjectileAimViewPointHomingTargetComponent_SetTargetActor");
static_assert(sizeof(ProjectileAimViewPointHomingTargetComponent_SetTargetActor) == 0x000008, "Wrong size on ProjectileAimViewPointHomingTargetComponent_SetTargetActor");
static_assert(offsetof(ProjectileAimViewPointHomingTargetComponent_SetTargetActor, InTargetActor) == 0x000000, "Member 'ProjectileAimViewPointHomingTargetComponent_SetTargetActor::InTargetActor' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.SetTargetController
// 0x0008 (0x0008 - 0x0000)
struct ProjectileAimViewPointHomingTargetComponent_SetTargetController final
{
public:
	class AController*                            InTargetController;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileAimViewPointHomingTargetComponent_SetTargetController) == 0x000008, "Wrong alignment on ProjectileAimViewPointHomingTargetComponent_SetTargetController");
static_assert(sizeof(ProjectileAimViewPointHomingTargetComponent_SetTargetController) == 0x000008, "Wrong size on ProjectileAimViewPointHomingTargetComponent_SetTargetController");
static_assert(offsetof(ProjectileAimViewPointHomingTargetComponent_SetTargetController, InTargetController) == 0x000000, "Member 'ProjectileAimViewPointHomingTargetComponent_SetTargetController::InTargetController' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.GetCurrentHomingLoc
// 0x000C (0x000C - 0x0000)
struct ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc) == 0x000004, "Wrong alignment on ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc");
static_assert(sizeof(ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc) == 0x00000C, "Wrong size on ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc");
static_assert(offsetof(ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc, ReturnValue) == 0x000000, "Member 'ProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.GetTargetController
// 0x0008 (0x0008 - 0x0000)
struct ProjectileAimViewPointHomingTargetComponent_GetTargetController final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileAimViewPointHomingTargetComponent_GetTargetController) == 0x000008, "Wrong alignment on ProjectileAimViewPointHomingTargetComponent_GetTargetController");
static_assert(sizeof(ProjectileAimViewPointHomingTargetComponent_GetTargetController) == 0x000008, "Wrong size on ProjectileAimViewPointHomingTargetComponent_GetTargetController");
static_assert(offsetof(ProjectileAimViewPointHomingTargetComponent_GetTargetController, ReturnValue) == 0x000000, "Member 'ProjectileAimViewPointHomingTargetComponent_GetTargetController::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.ReferenceActor.EnumeratePreviewClasses
// 0x0010 (0x0010 - 0x0000)
struct ReferenceActor_EnumeratePreviewClasses final
{
public:
	TArray<class FName>                           ClasssList;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReferenceActor_EnumeratePreviewClasses) == 0x000008, "Wrong alignment on ReferenceActor_EnumeratePreviewClasses");
static_assert(sizeof(ReferenceActor_EnumeratePreviewClasses) == 0x000010, "Wrong size on ReferenceActor_EnumeratePreviewClasses");
static_assert(offsetof(ReferenceActor_EnumeratePreviewClasses, ClasssList) == 0x000000, "Member 'ReferenceActor_EnumeratePreviewClasses::ClasssList' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchComponent.HandleParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct SceneBodySwitchComponent_HandleParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchComponent_HandleParticleSystemFinished) == 0x000008, "Wrong alignment on SceneBodySwitchComponent_HandleParticleSystemFinished");
static_assert(sizeof(SceneBodySwitchComponent_HandleParticleSystemFinished) == 0x000008, "Wrong size on SceneBodySwitchComponent_HandleParticleSystemFinished");
static_assert(offsetof(SceneBodySwitchComponent_HandleParticleSystemFinished, PSC) == 0x000000, "Member 'SceneBodySwitchComponent_HandleParticleSystemFinished::PSC' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchComponent.HandleWwiseEventFinished
// 0x0010 (0x0010 - 0x0000)
struct SceneBodySwitchComponent_HandleWwiseEventFinished final
{
public:
	class UWwiseAudioComponent*                   WAC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchComponent_HandleWwiseEventFinished) == 0x000008, "Wrong alignment on SceneBodySwitchComponent_HandleWwiseEventFinished");
static_assert(sizeof(SceneBodySwitchComponent_HandleWwiseEventFinished) == 0x000010, "Wrong size on SceneBodySwitchComponent_HandleWwiseEventFinished");
static_assert(offsetof(SceneBodySwitchComponent_HandleWwiseEventFinished, WAC) == 0x000000, "Member 'SceneBodySwitchComponent_HandleWwiseEventFinished::WAC' has a wrong offset!");
static_assert(offsetof(SceneBodySwitchComponent_HandleWwiseEventFinished, WwiseEvent) == 0x000008, "Member 'SceneBodySwitchComponent_HandleWwiseEventFinished::WwiseEvent' has a wrong offset!");

// Function GbxGameSystemCore.SceneBodySwitchComponent.GetValidSwitchStateNames
// 0x0010 (0x0010 - 0x0000)
struct SceneBodySwitchComponent_GetValidSwitchStateNames final
{
public:
	TArray<class FName>                           OutNames;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneBodySwitchComponent_GetValidSwitchStateNames) == 0x000008, "Wrong alignment on SceneBodySwitchComponent_GetValidSwitchStateNames");
static_assert(sizeof(SceneBodySwitchComponent_GetValidSwitchStateNames) == 0x000010, "Wrong size on SceneBodySwitchComponent_GetValidSwitchStateNames");
static_assert(offsetof(SceneBodySwitchComponent_GetValidSwitchStateNames, OutNames) == 0x000000, "Member 'SceneBodySwitchComponent_GetValidSwitchStateNames::OutNames' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.ClearStance
// 0x0008 (0x0008 - 0x0000)
struct StanceBlueprintLibrary_ClearStance final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceBlueprintLibrary_ClearStance) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_ClearStance");
static_assert(sizeof(StanceBlueprintLibrary_ClearStance) == 0x000008, "Wrong size on StanceBlueprintLibrary_ClearStance");
static_assert(offsetof(StanceBlueprintLibrary_ClearStance, Target) == 0x000000, "Member 'StanceBlueprintLibrary_ClearStance::Target' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.EqualEqual_StanceDataStanceData
// 0x0018 (0x0018 - 0x0000)
struct StanceBlueprintLibrary_EqualEqual_StanceDataStanceData final
{
public:
	class UStanceData*                            A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceData*                            B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceBlueprintLibrary_EqualEqual_StanceDataStanceData) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_EqualEqual_StanceDataStanceData");
static_assert(sizeof(StanceBlueprintLibrary_EqualEqual_StanceDataStanceData) == 0x000018, "Wrong size on StanceBlueprintLibrary_EqualEqual_StanceDataStanceData");
static_assert(offsetof(StanceBlueprintLibrary_EqualEqual_StanceDataStanceData, A) == 0x000000, "Member 'StanceBlueprintLibrary_EqualEqual_StanceDataStanceData::A' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_EqualEqual_StanceDataStanceData, B) == 0x000008, "Member 'StanceBlueprintLibrary_EqualEqual_StanceDataStanceData::B' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_EqualEqual_StanceDataStanceData, ReturnValue) == 0x000010, "Member 'StanceBlueprintLibrary_EqualEqual_StanceDataStanceData::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.EqualEqual_StanceTypeStanceType
// 0x0018 (0x0018 - 0x0000)
struct StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType final
{
public:
	class UStanceType*                            A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceType*                            B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType");
static_assert(sizeof(StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType) == 0x000018, "Wrong size on StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType");
static_assert(offsetof(StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType, A) == 0x000000, "Member 'StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType::A' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType, B) == 0x000008, "Member 'StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType::B' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType, ReturnValue) == 0x000010, "Member 'StanceBlueprintLibrary_EqualEqual_StanceTypeStanceType::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.IsInStance
// 0x0018 (0x0018 - 0x0000)
struct StanceBlueprintLibrary_IsInStance final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    Stance;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceBlueprintLibrary_IsInStance) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_IsInStance");
static_assert(sizeof(StanceBlueprintLibrary_IsInStance) == 0x000018, "Wrong size on StanceBlueprintLibrary_IsInStance");
static_assert(offsetof(StanceBlueprintLibrary_IsInStance, AnimInstance) == 0x000000, "Member 'StanceBlueprintLibrary_IsInStance::AnimInstance' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_IsInStance, Stance) == 0x000008, "Member 'StanceBlueprintLibrary_IsInStance::Stance' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_IsInStance, ReturnValue) == 0x000010, "Member 'StanceBlueprintLibrary_IsInStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.IsStanceComponentInStance
// 0x0018 (0x0018 - 0x0000)
struct StanceBlueprintLibrary_IsStanceComponentInStance final
{
public:
	class UStanceComponent*                       StanceComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    Stance;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StanceBlueprintLibrary_IsStanceComponentInStance) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_IsStanceComponentInStance");
static_assert(sizeof(StanceBlueprintLibrary_IsStanceComponentInStance) == 0x000018, "Wrong size on StanceBlueprintLibrary_IsStanceComponentInStance");
static_assert(offsetof(StanceBlueprintLibrary_IsStanceComponentInStance, StanceComponent) == 0x000000, "Member 'StanceBlueprintLibrary_IsStanceComponentInStance::StanceComponent' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_IsStanceComponentInStance, Stance) == 0x000008, "Member 'StanceBlueprintLibrary_IsStanceComponentInStance::Stance' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_IsStanceComponentInStance, ReturnValue) == 0x000010, "Member 'StanceBlueprintLibrary_IsStanceComponentInStance::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.SetStance
// 0x0010 (0x0010 - 0x0000)
struct StanceBlueprintLibrary_SetStance final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    Stance;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceBlueprintLibrary_SetStance) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_SetStance");
static_assert(sizeof(StanceBlueprintLibrary_SetStance) == 0x000010, "Wrong size on StanceBlueprintLibrary_SetStance");
static_assert(offsetof(StanceBlueprintLibrary_SetStance, Target) == 0x000000, "Member 'StanceBlueprintLibrary_SetStance::Target' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_SetStance, Stance) == 0x000008, "Member 'StanceBlueprintLibrary_SetStance::Stance' has a wrong offset!");

// Function GbxGameSystemCore.StanceBlueprintLibrary.TryGetStanceComponent
// 0x0010 (0x0010 - 0x0000)
struct StanceBlueprintLibrary_TryGetStanceComponent final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StanceBlueprintLibrary_TryGetStanceComponent) == 0x000008, "Wrong alignment on StanceBlueprintLibrary_TryGetStanceComponent");
static_assert(sizeof(StanceBlueprintLibrary_TryGetStanceComponent) == 0x000010, "Wrong size on StanceBlueprintLibrary_TryGetStanceComponent");
static_assert(offsetof(StanceBlueprintLibrary_TryGetStanceComponent, AIController) == 0x000000, "Member 'StanceBlueprintLibrary_TryGetStanceComponent::AIController' has a wrong offset!");
static_assert(offsetof(StanceBlueprintLibrary_TryGetStanceComponent, ReturnValue) == 0x000008, "Member 'StanceBlueprintLibrary_TryGetStanceComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetTargetNameString
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_GetTargetNameString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetTargetNameString) == 0x000008, "Wrong alignment on TargetableComponent_GetTargetNameString");
static_assert(sizeof(TargetableComponent_GetTargetNameString) == 0x000010, "Wrong size on TargetableComponent_GetTargetNameString");
static_assert(offsetof(TargetableComponent_GetTargetNameString, ReturnValue) == 0x000000, "Member 'TargetableComponent_GetTargetNameString::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.SetIsTargetable
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_SetIsTargetable final
{
public:
	bool                                          IsTargetable;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_SetIsTargetable) == 0x000001, "Wrong alignment on TargetableComponent_SetIsTargetable");
static_assert(sizeof(TargetableComponent_SetIsTargetable) == 0x000001, "Wrong size on TargetableComponent_SetIsTargetable");
static_assert(offsetof(TargetableComponent_SetIsTargetable, IsTargetable) == 0x000000, "Member 'TargetableComponent_SetIsTargetable::IsTargetable' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByAIPlayers
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_SetIsTargetableByAIPlayers final
{
public:
	bool                                          IsTargetable;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_SetIsTargetableByAIPlayers) == 0x000001, "Wrong alignment on TargetableComponent_SetIsTargetableByAIPlayers");
static_assert(sizeof(TargetableComponent_SetIsTargetableByAIPlayers) == 0x000001, "Wrong size on TargetableComponent_SetIsTargetableByAIPlayers");
static_assert(offsetof(TargetableComponent_SetIsTargetableByAIPlayers, IsTargetable) == 0x000000, "Member 'TargetableComponent_SetIsTargetableByAIPlayers::IsTargetable' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByHumanPlayers
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_SetIsTargetableByHumanPlayers final
{
public:
	bool                                          IsTargetable;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_SetIsTargetableByHumanPlayers) == 0x000001, "Wrong alignment on TargetableComponent_SetIsTargetableByHumanPlayers");
static_assert(sizeof(TargetableComponent_SetIsTargetableByHumanPlayers) == 0x000001, "Wrong size on TargetableComponent_SetIsTargetableByHumanPlayers");
static_assert(offsetof(TargetableComponent_SetIsTargetableByHumanPlayers, IsTargetable) == 0x000000, "Member 'TargetableComponent_SetIsTargetableByHumanPlayers::IsTargetable' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByNonPlayers
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_SetIsTargetableByNonPlayers final
{
public:
	bool                                          IsTargetable;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_SetIsTargetableByNonPlayers) == 0x000001, "Wrong alignment on TargetableComponent_SetIsTargetableByNonPlayers");
static_assert(sizeof(TargetableComponent_SetIsTargetableByNonPlayers) == 0x000001, "Wrong size on TargetableComponent_SetIsTargetableByNonPlayers");
static_assert(offsetof(TargetableComponent_SetIsTargetableByNonPlayers, IsTargetable) == 0x000000, "Member 'TargetableComponent_SetIsTargetableByNonPlayers::IsTargetable' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.SetTargetName
// 0x0018 (0x0018 - 0x0000)
struct TargetableComponent_SetTargetName final
{
public:
	class FText                                   NewTargetName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_SetTargetName) == 0x000008, "Wrong alignment on TargetableComponent_SetTargetName");
static_assert(sizeof(TargetableComponent_SetTargetName) == 0x000018, "Wrong size on TargetableComponent_SetTargetName");
static_assert(offsetof(TargetableComponent_SetTargetName, NewTargetName) == 0x000000, "Member 'TargetableComponent_SetTargetName::NewTargetName' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.SetTargetUIName
// 0x0008 (0x0008 - 0x0000)
struct TargetableComponent_SetTargetUIName final
{
public:
	const class UGbxUIName*                       NewTargetUIName;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_SetTargetUIName) == 0x000008, "Wrong alignment on TargetableComponent_SetTargetUIName");
static_assert(sizeof(TargetableComponent_SetTargetUIName) == 0x000008, "Wrong size on TargetableComponent_SetTargetUIName");
static_assert(offsetof(TargetableComponent_SetTargetUIName, NewTargetUIName) == 0x000000, "Member 'TargetableComponent_SetTargetUIName::NewTargetUIName' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetAvailableSocketNames
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_GetAvailableSocketNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetAvailableSocketNames) == 0x000008, "Wrong alignment on TargetableComponent_GetAvailableSocketNames");
static_assert(sizeof(TargetableComponent_GetAvailableSocketNames) == 0x000010, "Wrong size on TargetableComponent_GetAvailableSocketNames");
static_assert(offsetof(TargetableComponent_GetAvailableSocketNames, Array) == 0x000000, "Member 'TargetableComponent_GetAvailableSocketNames::Array' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetClosestTargetLocation
// 0x0024 (0x0024 - 0x0000)
struct TargetableComponent_GetClosestTargetLocation final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetClosestTargetLocation) == 0x000004, "Wrong alignment on TargetableComponent_GetClosestTargetLocation");
static_assert(sizeof(TargetableComponent_GetClosestTargetLocation) == 0x000024, "Wrong size on TargetableComponent_GetClosestTargetLocation");
static_assert(offsetof(TargetableComponent_GetClosestTargetLocation, Origin) == 0x000000, "Member 'TargetableComponent_GetClosestTargetLocation::Origin' has a wrong offset!");
static_assert(offsetof(TargetableComponent_GetClosestTargetLocation, Direction) == 0x00000C, "Member 'TargetableComponent_GetClosestTargetLocation::Direction' has a wrong offset!");
static_assert(offsetof(TargetableComponent_GetClosestTargetLocation, ReturnValue) == 0x000018, "Member 'TargetableComponent_GetClosestTargetLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetTargetLocation
// 0x000C (0x000C - 0x0000)
struct TargetableComponent_GetTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetTargetLocation) == 0x000004, "Wrong alignment on TargetableComponent_GetTargetLocation");
static_assert(sizeof(TargetableComponent_GetTargetLocation) == 0x00000C, "Wrong size on TargetableComponent_GetTargetLocation");
static_assert(offsetof(TargetableComponent_GetTargetLocation, ReturnValue) == 0x000000, "Member 'TargetableComponent_GetTargetLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetTargetLocations
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_GetTargetLocations final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetTargetLocations) == 0x000008, "Wrong alignment on TargetableComponent_GetTargetLocations");
static_assert(sizeof(TargetableComponent_GetTargetLocations) == 0x000010, "Wrong size on TargetableComponent_GetTargetLocations");
static_assert(offsetof(TargetableComponent_GetTargetLocations, ReturnValue) == 0x000000, "Member 'TargetableComponent_GetTargetLocations::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetTargetProxyComponentNames
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_GetTargetProxyComponentNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetTargetProxyComponentNames) == 0x000008, "Wrong alignment on TargetableComponent_GetTargetProxyComponentNames");
static_assert(sizeof(TargetableComponent_GetTargetProxyComponentNames) == 0x000010, "Wrong size on TargetableComponent_GetTargetProxyComponentNames");
static_assert(offsetof(TargetableComponent_GetTargetProxyComponentNames, Array) == 0x000000, "Member 'TargetableComponent_GetTargetProxyComponentNames::Array' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.GetTargetSocketName
// 0x0008 (0x0008 - 0x0000)
struct TargetableComponent_GetTargetSocketName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_GetTargetSocketName) == 0x000004, "Wrong alignment on TargetableComponent_GetTargetSocketName");
static_assert(sizeof(TargetableComponent_GetTargetSocketName) == 0x000008, "Wrong size on TargetableComponent_GetTargetSocketName");
static_assert(offsetof(TargetableComponent_GetTargetSocketName, ReturnValue) == 0x000000, "Member 'TargetableComponent_GetTargetSocketName::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetable
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_IsTargetable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_IsTargetable) == 0x000001, "Wrong alignment on TargetableComponent_IsTargetable");
static_assert(sizeof(TargetableComponent_IsTargetable) == 0x000001, "Wrong size on TargetableComponent_IsTargetable");
static_assert(offsetof(TargetableComponent_IsTargetable, ReturnValue) == 0x000000, "Member 'TargetableComponent_IsTargetable::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetableByActor
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_IsTargetableByActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetableComponent_IsTargetableByActor) == 0x000008, "Wrong alignment on TargetableComponent_IsTargetableByActor");
static_assert(sizeof(TargetableComponent_IsTargetableByActor) == 0x000010, "Wrong size on TargetableComponent_IsTargetableByActor");
static_assert(offsetof(TargetableComponent_IsTargetableByActor, Actor) == 0x000000, "Member 'TargetableComponent_IsTargetableByActor::Actor' has a wrong offset!");
static_assert(offsetof(TargetableComponent_IsTargetableByActor, ReturnValue) == 0x000008, "Member 'TargetableComponent_IsTargetableByActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetableByAIPlayers
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_IsTargetableByAIPlayers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_IsTargetableByAIPlayers) == 0x000001, "Wrong alignment on TargetableComponent_IsTargetableByAIPlayers");
static_assert(sizeof(TargetableComponent_IsTargetableByAIPlayers) == 0x000001, "Wrong size on TargetableComponent_IsTargetableByAIPlayers");
static_assert(offsetof(TargetableComponent_IsTargetableByAIPlayers, ReturnValue) == 0x000000, "Member 'TargetableComponent_IsTargetableByAIPlayers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetableByController
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_IsTargetableByController final
{
public:
	const class AController*                      Controller;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetableComponent_IsTargetableByController) == 0x000008, "Wrong alignment on TargetableComponent_IsTargetableByController");
static_assert(sizeof(TargetableComponent_IsTargetableByController) == 0x000010, "Wrong size on TargetableComponent_IsTargetableByController");
static_assert(offsetof(TargetableComponent_IsTargetableByController, Controller) == 0x000000, "Member 'TargetableComponent_IsTargetableByController::Controller' has a wrong offset!");
static_assert(offsetof(TargetableComponent_IsTargetableByController, ReturnValue) == 0x000008, "Member 'TargetableComponent_IsTargetableByController::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetableByHumanPlayers
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_IsTargetableByHumanPlayers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_IsTargetableByHumanPlayers) == 0x000001, "Wrong alignment on TargetableComponent_IsTargetableByHumanPlayers");
static_assert(sizeof(TargetableComponent_IsTargetableByHumanPlayers) == 0x000001, "Wrong size on TargetableComponent_IsTargetableByHumanPlayers");
static_assert(offsetof(TargetableComponent_IsTargetableByHumanPlayers, ReturnValue) == 0x000000, "Member 'TargetableComponent_IsTargetableByHumanPlayers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetableByNonPlayers
// 0x0001 (0x0001 - 0x0000)
struct TargetableComponent_IsTargetableByNonPlayers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetableComponent_IsTargetableByNonPlayers) == 0x000001, "Wrong alignment on TargetableComponent_IsTargetableByNonPlayers");
static_assert(sizeof(TargetableComponent_IsTargetableByNonPlayers) == 0x000001, "Wrong size on TargetableComponent_IsTargetableByNonPlayers");
static_assert(offsetof(TargetableComponent_IsTargetableByNonPlayers, ReturnValue) == 0x000000, "Member 'TargetableComponent_IsTargetableByNonPlayers::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetableComponent.IsTargetableByPawn
// 0x0010 (0x0010 - 0x0000)
struct TargetableComponent_IsTargetableByPawn final
{
public:
	const class APawn*                            Pawn;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetableComponent_IsTargetableByPawn) == 0x000008, "Wrong alignment on TargetableComponent_IsTargetableByPawn");
static_assert(sizeof(TargetableComponent_IsTargetableByPawn) == 0x000010, "Wrong size on TargetableComponent_IsTargetableByPawn");
static_assert(offsetof(TargetableComponent_IsTargetableByPawn, Pawn) == 0x000000, "Member 'TargetableComponent_IsTargetableByPawn::Pawn' has a wrong offset!");
static_assert(offsetof(TargetableComponent_IsTargetableByPawn, ReturnValue) == 0x000008, "Member 'TargetableComponent_IsTargetableByPawn::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.ServerSetBestTarget
// 0x0008 (0x0008 - 0x0000)
struct TargetingComponent_ServerSetBestTarget final
{
public:
	class AActor*                                 NewBestTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_ServerSetBestTarget) == 0x000008, "Wrong alignment on TargetingComponent_ServerSetBestTarget");
static_assert(sizeof(TargetingComponent_ServerSetBestTarget) == 0x000008, "Wrong size on TargetingComponent_ServerSetBestTarget");
static_assert(offsetof(TargetingComponent_ServerSetBestTarget, NewBestTarget) == 0x000000, "Member 'TargetingComponent_ServerSetBestTarget::NewBestTarget' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.DoesBestTargetHaveStimulusForSense
// 0x0018 (0x0018 - 0x0000)
struct TargetingComponent_DoesBestTargetHaveStimulusForSense final
{
public:
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAge;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_DoesBestTargetHaveStimulusForSense) == 0x000008, "Wrong alignment on TargetingComponent_DoesBestTargetHaveStimulusForSense");
static_assert(sizeof(TargetingComponent_DoesBestTargetHaveStimulusForSense) == 0x000018, "Wrong size on TargetingComponent_DoesBestTargetHaveStimulusForSense");
static_assert(offsetof(TargetingComponent_DoesBestTargetHaveStimulusForSense, Sense) == 0x000000, "Member 'TargetingComponent_DoesBestTargetHaveStimulusForSense::Sense' has a wrong offset!");
static_assert(offsetof(TargetingComponent_DoesBestTargetHaveStimulusForSense, MaxAge) == 0x000008, "Member 'TargetingComponent_DoesBestTargetHaveStimulusForSense::MaxAge' has a wrong offset!");
static_assert(offsetof(TargetingComponent_DoesBestTargetHaveStimulusForSense, TargetIndex) == 0x00000C, "Member 'TargetingComponent_DoesBestTargetHaveStimulusForSense::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_DoesBestTargetHaveStimulusForSense, ReturnValue) == 0x000010, "Member 'TargetingComponent_DoesBestTargetHaveStimulusForSense::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetBestAttackTargetLocation
// 0x001C (0x001C - 0x0000)
struct TargetingComponent_GetBestAttackTargetLocation final
{
public:
	struct FVector                                OutTargetVelocity;                                 // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetBestAttackTargetLocation) == 0x000004, "Wrong alignment on TargetingComponent_GetBestAttackTargetLocation");
static_assert(sizeof(TargetingComponent_GetBestAttackTargetLocation) == 0x00001C, "Wrong size on TargetingComponent_GetBestAttackTargetLocation");
static_assert(offsetof(TargetingComponent_GetBestAttackTargetLocation, OutTargetVelocity) == 0x000000, "Member 'TargetingComponent_GetBestAttackTargetLocation::OutTargetVelocity' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestAttackTargetLocation, TargetIndex) == 0x00000C, "Member 'TargetingComponent_GetBestAttackTargetLocation::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestAttackTargetLocation, ReturnValue) == 0x000010, "Member 'TargetingComponent_GetBestAttackTargetLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetBestTargetableComponent
// 0x0010 (0x0010 - 0x0000)
struct TargetingComponent_GetBestTargetableComponent final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetableComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetBestTargetableComponent) == 0x000008, "Wrong alignment on TargetingComponent_GetBestTargetableComponent");
static_assert(sizeof(TargetingComponent_GetBestTargetableComponent) == 0x000010, "Wrong size on TargetingComponent_GetBestTargetableComponent");
static_assert(offsetof(TargetingComponent_GetBestTargetableComponent, TargetIndex) == 0x000000, "Member 'TargetingComponent_GetBestTargetableComponent::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestTargetableComponent, ReturnValue) == 0x000008, "Member 'TargetingComponent_GetBestTargetableComponent::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetBestTargetActor
// 0x0010 (0x0010 - 0x0000)
struct TargetingComponent_GetBestTargetActor final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetBestTargetActor) == 0x000008, "Wrong alignment on TargetingComponent_GetBestTargetActor");
static_assert(sizeof(TargetingComponent_GetBestTargetActor) == 0x000010, "Wrong size on TargetingComponent_GetBestTargetActor");
static_assert(offsetof(TargetingComponent_GetBestTargetActor, TargetIndex) == 0x000000, "Member 'TargetingComponent_GetBestTargetActor::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestTargetActor, ReturnValue) == 0x000008, "Member 'TargetingComponent_GetBestTargetActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetBestTargetInfo
// 0x0398 (0x0398 - 0x0000)
struct TargetingComponent_GetBestTargetInfo final
{
public:
	struct FTargetActorInfo                       TargetInfo;                                        // 0x0000(0x0390)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0390(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0394(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_GetBestTargetInfo) == 0x000008, "Wrong alignment on TargetingComponent_GetBestTargetInfo");
static_assert(sizeof(TargetingComponent_GetBestTargetInfo) == 0x000398, "Wrong size on TargetingComponent_GetBestTargetInfo");
static_assert(offsetof(TargetingComponent_GetBestTargetInfo, TargetInfo) == 0x000000, "Member 'TargetingComponent_GetBestTargetInfo::TargetInfo' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestTargetInfo, TargetIndex) == 0x000390, "Member 'TargetingComponent_GetBestTargetInfo::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestTargetInfo, ReturnValue) == 0x000394, "Member 'TargetingComponent_GetBestTargetInfo::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetBestTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct TargetingComponent_GetBestTargetLocation final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetBestTargetLocation) == 0x000004, "Wrong alignment on TargetingComponent_GetBestTargetLocation");
static_assert(sizeof(TargetingComponent_GetBestTargetLocation) == 0x000010, "Wrong size on TargetingComponent_GetBestTargetLocation");
static_assert(offsetof(TargetingComponent_GetBestTargetLocation, TargetIndex) == 0x000000, "Member 'TargetingComponent_GetBestTargetLocation::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestTargetLocation, ReturnValue) == 0x000004, "Member 'TargetingComponent_GetBestTargetLocation::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetBestThreatActor
// 0x0010 (0x0010 - 0x0000)
struct TargetingComponent_GetBestThreatActor final
{
public:
	bool                                          bRequireFirsthandKnowledge;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetBestThreatActor) == 0x000008, "Wrong alignment on TargetingComponent_GetBestThreatActor");
static_assert(sizeof(TargetingComponent_GetBestThreatActor) == 0x000010, "Wrong size on TargetingComponent_GetBestThreatActor");
static_assert(offsetof(TargetingComponent_GetBestThreatActor, bRequireFirsthandKnowledge) == 0x000000, "Member 'TargetingComponent_GetBestThreatActor::bRequireFirsthandKnowledge' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetBestThreatActor, ReturnValue) == 0x000008, "Member 'TargetingComponent_GetBestThreatActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetTargetActorAt
// 0x0010 (0x0010 - 0x0000)
struct TargetingComponent_GetTargetActorAt final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetTargetActorAt) == 0x000008, "Wrong alignment on TargetingComponent_GetTargetActorAt");
static_assert(sizeof(TargetingComponent_GetTargetActorAt) == 0x000010, "Wrong size on TargetingComponent_GetTargetActorAt");
static_assert(offsetof(TargetingComponent_GetTargetActorAt, TargetIndex) == 0x000000, "Member 'TargetingComponent_GetTargetActorAt::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetActorAt, ReturnValue) == 0x000008, "Member 'TargetingComponent_GetTargetActorAt::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetTargetInfoAt
// 0x03A0 (0x03A0 - 0x0000)
struct TargetingComponent_GetTargetInfoAt final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTargetActorInfo                       TargetInfo;                                        // 0x0008(0x0390)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0398(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_GetTargetInfoAt) == 0x000008, "Wrong alignment on TargetingComponent_GetTargetInfoAt");
static_assert(sizeof(TargetingComponent_GetTargetInfoAt) == 0x0003A0, "Wrong size on TargetingComponent_GetTargetInfoAt");
static_assert(offsetof(TargetingComponent_GetTargetInfoAt, TargetIndex) == 0x000000, "Member 'TargetingComponent_GetTargetInfoAt::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetInfoAt, TargetInfo) == 0x000008, "Member 'TargetingComponent_GetTargetInfoAt::TargetInfo' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetInfoAt, ReturnValue) == 0x000398, "Member 'TargetingComponent_GetTargetInfoAt::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetTargetInfoCount
// 0x0004 (0x0004 - 0x0000)
struct TargetingComponent_GetTargetInfoCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_GetTargetInfoCount) == 0x000004, "Wrong alignment on TargetingComponent_GetTargetInfoCount");
static_assert(sizeof(TargetingComponent_GetTargetInfoCount) == 0x000004, "Wrong size on TargetingComponent_GetTargetInfoCount");
static_assert(offsetof(TargetingComponent_GetTargetInfoCount, ReturnValue) == 0x000000, "Member 'TargetingComponent_GetTargetInfoCount::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetTargetInfoForActor
// 0x03A0 (0x03A0 - 0x0000)
struct TargetingComponent_GetTargetInfoForActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTargetActorInfo                       TargetInfo;                                        // 0x0008(0x0390)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0398(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_GetTargetInfoForActor) == 0x000008, "Wrong alignment on TargetingComponent_GetTargetInfoForActor");
static_assert(sizeof(TargetingComponent_GetTargetInfoForActor) == 0x0003A0, "Wrong size on TargetingComponent_GetTargetInfoForActor");
static_assert(offsetof(TargetingComponent_GetTargetInfoForActor, Actor) == 0x000000, "Member 'TargetingComponent_GetTargetInfoForActor::Actor' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetInfoForActor, TargetInfo) == 0x000008, "Member 'TargetingComponent_GetTargetInfoForActor::TargetInfo' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetInfoForActor, ReturnValue) == 0x000398, "Member 'TargetingComponent_GetTargetInfoForActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.GetTargetLocationForActor
// 0x0018 (0x0018 - 0x0000)
struct TargetingComponent_GetTargetLocationForActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_GetTargetLocationForActor) == 0x000008, "Wrong alignment on TargetingComponent_GetTargetLocationForActor");
static_assert(sizeof(TargetingComponent_GetTargetLocationForActor) == 0x000018, "Wrong size on TargetingComponent_GetTargetLocationForActor");
static_assert(offsetof(TargetingComponent_GetTargetLocationForActor, Actor) == 0x000000, "Member 'TargetingComponent_GetTargetLocationForActor::Actor' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetLocationForActor, TargetLocation) == 0x000008, "Member 'TargetingComponent_GetTargetLocationForActor::TargetLocation' has a wrong offset!");
static_assert(offsetof(TargetingComponent_GetTargetLocationForActor, ReturnValue) == 0x000014, "Member 'TargetingComponent_GetTargetLocationForActor::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.HasTarget
// 0x0010 (0x0010 - 0x0000)
struct TargetingComponent_HasTarget final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_HasTarget) == 0x000008, "Wrong alignment on TargetingComponent_HasTarget");
static_assert(sizeof(TargetingComponent_HasTarget) == 0x000010, "Wrong size on TargetingComponent_HasTarget");
static_assert(offsetof(TargetingComponent_HasTarget, Actor) == 0x000000, "Member 'TargetingComponent_HasTarget::Actor' has a wrong offset!");
static_assert(offsetof(TargetingComponent_HasTarget, ReturnValue) == 0x000008, "Member 'TargetingComponent_HasTarget::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.HasTargets
// 0x0001 (0x0001 - 0x0000)
struct TargetingComponent_HasTargets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TargetingComponent_HasTargets) == 0x000001, "Wrong alignment on TargetingComponent_HasTargets");
static_assert(sizeof(TargetingComponent_HasTargets) == 0x000001, "Wrong size on TargetingComponent_HasTargets");
static_assert(offsetof(TargetingComponent_HasTargets, ReturnValue) == 0x000000, "Member 'TargetingComponent_HasTargets::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.TargetingComponent.IsBestTargetDirectlySensed
// 0x0008 (0x0008 - 0x0000)
struct TargetingComponent_IsBestTargetDirectlySensed final
{
public:
	int32                                         TargetIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TargetingComponent_IsBestTargetDirectlySensed) == 0x000004, "Wrong alignment on TargetingComponent_IsBestTargetDirectlySensed");
static_assert(sizeof(TargetingComponent_IsBestTargetDirectlySensed) == 0x000008, "Wrong size on TargetingComponent_IsBestTargetDirectlySensed");
static_assert(offsetof(TargetingComponent_IsBestTargetDirectlySensed, TargetIndex) == 0x000000, "Member 'TargetingComponent_IsBestTargetDirectlySensed::TargetIndex' has a wrong offset!");
static_assert(offsetof(TargetingComponent_IsBestTargetDirectlySensed, ReturnValue) == 0x000004, "Member 'TargetingComponent_IsBestTargetDirectlySensed::ReturnValue' has a wrong offset!");

// Function GbxGameSystemCore.Team.GetAttitudeToward
// 0x0010 (0x0010 - 0x0000)
struct Team_GetAttitudeToward final
{
public:
	const class UTeam*                            Team;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Team_GetAttitudeToward) == 0x000008, "Wrong alignment on Team_GetAttitudeToward");
static_assert(sizeof(Team_GetAttitudeToward) == 0x000010, "Wrong size on Team_GetAttitudeToward");
static_assert(offsetof(Team_GetAttitudeToward, Team) == 0x000000, "Member 'Team_GetAttitudeToward::Team' has a wrong offset!");
static_assert(offsetof(Team_GetAttitudeToward, ReturnValue) == 0x000008, "Member 'Team_GetAttitudeToward::ReturnValue' has a wrong offset!");

}

