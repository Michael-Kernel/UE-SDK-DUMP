#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxTest

#include "Basic.hpp"

#include "InputCore_structs.hpp"
#include "GbxUI_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum GbxTest.EAutomationUIAction
// NumValues: 0x000F
enum class EAutomationUIAction : uint8
{
	PressDigitalUp                           = 0,
	PressDigitalDown                         = 1,
	PressDigitalLeft                         = 2,
	PressDigitalRight                        = 3,
	PressFaceTop                             = 4,
	PressFaceBottom                          = 5,
	PressFaceLeft                            = 6,
	PressFaceRight                           = 7,
	PressLeftStick                           = 8,
	PressLeftShoulder                        = 9,
	PressLeftTrigger                         = 10,
	PressRightStick                          = 11,
	PressRightShoulder                       = 12,
	PressRightTrigger                        = 13,
	EAutomationUIAction_MAX                  = 14,
};

// Enum GbxTest.EAutomationUIDirection
// NumValues: 0x0005
enum class EAutomationUIDirection : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	EAutomationUIDirection_MAX               = 4,
};

// Enum GbxTest.ECompare
// NumValues: 0x0007
enum class ECompare : uint8
{
	EQ                                       = 0,
	NE                                       = 1,
	GT                                       = 2,
	GE                                       = 3,
	LT                                       = 4,
	LE                                       = 5,
	ECompare_MAX                             = 6,
};

// Enum GbxTest.ESnapshotExecOutput
// NumValues: 0x0003
enum class ESnapshotExecOutput : uint8
{
	Succeeded                                = 0,
	Failed                                   = 1,
	ESnapshotExecOutput_MAX                  = 2,
};

// Enum GbxTest.ESyntaxOption
// NumValues: 0x000B
enum class ESyntaxOption : uint8
{
	E_ICASE                                  = 0,
	E_NOSUBS                                 = 1,
	E_OPTIMIZE                               = 2,
	E_COLLATE                                = 3,
	E_ECMASCRIPT                             = 4,
	E_BASIC                                  = 5,
	E_EXTENDED                               = 6,
	E_AWK                                    = 7,
	E_GREP                                   = 8,
	E_EGREP                                  = 9,
	E_MAX                                    = 10,
};

// Enum GbxTest.ETestIssueType
// NumValues: 0x0007
enum class ETestIssueType : uint8
{
	Info                                     = 0,
	Skipped                                  = 1,
	Warning                                  = 2,
	Bug                                      = 3,
	Critical                                 = 4,
	Count                                    = 5,
	ETestIssueType_MAX                       = 6,
};

// Enum GbxTest.ECollectionType
// NumValues: 0x0005
enum class ECollectionType : uint8
{
	ECT_System                               = 0,
	ECT_Local                                = 1,
	ECT_Private                              = 2,
	ECT_Shared                               = 3,
	ECT_MAX                                  = 4,
};

// Enum GbxTest.EGbxTestPlanOutput
// NumValues: 0x0004
enum class EGbxTestPlanOutput : uint8
{
	FullName                                 = 0,
	Console                                  = 1,
	Commandline                              = 2,
	EGbxTestPlanOutput_MAX                   = 3,
};

// Enum GbxTest.EGbxTestPlan
// NumValues: 0x0004
enum class EGbxTestPlan : uint8
{
	None                                     = 0,
	ABT                                      = 1,
	Nightly                                  = 2,
	EGbxTestPlan_MAX                         = 3,
};

// Enum GbxTest.EDiscovery
// NumValues: 0x000B
enum class EDiscovery : uint8
{
	Single                                   = 0,
	Ignore                                   = 1,
	AllContent                               = 2,
	AllQAMaps                                = 3,
	AllPersistentGameMaps                    = 4,
	AllGameMissions                          = 5,
	HierarchicalCommands                     = 6,
	AllTraitContent                          = 7,
	Custom                                   = 8,
	Count                                    = 9,
	EDiscovery_MAX                           = 10,
};

// ScriptStruct GbxTest.OptionalValue
// 0x0001 (0x0001 - 0x0000)
struct FOptionalValue
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionalValue) == 0x000001, "Wrong alignment on FOptionalValue");
static_assert(sizeof(FOptionalValue) == 0x000001, "Wrong size on FOptionalValue");
static_assert(offsetof(FOptionalValue, bEnabled) == 0x000000, "Member 'FOptionalValue::bEnabled' has a wrong offset!");

// ScriptStruct GbxTest.OptionalName
// 0x000F (0x0010 - 0x0001)
struct alignas(0x08) FOptionalName : public FOptionalValue
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionalName) == 0x000008, "Wrong alignment on FOptionalName");
static_assert(sizeof(FOptionalName) == 0x000010, "Wrong size on FOptionalName");
static_assert(offsetof(FOptionalName, Value) == 0x000008, "Member 'FOptionalName::Value' has a wrong offset!");

// ScriptStruct GbxTest.OptionalTextureLODGroup
// 0x0000 (0x0010 - 0x0010)
struct FOptionalTextureLODGroup final : public FOptionalName
{
};
static_assert(alignof(FOptionalTextureLODGroup) == 0x000008, "Wrong alignment on FOptionalTextureLODGroup");
static_assert(sizeof(FOptionalTextureLODGroup) == 0x000010, "Wrong size on FOptionalTextureLODGroup");

// ScriptStruct GbxTest.AutomationMenuFocusInfo
// 0x0030 (0x0030 - 0x0000)
struct FAutomationMenuFocusInfo final
{
public:
	class FName                                   ClassName;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectName;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectNum;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Label;                                             // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxButtonType                             ButtonType;                                        // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsButton;                                          // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsListCell;                                        // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsListItem;                                        // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGridList;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutomationMenuFocusInfo) == 0x000008, "Wrong alignment on FAutomationMenuFocusInfo");
static_assert(sizeof(FAutomationMenuFocusInfo) == 0x000030, "Wrong size on FAutomationMenuFocusInfo");
static_assert(offsetof(FAutomationMenuFocusInfo, ClassName) == 0x000000, "Member 'FAutomationMenuFocusInfo::ClassName' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, ObjectName) == 0x000008, "Member 'FAutomationMenuFocusInfo::ObjectName' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, ObjectNum) == 0x000010, "Member 'FAutomationMenuFocusInfo::ObjectNum' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, Index) == 0x000014, "Member 'FAutomationMenuFocusInfo::Index' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, Label) == 0x000018, "Member 'FAutomationMenuFocusInfo::Label' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, ButtonType) == 0x000028, "Member 'FAutomationMenuFocusInfo::ButtonType' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, IsButton) == 0x000029, "Member 'FAutomationMenuFocusInfo::IsButton' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, IsListCell) == 0x00002A, "Member 'FAutomationMenuFocusInfo::IsListCell' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, IsListItem) == 0x00002B, "Member 'FAutomationMenuFocusInfo::IsListItem' has a wrong offset!");
static_assert(offsetof(FAutomationMenuFocusInfo, IsGridList) == 0x00002C, "Member 'FAutomationMenuFocusInfo::IsGridList' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoStaticMesh
// 0x0030 (0x0030 - 0x0000)
struct FTestInfoStaticMesh final
{
public:
	TArray<class UAssetTraitStaticMesh*>          AssetTraits;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PrimitiveCount;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMapResolution;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMapIndex;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LODGroupName;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCollision;                                   // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoStaticMesh) == 0x000008, "Wrong alignment on FTestInfoStaticMesh");
static_assert(sizeof(FTestInfoStaticMesh) == 0x000030, "Wrong size on FTestInfoStaticMesh");
static_assert(offsetof(FTestInfoStaticMesh, AssetTraits) == 0x000000, "Member 'FTestInfoStaticMesh::AssetTraits' has a wrong offset!");
static_assert(offsetof(FTestInfoStaticMesh, PrimitiveCount) == 0x000010, "Member 'FTestInfoStaticMesh::PrimitiveCount' has a wrong offset!");
static_assert(offsetof(FTestInfoStaticMesh, LightMapResolution) == 0x000014, "Member 'FTestInfoStaticMesh::LightMapResolution' has a wrong offset!");
static_assert(offsetof(FTestInfoStaticMesh, LightMapIndex) == 0x000018, "Member 'FTestInfoStaticMesh::LightMapIndex' has a wrong offset!");
static_assert(offsetof(FTestInfoStaticMesh, LODGroupName) == 0x000020, "Member 'FTestInfoStaticMesh::LODGroupName' has a wrong offset!");
static_assert(offsetof(FTestInfoStaticMesh, CastShadow) == 0x000028, "Member 'FTestInfoStaticMesh::CastShadow' has a wrong offset!");
static_assert(offsetof(FTestInfoStaticMesh, EnableCollision) == 0x000029, "Member 'FTestInfoStaticMesh::EnableCollision' has a wrong offset!");

// ScriptStruct GbxTest.OptionalTextureCompressionMethod
// 0x0000 (0x0010 - 0x0010)
struct FOptionalTextureCompressionMethod final : public FOptionalName
{
};
static_assert(alignof(FOptionalTextureCompressionMethod) == 0x000008, "Wrong alignment on FOptionalTextureCompressionMethod");
static_assert(sizeof(FOptionalTextureCompressionMethod) == 0x000010, "Wrong size on FOptionalTextureCompressionMethod");

// ScriptStruct GbxTest.OptionalLODGroup
// 0x0000 (0x0010 - 0x0010)
struct FOptionalLODGroup final : public FOptionalName
{
};
static_assert(alignof(FOptionalLODGroup) == 0x000008, "Wrong alignment on FOptionalLODGroup");
static_assert(sizeof(FOptionalLODGroup) == 0x000010, "Wrong size on FOptionalLODGroup");

// ScriptStruct GbxTest.OptionalFloat
// 0x0007 (0x0008 - 0x0001)
struct FOptionalFloat final : public FOptionalValue
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionalFloat) == 0x000004, "Wrong alignment on FOptionalFloat");
static_assert(sizeof(FOptionalFloat) == 0x000008, "Wrong size on FOptionalFloat");
static_assert(offsetof(FOptionalFloat, Value) == 0x000004, "Member 'FOptionalFloat::Value' has a wrong offset!");

// ScriptStruct GbxTest.OptionalInt32
// 0x0007 (0x0008 - 0x0001)
struct FOptionalInt32 final : public FOptionalValue
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionalInt32) == 0x000004, "Wrong alignment on FOptionalInt32");
static_assert(sizeof(FOptionalInt32) == 0x000008, "Wrong size on FOptionalInt32");
static_assert(offsetof(FOptionalInt32, Value) == 0x000004, "Member 'FOptionalInt32::Value' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoParticleEmitter
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FTestInfoParticleEmitter final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EmitterName;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SuperMaxDrawCount;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinUnitScalar;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasLowestLOD;                                     // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAnimTrailData;                                 // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasGpuSpriteData;                                 // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMeshData;                                      // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRibbonOrBeamData;                              // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRequiredModule;                                // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnPerUnitModule;                            // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLifetimeModule;                                // 0x0027(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLightModule;                                   // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxDrawCountDisabled;                          // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInfiniteMaxDrawCount;                          // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInfiniteLifetime;                              // 0x002B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillOnCompletedNotSet;                            // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInverseSquaredFalloffSet;                      // 0x002D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoParticleEmitter) == 0x000008, "Wrong alignment on FTestInfoParticleEmitter");
static_assert(sizeof(FTestInfoParticleEmitter) == 0x000030, "Wrong size on FTestInfoParticleEmitter");
static_assert(offsetof(FTestInfoParticleEmitter, EmitterIndex) == 0x000000, "Member 'FTestInfoParticleEmitter::EmitterIndex' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, EmitterName) == 0x000008, "Member 'FTestInfoParticleEmitter::EmitterName' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, SuperMaxDrawCount) == 0x000014, "Member 'FTestInfoParticleEmitter::SuperMaxDrawCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, MinUnitScalar) == 0x000018, "Member 'FTestInfoParticleEmitter::MinUnitScalar' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasLowestLOD) == 0x000020, "Member 'FTestInfoParticleEmitter::bHasLowestLOD' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasAnimTrailData) == 0x000021, "Member 'FTestInfoParticleEmitter::bHasAnimTrailData' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasGpuSpriteData) == 0x000022, "Member 'FTestInfoParticleEmitter::bHasGpuSpriteData' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasMeshData) == 0x000023, "Member 'FTestInfoParticleEmitter::bHasMeshData' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasRibbonOrBeamData) == 0x000024, "Member 'FTestInfoParticleEmitter::bHasRibbonOrBeamData' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasRequiredModule) == 0x000025, "Member 'FTestInfoParticleEmitter::bHasRequiredModule' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasSpawnPerUnitModule) == 0x000026, "Member 'FTestInfoParticleEmitter::bHasSpawnPerUnitModule' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasLifetimeModule) == 0x000027, "Member 'FTestInfoParticleEmitter::bHasLifetimeModule' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasLightModule) == 0x000028, "Member 'FTestInfoParticleEmitter::bHasLightModule' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bUseMaxDrawCountDisabled) == 0x000029, "Member 'FTestInfoParticleEmitter::bUseMaxDrawCountDisabled' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasInfiniteMaxDrawCount) == 0x00002A, "Member 'FTestInfoParticleEmitter::bHasInfiniteMaxDrawCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bHasInfiniteLifetime) == 0x00002B, "Member 'FTestInfoParticleEmitter::bHasInfiniteLifetime' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bKillOnCompletedNotSet) == 0x00002C, "Member 'FTestInfoParticleEmitter::bKillOnCompletedNotSet' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleEmitter, bUseInverseSquaredFalloffSet) == 0x00002D, "Member 'FTestInfoParticleEmitter::bUseInverseSquaredFalloffSet' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoParticleSystem
// 0x0060 (0x0060 - 0x0000)
struct FTestInfoParticleSystem final
{
public:
	TArray<class UAssetTraitParticleSystem*>      AssetTraits;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTestInfoParticleEmitter>       EmitterInfo;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FixedRelativeBoundsSize;                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTime;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupTime;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODDistanceCheckTime;                              // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemplateCost;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterCount;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinModuleCount;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxModuleCount;                                    // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODCount;                                          // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimTrailDataCount;                                // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GpuSpriteDataCount;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeshDataCount;                                     // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RibbonOrBeamDataCount;                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesFixedRelativeBounds;                          // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZAxisOrientedTowardsCamera;                       // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllEmittersHaveRequiredModules;                   // 0x0056(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllEmittersHaveLowestLOD;                         // 0x0057(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillFlagsNotSet;                                  // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoParticleSystem) == 0x000008, "Wrong alignment on FTestInfoParticleSystem");
static_assert(sizeof(FTestInfoParticleSystem) == 0x000060, "Wrong size on FTestInfoParticleSystem");
static_assert(offsetof(FTestInfoParticleSystem, AssetTraits) == 0x000000, "Member 'FTestInfoParticleSystem::AssetTraits' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, EmitterInfo) == 0x000010, "Member 'FTestInfoParticleSystem::EmitterInfo' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, FixedRelativeBoundsSize) == 0x000020, "Member 'FTestInfoParticleSystem::FixedRelativeBoundsSize' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, UpdateTime) == 0x000024, "Member 'FTestInfoParticleSystem::UpdateTime' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, WarmupTime) == 0x000028, "Member 'FTestInfoParticleSystem::WarmupTime' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, LODDistanceCheckTime) == 0x00002C, "Member 'FTestInfoParticleSystem::LODDistanceCheckTime' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, TemplateCost) == 0x000030, "Member 'FTestInfoParticleSystem::TemplateCost' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, EmitterCount) == 0x000034, "Member 'FTestInfoParticleSystem::EmitterCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, MinModuleCount) == 0x000038, "Member 'FTestInfoParticleSystem::MinModuleCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, MaxModuleCount) == 0x00003C, "Member 'FTestInfoParticleSystem::MaxModuleCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, LODCount) == 0x000040, "Member 'FTestInfoParticleSystem::LODCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, AnimTrailDataCount) == 0x000044, "Member 'FTestInfoParticleSystem::AnimTrailDataCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, GpuSpriteDataCount) == 0x000048, "Member 'FTestInfoParticleSystem::GpuSpriteDataCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, MeshDataCount) == 0x00004C, "Member 'FTestInfoParticleSystem::MeshDataCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, RibbonOrBeamDataCount) == 0x000050, "Member 'FTestInfoParticleSystem::RibbonOrBeamDataCount' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, bUsesFixedRelativeBounds) == 0x000054, "Member 'FTestInfoParticleSystem::bUsesFixedRelativeBounds' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, bZAxisOrientedTowardsCamera) == 0x000055, "Member 'FTestInfoParticleSystem::bZAxisOrientedTowardsCamera' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, bAllEmittersHaveRequiredModules) == 0x000056, "Member 'FTestInfoParticleSystem::bAllEmittersHaveRequiredModules' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, bAllEmittersHaveLowestLOD) == 0x000057, "Member 'FTestInfoParticleSystem::bAllEmittersHaveLowestLOD' has a wrong offset!");
static_assert(offsetof(FTestInfoParticleSystem, bKillFlagsNotSet) == 0x000058, "Member 'FTestInfoParticleSystem::bKillFlagsNotSet' has a wrong offset!");

// ScriptStruct GbxTest.OptionalBool
// 0x0001 (0x0002 - 0x0001)
struct FOptionalBool final : public FOptionalValue
{
public:
	bool                                          Value;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionalBool) == 0x000001, "Wrong alignment on FOptionalBool");
static_assert(sizeof(FOptionalBool) == 0x000002, "Wrong size on FOptionalBool");
static_assert(offsetof(FOptionalBool, Value) == 0x000001, "Member 'FOptionalBool::Value' has a wrong offset!");

// ScriptStruct GbxTest.MapParameters
// 0x0050 (0x0050 - 0x0000)
struct FMapParameters final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Density;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLighting;                                         // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecular;                                         // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gamma;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeX;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeY;                                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeZ;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIndexX;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIndexY;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutputPattern;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapParameters) == 0x000008, "Wrong alignment on FMapParameters");
static_assert(sizeof(FMapParameters) == 0x000050, "Wrong size on FMapParameters");
static_assert(offsetof(FMapParameters, Density) == 0x000018, "Member 'FMapParameters::Density' has a wrong offset!");
static_assert(offsetof(FMapParameters, Width) == 0x00001C, "Member 'FMapParameters::Width' has a wrong offset!");
static_assert(offsetof(FMapParameters, Height) == 0x000020, "Member 'FMapParameters::Height' has a wrong offset!");
static_assert(offsetof(FMapParameters, bLighting) == 0x000024, "Member 'FMapParameters::bLighting' has a wrong offset!");
static_assert(offsetof(FMapParameters, bSpecular) == 0x000025, "Member 'FMapParameters::bSpecular' has a wrong offset!");
static_assert(offsetof(FMapParameters, Gamma) == 0x000028, "Member 'FMapParameters::Gamma' has a wrong offset!");
static_assert(offsetof(FMapParameters, VolumeX) == 0x00002C, "Member 'FMapParameters::VolumeX' has a wrong offset!");
static_assert(offsetof(FMapParameters, VolumeY) == 0x000030, "Member 'FMapParameters::VolumeY' has a wrong offset!");
static_assert(offsetof(FMapParameters, VolumeZ) == 0x000034, "Member 'FMapParameters::VolumeZ' has a wrong offset!");
static_assert(offsetof(FMapParameters, StartIndexX) == 0x000038, "Member 'FMapParameters::StartIndexX' has a wrong offset!");
static_assert(offsetof(FMapParameters, StartIndexY) == 0x00003C, "Member 'FMapParameters::StartIndexY' has a wrong offset!");
static_assert(offsetof(FMapParameters, OutputPattern) == 0x000040, "Member 'FMapParameters::OutputPattern' has a wrong offset!");

// ScriptStruct GbxTest.Regex
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FRegex final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegex) == 0x000008, "Wrong alignment on FRegex");
static_assert(sizeof(FRegex) == 0x000028, "Wrong size on FRegex");

// ScriptStruct GbxTest.GbxTestHierarchicalCommandL3
// 0x0020 (0x0020 - 0x0000)
struct FGbxTestHierarchicalCommandL3 final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestCommand;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxTestHierarchicalCommandL3) == 0x000008, "Wrong alignment on FGbxTestHierarchicalCommandL3");
static_assert(sizeof(FGbxTestHierarchicalCommandL3) == 0x000020, "Wrong size on FGbxTestHierarchicalCommandL3");
static_assert(offsetof(FGbxTestHierarchicalCommandL3, DisplayName) == 0x000000, "Member 'FGbxTestHierarchicalCommandL3::DisplayName' has a wrong offset!");
static_assert(offsetof(FGbxTestHierarchicalCommandL3, TestCommand) == 0x000010, "Member 'FGbxTestHierarchicalCommandL3::TestCommand' has a wrong offset!");

// ScriptStruct GbxTest.GbxTestHierarchicalCommandL2
// 0x0030 (0x0030 - 0x0000)
struct FGbxTestHierarchicalCommandL2 final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestCommand;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxTestHierarchicalCommandL3>  SubCommands;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxTestHierarchicalCommandL2) == 0x000008, "Wrong alignment on FGbxTestHierarchicalCommandL2");
static_assert(sizeof(FGbxTestHierarchicalCommandL2) == 0x000030, "Wrong size on FGbxTestHierarchicalCommandL2");
static_assert(offsetof(FGbxTestHierarchicalCommandL2, DisplayName) == 0x000000, "Member 'FGbxTestHierarchicalCommandL2::DisplayName' has a wrong offset!");
static_assert(offsetof(FGbxTestHierarchicalCommandL2, TestCommand) == 0x000010, "Member 'FGbxTestHierarchicalCommandL2::TestCommand' has a wrong offset!");
static_assert(offsetof(FGbxTestHierarchicalCommandL2, SubCommands) == 0x000020, "Member 'FGbxTestHierarchicalCommandL2::SubCommands' has a wrong offset!");

// ScriptStruct GbxTest.GbxTestHierarchicalCommandL1
// 0x0030 (0x0030 - 0x0000)
struct FGbxTestHierarchicalCommandL1 final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestCommand;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxTestHierarchicalCommandL2>  SubCommands;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxTestHierarchicalCommandL1) == 0x000008, "Wrong alignment on FGbxTestHierarchicalCommandL1");
static_assert(sizeof(FGbxTestHierarchicalCommandL1) == 0x000030, "Wrong size on FGbxTestHierarchicalCommandL1");
static_assert(offsetof(FGbxTestHierarchicalCommandL1, DisplayName) == 0x000000, "Member 'FGbxTestHierarchicalCommandL1::DisplayName' has a wrong offset!");
static_assert(offsetof(FGbxTestHierarchicalCommandL1, TestCommand) == 0x000010, "Member 'FGbxTestHierarchicalCommandL1::TestCommand' has a wrong offset!");
static_assert(offsetof(FGbxTestHierarchicalCommandL1, SubCommands) == 0x000020, "Member 'FGbxTestHierarchicalCommandL1::SubCommands' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoMaterial
// 0x0020 (0x0020 - 0x0000)
struct FTestInfoMaterial final
{
public:
	TArray<class UAssetTraitMaterial*>            AssetTraits;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUsedWithSkeletalMesh;                             // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithParticleSprites;                          // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithBeamTrails;                               // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithMeshParticles;                            // 0x0013(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithStaticLighting;                           // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithMorphTargets;                             // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithSplineMesh;                               // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithInstancedStaticMeshes;                    // 0x0017(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsedWithClothing;                                 // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPhysMatSet;                                    // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoMaterial) == 0x000008, "Wrong alignment on FTestInfoMaterial");
static_assert(sizeof(FTestInfoMaterial) == 0x000020, "Wrong size on FTestInfoMaterial");
static_assert(offsetof(FTestInfoMaterial, AssetTraits) == 0x000000, "Member 'FTestInfoMaterial::AssetTraits' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithSkeletalMesh) == 0x000010, "Member 'FTestInfoMaterial::bUsedWithSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithParticleSprites) == 0x000011, "Member 'FTestInfoMaterial::bUsedWithParticleSprites' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithBeamTrails) == 0x000012, "Member 'FTestInfoMaterial::bUsedWithBeamTrails' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithMeshParticles) == 0x000013, "Member 'FTestInfoMaterial::bUsedWithMeshParticles' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithStaticLighting) == 0x000014, "Member 'FTestInfoMaterial::bUsedWithStaticLighting' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithMorphTargets) == 0x000015, "Member 'FTestInfoMaterial::bUsedWithMorphTargets' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithSplineMesh) == 0x000016, "Member 'FTestInfoMaterial::bUsedWithSplineMesh' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithInstancedStaticMeshes) == 0x000017, "Member 'FTestInfoMaterial::bUsedWithInstancedStaticMeshes' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bUsedWithClothing) == 0x000018, "Member 'FTestInfoMaterial::bUsedWithClothing' has a wrong offset!");
static_assert(offsetof(FTestInfoMaterial, bHasPhysMatSet) == 0x000019, "Member 'FTestInfoMaterial::bHasPhysMatSet' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoMeshLOD
// 0x001C (0x001C - 0x0000)
struct FTestInfoMeshLOD final
{
public:
	int32                                         LODIndex;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertexCount;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TexCoordCount;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionCount;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSize;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDegenerateSections;                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoMeshLOD) == 0x000004, "Wrong alignment on FTestInfoMeshLOD");
static_assert(sizeof(FTestInfoMeshLOD) == 0x00001C, "Wrong size on FTestInfoMeshLOD");
static_assert(offsetof(FTestInfoMeshLOD, LODIndex) == 0x000000, "Member 'FTestInfoMeshLOD::LODIndex' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLOD, TriangleCount) == 0x000004, "Member 'FTestInfoMeshLOD::TriangleCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLOD, VertexCount) == 0x000008, "Member 'FTestInfoMeshLOD::VertexCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLOD, TexCoordCount) == 0x00000C, "Member 'FTestInfoMeshLOD::TexCoordCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLOD, SectionCount) == 0x000010, "Member 'FTestInfoMeshLOD::SectionCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLOD, ScreenSize) == 0x000014, "Member 'FTestInfoMeshLOD::ScreenSize' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLOD, bHasDegenerateSections) == 0x000018, "Member 'FTestInfoMeshLOD::bHasDegenerateSections' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoMesh
// 0x0024 (0x0024 - 0x0000)
struct FTestInfoMesh final
{
public:
	struct FBoxSphereBounds                       Bounds;                                            // 0x0000(0x001C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SocketCount;                                       // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasSockets;                                        // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoMesh) == 0x000004, "Wrong alignment on FTestInfoMesh");
static_assert(sizeof(FTestInfoMesh) == 0x000024, "Wrong size on FTestInfoMesh");
static_assert(offsetof(FTestInfoMesh, Bounds) == 0x000000, "Member 'FTestInfoMesh::Bounds' has a wrong offset!");
static_assert(offsetof(FTestInfoMesh, SocketCount) == 0x00001C, "Member 'FTestInfoMesh::SocketCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMesh, HasSockets) == 0x000020, "Member 'FTestInfoMesh::HasSockets' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoMeshLODSummary
// 0x0024 (0x0024 - 0x0000)
struct FTestInfoMeshLODSummary final
{
public:
	int32                                         LODCount;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODMaxTriangleCount;                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODMaxVertexCount;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODMinTexCoordCount;                               // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODMaxTexCoordCount;                               // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODMinSectionCount;                                // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODMaxSectionCount;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODMinScreenSize;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODMaxScreenSize;                                  // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTestInfoMeshLODSummary) == 0x000004, "Wrong alignment on FTestInfoMeshLODSummary");
static_assert(sizeof(FTestInfoMeshLODSummary) == 0x000024, "Wrong size on FTestInfoMeshLODSummary");
static_assert(offsetof(FTestInfoMeshLODSummary, LODCount) == 0x000000, "Member 'FTestInfoMeshLODSummary::LODCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMaxTriangleCount) == 0x000004, "Member 'FTestInfoMeshLODSummary::LODMaxTriangleCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMaxVertexCount) == 0x000008, "Member 'FTestInfoMeshLODSummary::LODMaxVertexCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMinTexCoordCount) == 0x00000C, "Member 'FTestInfoMeshLODSummary::LODMinTexCoordCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMaxTexCoordCount) == 0x000010, "Member 'FTestInfoMeshLODSummary::LODMaxTexCoordCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMinSectionCount) == 0x000014, "Member 'FTestInfoMeshLODSummary::LODMinSectionCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMaxSectionCount) == 0x000018, "Member 'FTestInfoMeshLODSummary::LODMaxSectionCount' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMinScreenSize) == 0x00001C, "Member 'FTestInfoMeshLODSummary::LODMinScreenSize' has a wrong offset!");
static_assert(offsetof(FTestInfoMeshLODSummary, LODMaxScreenSize) == 0x000020, "Member 'FTestInfoMeshLODSummary::LODMaxScreenSize' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoSkeletalMesh
// 0x0018 (0x0018 - 0x0000)
struct FTestInfoSkeletalMesh final
{
public:
	TArray<class UAssetTraitSkeletalMesh*>        AssetTraits;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Placeholder;                                       // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoSkeletalMesh) == 0x000008, "Wrong alignment on FTestInfoSkeletalMesh");
static_assert(sizeof(FTestInfoSkeletalMesh) == 0x000018, "Wrong size on FTestInfoSkeletalMesh");
static_assert(offsetof(FTestInfoSkeletalMesh, AssetTraits) == 0x000000, "Member 'FTestInfoSkeletalMesh::AssetTraits' has a wrong offset!");
static_assert(offsetof(FTestInfoSkeletalMesh, Placeholder) == 0x000010, "Member 'FTestInfoSkeletalMesh::Placeholder' has a wrong offset!");

// ScriptStruct GbxTest.TestInfoTexture
// 0x0028 (0x0028 - 0x0000)
struct FTestInfoTexture final
{
public:
	TArray<class UAssetTraitTexture*>             AssetTraits;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   CompressionMethod;                                 // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LODGroup;                                          // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODBias;                                           // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasAlpha;                                          // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HassRGB;                                           // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestInfoTexture) == 0x000008, "Wrong alignment on FTestInfoTexture");
static_assert(sizeof(FTestInfoTexture) == 0x000028, "Wrong size on FTestInfoTexture");
static_assert(offsetof(FTestInfoTexture, AssetTraits) == 0x000000, "Member 'FTestInfoTexture::AssetTraits' has a wrong offset!");
static_assert(offsetof(FTestInfoTexture, CompressionMethod) == 0x000010, "Member 'FTestInfoTexture::CompressionMethod' has a wrong offset!");
static_assert(offsetof(FTestInfoTexture, LODGroup) == 0x000018, "Member 'FTestInfoTexture::LODGroup' has a wrong offset!");
static_assert(offsetof(FTestInfoTexture, LODBias) == 0x000020, "Member 'FTestInfoTexture::LODBias' has a wrong offset!");
static_assert(offsetof(FTestInfoTexture, HasAlpha) == 0x000024, "Member 'FTestInfoTexture::HasAlpha' has a wrong offset!");
static_assert(offsetof(FTestInfoTexture, HassRGB) == 0x000025, "Member 'FTestInfoTexture::HassRGB' has a wrong offset!");

// ScriptStruct GbxTest.GbxTestInputAction
// 0x0030 (0x0030 - 0x0000)
struct FGbxTestInputAction final
{
public:
	EInputEvent                                   InputEvent;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   InputKey;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountDepressed;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountDelta;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxTestInputAction) == 0x000008, "Wrong alignment on FGbxTestInputAction");
static_assert(sizeof(FGbxTestInputAction) == 0x000030, "Wrong size on FGbxTestInputAction");
static_assert(offsetof(FGbxTestInputAction, InputEvent) == 0x000000, "Member 'FGbxTestInputAction::InputEvent' has a wrong offset!");
static_assert(offsetof(FGbxTestInputAction, InputKey) == 0x000008, "Member 'FGbxTestInputAction::InputKey' has a wrong offset!");
static_assert(offsetof(FGbxTestInputAction, StartTime) == 0x000020, "Member 'FGbxTestInputAction::StartTime' has a wrong offset!");
static_assert(offsetof(FGbxTestInputAction, LifeTime) == 0x000024, "Member 'FGbxTestInputAction::LifeTime' has a wrong offset!");
static_assert(offsetof(FGbxTestInputAction, AmountDepressed) == 0x000028, "Member 'FGbxTestInputAction::AmountDepressed' has a wrong offset!");
static_assert(offsetof(FGbxTestInputAction, AmountDelta) == 0x00002C, "Member 'FGbxTestInputAction::AmountDelta' has a wrong offset!");

}

