#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPChar_AI

#include "Basic.hpp"

#include "OakGame_structs.hpp"
#include "OakGame_classes.hpp"
#include "Engine_structs.hpp"
#include "Enum_AIThrowAtStyle_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BPChar_AI.BPChar_AI_C
// 0x0030 (0x2350 - 0x2320)
#pragma pack(push, 0x1)
class alignas(0x10) ABPChar_AI_C : public AOakCharacter_Default
{
public:
	uint8                                         Pad_2318[0x8];                                     // 0x2318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x2320(0x0008)(Transient, DuplicateTransient)
	class UOakCharacterSoundLogicComponent*       OakCharacterSoundLogic;                            // 0x2328(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_OakAttributeComponent_C*            BP_OakAttributeComponent;                          // 0x2330(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 VehicleDriverAction;                               // 0x2338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class UVehicleDrivingDataAsset*               VehicleDrivingData;                                // 0x2340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)

public:
	void ExecuteUbergraph_BPChar_AI(int32 EntryPoint);
	void ReceiveBeginPlay();
	void AIShield_Drop(bool RequestNewShield);
	void AIShield_ThrowAtLocation(const struct FVector& LocationToThrowAt, float ThrowSpeed, float ThrowAnglePercentage, bool RequestNewShield, bool SpawnIfDoesntExist);
	void AIShield_ThrowAtActor(class AActor* ActorToThrowAt, float ThrowSpeed, float ThrowAnglePercentage, class FName ActorSocket, const struct FVector& ActorOffset, const struct FRotator& ThrowAngleOffset, float MaxPrediction, bool RequestNewShield, bool SpawnIfDoesntExist);
	void AIShield_ThrowAtTarget(float ThrowSpeed, float ThrowAnglePercent, class FName TargetSocket, const struct FVector& TargetOffset, const struct FRotator& ThrowAngleOffset, float MaxPrediction, bool RequestNewShield, bool SpawnIfDoesntExist);
	void AIShield_Spawn();
	void AIShield_SetNewShieldClass(class UClass* NewShieldClass);
	void AIExplosive_SetNewExplosiveClass(class UClass* NewExplosiveClass);
	void AIMelee_SetNewMeleeWeaponClass(class UClass* NewMeleeWeaponClass);
	void AIMelee_ThrowAtLocation(const struct FVector& LocationToThrowAt, float ThrowSpeed, float ThrowAnglePercentage, bool RequestNewMeleeWeapon, bool SpawnIfDoesntExist);
	void AIMelee_ThrowAtActor(class AActor* ActorToThrowAt, float ThrowSpeed, float ThrowAnglePercentage, class FName ActorSocket, const struct FVector& ActorOffset, const struct FRotator& ThrowAngleOffset, float MaxPrediction, bool RequestNewMeleeWeapon, bool SpawnIfDoesntExist);
	void AIExplosive_ThrowAtLocation(const struct FVector& LocationToThrowAt, float ThrowSpeed, float ThrowAnglePercentage, bool RequestNewExplosive, bool SpawnIfDoesntExist);
	void AIExplosive_ThrowAtActor(class AActor* ActorToThrowAt, float ThrowSpeed, float ThrowAnglePercentage, class FName ActorSocket, const struct FVector& ActorOffset, const struct FRotator& ThrowAngleOffset, float MaxPrediction, bool RequestNewExplosive, bool SpawnIfDoesntExist);
	void AIExplosive_Drop(bool RequestNewExplosive, class AActor* InstigatorOverride);
	void AIExplosive_Detonate(bool KillSelfOnDetonate, bool RequestNewExplosive, class AActor* InstigatorOverride);
	void AIExplosive_ThrowAtTarget(float ThrowSpeed, float ThrowAnglePercent, class FName TargetSocket, const struct FVector& TargetOffset, const struct FRotator& ThrowAngleOffset, float MaxPrediction, bool RequestNewExplosive, bool SpawnIfDoesn_tExist);
	void AIExplosive_Prime();
	void AIExplosive_Spawn();
	void AIMelee_ThrowAtTarget(float ThrowSpeed, float ThrowAnglePercent, class FName TargetSocket, const struct FVector& TargetOffset, const struct FRotator& ThrowAngleOffset, float MaxPrediction, bool RequestNewMeleeWeapon, bool SpawnIfDoesntExist);
	void AIMelee_Spawn();
	void AIMelee_Drop(bool RequestNewMeleeWeapon);
	void UserConstructionScript();
	void AIMelee_GetElementalTypeFromMeleeWeapon(EOakElementalType* MeleeWeaponElement);
	void AIStolenProj_AttemptLerpToSocket(class FName SocketToLerpTo, float LerpDuration, bool* Success);
	void AIStolenProj_AttemptReturnTo(Enum_AIThrowAtStyle ReturnTo, class FName TargetSocket, float MaxPrediction, float Speed, float AnglePercent, const struct FRotator& DirectionOffset, const struct FVector& TargetOffset, class AActor* SpecifiedActor, const struct FVector& WorldLocation, bool* Success);
	void AIStolenProj_AttemptAttach(class FName SocketName, bool* Success);
	void AIStolenProj_AttemptDestroy(bool* Success);
	void AIStolenProj_AttemptDisarm(bool* Success);
	void AIStolenProj_GetElementalTypeFromStolenProjectile(EOakElementalType* StolenProjectileElement);
	void AIStolenProj_AttemptDetonate(bool* Success);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BPChar_AI_C">();
	}
	static class ABPChar_AI_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABPChar_AI_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABPChar_AI_C) == 0x000010, "Wrong alignment on ABPChar_AI_C");
static_assert(sizeof(ABPChar_AI_C) == 0x002350, "Wrong size on ABPChar_AI_C");
static_assert(offsetof(ABPChar_AI_C, UberGraphFrame) == 0x002320, "Member 'ABPChar_AI_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABPChar_AI_C, OakCharacterSoundLogic) == 0x002328, "Member 'ABPChar_AI_C::OakCharacterSoundLogic' has a wrong offset!");
static_assert(offsetof(ABPChar_AI_C, BP_OakAttributeComponent) == 0x002330, "Member 'ABPChar_AI_C::BP_OakAttributeComponent' has a wrong offset!");
static_assert(offsetof(ABPChar_AI_C, VehicleDriverAction) == 0x002338, "Member 'ABPChar_AI_C::VehicleDriverAction' has a wrong offset!");
static_assert(offsetof(ABPChar_AI_C, VehicleDrivingData) == 0x002340, "Member 'ABPChar_AI_C::VehicleDrivingData' has a wrong offset!");

}

