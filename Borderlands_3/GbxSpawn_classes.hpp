#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxSpawn

#include "Basic.hpp"

#include "GbxSpawn_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "GbxRuntime_structs.hpp"
#include "GbxRuntime_classes.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Class GbxSpawn.Spawner
// 0x0190 (0x05E8 - 0x0458)
class ASpawner : public AActor
{
public:
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActorSpawned;                                    // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDied;                                       // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorFellOutOfWorld;                             // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorSuspend;                                    // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorUnsuspend;                                  // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllSpawned;                                      // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllDied;                                         // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaveWarmup;                                      // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaveStart;                                       // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaveComplete;                                    // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReset;                                           // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorSpawnedData;                                // 0x0510(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_520[0x18];                                     // 0x0520(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnExternalActorSpawnedData;                        // 0x0538(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDiedData;                                   // 0x0548(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnExternalActorDiedData;                           // 0x0558(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnScriptedWarmup;                                  // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorSuspendData;                                // 0x0578(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class USpawnerComponent*                      SpawnerComponent;                                  // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnerLinkComponent*                  SpawnerLinkComponent;                              // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnPointComponent*                   SpawnPointComponent;                               // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnerTeamComponent*                  SpawnerTeamComponent;                              // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoGroundSpawnPointComponents;                   // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A9[0x7];                                      // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludeAutoGroundPointComponents;                  // 0x05B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x28];                                     // 0x05C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteScriptedWarmup();
	void DestroyAllActors();
	void DisableSpawner();
	void EnableSpawner();
	void OnSpawningComplete(class ASpawner* Spawner);
	void OverrideSpawnerStyle(class USpawnerStyle* NewSpawnerStyle);
	void ResetSpawning();
	void SetAlwaysActive(bool bInAlwaysActive);
	void SetTeam(class UTeam* NewTeam);
	void SetTeamOverride(class UTeam* OverrideTeam);
	void SuspendAllActors();

	bool AreAllDead(bool bIncludeExternal) const;
	int32 GetNumAliveActors(bool bIncludeExternal) const;
	class USpawnerComponent* GetSpawnerComponent() const;
	class USpawnerLinkComponent* GetSpawnerLinkComponent() const;
	class USpawnerTeamComponent* GetSpawnerTeamComponent() const;
	class USpawnPointComponent* GetSpawnPointComponent() const;
	bool IsFinishedSpawning() const;
	bool IsSpawnerEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Spawner">();
	}
	static class ASpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawner>();
	}
};
static_assert(alignof(ASpawner) == 0x000008, "Wrong alignment on ASpawner");
static_assert(sizeof(ASpawner) == 0x0005E8, "Wrong size on ASpawner");
static_assert(offsetof(ASpawner, OnActorSpawned) == 0x000460, "Member 'ASpawner::OnActorSpawned' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorDied) == 0x000470, "Member 'ASpawner::OnActorDied' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorFellOutOfWorld) == 0x000480, "Member 'ASpawner::OnActorFellOutOfWorld' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorSuspend) == 0x000490, "Member 'ASpawner::OnActorSuspend' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorUnsuspend) == 0x0004A0, "Member 'ASpawner::OnActorUnsuspend' has a wrong offset!");
static_assert(offsetof(ASpawner, OnAllSpawned) == 0x0004B0, "Member 'ASpawner::OnAllSpawned' has a wrong offset!");
static_assert(offsetof(ASpawner, OnAllDied) == 0x0004C0, "Member 'ASpawner::OnAllDied' has a wrong offset!");
static_assert(offsetof(ASpawner, OnWaveWarmup) == 0x0004D0, "Member 'ASpawner::OnWaveWarmup' has a wrong offset!");
static_assert(offsetof(ASpawner, OnWaveStart) == 0x0004E0, "Member 'ASpawner::OnWaveStart' has a wrong offset!");
static_assert(offsetof(ASpawner, OnWaveComplete) == 0x0004F0, "Member 'ASpawner::OnWaveComplete' has a wrong offset!");
static_assert(offsetof(ASpawner, OnReset) == 0x000500, "Member 'ASpawner::OnReset' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorSpawnedData) == 0x000510, "Member 'ASpawner::OnActorSpawnedData' has a wrong offset!");
static_assert(offsetof(ASpawner, OnExternalActorSpawnedData) == 0x000538, "Member 'ASpawner::OnExternalActorSpawnedData' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorDiedData) == 0x000548, "Member 'ASpawner::OnActorDiedData' has a wrong offset!");
static_assert(offsetof(ASpawner, OnExternalActorDiedData) == 0x000558, "Member 'ASpawner::OnExternalActorDiedData' has a wrong offset!");
static_assert(offsetof(ASpawner, OnScriptedWarmup) == 0x000568, "Member 'ASpawner::OnScriptedWarmup' has a wrong offset!");
static_assert(offsetof(ASpawner, OnActorSuspendData) == 0x000578, "Member 'ASpawner::OnActorSuspendData' has a wrong offset!");
static_assert(offsetof(ASpawner, SpawnerComponent) == 0x000588, "Member 'ASpawner::SpawnerComponent' has a wrong offset!");
static_assert(offsetof(ASpawner, SpawnerLinkComponent) == 0x000590, "Member 'ASpawner::SpawnerLinkComponent' has a wrong offset!");
static_assert(offsetof(ASpawner, SpawnPointComponent) == 0x000598, "Member 'ASpawner::SpawnPointComponent' has a wrong offset!");
static_assert(offsetof(ASpawner, SpawnerTeamComponent) == 0x0005A0, "Member 'ASpawner::SpawnerTeamComponent' has a wrong offset!");
static_assert(offsetof(ASpawner, bAutoGroundSpawnPointComponents) == 0x0005A8, "Member 'ASpawner::bAutoGroundSpawnPointComponents' has a wrong offset!");
static_assert(offsetof(ASpawner, ExcludeAutoGroundPointComponents) == 0x0005B0, "Member 'ASpawner::ExcludeAutoGroundPointComponents' has a wrong offset!");

// Class GbxSpawn.AnimNotify_SpawnAnim
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SpawnAnim final : public UAnimNotify
{
public:
	ESpawnAnimNotifyAction                        Action;                                            // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnAnim">();
	}
	static class UAnimNotify_SpawnAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnAnim>();
	}
};
static_assert(alignof(UAnimNotify_SpawnAnim) == 0x000008, "Wrong alignment on UAnimNotify_SpawnAnim");
static_assert(sizeof(UAnimNotify_SpawnAnim) == 0x000040, "Wrong size on UAnimNotify_SpawnAnim");
static_assert(offsetof(UAnimNotify_SpawnAnim, Action) == 0x000038, "Member 'UAnimNotify_SpawnAnim::Action' has a wrong offset!");

// Class GbxSpawn.SpawnerComponent
// 0x02A0 (0x0990 - 0x06F0)
class USpawnerComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x98];                                     // 0x06F0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActorSpawned;                                    // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDied;                                       // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorSuspend;                                    // 0x07A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorUnsuspend;                                  // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllSpawned;                                      // 0x07C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllDied;                                         // 0x07D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaveWarmup;                                      // 0x07E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaveStart;                                       // 0x07F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaveComplete;                                    // 0x0808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnScriptedWarmup;                                  // 0x0818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReset;                                           // 0x0828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorSpawnedData;                                // 0x0838(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDiedData;                                   // 0x0848(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorSuspendData;                                // 0x0858(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_868[0x20];                                     // 0x0868(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x0888(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_889[0x7];                                      // 0x0889(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ChanceToEnableOnInit;                              // 0x0890(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bAlwaysActive;                                     // 0x08C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResetOnEnabled;                                   // 0x08C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EScriptedWarmup                               ScriptedWarmup;                                    // 0x08CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8CB[0x1];                                      // 0x08CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivationRadius;                                  // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bActivationUsesRadius;                             // 0x08D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D1[0x7];                                      // 0x08D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVolume*>                        ActivationVolumes;                                 // 0x08D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bActivationUsesVolumes;                            // 0x08E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpawnDetails                          SpawnDetails;                                      // 0x08E9(0x0007)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         MinimumActivationTime;                             // 0x08F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F4[0x4];                                      // 0x08F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnerStyle*                          SpawnerStyle;                                      // 0x08F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnerStyle*                          SpawnerStyleOverride;                              // 0x0900(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnLimitData>                Limits;                                            // 0x0908(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bApplyLimitsToGroup;                               // 0x0918(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_919[0x7];                                      // 0x0919(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USpawnFactory*>                  WaitingFactories;                                  // 0x0920(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_930[0x10];                                     // 0x0930(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASpawnPoint*>                    SpawnPoints;                                       // 0x0940(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bRandomizeSpawnPoints;                             // 0x0950(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_951[0x7];                                      // 0x0951(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnPointGroup>               SpawnPointGroups;                                  // 0x0958(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	ESpawnPointUseType                            SpawnPointUseType;                                 // 0x0968(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_969[0x3];                                      // 0x0969(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnPointClusterRadius;                           // 0x096C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USpawnPointComponent*>           SpawnPointComponents;                              // 0x0970(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ASpawner*                               Spawner;                                           // 0x0980(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIncludeExternalActorsForAllDiedEvent;             // 0x0988(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_989[0x2];                                      // 0x0989(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESpawnerDrawStyle                             DrawStyle;                                         // 0x098B(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseScriptedWarmup;                                // 0x098C(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98D[0x3];                                      // 0x098D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteScriptedWarmup();
	void DestroyAllActors();
	void DisableSpawner();
	void EnableSpawner();
	TArray<class AActor*> GetAliveActors();
	void IncludeExternalActorsForAllDiedEvent();
	void OverrideSpawnerStyle(class USpawnerStyle* NewSpawnerStyle);
	void ResetSpawning();
	void SetSpawnOptions(class USpawnOptionData* NewSpawnOptions);
	void SetTeam(class UTeam* NewTeam);
	void SuspendAllActors();

	bool AreAllDead(bool bIncludeExternal, bool bInGroup) const;
	int32 GetNumAliveActors(bool bIncludeExternal, bool bInGroup) const;
	int32 GetNumDeadActors(bool bIncludeExternal, bool bInGroup) const;
	int32 GetNumSpawnedActors(bool bIncludeExternal, bool bInGroup) const;
	int32 GetNumSuspendedActors() const;
	class USpawnerComponent* GetParentSpawner() const;
	class USpawnOptionData* GetSpawnOptions() const;
	bool IsFinishedSpawning() const;
	bool IsSpawnerStyleClassAllowed(const class UClass* SpawnerStyleClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerComponent">();
	}
	static class USpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerComponent>();
	}
};
static_assert(alignof(USpawnerComponent) == 0x000008, "Wrong alignment on USpawnerComponent");
static_assert(sizeof(USpawnerComponent) == 0x000990, "Wrong size on USpawnerComponent");
static_assert(offsetof(USpawnerComponent, OnActorSpawned) == 0x000788, "Member 'USpawnerComponent::OnActorSpawned' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnActorDied) == 0x000798, "Member 'USpawnerComponent::OnActorDied' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnActorSuspend) == 0x0007A8, "Member 'USpawnerComponent::OnActorSuspend' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnActorUnsuspend) == 0x0007B8, "Member 'USpawnerComponent::OnActorUnsuspend' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnAllSpawned) == 0x0007C8, "Member 'USpawnerComponent::OnAllSpawned' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnAllDied) == 0x0007D8, "Member 'USpawnerComponent::OnAllDied' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnWaveWarmup) == 0x0007E8, "Member 'USpawnerComponent::OnWaveWarmup' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnWaveStart) == 0x0007F8, "Member 'USpawnerComponent::OnWaveStart' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnWaveComplete) == 0x000808, "Member 'USpawnerComponent::OnWaveComplete' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnScriptedWarmup) == 0x000818, "Member 'USpawnerComponent::OnScriptedWarmup' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnReset) == 0x000828, "Member 'USpawnerComponent::OnReset' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnActorSpawnedData) == 0x000838, "Member 'USpawnerComponent::OnActorSpawnedData' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnActorDiedData) == 0x000848, "Member 'USpawnerComponent::OnActorDiedData' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, OnActorSuspendData) == 0x000858, "Member 'USpawnerComponent::OnActorSuspendData' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bEnabled) == 0x000888, "Member 'USpawnerComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ChanceToEnableOnInit) == 0x000890, "Member 'USpawnerComponent::ChanceToEnableOnInit' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bAlwaysActive) == 0x0008C8, "Member 'USpawnerComponent::bAlwaysActive' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bResetOnEnabled) == 0x0008C9, "Member 'USpawnerComponent::bResetOnEnabled' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ScriptedWarmup) == 0x0008CA, "Member 'USpawnerComponent::ScriptedWarmup' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ActivationRadius) == 0x0008CC, "Member 'USpawnerComponent::ActivationRadius' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bActivationUsesRadius) == 0x0008D0, "Member 'USpawnerComponent::bActivationUsesRadius' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, ActivationVolumes) == 0x0008D8, "Member 'USpawnerComponent::ActivationVolumes' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bActivationUsesVolumes) == 0x0008E8, "Member 'USpawnerComponent::bActivationUsesVolumes' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnDetails) == 0x0008E9, "Member 'USpawnerComponent::SpawnDetails' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, MinimumActivationTime) == 0x0008F0, "Member 'USpawnerComponent::MinimumActivationTime' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnerStyle) == 0x0008F8, "Member 'USpawnerComponent::SpawnerStyle' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnerStyleOverride) == 0x000900, "Member 'USpawnerComponent::SpawnerStyleOverride' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, Limits) == 0x000908, "Member 'USpawnerComponent::Limits' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bApplyLimitsToGroup) == 0x000918, "Member 'USpawnerComponent::bApplyLimitsToGroup' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, WaitingFactories) == 0x000920, "Member 'USpawnerComponent::WaitingFactories' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnPoints) == 0x000940, "Member 'USpawnerComponent::SpawnPoints' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bRandomizeSpawnPoints) == 0x000950, "Member 'USpawnerComponent::bRandomizeSpawnPoints' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnPointGroups) == 0x000958, "Member 'USpawnerComponent::SpawnPointGroups' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnPointUseType) == 0x000968, "Member 'USpawnerComponent::SpawnPointUseType' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnPointClusterRadius) == 0x00096C, "Member 'USpawnerComponent::SpawnPointClusterRadius' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, SpawnPointComponents) == 0x000970, "Member 'USpawnerComponent::SpawnPointComponents' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, Spawner) == 0x000980, "Member 'USpawnerComponent::Spawner' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bIncludeExternalActorsForAllDiedEvent) == 0x000988, "Member 'USpawnerComponent::bIncludeExternalActorsForAllDiedEvent' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, DrawStyle) == 0x00098B, "Member 'USpawnerComponent::DrawStyle' has a wrong offset!");
static_assert(offsetof(USpawnerComponent, bUseScriptedWarmup) == 0x00098C, "Member 'USpawnerComponent::bUseScriptedWarmup' has a wrong offset!");

// Class GbxSpawn.GbxAction_SpawnAnim
// 0x0018 (0x01C0 - 0x01A8)
class UGbxAction_SpawnAnim : public UGbxAction_Anim
{
public:
	TSubclassOf<class UGbxAction>                 SpawnPointAction;                                  // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 SpawnPointActionStop;                              // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMovementMode                                 OverrideMovementMode;                              // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideMovementMode;                             // 0x01B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableCollisionOnSpawn;                          // 0x01BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB[0x5];                                      // 0x01BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* K2_GetSpawnPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_SpawnAnim">();
	}
	static class UGbxAction_SpawnAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_SpawnAnim>();
	}
};
static_assert(alignof(UGbxAction_SpawnAnim) == 0x000008, "Wrong alignment on UGbxAction_SpawnAnim");
static_assert(sizeof(UGbxAction_SpawnAnim) == 0x0001C0, "Wrong size on UGbxAction_SpawnAnim");
static_assert(offsetof(UGbxAction_SpawnAnim, SpawnPointAction) == 0x0001A8, "Member 'UGbxAction_SpawnAnim::SpawnPointAction' has a wrong offset!");
static_assert(offsetof(UGbxAction_SpawnAnim, SpawnPointActionStop) == 0x0001B0, "Member 'UGbxAction_SpawnAnim::SpawnPointActionStop' has a wrong offset!");
static_assert(offsetof(UGbxAction_SpawnAnim, OverrideMovementMode) == 0x0001B8, "Member 'UGbxAction_SpawnAnim::OverrideMovementMode' has a wrong offset!");
static_assert(offsetof(UGbxAction_SpawnAnim, bOverrideMovementMode) == 0x0001B9, "Member 'UGbxAction_SpawnAnim::bOverrideMovementMode' has a wrong offset!");
static_assert(offsetof(UGbxAction_SpawnAnim, bDisableCollisionOnSpawn) == 0x0001BA, "Member 'UGbxAction_SpawnAnim::bDisableCollisionOnSpawn' has a wrong offset!");

// Class GbxSpawn.SpawnPoint
// 0x0068 (0x04C0 - 0x0458)
class ASpawnPoint : public AActor
{
public:
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActorSpawned;                                    // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDied;                                       // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        SpawnRootComponent;                                // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpawnPointComponent*                   SpawnPointComponent;                               // 0x0488(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USpawnerComponent*>              ConnectedSpawners;                                 // 0x0490(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        TempRootFix;                                       // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableSpawnPoint();
	void EnableSpawnPoint();
	void ResetStretchPoint();
	void SetSpawnStyleTag(const struct FGameplayTag& NewTag);

	struct FGameplayTag GetSpawnStyleTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPoint">();
	}
	static class ASpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnPoint>();
	}
};
static_assert(alignof(ASpawnPoint) == 0x000008, "Wrong alignment on ASpawnPoint");
static_assert(sizeof(ASpawnPoint) == 0x0004C0, "Wrong size on ASpawnPoint");
static_assert(offsetof(ASpawnPoint, OnActorSpawned) == 0x000460, "Member 'ASpawnPoint::OnActorSpawned' has a wrong offset!");
static_assert(offsetof(ASpawnPoint, OnActorDied) == 0x000470, "Member 'ASpawnPoint::OnActorDied' has a wrong offset!");
static_assert(offsetof(ASpawnPoint, SpawnRootComponent) == 0x000480, "Member 'ASpawnPoint::SpawnRootComponent' has a wrong offset!");
static_assert(offsetof(ASpawnPoint, SpawnPointComponent) == 0x000488, "Member 'ASpawnPoint::SpawnPointComponent' has a wrong offset!");
static_assert(offsetof(ASpawnPoint, ConnectedSpawners) == 0x000490, "Member 'ASpawnPoint::ConnectedSpawners' has a wrong offset!");
static_assert(offsetof(ASpawnPoint, TempRootFix) == 0x0004A0, "Member 'ASpawnPoint::TempRootFix' has a wrong offset!");

// Class GbxSpawn.GbxCondition_SpawnCostAvailable
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_SpawnCostAvailable final : public UGbxCondition
{
public:
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_SpawnCostAvailable">();
	}
	static class UGbxCondition_SpawnCostAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_SpawnCostAvailable>();
	}
};
static_assert(alignof(UGbxCondition_SpawnCostAvailable) == 0x000008, "Wrong alignment on UGbxCondition_SpawnCostAvailable");
static_assert(sizeof(UGbxCondition_SpawnCostAvailable) == 0x000090, "Wrong size on UGbxCondition_SpawnCostAvailable");
static_assert(offsetof(UGbxCondition_SpawnCostAvailable, SpawnOptions) == 0x000088, "Member 'UGbxCondition_SpawnCostAvailable::SpawnOptions' has a wrong offset!");

// Class GbxSpawn.MultiSpawnPoint
// 0x0010 (0x04D0 - 0x04C0)
class AMultiSpawnPoint final : public ASpawnPoint
{
public:
	TArray<class USpawnPointComponent*>           SpawnPointComponents;                              // 0x04C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSpawnPoint">();
	}
	static class AMultiSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultiSpawnPoint>();
	}
};
static_assert(alignof(AMultiSpawnPoint) == 0x000008, "Wrong alignment on AMultiSpawnPoint");
static_assert(sizeof(AMultiSpawnPoint) == 0x0004D0, "Wrong size on AMultiSpawnPoint");
static_assert(offsetof(AMultiSpawnPoint, SpawnPointComponents) == 0x0004C0, "Member 'AMultiSpawnPoint::SpawnPointComponents' has a wrong offset!");

// Class GbxSpawn.SpawnDLCScript
// 0x0000 (0x0028 - 0x0028)
class USpawnDLCScript : public UObject
{
public:
	void OnActorDied(class USpawnerComponent* SpawnerComponent, class AActor* Actor) const;
	void OnActorSpawned(class USpawnerComponent* SpawnerComponent, class AActor* Actor) const;
	void OnAllDied(class USpawnerComponent* SpawnerComponent) const;
	void OnAllSpawned(class USpawnerComponent* SpawnerComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnDLCScript">();
	}
	static class USpawnDLCScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnDLCScript>();
	}
};
static_assert(alignof(USpawnDLCScript) == 0x000008, "Wrong alignment on USpawnDLCScript");
static_assert(sizeof(USpawnDLCScript) == 0x000028, "Wrong size on USpawnDLCScript");

// Class GbxSpawn.SpawnDLCData
// 0x0218 (0x0248 - 0x0030)
class USpawnDLCData final : public UGbxDataAsset
{
public:
	TMap<class USpawnOptionData*, class USpawnOptionData*> GlobalReplacement;                                 // 0x0030(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bGlobalReplacementAlwaysEnabledDuringEvent;        // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnDLCGroup>                 SpawnerReplacements;                               // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class USpawnDLCScript>            Script;                                            // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bScriptGloballyReplacedSpawners;                   // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bScriptManuallyReplacedSpawners;                   // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              MaximumTotalEventEnemies;                          // 0x00A8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaximumEventEnemiesPerSpawner;                     // 0x0128(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaximumScriptedSpawnersPerGroup;                   // 0x01A8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnDLCScriptGroup>           ScriptedSpawners;                                  // 0x0228(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UDLCScriptedSpawerExpansionList*> ExpansionScriptedSpawners;                         // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnDLCData">();
	}
	static class USpawnDLCData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnDLCData>();
	}
};
static_assert(alignof(USpawnDLCData) == 0x000008, "Wrong alignment on USpawnDLCData");
static_assert(sizeof(USpawnDLCData) == 0x000248, "Wrong size on USpawnDLCData");
static_assert(offsetof(USpawnDLCData, GlobalReplacement) == 0x000030, "Member 'USpawnDLCData::GlobalReplacement' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, bGlobalReplacementAlwaysEnabledDuringEvent) == 0x000080, "Member 'USpawnDLCData::bGlobalReplacementAlwaysEnabledDuringEvent' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, SpawnerReplacements) == 0x000088, "Member 'USpawnDLCData::SpawnerReplacements' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, Script) == 0x000098, "Member 'USpawnDLCData::Script' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, bScriptGloballyReplacedSpawners) == 0x0000A0, "Member 'USpawnDLCData::bScriptGloballyReplacedSpawners' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, bScriptManuallyReplacedSpawners) == 0x0000A1, "Member 'USpawnDLCData::bScriptManuallyReplacedSpawners' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, MaximumTotalEventEnemies) == 0x0000A8, "Member 'USpawnDLCData::MaximumTotalEventEnemies' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, MaximumEventEnemiesPerSpawner) == 0x000128, "Member 'USpawnDLCData::MaximumEventEnemiesPerSpawner' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, MaximumScriptedSpawnersPerGroup) == 0x0001A8, "Member 'USpawnDLCData::MaximumScriptedSpawnersPerGroup' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, ScriptedSpawners) == 0x000228, "Member 'USpawnDLCData::ScriptedSpawners' has a wrong offset!");
static_assert(offsetof(USpawnDLCData, ExpansionScriptedSpawners) == 0x000238, "Member 'USpawnDLCData::ExpansionScriptedSpawners' has a wrong offset!");

// Class GbxSpawn.GlobalSpawnDLCData
// 0x0010 (0x0040 - 0x0030)
class UGlobalSpawnDLCData final : public UGbxDataAsset
{
public:
	TArray<struct FSpawnDLCItem>                  DLCs;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalSpawnDLCData">();
	}
	static class UGlobalSpawnDLCData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalSpawnDLCData>();
	}
};
static_assert(alignof(UGlobalSpawnDLCData) == 0x000008, "Wrong alignment on UGlobalSpawnDLCData");
static_assert(sizeof(UGlobalSpawnDLCData) == 0x000040, "Wrong size on UGlobalSpawnDLCData");
static_assert(offsetof(UGlobalSpawnDLCData, DLCs) == 0x000030, "Member 'UGlobalSpawnDLCData::DLCs' has a wrong offset!");

// Class GbxSpawn.DLCScriptedSpawerExpansionList
// 0x0010 (0x0040 - 0x0030)
class UDLCScriptedSpawerExpansionList final : public UGbxDataAsset
{
public:
	TArray<struct FSpawnDLCScriptGroup>           ScriptedSpawners;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCScriptedSpawerExpansionList">();
	}
	static class UDLCScriptedSpawerExpansionList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCScriptedSpawerExpansionList>();
	}
};
static_assert(alignof(UDLCScriptedSpawerExpansionList) == 0x000008, "Wrong alignment on UDLCScriptedSpawerExpansionList");
static_assert(sizeof(UDLCScriptedSpawerExpansionList) == 0x000040, "Wrong size on UDLCScriptedSpawerExpansionList");
static_assert(offsetof(UDLCScriptedSpawerExpansionList, ScriptedSpawners) == 0x000030, "Member 'UDLCScriptedSpawerExpansionList::ScriptedSpawners' has a wrong offset!");

// Class GbxSpawn.SpawnedActorInterface
// 0x0000 (0x0028 - 0x0028)
class ISpawnedActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnedActorInterface">();
	}
	static class ISpawnedActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnedActorInterface>();
	}
};
static_assert(alignof(ISpawnedActorInterface) == 0x000008, "Wrong alignment on ISpawnedActorInterface");
static_assert(sizeof(ISpawnedActorInterface) == 0x000028, "Wrong size on ISpawnedActorInterface");

// Class GbxSpawn.SpawnerBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USpawnerBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelSpawnActorWithOptionsAsyncRequest(class UObject* WorldContext, int32 RequestID);
	static void RemoveActorFromSpawnSystem(class AActor* Actor);
	static void RestoreSuspendedActors(class UObject* WorldContextObject);
	static void SetMaxSpawnCost(class UObject* WorldContextObject, int32 NewMaxSpawnCost);
	static class AActor* SpawnActorWithSpawner(class AActor* Context, const class USpawnFactory* Factory, class USpawnPointComponent* SpawnPointComponent, class USpawnerComponent* SpawnerComponent, class AActor* Owner);
	static class AActor* SpawnActorWithSpawnOptions(class AActor* Context, class USpawnOptionData* SpawnOptions, class USpawnPointComponent* SpawnPointComponent);
	static int32 SpawnActorWithSpawnOptionsAsync(class UObject* WorldContext, const struct FSpawnManagerAsyncRequest& Request);
	static class AActor* SpawnActorWithSpawnOptionsTransform(class AActor* Context, class USpawnOptionData* SpawnOptions, const struct FTransform& SpawnTransform);
	static void SuspendSpawnedActors(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerBlueprintLibrary">();
	}
	static class USpawnerBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerBlueprintLibrary>();
	}
};
static_assert(alignof(USpawnerBlueprintLibrary) == 0x000008, "Wrong alignment on USpawnerBlueprintLibrary");
static_assert(sizeof(USpawnerBlueprintLibrary) == 0x000028, "Wrong size on USpawnerBlueprintLibrary");

// Class GbxSpawn.SpawnerLinkComponent
// 0x0080 (0x0770 - 0x06F0)
class USpawnerLinkComponent final : public UPrimitiveComponent
{
public:
	TArray<struct FSpawnerLinkData>               LinkDataList;                                      // 0x06F0(0x0010)(ZeroConstructor, ContainsInstancedReference, NonPIEDuplicateTransient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         LinkedSpawners;                                    // 0x0700(0x0010)(Edit, ZeroConstructor, NonPIEDuplicateTransient, NativeAccessSpecifierPrivate)
	bool                                          bAutoProximityLink;                                // 0x0710(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpawnerLinkData                       MasterLinkData;                                    // 0x0718(0x0028)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bBeingDestroyed;                                   // 0x0740(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_741[0x7];                                      // 0x0741(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        SharedStates;                                      // 0x0748(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ASpawner*>                       AllLinkedSpawners;                                 // 0x0758(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerLinkComponent">();
	}
	static class USpawnerLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerLinkComponent>();
	}
};
static_assert(alignof(USpawnerLinkComponent) == 0x000008, "Wrong alignment on USpawnerLinkComponent");
static_assert(sizeof(USpawnerLinkComponent) == 0x000770, "Wrong size on USpawnerLinkComponent");
static_assert(offsetof(USpawnerLinkComponent, LinkDataList) == 0x0006F0, "Member 'USpawnerLinkComponent::LinkDataList' has a wrong offset!");
static_assert(offsetof(USpawnerLinkComponent, LinkedSpawners) == 0x000700, "Member 'USpawnerLinkComponent::LinkedSpawners' has a wrong offset!");
static_assert(offsetof(USpawnerLinkComponent, bAutoProximityLink) == 0x000710, "Member 'USpawnerLinkComponent::bAutoProximityLink' has a wrong offset!");
static_assert(offsetof(USpawnerLinkComponent, MasterLinkData) == 0x000718, "Member 'USpawnerLinkComponent::MasterLinkData' has a wrong offset!");
static_assert(offsetof(USpawnerLinkComponent, bBeingDestroyed) == 0x000740, "Member 'USpawnerLinkComponent::bBeingDestroyed' has a wrong offset!");
static_assert(offsetof(USpawnerLinkComponent, SharedStates) == 0x000748, "Member 'USpawnerLinkComponent::SharedStates' has a wrong offset!");
static_assert(offsetof(USpawnerLinkComponent, AllLinkedSpawners) == 0x000758, "Member 'USpawnerLinkComponent::AllLinkedSpawners' has a wrong offset!");

// Class GbxSpawn.SpawnerStateInterface
// 0x0000 (0x0028 - 0x0028)
class ISpawnerStateInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStateInterface">();
	}
	static class ISpawnerStateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnerStateInterface>();
	}
};
static_assert(alignof(ISpawnerStateInterface) == 0x000008, "Wrong alignment on ISpawnerStateInterface");
static_assert(sizeof(ISpawnerStateInterface) == 0x000028, "Wrong size on ISpawnerStateInterface");

// Class GbxSpawn.SpawnerStyle
// 0x0000 (0x0030 - 0x0030)
class USpawnerStyle : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyle">();
	}
	static class USpawnerStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyle>();
	}
};
static_assert(alignof(USpawnerStyle) == 0x000008, "Wrong alignment on USpawnerStyle");
static_assert(sizeof(USpawnerStyle) == 0x000030, "Wrong size on USpawnerStyle");

// Class GbxSpawn.SpawnerStyle_Bunch
// 0x0090 (0x00C0 - 0x0030)
class USpawnerStyle_Bunch : public USpawnerStyle
{
public:
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxParam                              NumActorsParam;                                    // 0x0038(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         SpawnDelay;                                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyle_Bunch">();
	}
	static class USpawnerStyle_Bunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyle_Bunch>();
	}
};
static_assert(alignof(USpawnerStyle_Bunch) == 0x000008, "Wrong alignment on USpawnerStyle_Bunch");
static_assert(sizeof(USpawnerStyle_Bunch) == 0x0000C0, "Wrong size on USpawnerStyle_Bunch");
static_assert(offsetof(USpawnerStyle_Bunch, SpawnOptions) == 0x000030, "Member 'USpawnerStyle_Bunch::SpawnOptions' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Bunch, NumActorsParam) == 0x000038, "Member 'USpawnerStyle_Bunch::NumActorsParam' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Bunch, SpawnDelay) == 0x0000B8, "Member 'USpawnerStyle_Bunch::SpawnDelay' has a wrong offset!");

// Class GbxSpawn.SpawnerStyle_BunchList
// 0x0018 (0x0048 - 0x0030)
class USpawnerStyle_BunchList final : public USpawnerStyle
{
public:
	TArray<struct FSpawnBunchListItem>            Bunches;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         SpawnDelay;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyle_BunchList">();
	}
	static class USpawnerStyle_BunchList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyle_BunchList>();
	}
};
static_assert(alignof(USpawnerStyle_BunchList) == 0x000008, "Wrong alignment on USpawnerStyle_BunchList");
static_assert(sizeof(USpawnerStyle_BunchList) == 0x000048, "Wrong size on USpawnerStyle_BunchList");
static_assert(offsetof(USpawnerStyle_BunchList, Bunches) == 0x000030, "Member 'USpawnerStyle_BunchList::Bunches' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_BunchList, SpawnDelay) == 0x000040, "Member 'USpawnerStyle_BunchList::SpawnDelay' has a wrong offset!");

// Class GbxSpawn.SpawnerStyle_Den
// 0x0220 (0x0250 - 0x0030)
class USpawnerStyle_Den : public USpawnerStyle
{
public:
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInfinite;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              NumActorsParam;                                    // 0x0040(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaxAliveActorsWhenPassive;                         // 0x00C0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaxAliveActorsWhenThreatened;                      // 0x0140(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         SpawnDelay;                                        // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaveDelay;                                         // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WavePercent;                                       // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              NumAliveActorsParam;                               // 0x01D0(0x0080)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyle_Den">();
	}
	static class USpawnerStyle_Den* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyle_Den>();
	}
};
static_assert(alignof(USpawnerStyle_Den) == 0x000008, "Wrong alignment on USpawnerStyle_Den");
static_assert(sizeof(USpawnerStyle_Den) == 0x000250, "Wrong size on USpawnerStyle_Den");
static_assert(offsetof(USpawnerStyle_Den, SpawnOptions) == 0x000030, "Member 'USpawnerStyle_Den::SpawnOptions' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, bInfinite) == 0x000038, "Member 'USpawnerStyle_Den::bInfinite' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, NumActorsParam) == 0x000040, "Member 'USpawnerStyle_Den::NumActorsParam' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, MaxAliveActorsWhenPassive) == 0x0000C0, "Member 'USpawnerStyle_Den::MaxAliveActorsWhenPassive' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, MaxAliveActorsWhenThreatened) == 0x000140, "Member 'USpawnerStyle_Den::MaxAliveActorsWhenThreatened' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, SpawnDelay) == 0x0001C0, "Member 'USpawnerStyle_Den::SpawnDelay' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, WaveDelay) == 0x0001C4, "Member 'USpawnerStyle_Den::WaveDelay' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, WavePercent) == 0x0001C8, "Member 'USpawnerStyle_Den::WavePercent' has a wrong offset!");
static_assert(offsetof(USpawnerStyle_Den, NumAliveActorsParam) == 0x0001D0, "Member 'USpawnerStyle_Den::NumAliveActorsParam' has a wrong offset!");

// Class GbxSpawn.SpawnerStyle_Encounter
// 0x0010 (0x0040 - 0x0030)
class USpawnerStyle_Encounter final : public USpawnerStyle
{
public:
	TArray<struct FEncounterWave>                 Waves;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyle_Encounter">();
	}
	static class USpawnerStyle_Encounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyle_Encounter>();
	}
};
static_assert(alignof(USpawnerStyle_Encounter) == 0x000008, "Wrong alignment on USpawnerStyle_Encounter");
static_assert(sizeof(USpawnerStyle_Encounter) == 0x000040, "Wrong size on USpawnerStyle_Encounter");
static_assert(offsetof(USpawnerStyle_Encounter, Waves) == 0x000030, "Member 'USpawnerStyle_Encounter::Waves' has a wrong offset!");

// Class GbxSpawn.SpawnerStyle_Single
// 0x0008 (0x0038 - 0x0030)
class USpawnerStyle_Single : public USpawnerStyle
{
public:
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyle_Single">();
	}
	static class USpawnerStyle_Single* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyle_Single>();
	}
};
static_assert(alignof(USpawnerStyle_Single) == 0x000008, "Wrong alignment on USpawnerStyle_Single");
static_assert(sizeof(USpawnerStyle_Single) == 0x000038, "Wrong size on USpawnerStyle_Single");
static_assert(offsetof(USpawnerStyle_Single, SpawnOptions) == 0x000030, "Member 'USpawnerStyle_Single::SpawnOptions' has a wrong offset!");

// Class GbxSpawn.SpawnerStyleFactory_Bunch
// 0x0018 (0x00D8 - 0x00C0)
class USpawnerStyleFactory_Bunch final : public USpawnerStyle_Bunch
{
public:
	class USpawnFactory*                          SpawnFactory;                                      // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpawnLimitType                               AliveLimitType;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnOptionData*                       InternalSpawnOptions;                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsFactoryClassAllowed(const class UClass* FactoryClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyleFactory_Bunch">();
	}
	static class USpawnerStyleFactory_Bunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyleFactory_Bunch>();
	}
};
static_assert(alignof(USpawnerStyleFactory_Bunch) == 0x000008, "Wrong alignment on USpawnerStyleFactory_Bunch");
static_assert(sizeof(USpawnerStyleFactory_Bunch) == 0x0000D8, "Wrong size on USpawnerStyleFactory_Bunch");
static_assert(offsetof(USpawnerStyleFactory_Bunch, SpawnFactory) == 0x0000C0, "Member 'USpawnerStyleFactory_Bunch::SpawnFactory' has a wrong offset!");
static_assert(offsetof(USpawnerStyleFactory_Bunch, AliveLimitType) == 0x0000C8, "Member 'USpawnerStyleFactory_Bunch::AliveLimitType' has a wrong offset!");
static_assert(offsetof(USpawnerStyleFactory_Bunch, InternalSpawnOptions) == 0x0000D0, "Member 'USpawnerStyleFactory_Bunch::InternalSpawnOptions' has a wrong offset!");

// Class GbxSpawn.SpawnerStyleFactory_Den
// 0x0018 (0x0268 - 0x0250)
class USpawnerStyleFactory_Den final : public USpawnerStyle_Den
{
public:
	class USpawnFactory*                          SpawnFactory;                                      // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpawnLimitType                               AliveLimitType;                                    // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnOptionData*                       InternalSpawnOptions;                              // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsFactoryClassAllowed(const class UClass* FactoryClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyleFactory_Den">();
	}
	static class USpawnerStyleFactory_Den* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyleFactory_Den>();
	}
};
static_assert(alignof(USpawnerStyleFactory_Den) == 0x000008, "Wrong alignment on USpawnerStyleFactory_Den");
static_assert(sizeof(USpawnerStyleFactory_Den) == 0x000268, "Wrong size on USpawnerStyleFactory_Den");
static_assert(offsetof(USpawnerStyleFactory_Den, SpawnFactory) == 0x000250, "Member 'USpawnerStyleFactory_Den::SpawnFactory' has a wrong offset!");
static_assert(offsetof(USpawnerStyleFactory_Den, AliveLimitType) == 0x000258, "Member 'USpawnerStyleFactory_Den::AliveLimitType' has a wrong offset!");
static_assert(offsetof(USpawnerStyleFactory_Den, InternalSpawnOptions) == 0x000260, "Member 'USpawnerStyleFactory_Den::InternalSpawnOptions' has a wrong offset!");

// Class GbxSpawn.SpawnerStyleFactory_Single
// 0x0018 (0x0050 - 0x0038)
class USpawnerStyleFactory_Single final : public USpawnerStyle_Single
{
public:
	class USpawnFactory*                          SpawnFactory;                                      // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpawnLimitType                               AliveLimitType;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnOptionData*                       InternalSpawnOptions;                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsFactoryClassAllowed(const class UClass* FactoryClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStyleFactory_Single">();
	}
	static class USpawnerStyleFactory_Single* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStyleFactory_Single>();
	}
};
static_assert(alignof(USpawnerStyleFactory_Single) == 0x000008, "Wrong alignment on USpawnerStyleFactory_Single");
static_assert(sizeof(USpawnerStyleFactory_Single) == 0x000050, "Wrong size on USpawnerStyleFactory_Single");
static_assert(offsetof(USpawnerStyleFactory_Single, SpawnFactory) == 0x000038, "Member 'USpawnerStyleFactory_Single::SpawnFactory' has a wrong offset!");
static_assert(offsetof(USpawnerStyleFactory_Single, AliveLimitType) == 0x000040, "Member 'USpawnerStyleFactory_Single::AliveLimitType' has a wrong offset!");
static_assert(offsetof(USpawnerStyleFactory_Single, InternalSpawnOptions) == 0x000048, "Member 'USpawnerStyleFactory_Single::InternalSpawnOptions' has a wrong offset!");

// Class GbxSpawn.SpawnerTeamComponent
// 0x0020 (0x01D8 - 0x01B8)
class USpawnerTeamComponent final : public UTeamComponent
{
public:
	class UTeam*                                  OverrideTeam;                                      // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideTeam;                                     // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ResolvedTeamType;                                  // 0x01C8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTeam*                                  EvaluatedTeam;                                     // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerTeamComponent">();
	}
	static class USpawnerTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerTeamComponent>();
	}
};
static_assert(alignof(USpawnerTeamComponent) == 0x000008, "Wrong alignment on USpawnerTeamComponent");
static_assert(sizeof(USpawnerTeamComponent) == 0x0001D8, "Wrong size on USpawnerTeamComponent");
static_assert(offsetof(USpawnerTeamComponent, OverrideTeam) == 0x0001B8, "Member 'USpawnerTeamComponent::OverrideTeam' has a wrong offset!");
static_assert(offsetof(USpawnerTeamComponent, bOverrideTeam) == 0x0001C0, "Member 'USpawnerTeamComponent::bOverrideTeam' has a wrong offset!");
static_assert(offsetof(USpawnerTeamComponent, ResolvedTeamType) == 0x0001C8, "Member 'USpawnerTeamComponent::ResolvedTeamType' has a wrong offset!");
static_assert(offsetof(USpawnerTeamComponent, EvaluatedTeam) == 0x0001D0, "Member 'USpawnerTeamComponent::EvaluatedTeam' has a wrong offset!");

// Class GbxSpawn.SpawnFactory
// 0x0070 (0x0098 - 0x0028)
class USpawnFactory : public UObject
{
public:
	bool                                          bUsedInSpawnPointOverlapChecks;                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideActorTags;                                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0030(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FSpawnDetails                          SpawnDetails;                                      // 0x0050(0x0007)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         CachedActorClassTagComponent;                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTeam*                                  CachedTeam;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnFactory">();
	}
	static class USpawnFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnFactory>();
	}
};
static_assert(alignof(USpawnFactory) == 0x000008, "Wrong alignment on USpawnFactory");
static_assert(sizeof(USpawnFactory) == 0x000098, "Wrong size on USpawnFactory");
static_assert(offsetof(USpawnFactory, bUsedInSpawnPointOverlapChecks) == 0x000028, "Member 'USpawnFactory::bUsedInSpawnPointOverlapChecks' has a wrong offset!");
static_assert(offsetof(USpawnFactory, bOverrideActorTags) == 0x000029, "Member 'USpawnFactory::bOverrideActorTags' has a wrong offset!");
static_assert(offsetof(USpawnFactory, Tags) == 0x000030, "Member 'USpawnFactory::Tags' has a wrong offset!");
static_assert(offsetof(USpawnFactory, SpawnDetails) == 0x000050, "Member 'USpawnFactory::SpawnDetails' has a wrong offset!");
static_assert(offsetof(USpawnFactory, CachedActorClassTagComponent) == 0x000058, "Member 'USpawnFactory::CachedActorClassTagComponent' has a wrong offset!");
static_assert(offsetof(USpawnFactory, CachedTeam) == 0x000060, "Member 'USpawnFactory::CachedTeam' has a wrong offset!");

// Class GbxSpawn.SpawnFactory_Container
// 0x0008 (0x00A0 - 0x0098)
class USpawnFactory_Container final : public USpawnFactory
{
public:
	class USpawnOptionData*                       Options;                                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnFactory_Container">();
	}
	static class USpawnFactory_Container* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnFactory_Container>();
	}
};
static_assert(alignof(USpawnFactory_Container) == 0x000008, "Wrong alignment on USpawnFactory_Container");
static_assert(sizeof(USpawnFactory_Container) == 0x0000A0, "Wrong size on USpawnFactory_Container");
static_assert(offsetof(USpawnFactory_Container, Options) == 0x000098, "Member 'USpawnFactory_Container::Options' has a wrong offset!");

// Class GbxSpawn.SpawnFactory_ContainerSoftRef
// 0x0018 (0x00B0 - 0x0098)
class USpawnFactory_ContainerSoftRef final : public USpawnFactory
{
public:
	struct FSpawnOptionDataSoftPath               OptionsPath;                                       // 0x0098(0x0018)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnFactory_ContainerSoftRef">();
	}
	static class USpawnFactory_ContainerSoftRef* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnFactory_ContainerSoftRef>();
	}
};
static_assert(alignof(USpawnFactory_ContainerSoftRef) == 0x000008, "Wrong alignment on USpawnFactory_ContainerSoftRef");
static_assert(sizeof(USpawnFactory_ContainerSoftRef) == 0x0000B0, "Wrong size on USpawnFactory_ContainerSoftRef");
static_assert(offsetof(USpawnFactory_ContainerSoftRef, OptionsPath) == 0x000098, "Member 'USpawnFactory_ContainerSoftRef::OptionsPath' has a wrong offset!");

// Class GbxSpawn.SpawnFactory_Generic
// 0x0140 (0x01D8 - 0x0098)
class USpawnFactory_Generic : public USpawnFactory
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorProperties;                                   // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseActorProperties;                               // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncludeSkeletalMeshForSpawnExtent;                // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x00B0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpawnOrigin;                                       // 0x00D8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                SpawnExtent;                                       // 0x00E4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideSpawnSize;                                // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpawnActorCollisionHandlingMethod            CollisionHandling;                                 // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideCollisionHandling;                        // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F3[0xD5];                                      // 0x00F3(0x00D5)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                ActorPropertyAssetRefCache;                        // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static bool ShouldSkipActorProperty(class UProperty* ActorProperty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnFactory_Generic">();
	}
	static class USpawnFactory_Generic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnFactory_Generic>();
	}
};
static_assert(alignof(USpawnFactory_Generic) == 0x000008, "Wrong alignment on USpawnFactory_Generic");
static_assert(sizeof(USpawnFactory_Generic) == 0x0001D8, "Wrong size on USpawnFactory_Generic");
static_assert(offsetof(USpawnFactory_Generic, ActorProperties) == 0x0000A0, "Member 'USpawnFactory_Generic::ActorProperties' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, bUseActorProperties) == 0x0000A8, "Member 'USpawnFactory_Generic::bUseActorProperties' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, bIncludeSkeletalMeshForSpawnExtent) == 0x0000A9, "Member 'USpawnFactory_Generic::bIncludeSkeletalMeshForSpawnExtent' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, ActorClass) == 0x0000B0, "Member 'USpawnFactory_Generic::ActorClass' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, SpawnOrigin) == 0x0000D8, "Member 'USpawnFactory_Generic::SpawnOrigin' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, SpawnExtent) == 0x0000E4, "Member 'USpawnFactory_Generic::SpawnExtent' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, bOverrideSpawnSize) == 0x0000F0, "Member 'USpawnFactory_Generic::bOverrideSpawnSize' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, CollisionHandling) == 0x0000F1, "Member 'USpawnFactory_Generic::CollisionHandling' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, bOverrideCollisionHandling) == 0x0000F2, "Member 'USpawnFactory_Generic::bOverrideCollisionHandling' has a wrong offset!");
static_assert(offsetof(USpawnFactory_Generic, ActorPropertyAssetRefCache) == 0x0001C8, "Member 'USpawnFactory_Generic::ActorPropertyAssetRefCache' has a wrong offset!");

// Class GbxSpawn.SpawnManager
// 0x0308 (0x0330 - 0x0028)
class USpawnManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AdditionalSpawnPointOverlapActors;                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x148];                                     // 0x0040(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnManagerAsyncRequestEntry> AsyncRequests;                                     // 0x0188(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         SpawnManagerClassName;                             // 0x01A8(0x0018)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxSpawnCost;                                      // 0x01C0(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanResetSpawners;                                 // 0x01C4(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnerResetPeriod;                                // 0x01C8(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxActorsSpawnedPerFrame;                          // 0x01CC(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdatePeriod;                                      // 0x01D0(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SuspendTestPeriod;                                 // 0x01D4(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IrrelevantPeriod;                                  // 0x01D8(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AlwaysRelevantDistance;                            // 0x01DC(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AlwaysIrrelevantDistance;                          // 0x01E0(0x0004)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGlobalSpawnDLCData>     GlobalDLCData;                                     // 0x01E8(0x0028)(Edit, Config, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMultiframeSpawning;                            // 0x0210(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 PrivateWorld;                                      // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USpawnDLCData*>                  DLCs;                                              // 0x0220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnerData>                   Spawners;                                          // 0x0250(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        CachedPlayerLocations;                             // 0x0260(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AController*>                    CachedPlayers;                                     // 0x0270(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 SpawnedActor;                                      // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0xA8];                                     // 0x0288(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActorDestroyed(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnManager">();
	}
	static class USpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnManager>();
	}
};
static_assert(alignof(USpawnManager) == 0x000008, "Wrong alignment on USpawnManager");
static_assert(sizeof(USpawnManager) == 0x000330, "Wrong size on USpawnManager");
static_assert(offsetof(USpawnManager, AdditionalSpawnPointOverlapActors) == 0x000030, "Member 'USpawnManager::AdditionalSpawnPointOverlapActors' has a wrong offset!");
static_assert(offsetof(USpawnManager, AsyncRequests) == 0x000188, "Member 'USpawnManager::AsyncRequests' has a wrong offset!");
static_assert(offsetof(USpawnManager, SpawnManagerClassName) == 0x0001A8, "Member 'USpawnManager::SpawnManagerClassName' has a wrong offset!");
static_assert(offsetof(USpawnManager, MaxSpawnCost) == 0x0001C0, "Member 'USpawnManager::MaxSpawnCost' has a wrong offset!");
static_assert(offsetof(USpawnManager, bCanResetSpawners) == 0x0001C4, "Member 'USpawnManager::bCanResetSpawners' has a wrong offset!");
static_assert(offsetof(USpawnManager, SpawnerResetPeriod) == 0x0001C8, "Member 'USpawnManager::SpawnerResetPeriod' has a wrong offset!");
static_assert(offsetof(USpawnManager, MaxActorsSpawnedPerFrame) == 0x0001CC, "Member 'USpawnManager::MaxActorsSpawnedPerFrame' has a wrong offset!");
static_assert(offsetof(USpawnManager, UpdatePeriod) == 0x0001D0, "Member 'USpawnManager::UpdatePeriod' has a wrong offset!");
static_assert(offsetof(USpawnManager, SuspendTestPeriod) == 0x0001D4, "Member 'USpawnManager::SuspendTestPeriod' has a wrong offset!");
static_assert(offsetof(USpawnManager, IrrelevantPeriod) == 0x0001D8, "Member 'USpawnManager::IrrelevantPeriod' has a wrong offset!");
static_assert(offsetof(USpawnManager, AlwaysRelevantDistance) == 0x0001DC, "Member 'USpawnManager::AlwaysRelevantDistance' has a wrong offset!");
static_assert(offsetof(USpawnManager, AlwaysIrrelevantDistance) == 0x0001E0, "Member 'USpawnManager::AlwaysIrrelevantDistance' has a wrong offset!");
static_assert(offsetof(USpawnManager, GlobalDLCData) == 0x0001E8, "Member 'USpawnManager::GlobalDLCData' has a wrong offset!");
static_assert(offsetof(USpawnManager, bUseMultiframeSpawning) == 0x000210, "Member 'USpawnManager::bUseMultiframeSpawning' has a wrong offset!");
static_assert(offsetof(USpawnManager, PrivateWorld) == 0x000218, "Member 'USpawnManager::PrivateWorld' has a wrong offset!");
static_assert(offsetof(USpawnManager, DLCs) == 0x000220, "Member 'USpawnManager::DLCs' has a wrong offset!");
static_assert(offsetof(USpawnManager, Spawners) == 0x000250, "Member 'USpawnManager::Spawners' has a wrong offset!");
static_assert(offsetof(USpawnManager, CachedPlayerLocations) == 0x000260, "Member 'USpawnManager::CachedPlayerLocations' has a wrong offset!");
static_assert(offsetof(USpawnManager, CachedPlayers) == 0x000270, "Member 'USpawnManager::CachedPlayers' has a wrong offset!");
static_assert(offsetof(USpawnManager, SpawnedActor) == 0x000280, "Member 'USpawnManager::SpawnedActor' has a wrong offset!");

// Class GbxSpawn.SpawnSystemEditorSettings
// 0x0008 (0x0040 - 0x0038)
class USpawnSystemEditorSettings final : public UDeveloperSettings
{
public:
	ESpawnSystemStreamStyle                       StreamStyle;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnSystemEditorSettings">();
	}
	static class USpawnSystemEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnSystemEditorSettings>();
	}
};
static_assert(alignof(USpawnSystemEditorSettings) == 0x000008, "Wrong alignment on USpawnSystemEditorSettings");
static_assert(sizeof(USpawnSystemEditorSettings) == 0x000040, "Wrong size on USpawnSystemEditorSettings");
static_assert(offsetof(USpawnSystemEditorSettings, StreamStyle) == 0x000038, "Member 'USpawnSystemEditorSettings::StreamStyle' has a wrong offset!");

// Class GbxSpawn.SpawnOptionData
// 0x0018 (0x0048 - 0x0030)
class USpawnOptionData final : public UGbxDataAsset
{
public:
	TArray<struct FSpawnFactoryData>              Options;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FSpawnDetails                          SpawnDetails;                                      // 0x0040(0x0007)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnOptionData">();
	}
	static class USpawnOptionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnOptionData>();
	}
};
static_assert(alignof(USpawnOptionData) == 0x000008, "Wrong alignment on USpawnOptionData");
static_assert(sizeof(USpawnOptionData) == 0x000048, "Wrong size on USpawnOptionData");
static_assert(offsetof(USpawnOptionData, Options) == 0x000030, "Member 'USpawnOptionData::Options' has a wrong offset!");
static_assert(offsetof(USpawnOptionData, SpawnDetails) == 0x000040, "Member 'USpawnOptionData::SpawnDetails' has a wrong offset!");

// Class GbxSpawn.SpawnPointComponent
// 0x0290 (0x0980 - 0x06F0)
class USpawnPointComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x8];                                      // 0x06F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActorSpawned;                                    // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDied;                                       // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSpawnAnimComplete;                               // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_728[0x1A0];                                    // 0x0728(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x08C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpawnPoint*                            SpawnPoint;                                        // 0x08D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           SpawnAITreeTag;                                    // 0x08D8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           SpawnAction;                                       // 0x08E0(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpawnStretchType                             SpawnStretchType;                                  // 0x08E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E9[0x3];                                      // 0x08E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceToGroundDistance;                             // 0x08EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStretchOrient;                                    // 0x08F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F1[0x7];                                      // 0x08F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x08F8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	ESpawnPointFilter                             FilterMatchType;                                   // 0x0918(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFilterByTags;                                     // 0x0919(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGameplayContainerMatchType                   TagMatchType;                                      // 0x091A(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91B[0x5];                                      // 0x091B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StretchyPoint;                                     // 0x0920(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGbxTriggerProperty                    ResetStretch;                                      // 0x0950(0x0001)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_951[0x1F];                                     // 0x0951(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttachSpawnedActors;                              // 0x0970(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_971[0x7];                                      // 0x0971(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSlotName;                                    // 0x0978(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisableSpawnPoint();
	void EnableSpawnPoint();
	void ResetStretchPoint();
	void SetSpawnStyleTag(const struct FGameplayTag& NewTag);

	struct FGameplayTag GetSpawnAITreeTag() const;
	struct FGameplayTag GetSpawnStyleTag() const;
	struct FTransform GetStretchyPoint() const;
	bool HasSpawnAITreeTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointComponent">();
	}
	static class USpawnPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPointComponent>();
	}
};
static_assert(alignof(USpawnPointComponent) == 0x000010, "Wrong alignment on USpawnPointComponent");
static_assert(sizeof(USpawnPointComponent) == 0x000980, "Wrong size on USpawnPointComponent");
static_assert(offsetof(USpawnPointComponent, OnActorSpawned) == 0x0006F8, "Member 'USpawnPointComponent::OnActorSpawned' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, OnActorDied) == 0x000708, "Member 'USpawnPointComponent::OnActorDied' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, OnSpawnAnimComplete) == 0x000718, "Member 'USpawnPointComponent::OnSpawnAnimComplete' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, bEnabled) == 0x0008C8, "Member 'USpawnPointComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, SpawnPoint) == 0x0008D0, "Member 'USpawnPointComponent::SpawnPoint' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, SpawnAITreeTag) == 0x0008D8, "Member 'USpawnPointComponent::SpawnAITreeTag' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, SpawnAction) == 0x0008E0, "Member 'USpawnPointComponent::SpawnAction' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, SpawnStretchType) == 0x0008E8, "Member 'USpawnPointComponent::SpawnStretchType' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, TraceToGroundDistance) == 0x0008EC, "Member 'USpawnPointComponent::TraceToGroundDistance' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, bStretchOrient) == 0x0008F0, "Member 'USpawnPointComponent::bStretchOrient' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, Tags) == 0x0008F8, "Member 'USpawnPointComponent::Tags' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, FilterMatchType) == 0x000918, "Member 'USpawnPointComponent::FilterMatchType' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, bFilterByTags) == 0x000919, "Member 'USpawnPointComponent::bFilterByTags' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, TagMatchType) == 0x00091A, "Member 'USpawnPointComponent::TagMatchType' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, StretchyPoint) == 0x000920, "Member 'USpawnPointComponent::StretchyPoint' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, ResetStretch) == 0x000950, "Member 'USpawnPointComponent::ResetStretch' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, bAttachSpawnedActors) == 0x000970, "Member 'USpawnPointComponent::bAttachSpawnedActors' has a wrong offset!");
static_assert(offsetof(USpawnPointComponent, AttachSlotName) == 0x000978, "Member 'USpawnPointComponent::AttachSlotName' has a wrong offset!");

// Class GbxSpawn.SpawnPointProvider
// 0x0000 (0x0028 - 0x0028)
class ISpawnPointProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointProvider">();
	}
	static class ISpawnPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnPointProvider>();
	}
};
static_assert(alignof(ISpawnPointProvider) == 0x000008, "Wrong alignment on ISpawnPointProvider");
static_assert(sizeof(ISpawnPointProvider) == 0x000028, "Wrong size on ISpawnPointProvider");

// Class GbxSpawn.SpawnPreviewComponent
// 0x0058 (0x0840 - 0x07E8)
class USpawnPreviewComponent final : public UPreviewComponent
{
public:
	TArray<struct FSpawnPreviewState>             PreviewList;                                       // 0x07E8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         ActiveSpawnPointIdx;                               // 0x07F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7FC[0x4];                                      // 0x07FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 PreviewAction;                                     // 0x0800(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoCycle;                                        // 0x0808(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxTriggerProperty                    CycleActor;                                        // 0x0809(0x0001)(Edit, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bShowAction;                                       // 0x080A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRepeatAction;                                     // 0x080B(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxTriggerProperty                    ReplayAction;                                      // 0x080C(0x0001)(Edit, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80D[0x3];                                      // 0x080D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGbxActionComponent>     ActionComponent;                                   // 0x0810(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USpawnerComponent*>              SpawnerList;                                       // 0x0818(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_828[0x18];                                     // 0x0828(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCycleActor(ECycleDirection Direction);
	void OnReplayAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPreviewComponent">();
	}
	static class USpawnPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPreviewComponent>();
	}
};
static_assert(alignof(USpawnPreviewComponent) == 0x000008, "Wrong alignment on USpawnPreviewComponent");
static_assert(sizeof(USpawnPreviewComponent) == 0x000840, "Wrong size on USpawnPreviewComponent");
static_assert(offsetof(USpawnPreviewComponent, PreviewList) == 0x0007E8, "Member 'USpawnPreviewComponent::PreviewList' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, ActiveSpawnPointIdx) == 0x0007F8, "Member 'USpawnPreviewComponent::ActiveSpawnPointIdx' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, PreviewAction) == 0x000800, "Member 'USpawnPreviewComponent::PreviewAction' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, bAutoCycle) == 0x000808, "Member 'USpawnPreviewComponent::bAutoCycle' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, CycleActor) == 0x000809, "Member 'USpawnPreviewComponent::CycleActor' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, bShowAction) == 0x00080A, "Member 'USpawnPreviewComponent::bShowAction' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, bRepeatAction) == 0x00080B, "Member 'USpawnPreviewComponent::bRepeatAction' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, ReplayAction) == 0x00080C, "Member 'USpawnPreviewComponent::ReplayAction' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, ActionComponent) == 0x000810, "Member 'USpawnPreviewComponent::ActionComponent' has a wrong offset!");
static_assert(offsetof(USpawnPreviewComponent, SpawnerList) == 0x000818, "Member 'USpawnPreviewComponent::SpawnerList' has a wrong offset!");

}

