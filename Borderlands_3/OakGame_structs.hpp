#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OakGame

#include "Basic.hpp"

#include "WwiseAudio_structs.hpp"
#include "GbxInput_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GbxInventory_structs.hpp"
#include "GbxRuntime_structs.hpp"
#include "GbxWeapon_structs.hpp"
#include "GbxSpawn_structs.hpp"
#include "Engine_structs.hpp"
#include "GbxMission_structs.hpp"
#include "SlateCore_structs.hpp"
#include "GbxNav_structs.hpp"
#include "AIModule_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "GbxCameraModes_structs.hpp"
#include "GbxDialog_structs.hpp"
#include "PhysXVehicles_structs.hpp"
#include "InputCore_structs.hpp"
#include "GbxUI_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GbxAbilities_structs.hpp"
#include "GbxAI_structs.hpp"
#include "GbxTravelStation_structs.hpp"


namespace SDK
{

// Enum OakGame.EExitDownStateReason
// NumValues: 0x0008
enum class EExitDownStateReason : uint8
{
	ExitDownStateReason_None                 = 0,
	ExitDownStateReason_Revived              = 1,
	ExitDownStateReason_SecondWind           = 2,
	ExitDownStateReason_TimerExpired         = 3,
	ExitDownStateReason_Interrupted          = 4,
	ExitDownStateReason_Instant              = 5,
	ExitDownStateReason_Custom               = 6,
	ExitDownStateReason_MAX                  = 7,
};

// Enum OakGame.EDownState
// NumValues: 0x0006
enum class EDownState : uint8
{
	DownState_Healthy                        = 0,
	DownState_Down                           = 1,
	DownState_DownAndExerting                = 2,
	DownState_Resurrecting                   = 3,
	DownState_GivingUp                       = 4,
	DownState_MAX                            = 5,
};

// Enum OakGame.EReviveState
// NumValues: 0x0004
enum class EReviveState : uint8
{
	ReviveState_None                         = 0,
	ReviveState_BeingRevived                 = 1,
	ReviveState_Reviving                     = 2,
	ReviveState_MAX                          = 3,
};

// Enum OakGame.EOakElementalType
// NumValues: 0x0007
enum class EOakElementalType : uint8
{
	None                                     = 0,
	Corrosive                                = 1,
	Cryo                                     = 2,
	Fire                                     = 3,
	Shock                                    = 4,
	Radiation                                = 5,
	MAX                                      = 6,
};

// Enum OakGame.EKilledEnemyFriendEventType
// NumValues: 0x0005
enum class EKilledEnemyFriendEventType : uint8
{
	None                                     = 0,
	Enemy                                    = 1,
	NamedEnemy                               = 2,
	Boss                                     = 3,
	EKilledEnemyFriendEventType_MAX          = 4,
};

// Enum OakGame.EMatchmakingState
// NumValues: 0x0007
enum class EMatchmakingState : uint8
{
	Idle                                     = 0,
	PreparingToSearch                        = 1,
	Searching                                = 2,
	ConfirmingPlayers                        = 3,
	StartingGameplay                         = 4,
	Canceling                                = 5,
	EMatchmakingState_MAX                    = 6,
};

// Enum OakGame.EBossbarEventType
// NumValues: 0x0007
enum class EBossbarEventType : uint8
{
	Intro_Event                              = 0,
	Enable_Invulnerable_Event                = 1,
	Disable_Invulnerable_Event               = 2,
	Shake_Event                              = 3,
	Destroy_Event                            = 4,
	NONE                                     = 5,
	EBossbarEventType_MAX                    = 6,
};

// Enum OakGame.EOakLeague
// NumValues: 0x0006
enum class EOakLeague : uint8
{
	OL_None                                  = 0,
	OL_BloodyHarvest                         = 1,
	OL_ValentinesDay                         = 2,
	OL_TheCartels                            = 3,
	OL_SummerOfGreed                         = 4,
	OL_MAX                                   = 5,
};

// Enum OakGame.EEffectivePlayerCountSetting
// NumValues: 0x0004
enum class EEffectivePlayerCountSetting : uint32
{
	GameForced                               = 0,
	UserRequested                            = 1,
	Actual                                   = 2,
	EEffectivePlayerCountSetting_MAX         = 3,
};

// Enum OakGame.EOakGameStateUIGroupMode
// NumValues: 0x0004
enum class EOakGameStateUIGroupMode : uint8
{
	Unknown                                  = 0,
	Cooperation                              = 1,
	Coopetition                              = 2,
	EOakGameStateUIGroupMode_MAX             = 3,
};

// Enum OakGame.EMultiplayerLootMode
// NumValues: 0x0003
enum class EMultiplayerLootMode : uint8
{
	Standard                                 = 0,
	Instanced                                = 1,
	EMultiplayerLootMode_MAX                 = 2,
};

// Enum OakGame.ENewGameState
// NumValues: 0x0005
enum class ENewGameState : uint32
{
	None                                     = 0,
	IntroMovie                               = 1,
	CharacterSelect                          = 2,
	WaitingForPlayerPawns                    = 3,
	ENewGameState_MAX                        = 4,
};

// Enum OakGame.EPlayerExperienceType
// NumValues: 0x0004
enum class EPlayerExperienceType : uint8
{
	Generic                                  = 0,
	Combat                                   = 1,
	Mission                                  = 2,
	EPlayerExperienceType_MAX                = 3,
};

// Enum OakGame.EPlayerExperienceSource
// NumValues: 0x0007
enum class EPlayerExperienceSource : uint8
{
	XPUnknown                                = 0,
	XPCombat                                 = 1,
	PlotMissionAward                         = 2,
	Discovery                                = 3,
	SideMissionAward                         = 4,
	SaveGame                                 = 5,
	EPlayerExperienceSource_MAX              = 6,
};

// Enum OakGame.ECommandRingLocationType
// NumValues: 0x0004
enum class ECommandRingLocationType : uint8
{
	Default                                  = 0,
	Ground                                   = 1,
	Feet                                     = 2,
	ECommandRingLocationType_MAX             = 3,
};

// Enum OakGame.ECommandRingAlignmentType
// NumValues: 0x0007
enum class ECommandRingAlignmentType : uint8
{
	Default                                  = 0,
	SurfaceWorld                             = 1,
	SurfaceView                              = 2,
	View                                     = 3,
	View2D                                   = 4,
	Actor                                    = 5,
	ECommandRingAlignmentType_MAX            = 6,
};

// Enum OakGame.ECommandRingReferenceActorType
// NumValues: 0x0004
enum class ECommandRingReferenceActorType : uint8
{
	Target                                   = 0,
	Owner                                    = 1,
	Custom                                   = 2,
	ECommandRingReferenceActorType_MAX       = 3,
};

// Enum OakGame.EOakStatusEffectResourceEffectType
// NumValues: 0x0002
enum class EOakStatusEffectResourceEffectType : uint8
{
	Cryo                                     = 0,
	EOakStatusEffectResourceEffectType_MAX   = 1,
};

// Enum OakGame.EHealthAdded
// NumValues: 0x0003
enum class EHealthAdded : uint8
{
	Success                                  = 0,
	Falure                                   = 1,
	EHealthAdded_MAX                         = 2,
};

// Enum OakGame.EValidIndex
// NumValues: 0x0003
enum class EValidIndex : uint8
{
	Valid                                    = 0,
	Invalid                                  = 1,
	EValidIndex_MAX                          = 2,
};

// Enum OakGame.EHealthState
// NumValues: 0x0006
enum class EHealthState : uint8
{
	Healthy                                  = 0,
	Low                                      = 1,
	VeryLow                                  = 2,
	Injured                                  = 3,
	Dead                                     = 4,
	EHealthState_MAX                         = 5,
};

// Enum OakGame.EWeaponActionChannel
// NumValues: 0x0005
enum class EWeaponActionChannel : uint8
{
	Use                                      = 0,
	Zoom                                     = 1,
	Reload                                   = 2,
	Other                                    = 3,
	EWeaponActionChannel_MAX                 = 4,
};

// Enum OakGame.EZoomEventType
// NumValues: 0x0004
enum class EZoomEventType : uint8
{
	None                                     = 0,
	ZoomingIn                                = 1,
	ZoomingOut                               = 2,
	EZoomEventType_MAX                       = 3,
};

// Enum OakGame.EDeathType
// NumValues: 0x0007
enum class EDeathType : uint8
{
	None                                     = 0,
	HealthDepleted                           = 1,
	Suicide                                  = 2,
	ScriptedInstantDeath                     = 3,
	FellOutOfWorld                           = 4,
	Ragdoll                                  = 5,
	EDeathType_MAX                           = 6,
};

// Enum OakGame.EOakGender
// NumValues: 0x0004
enum class EOakGender : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	Random                                   = 2,
	EOakGender_MAX                           = 3,
};

// Enum OakGame.EWeaponHolsteredSizeType
// NumValues: 0x0005
enum class EWeaponHolsteredSizeType : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	ExtraLarge                               = 3,
	EWeaponHolsteredSizeType_MAX             = 4,
};

// Enum OakGame.ETargetedNameplateType
// NumValues: 0x0005
enum class ETargetedNameplateType : uint8
{
	Standard                                 = 0,
	NPC                                      = 1,
	Boss                                     = 2,
	None                                     = 3,
	ETargetedNameplateType_MAX               = 4,
};

// Enum OakGame.EA9KSawState
// NumValues: 0x000D
enum class EA9KSawState : uint8
{
	NotStarted                               = 0,
	Cooldown                                 = 1,
	PickTarget                               = 2,
	TryToReachTarget                         = 3,
	ReachedTarget                            = 4,
	EquipSaw                                 = 5,
	WaitForQuipAnimDone                      = 6,
	Anticipation                             = 7,
	PrepareToShootAndShoot                   = 8,
	WaitForBPCallback                        = 9,
	FollowingTarget                          = 10,
	Resting                                  = 11,
	EA9KSawState_MAX                         = 12,
};

// Enum OakGame.EVaultRewardType
// NumValues: 0x0007
enum class EVaultRewardType : uint8
{
	None                                     = 0,
	EridianAnalyser                          = 1,
	EridianResonator                         = 2,
	ArtifactSlot                             = 3,
	EridianFabricator                        = 4,
	MayhemMode                               = 5,
	EVaultRewardType_MAX                     = 6,
};

// Enum OakGame.ETrackedIconOwner
// NumValues: 0x0006
enum class ETrackedIconOwner : uint8
{
	Unknown                                  = 0,
	Released                                 = 1,
	Minimap_Clamped                          = 2,
	Minimap_Interior3D                       = 3,
	InWorldContainer                         = 4,
	ETrackedIconOwner_MAX                    = 5,
};

// Enum OakGame.EAnointedDeathState
// NumValues: 0x0006
enum class EAnointedDeathState : uint8
{
	PreFreeze                                = 0,
	Freezing                                 = 1,
	Frozen                                   = 2,
	ShatterKilled                            = 3,
	TimedOut                                 = 4,
	EAnointedDeathState_MAX                  = 5,
};

// Enum OakGame.EVehicleDeathType
// NumValues: 0x0006
enum class EVehicleDeathType : uint8
{
	None                                     = 0,
	HealthDepleted                           = 1,
	FellOutOfWorld                           = 2,
	DigistuctOut                             = 3,
	InstantDeath                             = 4,
	EVehicleDeathType_MAX                    = 5,
};

// Enum OakGame.EClearInputFilter
// NumValues: 0x0005
enum class EClearInputFilter : uint8
{
	ClearWeapons                             = 1,
	ClearInputComponent                      = 2,
	DisableHover                             = 4,
	ClearAll                                 = 255,
	EClearInputFilter_MAX                    = 256,
};

// Enum OakGame.ENavPainterLayer
// NumValues: 0x0004
enum class ENavPainterLayer : uint8
{
	Default                                  = 0,
	Driver                                   = 1,
	Scripted                                 = 2,
	ENavPainterLayer_MAX                     = 3,
};

// Enum OakGame.EVehicleEffectEvent
// NumValues: 0x001D
enum class EVehicleEffectEvent : uint8
{
	None                                     = 0,
	Boost                                    = 1,
	BoostChargeCountChanged                  = 2,
	BoostPoolEmpty                           = 3,
	BoostPoolFull                            = 4,
	StartEngine                              = 5,
	Braking                                  = 6,
	Hover                                    = 7,
	Horn                                     = 8,
	Digithrust                               = 9,
	ShieldBreak                              = 10,
	ShieldHealthEvent_Normal                 = 11,
	ShieldHealthEvent_Low                    = 12,
	ShieldHealthEvent_VeryLow                = 13,
	ShieldFullHealth                         = 14,
	Backfire                                 = 15,
	MaxRPMBackfire                           = 16,
	HealthEvent_Healthy                      = 17,
	HealthEvent_Low                          = 18,
	HealthEvent_VeryLow                      = 19,
	HealthEvent_Dead                         = 20,
	StatusEffect_CryoFrozen                  = 21,
	StatusEffect_CryoThawing                 = 22,
	StatusEffect_Cryo                        = 23,
	StatusEffect_Corrosive                   = 24,
	StatusEffect_Shock                       = 25,
	StatusEffect_Fire                        = 26,
	StatusEffect_Radiation                   = 27,
	EVehicleEffectEvent_MAX                  = 28,
};

// Enum OakGame.ENavCorrectionSetting
// NumValues: 0x0004
enum class ENavCorrectionSetting : uint8
{
	Default                                  = 0,
	Enabled                                  = 1,
	Disabled                                 = 2,
	ENavCorrectionSetting_MAX                = 3,
};

// Enum OakGame.EVehicleHealthState
// NumValues: 0x0005
enum class EVehicleHealthState : uint8
{
	Healthy                                  = 0,
	Low                                      = 1,
	VeryLow                                  = 2,
	Dead                                     = 3,
	EVehicleHealthState_MAX                  = 4,
};

// Enum OakGame.EIronBearExitReason
// NumValues: 0x0007
enum class EIronBearExitReason : uint8
{
	Undefined                                = 0,
	ActionSkillStopped                       = 1,
	ManualExit                               = 2,
	Died                                     = 3,
	FellOutOfWorld                           = 4,
	EmergencyExit                            = 5,
	EIronBearExitReason_MAX                  = 6,
};

// Enum OakGame.EIronBearHardPointOrientation
// NumValues: 0x0004
enum class EIronBearHardPointOrientation : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EIronBearHardPointOrientation_MAX        = 3,
};

// Enum OakGame.EIronBearCoreType
// NumValues: 0x0009
enum class EIronBearCoreType : uint8
{
	None                                     = 0,
	GundamBear                               = 1,
	StrengthThroughBalance                   = 2,
	GunnersNest                              = 3,
	SurpriseforYou                           = 4,
	VeryIronBear                             = 5,
	HighVoltage                              = 6,
	IronCub                                  = 7,
	EIronBearCoreType_MAX                    = 8,
};

// Enum OakGame.EIronBearDamageLevel
// NumValues: 0x0005
enum class EIronBearDamageLevel : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Moderate                                 = 2,
	Heavy                                    = 3,
	EIronBearDamageLevel_MAX                 = 4,
};

// Enum OakGame.EIronBearSpawnStyle
// NumValues: 0x0003
enum class EIronBearSpawnStyle : uint8
{
	Full                                     = 0,
	Quick                                    = 1,
	EIronBearSpawnStyle_MAX                  = 2,
};

// Enum OakGame.EJumpType
// NumValues: 0x0006
enum class EJumpType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Sprint                                   = 2,
	Slide                                    = 3,
	UpwardLadderJump                         = 4,
	EJumpType_MAX                            = 5,
};

// Enum OakGame.EGameModeNotificationType
// NumValues: 0x0015
enum class EGameModeNotificationType : uint8
{
	None                                     = 0,
	Raid_RaidSurvived                        = 1,
	Raid_TeleporterActivated                 = 2,
	Raid_Defeat                              = 3,
	Raid_PlayerIsOut                         = 4,
	Raid_Start                               = 5,
	Raid_CountDown                           = 6,
	COS_Victory                              = 7,
	COS_Defeat                               = 8,
	COS_Wave                                 = 9,
	COS_NotAllPlayersAssembled               = 10,
	GearUp_Victory                           = 11,
	GearUp_Defeat                            = 12,
	GearUp_Respawn                           = 13,
	GearUp_Start                             = 14,
	GearUp_Countdown                         = 15,
	GearUp_SupplyDrop                        = 16,
	GearUp_CircleClosing                     = 17,
	GearUp_NewCircle                         = 18,
	Off                                      = 19,
	EGameModeNotificationType_MAX            = 20,
};

// Enum OakGame.EDeathCircleStatus
// NumValues: 0x0005
enum class EDeathCircleStatus : uint8
{
	DCS_None                                 = 0,
	DCS_Stable                               = 1,
	DCS_Transitioning                        = 2,
	DCS_Complete                             = 3,
	DCS_MAX                                  = 4,
};

// Enum OakGame.EOakReticleFeedbackGameEvent
// NumValues: 0x0004
enum class EOakReticleFeedbackGameEvent : uint8
{
	None                                     = 0,
	DamageCaused                             = 1,
	DeathCaused                              = 2,
	EOakReticleFeedbackGameEvent_MAX         = 3,
};

// Enum OakGame.ECanReRollInventoryResult
// NumValues: 0x0004
enum class ECanReRollInventoryResult : uint8
{
	Yes                                      = 0,
	CantAfford                               = 1,
	No                                       = 2,
	ECanReRollInventoryResult_MAX            = 3,
};

// Enum OakGame.EPOIActivationResult
// NumValues: 0x000A
enum class EPOIActivationResult : uint8
{
	Success                                  = 0,
	Failure_Generic                          = 1,
	Failure_PlayerInMenu                     = 2,
	Failure_AllyDown                         = 3,
	Failure_FastTravelDisabled               = 4,
	Failure_PlayerInVehicle                  = 5,
	Failure_ClientJoining                    = 6,
	Failure_PlayerDueling                    = 7,
	Failure_PhotoModeActive                  = 8,
	EPOIActivationResult_MAX                 = 9,
};

// Enum OakGame.EKickReason
// NumValues: 0x0008
enum class EKickReason : uint8
{
	None                                     = 0,
	Kicked                                   = 1,
	Invite                                   = 2,
	QuitGame                                 = 3,
	SessionEnd                               = 4,
	TitleScreen                              = 5,
	IncompatibleMission                      = 6,
	EKickReason_MAX                          = 7,
};

// Enum OakGame.EInventoryListType
// NumValues: 0x0005
enum class EInventoryListType : uint8
{
	IL_Primary                               = 0,
	IL_Bank                                  = 1,
	IL_LostLoot                              = 2,
	IL_GearUp                                = 3,
	IL_MAX                                   = 4,
};

// Enum OakGame.EAutosellRarityEnum
// NumValues: 0x0006
enum class EAutosellRarityEnum : uint8
{
	NONE                                     = 0,
	COMMON                                   = 1,
	UNCOMMON                                 = 2,
	RARE                                     = 3,
	EPIC                                     = 4,
	MAX                                      = 5,
};

// Enum OakGame.EPlayerDifficultySetting
// NumValues: 0x0003
enum class EPlayerDifficultySetting : uint8
{
	Normal                                   = 0,
	StoryMode                                = 1,
	MAX                                      = 2,
};

// Enum OakGame.ELateJoinState
// NumValues: 0x0004
enum class ELateJoinState : uint8
{
	NotLateJoining                           = 0,
	SelectingCharacter                       = 1,
	ApplyingSaveGame                         = 2,
	ELateJoinState_MAX                       = 3,
};

// Enum OakGame.ETradeRequestReceptionType
// NumValues: 0x0004
enum class ETradeRequestReceptionType : uint8
{
	All                                      = 0,
	FriendsOnly                              = 1,
	Off                                      = 2,
	MAX                                      = 3,
};

// Enum OakGame.EHyperHoopState
// NumValues: 0x0008
enum class EHyperHoopState : uint8
{
	Invalid                                  = 0,
	NotStarted                               = 1,
	AttachingPawn                            = 2,
	Accelerating                             = 3,
	Moving                                   = 4,
	Deccelerating                            = 5,
	DetachingPawn                            = 6,
	EHyperHoopState_MAX                      = 7,
};

// Enum OakGame.EVendingMachineBuyType
// NumValues: 0x0005
enum class EVendingMachineBuyType : uint8
{
	Regular                                  = 0,
	BuyBack                                  = 1,
	GearSoldByFriend                         = 2,
	ItemOfTheDay                             = 3,
	EVendingMachineBuyType_MAX               = 4,
};

// Enum OakGame.EVendingMachineScrollDirection
// NumValues: 0x0003
enum class EVendingMachineScrollDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	EVendingMachineScrollDirection_MAX       = 2,
};

// Enum OakGame.EGrenadeThrowFailureReason
// NumValues: 0x0006
enum class EGrenadeThrowFailureReason : uint8
{
	UnknownError                             = 0,
	ActionsLocked                            = 1,
	NotHealthy                               = 2,
	InternalCooldown                         = 3,
	NotEnoughAmmo                            = 4,
	EGrenadeThrowFailureReason_MAX           = 5,
};

// Enum OakGame.EDuelClassification
// NumValues: 0x0003
enum class EDuelClassification : uint8
{
	Standard1v1                              = 0,
	FreeForAll                               = 1,
	EDuelClassification_MAX                  = 2,
};

// Enum OakGame.EDuelLoseReason
// NumValues: 0x0005
enum class EDuelLoseReason : uint8
{
	None                                     = 0,
	PlayerKilled                             = 1,
	PlayerQuit                               = 2,
	OutOfBounds                              = 3,
	EDuelLoseReason_MAX                      = 4,
};

// Enum OakGame.EVehicleImpactForce
// NumValues: 0x0008
enum class EVehicleImpactForce : uint8
{
	Unknown                                  = 0,
	Grinding                                 = 1,
	VerySmall                                = 2,
	Small                                    = 3,
	Medium                                   = 4,
	Heavy                                    = 5,
	Count                                    = 6,
	EVehicleImpactForce_MAX                  = 7,
};

// Enum OakGame.EEffectStateType
// NumValues: 0x0004
enum class EEffectStateType : uint8
{
	Play                                     = 0,
	Stop                                     = 1,
	Count                                    = 2,
	EEffectStateType_MAX                     = 3,
};

// Enum OakGame.EFreezeType
// NumValues: 0x0003
enum class EFreezeType : uint8
{
	Cryo                                     = 0,
	Anointed                                 = 1,
	MAX                                      = 2,
};

// Enum OakGame.EShieldEffectState
// NumValues: 0x0004
enum class EShieldEffectState : uint8
{
	Full                                     = 0,
	Damaged                                  = 1,
	Depleted                                 = 2,
	EShieldEffectState_MAX                   = 3,
};

// Enum OakGame.EFreezeState
// NumValues: 0x0005
enum class EFreezeState : uint8
{
	None                                     = 0,
	Freezing                                 = 1,
	Frozen                                   = 2,
	Thawing                                  = 3,
	EFreezeState_MAX                         = 4,
};

// Enum OakGame.EOakUIInventoryItemUseType
// NumValues: 0x0004
enum class EOakUIInventoryItemUseType : uint32
{
	Unknown                                  = 0,
	EquippableInternal                       = 1,
	UsableInternal                           = 2,
	EOakUIInventoryItemUseType_MAX           = 3,
};

// Enum OakGame.EInteractiveObjectInteractiveState
// NumValues: 0x0005
enum class EInteractiveObjectInteractiveState : uint8
{
	None                                     = 0,
	Interactive                              = 1,
	NonInteractive                           = 2,
	Uninitialized                            = 3,
	EInteractiveObjectInteractiveState_MAX   = 4,
};

// Enum OakGame.EInteractiveObjectLockState
// NumValues: 0x0005
enum class EInteractiveObjectLockState : uint8
{
	None                                     = 0,
	Unlocked                                 = 1,
	Locked                                   = 2,
	Uninitialized                            = 3,
	EInteractiveObjectLockState_MAX          = 4,
};

// Enum OakGame.EInteractiveObjectState
// NumValues: 0x0008
enum class EInteractiveObjectState : uint8
{
	None                                     = 0,
	Enabling                                 = 1,
	Enabled                                  = 2,
	Disabling                                = 3,
	Disabled                                 = 4,
	Locked                                   = 5,
	Uninitialized                            = 6,
	EInteractiveObjectState_MAX              = 7,
};

// Enum OakGame.EPlayerAlertType
// NumValues: 0x0007
enum class EPlayerAlertType : uint8
{
	Location                                 = 0,
	Neutral                                  = 1,
	Friendly                                 = 2,
	Hostile                                  = 3,
	Loot                                     = 4,
	Chest                                    = 5,
	Max                                      = 6,
};

// Enum OakGame.EInteractiveObjectTrapActivationType
// NumValues: 0x0003
enum class EInteractiveObjectTrapActivationType : uint8
{
	ActivateTrap                             = 0,
	DeactivateTrap                           = 1,
	EInteractiveObjectTrapActivationType_MAX = 2,
};

// Enum OakGame.EManagedWidgetType
// NumValues: 0x0003
enum class EManagedWidgetType : uint8
{
	Basic                                    = 0,
	OnlineMessageAnimation                   = 1,
	EManagedWidgetType_MAX                   = 2,
};

// Enum OakGame.EZoneMapChallengeStatus
// NumValues: 0x0004
enum class EZoneMapChallengeStatus : uint8
{
	ZMC_AvailableChallenge                   = 0,
	ZMC_CompletedChallenge                   = 1,
	ZMC_Unknown                              = 2,
	ZMC_MAX                                  = 3,
};

// Enum OakGame.EZoneMapMissionStatus
// NumValues: 0x0007
enum class EZoneMapMissionStatus : uint8
{
	ZMM_AvailableMission                     = 0,
	ZMM_TrackedObjective                     = 1,
	ZMM_OptionalObjective                    = 2,
	ZMM_NotTrackedObjective                  = 3,
	ZMM_OutOfMap                             = 4,
	ZMM_Unknown                              = 5,
	ZMM_MAX                                  = 6,
};

// Enum OakGame.EZoneMapViewerState
// NumValues: 0x0005
enum class EZoneMapViewerState : uint8
{
	Level                                    = 0,
	Planet                                   = 1,
	Galaxy                                   = 2,
	Invalid                                  = 3,
	EZoneMapViewerState_MAX                  = 4,
};

// Enum OakGame.EZoneMapMovementMode
// NumValues: 0x0004
enum class EZoneMapMovementMode : uint8
{
	Direct                                   = 0,
	Interpolate                              = 1,
	Animate                                  = 2,
	EZoneMapMovementMode_MAX                 = 3,
};

// Enum OakGame.EMissionDeliveryMenuDisplayState
// NumValues: 0x0003
enum class EMissionDeliveryMenuDisplayState : uint8
{
	Description                              = 0,
	Friends                                  = 1,
	EMissionDeliveryMenuDisplayState_MAX     = 2,
};

// Enum OakGame.EOakMessageType
// NumValues: 0x0006
enum class EOakMessageType : uint8
{
	MessageType_PlayerJoined                 = 1,
	MessageType_PlayerChangedName            = 2,
	MessageType_PlayerLeft                   = 4,
	MessageType_PlayerUnableToJoin           = 7,
	MessageType_SpectatorJoined              = 16,
	MessageType_MAX                          = 17,
};

// Enum OakGame.EMessageSpecialType
// NumValues: 0x0004
enum class EMessageSpecialType : uint8
{
	MST_None                                 = 0,
	MST_TradeOffer                           = 1,
	MST_SeatSwapOffer                        = 2,
	MST_MAX                                  = 3,
};

// Enum OakGame.EMainMenuViewpointType
// NumValues: 0x0008
enum class EMainMenuViewpointType : uint8
{
	TitleScreen                              = 0,
	OptionsMenu                              = 1,
	PlaythroughMode                          = 2,
	NewGameSettings                          = 3,
	MainMenuGroup                            = 4,
	CharacterSelect                          = 5,
	BehindTheScenes                          = 6,
	MAX                                      = 7,
};

// Enum OakGame.EActivityFeedImageAspectRatio
// NumValues: 0x0006
enum class EActivityFeedImageAspectRatio : uint8
{
	FEED_IMAGE_ASPECT_RATIO_1_X_1            = 0,
	FEED_IMAGE_ASPECT_RATIO_1_51_X_1         = 1,
	FEED_IMAGE_ASPECT_RATIO_2_08_X_1         = 2,
	FEED_IMAGE_ASPECT_RATIO_16_X_9           = 3,
	FEED_IMAGE_ASPECT_RATIO_4_X_3            = 4,
	FEED_IMAGE_ASPECT_RATIO_MAX              = 5,
};

// Enum OakGame.EAIOOrientedParticleTargetType
// NumValues: 0x0004
enum class EAIOOrientedParticleTargetType : uint8
{
	None                                     = 0,
	DefaultPosition                          = 1,
	UIObject                                 = 2,
	EAIOOrientedParticleTargetType_MAX       = 3,
};

// Enum OakGame.EA9KFightPhase
// NumValues: 0x0007
enum class EA9KFightPhase : uint8
{
	NotStarted                               = 0,
	Phase1                                   = 1,
	Phase2                                   = 2,
	Phase3                                   = 3,
	Phase4                                   = 4,
	Dead                                     = 5,
	EA9KFightPhase_MAX                       = 6,
};

// Enum OakGame.EVehicleAchetypeNative
// NumValues: 0x0007
enum class EVehicleAchetypeNative : uint8
{
	Null                                     = 0,
	Technical                                = 1,
	Outrunner                                = 2,
	Revolver                                 = 3,
	Emperor                                  = 4,
	Num                                      = 5,
	EVehicleAchetypeNative_MAX               = 6,
};

// Enum OakGame.EHeldActorPreset
// NumValues: 0x0004
enum class EHeldActorPreset : uint8
{
	Explosive                                = 0,
	Melee                                    = 1,
	Shield                                   = 2,
	EHeldActorPreset_MAX                     = 3,
};

// Enum OakGame.ECarnivoraBones
// NumValues: 0x0027
enum class ECarnivoraBones : uint8
{
	Root                                     = 0,
	RW_Root                                  = 1,
	RW_SuspensionR0                          = 2,
	RW_SuspensionR1                          = 3,
	RW_Wheel0                                = 4,
	RW_Tire0                                 = 5,
	RW_Wheel1                                = 6,
	RW_Tire1                                 = 7,
	RW_Wheel2                                = 8,
	RW_Tire2                                 = 9,
	RW_SuspensionB0                          = 10,
	RW_SuspensionB1                          = 11,
	TrackShaft3                              = 12,
	TrackSuspension3                         = 13,
	TrackTire3                               = 14,
	TrackShaft3_T                            = 15,
	SideAxle                                 = 16,
	TrackShaft0                              = 17,
	TrackSuspension2                         = 18,
	TrackTire2                               = 19,
	TrackShaft0_T                            = 20,
	SideAxle1                                = 21,
	TrackShaft1                              = 22,
	SideAxleSecondary                        = 23,
	TrackSuspension1                         = 24,
	TrackTire1                               = 25,
	TrackShaft1_T                            = 26,
	SideAxleSecondary1                       = 27,
	SideAxle2                                = 28,
	TrackShaft2                              = 29,
	TrackSuspension0                         = 30,
	TrackTire0                               = 31,
	TrackShaft2_T                            = 32,
	TunnelDoor                               = 33,
	MainAxle                                 = 34,
	MainAxle_Part1                           = 35,
	MainAxle_Part2                           = 36,
	Count                                    = 37,
	ECarnivoraBones_MAX                      = 38,
};

// Enum OakGame.EEmperorBones
// NumValues: 0x0025
enum class EEmperorBones : uint8
{
	Body                                     = 0,
	Cannon_Yaw                               = 1,
	Cannon_Pitch                             = 2,
	Cannon_Recoil                            = 3,
	EntropyCore                              = 4,
	CannonTurret_Main                        = 5,
	CannonTurret_Pitch                       = 6,
	L_Turret_Yaw                             = 7,
	L_Turret_Pitch                           = 8,
	R_Turret_Yaw                             = 9,
	R_Turret_Pitch                           = 10,
	F_R_Wheel                                = 11,
	F_R_Wheel1                               = 12,
	F_R_Wheel2                               = 13,
	F_L_Wheel                                = 14,
	F_L_Wheel1                               = 15,
	F_L_Wheel2                               = 16,
	R_R_Wheel                                = 17,
	R_L_Wheel                                = 18,
	R_L_Wheel1                               = 19,
	R_R_Wheel1                               = 20,
	F_L_ThreadSuspension                     = 21,
	F_R_ThreadSuspension                     = 22,
	F_L_BigWheel_Suspension                  = 23,
	F_R_BigWheel_Suspension                  = 24,
	F_R_Hover01                              = 25,
	F_R_Hover02                              = 26,
	F_R_Hover03                              = 27,
	F_L_Hover01                              = 28,
	F_L_Hover02                              = 29,
	F_L_Hover03                              = 30,
	R_R_Hover01                              = 31,
	R_R_Hover02                              = 32,
	R_L_Hover01                              = 33,
	R_L_Hover02                              = 34,
	Count                                    = 35,
	EEmperorBones_MAX                        = 36,
};

// Enum OakGame.EOutrunnerBoosterBones
// NumValues: 0x000E
enum class EOutrunnerBoosterBones : uint8
{
	Body                                     = 0,
	L_Muffler                                = 1,
	R_Muffler                                = 2,
	M_Turbine                                = 3,
	L_Turbine                                = 4,
	R_Turbine                                = 5,
	L_Top_Muffler                            = 6,
	L_Bot_Muffler                            = 7,
	R_Top_Muffler                            = 8,
	R_Bot_Muffler                            = 9,
	L_Razor_Wing                             = 10,
	R_Razor_Wing                             = 11,
	Count                                    = 12,
	EOutrunnerBoosterBones_MAX               = 13,
};

// Enum OakGame.EOutrunnerBones
// NumValues: 0x001D
enum class EOutrunnerBones : uint8
{
	Body                                     = 0,
	F_L_SuspensionArm                        = 1,
	F_L_Steering                             = 2,
	F_L_Wheel                                = 3,
	F_R_SuspensionArm                        = 4,
	F_R_Steering                             = 5,
	F_R_Wheel                                = 6,
	R_L_SuspensionArm                        = 7,
	R_L_Steering                             = 8,
	R_L_Wheel                                = 9,
	R_R_SuspensionArm                        = 10,
	R_R_Steering                             = 11,
	R_R_Wheel                                = 12,
	Turret_Yaw                               = 13,
	F_Cannon                                 = 14,
	F_Cannon_Visual                          = 15,
	Turret_Pitch                             = 16,
	SteeringWheel                            = 17,
	F_L_Spring01                             = 18,
	F_L_Spring02                             = 19,
	F_R_Spring01                             = 20,
	F_R_Spring02                             = 21,
	R_L_Spring01                             = 22,
	R_L_Spring02                             = 23,
	R_R_Spring01                             = 24,
	R_R_Spring02                             = 25,
	SeatMain                                 = 26,
	Count                                    = 27,
	EOutrunnerBones_MAX                      = 28,
};

// Enum OakGame.ERevolverBoosterBones
// NumValues: 0x0006
enum class ERevolverBoosterBones : uint8
{
	Root                                     = 0,
	Main                                     = 1,
	Muffler                                  = 2,
	Helix                                    = 3,
	Count                                    = 4,
	ERevolverBoosterBones_MAX                = 5,
};

// Enum OakGame.ERevolverBones
// NumValues: 0x0006
enum class ERevolverBones : uint8
{
	Body_Banking                             = 0,
	Body_Pitch                               = 1,
	Wheels                                   = 2,
	SteeringWheel                            = 3,
	Count                                    = 4,
	ERevolverBones_MAX                       = 5,
};

// Enum OakGame.ETechnicalBones
// NumValues: 0x003C
enum class ETechnicalBones : uint8
{
	Body                                     = 0,
	LeftMuffler                              = 1,
	RightMuffler                             = 2,
	Engine                                   = 3,
	R_Axle                                   = 4,
	R_R_Wheel                                = 5,
	R_L_Wheel                                = 6,
	F_R_Wheel                                = 7,
	F_L_Wheel                                = 8,
	F_L_Axle                                 = 9,
	F_L_Steering                             = 10,
	F_L_Steering_T                           = 11,
	F_L_SteeringShaft                        = 12,
	F_L_SuspensionUp                         = 13,
	F_L_SuspensionBodyUp_T                   = 14,
	F_L_SuspensionBodyDn                     = 15,
	F_L_SuspensionDn_T                       = 16,
	F_L_SuspensionSprings                    = 17,
	F_L_SuspensionSpringsBody                = 18,
	F_R_Axle                                 = 19,
	F_R_Steering                             = 20,
	F_R_Steering_T                           = 21,
	F_R_SteeringShaft                        = 22,
	F_R_SuspensionUp                         = 23,
	F_R_SuspensionBodyUp_T                   = 24,
	F_R_SuspensionBodyDn                     = 25,
	F_R_SuspensionDn_T                       = 26,
	F_R_SuspensionSprings                    = 27,
	F_R_SuspensionSpringsBody                = 28,
	F_Cannon                                 = 29,
	F_Cannon_Visual                          = 30,
	Turret                                   = 31,
	Player2                                  = 32,
	R_DriveShaftPole                         = 33,
	R_DriveShaftBodyPole                     = 34,
	R_DriveShaftAttach                       = 35,
	R_DriveShaftBodyAttach                   = 36,
	F_R_DriveShaft00                         = 37,
	F_R_DriveShaft01                         = 38,
	F_R_DriveShaft02                         = 39,
	F_L_DriveShaft00                         = 40,
	F_L_DriveShaft01                         = 41,
	F_L_DriveShaft02                         = 42,
	SteeringWheel                            = 43,
	F_R_Wheel_Hover                          = 44,
	F_L_Wheel_Hover                          = 45,
	R_R_Wheel_Hover                          = 46,
	R_L_Wheel_Hover                          = 47,
	F_DriveShaftAttach                       = 48,
	F_DriveShaftPole                         = 49,
	F_DriveShaftBodyAttach                   = 50,
	R_L_Suspension_Body                      = 51,
	R_L_Suspension_Axle                      = 52,
	R_R_Suspension_Body                      = 53,
	R_R_Suspension_Axle                      = 54,
	EngineShaft                              = 55,
	EngineBelt                               = 56,
	Seat                                     = 57,
	Count                                    = 58,
	ETechnicalBones_MAX                      = 59,
};

// Enum OakGame.ETrailerBones
// NumValues: 0x000C
enum class ETrailerBones : uint8
{
	F_Axle                                   = 0,
	F_R_Wheel                                = 1,
	F_L_Wheel                                = 2,
	R_Axle                                   = 3,
	R_R_Wheel                                = 4,
	R_L_Wheel                                = 5,
	R_R_Spring_Axle                          = 6,
	R_L_Spring_Axle                          = 7,
	R_R_Spring_Body                          = 8,
	R_L_Spring_Body                          = 9,
	Count                                    = 10,
	ETrailerBones_MAX                        = 11,
};

// Enum OakGame.EDualWeaponBones
// NumValues: 0x0017
enum class EDualWeaponBones : uint8
{
	Root                                     = 0,
	Main                                     = 1,
	Base                                     = 2,
	L_Base                                   = 3,
	L_Shoulder                               = 4,
	L_Elbow                                  = 5,
	L_End                                    = 6,
	L_Elbow_Piston                           = 7,
	L_Shoulder_Piston                        = 8,
	L_Pitch                                  = 9,
	L_Projectile                             = 10,
	R_Base                                   = 11,
	R_Shoulder                               = 12,
	R_Elbow                                  = 13,
	R_End                                    = 14,
	R_Elbow_Piston                           = 15,
	R_Shoulder_Piston                        = 16,
	R_Pitch                                  = 17,
	R_Projectile                             = 18,
	L_BaseAttach                             = 19,
	R_BaseAttach                             = 20,
	Count                                    = 21,
	EDualWeaponBones_MAX                     = 22,
};

// Enum OakGame.EWeaponBones
// NumValues: 0x000A
enum class EWeaponBones : uint8
{
	None                                     = 0,
	Root                                     = 1,
	Main                                     = 2,
	Turret_Yaw                               = 3,
	Turret_Pitch                             = 4,
	Cannon_Yaw                               = 5,
	Cannon_Pitch                             = 6,
	Projectile                               = 7,
	Count                                    = 8,
	EWeaponBones_MAX                         = 9,
};

// Enum OakGame.EPetRespawnCooldownRefundType
// NumValues: 0x0002
enum class EPetRespawnCooldownRefundType : uint8
{
	PetProfileChanged                        = 0,
	EPetRespawnCooldownRefundType_MAX        = 1,
};

// Enum OakGame.EPetReleaseReason
// NumValues: 0x0005
enum class EPetReleaseReason : uint8
{
	SpawnCheckFailed                         = 0,
	PetProfileChanged                        = 1,
	PetDied                                  = 2,
	PlayerDied                               = 3,
	EPetReleaseReason_MAX                    = 4,
};

// Enum OakGame.EBehindTheScenesItemType
// NumValues: 0x0003
enum class EBehindTheScenesItemType : uint8
{
	Video                                    = 0,
	Slideshow                                = 1,
	EBehindTheScenesItemType_MAX             = 2,
};

// Enum OakGame.EIntroType
// NumValues: 0x0005
enum class EIntroType : uint8
{
	EnterFromGround                          = 0,
	EnterFromSwapSeat                        = 1,
	HijackFromGround                         = 2,
	HijackFromSwapSeat                       = 3,
	EIntroType_MAX                           = 4,
};

// Enum OakGame.ECARStatus
// NumValues: 0x0005
enum class ECARStatus : uint8
{
	Locked                                   = 0,
	Unfolding                                = 1,
	Active                                   = 2,
	Inactive                                 = 3,
	ECARStatus_MAX                           = 4,
};

// Enum OakGame.ECarnivoraFakeTurretShootingStyle
// NumValues: 0x0003
enum class ECarnivoraFakeTurretShootingStyle : uint8
{
	TARGET_AROUND_PLAYER                     = 0,
	CONE_IN_DIRECTION                        = 1,
	ECarnivoraFakeTurretShootingStyle_MAX    = 2,
};

// Enum OakGame.ECarnivoraAverageLocation
// NumValues: 0x0006
enum class ECarnivoraAverageLocation : uint8
{
	FRONT_RIGHT                              = 0,
	FRONT_LEFT                               = 1,
	BACK_RIGHT                               = 2,
	BACK_LEFT                                = 3,
	NUM                                      = 4,
	ECarnivoraAverageLocation_MAX            = 5,
};

// Enum OakGame.ECarnivoraPartName
// NumValues: 0x0009
enum class ECarnivoraPartName : uint8
{
	FRONT_WHEEL_0                            = 0,
	FRONT_WHEEL_1                            = 1,
	FRONT_WHEEL_2                            = 2,
	TIRE_TRACK_0                             = 3,
	TIRE_TRACK_1                             = 4,
	TIRE_TRACK_2                             = 5,
	TIRE_TRACK_3                             = 6,
	NUM                                      = 7,
	ECarnivoraPartName_MAX                   = 8,
};

// Enum OakGame.ECharacterEchoDataMediaPlaybackType
// NumValues: 0x0003
enum class ECharacterEchoDataMediaPlaybackType : uint32
{
	PlayAndClose                             = 0,
	LoopUntilAudioEnds                       = 1,
	ECharacterEchoDataMediaPlaybackType_MAX  = 2,
};

// Enum OakGame.ECrosshairColorsEnum
// NumValues: 0x0008
enum class ECrosshairColorsEnum : uint8
{
	NONE                                     = 0,
	WHITE                                    = 1,
	GREEN                                    = 2,
	RED                                      = 3,
	TEAL                                     = 4,
	ORANGE                                   = 5,
	PURPLE                                   = 6,
	MAX                                      = 7,
};

// Enum OakGame.EDamagePresentationLevel
// NumValues: 0x0005
enum class EDamagePresentationLevel : uint8
{
	Negligible                               = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	MAX                                      = 4,
};

// Enum OakGame.EDiscoveryAreaDrawStyle
// NumValues: 0x0005
enum class EDiscoveryAreaDrawStyle : uint8
{
	None                                     = 0,
	Wire                                     = 1,
	Solid                                    = 2,
	SolidAndWire                             = 3,
	EDiscoveryAreaDrawStyle_MAX              = 4,
};

// Enum OakGame.EDuelTotemDestroyReason
// NumValues: 0x0005
enum class EDuelTotemDestroyReason : uint8
{
	None                                     = 0,
	TimedOut                                 = 1,
	Canceled                                 = 2,
	DuelFinished                             = 3,
	EDuelTotemDestroyReason_MAX              = 4,
};

// Enum OakGame.EPotentialDuelState
// NumValues: 0x0005
enum class EPotentialDuelState : uint8
{
	None                                     = 0,
	WaitingToBeAccepted                      = 1,
	WaitingToStart                           = 2,
	Started                                  = 3,
	EPotentialDuelState_MAX                  = 4,
};

// Enum OakGame.EActiveDuelStatus
// NumValues: 0x0004
enum class EActiveDuelStatus : uint8
{
	WaitingToStart                           = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	EActiveDuelStatus_MAX                    = 3,
};

// Enum OakGame.EDuelMode
// NumValues: 0x0003
enum class EDuelMode : uint8
{
	OnFoot                                   = 0,
	Vehicle                                  = 1,
	EDuelMode_MAX                            = 2,
};

// Enum OakGame.ECanSprintResult
// NumValues: 0x0004
enum class ECanSprintResult : uint8
{
	Yes                                      = 0,
	No                                       = 1,
	Cancel                                   = 2,
	ECanSprintResult_MAX                     = 3,
};

// Enum OakGame.EEchoDeviceButton
// NumValues: 0x0005
enum class EEchoDeviceButton : uint8
{
	Button1                                  = 0,
	Button2                                  = 1,
	Button3                                  = 2,
	Count                                    = 3,
	EEchoDeviceButton_MAX                    = 4,
};

// Enum OakGame.EEchoLogBlockedStartMethod
// NumValues: 0x0005
enum class EEchoLogBlockedStartMethod : uint8
{
	Cancel                                   = 0,
	PlayInWorldOnly                          = 1,
	Queue                                    = 2,
	Interrupt                                = 3,
	EEchoLogBlockedStartMethod_MAX           = 4,
};

// Enum OakGame.EEchoLogDisplayCategory
// NumValues: 0x0004
enum class EEchoLogDisplayCategory : uint8
{
	EchoLog                                  = 0,
	EridianLog                               = 1,
	TyphonLog                                = 2,
	EEchoLogDisplayCategory_MAX              = 3,
};

// Enum OakGame.EDamagePresentationModifier
// NumValues: 0x0004
enum class EDamagePresentationModifier : uint8
{
	Default                                  = 0,
	Increase                                 = 1,
	Decrease                                 = 2,
	EDamagePresentationModifier_MAX          = 3,
};

// Enum OakGame.EElementalEffectSizeComputationType
// NumValues: 0x0003
enum class EElementalEffectSizeComputationType : uint8
{
	BoundsSphereRadius                       = 0,
	BoundsBoxExtentMaxAxis                   = 1,
	EElementalEffectSizeComputationType_MAX  = 2,
};

// Enum OakGame.EElementalInteractionMode
// NumValues: 0x0004
enum class EElementalInteractionMode : uint8
{
	Default                                  = 0,
	OnlyTransmit                             = 1,
	OnlyReceive                              = 2,
	EElementalInteractionMode_MAX            = 3,
};

// Enum OakGame.EElementalInteractionSourceMode
// NumValues: 0x0005
enum class EElementalInteractionSourceMode : uint8
{
	Default                                  = 0,
	Always                                   = 1,
	Never                                    = 2,
	OnlyThroughBlueprint                     = 3,
	EElementalInteractionSourceMode_MAX      = 4,
};

// Enum OakGame.EPuddleState
// NumValues: 0x0005
enum class EPuddleState : uint8
{
	Spawning                                 = 0,
	Idle                                     = 1,
	CleaningUp                               = 2,
	CleanedUp                                = 3,
	EPuddleState_MAX                         = 4,
};

// Enum OakGame.ENativeEnemyExperienceType
// NumValues: 0x000A
enum class ENativeEnemyExperienceType : uint8
{
	Chump                                    = 0,
	Normal                                   = 1,
	NormalHigh                               = 2,
	Tough                                    = 3,
	ToughHigh                                = 4,
	Badass                                   = 5,
	SuperBadass                              = 6,
	UltimateBadass                           = 7,
	Boss                                     = 8,
	ENativeEnemyExperienceType_MAX           = 9,
};

// Enum OakGame.EWeaponInputChannel
// NumValues: 0x0003
enum class EWeaponInputChannel : uint8
{
	Channel1                                 = 0,
	Channel2                                 = 1,
	EWeaponInputChannel_MAX                  = 255,
};

// Enum OakGame.EWeaponUseMode
// NumValues: 0x0004
enum class EWeaponUseMode : uint8
{
	Mode1                                    = 0,
	Mode2                                    = 1,
	Mode3                                    = 2,
	EWeaponUseMode_MAX                       = 255,
};

// Enum OakGame.EFriendEventPriority
// NumValues: 0x0005
enum class EFriendEventPriority : uint8
{
	Highest                                  = 0,
	High                                     = 1,
	Normal                                   = 2,
	Low                                      = 3,
	EFriendEventPriority_MAX                 = 4,
};

// Enum OakGame.EFriendEventType
// NumValues: 0x001B
enum class EFriendEventType : uint8
{
	None                                     = 0,
	LevelUp                                  = 1,
	GearSold                                 = 2,
	GearReceived                             = 3,
	PlotMissionCompletion                    = 4,
	SideMissionCompletion                    = 5,
	PropagateRareSpawnMission                = 6,
	KilledEnemy                              = 7,
	KilledNamedEnemy                         = 8,
	KilledBoss                               = 9,
	GuardianRankMilestone                    = 10,
	ChallengeUpdate                          = 11,
	ChallengeCompletion                      = 12,
	ProvingGroundCompletion                  = 13,
	CircleOfSlaughterCompletion              = 14,
	RaidCompletion                           = 15,
	UnlockedTrueVaultHunterMode              = 16,
	SlotMachineJackpot                       = 17,
	OpenedGoldenChest                        = 18,
	SentMail                                 = 19,
	FriendGearPurchased                      = 20,
	LookingForHelp                           = 21,
	AchievementUnlocked                      = 22,
	ChallengeUpdatesMerged                   = 23,
	LikedEvent                               = 24,
	CustomizationAcquired                    = 25,
	Max                                      = 26,
};

// Enum OakGame.EFriendEventNotificationLifetime
// NumValues: 0x0004
enum class EFriendEventNotificationLifetime : uint8
{
	Normal                                   = 0,
	Long                                     = 1,
	VeryLong                                 = 2,
	EFriendEventNotificationLifetime_MAX     = 3,
};

// Enum OakGame.EFriendEventNotificationFrequency
// NumValues: 0x0007
enum class EFriendEventNotificationFrequency : uint8
{
	Off                                      = 0,
	VeryLow                                  = 1,
	Low                                      = 2,
	Normal                                   = 3,
	High                                     = 4,
	VeryHigh                                 = 5,
	EFriendEventNotificationFrequency_MAX    = 6,
};

// Enum OakGame.EFrontendStandInAnimType
// NumValues: 0x0005
enum class EFrontendStandInAnimType : uint8
{
	Default                                  = 0,
	CharacterSelect                          = 1,
	CharacterCreate                          = 2,
	RnRCharaterCreate                        = 3,
	EFrontendStandInAnimType_MAX             = 4,
};

// Enum OakGame.EOakCharacterMovementConditionType
// NumValues: 0x0003
enum class EOakCharacterMovementConditionType : uint8
{
	IsGroundSlamming                         = 0,
	IsLandingFromGroundSlam                  = 1,
	EOakCharacterMovementConditionType_MAX   = 2,
};

// Enum OakGame.EBoostChargeCountComparisonMode
// NumValues: 0x0008
enum class EBoostChargeCountComparisonMode : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	GreaterThan                              = 2,
	GreaterThanOrEqual                       = 3,
	SmallerThan                              = 4,
	SmallerThanOrEqual                       = 5,
	FullCharges                              = 6,
	EBoostChargeCountComparisonMode_MAX      = 7,
};

// Enum OakGame.EBoostPoolValueComparisonMode
// NumValues: 0x0007
enum class EBoostPoolValueComparisonMode : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	GreaterThan                              = 2,
	GreaterThanOrEqual                       = 3,
	SmallerThan                              = 4,
	SmallerThanOrEqual                       = 5,
	EBoostPoolValueComparisonMode_MAX        = 6,
};

// Enum OakGame.EGbxGFxDialogBoxButtonType
// NumValues: 0x0003
enum class EGbxGFxDialogBoxButtonType : uint8
{
	ListButtons                              = 0,
	HintBox                                  = 1,
	EGbxGFxDialogBoxButtonType_MAX           = 2,
};

// Enum OakGame.EGbxGFxDialogBoxStyle
// NumValues: 0x0005
enum class EGbxGFxDialogBoxStyle : uint8
{
	Default                                  = 0,
	Warning                                  = 1,
	Error                                    = 2,
	Keybinding                               = 3,
	EGbxGFxDialogBoxStyle_MAX                = 4,
};

// Enum OakGame.EShiftReportReason
// NumValues: 0x0009
enum class EShiftReportReason : uint32
{
	Username                                 = 0,
	Sportsmanship                            = 1,
	Abuse                                    = 2,
	HateSpeech                               = 3,
	LeavingOrAfk                             = 4,
	Cheating                                 = 5,
	UserGeneratedContent                     = 6,
	IllicitBehavior                          = 7,
	EShiftReportReason_MAX                   = 8,
};

// Enum OakGame.EGbxInputEvent_OakUIAxis_Events
// NumValues: 0x0004
enum class EGbxInputEvent_OakUIAxis_Events : uint8
{
	Pressed                                  = 0,
	Held                                     = 1,
	Released                                 = 2,
	EGbxInputEvent_OakUIAxis_MAX             = 3,
};

// Enum OakGame.EGeyserBehavior
// NumValues: 0x0004
enum class EGeyserBehavior : uint8
{
	None                                     = 0,
	Intermittent                             = 1,
	AlwaysOn                                 = 2,
	EGeyserBehavior_MAX                      = 3,
};

// Enum OakGame.EGeyserState
// NumValues: 0x0006
enum class EGeyserState : uint8
{
	None                                     = 0,
	SteamOn                                  = 1,
	SteamOff                                 = 2,
	SteamAnticipationOn                      = 3,
	SteamAnticipationOff                     = 4,
	EGeyserState_MAX                         = 5,
};

// Enum OakGame.EAmmoBarMode
// NumValues: 0x0006
enum class EAmmoBarMode : uint8
{
	None                                     = 0,
	NoMode                                   = 1,
	ModeSwitch                               = 2,
	COV                                      = 3,
	EridianFabricator                        = 4,
	EAmmoBarMode_MAX                         = 5,
};

// Enum OakGame.EMovieFFRWState
// NumValues: 0x0004
enum class EMovieFFRWState : uint8
{
	RegularPlayback                          = 0,
	FastForward                              = 1,
	Rewind                                   = 2,
	EMovieFFRWState_MAX                      = 3,
};

// Enum OakGame.EBuddyWidgetFanfareState
// NumValues: 0x0004
enum class EBuddyWidgetFanfareState : uint8
{
	None                                     = 0,
	LevelUp                                  = 1,
	SecondWind                               = 2,
	EBuddyWidgetFanfareState_MAX             = 3,
};

// Enum OakGame.EBuddyWidgetState
// NumValues: 0x0008
enum class EBuddyWidgetState : uint8
{
	Healthy                                  = 0,
	Healthy_JustRespawned                    = 1,
	Dying                                    = 2,
	BeingRevived                             = 3,
	Respawning                               = 4,
	RespawnTimer                             = 5,
	Spectating                               = 6,
	EBuddyWidgetState_MAX                    = 7,
};

// Enum OakGame.EBuddyWidgetContainerAnimState
// NumValues: 0x0005
enum class EBuddyWidgetContainerAnimState : uint8
{
	Inactive                                 = 0,
	SlideIn                                  = 1,
	SlideOut                                 = 2,
	SlideDown                                = 3,
	EBuddyWidgetContainerAnimState_MAX       = 4,
};

// Enum OakGame.EGFxCARMenuPage
// NumValues: 0x0004
enum class EGFxCARMenuPage : uint8
{
	Loadout                                  = 0,
	Customize                                = 1,
	Deploy                                   = 2,
	EGFxCARMenuPage_MAX                      = 3,
};

// Enum OakGame.EGFxCARMenuPartCellType
// NumValues: 0x0004
enum class EGFxCARMenuPartCellType : uint32
{
	None                                     = 0,
	LoadoutButton                            = 1,
	CustomizeCell                            = 2,
	EGFxCARMenuPartCellType_MAX              = 3,
};

// Enum OakGame.EGFxChallegeProgressWidgetState
// NumValues: 0x0004
enum class EGFxChallegeProgressWidgetState : uint32
{
	Off                                      = 0,
	On                                       = 1,
	Out                                      = 2,
	EGFxChallegeProgressWidgetState_MAX      = 3,
};

// Enum OakGame.ECheckpointWidgetState
// NumValues: 0x0006
enum class ECheckpointWidgetState : uint8
{
	None                                     = 0,
	Hidden                                   = 1,
	Intro                                    = 2,
	Idle                                     = 3,
	Exit                                     = 4,
	ECheckpointWidgetState_MAX               = 5,
};

// Enum OakGame.EColorPickerMode
// NumValues: 0x0004
enum class EColorPickerMode : uint8
{
	All                                      = 0,
	PrimarySecondary                         = 1,
	PrimaryOnly                              = 2,
	EColorPickerMode_MAX                     = 3,
};

// Enum OakGame.EColorSelectionType
// NumValues: 0x0004
enum class EColorSelectionType : uint8
{
	TopColor                                 = 0,
	BottomColor                              = 1,
	ResetBothToDefault                       = 2,
	EColorSelectionType_MAX                  = 3,
};

// Enum OakGame.ECrosshairType
// NumValues: 0x0003
enum class ECrosshairType : uint8
{
	NORMAL                                   = 0,
	IRONBEAR                                 = 1,
	ECrosshairType_MAX                       = 2,
};

// Enum OakGame.ECrosshairState
// NumValues: 0x0005
enum class ECrosshairState : uint8
{
	NORMAL                                   = 0,
	ACTION_SKILL                             = 1,
	SPRINTING                                = 2,
	MELEE                                    = 3,
	ECrosshairState_MAX                      = 4,
};

// Enum OakGame.EGFxCurrencyCounterState
// NumValues: 0x0004
enum class EGFxCurrencyCounterState : uint32
{
	Off                                      = 0,
	AnimatingToValue                         = 1,
	HoldingOnValue                           = 2,
	EGFxCurrencyCounterState_MAX             = 3,
};

// Enum OakGame.EGFxDuelingTimerState
// NumValues: 0x0006
enum class EGFxDuelingTimerState : uint8
{
	TimerOnly                                = 0,
	TimerAndMatch                            = 1,
	Challenger                               = 2,
	TimeOut                                  = 3,
	Hidden                                   = 4,
	EGFxDuelingTimerState_MAX                = 5,
};

// Enum OakGame.EECHOLOGWidgetState
// NumValues: 0x0005
enum class EECHOLOGWidgetState : uint8
{
	Inactive                                 = 0,
	Activating                               = 1,
	Displayed                                = 2,
	Deactivating                             = 3,
	EECHOLOGWidgetState_MAX                  = 4,
};

// Enum OakGame.EGFxMailboxMenuMailSort
// NumValues: 0x0005
enum class EGFxMailboxMenuMailSort : uint8
{
	Date                                     = 0,
	Unread                                   = 1,
	Friend                                   = 2,
	System                                   = 3,
	EGFxMailboxMenuMailSort_MAX              = 4,
};

// Enum OakGame.EGFxMailboxMenuState
// NumValues: 0x0006
enum class EGFxMailboxMenuState : uint8
{
	None                                     = 0,
	Receive                                  = 1,
	Send_ChooseItem                          = 2,
	Send_ChooseFriend                        = 3,
	Send_Confirm                             = 4,
	EGFxMailboxMenuState_MAX                 = 5,
};

// Enum OakGame.EGFxRosterCellType
// NumValues: 0x0007
enum class EGFxRosterCellType : uint32
{
	EmptyCell                                = 0,
	FindShiftFriendButton                    = 1,
	ManageShiftFriendsButton                 = 2,
	OnlineFriendInThisGame                   = 3,
	OnlineFriend                             = 4,
	OfflineFriend                            = 5,
	EGFxRosterCellType_MAX                   = 6,
};

// Enum OakGame.EECHOWidgetState
// NumValues: 0x0005
enum class EECHOWidgetState : uint8
{
	Inactive                                 = 0,
	Activating                               = 1,
	Displayed                                = 2,
	Deactivating                             = 3,
	EECHOWidgetState_MAX                     = 4,
};

// Enum OakGame.EGFxExperienceBarState
// NumValues: 0x0005
enum class EGFxExperienceBarState : uint8
{
	None                                     = 0,
	ExperienceAddedAnimation                 = 1,
	LevelUpAnimation                         = 2,
	FadingOut                                = 3,
	EGFxExperienceBarState_MAX               = 4,
};

// Enum OakGame.EGFxFeedWidgetState
// NumValues: 0x0004
enum class EGFxFeedWidgetState : uint32
{
	Off                                      = 0,
	On                                       = 1,
	Out                                      = 2,
	EGFxFeedWidgetState_MAX                  = 3,
};

// Enum OakGame.EFFYLBarState
// NumValues: 0x0004
enum class EFFYLBarState : uint8
{
	Dying                                    = 0,
	BeingRevived                             = 1,
	Reviving                                 = 2,
	EFFYLBarState_MAX                        = 3,
};

// Enum OakGame.EGFxFrontendLandingPageType
// NumValues: 0x0004
enum class EGFxFrontendLandingPageType : uint32
{
	WantsOnline                              = 0,
	WantsLan                                 = 1,
	WantsInGameForMail                       = 2,
	EGFxFrontendLandingPageType_MAX          = 3,
};

// Enum OakGame.EGFxFrontendMenuFocusAnim
// NumValues: 0x0004
enum class EGFxFrontendMenuFocusAnim : uint8
{
	Standard                                 = 0,
	MainMenuFocus                            = 1,
	Focused                                  = 2,
	EGFxFrontendMenuFocusAnim_MAX            = 3,
};

// Enum OakGame.EGFxFrontendMenuMode
// NumValues: 0x0006
enum class EGFxFrontendMenuMode : uint8
{
	Unknown                                  = 0,
	MainMenu                                 = 1,
	EchoNetMenus                             = 2,
	SettingsMenus                            = 3,
	NewGameMenu                              = 4,
	EGFxFrontendMenuMode_MAX                 = 5,
};

// Enum OakGame.EGFxGrenadeIndicatorMode
// NumValues: 0x0004
enum class EGFxGrenadeIndicatorMode : uint32
{
	Hidden                                   = 0,
	Safe                                     = 1,
	Danger                                   = 2,
	EGFxGrenadeIndicatorMode_MAX             = 3,
};

// Enum OakGame.EGFxGuardianRankMenuState
// NumValues: 0x0008
enum class EGFxGuardianRankMenuState : uint8
{
	None                                     = 0,
	MenuLocked                               = 1,
	GuardianRankDisabled                     = 2,
	Information_RedeemButtonSelected         = 3,
	Information_PerkSelected                 = 4,
	TokenRedemption                          = 5,
	TokenRedemption_WaitingForPurchase       = 6,
	EGFxGuardianRankMenuState_MAX            = 7,
};

// Enum OakGame.ECalibrationOptionSourceType
// NumValues: 0x0004
enum class ECalibrationOptionSourceType : uint8
{
	COST_FromPlayerController                = 0,
	COST_FromRecent                          = 1,
	COST_FromDefaults                        = 2,
	COST_MAX                                 = 3,
};

// Enum OakGame.EHUDInitAnimWidgetTarget
// NumValues: 0x0009
enum class EHUDInitAnimWidgetTarget : uint8
{
	None                                     = 0,
	HealthBar                                = 1,
	XPBar                                    = 2,
	Minimap                                  = 3,
	MissionTracker                           = 4,
	AmmoBar                                  = 5,
	ShieldBar                                = 6,
	GrenadeBar                               = 7,
	EHUDInitAnimWidgetTarget_MAX             = 8,
};

// Enum OakGame.EPromptLinesLayouts
// NumValues: 0x0009
enum class EPromptLinesLayouts : uint8
{
	INVALID                                  = 0,
	PrimaryPress                             = 1,
	PrimaryHold                              = 2,
	PrimaryPress_PrimaryHold                 = 3,
	PrimaryPress_SecondaryPress              = 4,
	PrimaryPress_SecondaryHold               = 5,
	PrimaryHold_SecondaryPress               = 6,
	PrimaryHold_SecondaryHold                = 7,
	EPromptLinesLayouts_MAX                  = 8,
};

// Enum OakGame.EInteractionPromptGlyphMode
// NumValues: 0x0005
enum class EInteractionPromptGlyphMode : uint8
{
	InvalidForUseDef                         = 0,
	Normal                                   = 1,
	CantUse                                  = 2,
	Locked                                   = 3,
	EInteractionPromptGlyphMode_MAX          = 4,
};

// Enum OakGame.EGFxInventoryMenuBackpackSize
// NumValues: 0x0003
enum class EGFxInventoryMenuBackpackSize : uint8
{
	TwoColumns                               = 0,
	OneColumn                                = 1,
	EGFxInventoryMenuBackpackSize_MAX        = 2,
};

// Enum OakGame.EGFxInventoryMenuFocusSide
// NumValues: 0x0004
enum class EGFxInventoryMenuFocusSide : uint8
{
	None                                     = 0,
	PaperDoll                                = 1,
	Backpack                                 = 2,
	EGFxInventoryMenuFocusSide_MAX           = 3,
};

// Enum OakGame.EGFxInWorldIconClampUpdate
// NumValues: 0x0005
enum class EGFxInWorldIconClampUpdate : uint8
{
	Unknown                                  = 0,
	NotClamped                               = 1,
	ClampedInFront                           = 2,
	ClampedBehind                            = 3,
	EGFxInWorldIconClampUpdate_MAX           = 4,
};

// Enum OakGame.EInWorldIconRange
// NumValues: 0x0004
enum class EInWorldIconRange : uint8
{
	None                                     = 0,
	Near                                     = 1,
	Far                                      = 2,
	EInWorldIconRange_MAX                    = 3,
};

// Enum OakGame.EGFxItemInspectionPages
// NumValues: 0x0007
enum class EGFxItemInspectionPages : uint8
{
	None                                     = 0,
	Inspect                                  = 1,
	Manufacturer                             = 2,
	Elemental                                = 3,
	Parts                                    = 4,
	Skins                                    = 5,
	EGFxItemInspectionPages_MAX              = 6,
};

// Enum OakGame.EBackButtonHint
// NumValues: 0x0004
enum class EBackButtonHint : uint8
{
	Back                                     = 0,
	Cancel                                   = 1,
	Exit                                     = 2,
	EBackButtonHint_MAX                      = 3,
};

// Enum OakGame.ETradingMenuState
// NumValues: 0x0004
enum class ETradingMenuState : uint8
{
	Offering                                 = 0,
	Backpack                                 = 1,
	Done                                     = 2,
	ETradingMenuState_MAX                    = 3,
};

// Enum OakGame.ELeaguesMenuLayout
// NumValues: 0x0004
enum class ELeaguesMenuLayout : uint8
{
	None                                     = 0,
	Overview                                 = 1,
	Challenges                               = 2,
	ELeaguesMenuLayout_MAX                   = 3,
};

// Enum OakGame.EGFxMainAndPauseMenuType
// NumValues: 0x0004
enum class EGFxMainAndPauseMenuType : uint32
{
	Unknown                                  = 0,
	Main                                     = 1,
	Pause                                    = 2,
	EGFxMainAndPauseMenuType_MAX             = 3,
};

// Enum OakGame.EGFxMapMenuProgressPanelState
// NumValues: 0x0004
enum class EGFxMapMenuProgressPanelState : uint8
{
	None                                     = 0,
	Progress                                 = 1,
	List                                     = 2,
	EGFxMapMenuProgressPanelState_MAX        = 3,
};

// Enum OakGame.EDetailsPanelMode
// NumValues: 0x0009
enum class EDetailsPanelMode : uint8
{
	Unknown                                  = 0,
	NoTarget                                 = 1,
	POIInfo                                  = 2,
	Challenge                                = 3,
	Mission                                  = 4,
	PlanetOverview                           = 5,
	LevelOverview                            = 6,
	POIInfoPlayer                            = 7,
	EDetailsPanelMode_MAX                    = 8,
};

// Enum OakGame.EGFxMapMenuState
// NumValues: 0x000B
enum class EGFxMapMenuState : uint8
{
	None                                     = 0,
	Tutorial_Stage1                          = 1,
	Tutorial_Stage2                          = 2,
	Tutorial_Stage3                          = 3,
	Tutorial_Stage4                          = 4,
	Tutorial_Stage5                          = 5,
	Progress                                 = 6,
	FastTravel                               = 7,
	Challenges                               = 8,
	Friends                                  = 9,
	EGFxMapMenuState_MAX                     = 10,
};

// Enum OakGame.EGFxMapMenuMapState
// NumValues: 0x0005
enum class EGFxMapMenuMapState : uint8
{
	None                                     = 0,
	Level                                    = 1,
	Planet                                   = 2,
	Galaxy                                   = 3,
	EGFxMapMenuMapState_MAX                  = 4,
};

// Enum OakGame.EGFxMenuTutorialFocusDirection
// NumValues: 0x0005
enum class EGFxMenuTutorialFocusDirection : uint32
{
	Center                                   = 0,
	Left                                     = 1,
	Right                                    = 2,
	SameAsStardard                           = 3,
	EGFxMenuTutorialFocusDirection_MAX       = 4,
};

// Enum OakGame.EGFxMenuTutorialDialogSize
// NumValues: 0x0004
enum class EGFxMenuTutorialDialogSize : uint32
{
	Large                                    = 0,
	Medium                                   = 1,
	Small                                    = 2,
	EGFxMenuTutorialDialogSize_MAX           = 3,
};

// Enum OakGame.EGFxMinimapWidgetIconTrackedType
// NumValues: 0x0006
enum class EGFxMinimapWidgetIconTrackedType : uint8
{
	Unused                                   = 0,
	Mission                                  = 1,
	MinimapIconComponent                     = 2,
	CustomWaypoint                           = 3,
	PlayerIcon                               = 4,
	EGFxMinimapWidgetIconTrackedType_MAX     = 5,
};

// Enum OakGame.EGFxMissionLogMissionItemType
// NumValues: 0x0004
enum class EGFxMissionLogMissionItemType : uint8
{
	Mission                                  = 0,
	EchoLog                                  = 1,
	Header                                   = 2,
	EGFxMissionLogMissionItemType_MAX        = 3,
};

// Enum OakGame.EGFxMissionLogFilterType
// NumValues: 0x0005
enum class EGFxMissionLogFilterType : uint8
{
	None                                     = 0,
	MissionLogMissionType                    = 1,
	MissionLogByExpansion                    = 2,
	MissionLogByRegion                       = 3,
	EGFxMissionLogFilterType_MAX             = 4,
};

// Enum OakGame.EGFxMissionLogNavType
// NumValues: 0x0006
enum class EGFxMissionLogNavType : uint8
{
	None                                     = 0,
	Missions                                 = 1,
	EchoLog                                  = 2,
	TyphonLog                                = 3,
	EridianLog                               = 4,
	EGFxMissionLogNavType_MAX                = 5,
};

// Enum OakGame.EGFxMissionLogMissionIconType
// NumValues: 0x000C
enum class EGFxMissionLogMissionIconType : uint8
{
	Normal                                   = 0,
	Plot                                     = 1,
	Side                                     = 2,
	Contract                                 = 3,
	EchoLog                                  = 4,
	EridianWriting                           = 5,
	TyphonLog                                = 6,
	Complete                                 = 7,
	Ignored                                  = 8,
	Failed                                   = 9,
	HardMission                              = 10,
	EGFxMissionLogMissionIconType_MAX        = 11,
};

// Enum OakGame.EGFxMissionTrackerAnimationType
// NumValues: 0x000E
enum class EGFxMissionTrackerAnimationType : uint8
{
	None                                     = 0,
	Active                                   = 1,
	SlideIn                                  = 2,
	SlideInChecked                           = 3,
	SlideOut                                 = 4,
	SlideInFromAbove                         = 5,
	SlideInFromAboveChecked                  = 6,
	SlideInFromBelow                         = 7,
	SlideInFromBelowChecked                  = 8,
	Checked                                  = 9,
	CheckedFailed                            = 10,
	Failed                                   = 11,
	SlideOutFailed                           = 12,
	EGFxMissionTrackerAnimationType_MAX      = 13,
};

// Enum OakGame.ETargetedNameplateState
// NumValues: 0x0005
enum class ETargetedNameplateState : uint8
{
	NotShowingTarget_Linger                  = 0,
	NotShowingTarget                         = 1,
	ShowingValidTarget                       = 2,
	ShowingDyingTarget                       = 3,
	ETargetedNameplateState_MAX              = 4,
};

// Enum OakGame.ENameplateStyle
// NumValues: 0x0004
enum class ENameplateStyle : uint8
{
	Targeted                                 = 0,
	BossBar                                  = 1,
	Overhead                                 = 2,
	ENameplateStyle_MAX                      = 3,
};

// Enum OakGame.EDLCMenuItemUsability
// NumValues: 0x0007
enum class EDLCMenuItemUsability : uint8
{
	None                                     = 0,
	CanUse                                   = 1,
	AlreadyStarted                           = 2,
	RequiresMissionProgress                  = 3,
	NotInstalled                             = 4,
	NotLicensed                              = 5,
	EDLCMenuItemUsability_MAX                = 6,
};

// Enum OakGame.EOverheadNameplateDisplayState
// NumValues: 0x0006
enum class EOverheadNameplateDisplayState : uint8
{
	None                                     = 0,
	CenteredName_Name                        = 1,
	CenteredName_Arrow                       = 2,
	State_Name                               = 3,
	State_Arrow                              = 4,
	EOverheadNameplateDisplayState_MAX       = 5,
};

// Enum OakGame.EOverheadNameplateHealthState
// NumValues: 0x0005
enum class EOverheadNameplateHealthState : uint8
{
	Healthy                                  = 0,
	Dying                                    = 1,
	BeingRevived                             = 2,
	Respawning                               = 3,
	EOverheadNameplateHealthState_MAX        = 4,
};

// Enum OakGame.EPetCommandWidgetState
// NumValues: 0x000A
enum class EPetCommandWidgetState : uint8
{
	Off                                      = 0,
	Ready                                    = 1,
	Unlocked                                 = 2,
	Activated                                = 3,
	BeginCooldown                            = 4,
	CoolingDown                              = 5,
	NowReady                                 = 6,
	CantUse                                  = 7,
	Initalization                            = 8,
	EPetCommandWidgetState_MAX               = 9,
};

// Enum OakGame.EGFxPlayerStorageMenuItemAction
// NumValues: 0x0005
enum class EGFxPlayerStorageMenuItemAction : uint8
{
	None                                     = 0,
	MoveToBank                               = 1,
	MoveToInventory                          = 2,
	Inspect                                  = 3,
	EGFxPlayerStorageMenuItemAction_MAX      = 4,
};

// Enum OakGame.EGFxPlayerStorageMenuState
// NumValues: 0x0006
enum class EGFxPlayerStorageMenuState : uint8
{
	None                                     = 0,
	BankRetrieve                             = 1,
	BackpackDeposit                          = 2,
	CompareBankFocused                       = 3,
	CompareBackpackFocused                   = 4,
	EGFxPlayerStorageMenuState_MAX           = 5,
};

// Enum OakGame.EQuickChangeMenuSortMode
// NumValues: 0x0004
enum class EQuickChangeMenuSortMode : uint8
{
	Rarity                                   = 0,
	Alphabetic                               = 1,
	NewToOld                                 = 2,
	EQuickChangeMenuSortMode_MAX             = 3,
};

// Enum OakGame.EBaseQuickChangeChoiceType
// NumValues: 0x000A
enum class EBaseQuickChangeChoiceType : uint8
{
	Skin                                     = 0,
	Head                                     = 1,
	Body                                     = 2,
	Emote                                    = 3,
	Color                                    = 4,
	ECHOSkin                                 = 5,
	Respec                                   = 6,
	WeaponSkin                               = 7,
	WeaponTrinket                            = 8,
	EBaseQuickChangeChoiceType_MAX           = 9,
};

// Enum OakGame.EBaseQuickChangeMenuState
// NumValues: 0x000D
enum class EBaseQuickChangeMenuState : uint8
{
	CategorySelection                        = 0,
	BodySelection                            = 1,
	HeadSelection                            = 2,
	SkinSelection                            = 3,
	ColorSelection                           = 4,
	EmoteSelection                           = 5,
	ECHOSelection                            = 6,
	Respec                                   = 7,
	TrinketIcon                              = 8,
	WeaponSkinIcon                           = 9,
	DecorationIcon                           = 10,
	None                                     = 11,
	MAX                                      = 12,
};

// Enum OakGame.EReloadWidgetDisplayState
// NumValues: 0x0005
enum class EReloadWidgetDisplayState : uint8
{
	Default                                  = 0,
	AmmoLow                                  = 1,
	NoSpareAmmo                              = 2,
	NoAmmoAtAll                              = 3,
	EReloadWidgetDisplayState_MAX            = 4,
};

// Enum OakGame.GFxSHiFT
// NumValues: 0x0009
enum class EGFxSHiFT : uint8
{
	None                                     = 0,
	NotSignedIn                              = 1,
	SignInAccount                            = 2,
	CreateAccount                            = 3,
	ResetPassword                            = 4,
	CodeRedemption                           = 5,
	RewardHistory                            = 6,
	Offline                                  = 7,
	GFxSHiFT_MAX                             = 8,
};

// Enum OakGame.ESirenSkillScreenSlotType
// NumValues: 0x0006
enum class ESirenSkillScreenSlotType : uint8
{
	None                                     = 0,
	ComboAbility                             = 1,
	ComboEffect                              = 2,
	ComboElement                             = 3,
	Passive                                  = 4,
	ESirenSkillScreenSlotType_MAX            = 5,
};

// Enum OakGame.ESkillItemActionState
// NumValues: 0x000D
enum class ESkillItemActionState : uint8
{
	None                                     = 0,
	CanEquipPrimary                          = 1,
	CanEquipSecondary                        = 2,
	CanEquipBoth                             = 3,
	BlockedByTutorial                        = 4,
	NoPointsToSpend                          = 5,
	Unlock                                   = 6,
	AddPoint                                 = 7,
	Maxed                                    = 8,
	NotEnoughBranchPoints                    = 9,
	RequiresTreeUnlock                       = 10,
	RequiresOtherSkill                       = 11,
	ESkillItemActionState_MAX                = 12,
};

// Enum OakGame.ESkillItemUnlockAnimState
// NumValues: 0x0004
enum class ESkillItemUnlockAnimState : uint8
{
	Uninitialized                            = 0,
	Unplayed                                 = 1,
	Played                                   = 2,
	ESkillItemUnlockAnimState_MAX            = 3,
};

// Enum OakGame.ESkillScreenItemPurchaseState
// NumValues: 0x0005
enum class ESkillScreenItemPurchaseState : uint8
{
	CannotPurchase                           = 0,
	FirstPoint                               = 1,
	AddPoints                                = 2,
	MaxPoints                                = 3,
	ESkillScreenItemPurchaseState_MAX        = 4,
};

// Enum OakGame.ESkillScreenReceiveHighlightState
// NumValues: 0x0004
enum class ESkillScreenReceiveHighlightState : uint8
{
	Off                                      = 0,
	Available                                = 1,
	Active                                   = 2,
	ESkillScreenReceiveHighlightState_MAX    = 3,
};

// Enum OakGame.ESkillScreenLoadoutSlotClearability
// NumValues: 0x0006
enum class ESkillScreenLoadoutSlotClearability : uint8
{
	CannotClear_Error                        = 0,
	CannotClear_SlotEmpty                    = 1,
	CannotClear_SlotMustBeFilled             = 2,
	CannotClear_AbilityInUse                 = 3,
	CanClear                                 = 4,
	ESkillScreenLoadoutSlotClearability_MAX  = 5,
};

// Enum OakGame.EGFxSkillScreenLoadoutChoiceEquipState
// NumValues: 0x0004
enum class EGFxSkillScreenLoadoutChoiceEquipState : uint8
{
	Locked                                   = 0,
	Available                                = 1,
	Equipped                                 = 2,
	EGFxSkillScreenLoadoutChoiceEquipState_MAX = 3,
};

// Enum OakGame.EGFxSkillScreenState
// NumValues: 0x0008
enum class EGFxSkillScreenState : uint8
{
	None                                     = 0,
	BranchesFocused                          = 1,
	LoadoutEdit                              = 2,
	PlayingUnlockAnim                        = 3,
	TreeLocked_Info                          = 4,
	TreeLocked_Branches                      = 5,
	DraggingSkillItem                        = 6,
	EGFxSkillScreenState_MAX                 = 7,
};

// Enum OakGame.ESkillScreenSlotType
// NumValues: 0x0004
enum class ESkillScreenSlotType : uint8
{
	None                                     = 0,
	Compatible                               = 1,
	All                                      = 2,
	ESkillScreenSlotType_MAX                 = 3,
};

// Enum OakGame.EGFxStatusMenuTransitionReason
// NumValues: 0x0007
enum class EGFxStatusMenuTransitionReason : uint8
{
	None                                     = 0,
	Pushed                                   = 1,
	NextPage                                 = 2,
	PrevPage                                 = 3,
	Switched                                 = 4,
	Popped                                   = 5,
	EGFxStatusMenuTransitionReason_MAX       = 6,
};

// Enum OakGame.EGFxStoreMenuTabType
// NumValues: 0x0006
enum class EGFxStoreMenuTabType : uint32
{
	Empty                                    = 0,
	Featured                                 = 1,
	Expansions                               = 2,
	Customizations                           = 3,
	Purchased                                = 4,
	EGFxStoreMenuTabType_MAX                 = 5,
};

// Enum OakGame.ESubtitleLayoutType
// NumValues: 0x0005
enum class ESubtitleLayoutType : uint8
{
	None                                     = 0,
	SubtitlesOnly                            = 1,
	ClosedCaptionsOnly                       = 2,
	Both                                     = 3,
	ESubtitleLayoutType_MAX                  = 4,
};

// Enum OakGame.EGbxGFxSpinnerWidgetGoToMethod
// NumValues: 0x0003
enum class EGbxGFxSpinnerWidgetGoToMethod : uint8
{
	FromCurrent                              = 0,
	Immediately                              = 1,
	EGbxGFxSpinnerWidgetGoToMethod_MAX       = 2,
};

// Enum OakGame.EGFxVaultHunterProfileCardView
// NumValues: 0x0004
enum class EGFxVaultHunterProfileCardView : uint8
{
	Skill                                    = 0,
	Inventory                                = 1,
	Stat                                     = 2,
	EGFxVaultHunterProfileCardView_MAX       = 3,
};

// Enum OakGame.EGFxVaultHunterProfileCardMode
// NumValues: 0x0004
enum class EGFxVaultHunterProfileCardMode : uint8
{
	Unknown                                  = 0,
	Friend                                   = 1,
	Self                                     = 2,
	EGFxVaultHunterProfileCardMode_MAX       = 3,
};

// Enum OakGame.EGFxVehiclePartWidgetState
// NumValues: 0x0007
enum class EGFxVehiclePartWidgetState : uint8
{
	On                                       = 0,
	Off                                      = 1,
	RollOn                                   = 2,
	RollOff                                  = 3,
	Condensed                                = 4,
	TurnIn                                   = 5,
	EGFxVehiclePartWidgetState_MAX           = 6,
};

// Enum OakGame.UGFxVehiclePartUnlockedWidgetState
// NumValues: 0x0003
enum class EUGFxVehiclePartUnlockedWidgetState : uint32
{
	Off                                      = 0,
	Playing                                  = 1,
	UGFxVehiclePartUnlockedWidgetState_MAX   = 2,
};

// Enum OakGame.EGFxVehicleWeaponType
// NumValues: 0x0005
enum class EGFxVehicleWeaponType : uint8
{
	CHARGE                                   = 0,
	MAGAZINE                                 = 1,
	HEAT                                     = 2,
	RECOVERY                                 = 3,
	EGFxVehicleWeaponType_MAX                = 4,
};

// Enum OakGame.EGFxVendingMachineMenuBackpackState
// NumValues: 0x0006
enum class EGFxVendingMachineMenuBackpackState : uint32
{
	Unknown                                  = 0,
	Buy                                      = 1,
	Sell                                     = 2,
	Compare                                  = 3,
	CompareToMachine                         = 4,
	EGFxVendingMachineMenuBackpackState_MAX  = 5,
};

// Enum OakGame.EVendingMachineSocketMapStates
// NumValues: 0x0005
enum class EVendingMachineSocketMapStates : uint8
{
	SOCKETMAP_BUY                            = 0,
	SOCKETMAP_SELL                           = 1,
	SOCKETMAP_COMPARE                        = 2,
	SOCKETMAP_VENDINGCOMPARE                 = 3,
	SOCKETMAP_MAX                            = 4,
};

// Enum OakGame.GFxVendingMachineDisplayMode
// NumValues: 0x0005
enum class EGFxVendingMachineDisplayMode : uint8
{
	GFXVENDOR_Buy                            = 0,
	GFXVENDOR_Sell                           = 1,
	GFXVENDOR_Buyback                        = 2,
	GFXVENDOR_END                            = 3,
	GFXVENDOR_MAX                            = 4,
};

// Enum OakGame.EGoreRegionType
// NumValues: 0x0005
enum class EGoreRegionType : uint8
{
	Head                                     = 0,
	Arm                                      = 1,
	Leg                                      = 2,
	Torso                                    = 3,
	EGoreRegionType_MAX                      = 4,
};

// Enum OakGame.EChildPayloadType
// NumValues: 0x0007
enum class EChildPayloadType : uint8
{
	Payload_Divider                          = 0,
	Payload_MiniMirv                         = 1,
	Payload_Mirv                             = 2,
	Payload_Rain                             = 3,
	Payload_Spring                           = 4,
	Payload_Sticky                           = 5,
	Payload_MAX                              = 6,
};

// Enum OakGame.ELingeringDamageStyle
// NumValues: 0x0004
enum class ELingeringDamageStyle : uint8
{
	DamageStyle_Burst                        = 0,
	DamageStyle_Beam                         = 1,
	DamageStyle_Radius                       = 2,
	DamageStyle_MAX                          = 3,
};

// Enum OakGame.EInstanceDataOperator
// NumValues: 0x0003
enum class EInstanceDataOperator : uint8
{
	Add                                      = 0,
	Multiply                                 = 1,
	EInstanceDataOperator_MAX                = 2,
};

// Enum OakGame.ESpinDirection
// NumValues: 0x0004
enum class ESpinDirection : uint8
{
	SD_NoSpin                                = 0,
	SD_Clockwise                             = 1,
	SD_Counterclockwise                      = 2,
	SD_MAX                                   = 3,
};

// Enum OakGame.EHolsteredGearState
// NumValues: 0x0004
enum class EHolsteredGearState : uint8
{
	None                                     = 0,
	FadingIn                                 = 1,
	FadingOut                                = 2,
	EHolsteredGearState_MAX                  = 3,
};

// Enum OakGame.EInWorldIconFadeType
// NumValues: 0x0004
enum class EInWorldIconFadeType : uint8
{
	None                                     = 0,
	Distance                                 = 1,
	TargetedRadius                           = 2,
	EInWorldIconFadeType_MAX                 = 3,
};

// Enum OakGame.EInWorldIconClassType
// NumValues: 0x0003
enum class EInWorldIconClassType : uint8
{
	Icon                                     = 0,
	Nameplate                                = 1,
	EInWorldIconClassType_MAX                = 2,
};

// Enum OakGame.EInWorldIconEdgeBehavior
// NumValues: 0x0003
enum class EInWorldIconEdgeBehavior : uint8
{
	Clamp                                    = 0,
	Hide                                     = 1,
	EInWorldIconEdgeBehavior_MAX             = 2,
};

// Enum OakGame.ELootSpawnTiming
// NumValues: 0x0004
enum class ELootSpawnTiming : uint8
{
	OnEnabled                                = 0,
	OnEnabling                               = 1,
	OnAnimNotify                             = 2,
	ELootSpawnTiming_MAX                     = 3,
};

// Enum OakGame.EMissionDrivenLootableType
// NumValues: 0x0004
enum class EMissionDrivenLootableType : uint8
{
	None                                     = 0,
	CopyPickupMissionObjective               = 1,
	UseSelfMissionObjective                  = 2,
	EMissionDrivenLootableType_MAX           = 3,
};

// Enum OakGame.ELootableOpenReason
// NumValues: 0x0003
enum class ELootableOpenReason : uint8
{
	Use                                      = 0,
	Damage                                   = 1,
	ELootableOpenReason_MAX                  = 2,
};

// Enum OakGame.EDebugMatchmakingFailure
// NumValues: 0x0009
enum class EDebugMatchmakingFailure : uint32
{
	None                                     = 0,
	CreateMatchmakingSession                 = 1,
	JoinMatchmakingSession                   = 2,
	FindMatchmakingSession                   = 3,
	FindGameplaySession                      = 4,
	JoinGameplaySession                      = 5,
	InitClientMatchmakingBeacon              = 6,
	CreateHostMatchmakingBeacon              = 7,
	EDebugMatchmakingFailure_MAX             = 8,
};

// Enum OakGame.EMatchmakingError
// NumValues: 0x0010
enum class EMatchmakingError : uint8
{
	None                                     = 0,
	StartHostingFailed                       = 1,
	StartMatchmakingRoundFailed              = 2,
	StartMatchmakingSearchFailed             = 3,
	CreateClientMatchmakingBeaconFailed      = 4,
	SearchFailed                             = 5,
	JoinGameFailed                           = 6,
	RateLimit                                = 7,
	NetworkFailure                           = 8,
	ClientCriticalFailure                    = 9,
	UpdateSessionFailed                      = 10,
	StartGameplayFailed                      = 11,
	SplitscreenJoinFailure                   = 12,
	SplitscreenLeaveFailure                  = 13,
	NoPlaylistContentAvailable               = 14,
	EMatchmakingError_MAX                    = 15,
};

// Enum OakGame.EMatchmakingRequirementComparisonOp
// NumValues: 0x0006
enum class EMatchmakingRequirementComparisonOp : uint8
{
	None                                     = 0,
	Equal                                    = 1,
	NotEqual                                 = 2,
	LessThan                                 = 3,
	GreaterThan                              = 4,
	EMatchmakingRequirementComparisonOp_MAX  = 5,
};

// Enum OakGame.EMatchmakingRequirementType
// NumValues: 0x0005
enum class EMatchmakingRequirementType : uint8
{
	None                                     = 0,
	PlayerLevel                              = 1,
	PlotMission                              = 2,
	DlcInstalled                             = 3,
	EMatchmakingRequirementType_MAX          = 4,
};

// Enum OakGame.EMatchmakingSearchParameterOp
// NumValues: 0x0008
enum class EMatchmakingSearchParameterOp : uint8
{
	Invalid                                  = 0,
	Equals                                   = 1,
	NotEquals                                = 2,
	GreaterThan                              = 3,
	GreaterThanEquals                        = 4,
	LessThan                                 = 5,
	LessThanEquals                           = 6,
	Max                                      = 7,
};

// Enum OakGame.EInitialPlayerStatus
// NumValues: 0x0003
enum class EInitialPlayerStatus : uint8
{
	NotSelected                              = 0,
	Selected                                 = 1,
	EInitialPlayerStatus_MAX                 = 2,
};

// Enum OakGame.EOakAbilityTimerResult
// NumValues: 0x0005
enum class EOakAbilityTimerResult : uint8
{
	Pulsed                                   = 0,
	Finished                                 = 1,
	Stopped                                  = 2,
	Replaced                                 = 3,
	EOakAbilityTimerResult_MAX               = 4,
};

// Enum OakGame.EOakAbilityTimerTickPolicy
// NumValues: 0x0003
enum class EOakAbilityTimerTickPolicy : uint8
{
	AlwaysTick                               = 0,
	OnlyWhenActive                           = 1,
	EOakAbilityTimerTickPolicy_MAX           = 2,
};

// Enum OakGame.EOakAbilityTimerReplacePolicy
// NumValues: 0x0003
enum class EOakAbilityTimerReplacePolicy : uint8
{
	KeepExisting                             = 0,
	ReplaceExisting                          = 1,
	EOakAbilityTimerReplacePolicy_MAX        = 2,
};

// Enum OakGame.ESkillWidgetSlot
// NumValues: 0x0004
enum class ESkillWidgetSlot : uint8
{
	None                                     = 0,
	ActionSkillWidget                        = 1,
	GrenadeActionSkillWidget                 = 2,
	ESkillWidgetSlot_MAX                     = 3,
};

// Enum OakGame.EOakAchievements
// NumValues: 0x0053
enum class EOakAchievements : uint8
{
	Invalid                                  = 0,
	ReachLevel2                              = 1,
	ReachLevel10                             = 2,
	ReachLevel25                             = 3,
	ReachLevel50                             = 4,
	UnlockHeadsSkins                         = 5,
	UnlockVehicleParts                       = 6,
	UsePhotoMode                             = 7,
	WinDuel                                  = 8,
	ReviveAnotherPlayer                      = 9,
	SendItemToFriend                         = 10,
	WinLiveGrenadeSlotMachine                = 11,
	PerfectScoreFiringRange                  = 12,
	CrazyEarl                                = 13,
	EridianSlabs                             = 14,
	CompleteAllCircleOfSlaughter             = 15,
	DiscoverAllPandoraLocations              = 16,
	DiscoverAllEden6Locations                = 17,
	DiscoverAllPrometheaLocations            = 18,
	DiscoverAllNekrotaphayoLocations         = 19,
	DiscoverAllNamedLocations                = 20,
	CompleteSomeSideMissions                 = 21,
	CompleteAllSideMissions                  = 22,
	ClearAllProvingGrounds                   = 23,
	DefeatAllLegendaryHunts                  = 24,
	DefeatAllTargetsOfOpportunity            = 25,
	KillEnemyWithExplodingBarrel             = 26,
	KillEnemyWithGunBlade                    = 27,
	KillMultipleEnemiesWithStickyGrenade     = 28,
	EquipPurpleGear                          = 29,
	LoyaltyPackage                           = 30,
	CompleteMission1                         = 31,
	CompleteMission2                         = 32,
	CompleteMission3                         = 33,
	CompleteMission4                         = 34,
	CompleteMission5                         = 35,
	CompleteMission6                         = 36,
	CompleteMission7                         = 37,
	CompleteMission8                         = 38,
	CompleteMission9                         = 39,
	CompleteMission10                        = 40,
	CompleteMission11                        = 41,
	Suicide                                  = 42,
	GoldenKey                                = 43,
	VaultRewards                             = 44,
	CompleteAllAchievements                  = 45,
	DLC1_CompleteMissionVIP                  = 46,
	DLC1_EmberChallenges                     = 47,
	DLC1_MayorChallenges                     = 48,
	DLC1_TorgueChallenges                    = 49,
	DLC1_Blackjack                           = 50,
	DLC1_Clapstructor                        = 51,
	DLC1_DebtCollector                       = 52,
	DLC2_CompleteMission1                    = 53,
	DLC2_CompleteFinalMission                = 54,
	DLC2_KillWendigo                         = 55,
	DLC2_DeathrapKill                        = 56,
	DLC2_CrewChallenges                      = 57,
	DLC2_CollectECHO                         = 58,
	DLC2_RareSpawns                          = 59,
	DLC2_FishJokes                           = 60,
	DLC3_CompleteAllAchievements             = 61,
	DLC3_CrewChallenges                      = 62,
	DLC3_CompleteSideMissions                = 63,
	DLC3_CompleteMission1                    = 64,
	DLC3_CompleteMission2                    = 65,
	DLC3_CompleteMission3                    = 66,
	DLC3_CompleteMission4                    = 67,
	DLC3_CompleteFinalMission                = 68,
	DLC4_CompleteMission1                    = 69,
	DLC4_DefeatDarkLilith                    = 70,
	DLC4_DestroyTheTrain                     = 71,
	DLC4_KillBenedict                        = 72,
	DLC4_DefeatPsychodin                     = 73,
	DLC4_OpenAllGates                        = 74,
	DLC4_SidesAndChallenges                  = 75,
	DLC5_WinShootingSpreeRound               = 76,
	DLC5_Extract100PiecesOfGear              = 77,
	DLC5_ExploreEntireWhiteout               = 78,
	DLC6_SolveAllMysteries                   = 79,
	DLC6_DefeatHemovorous                    = 80,
	DLC6_DestroyMysteriousEridium            = 81,
	EOakAchievements_MAX                     = 82,
};

// Enum OakGame.EOakAnimActionAbilityEndAction
// NumValues: 0x0005
enum class EOakAnimActionAbilityEndAction : uint8
{
	None                                     = 0,
	Stop                                     = 1,
	Abort                                    = 2,
	AbortReset                               = 3,
	EOakAnimActionAbilityEndAction_MAX       = 4,
};

// Enum OakGame.EHostileAttachState
// NumValues: 0x0007
enum class EHostileAttachState : uint8
{
	Loop                                     = 0,
	Attack                                   = 1,
	GripFeedback                             = 2,
	GetDown                                  = 3,
	Ejected                                  = 4,
	Completed                                = 5,
	EHostileAttachState_MAX                  = 6,
};

// Enum OakGame.ELeapOnVehicle_SeatType
// NumValues: 0x0006
enum class ELeapOnVehicle_SeatType : uint8
{
	SpecifiedSlot                            = 0,
	Driver                                   = 1,
	Gunner                                   = 2,
	Passenger                                = 3,
	Hostile                                  = 4,
	ELeapOnVehicle_MAX                       = 5,
};

// Enum OakGame.EOakActionAbilitySecondaryUseActionType
// NumValues: 0x0004
enum class EOakActionAbilitySecondaryUseActionType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	EOakActionAbilitySecondaryUseActionType_MAX = 3,
};

// Enum OakGame.EOakActionAbilityStopAction
// NumValues: 0x0004
enum class EOakActionAbilityStopAction : uint8
{
	Normal                                   = 0,
	Expidited                                = 1,
	Abort                                    = 2,
	EOakActionAbilityStopAction_MAX          = 3,
};

// Enum OakGame.ECloneSwapReason
// NumValues: 0x0003
enum class ECloneSwapReason : uint8
{
	Manual                                   = 0,
	NewU                                     = 1,
	ECloneSwapReason_MAX                     = 2,
};

// Enum OakGame.EOakActionAbilityPetModType
// NumValues: 0x0007
enum class EOakActionAbilityPetModType : uint8
{
	None                                     = 0,
	Mod1                                     = 1,
	Mod2                                     = 2,
	Mod3                                     = 3,
	Mod4                                     = 4,
	Mod5                                     = 5,
	EOakActionAbilityPetModType_MAX          = 6,
};

// Enum OakGame.EOakActionAbilityPetEvolutionType
// NumValues: 0x0004
enum class EOakActionAbilityPetEvolutionType : uint8
{
	None                                     = 0,
	Evolution1                               = 1,
	Evolution2                               = 2,
	EOakActionAbilityPetEvolutionType_MAX    = 3,
};

// Enum OakGame.EOakActionAbilityPetType
// NumValues: 0x0006
enum class EOakActionAbilityPetType : uint8
{
	None                                     = 0,
	Spiderant                                = 1,
	Jabbermon                                = 2,
	Skag                                     = 3,
	Loader                                   = 4,
	EOakActionAbilityPetType_MAX             = 5,
};

// Enum OakGame.EPhaseTranceEffectTargetType
// NumValues: 0x0003
enum class EPhaseTranceEffectTargetType : uint8
{
	Actor                                    = 0,
	Location                                 = 1,
	EPhaseTranceEffectTargetType_MAX         = 2,
};

// Enum OakGame.EPhaseTranceElementalType
// NumValues: 0x0006
enum class EPhaseTranceElementalType : uint8
{
	None                                     = 0,
	Element1                                 = 1,
	Element2                                 = 2,
	Element3                                 = 3,
	Element4                                 = 4,
	EPhaseTranceElementalType_MAX            = 5,
};

// Enum OakGame.EPhaseTranceEffectType
// NumValues: 0x0008
enum class EPhaseTranceEffectType : uint8
{
	None                                     = 0,
	Effect1                                  = 1,
	Effect2                                  = 2,
	Effect3                                  = 3,
	Effect4                                  = 4,
	Effect5                                  = 5,
	Effect6                                  = 6,
	EPhaseTranceEffectType_MAX               = 7,
};

// Enum OakGame.EPhaseTranceAttackFamilyType
// NumValues: 0x0006
enum class EPhaseTranceAttackFamilyType : uint8
{
	None                                     = 0,
	AttackFamily1                            = 1,
	AttackFamily2                            = 2,
	AttackFamily3                            = 3,
	AttackFamily4                            = 4,
	EPhaseTranceAttackFamilyType_MAX         = 5,
};

// Enum OakGame.EOperativeBarrierModType
// NumValues: 0x0007
enum class EOperativeBarrierModType : uint8
{
	Mod1                                     = 0,
	Mod2                                     = 1,
	Mod3                                     = 2,
	Mod4                                     = 3,
	Mod5                                     = 4,
	Mod6                                     = 5,
	EOperativeBarrierModType_MAX             = 6,
};

// Enum OakGame.EDigiCloneModType
// NumValues: 0x000A
enum class EDigiCloneModType : uint8
{
	Mod1                                     = 0,
	Mod2                                     = 1,
	Mod3                                     = 2,
	Mod4                                     = 3,
	Mod5                                     = 4,
	Mod6                                     = 5,
	Mod7                                     = 6,
	Mod8                                     = 7,
	Mod9                                     = 8,
	EDigiCloneModType_MAX                    = 9,
};

// Enum OakGame.EGRMLNModType
// NumValues: 0x0007
enum class EGRMLNModType : uint8
{
	Mod1                                     = 0,
	Mod2                                     = 1,
	Mod3                                     = 2,
	Mod4                                     = 3,
	Mod5                                     = 4,
	Mod6                                     = 5,
	EGRMLNModType_MAX                        = 6,
};

// Enum OakGame.EIronBearUIHardpointType
// NumValues: 0x0008
enum class EIronBearUIHardpointType : uint8
{
	GRENADE_LAUNCHER                         = 0,
	MINIGUN                                  = 1,
	BEARFIST                                 = 2,
	FALCON_STRIKE                            = 3,
	SALAMANDER_THROWER                       = 4,
	BUBBLE_SHIELD                            = 5,
	RAILGUN                                  = 6,
	EIronBearUIHardpointType_MAX             = 7,
};

// Enum OakGame.EIronBearModType
// NumValues: 0x0005
enum class EIronBearModType : uint8
{
	None                                     = 0,
	Mod1                                     = 1,
	Mod2                                     = 2,
	Mod3                                     = 3,
	EIronBearModType_MAX                     = 4,
};

// Enum OakGame.EOakAISwarmRotation
// NumValues: 0x0004
enum class EOakAISwarmRotation : uint8
{
	None                                     = 0,
	Strafe                                   = 1,
	Forward                                  = 2,
	EOakAISwarmRotation_MAX                  = 3,
};

// Enum OakGame.ECARRestrictionType
// NumValues: 0x0003
enum class ECARRestrictionType : uint8
{
	Default                                  = 0,
	DLC3                                     = 1,
	ECARRestrictionType_MAX                  = 2,
};

// Enum OakGame.ECARPartType
// NumValues: 0x000A
enum class ECARPartType : uint8
{
	Wheel                                    = 1,
	Armor                                    = 2,
	CoreMod                                  = 3,
	GunnerWeapon                             = 4,
	DriverWeapon                             = 5,
	Ornament                                 = 6,
	MaterialDecal                            = 7,
	Material                                 = 8,
	None                                     = 9,
	ECARPartType_MAX                         = 10,
};

// Enum OakGame.EChallengRewardFormattingType
// NumValues: 0x0004
enum class EChallengRewardFormattingType : uint8
{
	Cash                                     = 0,
	Eridium                                  = 1,
	Other                                    = 2,
	EChallengRewardFormattingType_MAX        = 3,
};

// Enum OakGame.ECameraAttachState
// NumValues: 0x0003
enum class ECameraAttachState : uint8
{
	CAS_Dettached                            = 0,
	CAS_Attached                             = 1,
	CAS_MAX                                  = 2,
};

// Enum OakGame.EVehicleArchetype
// NumValues: 0x0006
enum class EVehicleArchetype : uint8
{
	Null                                     = 0,
	Technical                                = 1,
	Outrunner                                = 2,
	Revolver                                 = 3,
	Emperor                                  = 4,
	EVehicleArchetype_MAX                    = 5,
};

// Enum OakGame.ECinematicState
// NumValues: 0x0004
enum class ECinematicState : uint8
{
	Inactive                                 = 0,
	PlayingIntro                             = 1,
	PlayingSequence                          = 2,
	ECinematicState_MAX                      = 3,
};

// Enum OakGame.EOakMayhemModeConditionType
// NumValues: 0x0003
enum class EOakMayhemModeConditionType : uint8
{
	IsMayhemModeActive                       = 0,
	CompareMayhemLevel                       = 1,
	EOakMayhemModeConditionType_MAX          = 2,
};

// Enum OakGame.EHealthTypeState
// NumValues: 0x0005
enum class EHealthTypeState : uint8
{
	Normal                                   = 0,
	Low                                      = 1,
	VeryLow                                  = 2,
	Depleted                                 = 3,
	EHealthTypeState_MAX                     = 4,
};

// Enum OakGame.EDamageInstigatorClassification
// NumValues: 0x0005
enum class EDamageInstigatorClassification : uint8
{
	Other                                    = 0,
	PlayerVersusPlayer                       = 1,
	PlayerVersusAI                           = 2,
	AIVersusPlayer                           = 3,
	EDamageInstigatorClassification_MAX      = 4,
};

// Enum OakGame.EOakElementalDeathEffects
// NumValues: 0x0004
enum class EOakElementalDeathEffects : uint8
{
	Default                                  = 0,
	Custom                                   = 1,
	Disabled                                 = 2,
	EOakElementalDeathEffects_MAX            = 3,
};

// Enum OakGame.EUIDialogCallout
// NumValues: 0x0006
enum class EUIDialogCallout : uint8
{
	OutOfGrenades                            = 0,
	EquipAskillFailed                        = 1,
	EquipItemFailed                          = 2,
	RemoveItemFailed                         = 3,
	InsufficientFunds                        = 4,
	EUIDialogCallout_MAX                     = 5,
};

// Enum OakGame.EGRMLNHardpointType
// NumValues: 0x0004
enum class EGRMLNHardpointType : uint8
{
	None                                     = 0,
	MachineGun                               = 1,
	Mod4                                     = 2,
	EGRMLNHardpointType_MAX                  = 3,
};

// Enum OakGame.EOakDroneFacingMode
// NumValues: 0x0005
enum class EOakDroneFacingMode : uint8
{
	None                                     = 0,
	FaceMoveDir                              = 1,
	FaceTarget                               = 2,
	FaceMovementTarget                       = 3,
	EOakDroneFacingMode_MAX                  = 4,
};

// Enum OakGame.EOakDroneMovementMode
// NumValues: 0x0005
enum class EOakDroneMovementMode : uint8
{
	Projectile                               = 0,
	FlyToTarget                              = 1,
	HoverAtTarget                            = 2,
	HoverAtOwner                             = 3,
	EOakDroneMovementMode_MAX                = 4,
};

// Enum OakGame.EOakElementalStackBucketType
// NumValues: 0x0007
enum class EOakElementalStackBucketType : uint8
{
	Unknown                                  = 0,
	Character                                = 1,
	Weapon                                   = 2,
	Grenade                                  = 3,
	InteractiveObject                        = 4,
	ElementalInteraction                     = 5,
	EOakElementalStackBucketType_MAX         = 6,
};

// Enum OakGame.EInviteType
// NumValues: 0x0004
enum class EInviteType : uint8
{
	Public                                   = 0,
	InviteOnly                               = 1,
	FriendsOnly                              = 2,
	EInviteType_MAX                          = 3,
};

// Enum OakGame.EFriendSyncState
// NumValues: 0x0003
enum class EFriendSyncState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	EFriendSyncState_MAX                     = 2,
};

// Enum OakGame.ECrossplayState
// NumValues: 0x0003
enum class ECrossplayState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	ECrossplayState_MAX                      = 2,
};

// Enum OakGame.ENetworkType
// NumValues: 0x0004
enum class ENetworkType : uint8
{
	Offline                                  = 0,
	Lan                                      = 1,
	Online                                   = 2,
	ENetworkType_MAX                         = 3,
};

// Enum OakGame.EPlayerInputLockType
// NumValues: 0x0007
enum class EPlayerInputLockType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Movement                                 = 2,
	Looking                                  = 3,
	Jumping                                  = 4,
	Weapon                                   = 5,
	EPlayerInputLockType_MAX                 = 6,
};

// Enum OakGame.EActivityCompletionFriendEventType
// NumValues: 0x0004
enum class EActivityCompletionFriendEventType : uint8
{
	RaidCompletion                           = 0,
	CircleOfSlaughterCompletion              = 1,
	ProvingGroundsCompletion                 = 2,
	EActivityCompletionFriendEventType_MAX   = 3,
};

// Enum OakGame.EBenchmarkDataOutputMode
// NumValues: 0x0004
enum class EBenchmarkDataOutputMode : uint8
{
	None                                     = 0,
	Summary                                  = 1,
	DetailedCSV                              = 2,
	EBenchmarkDataOutputMode_MAX             = 3,
};

// Enum OakGame.EAmbientOcclusionQuality
// NumValues: 0x0006
enum class EAmbientOcclusionQuality : uint8
{
	Off                                      = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Ultra                                    = 4,
	EAmbientOcclusionQuality_MAX             = 5,
};

// Enum OakGame.ECharacterDetail
// NumValues: 0x0005
enum class ECharacterDetail : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	ECharacterDetail_MAX                     = 4,
};

// Enum OakGame.ECharacterTextureDetail
// NumValues: 0x0006
enum class ECharacterTextureDetail : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	Deprecated                               = 4,
	ECharacterTextureDetail_MAX              = 5,
};

// Enum OakGame.EScreenSpaceReflections
// NumValues: 0x0005
enum class EScreenSpaceReflections : uint8
{
	Off                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EScreenSpaceReflections_MAX              = 4,
};

// Enum OakGame.EVolumetricFogType
// NumValues: 0x0005
enum class EVolumetricFogType : uint8
{
	Off                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EVolumetricFogType_MAX                   = 4,
};

// Enum OakGame.EFoliageDensity
// NumValues: 0x0005
enum class EFoliageDensity : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EFoliageDensity_MAX                      = 4,
};

// Enum OakGame.ETerrainType
// NumValues: 0x0005
enum class ETerrainType : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	ETerrainType_MAX                         = 4,
};

// Enum OakGame.EEnvironmentDetail
// NumValues: 0x0005
enum class EEnvironmentDetail : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EEnvironmentDetail_MAX                   = 4,
};

// Enum OakGame.EDrawDistance
// NumValues: 0x0005
enum class EDrawDistance : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EDrawDistance_MAX                        = 4,
};

// Enum OakGame.EEnvironmentTextureDetail
// NumValues: 0x0006
enum class EEnvironmentTextureDetail : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	Deprecated                               = 4,
	EEnvironmentTextureDetail_MAX            = 5,
};

// Enum OakGame.EShadowQuality
// NumValues: 0x0005
enum class EShadowQuality : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EShadowQuality_MAX                       = 4,
};

// Enum OakGame.EAnisotropicFilteringType
// NumValues: 0x0006
enum class EAnisotropicFilteringType : uint8
{
	Trilinear                                = 0,
	TwoX                                     = 1,
	FourX                                    = 2,
	EightX                                   = 3,
	SixteenX                                 = 4,
	EAnisotropicFilteringType_MAX            = 5,
};

// Enum OakGame.EMaterialQuality
// NumValues: 0x0005
enum class EMaterialQuality : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	EMaterialQuality_MAX                     = 4,
};

// Enum OakGame.ETextureStreamingQuality
// NumValues: 0x0005
enum class ETextureStreamingQuality : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Ultra                                    = 3,
	ETextureStreamingQuality_MAX             = 4,
};

// Enum OakGame.EGraphicsQuality
// NumValues: 0x0008
enum class EGraphicsQuality : uint8
{
	VeryLow                                  = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Ultra                                    = 4,
	Badass                                   = 5,
	Undefined                                = 6,
	EGraphicsQuality_MAX                     = 7,
};

// Enum OakGame.EFrameRateLimit
// NumValues: 0x0007
enum class EFrameRateLimit : uint8
{
	Smooth22_62FPS                           = 0,
	Capped30FPS                              = 1,
	Capped60FPS                              = 2,
	Capped120FPS                             = 3,
	Unlimited                                = 4,
	Custom                                   = 5,
	EFrameRateLimit_MAX                      = 6,
};

// Enum OakGame.EResolutionScale
// NumValues: 0x0008
enum class EResolutionScale : uint8
{
	Scale_50                                 = 0,
	Scale_75                                 = 1,
	Scale_100                                = 2,
	Scale_125                                = 3,
	Scale_150                                = 4,
	Scale_175                                = 5,
	Scale_200                                = 6,
	Scale_MAX                                = 7,
};

// Enum OakGame.ESupportedAspectRatios
// NumValues: 0x0006
enum class ESupportedAspectRatios : uint8
{
	AspectRatio_16_9                         = 0,
	AspectRatio_16_10                        = 1,
	AspectRatio_32_9                         = 2,
	AspectRatio_21_9                         = 3,
	AspectRatio_Unsupported                  = 4,
	AspectRatio_MAX                          = 5,
};

// Enum OakGame.EHUDType
// NumValues: 0x0005
enum class EHUDType : uint8
{
	NoHUD                                    = 0,
	StandardPlayerHUD                        = 1,
	VehicleHUD                               = 2,
	IronbearHUD                              = 3,
	EHUDType_MAX                             = 4,
};

// Enum OakGame.EOakInputActionEventType
// NumValues: 0x0004
enum class EOakInputActionEventType : uint8
{
	None                                     = 0,
	Button                                   = 1,
	Axis                                     = 2,
	EOakInputActionEventType_MAX             = 3,
};

// Enum OakGame.EPickupFlyToSettingsType
// NumValues: 0x0004
enum class EPickupFlyToSettingsType : uint8
{
	Dropped                                  = 0,
	Container                                = 1,
	AutoLootContainer                        = 2,
	EPickupFlyToSettingsType_MAX             = 3,
};

// Enum OakGame.EOakInventoryItemFlags
// NumValues: 0x0004
enum class EOakInventoryItemFlags : uint8
{
	HasBeenSeenInInventoryMenu               = 0,
	MarkedAsFavorite                         = 1,
	MarkedAsJunk                             = 2,
	EOakInventoryItemFlags_MAX               = 3,
};

// Enum OakGame.EOakInventoryMenuPaperDollSlotAdjacency
// NumValues: 0x0004
enum class EOakInventoryMenuPaperDollSlotAdjacency : uint32
{
	Mid                                      = 0,
	Left                                     = 1,
	Right                                    = 2,
	EOakInventoryMenuPaperDollSlotAdjacency_MAX = 3,
};

// Enum OakGame.EOakInventoryMenuAmmoState
// NumValues: 0x0007
enum class EOakInventoryMenuAmmoState : uint8
{
	Default                                  = 0,
	Highlighted                              = 1,
	HighlightedEmpty                         = 2,
	Low                                      = 3,
	Empty                                    = 4,
	Full                                     = 5,
	EOakInventoryMenuAmmoState_MAX           = 6,
};

// Enum OakGame.EOakInventoryMenuWhatChanged
// NumValues: 0x0008
enum class EOakInventoryMenuWhatChanged : uint8
{
	Initial                                  = 0,
	RefreshAll                               = 1,
	SortChanged                              = 2,
	AddedItem                                = 3,
	RemovedItem                              = 4,
	UnequippedItem                           = 5,
	EquippedItem                             = 6,
	EOakInventoryMenuWhatChanged_MAX         = 7,
};

// Enum OakGame.EOakInventoryMenuSortMode
// NumValues: 0x0006
enum class EOakInventoryMenuSortMode : uint8
{
	NewestFirst                              = 0,
	Type                                     = 1,
	Level                                    = 2,
	Manufacturer                             = 3,
	Rarity                                   = 4,
	EOakInventoryMenuSortMode_MAX            = 5,
};

// Enum OakGame.EOakInventoryItemWidgetSelectType
// NumValues: 0x0004
enum class EOakInventoryItemWidgetSelectType : uint8
{
	Normal                                   = 0,
	HideWhenSelected                         = 1,
	PopoutSelection                          = 2,
	EOakInventoryItemWidgetSelectType_MAX    = 3,
};

// Enum OakGame.EOakInventoryItemWidgetDisabledReason
// NumValues: 0x0005
enum class EOakInventoryItemWidgetDisabledReason : uint8
{
	NotDisabled                              = 0,
	SlotLocked                               = 1,
	BrowsingAnotherPanel                     = 2,
	CantEquipInSlot                          = 3,
	EOakInventoryItemWidgetDisabledReason_MAX = 4,
};

// Enum OakGame.EOakStatusMenuInventoryEvent
// NumValues: 0x0005
enum class EOakStatusMenuInventoryEvent : uint8
{
	PaperDollItemHighlighted                 = 0,
	BackpackItemHighlighted                  = 1,
	BackpackHighlighted                      = 2,
	PaperDollHighlighted                     = 3,
	EOakStatusMenuInventoryEvent_MAX         = 4,
};

// Enum OakGame.EOakInventoryRarityBalanceTableType
// NumValues: 0x0002
enum class EOakInventoryRarityBalanceTableType : uint8
{
	Weapon                                   = 0,
	EOakInventoryRarityBalanceTableType_MAX  = 1,
};

// Enum OakGame.EMailItemType
// NumValues: 0x0007
enum class EMailItemType : uint8
{
	None                                     = 0,
	GearboxMail                              = 1,
	PlayerMail                               = 2,
	StreamerMail                             = 3,
	NPCMail                                  = 4,
	DownloadableEntitlement                  = 5,
	EMailItemType_MAX                        = 6,
};

// Enum OakGame.EReapOrder
// NumValues: 0x0004
enum class EReapOrder : uint8
{
	OldestFirst                              = 0,
	NewestFirst                              = 1,
	Random                                   = 2,
	EReapOrder_MAX                           = 3,
};

// Enum OakGame.EOakManufacturerBalanceTableType
// NumValues: 0x0002
enum class EOakManufacturerBalanceTableType : uint8
{
	Weapon                                   = 0,
	EOakManufacturerBalanceTableType_MAX     = 1,
};

// Enum OakGame.EOakMinimapIconComponentType
// NumValues: 0x0004
enum class EOakMinimapIconComponentType : uint8
{
	Manual                                   = 0,
	TargetingComponentDriven                 = 1,
	WhileAlive                               = 2,
	EOakMinimapIconComponentType_MAX         = 3,
};

// Enum OakGame.EOakMissionType
// NumValues: 0x0009
enum class EOakMissionType : uint8
{
	Default                                  = 0,
	Plot                                     = 1,
	Side                                     = 2,
	ProvingGrounds                           = 3,
	CircleOfSlaughter                        = 4,
	Raid                                     = 5,
	RareSpawn                                = 6,
	Count                                    = 7,
	EOakMissionType_MAX                      = 8,
};

// Enum OakGame.EOakMusicLayer
// NumValues: 0x0008
enum class EOakMusicLayer : uint8
{
	Aux                                      = 0,
	Bass                                     = 1,
	Chord                                    = 2,
	Melody                                   = 3,
	Perc_Kick                                = 4,
	Perc_Large                               = 5,
	Perc_Small                               = 6,
	MAX                                      = 7,
};

// Enum OakGame.EOakMusicPart
// NumValues: 0x0017
enum class EOakMusicPart : uint8
{
	Part_None                                = 0,
	Part_0                                   = 1,
	Part_1                                   = 2,
	Part_2                                   = 3,
	Part_3                                   = 4,
	Part_4                                   = 5,
	Part_5                                   = 6,
	Part_6                                   = 7,
	Part_7                                   = 8,
	Part_8                                   = 9,
	Part_9                                   = 10,
	Part_10                                  = 11,
	Part_11                                  = 12,
	Part_12                                  = 13,
	Part_13                                  = 14,
	Part_14                                  = 15,
	Part_15                                  = 16,
	Part_16                                  = 17,
	Part_17                                  = 18,
	Part_18                                  = 19,
	Part_19                                  = 20,
	Part_SparseAmbiance                      = 21,
	Part_MAX                                 = 22,
};

// Enum OakGame.EOakMusicSection
// NumValues: 0x000C
enum class EOakMusicSection : uint8
{
	Section_None                             = 0,
	Section_0                                = 1,
	Section_1                                = 2,
	Section_2                                = 3,
	Section_3                                = 4,
	Section_4                                = 5,
	Section_5                                = 6,
	Section_6                                = 7,
	Section_7                                = 8,
	Section_8                                = 9,
	Section_9                                = 10,
	Section_MAX                              = 11,
};

// Enum OakGame.EDrivingOverridePriority
// NumValues: 0x0006
enum class EDrivingOverridePriority : uint8
{
	AINode                                   = 0,
	Aspect                                   = 1,
	Scripted                                 = 2,
	Count                                    = 3,
	Invalid                                  = 4,
	EDrivingOverridePriority_MAX             = 5,
};

// Enum OakGame.ESpeedModifierOverridePriority
// NumValues: 0x0008
enum class ESpeedModifierOverridePriority : uint8
{
	AINode                                   = 0,
	Aspect                                   = 1,
	Scripted                                 = 2,
	Escort                                   = 3,
	UserEdge                                 = 4,
	Count                                    = 5,
	Invalid                                  = 6,
	ESpeedModifierOverridePriority_MAX       = 7,
};

// Enum OakGame.EOakOnlineLobbyTalkingState
// NumValues: 0x0004
enum class EOakOnlineLobbyTalkingState : uint8
{
	NotTalking                               = 0,
	Talking                                  = 1,
	Muted                                    = 2,
	EOakOnlineLobbyTalkingState_MAX          = 3,
};

// Enum OakGame.EOakOnlineLobbyPlayerPlateState
// NumValues: 0x0006
enum class EOakOnlineLobbyPlayerPlateState : uint8
{
	Offline                                  = 0,
	WaitingForPlayers                        = 1,
	Invite                                   = 2,
	SplitPlayerToJoin                        = 3,
	PlayerListed                             = 4,
	EOakOnlineLobbyPlayerPlateState_MAX      = 5,
};

// Enum OakGame.EOakOnlineLobbyConnectivityState
// NumValues: 0x0006
enum class EOakOnlineLobbyConnectivityState : uint8
{
	Unknown                                  = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	None                                     = 4,
	EOakOnlineLobbyConnectivityState_MAX     = 5,
};

// Enum OakGame.EOakPassiveAbilityHUDIconActivationType
// NumValues: 0x0006
enum class EOakPassiveAbilityHUDIconActivationType : uint8
{
	TriggeredEffect                          = 0,
	StatusEffect                             = 1,
	AbilityTimer                             = 2,
	Manual                                   = 3,
	ActiveState                              = 4,
	EOakPassiveAbilityHUDIconActivationType_MAX = 5,
};

// Enum OakGame.EAdditionalTriggeredEffectTargets
// NumValues: 0x0004
enum class EAdditionalTriggeredEffectTargets : uint8
{
	None                                     = 0,
	MyCompanions                             = 1,
	MyAllies                                 = 2,
	EAdditionalTriggeredEffectTargets_MAX    = 3,
};

// Enum OakGame.EOakPassiveAbilitySirenArmDurationType
// NumValues: 0x0005
enum class EOakPassiveAbilitySirenArmDurationType : uint8
{
	None                                     = 0,
	AbilityState                             = 1,
	AbilityTimer                             = 2,
	StatusEffect                             = 3,
	EOakPassiveAbilitySirenArmDurationType_MAX = 4,
};

// Enum OakGame.ESkillItemRealType
// NumValues: 0x0006
enum class ESkillItemRealType : uint8
{
	None                                     = 0,
	PlayerAbility                            = 1,
	Augment                                  = 2,
	AugmentSlot                              = 3,
	CharacterAugment                         = 4,
	ESkillItemRealType_MAX                   = 5,
};

// Enum OakGame.ESkillItemDisplayType
// NumValues: 0x0007
enum class ESkillItemDisplayType : uint8
{
	None                                     = 0,
	ActionSkill                              = 1,
	ModPrimary                               = 2,
	ModSecondary                             = 3,
	Passive                                  = 4,
	ClassAbility                             = 5,
	ESkillItemDisplayType_MAX                = 6,
};

// Enum OakGame.ESkillItemLayoutInfo
// NumValues: 0x0006
enum class ESkillItemLayoutInfo : uint8
{
	Left                                     = 0,
	Center                                   = 1,
	Right                                    = 2,
	LeftWing                                 = 3,
	RightWing                                = 4,
	ESkillItemLayoutInfo_MAX                 = 5,
};

// Enum OakGame.EScreenCalibrationMode
// NumValues: 0x0004
enum class EScreenCalibrationMode : uint8
{
	Off                                      = 0,
	HDRBrightness                            = 1,
	StandardBrightnessAndBlackLevel          = 2,
	EScreenCalibrationMode_MAX               = 3,
};

// Enum OakGame.EJoystickScheme
// NumValues: 0x0006
enum class EJoystickScheme : uint32
{
	Classic                                  = 0,
	SouthPaw                                 = 1,
	OldSchool                                = 2,
	OldSchool_Southpaw                       = 3,
	Count                                    = 4,
	EJoystickScheme_MAX                      = 5,
};

// Enum OakGame.EDrivingButtonScheme
// NumValues: 0x0006
enum class EDrivingButtonScheme : uint32
{
	Classic                                  = 0,
	CameraRelative                           = 1,
	VehicleRelative                          = 2,
	VehicleRelativeStick                     = 3,
	Count                                    = 4,
	EDrivingButtonScheme_MAX                 = 5,
};

// Enum OakGame.EWalkingButtonScheme
// NumValues: 0x0004
enum class EWalkingButtonScheme : uint32
{
	Default                                  = 0,
	Classic                                  = 1,
	Count                                    = 2,
	EWalkingButtonScheme_MAX                 = 3,
};

// Enum OakGame.EGameJoinNotificationState
// NumValues: 0x0005
enum class EGameJoinNotificationState : uint8
{
	EGJNS_None                               = 0,
	EGJNS_PlayerStateReplicated              = 1,
	EGJNS_SyncLevelReplicated                = 2,
	EGJNS_PlayerNotified                     = 3,
	EGJNS_MAX                                = 4,
};

// Enum OakGame.EPresentableStatusEffectValueStrategy
// NumValues: 0x0003
enum class EPresentableStatusEffectValueStrategy : uint32
{
	PercentOfMaxHealth                       = 0,
	InstanceCount                            = 1,
	EPresentableStatusEffectValueStrategy_MAX = 2,
};

// Enum OakGame.ERadiateMovementType
// NumValues: 0x0003
enum class ERadiateMovementType : uint8
{
	FollowInitialDirection                   = 0,
	SimpleMoveOnGround                       = 1,
	ERadiateMovementType_MAX                 = 2,
};

// Enum OakGame.ERadiateMethod
// NumValues: 0x0003
enum class ERadiateMethod : uint8
{
	Velocity                                 = 0,
	MinMaxDistance                           = 1,
	ERadiateMethod_MAX                       = 2,
};

// Enum OakGame.EClassRepNodeMapping
// NumValues: 0x0006
enum class EClassRepNodeMapping : uint8
{
	NotRouted                                = 0,
	RelevantForConnections                   = 1,
	Spatialize_Static                        = 2,
	Spatialize_Dynamic                       = 3,
	Spatialize_Dormancy                      = 4,
	EClassRepNodeMapping_MAX                 = 5,
};

// Enum OakGame.EEventTriggerType
// NumValues: 0x0004
enum class EEventTriggerType : uint8
{
	StreamingEvent_DirectorTriggered         = 0,
	StreamingEvent_WorldTriggered            = 1,
	StreamingEvent_ViewerTriggered           = 2,
	StreamingEvent_MAX                       = 3,
};

// Enum OakGame.EStreamingInteractionEventState
// NumValues: 0x0005
enum class EStreamingInteractionEventState : uint8
{
	StreamingEvent_Disabled                  = 0,
	StreamingEvent_Preliminary               = 1,
	StreamingEvent_Standby                   = 2,
	StreamingEvent_Active                    = 3,
	StreamingEvent_MAX                       = 4,
};

// Enum OakGame.ECharacterProfileUpdateStep
// NumValues: 0x0004
enum class ECharacterProfileUpdateStep : uint8
{
	Step_MainCharacterInfo                   = 0,
	Step_MainCharacterInfo2                  = 1,
	Step_Inventory                           = 2,
	Step_MAX                                 = 3,
};

// Enum OakGame.EStreamingManagerState
// NumValues: 0x0005
enum class EStreamingManagerState : uint8
{
	StreamingManager_Off                     = 0,
	StreamingManager_Initialized             = 1,
	StreamingManager_Active                  = 2,
	StreamingManager_Paused                  = 3,
	StreamingManager_MAX                     = 4,
};

// Enum OakGame.EEndEventReasons
// NumValues: 0x000A
enum class EEndEventReasons : uint32
{
	Unknown                                  = 0,
	Success                                  = 1,
	NoParticipants                           = 2,
	Timeout                                  = 3,
	Error                                    = 4,
	Win                                      = 5,
	Draw                                     = 6,
	Lose                                     = 7,
	MapExited                                = 8,
	EEndEventReasons_MAX                     = 9,
};

// Enum OakGame.EOakTriggerComponentEventType
// NumValues: 0x0003
enum class EOakTriggerComponentEventType : uint8
{
	Touch                                    = 0,
	UnTouch                                  = 1,
	EOakTriggerComponentEventType_MAX        = 2,
};

// Enum OakGame.EOakUIChallengeDataProviderPopulateType
// NumValues: 0x0005
enum class EOakUIChallengeDataProviderPopulateType : uint32
{
	UNKNOWN                                  = 0,
	Galaxy                                   = 1,
	Planet                                   = 2,
	Level                                    = 3,
	EOakUIChallengeDataProviderPopulateType_MAX = 4,
};

// Enum OakGame.EVehicleInputMode
// NumValues: 0x0006
enum class EVehicleInputMode : uint32
{
	CameraRelative_Classic                   = 0,
	CameraRelative_ThirdPerson               = 1,
	VehicleRelative_LeftSide                 = 2,
	VehicleRelative_StickOnly                = 3,
	Count                                    = 4,
	EVehicleInputMode_MAX                    = 5,
};

// Enum OakGame.EVehiclePropertyValueType
// NumValues: 0x000A
enum class EVehiclePropertyValueType : uint8
{
	Speed_KPH                                = 0,
	PlanarSpeed_KPH                          = 1,
	ForwardSpeed_KPH                         = 2,
	Speed_MPH                                = 3,
	PlanarSpeed_MPH                          = 4,
	ForwardSpeed_MPH                         = 5,
	Mass                                     = 6,
	IsPlayerDriven                           = 7,
	IsAIDriven                               = 8,
	EVehiclePropertyValueType_MAX            = 9,
};

// Enum OakGame.EVoGDisplayState
// NumValues: 0x0006
enum class EVoGDisplayState : uint8
{
	None                                     = 0,
	Inactive                                 = 1,
	FadingIn                                 = 2,
	Displayed                                = 3,
	FadingOut                                = 4,
	EVoGDisplayState_MAX                     = 5,
};

// Enum OakGame.EOakWeaponPartType
// NumValues: 0x000F
enum class EOakWeaponPartType : uint8
{
	Grip                                     = 0,
	Foregrip                                 = 1,
	Mag                                      = 2,
	Mode                                     = 3,
	ModeSwitch                               = 4,
	Barrel                                   = 5,
	Scope                                    = 6,
	Reload                                   = 7,
	Melee                                    = 8,
	Bolt                                     = 9,
	Trigger                                  = 10,
	Hammer                                   = 11,
	CustomA                                  = 12,
	CustomB                                  = 13,
	EOakWeaponPartType_MAX                   = 14,
};

// Enum OakGame.VehicleWeapons
// NumValues: 0x0012
enum class EVehicleWeapons : uint8
{
	Technical_BarrelLauncher                 = 0,
	Technical_StickyBombs                    = 1,
	Technical_TireBombs                      = 2,
	Outrunner_HeavyMissile                   = 3,
	Outrunner_SwarmerMissile                 = 4,
	Outrunner_ShotgunMissile                 = 5,
	Emperor_Entropy                          = 6,
	Emperor_Hellfire                         = 7,
	Outrunner_FlameThrower                   = 8,
	Outrunner_TeslaCoil                      = 9,
	Technical_MachineGun                     = 10,
	Technical_FlakCannon                     = 11,
	Revolver_SpikeLauncher                   = 12,
	Revolver_SawBladeLauncher                = 13,
	Revolver_GrenadeLauncher                 = 14,
	Emperor_PulseRifle                       = 15,
	Emperor_BouncingLaser                    = 16,
	VehicleWeapons_MAX                       = 17,
};

// Enum OakGame.EWeaponAudioBodyLoopState
// NumValues: 0x0005
enum class EWeaponAudioBodyLoopState : uint8
{
	Active                                   = 0,
	Equipping                                = 1,
	Reloading                                = 2,
	Invalid                                  = 3,
	EWeaponAudioBodyLoopState_MAX            = 4,
};

// Enum OakGame.EWeaponAudioBodyLoopType
// NumValues: 0x0004
enum class EWeaponAudioBodyLoopType : uint32
{
	PlayerOnly                               = 0,
	BothPlayersAndNPCs                       = 1,
	NPCOnly                                  = 2,
	EWeaponAudioBodyLoopType_MAX             = 3,
};

// Enum OakGame.EOnlineMessageAnimationEnum
// NumValues: 0x0004
enum class EOnlineMessageAnimationEnum : uint8
{
	NONE                                     = 0,
	EXIT_ANIMATION                           = 1,
	INTRO_ANIMATION                          = 2,
	EOnlineMessageAnimationEnum_MAX          = 3,
};

// Enum OakGame.EOperativeBarrierState
// NumValues: 0x0005
enum class EOperativeBarrierState : uint8
{
	Activating                               = 0,
	Carried                                  = 1,
	Deployed                                 = 2,
	ShuttingDown                             = 3,
	EOperativeBarrierState_MAX               = 4,
};

// Enum OakGame.EOptionType
// NumValues: 0x00BC
enum class EOptionType : uint8
{
	Option_TODO                              = 0,
	Option_Title                             = 1,
	Option_Keybinding                        = 2,
	Gameplay_InvertMapPitchControls          = 3,
	Gameplay_InvertMapYawControls            = 4,
	Audio_MasterVolume                       = 5,
	Audio_MusicVolume                        = 6,
	Audio_SoundEffectVolume                  = 7,
	Audio_VoiceVolume                        = 8,
	Audio_SoundMode                          = 9,
	Audio_PlayerCallouts                     = 10,
	Audio_MuteAudioOnFocusLost               = 11,
	Audio_ControllerAudio                    = 12,
	Audio_PushToTalk                         = 13,
	Audio_VoiceChatVolume                    = 14,
	Audio_EnableMicrosoftSpatial_Available   = 15,
	Audio_EnableMicrosoftSpatial_Unavailable = 16,
	Gameplay_ResetTutorials                  = 17,
	Gameplay_IndividualDifficulty            = 18,
	Gameplay_EnableTrainingMessages          = 19,
	Gameplay_MPHOrKPH                        = 20,
	Gameplay_CenterCrosshair                 = 21,
	Gameplay_FixedMinimapRotation            = 22,
	Gameplay_CensorGore                      = 23,
	Gameplay_MinimapLegendaries              = 24,
	Gameplay_AutosellRarity                  = 25,
	Network_NetworkConnection                = 26,
	Network_CrossplayState                   = 27,
	Network_FriendSync                       = 28,
	Network_MatchmakingRegion                = 29,
	Network_HideTextChat                     = 30,
	Network_TradeRequest                     = 31,
	Network_PlayerToasts                     = 32,
	Network_ToastsDuration                   = 33,
	Network_StreamingService                 = 34,
	Network_IncreasedSubscribersChance       = 35,
	Network_RareChestEventEnabled            = 36,
	Network_BadassEventEnabled               = 37,
	Network_BadassEventCooldown              = 38,
	Network_PinataEventEnabled               = 39,
	Network_MoxxisDrinkEventEnabled          = 40,
	Network_MoxxisDrinkEventBitsProductId    = 41,
	Network_ExtractionEventEnabled           = 42,
	Graphics_WindowMode                      = 43,
	Graphics_Resolutions                     = 44,
	Graphics_VSync                           = 45,
	Graphics_FieldOfView                     = 46,
	Graphics_EnableMotionBlur                = 47,
	Graphics_TargetDisplay                   = 48,
	Graphics_GraphicsMode                    = 49,
	Graphics_CalibrateSafeArea               = 50,
	Graphics_CalibrateDisplay                = 51,
	Graphics_VehicleFieldOfView              = 52,
	Graphics_FramerateLimiter                = 53,
	Graphics_EnableCAS                       = 54,
	Graphics_PreferredAPI                    = 55,
	Graphics_AspectRatio                     = 56,
	Graphics_RefreshRate                     = 57,
	Graphics_FramerateLimitCustom            = 58,
	Graphics_ResolutionScale                 = 59,
	Graphics_HUDScaleMultiplier              = 60,
	Graphics_SplitScreenConfig               = 61,
	AdvancedGraphics_GraphicsQuality         = 62,
	AdvancedGraphics_AntialiasingMode        = 63,
	AdvancedGraphics_AnisotropicFiltering    = 64,
	AdvancedGraphics_DisplayPerformanceStats = 65,
	AdvancedGraphics_TextureDetail           = 66,
	AdvancedGraphics_DrawDistance            = 67,
	AdvancedGraphics_Clutter                 = 68,
	AdvancedGraphics_Tessellation            = 69,
	AdvancedGraphics_Foliage                 = 70,
	AdvancedGraphics_VolumetricFog           = 71,
	AdvancedGraphics_ScreenSpaceReflections  = 72,
	AdvancedGraphics_CharacterTextureDetail  = 73,
	AdvancedGraphics_CharacterDetail         = 74,
	AdvancedGraphics_ShadowQuality           = 75,
	AdvancedGraphics_AmbientOcclusionQuality = 76,
	AdvancedGraphics_CameraMotionBlur        = 77,
	AdvancedGraphics_ObjectMotionBlur        = 78,
	AdvancedGraphics_TextureStreaming        = 79,
	AdvancedGraphics_MaterialQuality         = 80,
	AdvancedGraphics_SystemInfo              = 81,
	Benchmark_Run                            = 82,
	Benchmark_Type                           = 83,
	Benchmark_DataOutput                     = 84,
	Benchmark_Results                        = 85,
	Benchmark_Uncapped                       = 86,
	Benchmark_ResultPhase                    = 87,
	Benchmark_ResultMeasurementType          = 88,
	Benchmark_ResultDateTime                 = 89,
	Benchmark_ResultFPS                      = 90,
	Benchmark_ResultFrameTime                = 91,
	Benchmark_ResultLoadTime                 = 92,
	Benchmark_ResultDataOutputPath           = 93,
	Benchmark_ResultDetails0                 = 94,
	Benchmark_ResultDetails1                 = 95,
	Benchmark_ResultDetails2                 = 96,
	Benchmark_ResultDetails3                 = 97,
	Benchmark_ResultDetails4                 = 98,
	Controls_MouseInvertLook                 = 99,
	Controls_MouseSmoothing                  = 100,
	Controls_LookSensitivity                 = 101,
	Controls_MouseWeaponZoomSensitivity      = 102,
	Controls_MouseVehicleSpensitivity        = 103,
	Controls_GamepadInvertVerticalLook       = 104,
	Controls_GamepadInvertHorizontalLook     = 105,
	Controls_GamepadLookSensitivity          = 106,
	Controls_GamepadWeaponZoomSensitivity    = 107,
	Controls_GamepadVehicleSensitivity       = 108,
	Controls_Vibration                       = 109,
	Controls_TriggerFeedback                 = 110,
	Controls_GamepadInvertMapVerticalLook    = 111,
	Controls_GamepadInvertMapHorizontalLook  = 112,
	Controls_MouseAcceleration               = 113,
	Controls_EnableGamepad                   = 114,
	Controls_GamepadAimingInputStyle         = 115,
	Controls_InvertIronBearHardpoints        = 116,
	Controls_GlyphMode                       = 117,
	Controls_AllowWindowsKey                 = 118,
	ControlsAdvanced_InvertForwardMovement   = 119,
	ControlsAdvanced_InvertStrafeMovement    = 120,
	ControlsAdvanced_LeftDeadZoneCenter      = 121,
	ControlsAdvanced_LeftDeadZoneOuter       = 122,
	ControlsAdvanced_LeftAxialDeadZone       = 123,
	ControlsAdvanced_RightDeadZoneCenter     = 124,
	ControlsAdvanced_RightDeadZoneOuter      = 125,
	ControlsAdvanced_RightAxialDeadZone      = 126,
	Bindings_Move                            = 127,
	Bindings_Look                            = 128,
	Bindings_PCMoveForward                   = 129,
	Bindings_PCMoveBackward                  = 130,
	Bindings_PCStrafeLeft                    = 131,
	Bindings_PCStrafeRight                   = 132,
	Bindings_Jump                            = 133,
	Bindings_Crouch                          = 134,
	Bindings_Sprint                          = 135,
	Bindings_Fire                            = 136,
	Bindings_Reload                          = 137,
	Bindings_Melee                           = 138,
	Bindings_ActionSkill                     = 139,
	Bindings_GrenadeActionSkill2             = 140,
	Bindings_NextWeapon                      = 141,
	Bindings_PrevWeapon                      = 142,
	Bindings_NextWeaponCycleModeUseAlt       = 143,
	Bindings_SelectWeapon1                   = 144,
	Bindings_SelectWeapon2                   = 145,
	Bindings_SelectWeapon3                   = 146,
	Bindings_SelectWeapon4                   = 147,
	Bindings_DropWeapon                      = 148,
	Bindings_SecondaryUseQuickMenu           = 149,
	Bindings_UseGiveUp                       = 150,
	Bindings_UseGiveUpReload                 = 151,
	Bindings_WeaponToggle                    = 152,
	Bindings_Zoom                            = 153,
	Bindings_Emote1                          = 154,
	Bindings_Emote2                          = 155,
	Bindings_Emote3                          = 156,
	Bindings_Emote4                          = 157,
	Bindings_UnrebindableButton              = 158,
	Bindings_Vehicle_SteerForward            = 159,
	Bindings_Vehicle_SteerBackward           = 160,
	Bindings_Vehicle_WeaponPrimary           = 161,
	Bindings_Vehicle                         = 162,
	ControlSchemes_Driving                   = 163,
	ControlSchemes_DrivingJoystick           = 164,
	ControlSchemes_Walking                   = 165,
	ControlSchemes_WalkingJoystick           = 166,
	Accessibility_CrosshairFriendlyColor     = 167,
	Accessibility_CrosshairNeutralColor      = 168,
	Accessibility_CrosshairHostileColor      = 169,
	Accessibility_Subtitles                  = 170,
	Accessibility_ClosedCaptioning           = 171,
	Accessibility_CCTextSize                 = 172,
	Accessibility_CCBackgroundOpacity        = 173,
	Accessibility_AimAssist                  = 174,
	Accessibility_GamepadAimAssist           = 175,
	Accessibility_ZoomSnap                   = 176,
	Accessibility_GamepadZoomSnap            = 177,
	Accessibility_MouseZoomSnap              = 178,
	Accessibility_WeaponZoom                 = 179,
	Accessibility_AutoCenter                 = 180,
	Accessibility_HeadBobScale               = 181,
	Accessibility_Sprint                     = 182,
	Accessibility_Crouch                     = 183,
	Accessibility_MantleStyle                = 184,
	Accessibility_MovementRecenters          = 185,
	Accessibility_ShowDamageNumberElementalIcons = 186,
	EOptionType_MAX                          = 187,
};

// Enum OakGame.EOptionItemType
// NumValues: 0x000B
enum class EOptionItemType : uint8
{
	Title                                    = 0,
	Slider                                   = 1,
	Spinner                                  = 2,
	BooleanSpinner                           = 3,
	Button                                   = 4,
	Controls                                 = 5,
	Keybinding_Button                        = 6,
	KeyBinding_Axis                          = 7,
	TodoItem                                 = 8,
	DropDownList                             = 9,
	EOptionItemType_MAX                      = 10,
};

// Enum OakGame.EEchoPerformanceMode
// NumValues: 0x0005
enum class EEchoPerformanceMode : uint8
{
	EchoCommunication                        = 0,
	EchoLog                                  = 1,
	VoG                                      = 2,
	EridianWriting                           = 3,
	EEchoPerformanceMode_MAX                 = 4,
};

// Enum OakGame.EPhotoModeOptionEffect
// NumValues: 0x0017
enum class EPhotoModeOptionEffect : uint8
{
	None                                     = 0,
	FieldOfView                              = 1,
	CameraRoll                               = 2,
	Target                                   = 3,
	FocusDistance                            = 4,
	FocusRegion                              = 5,
	DOFIntensity                             = 6,
	Contrast                                 = 7,
	Saturation                               = 8,
	Gamma                                    = 9,
	Gain                                     = 10,
	TimeOfDay                                = 11,
	HideCharacters                           = 12,
	FilmGrain                                = 13,
	Filter                                   = 14,
	FilterIntensity                          = 15,
	VignetteIntensity                        = 16,
	VignetteFeathering                       = 17,
	HideDamageNumbers                        = 18,
	OverrideDOF                              = 19,
	Border                                   = 20,
	Tag                                      = 21,
	EPhotoModeOptionEffect_MAX               = 22,
};

// Enum OakGame.EEchoDeviceFXPositionMode
// NumValues: 0x0004
enum class EEchoDeviceFXPositionMode : uint8
{
	None                                     = 0,
	UIObject                                 = 1,
	ViewportPosition                         = 2,
	EEchoDeviceFXPositionMode_MAX            = 3,
};

// Enum OakGame.ETransactionType
// NumValues: 0x0006
enum class ETransactionType : uint8
{
	Buy                                      = 0,
	Sell                                     = 1,
	BuyBack                                  = 2,
	SellAllJunk                              = 3,
	PurchaseCustomization                    = 4,
	ETransactionType_MAX                     = 5,
};

// Enum OakGame.EPlayerStandInType
// NumValues: 0x0007
enum class EPlayerStandInType : uint8
{
	Unspecified                              = 0,
	FrontendLobby                            = 1,
	CharacterSelect                          = 2,
	CharacterCreate                          = 3,
	SkillScreen                              = 4,
	RnRCharacterSelect                       = 5,
	EPlayerStandInType_MAX                   = 6,
};

// Enum OakGame.EFrontendStandInSpecialAnimType
// NumValues: 0x0006
enum class EFrontendStandInSpecialAnimType : uint8
{
	PlayerArrival                            = 0,
	PrimaryPlayerFlourish                    = 1,
	CharacterSelectSelection                 = 2,
	CharacterSelectSelection_NoActionSkill   = 3,
	CharacterCreationSelection               = 4,
	MAX                                      = 5,
};

// Enum OakGame.EPlayerTradingStance
// NumValues: 0x0005
enum class EPlayerTradingStance : uint8
{
	Deciding                                 = 0,
	TradeReady                               = 1,
	DuelReady                                = 2,
	Disconnected                             = 3,
	EPlayerTradingStance_MAX                 = 4,
};

// Enum OakGame.EPlayerTradeManagerStatus
// NumValues: 0x0006
enum class EPlayerTradeManagerStatus : uint8
{
	Uninitialized                            = 0,
	Trading                                  = 1,
	Dueling                                  = 2,
	ResolvingTrade                           = 3,
	ResolvingDuel                            = 4,
	EPlayerTradeManagerStatus_MAX            = 5,
};

// Enum OakGame.EPlayThroughType
// NumValues: 0x0003
enum class EPlayThroughType : uint8
{
	CurrentPlayThrough                       = 0,
	EffectivePlayThrough                     = 1,
	EPlayThroughType_MAX                     = 2,
};

// Enum OakGame.EProjectedMeshShape
// NumValues: 0x0003
enum class EProjectedMeshShape : uint8
{
	Circle                                   = 0,
	Square                                   = 1,
	EProjectedMeshShape_MAX                  = 2,
};

// Enum OakGame.EShieldState
// NumValues: 0x0005
enum class EShieldState : uint8
{
	Uninitialized                            = 0,
	Empty                                    = 1,
	PartiallyFilled                          = 2,
	Filled                                   = 3,
	EShieldState_MAX                         = 4,
};

// Enum OakGame.EShieldAttributeModificationSource
// NumValues: 0x0006
enum class EShieldAttributeModificationSource : uint8
{
	Other                                    = 0,
	Equipped                                 = 1,
	Filled                                   = 2,
	Depleted                                 = 3,
	NotDepleted                              = 4,
	EShieldAttributeModificationSource_MAX   = 5,
};

// Enum OakGame.EStackOperator
// NumValues: 0x0003
enum class EStackOperator : uint8
{
	Add                                      = 0,
	Multiply                                 = 1,
	EStackOperator_MAX                       = 2,
};

// Enum OakGame.EShieldDamageModifierApplicationTarget
// NumValues: 0x0003
enum class EShieldDamageModifierApplicationTarget : uint8
{
	InstigatorCausedDamage                   = 0,
	InstigatorReceivedDamage                 = 1,
	EShieldDamageModifierApplicationTarget_MAX = 2,
};

// Enum OakGame.EAugmentTriggerOn
// NumValues: 0x0005
enum class EAugmentTriggerOn : uint8
{
	TriggerOn_Filled                         = 0,
	TriggerOn_NotFilled                      = 1,
	TriggerOn_Depleted                       = 2,
	TriggerOn_NotDepleted                    = 3,
	TriggerOn_MAX                            = 4,
};

// Enum OakGame.ESirenGhostArmConfigurationType
// NumValues: 0x0006
enum class ESirenGhostArmConfigurationType : uint8
{
	None                                     = 0,
	FirstPerson                              = 1,
	ThirdPerson                              = 2,
	FirstAndThirdPerson                      = 3,
	GhostArmsLocked                          = 4,
	ESirenGhostArmConfigurationType_MAX      = 5,
};

// Enum OakGame.EItemDropOnDeathType
// NumValues: 0x0005
enum class EItemDropOnDeathType : uint8
{
	DropOnDeath_All                          = 0,
	DropOnDeath_FirstDeath                   = 1,
	DropOnDeath_LastDeath                    = 2,
	DropOnDeath_RandomDeath                  = 3,
	DropOnDeath_MAX                          = 4,
};

// Enum OakGame.ELootInstancingPolicy
// NumValues: 0x0004
enum class ELootInstancingPolicy : uint8
{
	Instance                                 = 0,
	DontInstance                             = 1,
	InstanceForPlayer                        = 2,
	ELootInstancingPolicy_MAX                = 3,
};

// Enum OakGame.ESpawnDroppedPickupLootRequestType
// NumValues: 0x0003
enum class ESpawnDroppedPickupLootRequestType : uint8
{
	Drop                                     = 0,
	Attach                                   = 1,
	ESpawnDroppedPickupLootRequestType_MAX   = 2,
};

// Enum OakGame.EStandInAutoScaleMode
// NumValues: 0x0004
enum class EStandInAutoScaleMode : uint8
{
	None                                     = 0,
	ScaleDown                                = 1,
	ScaleUpOrDown                            = 2,
	EStandInAutoScaleMode_MAX                = 3,
};

// Enum OakGame.EStandInActorType
// NumValues: 0x0008
enum class EStandInActorType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	PlayerSkillScreen                        = 2,
	WeaponSkin                               = 3,
	WeaponTrinket                            = 4,
	CrewQuartersDecoration                   = 5,
	CustomActor                              = 6,
	EStandInActorType_MAX                    = 7,
};

// Enum OakGame.EBehaviorOutput
// NumValues: 0x0003
enum class EBehaviorOutput : uint8
{
	Found                                    = 0,
	NotFound                                 = 1,
	EBehaviorOutput_MAX                      = 2,
};

// Enum OakGame.ETinkPileUseState
// NumValues: 0x0006
enum class ETinkPileUseState : uint8
{
	None                                     = 0,
	NotUsed                                  = 1,
	InUse                                    = 2,
	WasUsed                                  = 3,
	Resetting                                = 4,
	ETinkPileUseState_MAX                    = 5,
};

// Enum OakGame.ETinkPileBuildOption
// NumValues: 0x0008
enum class ETinkPileBuildOption : uint8
{
	None                                     = 0,
	TurretBasic                              = 1,
	RocketPodBasic                           = 2,
	TurretPlaceholder1                       = 3,
	TurretPlaceholder2                       = 4,
	TurretPlaceholder3                       = 5,
	TurretPlaceholder4                       = 6,
	ETinkPileBuildOption_MAX                 = 7,
};

// Enum OakGame.ETransporterCraneState
// NumValues: 0x0005
enum class ETransporterCraneState : uint8
{
	Deactivated                              = 0,
	Stopped                                  = 1,
	MoveForward                              = 2,
	MoveBackward                             = 3,
	ETransporterCraneState_MAX               = 4,
};

// Enum OakGame.ETrophyCaseViewingState
// NumValues: 0x0005
enum class ETrophyCaseViewingState : uint8
{
	ViewingNone                              = 0,
	ViewingSet                               = 1,
	ViewingGroup                             = 2,
	ViewingTrophy                            = 3,
	ETrophyCaseViewingState_MAX              = 4,
};

// Enum OakGame.EGroundTurretType
// NumValues: 0x0003
enum class EGroundTurretType : uint8
{
	Seated                                   = 0,
	Standing                                 = 1,
	EGroundTurretType_MAX                    = 2,
};

// Enum OakGame.EUIManagerState
// NumValues: 0x0003
enum class EUIManagerState : uint8
{
	NONE                                     = 0,
	PLAYING_ANIMATION                        = 1,
	EUIManagerState_MAX                      = 2,
};

// Enum OakGame.UIManagerMessages
// NumValues: 0x0006
enum class EUIManagerMessages : uint8
{
	Critical                                 = 0,
	High                                     = 1,
	Normal                                   = 2,
	Low                                      = 3,
	Lowest                                   = 4,
	UIManagerMessages_MAX                    = 5,
};

// Enum OakGame.EChallengeCategoryID
// NumValues: 0x0009
enum class EChallengeCategoryID : uint8
{
	GameCompletion                           = 0,
	Enemy                                    = 1,
	Weapon                                   = 2,
	Crew                                     = 3,
	Exploration                              = 4,
	Slaughter                                = 5,
	Raid                                     = 6,
	ProvingGround                            = 7,
	Max                                      = 8,
};

// Enum OakGame.ERevolverOffsetMode
// NumValues: 0x0004
enum class ERevolverOffsetMode : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	ERevolverOffsetMode_MAX                  = 3,
};

// Enum OakGame.EWheelAudioType
// NumValues: 0x0005
enum class EWheelAudioType : uint8
{
	Standard                                 = 0,
	MultiPosition2Wheels                     = 1,
	MultiPosition1Wheel                      = 2,
	SingleWheel                              = 3,
	EWheelAudioType_MAX                      = 4,
};

// Enum OakGame.EVehiclePlaySingleAnimMode
// NumValues: 0x0003
enum class EVehiclePlaySingleAnimMode : uint32
{
	PlayOnStart                              = 0,
	PlayOnStop                               = 1,
	EVehiclePlaySingleAnimMode_MAX           = 2,
};

// Enum OakGame.EEmitterEnableMode
// NumValues: 0x0007
enum class EEmitterEnableMode : uint8
{
	EnableOnStart                            = 0,
	EnableOnStartDisableOnStop               = 1,
	EnableOnStop                             = 2,
	DisableOnStart                           = 3,
	DisableOnStartEnableOnStop               = 4,
	DisableOnStop                            = 5,
	EEmitterEnableMode_MAX                   = 6,
};

// Enum OakGame.EFollowVehicleRotation
// NumValues: 0x0004
enum class EFollowVehicleRotation : uint8
{
	None                                     = 0,
	Yaw                                      = 1,
	YawAndPitch                              = 2,
	EFollowVehicleRotation_MAX               = 3,
};

// Enum OakGame.EVendingMachineType
// NumValues: 0x0005
enum class EVendingMachineType : uint8
{
	Guns                                     = 0,
	Ammo                                     = 1,
	Health                                   = 2,
	CrazyEarl                                = 3,
	EVendingMachineType_MAX                  = 4,
};

// Enum OakGame.VendingMachineDisplayMode
// NumValues: 0x0004
enum class EVendingMachineDisplayMode : uint8
{
	EVMDM_Buy                                = 0,
	EVMDM_Sell                               = 1,
	EVMDM_Buyback                            = 2,
	EVMDM_MAX                                = 3,
};

// Enum OakGame.EVendingMachineTilesMode
// NumValues: 0x0004
enum class EVendingMachineTilesMode : uint8
{
	Purchase                                 = 0,
	BuyBack                                  = 1,
	Sell                                     = 2,
	MAX                                      = 3,
};

// Enum OakGame.EVendingMachineInteractionMode
// NumValues: 0x0004
enum class EVendingMachineInteractionMode : uint8
{
	Purchase                                 = 0,
	BuyBack                                  = 1,
	Sell                                     = 2,
	EVendingMachineInteractionMode_MAX       = 3,
};

// Enum OakGame.EVendingMachineAnimType
// NumValues: 0x0011
enum class EVendingMachineAnimType : uint8
{
	Idle                                     = 0,
	Back                                     = 1,
	BackTwice                                = 2,
	BackThrice                               = 3,
	BackJiggle                               = 4,
	Forward                                  = 5,
	ForwardTwice                             = 6,
	ForwardThrice                            = 7,
	ForwardJiggle                            = 8,
	Purchase                                 = 9,
	PurchaseInPlace                          = 10,
	TurnOn                                   = 11,
	TurnOff                                  = 12,
	ErrorJiggle                              = 13,
	SlideInFromTop                           = 14,
	SlideInFromBottom                        = 15,
	MAX                                      = 16,
};

// Enum OakGame.EVendingMachineTrayTileType
// NumValues: 0x0006
enum class EVendingMachineTrayTileType : uint8
{
	Regular                                  = 0,
	Featured                                 = 1,
	GearSoldByFriend                         = 2,
	VisibleDummy                             = 3,
	EndOfListDummy                           = 4,
	EVendingMachineTrayTileType_MAX          = 5,
};

// Enum OakGame.EWeaponShieldActivationTrigger
// NumValues: 0x0004
enum class EWeaponShieldActivationTrigger : uint8
{
	Zoom                                     = 0,
	Attach                                   = 1,
	Custom                                   = 2,
	EWeaponShieldActivationTrigger_MAX       = 3,
};

// Enum OakGame.EWeaponShieldState
// NumValues: 0x0003
enum class EWeaponShieldState : uint8
{
	Normal                                   = 0,
	Depleted                                 = 1,
	EWeaponShieldState_MAX                   = 2,
};

// Enum OakGame.EWeaponWearValueType
// NumValues: 0x0004
enum class EWeaponWearValueType : uint8
{
	Wear                                     = 0,
	Rust                                     = 1,
	Dirt                                     = 2,
	EWeaponWearValueType_MAX                 = 3,
};

// Enum OakGame.EZoneMapTargetType
// NumValues: 0x0007
enum class EZoneMapTargetType : uint8
{
	None                                     = 0,
	POI                                      = 1,
	Player                                   = 2,
	CrewChallenge                            = 3,
	MissionWaypoint                          = 4,
	DeployedVehicle                          = 5,
	EZoneMapTargetType_MAX                   = 6,
};

// ScriptStruct OakGame.GFxMissionTrackerRewardSlot
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FGFxMissionTrackerRewardSlot final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxMissionTrackerRewardSlot) == 0x000008, "Wrong alignment on FGFxMissionTrackerRewardSlot");
static_assert(sizeof(FGFxMissionTrackerRewardSlot) == 0x000080, "Wrong size on FGFxMissionTrackerRewardSlot");

// ScriptStruct OakGame.ReplicatedMeleeActionData
// 0x0018 (0x0018 - 0x0000)
struct FReplicatedMeleeActionData final
{
public:
	int32                                         Counter;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerMeleeData*                       MeleeData;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedMeleeActionData) == 0x000008, "Wrong alignment on FReplicatedMeleeActionData");
static_assert(sizeof(FReplicatedMeleeActionData) == 0x000018, "Wrong size on FReplicatedMeleeActionData");
static_assert(offsetof(FReplicatedMeleeActionData, Counter) == 0x000000, "Member 'FReplicatedMeleeActionData::Counter' has a wrong offset!");
static_assert(offsetof(FReplicatedMeleeActionData, Action) == 0x000008, "Member 'FReplicatedMeleeActionData::Action' has a wrong offset!");
static_assert(offsetof(FReplicatedMeleeActionData, MeleeData) == 0x000010, "Member 'FReplicatedMeleeActionData::MeleeData' has a wrong offset!");

// ScriptStruct OakGame.MinimalInventoryInfo
// 0x0068 (0x0068 - 0x0000)
struct FMinimalInventoryInfo final
{
public:
	int32                                         PickupOrderIdx;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 StoredActor;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SerialNumber;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ThumbnailName;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 InventoryCategory;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrash;                                          // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFavorite;                                       // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMissionItem;                                    // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        TrinketPartHash;                                   // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SkinPartHash;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MayhemPartHash;                                    // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MayhemPartUIStatHash;                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemJsonObjString;                                 // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBase64ThumbnailGenerated;                         // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalInventoryInfo) == 0x000008, "Wrong alignment on FMinimalInventoryInfo");
static_assert(sizeof(FMinimalInventoryInfo) == 0x000068, "Wrong size on FMinimalInventoryInfo");
static_assert(offsetof(FMinimalInventoryInfo, PickupOrderIdx) == 0x000000, "Member 'FMinimalInventoryInfo::PickupOrderIdx' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, StoredActor) == 0x000008, "Member 'FMinimalInventoryInfo::StoredActor' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, SerialNumber) == 0x000010, "Member 'FMinimalInventoryInfo::SerialNumber' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, ThumbnailName) == 0x000020, "Member 'FMinimalInventoryInfo::ThumbnailName' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, InventoryCategory) == 0x000030, "Member 'FMinimalInventoryInfo::InventoryCategory' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, bIsTrash) == 0x000038, "Member 'FMinimalInventoryInfo::bIsTrash' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, bIsFavorite) == 0x000039, "Member 'FMinimalInventoryInfo::bIsFavorite' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, bIsMissionItem) == 0x00003A, "Member 'FMinimalInventoryInfo::bIsMissionItem' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, TrinketPartHash) == 0x00003C, "Member 'FMinimalInventoryInfo::TrinketPartHash' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, SkinPartHash) == 0x000040, "Member 'FMinimalInventoryInfo::SkinPartHash' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, MayhemPartHash) == 0x000044, "Member 'FMinimalInventoryInfo::MayhemPartHash' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, MayhemPartUIStatHash) == 0x000048, "Member 'FMinimalInventoryInfo::MayhemPartUIStatHash' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, ItemJsonObjString) == 0x000050, "Member 'FMinimalInventoryInfo::ItemJsonObjString' has a wrong offset!");
static_assert(offsetof(FMinimalInventoryInfo, bBase64ThumbnailGenerated) == 0x000060, "Member 'FMinimalInventoryInfo::bBase64ThumbnailGenerated' has a wrong offset!");

// ScriptStruct OakGame.MinimalAugmentSlotInfo
// 0x000C (0x000C - 0x0000)
struct FMinimalAugmentSlotInfo final
{
public:
	uint32                                        ActionAbilityHash;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AugmentSlotHash;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AugmentHash;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimalAugmentSlotInfo) == 0x000004, "Wrong alignment on FMinimalAugmentSlotInfo");
static_assert(sizeof(FMinimalAugmentSlotInfo) == 0x00000C, "Wrong size on FMinimalAugmentSlotInfo");
static_assert(offsetof(FMinimalAugmentSlotInfo, ActionAbilityHash) == 0x000000, "Member 'FMinimalAugmentSlotInfo::ActionAbilityHash' has a wrong offset!");
static_assert(offsetof(FMinimalAugmentSlotInfo, AugmentSlotHash) == 0x000004, "Member 'FMinimalAugmentSlotInfo::AugmentSlotHash' has a wrong offset!");
static_assert(offsetof(FMinimalAugmentSlotInfo, AugmentHash) == 0x000008, "Member 'FMinimalAugmentSlotInfo::AugmentHash' has a wrong offset!");

// ScriptStruct OakGame.MinimalEquippedInventoryInfo
// 0x000C (0x000C - 0x0000)
struct FMinimalEquippedInventoryInfo final
{
public:
	uint32                                        InventorySlotHash;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickupOrderIdx;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimalEquippedInventoryInfo) == 0x000004, "Wrong alignment on FMinimalEquippedInventoryInfo");
static_assert(sizeof(FMinimalEquippedInventoryInfo) == 0x00000C, "Wrong size on FMinimalEquippedInventoryInfo");
static_assert(offsetof(FMinimalEquippedInventoryInfo, InventorySlotHash) == 0x000000, "Member 'FMinimalEquippedInventoryInfo::InventorySlotHash' has a wrong offset!");
static_assert(offsetof(FMinimalEquippedInventoryInfo, PickupOrderIdx) == 0x000004, "Member 'FMinimalEquippedInventoryInfo::PickupOrderIdx' has a wrong offset!");
static_assert(offsetof(FMinimalEquippedInventoryInfo, bEnabled) == 0x000008, "Member 'FMinimalEquippedInventoryInfo::bEnabled' has a wrong offset!");

// ScriptStruct OakGame.MinimalAbilitSlotInfo
// 0x0008 (0x0008 - 0x0000)
struct FMinimalAbilitSlotInfo final
{
public:
	uint32                                        AbilitySlotHash;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AbilityHash;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimalAbilitSlotInfo) == 0x000004, "Wrong alignment on FMinimalAbilitSlotInfo");
static_assert(sizeof(FMinimalAbilitSlotInfo) == 0x000008, "Wrong size on FMinimalAbilitSlotInfo");
static_assert(offsetof(FMinimalAbilitSlotInfo, AbilitySlotHash) == 0x000000, "Member 'FMinimalAbilitSlotInfo::AbilitySlotHash' has a wrong offset!");
static_assert(offsetof(FMinimalAbilitSlotInfo, AbilityHash) == 0x000004, "Member 'FMinimalAbilitSlotInfo::AbilityHash' has a wrong offset!");

// ScriptStruct OakGame.SkillTreeItemsStatValues
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FSkillTreeItemsStatValues final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillTreeItemsStatValues) == 0x000008, "Wrong alignment on FSkillTreeItemsStatValues");
static_assert(sizeof(FSkillTreeItemsStatValues) == 0x0000A0, "Wrong size on FSkillTreeItemsStatValues");

// ScriptStruct OakGame.MinimalCharacterInfo
// 0x0158 (0x0158 - 0x0000)
struct FMinimalCharacterInfo final
{
public:
	uint32                                        TimePlayedSeconds;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperiencePoints;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BackpackSize;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldenKeys;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMinimalInventoryInfo>          Inventory;                                         // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMinimalEquippedInventoryInfo>  EquippedInventory;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<uint32, int32>                           InventoryCategoryList;                             // 0x0038(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AbilityPoints;                                     // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, int32>                           TreeItems;                                         // 0x0090(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMinimalAbilitSlotInfo>         AbilitySlots;                                      // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMinimalAugmentSlotInfo>        AugmentSlots;                                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        PetAugmentHash;                                    // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FSkillTreeItemsStatValues> SkillTreeItemsStatValues;                          // 0x0108(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimalCharacterInfo) == 0x000008, "Wrong alignment on FMinimalCharacterInfo");
static_assert(sizeof(FMinimalCharacterInfo) == 0x000158, "Wrong size on FMinimalCharacterInfo");
static_assert(offsetof(FMinimalCharacterInfo, TimePlayedSeconds) == 0x000000, "Member 'FMinimalCharacterInfo::TimePlayedSeconds' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, ExperiencePoints) == 0x000004, "Member 'FMinimalCharacterInfo::ExperiencePoints' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, PlayerLevel) == 0x000008, "Member 'FMinimalCharacterInfo::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, BackpackSize) == 0x00000C, "Member 'FMinimalCharacterInfo::BackpackSize' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, GoldenKeys) == 0x000010, "Member 'FMinimalCharacterInfo::GoldenKeys' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, Inventory) == 0x000018, "Member 'FMinimalCharacterInfo::Inventory' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, EquippedInventory) == 0x000028, "Member 'FMinimalCharacterInfo::EquippedInventory' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, InventoryCategoryList) == 0x000038, "Member 'FMinimalCharacterInfo::InventoryCategoryList' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, AbilityPoints) == 0x000088, "Member 'FMinimalCharacterInfo::AbilityPoints' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, TreeItems) == 0x000090, "Member 'FMinimalCharacterInfo::TreeItems' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, AbilitySlots) == 0x0000E0, "Member 'FMinimalCharacterInfo::AbilitySlots' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, AugmentSlots) == 0x0000F0, "Member 'FMinimalCharacterInfo::AugmentSlots' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, PetAugmentHash) == 0x000100, "Member 'FMinimalCharacterInfo::PetAugmentHash' has a wrong offset!");
static_assert(offsetof(FMinimalCharacterInfo, SkillTreeItemsStatValues) == 0x000108, "Member 'FMinimalCharacterInfo::SkillTreeItemsStatValues' has a wrong offset!");

// ScriptStruct OakGame.MayhemDebugOverrides
// 0x0010 (0x0010 - 0x0000)
struct FMayhemDebugOverrides final
{
public:
	TArray<int32>                                 ModifierIndexOverrides;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemDebugOverrides) == 0x000008, "Wrong alignment on FMayhemDebugOverrides");
static_assert(sizeof(FMayhemDebugOverrides) == 0x000010, "Wrong size on FMayhemDebugOverrides");
static_assert(offsetof(FMayhemDebugOverrides, ModifierIndexOverrides) == 0x000000, "Member 'FMayhemDebugOverrides::ModifierIndexOverrides' has a wrong offset!");

// ScriptStruct OakGame.MayhemReplicableSetsData
// 0x0004 (0x0004 - 0x0000)
struct FMayhemReplicableSetsData final
{
public:
	int32                                         ActiveSetsBits;                                    // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemReplicableSetsData) == 0x000004, "Wrong alignment on FMayhemReplicableSetsData");
static_assert(sizeof(FMayhemReplicableSetsData) == 0x000004, "Wrong size on FMayhemReplicableSetsData");
static_assert(offsetof(FMayhemReplicableSetsData, ActiveSetsBits) == 0x000000, "Member 'FMayhemReplicableSetsData::ActiveSetsBits' has a wrong offset!");

// ScriptStruct OakGame.MayhemModeState
// 0x0028 (0x0028 - 0x0000)
struct FMayhemModeState final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MayhemLevel;                                       // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PendingMayhemLevel;                                // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PendingRandomSeed;                                 // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMayhemDebugOverrides                  CachedOptionalOverrides;                           // 0x0010(0x0010)(Transient, NativeAccessSpecifierPrivate)
	struct FMayhemReplicableSetsData              ReplicableSets;                                    // 0x0020(0x0004)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         RandomSeed;                                        // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMayhemModeState) == 0x000008, "Wrong alignment on FMayhemModeState");
static_assert(sizeof(FMayhemModeState) == 0x000028, "Wrong size on FMayhemModeState");
static_assert(offsetof(FMayhemModeState, bIsActive) == 0x000000, "Member 'FMayhemModeState::bIsActive' has a wrong offset!");
static_assert(offsetof(FMayhemModeState, MayhemLevel) == 0x000004, "Member 'FMayhemModeState::MayhemLevel' has a wrong offset!");
static_assert(offsetof(FMayhemModeState, PendingMayhemLevel) == 0x000008, "Member 'FMayhemModeState::PendingMayhemLevel' has a wrong offset!");
static_assert(offsetof(FMayhemModeState, PendingRandomSeed) == 0x00000C, "Member 'FMayhemModeState::PendingRandomSeed' has a wrong offset!");
static_assert(offsetof(FMayhemModeState, CachedOptionalOverrides) == 0x000010, "Member 'FMayhemModeState::CachedOptionalOverrides' has a wrong offset!");
static_assert(offsetof(FMayhemModeState, ReplicableSets) == 0x000020, "Member 'FMayhemModeState::ReplicableSets' has a wrong offset!");
static_assert(offsetof(FMayhemModeState, RandomSeed) == 0x000024, "Member 'FMayhemModeState::RandomSeed' has a wrong offset!");

// ScriptStruct OakGame.ExitDownStateInformation
// 0x0028 (0x0028 - 0x0000)
struct FExitDownStateInformation final
{
public:
	EExitDownStateReason                          ExitReason;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDNotificationAsset*                  CustomExitNotification;                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CustomExitMessageText;                             // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExitDownStateInformation) == 0x000008, "Wrong alignment on FExitDownStateInformation");
static_assert(sizeof(FExitDownStateInformation) == 0x000028, "Wrong size on FExitDownStateInformation");
static_assert(offsetof(FExitDownStateInformation, ExitReason) == 0x000000, "Member 'FExitDownStateInformation::ExitReason' has a wrong offset!");
static_assert(offsetof(FExitDownStateInformation, CustomExitNotification) == 0x000008, "Member 'FExitDownStateInformation::CustomExitNotification' has a wrong offset!");
static_assert(offsetof(FExitDownStateInformation, CustomExitMessageText) == 0x000010, "Member 'FExitDownStateInformation::CustomExitMessageText' has a wrong offset!");

// ScriptStruct OakGame.HealthTypeDepletedDetails
// 0x0018 (0x0018 - 0x0000)
struct FHealthTypeDepletedDetails final
{
public:
	class UHealthTypeData*                        HealthType;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHealthTypeDepletedDetails) == 0x000008, "Wrong alignment on FHealthTypeDepletedDetails");
static_assert(sizeof(FHealthTypeDepletedDetails) == 0x000018, "Wrong size on FHealthTypeDepletedDetails");
static_assert(offsetof(FHealthTypeDepletedDetails, HealthType) == 0x000000, "Member 'FHealthTypeDepletedDetails::HealthType' has a wrong offset!");
static_assert(offsetof(FHealthTypeDepletedDetails, DamageType) == 0x000008, "Member 'FHealthTypeDepletedDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FHealthTypeDepletedDetails, Index) == 0x000010, "Member 'FHealthTypeDepletedDetails::Index' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakAnim
// 0x0028 (0x0520 - 0x04F8)
struct FActionState_OakAnim : public FActionState_Anim
{
public:
	uint8                                         Pad_4F8[0x28];                                     // 0x04F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakAnim) == 0x000008, "Wrong alignment on FActionState_OakAnim");
static_assert(sizeof(FActionState_OakAnim) == 0x000520, "Wrong size on FActionState_OakAnim");

// ScriptStruct OakGame.ActionState_OakAnimActionAbility
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakAnimActionAbility : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakAnimActionAbility) == 0x000008, "Wrong alignment on FActionState_OakAnimActionAbility");
static_assert(sizeof(FActionState_OakAnimActionAbility) == 0x000520, "Wrong size on FActionState_OakAnimActionAbility");

// ScriptStruct OakGame.GFxFriendsInAreaListMenu_Adjustment
// 0x0010 (0x0010 - 0x0000)
struct FGFxFriendsInAreaListMenu_Adjustment final
{
public:
	struct FVector2D                              ContextMenuOffsetExpandingDown;                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContextMenuOffsetExpandingUp;                      // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxFriendsInAreaListMenu_Adjustment) == 0x000004, "Wrong alignment on FGFxFriendsInAreaListMenu_Adjustment");
static_assert(sizeof(FGFxFriendsInAreaListMenu_Adjustment) == 0x000010, "Wrong size on FGFxFriendsInAreaListMenu_Adjustment");
static_assert(offsetof(FGFxFriendsInAreaListMenu_Adjustment, ContextMenuOffsetExpandingDown) == 0x000000, "Member 'FGFxFriendsInAreaListMenu_Adjustment::ContextMenuOffsetExpandingDown' has a wrong offset!");
static_assert(offsetof(FGFxFriendsInAreaListMenu_Adjustment, ContextMenuOffsetExpandingUp) == 0x000008, "Member 'FGFxFriendsInAreaListMenu_Adjustment::ContextMenuOffsetExpandingUp' has a wrong offset!");

// ScriptStruct OakGame.LobbyPlayerStandInLoadOutInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FLobbyPlayerStandInLoadOutInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakCustomizationData*                  HeadCustomization;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakCustomizationData*                  BodyCustomization;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakCustomizationData*                  SkinCustomization;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakCustomizationData*                  EquippedEmote;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponSkinPartData*                    Weapon1Skin;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyPlayerStandInLoadOutInfo) == 0x000008, "Wrong alignment on FLobbyPlayerStandInLoadOutInfo");
static_assert(sizeof(FLobbyPlayerStandInLoadOutInfo) == 0x0000C8, "Wrong size on FLobbyPlayerStandInLoadOutInfo");
static_assert(offsetof(FLobbyPlayerStandInLoadOutInfo, HeadCustomization) == 0x000008, "Member 'FLobbyPlayerStandInLoadOutInfo::HeadCustomization' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerStandInLoadOutInfo, BodyCustomization) == 0x000010, "Member 'FLobbyPlayerStandInLoadOutInfo::BodyCustomization' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerStandInLoadOutInfo, SkinCustomization) == 0x000018, "Member 'FLobbyPlayerStandInLoadOutInfo::SkinCustomization' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerStandInLoadOutInfo, EquippedEmote) == 0x000020, "Member 'FLobbyPlayerStandInLoadOutInfo::EquippedEmote' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerStandInLoadOutInfo, Weapon1Skin) == 0x0000B0, "Member 'FLobbyPlayerStandInLoadOutInfo::Weapon1Skin' has a wrong offset!");

// ScriptStruct OakGame.IronBearHardPointData
// 0x0020 (0x0020 - 0x0000)
struct FIronBearHardPointData final
{
public:
	class UOakActionAbilityAugmentSlotData*       Slot;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakActionAbilityAugmentSlotData*       ModSlot;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSlotData*                        WeaponSlot;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIronBearHardPointOrientation                 Orientation;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIronBearHardPointData) == 0x000008, "Wrong alignment on FIronBearHardPointData");
static_assert(sizeof(FIronBearHardPointData) == 0x000020, "Wrong size on FIronBearHardPointData");
static_assert(offsetof(FIronBearHardPointData, Slot) == 0x000000, "Member 'FIronBearHardPointData::Slot' has a wrong offset!");
static_assert(offsetof(FIronBearHardPointData, ModSlot) == 0x000008, "Member 'FIronBearHardPointData::ModSlot' has a wrong offset!");
static_assert(offsetof(FIronBearHardPointData, WeaponSlot) == 0x000010, "Member 'FIronBearHardPointData::WeaponSlot' has a wrong offset!");
static_assert(offsetof(FIronBearHardPointData, Orientation) == 0x000018, "Member 'FIronBearHardPointData::Orientation' has a wrong offset!");

// ScriptStruct OakGame.WeaponSlotEntry
// 0x00F8 (0x00F8 - 0x0000)
struct FWeaponSlotEntry final
{
public:
	class UWeaponSlotData*                        SlotData;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeapon*                                AttachedWeapon;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeapon*                                PendingAttachedWeapon;                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeapon*                                ClientPredictedPendingAttachedWeapon;              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                RestoreSlotData;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0xB8];                                      // 0x0028(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameResourcePoolReference             AccuracyPool;                                      // 0x00E0(0x0018)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWeaponSlotEntry) == 0x000008, "Wrong alignment on FWeaponSlotEntry");
static_assert(sizeof(FWeaponSlotEntry) == 0x0000F8, "Wrong size on FWeaponSlotEntry");
static_assert(offsetof(FWeaponSlotEntry, SlotData) == 0x000000, "Member 'FWeaponSlotEntry::SlotData' has a wrong offset!");
static_assert(offsetof(FWeaponSlotEntry, AttachedWeapon) == 0x000008, "Member 'FWeaponSlotEntry::AttachedWeapon' has a wrong offset!");
static_assert(offsetof(FWeaponSlotEntry, PendingAttachedWeapon) == 0x000010, "Member 'FWeaponSlotEntry::PendingAttachedWeapon' has a wrong offset!");
static_assert(offsetof(FWeaponSlotEntry, ClientPredictedPendingAttachedWeapon) == 0x000018, "Member 'FWeaponSlotEntry::ClientPredictedPendingAttachedWeapon' has a wrong offset!");
static_assert(offsetof(FWeaponSlotEntry, RestoreSlotData) == 0x000020, "Member 'FWeaponSlotEntry::RestoreSlotData' has a wrong offset!");
static_assert(offsetof(FWeaponSlotEntry, AccuracyPool) == 0x0000E0, "Member 'FWeaponSlotEntry::AccuracyPool' has a wrong offset!");

// ScriptStruct OakGame.WeaponSlotContainer
// 0x05B8 (0x05B8 - 0x0000)
struct FWeaponSlotContainer final
{
public:
	TArray<struct FWeaponSlotEntry>               WeaponSlots;                                       // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x5A8];                                     // 0x0010(0x05A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponSlotContainer) == 0x000008, "Wrong alignment on FWeaponSlotContainer");
static_assert(sizeof(FWeaponSlotContainer) == 0x0005B8, "Wrong size on FWeaponSlotContainer");
static_assert(offsetof(FWeaponSlotContainer, WeaponSlots) == 0x000000, "Member 'FWeaponSlotContainer::WeaponSlots' has a wrong offset!");

// ScriptStruct OakGame.DiscoveredAreaInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDiscoveredAreaInfo final
{
public:
	class FName                                   DiscoveredAreaName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PlaythroughBits;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDiscoveredAreaInfo) == 0x000008, "Wrong alignment on FDiscoveredAreaInfo");
static_assert(sizeof(FDiscoveredAreaInfo) == 0x000010, "Wrong size on FDiscoveredAreaInfo");
static_assert(offsetof(FDiscoveredAreaInfo, DiscoveredAreaName) == 0x000000, "Member 'FDiscoveredAreaInfo::DiscoveredAreaName' has a wrong offset!");
static_assert(offsetof(FDiscoveredAreaInfo, PlaythroughBits) == 0x000008, "Member 'FDiscoveredAreaInfo::PlaythroughBits' has a wrong offset!");

// ScriptStruct OakGame.DiscoveredLevelInfo
// 0x0020 (0x0020 - 0x0000)
struct FDiscoveredLevelInfo final
{
public:
	class FName                                   DiscoveredLevelName;                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDiscoveredAreaInfo>            DiscoveredAreas;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        PlaythroughBits;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDiscoveredLevelInfo) == 0x000008, "Wrong alignment on FDiscoveredLevelInfo");
static_assert(sizeof(FDiscoveredLevelInfo) == 0x000020, "Wrong size on FDiscoveredLevelInfo");
static_assert(offsetof(FDiscoveredLevelInfo, DiscoveredLevelName) == 0x000000, "Member 'FDiscoveredLevelInfo::DiscoveredLevelName' has a wrong offset!");
static_assert(offsetof(FDiscoveredLevelInfo, DiscoveredAreas) == 0x000008, "Member 'FDiscoveredLevelInfo::DiscoveredAreas' has a wrong offset!");
static_assert(offsetof(FDiscoveredLevelInfo, PlaythroughBits) == 0x000018, "Member 'FDiscoveredLevelInfo::PlaythroughBits' has a wrong offset!");

// ScriptStruct OakGame.DiscoverySaveData
// 0x0010 (0x0010 - 0x0000)
struct FDiscoverySaveData final
{
public:
	TArray<struct FDiscoveredLevelInfo>           DiscoveredLevelInfo;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscoverySaveData) == 0x000008, "Wrong alignment on FDiscoverySaveData");
static_assert(sizeof(FDiscoverySaveData) == 0x000010, "Wrong size on FDiscoverySaveData");
static_assert(offsetof(FDiscoverySaveData, DiscoveredLevelInfo) == 0x000000, "Member 'FDiscoverySaveData::DiscoveredLevelInfo' has a wrong offset!");

// ScriptStruct OakGame.VendingMachineLastSelectionData
// 0x0010 (0x0010 - 0x0000)
struct FVendingMachineLastSelectionData final
{
public:
	class AActor*                                 InventoryActor;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendingMachineLastSelectionData) == 0x000008, "Wrong alignment on FVendingMachineLastSelectionData");
static_assert(sizeof(FVendingMachineLastSelectionData) == 0x000010, "Wrong size on FVendingMachineLastSelectionData");
static_assert(offsetof(FVendingMachineLastSelectionData, InventoryActor) == 0x000000, "Member 'FVendingMachineLastSelectionData::InventoryActor' has a wrong offset!");

// ScriptStruct OakGame.HUDInWorldIconTargetInfo
// 0x0058 (0x0058 - 0x0000)
struct FHUDInWorldIconTargetInfo final
{
public:
	class UInWorldIconData*                       IconData;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LocationComponent;                                 // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0020(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0030(0x0010)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHUDInWorldIconTargetInfo) == 0x000008, "Wrong alignment on FHUDInWorldIconTargetInfo");
static_assert(sizeof(FHUDInWorldIconTargetInfo) == 0x000058, "Wrong size on FHUDInWorldIconTargetInfo");
static_assert(offsetof(FHUDInWorldIconTargetInfo, IconData) == 0x000000, "Member 'FHUDInWorldIconTargetInfo::IconData' has a wrong offset!");
static_assert(offsetof(FHUDInWorldIconTargetInfo, Actor) == 0x000008, "Member 'FHUDInWorldIconTargetInfo::Actor' has a wrong offset!");
static_assert(offsetof(FHUDInWorldIconTargetInfo, LocationComponent) == 0x000010, "Member 'FHUDInWorldIconTargetInfo::LocationComponent' has a wrong offset!");
static_assert(offsetof(FHUDInWorldIconTargetInfo, SocketName) == 0x000018, "Member 'FHUDInWorldIconTargetInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FHUDInWorldIconTargetInfo, LocationOffset) == 0x000020, "Member 'FHUDInWorldIconTargetInfo::LocationOffset' has a wrong offset!");
static_assert(offsetof(FHUDInWorldIconTargetInfo, Radius) == 0x00002C, "Member 'FHUDInWorldIconTargetInfo::Radius' has a wrong offset!");
static_assert(offsetof(FHUDInWorldIconTargetInfo, Guid) == 0x000030, "Member 'FHUDInWorldIconTargetInfo::Guid' has a wrong offset!");

// ScriptStruct OakGame.VaultCardPreviousChallenge
// 0x0010 (0x0010 - 0x0000)
struct FVaultCardPreviousChallenge final
{
public:
	int32                                         PreviousChallengeSeed;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UChallenge>                 PreviousChallenge;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardPreviousChallenge) == 0x000008, "Wrong alignment on FVaultCardPreviousChallenge");
static_assert(sizeof(FVaultCardPreviousChallenge) == 0x000010, "Wrong size on FVaultCardPreviousChallenge");
static_assert(offsetof(FVaultCardPreviousChallenge, PreviousChallengeSeed) == 0x000000, "Member 'FVaultCardPreviousChallenge::PreviousChallengeSeed' has a wrong offset!");
static_assert(offsetof(FVaultCardPreviousChallenge, PreviousChallenge) == 0x000008, "Member 'FVaultCardPreviousChallenge::PreviousChallenge' has a wrong offset!");

// ScriptStruct OakGame.VaultCardCurrentChallengeLists
// 0x0048 (0x0048 - 0x0000)
struct FVaultCardCurrentChallengeLists final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UChallenge>>         Challenges;                                        // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UChallenge>>         CompletedChallenges;                               // 0x0018(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FVaultCardPreviousChallenge>    PreviouslyActiveDailyChallenges;                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVaultCardPreviousChallenge>    PreviouslyActiveWeeklyChallenges;                  // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardCurrentChallengeLists) == 0x000008, "Wrong alignment on FVaultCardCurrentChallengeLists");
static_assert(sizeof(FVaultCardCurrentChallengeLists) == 0x000048, "Wrong size on FVaultCardCurrentChallengeLists");
static_assert(offsetof(FVaultCardCurrentChallengeLists, Challenges) == 0x000008, "Member 'FVaultCardCurrentChallengeLists::Challenges' has a wrong offset!");
static_assert(offsetof(FVaultCardCurrentChallengeLists, CompletedChallenges) == 0x000018, "Member 'FVaultCardCurrentChallengeLists::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(FVaultCardCurrentChallengeLists, PreviouslyActiveDailyChallenges) == 0x000028, "Member 'FVaultCardCurrentChallengeLists::PreviouslyActiveDailyChallenges' has a wrong offset!");
static_assert(offsetof(FVaultCardCurrentChallengeLists, PreviouslyActiveWeeklyChallenges) == 0x000038, "Member 'FVaultCardCurrentChallengeLists::PreviouslyActiveWeeklyChallenges' has a wrong offset!");

// ScriptStruct OakGame.OakPresentationParamTransitionInstance
// 0x0028 (0x0028 - 0x0000)
struct FOakPresentationParamTransitionInstance final
{
public:
	class UOakStatusEffectPresentationData*       FXData;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ScreenComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPresentationParamTransitionInstance) == 0x000008, "Wrong alignment on FOakPresentationParamTransitionInstance");
static_assert(sizeof(FOakPresentationParamTransitionInstance) == 0x000028, "Wrong size on FOakPresentationParamTransitionInstance");
static_assert(offsetof(FOakPresentationParamTransitionInstance, FXData) == 0x000000, "Member 'FOakPresentationParamTransitionInstance::FXData' has a wrong offset!");
static_assert(offsetof(FOakPresentationParamTransitionInstance, ScreenComponent) == 0x000008, "Member 'FOakPresentationParamTransitionInstance::ScreenComponent' has a wrong offset!");

// ScriptStruct OakGame.SecondaryHealthDamageEventDetails
// 0x0038 (0x0038 - 0x0000)
struct FSecondaryHealthDamageEventDetails final
{
public:
	class UDamageSource*                          DamageSource;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  InstigatorPawn;                                    // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrit;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSecondaryHealthDamageEventDetails) == 0x000008, "Wrong alignment on FSecondaryHealthDamageEventDetails");
static_assert(sizeof(FSecondaryHealthDamageEventDetails) == 0x000038, "Wrong size on FSecondaryHealthDamageEventDetails");
static_assert(offsetof(FSecondaryHealthDamageEventDetails, DamageSource) == 0x000000, "Member 'FSecondaryHealthDamageEventDetails::DamageSource' has a wrong offset!");
static_assert(offsetof(FSecondaryHealthDamageEventDetails, DamageType) == 0x000008, "Member 'FSecondaryHealthDamageEventDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FSecondaryHealthDamageEventDetails, InstigatorPawn) == 0x000010, "Member 'FSecondaryHealthDamageEventDetails::InstigatorPawn' has a wrong offset!");
static_assert(offsetof(FSecondaryHealthDamageEventDetails, bWasCrit) == 0x000018, "Member 'FSecondaryHealthDamageEventDetails::bWasCrit' has a wrong offset!");
static_assert(offsetof(FSecondaryHealthDamageEventDetails, HitLocation) == 0x00001C, "Member 'FSecondaryHealthDamageEventDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FSecondaryHealthDamageEventDetails, HitDirection) == 0x000028, "Member 'FSecondaryHealthDamageEventDetails::HitDirection' has a wrong offset!");

// ScriptStruct OakGame.OakWeaponNameThresholdPairData
// 0x0010 (0x0010 - 0x0000)
struct FOakWeaponNameThresholdPairData final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryNamePartData*                 NamePart;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOakWeaponNameThresholdPairData) == 0x000008, "Wrong alignment on FOakWeaponNameThresholdPairData");
static_assert(sizeof(FOakWeaponNameThresholdPairData) == 0x000010, "Wrong size on FOakWeaponNameThresholdPairData");
static_assert(offsetof(FOakWeaponNameThresholdPairData, Threshold) == 0x000000, "Member 'FOakWeaponNameThresholdPairData::Threshold' has a wrong offset!");
static_assert(offsetof(FOakWeaponNameThresholdPairData, NamePart) == 0x000008, "Member 'FOakWeaponNameThresholdPairData::NamePart' has a wrong offset!");

// ScriptStruct OakGame.DamageBlockEventDetails
// 0x0010 (0x0010 - 0x0000)
struct FDamageBlockEventDetails final
{
public:
	class UGbxDamageType*                         DamageType;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageSource*                          DamageSource;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageBlockEventDetails) == 0x000008, "Wrong alignment on FDamageBlockEventDetails");
static_assert(sizeof(FDamageBlockEventDetails) == 0x000010, "Wrong size on FDamageBlockEventDetails");
static_assert(offsetof(FDamageBlockEventDetails, DamageType) == 0x000000, "Member 'FDamageBlockEventDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageBlockEventDetails, DamageSource) == 0x000008, "Member 'FDamageBlockEventDetails::DamageSource' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterTexturePair
// 0x0010 (0x0010 - 0x0000)
struct FOakCharacterTexturePair final
{
public:
	class UTexture*                               Comp;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Normal;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCharacterTexturePair) == 0x000008, "Wrong alignment on FOakCharacterTexturePair");
static_assert(sizeof(FOakCharacterTexturePair) == 0x000010, "Wrong size on FOakCharacterTexturePair");
static_assert(offsetof(FOakCharacterTexturePair, Comp) == 0x000000, "Member 'FOakCharacterTexturePair::Comp' has a wrong offset!");
static_assert(offsetof(FOakCharacterTexturePair, Normal) == 0x000008, "Member 'FOakCharacterTexturePair::Normal' has a wrong offset!");

// ScriptStruct OakGame.MapIDData
// 0x0002 (0x0002 - 0x0000)
struct FMapIDData final
{
public:
	uint8                                         ZoneNameID;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MapNameID;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapIDData) == 0x000001, "Wrong alignment on FMapIDData");
static_assert(sizeof(FMapIDData) == 0x000002, "Wrong size on FMapIDData");
static_assert(offsetof(FMapIDData, ZoneNameID) == 0x000000, "Member 'FMapIDData::ZoneNameID' has a wrong offset!");
static_assert(offsetof(FMapIDData, MapNameID) == 0x000001, "Member 'FMapIDData::MapNameID' has a wrong offset!");

// ScriptStruct OakGame.MayhemModifier
// 0x0030 (0x0030 - 0x0000)
struct FMayhemModifier final
{
public:
	TSoftClassPtr<class UClass>                   ModifierAbility;                                   // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAbilityEffectTargetResolutionData*  ModifierTarget;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemModifier) == 0x000008, "Wrong alignment on FMayhemModifier");
static_assert(sizeof(FMayhemModifier) == 0x000030, "Wrong size on FMayhemModifier");
static_assert(offsetof(FMayhemModifier, ModifierAbility) == 0x000000, "Member 'FMayhemModifier::ModifierAbility' has a wrong offset!");
static_assert(offsetof(FMayhemModifier, ModifierTarget) == 0x000028, "Member 'FMayhemModifier::ModifierTarget' has a wrong offset!");

// ScriptStruct OakGame.MayhemModifierSet
// 0x0038 (0x0038 - 0x0000)
struct FMayhemModifierSet final
{
public:
	TArray<struct FMayhemModifier>                Modifiers;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MutualExclusionTags;                               // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UUIStatData*>                    UIStats;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemModifierSet) == 0x000008, "Wrong alignment on FMayhemModifierSet");
static_assert(sizeof(FMayhemModifierSet) == 0x000038, "Wrong size on FMayhemModifierSet");
static_assert(offsetof(FMayhemModifierSet, Modifiers) == 0x000000, "Member 'FMayhemModifierSet::Modifiers' has a wrong offset!");
static_assert(offsetof(FMayhemModifierSet, Weight) == 0x000010, "Member 'FMayhemModifierSet::Weight' has a wrong offset!");
static_assert(offsetof(FMayhemModifierSet, MutualExclusionTags) == 0x000018, "Member 'FMayhemModifierSet::MutualExclusionTags' has a wrong offset!");
static_assert(offsetof(FMayhemModifierSet, UIStats) == 0x000028, "Member 'FMayhemModifierSet::UIStats' has a wrong offset!");

// ScriptStruct OakGame.PendingMayhemState
// 0x0010 (0x0010 - 0x0000)
struct FPendingMayhemState final
{
public:
	TArray<struct FMayhemModifierSet>             ModifierSets;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPendingMayhemState) == 0x000008, "Wrong alignment on FPendingMayhemState");
static_assert(sizeof(FPendingMayhemState) == 0x000010, "Wrong size on FPendingMayhemState");
static_assert(offsetof(FPendingMayhemState, ModifierSets) == 0x000000, "Member 'FPendingMayhemState::ModifierSets' has a wrong offset!");

// ScriptStruct OakGame.DamageDataCustomStatusEffectApplicationSpec
// 0x0050 (0x0050 - 0x0000)
struct FDamageDataCustomStatusEffectApplicationSpec final
{
public:
	class UStatusEffectData*                      StatusEffect;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToEnemiesOnly;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           EffectDuration;                                    // 0x0018(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageDataCustomStatusEffectApplicationSpec) == 0x000008, "Wrong alignment on FDamageDataCustomStatusEffectApplicationSpec");
static_assert(sizeof(FDamageDataCustomStatusEffectApplicationSpec) == 0x000050, "Wrong size on FDamageDataCustomStatusEffectApplicationSpec");
static_assert(offsetof(FDamageDataCustomStatusEffectApplicationSpec, StatusEffect) == 0x000000, "Member 'FDamageDataCustomStatusEffectApplicationSpec::StatusEffect' has a wrong offset!");
static_assert(offsetof(FDamageDataCustomStatusEffectApplicationSpec, Condition) == 0x000008, "Member 'FDamageDataCustomStatusEffectApplicationSpec::Condition' has a wrong offset!");
static_assert(offsetof(FDamageDataCustomStatusEffectApplicationSpec, bApplyToEnemiesOnly) == 0x000010, "Member 'FDamageDataCustomStatusEffectApplicationSpec::bApplyToEnemiesOnly' has a wrong offset!");
static_assert(offsetof(FDamageDataCustomStatusEffectApplicationSpec, EffectDuration) == 0x000018, "Member 'FDamageDataCustomStatusEffectApplicationSpec::EffectDuration' has a wrong offset!");

// ScriptStruct OakGame.GearSoldByFriendData
// 0x0040 (0x0040 - 0x0000)
struct FGearSoldByFriendData final
{
public:
	class FString                                 GearSerialNumber;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerClassIdentifierHash;                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       FriendNetId;                                       // 0x0018(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGearSoldByFriendData) == 0x000008, "Wrong alignment on FGearSoldByFriendData");
static_assert(sizeof(FGearSoldByFriendData) == 0x000040, "Wrong size on FGearSoldByFriendData");
static_assert(offsetof(FGearSoldByFriendData, GearSerialNumber) == 0x000000, "Member 'FGearSoldByFriendData::GearSerialNumber' has a wrong offset!");
static_assert(offsetof(FGearSoldByFriendData, PlayerClassIdentifierHash) == 0x000010, "Member 'FGearSoldByFriendData::PlayerClassIdentifierHash' has a wrong offset!");
static_assert(offsetof(FGearSoldByFriendData, FriendNetId) == 0x000018, "Member 'FGearSoldByFriendData::FriendNetId' has a wrong offset!");

// ScriptStruct OakGame.OakModifierSet
// 0x0050 (0x0050 - 0x0000)
struct FOakModifierSet final
{
public:
	bool                                          bDisplay;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ModifierName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DisplayDesc;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowHandle>            Modifiers;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakModifierSet) == 0x000008, "Wrong alignment on FOakModifierSet");
static_assert(sizeof(FOakModifierSet) == 0x000050, "Wrong size on FOakModifierSet");
static_assert(offsetof(FOakModifierSet, bDisplay) == 0x000000, "Member 'FOakModifierSet::bDisplay' has a wrong offset!");
static_assert(offsetof(FOakModifierSet, ModifierName) == 0x000008, "Member 'FOakModifierSet::ModifierName' has a wrong offset!");
static_assert(offsetof(FOakModifierSet, DisplayName) == 0x000010, "Member 'FOakModifierSet::DisplayName' has a wrong offset!");
static_assert(offsetof(FOakModifierSet, DisplayDesc) == 0x000028, "Member 'FOakModifierSet::DisplayDesc' has a wrong offset!");
static_assert(offsetof(FOakModifierSet, Modifiers) == 0x000040, "Member 'FOakModifierSet::Modifiers' has a wrong offset!");

// ScriptStruct OakGame.OakElementalGibData
// 0x0160 (0x0160 - 0x0000)
struct FOakElementalGibData final
{
public:
	uint8                                         bOverrideDefaultEffects : 1;                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDefaultParticleSystem : 1;                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDefaultSound : 1;                         // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDefaultDecal : 1;                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpactResponseEffect                  Effect;                                            // 0x0010(0x0140)(Edit, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0150(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            Sound;                                             // 0x0158(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakElementalGibData) == 0x000010, "Wrong alignment on FOakElementalGibData");
static_assert(sizeof(FOakElementalGibData) == 0x000160, "Wrong size on FOakElementalGibData");
static_assert(offsetof(FOakElementalGibData, Effect) == 0x000010, "Member 'FOakElementalGibData::Effect' has a wrong offset!");
static_assert(offsetof(FOakElementalGibData, Particle) == 0x000150, "Member 'FOakElementalGibData::Particle' has a wrong offset!");
static_assert(offsetof(FOakElementalGibData, Sound) == 0x000158, "Member 'FOakElementalGibData::Sound' has a wrong offset!");

// ScriptStruct OakGame.HolsteredWeaponData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FHolsteredWeaponData final
{
public:
	EWeaponHolsteredSizeType                      WeaponSizeType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPickupLootAttachmentMode                     AttachMode;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleInFirstPerson;                             // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHolsteredWeaponData) == 0x000008, "Wrong alignment on FHolsteredWeaponData");
static_assert(sizeof(FHolsteredWeaponData) == 0x000018, "Wrong size on FHolsteredWeaponData");
static_assert(offsetof(FHolsteredWeaponData, WeaponSizeType) == 0x000000, "Member 'FHolsteredWeaponData::WeaponSizeType' has a wrong offset!");
static_assert(offsetof(FHolsteredWeaponData, AttachMode) == 0x000001, "Member 'FHolsteredWeaponData::AttachMode' has a wrong offset!");
static_assert(offsetof(FHolsteredWeaponData, SocketName) == 0x000008, "Member 'FHolsteredWeaponData::SocketName' has a wrong offset!");
static_assert(offsetof(FHolsteredWeaponData, bVisibleInFirstPerson) == 0x000010, "Member 'FHolsteredWeaponData::bVisibleInFirstPerson' has a wrong offset!");

// ScriptStruct OakGame.NameplateBarData
// 0x0028 (0x0028 - 0x0000)
struct FNameplateBarData final
{
public:
	class UGbxGFxProgressBar*                     NameplateBar;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          NameplateBarContainer;                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class INameplateInfoProviderInterface> TargetActorOverride;                               // 0x0010(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNameplateBarData) == 0x000008, "Wrong alignment on FNameplateBarData");
static_assert(sizeof(FNameplateBarData) == 0x000028, "Wrong size on FNameplateBarData");
static_assert(offsetof(FNameplateBarData, NameplateBar) == 0x000000, "Member 'FNameplateBarData::NameplateBar' has a wrong offset!");
static_assert(offsetof(FNameplateBarData, NameplateBarContainer) == 0x000008, "Member 'FNameplateBarData::NameplateBarContainer' has a wrong offset!");
static_assert(offsetof(FNameplateBarData, TargetActorOverride) == 0x000010, "Member 'FNameplateBarData::TargetActorOverride' has a wrong offset!");

// ScriptStruct OakGame.CARSkinMaterials
// 0x0068 (0x0068 - 0x0000)
struct FCARSkinMaterials final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      Materials;                                         // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Color1Params;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Color2Params;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Color3Params;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARSkinMaterials) == 0x000008, "Wrong alignment on FCARSkinMaterials");
static_assert(sizeof(FCARSkinMaterials) == 0x000068, "Wrong size on FCARSkinMaterials");
static_assert(offsetof(FCARSkinMaterials, Materials) == 0x000000, "Member 'FCARSkinMaterials::Materials' has a wrong offset!");
static_assert(offsetof(FCARSkinMaterials, ComponentName) == 0x000028, "Member 'FCARSkinMaterials::ComponentName' has a wrong offset!");
static_assert(offsetof(FCARSkinMaterials, SectionIndex) == 0x000030, "Member 'FCARSkinMaterials::SectionIndex' has a wrong offset!");
static_assert(offsetof(FCARSkinMaterials, Color1Params) == 0x000038, "Member 'FCARSkinMaterials::Color1Params' has a wrong offset!");
static_assert(offsetof(FCARSkinMaterials, Color2Params) == 0x000048, "Member 'FCARSkinMaterials::Color2Params' has a wrong offset!");
static_assert(offsetof(FCARSkinMaterials, Color3Params) == 0x000058, "Member 'FCARSkinMaterials::Color3Params' has a wrong offset!");

// ScriptStruct OakGame.CARPreviewMeshOffsetByPart
// 0x0010 (0x0010 - 0x0000)
struct FCARPreviewMeshOffsetByPart final
{
public:
	ECARPartType                                  Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCARPreviewMeshOffsetByPart) == 0x000004, "Wrong alignment on FCARPreviewMeshOffsetByPart");
static_assert(sizeof(FCARPreviewMeshOffsetByPart) == 0x000010, "Wrong size on FCARPreviewMeshOffsetByPart");
static_assert(offsetof(FCARPreviewMeshOffsetByPart, Type) == 0x000000, "Member 'FCARPreviewMeshOffsetByPart::Type' has a wrong offset!");
static_assert(offsetof(FCARPreviewMeshOffsetByPart, Offset) == 0x000004, "Member 'FCARPreviewMeshOffsetByPart::Offset' has a wrong offset!");

// ScriptStruct OakGame.CARPreviewMesh
// 0x00F0 (0x00F0 - 0x0000)
struct FCARPreviewMesh final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkinMesh;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCARSkinMaterials>              Skin;                                              // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECARPartType                                  ParentPart;                                        // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentSocket;                                      // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCARPreviewMeshOffsetByPart>    OffsetToOtherParts;                                // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARPreviewMesh) == 0x000010, "Wrong alignment on FCARPreviewMesh");
static_assert(sizeof(FCARPreviewMesh) == 0x0000F0, "Wrong size on FCARPreviewMesh");
static_assert(offsetof(FCARPreviewMesh, ComponentName) == 0x000000, "Member 'FCARPreviewMesh::ComponentName' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, Offset) == 0x000010, "Member 'FCARPreviewMesh::Offset' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, SkinMesh) == 0x000040, "Member 'FCARPreviewMesh::SkinMesh' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, AnimInstanceClass) == 0x000068, "Member 'FCARPreviewMesh::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, StaticMesh) == 0x000090, "Member 'FCARPreviewMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, Skin) == 0x0000B8, "Member 'FCARPreviewMesh::Skin' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, ParentPart) == 0x0000C8, "Member 'FCARPreviewMesh::ParentPart' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, ParentSocket) == 0x0000D0, "Member 'FCARPreviewMesh::ParentSocket' has a wrong offset!");
static_assert(offsetof(FCARPreviewMesh, OffsetToOtherParts) == 0x0000D8, "Member 'FCARPreviewMesh::OffsetToOtherParts' has a wrong offset!");

// ScriptStruct OakGame.BossbarEventData
// 0x0010 (0x0010 - 0x0000)
struct FBossbarEventData final
{
public:
	EBossbarEventType                             Type;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakCharacter*                          Boss;                                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBossbarEventData) == 0x000008, "Wrong alignment on FBossbarEventData");
static_assert(sizeof(FBossbarEventData) == 0x000010, "Wrong size on FBossbarEventData");
static_assert(offsetof(FBossbarEventData, Type) == 0x000000, "Member 'FBossbarEventData::Type' has a wrong offset!");
static_assert(offsetof(FBossbarEventData, Boss) == 0x000008, "Member 'FBossbarEventData::Boss' has a wrong offset!");

// ScriptStruct OakGame.OakWeaponNamedNamingAttribute
// 0x0020 (0x0020 - 0x0000)
struct FOakWeaponNamedNamingAttribute final
{
public:
	class FName                                   AttributeName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFormula;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAttributeData*                      Attribute;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStatFormulaEvaluator*                Formula;                                           // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakWeaponNamedNamingAttribute) == 0x000008, "Wrong alignment on FOakWeaponNamedNamingAttribute");
static_assert(sizeof(FOakWeaponNamedNamingAttribute) == 0x000020, "Wrong size on FOakWeaponNamedNamingAttribute");
static_assert(offsetof(FOakWeaponNamedNamingAttribute, AttributeName) == 0x000000, "Member 'FOakWeaponNamedNamingAttribute::AttributeName' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamedNamingAttribute, bUseFormula) == 0x000008, "Member 'FOakWeaponNamedNamingAttribute::bUseFormula' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamedNamingAttribute, Attribute) == 0x000010, "Member 'FOakWeaponNamedNamingAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamedNamingAttribute, Formula) == 0x000018, "Member 'FOakWeaponNamedNamingAttribute::Formula' has a wrong offset!");

// ScriptStruct OakGame.GlobalScreenParticleData
// 0x0028 (0x0028 - 0x0000)
struct FGlobalScreenParticleData final
{
public:
	class UParticleSystem*                        StartAndLoopParticle;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EndParticle;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContentDims;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlobalScreenParticleData) == 0x000008, "Wrong alignment on FGlobalScreenParticleData");
static_assert(sizeof(FGlobalScreenParticleData) == 0x000028, "Wrong size on FGlobalScreenParticleData");
static_assert(offsetof(FGlobalScreenParticleData, StartAndLoopParticle) == 0x000000, "Member 'FGlobalScreenParticleData::StartAndLoopParticle' has a wrong offset!");
static_assert(offsetof(FGlobalScreenParticleData, EndParticle) == 0x000008, "Member 'FGlobalScreenParticleData::EndParticle' has a wrong offset!");
static_assert(offsetof(FGlobalScreenParticleData, ContentDims) == 0x000010, "Member 'FGlobalScreenParticleData::ContentDims' has a wrong offset!");
static_assert(offsetof(FGlobalScreenParticleData, ParticleDepth) == 0x000018, "Member 'FGlobalScreenParticleData::ParticleDepth' has a wrong offset!");
static_assert(offsetof(FGlobalScreenParticleData, Tag) == 0x000020, "Member 'FGlobalScreenParticleData::Tag' has a wrong offset!");

// ScriptStruct OakGame.EffectivePlayerCountData
// 0x0008 (0x0008 - 0x0000)
struct FEffectivePlayerCountData final
{
public:
	int32                                         EffectiveNumPlayers;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEffectivePlayerCountSetting                  Setting;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectivePlayerCountData) == 0x000004, "Wrong alignment on FEffectivePlayerCountData");
static_assert(sizeof(FEffectivePlayerCountData) == 0x000008, "Wrong size on FEffectivePlayerCountData");
static_assert(offsetof(FEffectivePlayerCountData, EffectiveNumPlayers) == 0x000000, "Member 'FEffectivePlayerCountData::EffectiveNumPlayers' has a wrong offset!");
static_assert(offsetof(FEffectivePlayerCountData, Setting) == 0x000004, "Member 'FEffectivePlayerCountData::Setting' has a wrong offset!");

// ScriptStruct OakGame.SectorDistance
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSectorDistance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSectorDistance) == 0x000004, "Wrong alignment on FSectorDistance");
static_assert(sizeof(FSectorDistance) == 0x000008, "Wrong size on FSectorDistance");

// ScriptStruct OakGame.MatchmakingRequirement
// 0x0030 (0x0030 - 0x0000)
struct FMatchmakingRequirement final
{
public:
	EMatchmakingRequirementType                   Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchmakingRequirementComparisonOp           ComparisonOp;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescriptionKey;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchmakingRequirement) == 0x000008, "Wrong alignment on FMatchmakingRequirement");
static_assert(sizeof(FMatchmakingRequirement) == 0x000030, "Wrong size on FMatchmakingRequirement");
static_assert(offsetof(FMatchmakingRequirement, Type) == 0x000000, "Member 'FMatchmakingRequirement::Type' has a wrong offset!");
static_assert(offsetof(FMatchmakingRequirement, ComparisonOp) == 0x000001, "Member 'FMatchmakingRequirement::ComparisonOp' has a wrong offset!");
static_assert(offsetof(FMatchmakingRequirement, Value) == 0x000004, "Member 'FMatchmakingRequirement::Value' has a wrong offset!");
static_assert(offsetof(FMatchmakingRequirement, DescriptionKey) == 0x000008, "Member 'FMatchmakingRequirement::DescriptionKey' has a wrong offset!");

// ScriptStruct OakGame.ColorRandomizer
// 0x0010 (0x0010 - 0x0000)
struct FColorRandomizer final
{
public:
	float                                         Hue;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Saturation;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNumericRange                          Scale;                                             // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FColorRandomizer) == 0x000004, "Wrong alignment on FColorRandomizer");
static_assert(sizeof(FColorRandomizer) == 0x000010, "Wrong size on FColorRandomizer");
static_assert(offsetof(FColorRandomizer, Hue) == 0x000000, "Member 'FColorRandomizer::Hue' has a wrong offset!");
static_assert(offsetof(FColorRandomizer, Saturation) == 0x000004, "Member 'FColorRandomizer::Saturation' has a wrong offset!");
static_assert(offsetof(FColorRandomizer, Scale) == 0x000008, "Member 'FColorRandomizer::Scale' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterCustomization
// 0x0014 (0x0014 - 0x0000)
struct FOakCharacterCustomization
{
public:
	bool                                          bRandomizeColor;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColorRandomizer                       ColorRandomizer;                                   // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCharacterCustomization) == 0x000004, "Wrong alignment on FOakCharacterCustomization");
static_assert(sizeof(FOakCharacterCustomization) == 0x000014, "Wrong size on FOakCharacterCustomization");
static_assert(offsetof(FOakCharacterCustomization, bRandomizeColor) == 0x000000, "Member 'FOakCharacterCustomization::bRandomizeColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomization, ColorRandomizer) == 0x000004, "Member 'FOakCharacterCustomization::ColorRandomizer' has a wrong offset!");

// ScriptStruct OakGame.LevelledSaveGameData
// 0x00C0 (0x00C0 - 0x0000)
struct FLevelledSaveGameData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTravelStationData>      InitialTravelStation;                              // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActiveMissionClass;                                // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMissionObjectiveSet>    ActiveMissionObjectiveSet;                         // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CompleteActiveMission;                             // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CreditsAmount;                                     // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        EridiumAmount;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UItemPoolData>>   DefaultInventory;                                  // 0x0090(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint32                                        RandomRolls;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UItemPoolData>>   RandomInventory;                                   // 0x00A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          FixupEndGameData;                                  // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelledSaveGameData) == 0x000008, "Wrong alignment on FLevelledSaveGameData");
static_assert(sizeof(FLevelledSaveGameData) == 0x0000C0, "Wrong size on FLevelledSaveGameData");
static_assert(offsetof(FLevelledSaveGameData, Level) == 0x000000, "Member 'FLevelledSaveGameData::Level' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, InitialTravelStation) == 0x000008, "Member 'FLevelledSaveGameData::InitialTravelStation' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, ActiveMissionClass) == 0x000030, "Member 'FLevelledSaveGameData::ActiveMissionClass' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, ActiveMissionObjectiveSet) == 0x000058, "Member 'FLevelledSaveGameData::ActiveMissionObjectiveSet' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, CompleteActiveMission) == 0x000080, "Member 'FLevelledSaveGameData::CompleteActiveMission' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, CreditsAmount) == 0x000084, "Member 'FLevelledSaveGameData::CreditsAmount' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, EridiumAmount) == 0x000088, "Member 'FLevelledSaveGameData::EridiumAmount' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, DefaultInventory) == 0x000090, "Member 'FLevelledSaveGameData::DefaultInventory' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, RandomRolls) == 0x0000A0, "Member 'FLevelledSaveGameData::RandomRolls' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, RandomInventory) == 0x0000A8, "Member 'FLevelledSaveGameData::RandomInventory' has a wrong offset!");
static_assert(offsetof(FLevelledSaveGameData, FixupEndGameData) == 0x0000B8, "Member 'FLevelledSaveGameData::FixupEndGameData' has a wrong offset!");

// ScriptStruct OakGame.VaultCardRewardInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FVaultCardRewardInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultCardRewardInfo) == 0x000004, "Wrong alignment on FVaultCardRewardInfo");
static_assert(sizeof(FVaultCardRewardInfo) == 0x000008, "Wrong size on FVaultCardRewardInfo");

// ScriptStruct OakGame.VendingMachineSocketLocationAndOffset
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FVendingMachineSocketLocationAndOffset final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0018(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OffsetSplitScreen;                                 // 0x0020(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingMachineSocketLocationAndOffset) == 0x000008, "Wrong alignment on FVendingMachineSocketLocationAndOffset");
static_assert(sizeof(FVendingMachineSocketLocationAndOffset) == 0x000028, "Wrong size on FVendingMachineSocketLocationAndOffset");
static_assert(offsetof(FVendingMachineSocketLocationAndOffset, Location) == 0x000000, "Member 'FVendingMachineSocketLocationAndOffset::Location' has a wrong offset!");
static_assert(offsetof(FVendingMachineSocketLocationAndOffset, SocketName) == 0x000010, "Member 'FVendingMachineSocketLocationAndOffset::SocketName' has a wrong offset!");
static_assert(offsetof(FVendingMachineSocketLocationAndOffset, Offset) == 0x000018, "Member 'FVendingMachineSocketLocationAndOffset::Offset' has a wrong offset!");
static_assert(offsetof(FVendingMachineSocketLocationAndOffset, OffsetSplitScreen) == 0x000020, "Member 'FVendingMachineSocketLocationAndOffset::OffsetSplitScreen' has a wrong offset!");

// ScriptStruct OakGame.OakResourceEffectData
// 0x0040 (0x0040 - 0x0000)
struct FOakResourceEffectData final
{
public:
	EOakStatusEffectResourceEffectType            ResourceEffectType;                                // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameResourcePoolData*                  ResourcePool;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      PostDepleteImmuneTime;                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageTypeClass;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      DamageModifier;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      DamagedActorModifier;                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPercentBaseDamage;                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakStatusEffectPresentationData*       FXData;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakResourceEffectData) == 0x000008, "Wrong alignment on FOakResourceEffectData");
static_assert(sizeof(FOakResourceEffectData) == 0x000040, "Wrong size on FOakResourceEffectData");
static_assert(offsetof(FOakResourceEffectData, ResourceEffectType) == 0x000000, "Member 'FOakResourceEffectData::ResourceEffectType' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, ResourcePool) == 0x000008, "Member 'FOakResourceEffectData::ResourcePool' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, PostDepleteImmuneTime) == 0x000010, "Member 'FOakResourceEffectData::PostDepleteImmuneTime' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, DamageTypeClass) == 0x000018, "Member 'FOakResourceEffectData::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, DamageModifier) == 0x000020, "Member 'FOakResourceEffectData::DamageModifier' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, DamagedActorModifier) == 0x000028, "Member 'FOakResourceEffectData::DamagedActorModifier' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, DefaultPercentBaseDamage) == 0x000030, "Member 'FOakResourceEffectData::DefaultPercentBaseDamage' has a wrong offset!");
static_assert(offsetof(FOakResourceEffectData, FXData) == 0x000038, "Member 'FOakResourceEffectData::FXData' has a wrong offset!");

// ScriptStruct OakGame.ActiveOakResourceEffect
// 0x00F0 (0x00F0 - 0x0000)
struct FActiveOakResourceEffect final
{
public:
	struct FOakResourceEffectData                 ResourceEffectData;                                // 0x0000(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGameResourcePoolReference             ResourcePoolReference;                             // 0x0040(0x0018)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FResourceLock                          ResourceLock;                                      // 0x0058(0x0098)(RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveOakResourceEffect) == 0x000008, "Wrong alignment on FActiveOakResourceEffect");
static_assert(sizeof(FActiveOakResourceEffect) == 0x0000F0, "Wrong size on FActiveOakResourceEffect");
static_assert(offsetof(FActiveOakResourceEffect, ResourceEffectData) == 0x000000, "Member 'FActiveOakResourceEffect::ResourceEffectData' has a wrong offset!");
static_assert(offsetof(FActiveOakResourceEffect, ResourcePoolReference) == 0x000040, "Member 'FActiveOakResourceEffect::ResourcePoolReference' has a wrong offset!");
static_assert(offsetof(FActiveOakResourceEffect, ResourceLock) == 0x000058, "Member 'FActiveOakResourceEffect::ResourceLock' has a wrong offset!");

// ScriptStruct OakGame.OakUIInventoryItemDisplayInfo
// 0x0110 (0x0110 - 0x0000)
struct FOakUIInventoryItemDisplayInfo final
{
public:
	class FText                                   ItemName;                                          // 0x0000(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	int32                                         ItemLevel;                                         // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemDescription;                                   // 0x0020(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   ManufacturerName;                                  // 0x0038(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	int32                                         ItemScore;                                         // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNew;                                              // 0x0054(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavorite;                                         // 0x0055(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrash;                                            // 0x0056(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEquip;                                         // 0x0057(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCellLocked;                                       // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCellUnavailable;                                  // 0x005A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 ReferenceObject;                                   // 0x005C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture>                ReferencePicture;                                  // 0x0068(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickupOrderIndex;                                  // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryListEntry                    ListEntry;                                         // 0x0098(0x0040)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FInventoryListEntryHandle              ItemHandle;                                        // 0x00D8(0x0004)(BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ItemActor;                                         // 0x00DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UInventoryRarityData>    RarityData;                                        // 0x00E4(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UManufacturerData>       ManufacturerData;                                  // 0x00EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxDamageType>          DamageType;                                        // 0x00F4(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpecialSortName;                                   // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakUIInventoryItemUseType                    UseType;                                           // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCosmeticLabel;                                 // 0x010C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakUIInventoryItemDisplayInfo) == 0x000008, "Wrong alignment on FOakUIInventoryItemDisplayInfo");
static_assert(sizeof(FOakUIInventoryItemDisplayInfo) == 0x000110, "Wrong size on FOakUIInventoryItemDisplayInfo");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ItemName) == 0x000000, "Member 'FOakUIInventoryItemDisplayInfo::ItemName' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ItemLevel) == 0x000018, "Member 'FOakUIInventoryItemDisplayInfo::ItemLevel' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ItemDescription) == 0x000020, "Member 'FOakUIInventoryItemDisplayInfo::ItemDescription' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ManufacturerName) == 0x000038, "Member 'FOakUIInventoryItemDisplayInfo::ManufacturerName' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ItemScore) == 0x000050, "Member 'FOakUIInventoryItemDisplayInfo::ItemScore' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bNew) == 0x000054, "Member 'FOakUIInventoryItemDisplayInfo::bNew' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bFavorite) == 0x000055, "Member 'FOakUIInventoryItemDisplayInfo::bFavorite' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bTrash) == 0x000056, "Member 'FOakUIInventoryItemDisplayInfo::bTrash' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bCanEquip) == 0x000057, "Member 'FOakUIInventoryItemDisplayInfo::bCanEquip' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bIsEquipped) == 0x000058, "Member 'FOakUIInventoryItemDisplayInfo::bIsEquipped' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bCellLocked) == 0x000059, "Member 'FOakUIInventoryItemDisplayInfo::bCellLocked' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bCellUnavailable) == 0x00005A, "Member 'FOakUIInventoryItemDisplayInfo::bCellUnavailable' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ReferenceObject) == 0x00005C, "Member 'FOakUIInventoryItemDisplayInfo::ReferenceObject' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ReferencePicture) == 0x000068, "Member 'FOakUIInventoryItemDisplayInfo::ReferencePicture' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, PickupOrderIndex) == 0x000090, "Member 'FOakUIInventoryItemDisplayInfo::PickupOrderIndex' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ListEntry) == 0x000098, "Member 'FOakUIInventoryItemDisplayInfo::ListEntry' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ItemHandle) == 0x0000D8, "Member 'FOakUIInventoryItemDisplayInfo::ItemHandle' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ItemActor) == 0x0000DC, "Member 'FOakUIInventoryItemDisplayInfo::ItemActor' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, RarityData) == 0x0000E4, "Member 'FOakUIInventoryItemDisplayInfo::RarityData' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, ManufacturerData) == 0x0000EC, "Member 'FOakUIInventoryItemDisplayInfo::ManufacturerData' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, DamageType) == 0x0000F4, "Member 'FOakUIInventoryItemDisplayInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, SpecialSortName) == 0x000100, "Member 'FOakUIInventoryItemDisplayInfo::SpecialSortName' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, UseType) == 0x000108, "Member 'FOakUIInventoryItemDisplayInfo::UseType' has a wrong offset!");
static_assert(offsetof(FOakUIInventoryItemDisplayInfo, bUseCosmeticLabel) == 0x00010C, "Member 'FOakUIInventoryItemDisplayInfo::bUseCosmeticLabel' has a wrong offset!");

// ScriptStruct OakGame.GFxPlayerStorageBag
// 0x00D0 (0x00D0 - 0x0000)
struct FGFxPlayerStorageBag final
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakUIInventoryItemDisplayInfo> Items;                                             // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxPlayerStorageBag) == 0x000008, "Wrong alignment on FGFxPlayerStorageBag");
static_assert(sizeof(FGFxPlayerStorageBag) == 0x0000D0, "Wrong size on FGFxPlayerStorageBag");
static_assert(offsetof(FGFxPlayerStorageBag, Items) == 0x0000B8, "Member 'FGFxPlayerStorageBag::Items' has a wrong offset!");

// ScriptStruct OakGame.ProcessedReward
// 0x0020 (0x0020 - 0x0000)
struct FProcessedReward final
{
public:
	int32                                         Currency;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 CurrencyType;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnedInventoryItems;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProcessedReward) == 0x000008, "Wrong alignment on FProcessedReward");
static_assert(sizeof(FProcessedReward) == 0x000020, "Wrong size on FProcessedReward");
static_assert(offsetof(FProcessedReward, Currency) == 0x000000, "Member 'FProcessedReward::Currency' has a wrong offset!");
static_assert(offsetof(FProcessedReward, Experience) == 0x000004, "Member 'FProcessedReward::Experience' has a wrong offset!");
static_assert(offsetof(FProcessedReward, CurrencyType) == 0x000008, "Member 'FProcessedReward::CurrencyType' has a wrong offset!");
static_assert(offsetof(FProcessedReward, SpawnedInventoryItems) == 0x000010, "Member 'FProcessedReward::SpawnedInventoryItems' has a wrong offset!");

// ScriptStruct OakGame.GFxVaultHunterProfileCardPlayerConfig
// 0x0078 (0x0078 - 0x0000)
struct FGFxVaultHunterProfileCardPlayerConfig final
{
public:
	class UTexture*                               ProfilePicture;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PlayerName;                                        // 0x0008(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   MissionName;                                       // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPlayerClassIdentifier>  PlayerClass;                                       // 0x0038(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSelectedCharacter;                             // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x17];                                      // 0x0061(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxVaultHunterProfileCardPlayerConfig) == 0x000008, "Wrong alignment on FGFxVaultHunterProfileCardPlayerConfig");
static_assert(sizeof(FGFxVaultHunterProfileCardPlayerConfig) == 0x000078, "Wrong size on FGFxVaultHunterProfileCardPlayerConfig");
static_assert(offsetof(FGFxVaultHunterProfileCardPlayerConfig, ProfilePicture) == 0x000000, "Member 'FGFxVaultHunterProfileCardPlayerConfig::ProfilePicture' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardPlayerConfig, PlayerName) == 0x000008, "Member 'FGFxVaultHunterProfileCardPlayerConfig::PlayerName' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardPlayerConfig, MissionName) == 0x000020, "Member 'FGFxVaultHunterProfileCardPlayerConfig::MissionName' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardPlayerConfig, PlayerClass) == 0x000038, "Member 'FGFxVaultHunterProfileCardPlayerConfig::PlayerClass' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardPlayerConfig, bHasSelectedCharacter) == 0x000060, "Member 'FGFxVaultHunterProfileCardPlayerConfig::bHasSelectedCharacter' has a wrong offset!");

// ScriptStruct OakGame.CommandRingTarget
// 0x0028 (0x0028 - 0x0000)
struct FCommandRingTarget final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        BaseComponent;                                     // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandRingTarget) == 0x000008, "Wrong alignment on FCommandRingTarget");
static_assert(sizeof(FCommandRingTarget) == 0x000028, "Wrong size on FCommandRingTarget");
static_assert(offsetof(FCommandRingTarget, Actor) == 0x000000, "Member 'FCommandRingTarget::Actor' has a wrong offset!");
static_assert(offsetof(FCommandRingTarget, BaseComponent) == 0x000008, "Member 'FCommandRingTarget::BaseComponent' has a wrong offset!");
static_assert(offsetof(FCommandRingTarget, Location) == 0x000010, "Member 'FCommandRingTarget::Location' has a wrong offset!");
static_assert(offsetof(FCommandRingTarget, Rotation) == 0x00001C, "Member 'FCommandRingTarget::Rotation' has a wrong offset!");

// ScriptStruct OakGame.DiscoveredPlanetInfo
// 0x0030 (0x0030 - 0x0000)
struct FDiscoveredPlanetInfo final
{
public:
	TSoftObjectPtr<class UPlanetData>             DiscoveredPlanet;                                  // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewPlanet;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDiscoveredPlanetInfo) == 0x000008, "Wrong alignment on FDiscoveredPlanetInfo");
static_assert(sizeof(FDiscoveredPlanetInfo) == 0x000030, "Wrong size on FDiscoveredPlanetInfo");
static_assert(offsetof(FDiscoveredPlanetInfo, DiscoveredPlanet) == 0x000000, "Member 'FDiscoveredPlanetInfo::DiscoveredPlanet' has a wrong offset!");
static_assert(offsetof(FDiscoveredPlanetInfo, bIsNewPlanet) == 0x000028, "Member 'FDiscoveredPlanetInfo::bIsNewPlanet' has a wrong offset!");

// ScriptStruct OakGame.GearUpAirdropData
// 0x0010 (0x0010 - 0x0000)
struct FGearUpAirdropData final
{
public:
	class AOakMissionSpawner*                     Spawner;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGearUpAirdropData) == 0x000008, "Wrong alignment on FGearUpAirdropData");
static_assert(sizeof(FGearUpAirdropData) == 0x000010, "Wrong size on FGearUpAirdropData");
static_assert(offsetof(FGearUpAirdropData, Spawner) == 0x000000, "Member 'FGearUpAirdropData::Spawner' has a wrong offset!");

// ScriptStruct OakGame.InventoryAspectAbilityInfo
// 0x0008 (0x0008 - 0x0000)
struct FInventoryAspectAbilityInfo final
{
public:
	TSubclassOf<class UGbxAbility>                Ability;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryAspectAbilityInfo) == 0x000008, "Wrong alignment on FInventoryAspectAbilityInfo");
static_assert(sizeof(FInventoryAspectAbilityInfo) == 0x000008, "Wrong size on FInventoryAspectAbilityInfo");
static_assert(offsetof(FInventoryAspectAbilityInfo, Ability) == 0x000000, "Member 'FInventoryAspectAbilityInfo::Ability' has a wrong offset!");

// ScriptStruct OakGame.AbilityTreeTier
// 0x0038 (0x0038 - 0x0000)
struct FAbilityTreeTier final
{
public:
	class UOakPlayerAbilityTree*                  Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakPlayerAbilityTreeTierData*          TierData;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x28];                                      // 0x0010(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityTreeTier) == 0x000008, "Wrong alignment on FAbilityTreeTier");
static_assert(sizeof(FAbilityTreeTier) == 0x000038, "Wrong size on FAbilityTreeTier");
static_assert(offsetof(FAbilityTreeTier, Owner) == 0x000000, "Member 'FAbilityTreeTier::Owner' has a wrong offset!");
static_assert(offsetof(FAbilityTreeTier, TierData) == 0x000008, "Member 'FAbilityTreeTier::TierData' has a wrong offset!");

// ScriptStruct OakGame.MeleeWeaponAttachmentData
// 0x0040 (0x0040 - 0x0000)
struct FMeleeWeaponAttachmentData final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0010(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x001C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UGbxCustomizationTargetData*>    CustomizationTargets;                              // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxStaticMeshComponent*                Component;                                         // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeWeaponAttachmentData) == 0x000008, "Wrong alignment on FMeleeWeaponAttachmentData");
static_assert(sizeof(FMeleeWeaponAttachmentData) == 0x000040, "Wrong size on FMeleeWeaponAttachmentData");
static_assert(offsetof(FMeleeWeaponAttachmentData, Mesh) == 0x000000, "Member 'FMeleeWeaponAttachmentData::Mesh' has a wrong offset!");
static_assert(offsetof(FMeleeWeaponAttachmentData, Socket) == 0x000008, "Member 'FMeleeWeaponAttachmentData::Socket' has a wrong offset!");
static_assert(offsetof(FMeleeWeaponAttachmentData, RelativeLocation) == 0x000010, "Member 'FMeleeWeaponAttachmentData::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FMeleeWeaponAttachmentData, RelativeRotation) == 0x00001C, "Member 'FMeleeWeaponAttachmentData::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FMeleeWeaponAttachmentData, CustomizationTargets) == 0x000028, "Member 'FMeleeWeaponAttachmentData::CustomizationTargets' has a wrong offset!");
static_assert(offsetof(FMeleeWeaponAttachmentData, Component) == 0x000038, "Member 'FMeleeWeaponAttachmentData::Component' has a wrong offset!");

// ScriptStruct OakGame.OnlineNetworkOptionData
// 0x0038 (0x0038 - 0x0000)
struct FOnlineNetworkOptionData final
{
public:
	class FText                                   Label;                                             // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ENetworkType                                  NetworkType;                                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInviteType                                   InviteType;                                        // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineNetworkOptionData) == 0x000008, "Wrong alignment on FOnlineNetworkOptionData");
static_assert(sizeof(FOnlineNetworkOptionData) == 0x000038, "Wrong size on FOnlineNetworkOptionData");
static_assert(offsetof(FOnlineNetworkOptionData, Label) == 0x000000, "Member 'FOnlineNetworkOptionData::Label' has a wrong offset!");
static_assert(offsetof(FOnlineNetworkOptionData, Description) == 0x000018, "Member 'FOnlineNetworkOptionData::Description' has a wrong offset!");
static_assert(offsetof(FOnlineNetworkOptionData, NetworkType) == 0x000030, "Member 'FOnlineNetworkOptionData::NetworkType' has a wrong offset!");
static_assert(offsetof(FOnlineNetworkOptionData, InviteType) == 0x000031, "Member 'FOnlineNetworkOptionData::InviteType' has a wrong offset!");

// ScriptStruct OakGame.GFxNotificationQueueListItem
// 0x0050 (0x0050 - 0x0000)
struct FGFxNotificationQueueListItem final
{
public:
	class UHUDNotificationAsset*                  AssetData;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxDisplayedNotificationWidget*        ActiveWidgetContent;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MessageText;                                       // 0x0018(0x0018)(NativeAccessSpecifierPublic)
	class FName                                   SpawnAudioOverride;                                // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DespawnAudioOverride;                              // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeoutTimeRemaining;                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyDisplayed;                               // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NotificationId;                                    // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0xA];                                       // 0x0046(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxNotificationQueueListItem) == 0x000008, "Wrong alignment on FGFxNotificationQueueListItem");
static_assert(sizeof(FGFxNotificationQueueListItem) == 0x000050, "Wrong size on FGFxNotificationQueueListItem");
static_assert(offsetof(FGFxNotificationQueueListItem, AssetData) == 0x000000, "Member 'FGFxNotificationQueueListItem::AssetData' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, ActiveWidgetContent) == 0x000008, "Member 'FGFxNotificationQueueListItem::ActiveWidgetContent' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, Priority) == 0x000010, "Member 'FGFxNotificationQueueListItem::Priority' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, MessageText) == 0x000018, "Member 'FGFxNotificationQueueListItem::MessageText' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, SpawnAudioOverride) == 0x000030, "Member 'FGFxNotificationQueueListItem::SpawnAudioOverride' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, DespawnAudioOverride) == 0x000038, "Member 'FGFxNotificationQueueListItem::DespawnAudioOverride' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, TimeoutTimeRemaining) == 0x000040, "Member 'FGFxNotificationQueueListItem::TimeoutTimeRemaining' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, bCurrentlyDisplayed) == 0x000044, "Member 'FGFxNotificationQueueListItem::bCurrentlyDisplayed' has a wrong offset!");
static_assert(offsetof(FGFxNotificationQueueListItem, NotificationId) == 0x000045, "Member 'FGFxNotificationQueueListItem::NotificationId' has a wrong offset!");

// ScriptStruct OakGame.IncomingDamagePresentationGenericData
// 0x0001 (0x0001 - 0x0000)
struct FIncomingDamagePresentationGenericData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIncomingDamagePresentationGenericData) == 0x000001, "Wrong alignment on FIncomingDamagePresentationGenericData");
static_assert(sizeof(FIncomingDamagePresentationGenericData) == 0x000001, "Wrong size on FIncomingDamagePresentationGenericData");

// ScriptStruct OakGame.IncomingDamagePresentationGlobalInfo
// 0x0080 (0x0080 - 0x0000)
struct FIncomingDamagePresentationGlobalInfo final
{
public:
	class UParticleSystem*                        ScreenParticleHealth;                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ScreenParticleShield;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ScreenParticleArmor;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ScreenParticleHealth_SplitScreen;                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ScreenParticleShield_SplitScreen;                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ScreenParticleArmor_SplitScreen;                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DirectionalParticleEventName;                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DirectionalEmitterName;                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumDirectionalParticles;                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FullParticleEventName;                             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FullEmitterName;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageSeverityParameterName;                       // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageDirectionParameterName;                      // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageParticleDirectionQuantization;               // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatioThresholdToUseWidescreenParticles;      // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchAnimationStregthNoise;                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchAnimationAngleNoise;                         // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialBlurMaxDistance;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIncomingDamagePresentationGenericData PresentationLevels[0x4];                           // 0x007C(0x0001)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIncomingDamagePresentationGlobalInfo) == 0x000008, "Wrong alignment on FIncomingDamagePresentationGlobalInfo");
static_assert(sizeof(FIncomingDamagePresentationGlobalInfo) == 0x000080, "Wrong size on FIncomingDamagePresentationGlobalInfo");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, ScreenParticleHealth) == 0x000000, "Member 'FIncomingDamagePresentationGlobalInfo::ScreenParticleHealth' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, ScreenParticleShield) == 0x000008, "Member 'FIncomingDamagePresentationGlobalInfo::ScreenParticleShield' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, ScreenParticleArmor) == 0x000010, "Member 'FIncomingDamagePresentationGlobalInfo::ScreenParticleArmor' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, ScreenParticleHealth_SplitScreen) == 0x000018, "Member 'FIncomingDamagePresentationGlobalInfo::ScreenParticleHealth_SplitScreen' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, ScreenParticleShield_SplitScreen) == 0x000020, "Member 'FIncomingDamagePresentationGlobalInfo::ScreenParticleShield_SplitScreen' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, ScreenParticleArmor_SplitScreen) == 0x000028, "Member 'FIncomingDamagePresentationGlobalInfo::ScreenParticleArmor_SplitScreen' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, DirectionalParticleEventName) == 0x000030, "Member 'FIncomingDamagePresentationGlobalInfo::DirectionalParticleEventName' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, DirectionalEmitterName) == 0x000038, "Member 'FIncomingDamagePresentationGlobalInfo::DirectionalEmitterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, MaxNumDirectionalParticles) == 0x000040, "Member 'FIncomingDamagePresentationGlobalInfo::MaxNumDirectionalParticles' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, FullParticleEventName) == 0x000048, "Member 'FIncomingDamagePresentationGlobalInfo::FullParticleEventName' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, FullEmitterName) == 0x000050, "Member 'FIncomingDamagePresentationGlobalInfo::FullEmitterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, DamageSeverityParameterName) == 0x000058, "Member 'FIncomingDamagePresentationGlobalInfo::DamageSeverityParameterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, DamageDirectionParameterName) == 0x000060, "Member 'FIncomingDamagePresentationGlobalInfo::DamageDirectionParameterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, DamageParticleDirectionQuantization) == 0x000068, "Member 'FIncomingDamagePresentationGlobalInfo::DamageParticleDirectionQuantization' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, AspectRatioThresholdToUseWidescreenParticles) == 0x00006C, "Member 'FIncomingDamagePresentationGlobalInfo::AspectRatioThresholdToUseWidescreenParticles' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, FlinchAnimationStregthNoise) == 0x000070, "Member 'FIncomingDamagePresentationGlobalInfo::FlinchAnimationStregthNoise' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, FlinchAnimationAngleNoise) == 0x000074, "Member 'FIncomingDamagePresentationGlobalInfo::FlinchAnimationAngleNoise' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, RadialBlurMaxDistance) == 0x000078, "Member 'FIncomingDamagePresentationGlobalInfo::RadialBlurMaxDistance' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationGlobalInfo, PresentationLevels) == 0x00007C, "Member 'FIncomingDamagePresentationGlobalInfo::PresentationLevels' has a wrong offset!");

// ScriptStruct OakGame.OakCoordinatedEffectSwitchState
// 0x0020 (0x0020 - 0x0000)
struct FOakCoordinatedEffectSwitchState final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOakAction_CoordinatedEffect> Effect;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCoordinatedEffectSwitchState) == 0x000008, "Wrong alignment on FOakCoordinatedEffectSwitchState");
static_assert(sizeof(FOakCoordinatedEffectSwitchState) == 0x000020, "Wrong size on FOakCoordinatedEffectSwitchState");
static_assert(offsetof(FOakCoordinatedEffectSwitchState, DisplayName) == 0x000000, "Member 'FOakCoordinatedEffectSwitchState::DisplayName' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitchState, Name) == 0x000010, "Member 'FOakCoordinatedEffectSwitchState::Name' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitchState, Effect) == 0x000018, "Member 'FOakCoordinatedEffectSwitchState::Effect' has a wrong offset!");

// ScriptStruct OakGame.OakCoordinatedEffectSwitch
// 0x0058 (0x0058 - 0x0000)
struct FOakCoordinatedEffectSwitch final
{
public:
	class UEnum*                                  Enum;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NativeEnumName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNativeEnum;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         InitialState;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakCoordinatedEffectSwitchState> States;                                            // 0x0018(0x0010)(Edit, EditFixedSize, ZeroConstructor, RepSkip, NativeAccessSpecifierPrivate)
	uint8                                         CurrentState;                                      // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    ActionComp;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReplicatedState;                                   // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCoordinatedEffectSwitch) == 0x000008, "Wrong alignment on FOakCoordinatedEffectSwitch");
static_assert(sizeof(FOakCoordinatedEffectSwitch) == 0x000058, "Wrong size on FOakCoordinatedEffectSwitch");
static_assert(offsetof(FOakCoordinatedEffectSwitch, Enum) == 0x000000, "Member 'FOakCoordinatedEffectSwitch::Enum' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, NativeEnumName) == 0x000008, "Member 'FOakCoordinatedEffectSwitch::NativeEnumName' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, bNativeEnum) == 0x000010, "Member 'FOakCoordinatedEffectSwitch::bNativeEnum' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, InitialState) == 0x000011, "Member 'FOakCoordinatedEffectSwitch::InitialState' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, States) == 0x000018, "Member 'FOakCoordinatedEffectSwitch::States' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, CurrentState) == 0x000028, "Member 'FOakCoordinatedEffectSwitch::CurrentState' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, Owner) == 0x000030, "Member 'FOakCoordinatedEffectSwitch::Owner' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, ActionComp) == 0x000038, "Member 'FOakCoordinatedEffectSwitch::ActionComp' has a wrong offset!");
static_assert(offsetof(FOakCoordinatedEffectSwitch, ReplicatedState) == 0x000050, "Member 'FOakCoordinatedEffectSwitch::ReplicatedState' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryMenuFilter
// 0x0020 (0x0020 - 0x0000)
struct FOakInventoryMenuFilter final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	EOakInventoryMenuSortMode                     SortMode;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakInventoryMenuFilter) == 0x000008, "Wrong alignment on FOakInventoryMenuFilter");
static_assert(sizeof(FOakInventoryMenuFilter) == 0x000020, "Wrong size on FOakInventoryMenuFilter");
static_assert(offsetof(FOakInventoryMenuFilter, DisplayName) == 0x000000, "Member 'FOakInventoryMenuFilter::DisplayName' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuFilter, SortMode) == 0x000018, "Member 'FOakInventoryMenuFilter::SortMode' has a wrong offset!");

// ScriptStruct OakGame.RandomAnimDef
// 0x0020 (0x0020 - 0x0000)
struct FRandomAnimDef final
{
public:
	struct FAnimActionDef                         AnimAsset3rd;                                      // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomAnimDef) == 0x000008, "Wrong alignment on FRandomAnimDef");
static_assert(sizeof(FRandomAnimDef) == 0x000020, "Wrong size on FRandomAnimDef");
static_assert(offsetof(FRandomAnimDef, AnimAsset3rd) == 0x000000, "Member 'FRandomAnimDef::AnimAsset3rd' has a wrong offset!");
static_assert(offsetof(FRandomAnimDef, Weight) == 0x000018, "Member 'FRandomAnimDef::Weight' has a wrong offset!");

// ScriptStruct OakGame.TrackedSlidingImpactEffect
// 0x0030 (0x0030 - 0x0000)
struct FTrackedSlidingImpactEffect final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackedSlidingImpactEffect) == 0x000008, "Wrong alignment on FTrackedSlidingImpactEffect");
static_assert(sizeof(FTrackedSlidingImpactEffect) == 0x000030, "Wrong size on FTrackedSlidingImpactEffect");
static_assert(offsetof(FTrackedSlidingImpactEffect, Component) == 0x000000, "Member 'FTrackedSlidingImpactEffect::Component' has a wrong offset!");
static_assert(offsetof(FTrackedSlidingImpactEffect, PhysicalMaterial) == 0x000008, "Member 'FTrackedSlidingImpactEffect::PhysicalMaterial' has a wrong offset!");

// ScriptStruct OakGame.SlidingImpactState
// 0x00E8 (0x00E8 - 0x0000)
struct FSlidingImpactState final
{
public:
	class UOakCharacterMovementComponent*         OwnerMovementComponent;                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StartAudioEvent;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StopAudioEvent;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSlidingState;                               // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastImpact;                                        // 0x0020(0x0090)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LastImpactTraceTime;                               // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTrackedSlidingImpactEffect>    Effects;                                           // 0x00B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   SpeedParticleParameterName;                        // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlidingImpactState) == 0x000008, "Wrong alignment on FSlidingImpactState");
static_assert(sizeof(FSlidingImpactState) == 0x0000E8, "Wrong size on FSlidingImpactState");
static_assert(offsetof(FSlidingImpactState, OwnerMovementComponent) == 0x000000, "Member 'FSlidingImpactState::OwnerMovementComponent' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, StartAudioEvent) == 0x000008, "Member 'FSlidingImpactState::StartAudioEvent' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, StopAudioEvent) == 0x000010, "Member 'FSlidingImpactState::StopAudioEvent' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, bIgnoreSlidingState) == 0x000018, "Member 'FSlidingImpactState::bIgnoreSlidingState' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, LastImpact) == 0x000020, "Member 'FSlidingImpactState::LastImpact' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, LastImpactTraceTime) == 0x0000B0, "Member 'FSlidingImpactState::LastImpactTraceTime' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, Effects) == 0x0000B8, "Member 'FSlidingImpactState::Effects' has a wrong offset!");
static_assert(offsetof(FSlidingImpactState, SpeedParticleParameterName) == 0x0000C8, "Member 'FSlidingImpactState::SpeedParticleParameterName' has a wrong offset!");

// ScriptStruct OakGame.OakEffectPresentationItem
// 0x0034 (0x0040 - 0x000C)
struct FOakEffectPresentationItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakStatusEffectPresentationData*       FXData;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EffectValue;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWwisePlaybackInstance                 EffectAudioInstance;                               // 0x0020(0x0018)(RepSkip, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakEffectPresentationItem) == 0x000008, "Wrong alignment on FOakEffectPresentationItem");
static_assert(sizeof(FOakEffectPresentationItem) == 0x000040, "Wrong size on FOakEffectPresentationItem");
static_assert(offsetof(FOakEffectPresentationItem, FXData) == 0x000010, "Member 'FOakEffectPresentationItem::FXData' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationItem, EffectValue) == 0x000018, "Member 'FOakEffectPresentationItem::EffectValue' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationItem, EffectAudioInstance) == 0x000020, "Member 'FOakEffectPresentationItem::EffectAudioInstance' has a wrong offset!");

// ScriptStruct OakGame.OakPresentationParticleSystemWrapper
// 0x0018 (0x0018 - 0x0000)
struct FOakPresentationParticleSystemWrapper final
{
public:
	class UParticleSystemComponent*               Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPresentationParticleSystemWrapper) == 0x000008, "Wrong alignment on FOakPresentationParticleSystemWrapper");
static_assert(sizeof(FOakPresentationParticleSystemWrapper) == 0x000018, "Wrong size on FOakPresentationParticleSystemWrapper");
static_assert(offsetof(FOakPresentationParticleSystemWrapper, Component) == 0x000000, "Member 'FOakPresentationParticleSystemWrapper::Component' has a wrong offset!");

// ScriptStruct OakGame.AppliedMeshComponentTracker
// 0x0030 (0x0030 - 0x0000)
struct FAppliedMeshComponentTracker final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakStatusEffectManagerComponent*       ManagerComponent;                                  // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 TrackedMeshes;                                     // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ChildTargetActors;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAppliedMeshComponentTracker) == 0x000008, "Wrong alignment on FAppliedMeshComponentTracker");
static_assert(sizeof(FAppliedMeshComponentTracker) == 0x000030, "Wrong size on FAppliedMeshComponentTracker");
static_assert(offsetof(FAppliedMeshComponentTracker, ManagerComponent) == 0x000008, "Member 'FAppliedMeshComponentTracker::ManagerComponent' has a wrong offset!");
static_assert(offsetof(FAppliedMeshComponentTracker, TrackedMeshes) == 0x000010, "Member 'FAppliedMeshComponentTracker::TrackedMeshes' has a wrong offset!");
static_assert(offsetof(FAppliedMeshComponentTracker, ChildTargetActors) == 0x000020, "Member 'FAppliedMeshComponentTracker::ChildTargetActors' has a wrong offset!");

// ScriptStruct OakGame.OakFreezePresentation
// 0x0040 (0x0040 - 0x0000)
struct FOakFreezePresentation final
{
public:
	class UOakFreezeData*                         Data;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDestructibleComponent*>         DestructibleComponents;                            // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           StaticMeshComponents;                              // 0x0018(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDecalComponent*                        GroundDecalComponent;                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakFreezePresentation) == 0x000008, "Wrong alignment on FOakFreezePresentation");
static_assert(sizeof(FOakFreezePresentation) == 0x000040, "Wrong size on FOakFreezePresentation");
static_assert(offsetof(FOakFreezePresentation, Data) == 0x000000, "Member 'FOakFreezePresentation::Data' has a wrong offset!");
static_assert(offsetof(FOakFreezePresentation, DestructibleComponents) == 0x000008, "Member 'FOakFreezePresentation::DestructibleComponents' has a wrong offset!");
static_assert(offsetof(FOakFreezePresentation, StaticMeshComponents) == 0x000018, "Member 'FOakFreezePresentation::StaticMeshComponents' has a wrong offset!");
static_assert(offsetof(FOakFreezePresentation, GroundDecalComponent) == 0x000028, "Member 'FOakFreezePresentation::GroundDecalComponent' has a wrong offset!");

// ScriptStruct OakGame.OakEffectPresentationManager
// 0x0108 (0x01B8 - 0x00B0)
struct FOakEffectPresentationManager final : public FFastArraySerializer
{
public:
	class UOakStatusEffectManagerComponent*       Owner;                                             // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakEffectPresentationItem>     Items;                                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOakPresentationParticleSystemWrapper> ParticleSystemWrappers;                            // 0x00C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FOakPresentationParamTransitionInstance> PresentationTransitionInstances;                   // 0x00D8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakFreezePresentation                 FreezePresentation;                                // 0x0118(0x0040)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAppliedMeshComponentTracker           MeshComponentTracker;                              // 0x0158(0x0030)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x30];                                     // 0x0188(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakEffectPresentationManager) == 0x000008, "Wrong alignment on FOakEffectPresentationManager");
static_assert(sizeof(FOakEffectPresentationManager) == 0x0001B8, "Wrong size on FOakEffectPresentationManager");
static_assert(offsetof(FOakEffectPresentationManager, Owner) == 0x0000B0, "Member 'FOakEffectPresentationManager::Owner' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationManager, Items) == 0x0000B8, "Member 'FOakEffectPresentationManager::Items' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationManager, ParticleSystemWrappers) == 0x0000C8, "Member 'FOakEffectPresentationManager::ParticleSystemWrappers' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationManager, PresentationTransitionInstances) == 0x0000D8, "Member 'FOakEffectPresentationManager::PresentationTransitionInstances' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationManager, FreezePresentation) == 0x000118, "Member 'FOakEffectPresentationManager::FreezePresentation' has a wrong offset!");
static_assert(offsetof(FOakEffectPresentationManager, MeshComponentTracker) == 0x000158, "Member 'FOakEffectPresentationManager::MeshComponentTracker' has a wrong offset!");

// ScriptStruct OakGame.HoverBodySinusOutrunner
// 0x001C (0x001C - 0x0000)
struct FHoverBodySinusOutrunner final
{
public:
	struct FVector                                HoverScale;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetX;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetY;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoverBodySinusOutrunner) == 0x000004, "Wrong alignment on FHoverBodySinusOutrunner");
static_assert(sizeof(FHoverBodySinusOutrunner) == 0x00001C, "Wrong size on FHoverBodySinusOutrunner");
static_assert(offsetof(FHoverBodySinusOutrunner, HoverScale) == 0x000000, "Member 'FHoverBodySinusOutrunner::HoverScale' has a wrong offset!");
static_assert(offsetof(FHoverBodySinusOutrunner, OffsetX) == 0x00000C, "Member 'FHoverBodySinusOutrunner::OffsetX' has a wrong offset!");
static_assert(offsetof(FHoverBodySinusOutrunner, OffsetY) == 0x000010, "Member 'FHoverBodySinusOutrunner::OffsetY' has a wrong offset!");
static_assert(offsetof(FHoverBodySinusOutrunner, Frequency) == 0x000014, "Member 'FHoverBodySinusOutrunner::Frequency' has a wrong offset!");
static_assert(offsetof(FHoverBodySinusOutrunner, Amplitude) == 0x000018, "Member 'FHoverBodySinusOutrunner::Amplitude' has a wrong offset!");

// ScriptStruct OakGame.RoadBumpinessDataOutrunner
// 0x0008 (0x0008 - 0x0000)
struct FRoadBumpinessDataOutrunner final
{
public:
	EPhysicalSurface                              SurfaceType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Bumpiness;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoadBumpinessDataOutrunner) == 0x000004, "Wrong alignment on FRoadBumpinessDataOutrunner");
static_assert(sizeof(FRoadBumpinessDataOutrunner) == 0x000008, "Wrong size on FRoadBumpinessDataOutrunner");
static_assert(offsetof(FRoadBumpinessDataOutrunner, SurfaceType) == 0x000000, "Member 'FRoadBumpinessDataOutrunner::SurfaceType' has a wrong offset!");
static_assert(offsetof(FRoadBumpinessDataOutrunner, Bumpiness) == 0x000004, "Member 'FRoadBumpinessDataOutrunner::Bumpiness' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_OutrunnerHandler
// 0x1700 (0x1840 - 0x0140)
struct alignas(0x10) FAnimNode_OutrunnerHandler final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         SuspensionDropMaxSpeed;                            // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelInterpSpeed;                                  // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTreshold;                              // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningVelocityTreshold;                           // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchInterpSpeed;                                  // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollInterpSpeed;                                   // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMaxAngle;                                      // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostAlphaInterSpeed;                              // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BankingBoostAlpha;                                 // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     PitchAccelerationCurve;                            // 0x0168(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TranslationUpAccelerationCurve;                    // 0x01E0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MaxSteeringAngle;                                  // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoostBodyTranslation;                              // 0x025C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostBodyPitchAdd;                                 // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceAmplitudePitchHighFreq;                 // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceFrequencyPitchHighFreq;                 // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceFrequencyRollFreq;                      // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfacePersistencePitchHighFreq;               // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoadSurfaceOctavesPitchHighFreq;                   // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceAmplitudePitchLowFreq;                  // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceFrequencyPitchLowFreq;                  // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfacePersistencePitchLowFreq;                // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoadSurfaceOctavesPitchLowFreq;                    // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyFollowSpeedOfPitch;                            // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyFollowAmplitudeMultiplier;                     // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToSwitch;                                   // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToSwitch;                                   // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBumpTimeValue;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBumpTimeValue;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAlphaValue;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAlphaValue;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInterpSpeed;                                    // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInterpSpeed;                                    // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultRoadBumpiness;                              // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRoadBumpinessDataOutrunner>    RoadBumpinessOverrides;                            // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         HoverWheelSpeedWhenTurningOnSelf;                  // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverWheelAngle;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HoverWheelRearLeftPos;                             // 0x02D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HoverWheelRearRightPos;                            // 0x02E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpinSpeedIdle;                                // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverOffsetZ;                                      // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSuspensionArmAngleOffset;                     // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSuspensionArmAmplitude;                       // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSuspensionArmSpeed;                           // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxPitchAngle;                                // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxRollAngle;                                 // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpinSpeedFullTrottle;                         // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpinMaxSpeedAngularVelocity;                  // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxVelocity;                                  // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverPitchInterpSpeed;                             // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverPitchBoostingInterpSpeed;                     // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverRollInterpSpeed;                              // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverBodyAccelTreshold;                            // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverBodyActiveBlend;                              // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverVelocityIntensityX;                           // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverVelocityIntensityY;                           // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverWheelRotationIntensity;                       // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverWheelRotationIntensityY;                      // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHoverBodySinusOutrunner>       HoverBodySin;                                      // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SwivelCone;                                        // 0x0350(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HoverBodyTransitionCurve;                          // 0x0358(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x1470];                                   // 0x03D0(0x1470)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_OutrunnerHandler) == 0x000010, "Wrong alignment on FAnimNode_OutrunnerHandler");
static_assert(sizeof(FAnimNode_OutrunnerHandler) == 0x001840, "Wrong size on FAnimNode_OutrunnerHandler");
static_assert(offsetof(FAnimNode_OutrunnerHandler, SuspensionDropMaxSpeed) == 0x000140, "Member 'FAnimNode_OutrunnerHandler::SuspensionDropMaxSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, AccelInterpSpeed) == 0x000144, "Member 'FAnimNode_OutrunnerHandler::AccelInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, AccelerationTreshold) == 0x000148, "Member 'FAnimNode_OutrunnerHandler::AccelerationTreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, TurningVelocityTreshold) == 0x00014C, "Member 'FAnimNode_OutrunnerHandler::TurningVelocityTreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, PitchInterpSpeed) == 0x000150, "Member 'FAnimNode_OutrunnerHandler::PitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RollInterpSpeed) == 0x000154, "Member 'FAnimNode_OutrunnerHandler::RollInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RollMaxAngle) == 0x000158, "Member 'FAnimNode_OutrunnerHandler::RollMaxAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, BoostAlphaInterSpeed) == 0x00015C, "Member 'FAnimNode_OutrunnerHandler::BoostAlphaInterSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, BankingBoostAlpha) == 0x000160, "Member 'FAnimNode_OutrunnerHandler::BankingBoostAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, PitchAccelerationCurve) == 0x000168, "Member 'FAnimNode_OutrunnerHandler::PitchAccelerationCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, TranslationUpAccelerationCurve) == 0x0001E0, "Member 'FAnimNode_OutrunnerHandler::TranslationUpAccelerationCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MaxSteeringAngle) == 0x000258, "Member 'FAnimNode_OutrunnerHandler::MaxSteeringAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, BoostBodyTranslation) == 0x00025C, "Member 'FAnimNode_OutrunnerHandler::BoostBodyTranslation' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, BoostBodyPitchAdd) == 0x000268, "Member 'FAnimNode_OutrunnerHandler::BoostBodyPitchAdd' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceAmplitudePitchHighFreq) == 0x00026C, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceAmplitudePitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceFrequencyPitchHighFreq) == 0x000270, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceFrequencyPitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceFrequencyRollFreq) == 0x000274, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceFrequencyRollFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfacePersistencePitchHighFreq) == 0x000278, "Member 'FAnimNode_OutrunnerHandler::RoadSurfacePersistencePitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceOctavesPitchHighFreq) == 0x00027C, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceOctavesPitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceAmplitudePitchLowFreq) == 0x000280, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceAmplitudePitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceFrequencyPitchLowFreq) == 0x000284, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceFrequencyPitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfacePersistencePitchLowFreq) == 0x000288, "Member 'FAnimNode_OutrunnerHandler::RoadSurfacePersistencePitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadSurfaceOctavesPitchLowFreq) == 0x00028C, "Member 'FAnimNode_OutrunnerHandler::RoadSurfaceOctavesPitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, BodyFollowSpeedOfPitch) == 0x000290, "Member 'FAnimNode_OutrunnerHandler::BodyFollowSpeedOfPitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, BodyFollowAmplitudeMultiplier) == 0x000294, "Member 'FAnimNode_OutrunnerHandler::BodyFollowAmplitudeMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MinTimeToSwitch) == 0x000298, "Member 'FAnimNode_OutrunnerHandler::MinTimeToSwitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MaxTimeToSwitch) == 0x00029C, "Member 'FAnimNode_OutrunnerHandler::MaxTimeToSwitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MinBumpTimeValue) == 0x0002A0, "Member 'FAnimNode_OutrunnerHandler::MinBumpTimeValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MaxBumpTimeValue) == 0x0002A4, "Member 'FAnimNode_OutrunnerHandler::MaxBumpTimeValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MinAlphaValue) == 0x0002A8, "Member 'FAnimNode_OutrunnerHandler::MinAlphaValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MaxAlphaValue) == 0x0002AC, "Member 'FAnimNode_OutrunnerHandler::MaxAlphaValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MinInterpSpeed) == 0x0002B0, "Member 'FAnimNode_OutrunnerHandler::MinInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, MaxInterpSpeed) == 0x0002B4, "Member 'FAnimNode_OutrunnerHandler::MaxInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, DefaultRoadBumpiness) == 0x0002B8, "Member 'FAnimNode_OutrunnerHandler::DefaultRoadBumpiness' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, RoadBumpinessOverrides) == 0x0002C0, "Member 'FAnimNode_OutrunnerHandler::RoadBumpinessOverrides' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverWheelSpeedWhenTurningOnSelf) == 0x0002D0, "Member 'FAnimNode_OutrunnerHandler::HoverWheelSpeedWhenTurningOnSelf' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverWheelAngle) == 0x0002D4, "Member 'FAnimNode_OutrunnerHandler::HoverWheelAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverWheelRearLeftPos) == 0x0002D8, "Member 'FAnimNode_OutrunnerHandler::HoverWheelRearLeftPos' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverWheelRearRightPos) == 0x0002E4, "Member 'FAnimNode_OutrunnerHandler::HoverWheelRearRightPos' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverSpinSpeedIdle) == 0x0002F0, "Member 'FAnimNode_OutrunnerHandler::HoverSpinSpeedIdle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverOffsetZ) == 0x0002F4, "Member 'FAnimNode_OutrunnerHandler::HoverOffsetZ' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverSuspensionArmAngleOffset) == 0x0002F8, "Member 'FAnimNode_OutrunnerHandler::HoverSuspensionArmAngleOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverSuspensionArmAmplitude) == 0x0002FC, "Member 'FAnimNode_OutrunnerHandler::HoverSuspensionArmAmplitude' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverSuspensionArmSpeed) == 0x000300, "Member 'FAnimNode_OutrunnerHandler::HoverSuspensionArmSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverMaxPitchAngle) == 0x000304, "Member 'FAnimNode_OutrunnerHandler::HoverMaxPitchAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverMaxRollAngle) == 0x000308, "Member 'FAnimNode_OutrunnerHandler::HoverMaxRollAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverSpinSpeedFullTrottle) == 0x00030C, "Member 'FAnimNode_OutrunnerHandler::HoverSpinSpeedFullTrottle' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverSpinMaxSpeedAngularVelocity) == 0x000310, "Member 'FAnimNode_OutrunnerHandler::HoverSpinMaxSpeedAngularVelocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverMaxVelocity) == 0x000314, "Member 'FAnimNode_OutrunnerHandler::HoverMaxVelocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverPitchInterpSpeed) == 0x000318, "Member 'FAnimNode_OutrunnerHandler::HoverPitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverPitchBoostingInterpSpeed) == 0x00031C, "Member 'FAnimNode_OutrunnerHandler::HoverPitchBoostingInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverRollInterpSpeed) == 0x000320, "Member 'FAnimNode_OutrunnerHandler::HoverRollInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverBodyAccelTreshold) == 0x000324, "Member 'FAnimNode_OutrunnerHandler::HoverBodyAccelTreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverBodyActiveBlend) == 0x000328, "Member 'FAnimNode_OutrunnerHandler::HoverBodyActiveBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverVelocityIntensityX) == 0x00032C, "Member 'FAnimNode_OutrunnerHandler::HoverVelocityIntensityX' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverVelocityIntensityY) == 0x000330, "Member 'FAnimNode_OutrunnerHandler::HoverVelocityIntensityY' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverWheelRotationIntensity) == 0x000334, "Member 'FAnimNode_OutrunnerHandler::HoverWheelRotationIntensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverWheelRotationIntensityY) == 0x000338, "Member 'FAnimNode_OutrunnerHandler::HoverWheelRotationIntensityY' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverBodySin) == 0x000340, "Member 'FAnimNode_OutrunnerHandler::HoverBodySin' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, SwivelCone) == 0x000350, "Member 'FAnimNode_OutrunnerHandler::SwivelCone' has a wrong offset!");
static_assert(offsetof(FAnimNode_OutrunnerHandler, HoverBodyTransitionCurve) == 0x000358, "Member 'FAnimNode_OutrunnerHandler::HoverBodyTransitionCurve' has a wrong offset!");

// ScriptStruct OakGame.UnlockedPlayerEchoLogData
// 0x0010 (0x0010 - 0x0000)
struct FUnlockedPlayerEchoLogData final
{
public:
	class UEchoLogData*                           EchoLogData;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnlockedPlayerEchoLogData) == 0x000008, "Wrong alignment on FUnlockedPlayerEchoLogData");
static_assert(sizeof(FUnlockedPlayerEchoLogData) == 0x000010, "Wrong size on FUnlockedPlayerEchoLogData");
static_assert(offsetof(FUnlockedPlayerEchoLogData, EchoLogData) == 0x000000, "Member 'FUnlockedPlayerEchoLogData::EchoLogData' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterColorization
// 0x0078 (0x008C - 0x0014)
struct FOakCharacterColorization final : public FOakCharacterCustomization
{
public:
	struct FLinearColor                           Primary1;                                          // 0x0014(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePrimary1;                                 // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Primary2;                                          // 0x0028(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePrimary2;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Secondary1;                                        // 0x003C(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSecondary1;                               // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Secondary2;                                        // 0x0050(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSecondary2;                               // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Tertiary1;                                         // 0x0064(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTertiary1;                                // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Tertiary2;                                         // 0x0078(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTertiary2;                                // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCharacterColorization) == 0x000004, "Wrong alignment on FOakCharacterColorization");
static_assert(sizeof(FOakCharacterColorization) == 0x00008C, "Wrong size on FOakCharacterColorization");
static_assert(offsetof(FOakCharacterColorization, Primary1) == 0x000014, "Member 'FOakCharacterColorization::Primary1' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, bOverridePrimary1) == 0x000024, "Member 'FOakCharacterColorization::bOverridePrimary1' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, Primary2) == 0x000028, "Member 'FOakCharacterColorization::Primary2' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, bOverridePrimary2) == 0x000038, "Member 'FOakCharacterColorization::bOverridePrimary2' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, Secondary1) == 0x00003C, "Member 'FOakCharacterColorization::Secondary1' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, bOverrideSecondary1) == 0x00004C, "Member 'FOakCharacterColorization::bOverrideSecondary1' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, Secondary2) == 0x000050, "Member 'FOakCharacterColorization::Secondary2' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, bOverrideSecondary2) == 0x000060, "Member 'FOakCharacterColorization::bOverrideSecondary2' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, Tertiary1) == 0x000064, "Member 'FOakCharacterColorization::Tertiary1' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, bOverrideTertiary1) == 0x000074, "Member 'FOakCharacterColorization::bOverrideTertiary1' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, Tertiary2) == 0x000078, "Member 'FOakCharacterColorization::Tertiary2' has a wrong offset!");
static_assert(offsetof(FOakCharacterColorization, bOverrideTertiary2) == 0x000088, "Member 'FOakCharacterColorization::bOverrideTertiary2' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterSkinTone
// 0x0014 (0x0028 - 0x0014)
struct FOakCharacterSkinTone final : public FOakCharacterCustomization
{
public:
	struct FLinearColor                           SkinTone;                                          // 0x0014(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSkinTone;                                 // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCharacterSkinTone) == 0x000004, "Wrong alignment on FOakCharacterSkinTone");
static_assert(sizeof(FOakCharacterSkinTone) == 0x000028, "Wrong size on FOakCharacterSkinTone");
static_assert(offsetof(FOakCharacterSkinTone, SkinTone) == 0x000014, "Member 'FOakCharacterSkinTone::SkinTone' has a wrong offset!");
static_assert(offsetof(FOakCharacterSkinTone, bOverrideSkinTone) == 0x000024, "Member 'FOakCharacterSkinTone::bOverrideSkinTone' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterHair
// 0x003C (0x0050 - 0x0014)
struct FOakCharacterHair final : public FOakCharacterCustomization
{
public:
	struct FLinearColor                           InnerColor;                                        // 0x0014(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideInnerColor;                               // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OuterColor;                                        // 0x0028(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideOuterColor;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SSSColor;                                          // 0x003C(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSSSColor;                                 // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCharacterHair) == 0x000004, "Wrong alignment on FOakCharacterHair");
static_assert(sizeof(FOakCharacterHair) == 0x000050, "Wrong size on FOakCharacterHair");
static_assert(offsetof(FOakCharacterHair, InnerColor) == 0x000014, "Member 'FOakCharacterHair::InnerColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterHair, bOverrideInnerColor) == 0x000024, "Member 'FOakCharacterHair::bOverrideInnerColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterHair, OuterColor) == 0x000028, "Member 'FOakCharacterHair::OuterColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterHair, bOverrideOuterColor) == 0x000038, "Member 'FOakCharacterHair::bOverrideOuterColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterHair, SSSColor) == 0x00003C, "Member 'FOakCharacterHair::SSSColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterHair, bOverrideSSSColor) == 0x00004C, "Member 'FOakCharacterHair::bOverrideSSSColor' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterDecal
// 0x005C (0x0070 - 0x0014)
struct FOakCharacterDecal final : public FOakCharacterCustomization
{
public:
	float                                         DecalStrength;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDecalStrength;                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DecalColor;                                        // 0x001C(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDecalColor;                               // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DecalColorHighlight;                               // 0x0030(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDecalColorHighlight;                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Texture_Comp;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Texture_Normal;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Texture_BaseColor;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOakCharacterTexturePair>       Textures;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCharacterDecal) == 0x000008, "Wrong alignment on FOakCharacterDecal");
static_assert(sizeof(FOakCharacterDecal) == 0x000070, "Wrong size on FOakCharacterDecal");
static_assert(offsetof(FOakCharacterDecal, DecalStrength) == 0x000014, "Member 'FOakCharacterDecal::DecalStrength' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, bOverrideDecalStrength) == 0x000018, "Member 'FOakCharacterDecal::bOverrideDecalStrength' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, DecalColor) == 0x00001C, "Member 'FOakCharacterDecal::DecalColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, bOverrideDecalColor) == 0x00002C, "Member 'FOakCharacterDecal::bOverrideDecalColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, DecalColorHighlight) == 0x000030, "Member 'FOakCharacterDecal::DecalColorHighlight' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, bOverrideDecalColorHighlight) == 0x000040, "Member 'FOakCharacterDecal::bOverrideDecalColorHighlight' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, Texture_Comp) == 0x000048, "Member 'FOakCharacterDecal::Texture_Comp' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, Texture_Normal) == 0x000050, "Member 'FOakCharacterDecal::Texture_Normal' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, Texture_BaseColor) == 0x000058, "Member 'FOakCharacterDecal::Texture_BaseColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterDecal, Textures) == 0x000060, "Member 'FOakCharacterDecal::Textures' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterPattern
// 0x0038 (0x0038 - 0x0000)
struct FOakCharacterPattern final
{
public:
	float                                         Primary;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePrimary;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Secondary;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSecondary;                                // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tertiary;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTertiary;                                 // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Skin;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSkin;                                     // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeUse;                                     // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Chance;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeTexture;                                 // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakCharacterTexturePair>       Textures;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCharacterPattern) == 0x000008, "Wrong alignment on FOakCharacterPattern");
static_assert(sizeof(FOakCharacterPattern) == 0x000038, "Wrong size on FOakCharacterPattern");
static_assert(offsetof(FOakCharacterPattern, Primary) == 0x000000, "Member 'FOakCharacterPattern::Primary' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, bOverridePrimary) == 0x000004, "Member 'FOakCharacterPattern::bOverridePrimary' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, Secondary) == 0x000008, "Member 'FOakCharacterPattern::Secondary' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, bOverrideSecondary) == 0x00000C, "Member 'FOakCharacterPattern::bOverrideSecondary' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, Tertiary) == 0x000010, "Member 'FOakCharacterPattern::Tertiary' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, bOverrideTertiary) == 0x000014, "Member 'FOakCharacterPattern::bOverrideTertiary' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, Skin) == 0x000018, "Member 'FOakCharacterPattern::Skin' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, bOverrideSkin) == 0x00001C, "Member 'FOakCharacterPattern::bOverrideSkin' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, bRandomizeUse) == 0x00001D, "Member 'FOakCharacterPattern::bRandomizeUse' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, Chance) == 0x000020, "Member 'FOakCharacterPattern::Chance' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, bRandomizeTexture) == 0x000024, "Member 'FOakCharacterPattern::bRandomizeTexture' has a wrong offset!");
static_assert(offsetof(FOakCharacterPattern, Textures) == 0x000028, "Member 'FOakCharacterPattern::Textures' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterTattoos
// 0x0014 (0x0028 - 0x0014)
struct FOakCharacterTattoos final : public FOakCharacterCustomization
{
public:
	struct FLinearColor                           TattooColor;                                       // 0x0014(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTattooColor;                              // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCharacterTattoos) == 0x000004, "Wrong alignment on FOakCharacterTattoos");
static_assert(sizeof(FOakCharacterTattoos) == 0x000028, "Wrong size on FOakCharacterTattoos");
static_assert(offsetof(FOakCharacterTattoos, TattooColor) == 0x000014, "Member 'FOakCharacterTattoos::TattooColor' has a wrong offset!");
static_assert(offsetof(FOakCharacterTattoos, bOverrideTattooColor) == 0x000024, "Member 'FOakCharacterTattoos::bOverrideTattooColor' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterEyes
// 0x0018 (0x0018 - 0x0000)
struct FOakCharacterEyes final
{
public:
	TArray<struct FColor>                         RandomEyeColors;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideEyeColor;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCharacterEyes) == 0x000008, "Wrong alignment on FOakCharacterEyes");
static_assert(sizeof(FOakCharacterEyes) == 0x000018, "Wrong size on FOakCharacterEyes");
static_assert(offsetof(FOakCharacterEyes, RandomEyeColors) == 0x000000, "Member 'FOakCharacterEyes::RandomEyeColors' has a wrong offset!");
static_assert(offsetof(FOakCharacterEyes, bOverrideEyeColor) == 0x000010, "Member 'FOakCharacterEyes::bOverrideEyeColor' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterCustomizationData
// 0x0248 (0x0248 - 0x0000)
struct FOakCharacterCustomizationData final
{
public:
	TArray<struct FOakCharacterColorization>      Customization_Colorizations;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_Colorization;                  // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakCharacterPattern                   Customization_Pattern;                             // 0x0018(0x0038)(Edit, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_Pattern;                       // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakCharacterSkinTone                  Customization_SkinTone;                            // 0x0054(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_SkinTone;                      // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakCharacterTattoos                   Customization_Tattoos;                             // 0x0080(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_Tattoos;                       // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakCharacterHair>              Customization_Hairs;                               // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_Hair;                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakCharacterEyes                      Customization_Eyes;                                // 0x00C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_Eyes;                          // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakCharacterDecal>             Customization_Decals;                              // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bApplyCustomization_Decal;                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakCharacterColorization              Customization_Colorization;                        // 0x00FC(0x008C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FOakCharacterHair                      Customization_Hair;                                // 0x0188(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
	struct FOakCharacterDecal                     Customization_Decal;                               // 0x01D8(0x0070)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCharacterCustomizationData) == 0x000008, "Wrong alignment on FOakCharacterCustomizationData");
static_assert(sizeof(FOakCharacterCustomizationData) == 0x000248, "Wrong size on FOakCharacterCustomizationData");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Colorizations) == 0x000000, "Member 'FOakCharacterCustomizationData::Customization_Colorizations' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_Colorization) == 0x000010, "Member 'FOakCharacterCustomizationData::bApplyCustomization_Colorization' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Pattern) == 0x000018, "Member 'FOakCharacterCustomizationData::Customization_Pattern' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_Pattern) == 0x000050, "Member 'FOakCharacterCustomizationData::bApplyCustomization_Pattern' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_SkinTone) == 0x000054, "Member 'FOakCharacterCustomizationData::Customization_SkinTone' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_SkinTone) == 0x00007C, "Member 'FOakCharacterCustomizationData::bApplyCustomization_SkinTone' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Tattoos) == 0x000080, "Member 'FOakCharacterCustomizationData::Customization_Tattoos' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_Tattoos) == 0x0000A8, "Member 'FOakCharacterCustomizationData::bApplyCustomization_Tattoos' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Hairs) == 0x0000B0, "Member 'FOakCharacterCustomizationData::Customization_Hairs' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_Hair) == 0x0000C0, "Member 'FOakCharacterCustomizationData::bApplyCustomization_Hair' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Eyes) == 0x0000C8, "Member 'FOakCharacterCustomizationData::Customization_Eyes' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_Eyes) == 0x0000E0, "Member 'FOakCharacterCustomizationData::bApplyCustomization_Eyes' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Decals) == 0x0000E8, "Member 'FOakCharacterCustomizationData::Customization_Decals' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, bApplyCustomization_Decal) == 0x0000F8, "Member 'FOakCharacterCustomizationData::bApplyCustomization_Decal' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Colorization) == 0x0000FC, "Member 'FOakCharacterCustomizationData::Customization_Colorization' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Hair) == 0x000188, "Member 'FOakCharacterCustomizationData::Customization_Hair' has a wrong offset!");
static_assert(offsetof(FOakCharacterCustomizationData, Customization_Decal) == 0x0001D8, "Member 'FOakCharacterCustomizationData::Customization_Decal' has a wrong offset!");

// ScriptStruct OakGame.SpawnFactoryDataArray
// 0x0018 (0x0018 - 0x0000)
struct FSpawnFactoryDataArray final
{
public:
	TArray<struct FSpawnFactoryData>              SpawnFactoryDataArray;                             // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnFactoryDataArray) == 0x000008, "Wrong alignment on FSpawnFactoryDataArray");
static_assert(sizeof(FSpawnFactoryDataArray) == 0x000018, "Wrong size on FSpawnFactoryDataArray");
static_assert(offsetof(FSpawnFactoryDataArray, SpawnFactoryDataArray) == 0x000000, "Member 'FSpawnFactoryDataArray::SpawnFactoryDataArray' has a wrong offset!");

// ScriptStruct OakGame.MayhemUILevelData
// 0x0090 (0x0090 - 0x0000)
struct FMayhemUILevelData final
{
public:
	class FText                                   ModEnemies[0x3];                                   // 0x0000(0x0018)(Deprecated, NativeAccessSpecifierPublic)
	class FText                                   ModCurrency;                                       // 0x0048(0x0018)(Deprecated, NativeAccessSpecifierPublic)
	class FText                                   ModDropRate;                                       // 0x0060(0x0018)(Deprecated, NativeAccessSpecifierPublic)
	class FText                                   ModXP;                                             // 0x0078(0x0018)(Deprecated, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemUILevelData) == 0x000008, "Wrong alignment on FMayhemUILevelData");
static_assert(sizeof(FMayhemUILevelData) == 0x000090, "Wrong size on FMayhemUILevelData");
static_assert(offsetof(FMayhemUILevelData, ModEnemies) == 0x000000, "Member 'FMayhemUILevelData::ModEnemies' has a wrong offset!");
static_assert(offsetof(FMayhemUILevelData, ModCurrency) == 0x000048, "Member 'FMayhemUILevelData::ModCurrency' has a wrong offset!");
static_assert(offsetof(FMayhemUILevelData, ModDropRate) == 0x000060, "Member 'FMayhemUILevelData::ModDropRate' has a wrong offset!");
static_assert(offsetof(FMayhemUILevelData, ModXP) == 0x000078, "Member 'FMayhemUILevelData::ModXP' has a wrong offset!");

// ScriptStruct OakGame.GrenadeChildGenerationData
// 0x0028 (0x0028 - 0x0000)
struct FGrenadeChildGenerationData final
{
public:
	int32                                         DividerGrenadeGeneration;                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MiniMirvGrenadeGeneration;                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MirvGrenadeGeneration;                             // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RainGrenadeGeneration;                             // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpringGrenadeGeneration;                           // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StickyGrenadeGeneration;                           // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLingering;                                      // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LongbowTarget;                                     // 0x001C(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrenadeChildGenerationData) == 0x000004, "Wrong alignment on FGrenadeChildGenerationData");
static_assert(sizeof(FGrenadeChildGenerationData) == 0x000028, "Wrong size on FGrenadeChildGenerationData");
static_assert(offsetof(FGrenadeChildGenerationData, DividerGrenadeGeneration) == 0x000000, "Member 'FGrenadeChildGenerationData::DividerGrenadeGeneration' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, MiniMirvGrenadeGeneration) == 0x000004, "Member 'FGrenadeChildGenerationData::MiniMirvGrenadeGeneration' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, MirvGrenadeGeneration) == 0x000008, "Member 'FGrenadeChildGenerationData::MirvGrenadeGeneration' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, RainGrenadeGeneration) == 0x00000C, "Member 'FGrenadeChildGenerationData::RainGrenadeGeneration' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, SpringGrenadeGeneration) == 0x000010, "Member 'FGrenadeChildGenerationData::SpringGrenadeGeneration' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, StickyGrenadeGeneration) == 0x000014, "Member 'FGrenadeChildGenerationData::StickyGrenadeGeneration' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, bIsLingering) == 0x000018, "Member 'FGrenadeChildGenerationData::bIsLingering' has a wrong offset!");
static_assert(offsetof(FGrenadeChildGenerationData, LongbowTarget) == 0x00001C, "Member 'FGrenadeChildGenerationData::LongbowTarget' has a wrong offset!");

// ScriptStruct OakGame.StatConfigInfo
// 0x0020 (0x0020 - 0x0000)
struct FStatConfigInfo final
{
public:
	class FText                                   StatName;                                          // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	uint8                                         PercentCompletion;                                 // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatConfigInfo) == 0x000008, "Wrong alignment on FStatConfigInfo");
static_assert(sizeof(FStatConfigInfo) == 0x000020, "Wrong size on FStatConfigInfo");
static_assert(offsetof(FStatConfigInfo, StatName) == 0x000000, "Member 'FStatConfigInfo::StatName' has a wrong offset!");
static_assert(offsetof(FStatConfigInfo, PercentCompletion) == 0x000018, "Member 'FStatConfigInfo::PercentCompletion' has a wrong offset!");

// ScriptStruct OakGame.OperativeBarrierState
// 0x0020 (0x0020 - 0x0000)
struct FOperativeBarrierState final
{
public:
	EOperativeBarrierState                        BarrierState;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RedeployLocation;                                  // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RedeployRotation;                                  // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsTransitioningStates;                            // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOperativeBarrierState) == 0x000004, "Wrong alignment on FOperativeBarrierState");
static_assert(sizeof(FOperativeBarrierState) == 0x000020, "Wrong size on FOperativeBarrierState");
static_assert(offsetof(FOperativeBarrierState, BarrierState) == 0x000000, "Member 'FOperativeBarrierState::BarrierState' has a wrong offset!");
static_assert(offsetof(FOperativeBarrierState, RedeployLocation) == 0x000004, "Member 'FOperativeBarrierState::RedeployLocation' has a wrong offset!");
static_assert(offsetof(FOperativeBarrierState, RedeployRotation) == 0x000010, "Member 'FOperativeBarrierState::RedeployRotation' has a wrong offset!");
static_assert(offsetof(FOperativeBarrierState, bIsTransitioningStates) == 0x00001C, "Member 'FOperativeBarrierState::bIsTransitioningStates' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityResourceSpec_SirenRushStack
// 0x0010 (0x0020 - 0x0010)
struct FOakAbilityResourceSpec_SirenRushStack final : public FGbxAbilityResourceSpec
{
public:
	class USirenCharacterComponent*               SirenComponent;                                    // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USirenRushStackData*                    RushStackData;                                     // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakAbilityResourceSpec_SirenRushStack) == 0x000008, "Wrong alignment on FOakAbilityResourceSpec_SirenRushStack");
static_assert(sizeof(FOakAbilityResourceSpec_SirenRushStack) == 0x000020, "Wrong size on FOakAbilityResourceSpec_SirenRushStack");
static_assert(offsetof(FOakAbilityResourceSpec_SirenRushStack, SirenComponent) == 0x000010, "Member 'FOakAbilityResourceSpec_SirenRushStack::SirenComponent' has a wrong offset!");
static_assert(offsetof(FOakAbilityResourceSpec_SirenRushStack, RushStackData) == 0x000018, "Member 'FOakAbilityResourceSpec_SirenRushStack::RushStackData' has a wrong offset!");

// ScriptStruct OakGame.VehicleOccupantLoopingFeedback
// 0x0020 (0x0020 - 0x0000)
struct FVehicleOccupantLoopingFeedback final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerController*>              AffectedControllers;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FVehicleOccupantLoopingFeedback) == 0x000008, "Wrong alignment on FVehicleOccupantLoopingFeedback");
static_assert(sizeof(FVehicleOccupantLoopingFeedback) == 0x000020, "Wrong size on FVehicleOccupantLoopingFeedback");
static_assert(offsetof(FVehicleOccupantLoopingFeedback, FeedbackData) == 0x000000, "Member 'FVehicleOccupantLoopingFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(FVehicleOccupantLoopingFeedback, AffectedControllers) == 0x000010, "Member 'FVehicleOccupantLoopingFeedback::AffectedControllers' has a wrong offset!");

// ScriptStruct OakGame.ResourcePoolSavegameData
// 0x0038 (0x0038 - 0x0000)
struct FResourcePoolSavegameData final
{
public:
	float                                         Amount;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGameResourceData>       ResourcePath;                                      // 0x0008(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourcePoolSavegameData) == 0x000008, "Wrong alignment on FResourcePoolSavegameData");
static_assert(sizeof(FResourcePoolSavegameData) == 0x000038, "Wrong size on FResourcePoolSavegameData");
static_assert(offsetof(FResourcePoolSavegameData, Amount) == 0x000000, "Member 'FResourcePoolSavegameData::Amount' has a wrong offset!");
static_assert(offsetof(FResourcePoolSavegameData, ResourcePath) == 0x000008, "Member 'FResourcePoolSavegameData::ResourcePath' has a wrong offset!");

// ScriptStruct OakGame.AutoplayAction
// 0x0020 (0x0020 - 0x0000)
struct FAutoplayAction final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoplayAction) == 0x000008, "Wrong alignment on FAutoplayAction");
static_assert(sizeof(FAutoplayAction) == 0x000020, "Wrong size on FAutoplayAction");
static_assert(offsetof(FAutoplayAction, Target) == 0x000000, "Member 'FAutoplayAction::Target' has a wrong offset!");

// ScriptStruct OakGame.HornSequenceEntry
// 0x0008 (0x0008 - 0x0000)
struct FHornSequenceEntry final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHornSequenceEntry) == 0x000004, "Wrong alignment on FHornSequenceEntry");
static_assert(sizeof(FHornSequenceEntry) == 0x000008, "Wrong size on FHornSequenceEntry");
static_assert(offsetof(FHornSequenceEntry, StartTime) == 0x000000, "Member 'FHornSequenceEntry::StartTime' has a wrong offset!");
static_assert(offsetof(FHornSequenceEntry, Duration) == 0x000004, "Member 'FHornSequenceEntry::Duration' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakAnim_TedioreReload
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakAnim_TedioreReload final : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakAnim_TedioreReload) == 0x000008, "Wrong alignment on FActionState_OakAnim_TedioreReload");
static_assert(sizeof(FActionState_OakAnim_TedioreReload) == 0x000520, "Wrong size on FActionState_OakAnim_TedioreReload");

// ScriptStruct OakGame.ReplicatedInteractionInfo
// 0x0020 (0x0020 - 0x0000)
struct FReplicatedInteractionInfo final
{
public:
	TArray<class UMaterialInterface*>             OriginalMaterials;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   HandSocketName;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGhostedMaterialOn;                                // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttractEmitterOn;                                 // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedInteractionInfo) == 0x000008, "Wrong alignment on FReplicatedInteractionInfo");
static_assert(sizeof(FReplicatedInteractionInfo) == 0x000020, "Wrong size on FReplicatedInteractionInfo");
static_assert(offsetof(FReplicatedInteractionInfo, OriginalMaterials) == 0x000000, "Member 'FReplicatedInteractionInfo::OriginalMaterials' has a wrong offset!");
static_assert(offsetof(FReplicatedInteractionInfo, HandSocketName) == 0x000010, "Member 'FReplicatedInteractionInfo::HandSocketName' has a wrong offset!");
static_assert(offsetof(FReplicatedInteractionInfo, bGhostedMaterialOn) == 0x000018, "Member 'FReplicatedInteractionInfo::bGhostedMaterialOn' has a wrong offset!");
static_assert(offsetof(FReplicatedInteractionInfo, bAttractEmitterOn) == 0x000019, "Member 'FReplicatedInteractionInfo::bAttractEmitterOn' has a wrong offset!");

// ScriptStruct OakGame.CreditsLineInfo
// 0x0020 (0x0020 - 0x0000)
struct FCreditsLineInfo final
{
public:
	class FName                                   StyleId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextEntry;                                         // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditsLineInfo) == 0x000008, "Wrong alignment on FCreditsLineInfo");
static_assert(sizeof(FCreditsLineInfo) == 0x000020, "Wrong size on FCreditsLineInfo");
static_assert(offsetof(FCreditsLineInfo, StyleId) == 0x000000, "Member 'FCreditsLineInfo::StyleId' has a wrong offset!");
static_assert(offsetof(FCreditsLineInfo, TextEntry) == 0x000008, "Member 'FCreditsLineInfo::TextEntry' has a wrong offset!");

// ScriptStruct OakGame.VendingMachineMenuFilter
// 0x0020 (0x0020 - 0x0000)
struct FVendingMachineMenuFilter final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 DataTypeFilter;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingMachineMenuFilter) == 0x000008, "Wrong alignment on FVendingMachineMenuFilter");
static_assert(sizeof(FVendingMachineMenuFilter) == 0x000020, "Wrong size on FVendingMachineMenuFilter");
static_assert(offsetof(FVendingMachineMenuFilter, Name) == 0x000000, "Member 'FVendingMachineMenuFilter::Name' has a wrong offset!");
static_assert(offsetof(FVendingMachineMenuFilter, DataTypeFilter) == 0x000018, "Member 'FVendingMachineMenuFilter::DataTypeFilter' has a wrong offset!");

// ScriptStruct OakGame.FloorSectorDistance
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FFloorSectorDistance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloorSectorDistance) == 0x000004, "Wrong alignment on FFloorSectorDistance");
static_assert(sizeof(FFloorSectorDistance) == 0x000008, "Wrong size on FFloorSectorDistance");

// ScriptStruct OakGame.GFxEchoNetMathcmakingActivitySubTypeData
// 0x0058 (0x0058 - 0x0000)
struct FGFxEchoNetMathcmakingActivitySubTypeData final
{
public:
	class FString                                 Guid;                                              // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFeatured;                                         // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHeroic;                                         // 0x0012(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxEchoNetMathcmakingActivitySubTypeData) == 0x000008, "Wrong alignment on FGFxEchoNetMathcmakingActivitySubTypeData");
static_assert(sizeof(FGFxEchoNetMathcmakingActivitySubTypeData) == 0x000058, "Wrong size on FGFxEchoNetMathcmakingActivitySubTypeData");
static_assert(offsetof(FGFxEchoNetMathcmakingActivitySubTypeData, Guid) == 0x000000, "Member 'FGFxEchoNetMathcmakingActivitySubTypeData::Guid' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMathcmakingActivitySubTypeData, bLocked) == 0x000010, "Member 'FGFxEchoNetMathcmakingActivitySubTypeData::bLocked' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMathcmakingActivitySubTypeData, bFeatured) == 0x000011, "Member 'FGFxEchoNetMathcmakingActivitySubTypeData::bFeatured' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMathcmakingActivitySubTypeData, bIsHeroic) == 0x000012, "Member 'FGFxEchoNetMathcmakingActivitySubTypeData::bIsHeroic' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMathcmakingActivitySubTypeData, Name) == 0x000018, "Member 'FGFxEchoNetMathcmakingActivitySubTypeData::Name' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMathcmakingActivitySubTypeData, Description) == 0x000030, "Member 'FGFxEchoNetMathcmakingActivitySubTypeData::Description' has a wrong offset!");

// ScriptStruct OakGame.CarnivoraDamageZoneInfo
// 0x000C (0x000C - 0x0000)
struct FCarnivoraDamageZoneInfo final
{
public:
	float                                         FrontDamageMultiplier;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideDamageMultiplier;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackDamageMultiplier;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarnivoraDamageZoneInfo) == 0x000004, "Wrong alignment on FCarnivoraDamageZoneInfo");
static_assert(sizeof(FCarnivoraDamageZoneInfo) == 0x00000C, "Wrong size on FCarnivoraDamageZoneInfo");
static_assert(offsetof(FCarnivoraDamageZoneInfo, FrontDamageMultiplier) == 0x000000, "Member 'FCarnivoraDamageZoneInfo::FrontDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCarnivoraDamageZoneInfo, SideDamageMultiplier) == 0x000004, "Member 'FCarnivoraDamageZoneInfo::SideDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCarnivoraDamageZoneInfo, BackDamageMultiplier) == 0x000008, "Member 'FCarnivoraDamageZoneInfo::BackDamageMultiplier' has a wrong offset!");

// ScriptStruct OakGame.InventorySlotEntry
// 0x0034 (0x0040 - 0x000C)
struct FInventorySlotEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EquippedInventory;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Selected;                                          // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventorySlotData*                     SlotData;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTrinketPartData*                 EquippedTrinket;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ClientCachedEquippedInventory;                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWeaponTrinketPartData*                 ClientCachedEquippedTrinket;                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInventorySlotEntry) == 0x000008, "Wrong alignment on FInventorySlotEntry");
static_assert(sizeof(FInventorySlotEntry) == 0x000040, "Wrong size on FInventorySlotEntry");
static_assert(offsetof(FInventorySlotEntry, EquippedInventory) == 0x000010, "Member 'FInventorySlotEntry::EquippedInventory' has a wrong offset!");
static_assert(offsetof(FInventorySlotEntry, Enabled) == 0x000018, "Member 'FInventorySlotEntry::Enabled' has a wrong offset!");
static_assert(offsetof(FInventorySlotEntry, Selected) == 0x000019, "Member 'FInventorySlotEntry::Selected' has a wrong offset!");
static_assert(offsetof(FInventorySlotEntry, SlotData) == 0x000020, "Member 'FInventorySlotEntry::SlotData' has a wrong offset!");
static_assert(offsetof(FInventorySlotEntry, EquippedTrinket) == 0x000028, "Member 'FInventorySlotEntry::EquippedTrinket' has a wrong offset!");
static_assert(offsetof(FInventorySlotEntry, ClientCachedEquippedInventory) == 0x000030, "Member 'FInventorySlotEntry::ClientCachedEquippedInventory' has a wrong offset!");
static_assert(offsetof(FInventorySlotEntry, ClientCachedEquippedTrinket) == 0x000038, "Member 'FInventorySlotEntry::ClientCachedEquippedTrinket' has a wrong offset!");

// ScriptStruct OakGame.SelectedInventorySpawningState
// 0x00E0 (0x00E0 - 0x0000)
struct FSelectedInventorySpawningState final
{
public:
	struct FSelectedInventoryInfo                 SeletedInventoryInfo;                              // 0x0000(0x0060)(NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryBalanceStateInitializationData InitData;                                          // 0x0068(0x0068)(NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectedInventorySpawningState) == 0x000008, "Wrong alignment on FSelectedInventorySpawningState");
static_assert(sizeof(FSelectedInventorySpawningState) == 0x0000E0, "Wrong size on FSelectedInventorySpawningState");
static_assert(offsetof(FSelectedInventorySpawningState, SeletedInventoryInfo) == 0x000000, "Member 'FSelectedInventorySpawningState::SeletedInventoryInfo' has a wrong offset!");
static_assert(offsetof(FSelectedInventorySpawningState, InitData) == 0x000068, "Member 'FSelectedInventorySpawningState::InitData' has a wrong offset!");

// ScriptStruct OakGame.GFxCurrencyCounterQueueInfo
// 0x0028 (0x0028 - 0x0000)
struct FGFxCurrencyCounterQueueInfo final
{
public:
	class UInventoryCategoryData*                 ItemCategory;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeltaValue;                                        // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartTotal;                                        // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FinalTotal;                                        // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartAudioEvent;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StopAudioEvent;                                    // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxCurrencyCounterQueueInfo) == 0x000008, "Wrong alignment on FGFxCurrencyCounterQueueInfo");
static_assert(sizeof(FGFxCurrencyCounterQueueInfo) == 0x000028, "Wrong size on FGFxCurrencyCounterQueueInfo");
static_assert(offsetof(FGFxCurrencyCounterQueueInfo, ItemCategory) == 0x000000, "Member 'FGFxCurrencyCounterQueueInfo::ItemCategory' has a wrong offset!");
static_assert(offsetof(FGFxCurrencyCounterQueueInfo, DeltaValue) == 0x000008, "Member 'FGFxCurrencyCounterQueueInfo::DeltaValue' has a wrong offset!");
static_assert(offsetof(FGFxCurrencyCounterQueueInfo, StartTotal) == 0x00000C, "Member 'FGFxCurrencyCounterQueueInfo::StartTotal' has a wrong offset!");
static_assert(offsetof(FGFxCurrencyCounterQueueInfo, FinalTotal) == 0x000010, "Member 'FGFxCurrencyCounterQueueInfo::FinalTotal' has a wrong offset!");
static_assert(offsetof(FGFxCurrencyCounterQueueInfo, StartAudioEvent) == 0x000018, "Member 'FGFxCurrencyCounterQueueInfo::StartAudioEvent' has a wrong offset!");
static_assert(offsetof(FGFxCurrencyCounterQueueInfo, StopAudioEvent) == 0x000020, "Member 'FGFxCurrencyCounterQueueInfo::StopAudioEvent' has a wrong offset!");

// ScriptStruct OakGame.LootableInteractionResponse
// 0x0010 (0x0010 - 0x0000)
struct FLootableInteractionResponse final
{
public:
	class UAnimSequence*                          TransitionAnimation;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnimation;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootableInteractionResponse) == 0x000008, "Wrong alignment on FLootableInteractionResponse");
static_assert(sizeof(FLootableInteractionResponse) == 0x000010, "Wrong size on FLootableInteractionResponse");
static_assert(offsetof(FLootableInteractionResponse, TransitionAnimation) == 0x000000, "Member 'FLootableInteractionResponse::TransitionAnimation' has a wrong offset!");
static_assert(offsetof(FLootableInteractionResponse, IdleAnimation) == 0x000008, "Member 'FLootableInteractionResponse::IdleAnimation' has a wrong offset!");

// ScriptStruct OakGame.LootableDirectionalResponse
// 0x0018 (0x0018 - 0x0000)
struct FLootableDirectionalResponse final
{
public:
	struct FNumericRange                          AngleRange;                                        // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLootableInteractionResponse>   Interactions;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootableDirectionalResponse) == 0x000008, "Wrong alignment on FLootableDirectionalResponse");
static_assert(sizeof(FLootableDirectionalResponse) == 0x000018, "Wrong size on FLootableDirectionalResponse");
static_assert(offsetof(FLootableDirectionalResponse, AngleRange) == 0x000000, "Member 'FLootableDirectionalResponse::AngleRange' has a wrong offset!");
static_assert(offsetof(FLootableDirectionalResponse, Interactions) == 0x000008, "Member 'FLootableDirectionalResponse::Interactions' has a wrong offset!");

// ScriptStruct OakGame.GFxMissionTrackerAnimationData
// 0x0060 (0x0060 - 0x0000)
struct FGFxMissionTrackerAnimationData final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	EGFxMissionTrackerAnimationType               AnimationType;                                     // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMissionObjectiveReference             MissionObjectiveLink;                              // 0x0020(0x0030)(Transient, NativeAccessSpecifierPublic)
	class UGFxMissionTrackerSlot*                 OptionalSlotToClearOut;                            // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxMissionTrackerAnimationData) == 0x000008, "Wrong alignment on FGFxMissionTrackerAnimationData");
static_assert(sizeof(FGFxMissionTrackerAnimationData) == 0x000060, "Wrong size on FGFxMissionTrackerAnimationData");
static_assert(offsetof(FGFxMissionTrackerAnimationData, Description) == 0x000000, "Member 'FGFxMissionTrackerAnimationData::Description' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerAnimationData, AnimationType) == 0x000018, "Member 'FGFxMissionTrackerAnimationData::AnimationType' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerAnimationData, MissionObjectiveLink) == 0x000020, "Member 'FGFxMissionTrackerAnimationData::MissionObjectiveLink' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerAnimationData, OptionalSlotToClearOut) == 0x000050, "Member 'FGFxMissionTrackerAnimationData::OptionalSlotToClearOut' has a wrong offset!");

// ScriptStruct OakGame.GameStatSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FGameStatSaveGameData final
{
public:
	int32                                         StatValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGameStatData>           StatPath;                                          // 0x0008(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameStatSaveGameData) == 0x000008, "Wrong alignment on FGameStatSaveGameData");
static_assert(sizeof(FGameStatSaveGameData) == 0x000030, "Wrong size on FGameStatSaveGameData");
static_assert(offsetof(FGameStatSaveGameData, StatValue) == 0x000000, "Member 'FGameStatSaveGameData::StatValue' has a wrong offset!");
static_assert(offsetof(FGameStatSaveGameData, StatPath) == 0x000008, "Member 'FGameStatSaveGameData::StatPath' has a wrong offset!");

// ScriptStruct OakGame.PlayerClassInfo
// 0x0030 (0x0030 - 0x0000)
struct FPlayerClassInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayerStandInActorName;                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorSocketName;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextOffset;                                        // 0x0018(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DefaultPosition;                                   // 0x0020(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerClassIdentifier*                 PlayerClassId;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerClassInfo) == 0x000008, "Wrong alignment on FPlayerClassInfo");
static_assert(sizeof(FPlayerClassInfo) == 0x000030, "Wrong size on FPlayerClassInfo");
static_assert(offsetof(FPlayerClassInfo, PlayerStandInActorName) == 0x000008, "Member 'FPlayerClassInfo::PlayerStandInActorName' has a wrong offset!");
static_assert(offsetof(FPlayerClassInfo, ActorSocketName) == 0x000010, "Member 'FPlayerClassInfo::ActorSocketName' has a wrong offset!");
static_assert(offsetof(FPlayerClassInfo, TextOffset) == 0x000018, "Member 'FPlayerClassInfo::TextOffset' has a wrong offset!");
static_assert(offsetof(FPlayerClassInfo, DefaultPosition) == 0x000020, "Member 'FPlayerClassInfo::DefaultPosition' has a wrong offset!");
static_assert(offsetof(FPlayerClassInfo, PlayerClassId) == 0x000028, "Member 'FPlayerClassInfo::PlayerClassId' has a wrong offset!");

// ScriptStruct OakGame.OakLevelSyncMessageText
// 0x0050 (0x0050 - 0x0000)
struct FOakLevelSyncMessageText final
{
public:
	class FText                                   TitleText;                                         // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   PlayerStateDescriptionText;                        // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AnonymousDescriptionText;                          // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         OnScreenDuration;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakLevelSyncMessageText) == 0x000008, "Wrong alignment on FOakLevelSyncMessageText");
static_assert(sizeof(FOakLevelSyncMessageText) == 0x000050, "Wrong size on FOakLevelSyncMessageText");
static_assert(offsetof(FOakLevelSyncMessageText, TitleText) == 0x000000, "Member 'FOakLevelSyncMessageText::TitleText' has a wrong offset!");
static_assert(offsetof(FOakLevelSyncMessageText, PlayerStateDescriptionText) == 0x000018, "Member 'FOakLevelSyncMessageText::PlayerStateDescriptionText' has a wrong offset!");
static_assert(offsetof(FOakLevelSyncMessageText, AnonymousDescriptionText) == 0x000030, "Member 'FOakLevelSyncMessageText::AnonymousDescriptionText' has a wrong offset!");
static_assert(offsetof(FOakLevelSyncMessageText, OnScreenDuration) == 0x000048, "Member 'FOakLevelSyncMessageText::OnScreenDuration' has a wrong offset!");

// ScriptStruct OakGame.OakGenderData
// 0x0098 (0x0098 - 0x0000)
struct FOakGenderData final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshOffset;                                        // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGestaltPartListData*                   GestaltPartList;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimBlueprint;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimSetGenericNames_Enable;                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimSetGenericNames_Disable;                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGbxAnimSet*>                    AnimSets_Enable;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGbxAnimSet*>                    AnimSets_Disable;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              Materials;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogNameTag*>                 DialogNameTags;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDestructibleMesh*                      CryoMesh;                                          // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoreSourceMaterialIndex;                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakGenderData) == 0x000008, "Wrong alignment on FOakGenderData");
static_assert(sizeof(FOakGenderData) == 0x000098, "Wrong size on FOakGenderData");
static_assert(offsetof(FOakGenderData, Mesh) == 0x000000, "Member 'FOakGenderData::Mesh' has a wrong offset!");
static_assert(offsetof(FOakGenderData, MeshOffset) == 0x000008, "Member 'FOakGenderData::MeshOffset' has a wrong offset!");
static_assert(offsetof(FOakGenderData, GestaltPartList) == 0x000018, "Member 'FOakGenderData::GestaltPartList' has a wrong offset!");
static_assert(offsetof(FOakGenderData, AnimBlueprint) == 0x000020, "Member 'FOakGenderData::AnimBlueprint' has a wrong offset!");
static_assert(offsetof(FOakGenderData, AnimSetGenericNames_Enable) == 0x000028, "Member 'FOakGenderData::AnimSetGenericNames_Enable' has a wrong offset!");
static_assert(offsetof(FOakGenderData, AnimSetGenericNames_Disable) == 0x000038, "Member 'FOakGenderData::AnimSetGenericNames_Disable' has a wrong offset!");
static_assert(offsetof(FOakGenderData, AnimSets_Enable) == 0x000048, "Member 'FOakGenderData::AnimSets_Enable' has a wrong offset!");
static_assert(offsetof(FOakGenderData, AnimSets_Disable) == 0x000058, "Member 'FOakGenderData::AnimSets_Disable' has a wrong offset!");
static_assert(offsetof(FOakGenderData, Materials) == 0x000068, "Member 'FOakGenderData::Materials' has a wrong offset!");
static_assert(offsetof(FOakGenderData, DialogNameTags) == 0x000078, "Member 'FOakGenderData::DialogNameTags' has a wrong offset!");
static_assert(offsetof(FOakGenderData, CryoMesh) == 0x000088, "Member 'FOakGenderData::CryoMesh' has a wrong offset!");
static_assert(offsetof(FOakGenderData, GoreSourceMaterialIndex) == 0x000090, "Member 'FOakGenderData::GoreSourceMaterialIndex' has a wrong offset!");

// ScriptStruct OakGame.GFxMenuTutorialState
// 0x00D0 (0x00D0 - 0x0000)
struct FGFxMenuTutorialState final
{
public:
	EGFxMenuTutorialDialogSize                    DialogSize;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxMenuTutorialFocusDirection                FocusDirection;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxMenuTutorialFocusDirection                SplitScreenFocusDirection;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxMenuTutorialFocusDirection                VerticalSplitScreenFocusDirection;                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxMenuTutorialFocusDirection                QuadSplitScreenFocusDirection;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DialogOffset;                                      // 0x0014(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SplitScreenDialogOffset;                           // 0x001C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VerticalSplitScreenDialogOffset;                   // 0x0024(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              QuadSplitScreenDialogOffset;                       // 0x002C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeaderText;                                        // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           VisibleTintClipsNames;                             // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SplitScreenVisibleTintClipsNames;                  // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           VerticalSplitScreenVisibleTintClipsNames;          // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           QuadSplitScreenVisibleTintClipsNames;              // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AllowedInputAxes;                                  // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AllowedInputActions;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAdvanceOnKeyPress;                                // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTutorialSkip;                                // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxMenuTutorialState) == 0x000008, "Wrong alignment on FGFxMenuTutorialState");
static_assert(sizeof(FGFxMenuTutorialState) == 0x0000D0, "Wrong size on FGFxMenuTutorialState");
static_assert(offsetof(FGFxMenuTutorialState, DialogSize) == 0x000000, "Member 'FGFxMenuTutorialState::DialogSize' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, FocusDirection) == 0x000004, "Member 'FGFxMenuTutorialState::FocusDirection' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, SplitScreenFocusDirection) == 0x000008, "Member 'FGFxMenuTutorialState::SplitScreenFocusDirection' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, VerticalSplitScreenFocusDirection) == 0x00000C, "Member 'FGFxMenuTutorialState::VerticalSplitScreenFocusDirection' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, QuadSplitScreenFocusDirection) == 0x000010, "Member 'FGFxMenuTutorialState::QuadSplitScreenFocusDirection' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, DialogOffset) == 0x000014, "Member 'FGFxMenuTutorialState::DialogOffset' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, SplitScreenDialogOffset) == 0x00001C, "Member 'FGFxMenuTutorialState::SplitScreenDialogOffset' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, VerticalSplitScreenDialogOffset) == 0x000024, "Member 'FGFxMenuTutorialState::VerticalSplitScreenDialogOffset' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, QuadSplitScreenDialogOffset) == 0x00002C, "Member 'FGFxMenuTutorialState::QuadSplitScreenDialogOffset' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, HeaderText) == 0x000038, "Member 'FGFxMenuTutorialState::HeaderText' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, BodyText) == 0x000050, "Member 'FGFxMenuTutorialState::BodyText' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, VisibleTintClipsNames) == 0x000068, "Member 'FGFxMenuTutorialState::VisibleTintClipsNames' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, SplitScreenVisibleTintClipsNames) == 0x000078, "Member 'FGFxMenuTutorialState::SplitScreenVisibleTintClipsNames' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, VerticalSplitScreenVisibleTintClipsNames) == 0x000088, "Member 'FGFxMenuTutorialState::VerticalSplitScreenVisibleTintClipsNames' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, QuadSplitScreenVisibleTintClipsNames) == 0x000098, "Member 'FGFxMenuTutorialState::QuadSplitScreenVisibleTintClipsNames' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, AllowedInputAxes) == 0x0000A8, "Member 'FGFxMenuTutorialState::AllowedInputAxes' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, AllowedInputActions) == 0x0000B8, "Member 'FGFxMenuTutorialState::AllowedInputActions' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, bAdvanceOnKeyPress) == 0x0000C8, "Member 'FGFxMenuTutorialState::bAdvanceOnKeyPress' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialState, bAllowTutorialSkip) == 0x0000C9, "Member 'FGFxMenuTutorialState::bAllowTutorialSkip' has a wrong offset!");

// ScriptStruct OakGame.GFxMenuTutorialSequence
// 0x0010 (0x0010 - 0x0000)
struct FGFxMenuTutorialSequence final
{
public:
	TArray<struct FGFxMenuTutorialState>          SequenceList;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMenuTutorialSequence) == 0x000008, "Wrong alignment on FGFxMenuTutorialSequence");
static_assert(sizeof(FGFxMenuTutorialSequence) == 0x000010, "Wrong size on FGFxMenuTutorialSequence");
static_assert(offsetof(FGFxMenuTutorialSequence, SequenceList) == 0x000000, "Member 'FGFxMenuTutorialSequence::SequenceList' has a wrong offset!");

// ScriptStruct OakGame.GFxMenuTutorial
// 0x0018 (0x0018 - 0x0000)
struct FGFxMenuTutorial final
{
public:
	class FName                                   TutorialName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGFxMenuTutorialSequence               TutorialSequence;                                  // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMenuTutorial) == 0x000008, "Wrong alignment on FGFxMenuTutorial");
static_assert(sizeof(FGFxMenuTutorial) == 0x000018, "Wrong size on FGFxMenuTutorial");
static_assert(offsetof(FGFxMenuTutorial, TutorialName) == 0x000000, "Member 'FGFxMenuTutorial::TutorialName' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorial, TutorialSequence) == 0x000008, "Member 'FGFxMenuTutorial::TutorialSequence' has a wrong offset!");

// ScriptStruct OakGame.GFxMenuTutorialTintClipData
// 0x0020 (0x0020 - 0x0000)
struct FGFxMenuTutorialTintClipData final
{
public:
	class FName                                   TintClipName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TintClipPath;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          TintClip;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMenuTutorialTintClipData) == 0x000008, "Wrong alignment on FGFxMenuTutorialTintClipData");
static_assert(sizeof(FGFxMenuTutorialTintClipData) == 0x000020, "Wrong size on FGFxMenuTutorialTintClipData");
static_assert(offsetof(FGFxMenuTutorialTintClipData, TintClipName) == 0x000000, "Member 'FGFxMenuTutorialTintClipData::TintClipName' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialTintClipData, TintClipPath) == 0x000008, "Member 'FGFxMenuTutorialTintClipData::TintClipPath' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialTintClipData, TintClip) == 0x000018, "Member 'FGFxMenuTutorialTintClipData::TintClip' has a wrong offset!");

// ScriptStruct OakGame.GFxMenuTutorialCollection
// 0x0020 (0x0020 - 0x0000)
struct FGFxMenuTutorialCollection final
{
public:
	TArray<struct FGFxMenuTutorial>               Tutorials;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGFxMenuTutorialTintClipData>   TintClips;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMenuTutorialCollection) == 0x000008, "Wrong alignment on FGFxMenuTutorialCollection");
static_assert(sizeof(FGFxMenuTutorialCollection) == 0x000020, "Wrong size on FGFxMenuTutorialCollection");
static_assert(offsetof(FGFxMenuTutorialCollection, Tutorials) == 0x000000, "Member 'FGFxMenuTutorialCollection::Tutorials' has a wrong offset!");
static_assert(offsetof(FGFxMenuTutorialCollection, TintClips) == 0x000010, "Member 'FGFxMenuTutorialCollection::TintClips' has a wrong offset!");

// ScriptStruct OakGame.InventorySlotContainer
// 0x0038 (0x00E8 - 0x00B0)
struct FInventorySlotContainer final : public FFastArraySerializer
{
public:
	TArray<struct FInventorySlotEntry>            InventorySlots;                                    // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySlotContainer) == 0x000008, "Wrong alignment on FInventorySlotContainer");
static_assert(sizeof(FInventorySlotContainer) == 0x0000E8, "Wrong size on FInventorySlotContainer");
static_assert(offsetof(FInventorySlotContainer, InventorySlots) == 0x0000B0, "Member 'FInventorySlotContainer::InventorySlots' has a wrong offset!");

// ScriptStruct OakGame.CharacterCorpseState
// 0x00E8 (0x00E8 - 0x0000)
struct alignas(0x08) FCharacterCorpseState final
{
public:
	uint8                                         bEnableCorpseCleanup : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldTearOff : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideVisibleCorpseRemovalTime : 1;             // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideVisibleCorpseRemovalTime;                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactWithVehiclesTime;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xDC];                                       // 0x000C(0x00DC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterCorpseState) == 0x000008, "Wrong alignment on FCharacterCorpseState");
static_assert(sizeof(FCharacterCorpseState) == 0x0000E8, "Wrong size on FCharacterCorpseState");
static_assert(offsetof(FCharacterCorpseState, OverrideVisibleCorpseRemovalTime) == 0x000004, "Member 'FCharacterCorpseState::OverrideVisibleCorpseRemovalTime' has a wrong offset!");
static_assert(offsetof(FCharacterCorpseState, ContactWithVehiclesTime) == 0x000008, "Member 'FCharacterCorpseState::ContactWithVehiclesTime' has a wrong offset!");

// ScriptStruct OakGame.MusicLayer
// 0x0008 (0x0008 - 0x0000)
struct FMusicLayer final
{
public:
	float                                         InterestMin;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestMax;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicLayer) == 0x000004, "Wrong alignment on FMusicLayer");
static_assert(sizeof(FMusicLayer) == 0x000008, "Wrong size on FMusicLayer");
static_assert(offsetof(FMusicLayer, InterestMin) == 0x000000, "Member 'FMusicLayer::InterestMin' has a wrong offset!");
static_assert(offsetof(FMusicLayer, InterestMax) == 0x000004, "Member 'FMusicLayer::InterestMax' has a wrong offset!");

// ScriptStruct OakGame.MusicPart
// 0x0060 (0x0060 - 0x0000)
struct FMusicPart final
{
public:
	int32                                         UpdateIntervalInBeats;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestMin;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestMax;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EOakMusicLayer, struct FMusicLayer>      AssociatedMusicLayers;                             // 0x0010(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicPart) == 0x000008, "Wrong alignment on FMusicPart");
static_assert(sizeof(FMusicPart) == 0x000060, "Wrong size on FMusicPart");
static_assert(offsetof(FMusicPart, UpdateIntervalInBeats) == 0x000000, "Member 'FMusicPart::UpdateIntervalInBeats' has a wrong offset!");
static_assert(offsetof(FMusicPart, InterestMin) == 0x000004, "Member 'FMusicPart::InterestMin' has a wrong offset!");
static_assert(offsetof(FMusicPart, InterestMax) == 0x000008, "Member 'FMusicPart::InterestMax' has a wrong offset!");
static_assert(offsetof(FMusicPart, AssociatedMusicLayers) == 0x000010, "Member 'FMusicPart::AssociatedMusicLayers' has a wrong offset!");

// ScriptStruct OakGame.VaultCardGearRewardInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FVaultCardGearRewardInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultCardGearRewardInfo) == 0x000004, "Wrong alignment on FVaultCardGearRewardInfo");
static_assert(sizeof(FVaultCardGearRewardInfo) == 0x000008, "Wrong size on FVaultCardGearRewardInfo");

// ScriptStruct OakGame.OakVehicleAnimInstanceProxy
// 0x00A0 (0x0780 - 0x06E0)
struct FOakVehicleAnimInstanceProxy : public FVehicleAnimInstanceProxy
{
public:
	uint8                                         Pad_6E0[0xA0];                                     // 0x06E0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakVehicleAnimInstanceProxy) == 0x000010, "Wrong alignment on FOakVehicleAnimInstanceProxy");
static_assert(sizeof(FOakVehicleAnimInstanceProxy) == 0x000780, "Wrong size on FOakVehicleAnimInstanceProxy");

// ScriptStruct OakGame.RegisteredWeaponShotModifier
// 0x0020 (0x0020 - 0x0000)
struct FRegisteredWeaponShotModifier final
{
public:
	class UWeaponShotModifier*                    Modifier;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Owner;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextOverride;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegisteredWeaponShotModifier) == 0x000008, "Wrong alignment on FRegisteredWeaponShotModifier");
static_assert(sizeof(FRegisteredWeaponShotModifier) == 0x000020, "Wrong size on FRegisteredWeaponShotModifier");
static_assert(offsetof(FRegisteredWeaponShotModifier, Modifier) == 0x000000, "Member 'FRegisteredWeaponShotModifier::Modifier' has a wrong offset!");
static_assert(offsetof(FRegisteredWeaponShotModifier, Owner) == 0x000008, "Member 'FRegisteredWeaponShotModifier::Owner' has a wrong offset!");
static_assert(offsetof(FRegisteredWeaponShotModifier, ContextOverride) == 0x000010, "Member 'FRegisteredWeaponShotModifier::ContextOverride' has a wrong offset!");

// ScriptStruct OakGame.DiscoveryIOData
// 0x0060 (0x0060 - 0x0000)
struct FDiscoveryIOData final
{
public:
	class UDownloadableExpansionData*             DownloadableExpansionData;                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   Class;                                             // 0x0008(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             Transform;                                         // 0x0030(0x0030)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDiscoveryIOData) == 0x000010, "Wrong alignment on FDiscoveryIOData");
static_assert(sizeof(FDiscoveryIOData) == 0x000060, "Wrong size on FDiscoveryIOData");
static_assert(offsetof(FDiscoveryIOData, DownloadableExpansionData) == 0x000000, "Member 'FDiscoveryIOData::DownloadableExpansionData' has a wrong offset!");
static_assert(offsetof(FDiscoveryIOData, Class) == 0x000008, "Member 'FDiscoveryIOData::Class' has a wrong offset!");
static_assert(offsetof(FDiscoveryIOData, Transform) == 0x000030, "Member 'FDiscoveryIOData::Transform' has a wrong offset!");

// ScriptStruct OakGame.OakVehicleAdditiveData
// 0x0028 (0x0028 - 0x0000)
struct FOakVehicleAdditiveData final
{
public:
	float                                         VelocityMinTresholdForward;                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMaxTresholdForward;                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMinTresholdBackward;                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMaxTresholdBackward;                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMinTresholdLateral;                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMaxTresholdLateral;                        // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontBackMinInterpSpeed;                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontBackMaxInterpSpeed;                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftRightMinInterpSpeed;                           // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftRightMaxInterpSpeed;                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakVehicleAdditiveData) == 0x000004, "Wrong alignment on FOakVehicleAdditiveData");
static_assert(sizeof(FOakVehicleAdditiveData) == 0x000028, "Wrong size on FOakVehicleAdditiveData");
static_assert(offsetof(FOakVehicleAdditiveData, VelocityMinTresholdForward) == 0x000000, "Member 'FOakVehicleAdditiveData::VelocityMinTresholdForward' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, VelocityMaxTresholdForward) == 0x000004, "Member 'FOakVehicleAdditiveData::VelocityMaxTresholdForward' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, VelocityMinTresholdBackward) == 0x000008, "Member 'FOakVehicleAdditiveData::VelocityMinTresholdBackward' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, VelocityMaxTresholdBackward) == 0x00000C, "Member 'FOakVehicleAdditiveData::VelocityMaxTresholdBackward' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, VelocityMinTresholdLateral) == 0x000010, "Member 'FOakVehicleAdditiveData::VelocityMinTresholdLateral' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, VelocityMaxTresholdLateral) == 0x000014, "Member 'FOakVehicleAdditiveData::VelocityMaxTresholdLateral' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, FrontBackMinInterpSpeed) == 0x000018, "Member 'FOakVehicleAdditiveData::FrontBackMinInterpSpeed' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, FrontBackMaxInterpSpeed) == 0x00001C, "Member 'FOakVehicleAdditiveData::FrontBackMaxInterpSpeed' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, LeftRightMinInterpSpeed) == 0x000020, "Member 'FOakVehicleAdditiveData::LeftRightMinInterpSpeed' has a wrong offset!");
static_assert(offsetof(FOakVehicleAdditiveData, LeftRightMaxInterpSpeed) == 0x000024, "Member 'FOakVehicleAdditiveData::LeftRightMaxInterpSpeed' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentConfigurationSetting
// 0x0010 (0x0010 - 0x0000)
struct FOakActionAbilityAugmentConfigurationSetting final
{
public:
	class UOakActionAbilityAugmentSlotData*       ModSlotData;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOakActionAbilityAugmentData*           ModData;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentConfigurationSetting) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentConfigurationSetting");
static_assert(sizeof(FOakActionAbilityAugmentConfigurationSetting) == 0x000010, "Wrong size on FOakActionAbilityAugmentConfigurationSetting");
static_assert(offsetof(FOakActionAbilityAugmentConfigurationSetting, ModSlotData) == 0x000000, "Member 'FOakActionAbilityAugmentConfigurationSetting::ModSlotData' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentConfigurationSetting, ModData) == 0x000008, "Member 'FOakActionAbilityAugmentConfigurationSetting::ModData' has a wrong offset!");

// ScriptStruct OakGame.PawnAttachCameraModeOptions
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FPawnAttachCameraModeOptions final
{
public:
	float                                         AttachingBlendInTimeOverride;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PersistentBlendInTimeOverride;                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PersistentBlendOutTimeOverride;                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetachingBlendOutTimeOverride;                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachingMode;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersistentMode;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachingMode;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnAttachCameraModeOptions) == 0x000008, "Wrong alignment on FPawnAttachCameraModeOptions");
static_assert(sizeof(FPawnAttachCameraModeOptions) == 0x000028, "Wrong size on FPawnAttachCameraModeOptions");
static_assert(offsetof(FPawnAttachCameraModeOptions, AttachingBlendInTimeOverride) == 0x000000, "Member 'FPawnAttachCameraModeOptions::AttachingBlendInTimeOverride' has a wrong offset!");
static_assert(offsetof(FPawnAttachCameraModeOptions, PersistentBlendInTimeOverride) == 0x000004, "Member 'FPawnAttachCameraModeOptions::PersistentBlendInTimeOverride' has a wrong offset!");
static_assert(offsetof(FPawnAttachCameraModeOptions, PersistentBlendOutTimeOverride) == 0x000008, "Member 'FPawnAttachCameraModeOptions::PersistentBlendOutTimeOverride' has a wrong offset!");
static_assert(offsetof(FPawnAttachCameraModeOptions, DetachingBlendOutTimeOverride) == 0x00000C, "Member 'FPawnAttachCameraModeOptions::DetachingBlendOutTimeOverride' has a wrong offset!");
static_assert(offsetof(FPawnAttachCameraModeOptions, AttachingMode) == 0x000010, "Member 'FPawnAttachCameraModeOptions::AttachingMode' has a wrong offset!");
static_assert(offsetof(FPawnAttachCameraModeOptions, PersistentMode) == 0x000018, "Member 'FPawnAttachCameraModeOptions::PersistentMode' has a wrong offset!");
static_assert(offsetof(FPawnAttachCameraModeOptions, DetachingMode) == 0x000020, "Member 'FPawnAttachCameraModeOptions::DetachingMode' has a wrong offset!");

// ScriptStruct OakGame.VehicleInputParams
// 0x0038 (0x0038 - 0x0000)
struct FVehicleInputParams final
{
public:
	TSubclassOf<class UInputComponent>            InputComponentClass;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCameraOverride;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPawnAttachCameraModeOptions           DriverSeatCameraModeOptionsOverride;               // 0x0010(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleInputParams) == 0x000008, "Wrong alignment on FVehicleInputParams");
static_assert(sizeof(FVehicleInputParams) == 0x000038, "Wrong size on FVehicleInputParams");
static_assert(offsetof(FVehicleInputParams, InputComponentClass) == 0x000000, "Member 'FVehicleInputParams::InputComponentClass' has a wrong offset!");
static_assert(offsetof(FVehicleInputParams, bUseCameraOverride) == 0x000008, "Member 'FVehicleInputParams::bUseCameraOverride' has a wrong offset!");
static_assert(offsetof(FVehicleInputParams, DriverSeatCameraModeOptionsOverride) == 0x000010, "Member 'FVehicleInputParams::DriverSeatCameraModeOptionsOverride' has a wrong offset!");

// ScriptStruct OakGame.ReportReason
// 0x0020 (0x0020 - 0x0000)
struct FReportReason final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	EShiftReportReason                            Code;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReportReason) == 0x000008, "Wrong alignment on FReportReason");
static_assert(sizeof(FReportReason) == 0x000020, "Wrong size on FReportReason");
static_assert(offsetof(FReportReason, DisplayName) == 0x000000, "Member 'FReportReason::DisplayName' has a wrong offset!");
static_assert(offsetof(FReportReason, Code) == 0x000018, "Member 'FReportReason::Code' has a wrong offset!");

// ScriptStruct OakGame.InventoryUISaveGameData
// 0x000C (0x000C - 0x0000)
struct FInventoryUISaveGameData final
{
public:
	int32                                         PickupOrderIndex;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenSeenInInventoryMenu;                       // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkedAsFavorite;                                 // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkedAsJunk;                                     // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InventoryListIndex;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryUISaveGameData) == 0x000004, "Wrong alignment on FInventoryUISaveGameData");
static_assert(sizeof(FInventoryUISaveGameData) == 0x00000C, "Wrong size on FInventoryUISaveGameData");
static_assert(offsetof(FInventoryUISaveGameData, PickupOrderIndex) == 0x000000, "Member 'FInventoryUISaveGameData::PickupOrderIndex' has a wrong offset!");
static_assert(offsetof(FInventoryUISaveGameData, bHasBeenSeenInInventoryMenu) == 0x000004, "Member 'FInventoryUISaveGameData::bHasBeenSeenInInventoryMenu' has a wrong offset!");
static_assert(offsetof(FInventoryUISaveGameData, bMarkedAsFavorite) == 0x000005, "Member 'FInventoryUISaveGameData::bMarkedAsFavorite' has a wrong offset!");
static_assert(offsetof(FInventoryUISaveGameData, bMarkedAsJunk) == 0x000006, "Member 'FInventoryUISaveGameData::bMarkedAsJunk' has a wrong offset!");
static_assert(offsetof(FInventoryUISaveGameData, InventoryListIndex) == 0x000008, "Member 'FInventoryUISaveGameData::InventoryListIndex' has a wrong offset!");

// ScriptStruct OakGame.LootableEventResultItem
// 0x0060 (0x0060 - 0x0000)
struct FLootableEventResultItem final
{
public:
	int32                                         OrderIndex;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayNameIsInventoryDataName;                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInventoryNamePartData*>         DisplayNameParts;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SerialNumber;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MonetaryValue;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryScoreValue;                               // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAFoilPart;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedUIStatCollectionData            Stats;                                             // 0x0038(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 Base64EncodedThumbnail;                            // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryBalanceStateComponent*        BalanceStateComp;                                  // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootableEventResultItem) == 0x000008, "Wrong alignment on FLootableEventResultItem");
static_assert(sizeof(FLootableEventResultItem) == 0x000060, "Wrong size on FLootableEventResultItem");
static_assert(offsetof(FLootableEventResultItem, OrderIndex) == 0x000000, "Member 'FLootableEventResultItem::OrderIndex' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, bDisplayNameIsInventoryDataName) == 0x000004, "Member 'FLootableEventResultItem::bDisplayNameIsInventoryDataName' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, DisplayNameParts) == 0x000008, "Member 'FLootableEventResultItem::DisplayNameParts' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, SerialNumber) == 0x000018, "Member 'FLootableEventResultItem::SerialNumber' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, MonetaryValue) == 0x000028, "Member 'FLootableEventResultItem::MonetaryValue' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, InventoryScoreValue) == 0x00002C, "Member 'FLootableEventResultItem::InventoryScoreValue' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, bHasAFoilPart) == 0x000030, "Member 'FLootableEventResultItem::bHasAFoilPart' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, Stats) == 0x000038, "Member 'FLootableEventResultItem::Stats' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, Base64EncodedThumbnail) == 0x000048, "Member 'FLootableEventResultItem::Base64EncodedThumbnail' has a wrong offset!");
static_assert(offsetof(FLootableEventResultItem, BalanceStateComp) == 0x000058, "Member 'FLootableEventResultItem::BalanceStateComp' has a wrong offset!");

// ScriptStruct OakGame.VehicleTrailData
// 0x0050 (0x0050 - 0x0000)
struct FVehicleTrailData final
{
public:
	class FName                                   WheelFXSocketName;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WheelPhysBoneName;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x0010(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalRotationOffset;                               // 0x001C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TrailPSComponent;                                  // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               WadingPSComponent;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxVehicleWheel*                       WheelRef;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleTrailData) == 0x000008, "Wrong alignment on FVehicleTrailData");
static_assert(sizeof(FVehicleTrailData) == 0x000050, "Wrong size on FVehicleTrailData");
static_assert(offsetof(FVehicleTrailData, WheelFXSocketName) == 0x000000, "Member 'FVehicleTrailData::WheelFXSocketName' has a wrong offset!");
static_assert(offsetof(FVehicleTrailData, WheelPhysBoneName) == 0x000008, "Member 'FVehicleTrailData::WheelPhysBoneName' has a wrong offset!");
static_assert(offsetof(FVehicleTrailData, LocalOffset) == 0x000010, "Member 'FVehicleTrailData::LocalOffset' has a wrong offset!");
static_assert(offsetof(FVehicleTrailData, LocalRotationOffset) == 0x00001C, "Member 'FVehicleTrailData::LocalRotationOffset' has a wrong offset!");
static_assert(offsetof(FVehicleTrailData, TrailPSComponent) == 0x000028, "Member 'FVehicleTrailData::TrailPSComponent' has a wrong offset!");
static_assert(offsetof(FVehicleTrailData, WadingPSComponent) == 0x000030, "Member 'FVehicleTrailData::WadingPSComponent' has a wrong offset!");
static_assert(offsetof(FVehicleTrailData, WheelRef) == 0x000038, "Member 'FVehicleTrailData::WheelRef' has a wrong offset!");

// ScriptStruct OakGame.TrailVectorParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FTrailVectorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrailVectorParam) == 0x000008, "Wrong alignment on FTrailVectorParam");
static_assert(sizeof(FTrailVectorParam) == 0x000018, "Wrong size on FTrailVectorParam");
static_assert(offsetof(FTrailVectorParam, ParamName) == 0x000000, "Member 'FTrailVectorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FTrailVectorParam, Value) == 0x000008, "Member 'FTrailVectorParam::Value' has a wrong offset!");

// ScriptStruct OakGame.VehicleTrailParticleSystemData
// 0x0018 (0x0018 - 0x0000)
struct FVehicleTrailParticleSystemData final
{
public:
	class UParticleSystem*                        ParticleSystemTemplate;                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTrailVectorParam>              VectorParamsToSet;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleTrailParticleSystemData) == 0x000008, "Wrong alignment on FVehicleTrailParticleSystemData");
static_assert(sizeof(FVehicleTrailParticleSystemData) == 0x000018, "Wrong size on FVehicleTrailParticleSystemData");
static_assert(offsetof(FVehicleTrailParticleSystemData, ParticleSystemTemplate) == 0x000000, "Member 'FVehicleTrailParticleSystemData::ParticleSystemTemplate' has a wrong offset!");
static_assert(offsetof(FVehicleTrailParticleSystemData, VectorParamsToSet) == 0x000008, "Member 'FVehicleTrailParticleSystemData::VectorParamsToSet' has a wrong offset!");

// ScriptStruct OakGame.ExtraWadingData
// 0x00B8 (0x00B8 - 0x0000)
struct FExtraWadingData final
{
public:
	struct FVehicleTrailData                      WadingData;                                        // 0x0000(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UElementalInteractionData*, struct FVehicleTrailParticleSystemData> WadeParticleSystems;                               // 0x0050(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVehicleTrailParticleSystemData        DefaultWadeParticleSystem;                         // 0x00A0(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtraWadingData) == 0x000008, "Wrong alignment on FExtraWadingData");
static_assert(sizeof(FExtraWadingData) == 0x0000B8, "Wrong size on FExtraWadingData");
static_assert(offsetof(FExtraWadingData, WadingData) == 0x000000, "Member 'FExtraWadingData::WadingData' has a wrong offset!");
static_assert(offsetof(FExtraWadingData, WadeParticleSystems) == 0x000050, "Member 'FExtraWadingData::WadeParticleSystems' has a wrong offset!");
static_assert(offsetof(FExtraWadingData, DefaultWadeParticleSystem) == 0x0000A0, "Member 'FExtraWadingData::DefaultWadeParticleSystem' has a wrong offset!");

// ScriptStruct OakGame.GroundSlamEndedDetails
// 0x0008 (0x0008 - 0x0000)
struct FGroundSlamEndedDetails final
{
public:
	bool                                          bInterrupted;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactVelocity;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundSlamEndedDetails) == 0x000004, "Wrong alignment on FGroundSlamEndedDetails");
static_assert(sizeof(FGroundSlamEndedDetails) == 0x000008, "Wrong size on FGroundSlamEndedDetails");
static_assert(offsetof(FGroundSlamEndedDetails, bInterrupted) == 0x000000, "Member 'FGroundSlamEndedDetails::bInterrupted' has a wrong offset!");
static_assert(offsetof(FGroundSlamEndedDetails, ImpactVelocity) == 0x000004, "Member 'FGroundSlamEndedDetails::ImpactVelocity' has a wrong offset!");

// ScriptStruct OakGame.AIOCameraStatePostProcessOverrides
// 0x0020 (0x0020 - 0x0000)
struct FAIOCameraStatePostProcessOverrides final
{
public:
	uint8                                         bOverrideFocalDistance : 1;                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideFarTransitionRegion : 1;                  // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideNearTransitionRegion : 1;                 // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideFocalRegion : 1;                          // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideFarBlurSize : 1;                          // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideNearBlurSize : 1;                         // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideVignetteIntensity : 1;                    // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalDistanceOverride;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarTransitionRegionOverride;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearTransitionRegionOverride;                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocalRegionOverride;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarBlurSizeOverride;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearBlurSizeOverride;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteIntensityOverride;                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIOCameraStatePostProcessOverrides) == 0x000004, "Wrong alignment on FAIOCameraStatePostProcessOverrides");
static_assert(sizeof(FAIOCameraStatePostProcessOverrides) == 0x000020, "Wrong size on FAIOCameraStatePostProcessOverrides");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, FocalDistanceOverride) == 0x000004, "Member 'FAIOCameraStatePostProcessOverrides::FocalDistanceOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, FarTransitionRegionOverride) == 0x000008, "Member 'FAIOCameraStatePostProcessOverrides::FarTransitionRegionOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, NearTransitionRegionOverride) == 0x00000C, "Member 'FAIOCameraStatePostProcessOverrides::NearTransitionRegionOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, FocalRegionOverride) == 0x000010, "Member 'FAIOCameraStatePostProcessOverrides::FocalRegionOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, FarBlurSizeOverride) == 0x000014, "Member 'FAIOCameraStatePostProcessOverrides::FarBlurSizeOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, NearBlurSizeOverride) == 0x000018, "Member 'FAIOCameraStatePostProcessOverrides::NearBlurSizeOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraStatePostProcessOverrides, VignetteIntensityOverride) == 0x00001C, "Member 'FAIOCameraStatePostProcessOverrides::VignetteIntensityOverride' has a wrong offset!");

// ScriptStruct OakGame.AIOCameraStateInfo
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FAIOCameraStateInfo final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocationSplitscreen;                         // 0x0014(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocationVerticalSplitscreen;                 // 0x0020(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocationQuadSplitscreen;                     // 0x002C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLookAtLocation;                              // 0x0038(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLookAtLocationSplitscreen;                   // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLookAtLocationVerticalSplitscreen;           // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLookAtLocationQuadSplitscreen;               // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         Easing;                                            // 0x0068(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TransitionDuration;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIOCameraStatePostProcessOverrides    PostProcessOverrides;                              // 0x0078(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIOCameraStateInfo) == 0x000008, "Wrong alignment on FAIOCameraStateInfo");
static_assert(sizeof(FAIOCameraStateInfo) == 0x000098, "Wrong size on FAIOCameraStateInfo");
static_assert(offsetof(FAIOCameraStateInfo, StateName) == 0x000000, "Member 'FAIOCameraStateInfo::StateName' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLocation) == 0x000008, "Member 'FAIOCameraStateInfo::TargetLocation' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLocationSplitscreen) == 0x000014, "Member 'FAIOCameraStateInfo::TargetLocationSplitscreen' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLocationVerticalSplitscreen) == 0x000020, "Member 'FAIOCameraStateInfo::TargetLocationVerticalSplitscreen' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLocationQuadSplitscreen) == 0x00002C, "Member 'FAIOCameraStateInfo::TargetLocationQuadSplitscreen' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLookAtLocation) == 0x000038, "Member 'FAIOCameraStateInfo::TargetLookAtLocation' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLookAtLocationSplitscreen) == 0x000044, "Member 'FAIOCameraStateInfo::TargetLookAtLocationSplitscreen' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLookAtLocationVerticalSplitscreen) == 0x000050, "Member 'FAIOCameraStateInfo::TargetLookAtLocationVerticalSplitscreen' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TargetLookAtLocationQuadSplitscreen) == 0x00005C, "Member 'FAIOCameraStateInfo::TargetLookAtLocationQuadSplitscreen' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, Easing) == 0x000068, "Member 'FAIOCameraStateInfo::Easing' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, TransitionDuration) == 0x000074, "Member 'FAIOCameraStateInfo::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FAIOCameraStateInfo, PostProcessOverrides) == 0x000078, "Member 'FAIOCameraStateInfo::PostProcessOverrides' has a wrong offset!");

// ScriptStruct OakGame.SlideEndedDetails
// 0x0018 (0x0018 - 0x0000)
struct FSlideEndedDetails final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StopVelocity;                                      // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlideEndedDetails) == 0x000008, "Wrong alignment on FSlideEndedDetails");
static_assert(sizeof(FSlideEndedDetails) == 0x000018, "Wrong size on FSlideEndedDetails");
static_assert(offsetof(FSlideEndedDetails, HitActor) == 0x000000, "Member 'FSlideEndedDetails::HitActor' has a wrong offset!");
static_assert(offsetof(FSlideEndedDetails, StopVelocity) == 0x000008, "Member 'FSlideEndedDetails::StopVelocity' has a wrong offset!");

// ScriptStruct OakGame.GFxMissionTrackerInventoryItemData
// 0x0040 (0x0040 - 0x0000)
struct FGFxMissionTrackerInventoryItemData final
{
public:
	class FString                                 ItemTypeFrameName;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemRarityFrameName;                               // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemRarityFrameText;                               // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	int32                                         ItemScore;                                         // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxMissionTrackerInventoryItemData) == 0x000008, "Wrong alignment on FGFxMissionTrackerInventoryItemData");
static_assert(sizeof(FGFxMissionTrackerInventoryItemData) == 0x000040, "Wrong size on FGFxMissionTrackerInventoryItemData");
static_assert(offsetof(FGFxMissionTrackerInventoryItemData, ItemTypeFrameName) == 0x000000, "Member 'FGFxMissionTrackerInventoryItemData::ItemTypeFrameName' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerInventoryItemData, ItemRarityFrameName) == 0x000010, "Member 'FGFxMissionTrackerInventoryItemData::ItemRarityFrameName' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerInventoryItemData, ItemRarityFrameText) == 0x000020, "Member 'FGFxMissionTrackerInventoryItemData::ItemRarityFrameText' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerInventoryItemData, ItemScore) == 0x000038, "Member 'FGFxMissionTrackerInventoryItemData::ItemScore' has a wrong offset!");

// ScriptStruct OakGame.CharacterJumpGoalSetting
// 0x000C (0x000C - 0x0000)
struct FCharacterJumpGoalSetting final
{
public:
	float                                         InitialZVelocity;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalHeight;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseInitialZVelocity : 1;                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseGoalHeight : 1;                                // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterJumpGoalSetting) == 0x000004, "Wrong alignment on FCharacterJumpGoalSetting");
static_assert(sizeof(FCharacterJumpGoalSetting) == 0x00000C, "Wrong size on FCharacterJumpGoalSetting");
static_assert(offsetof(FCharacterJumpGoalSetting, InitialZVelocity) == 0x000000, "Member 'FCharacterJumpGoalSetting::InitialZVelocity' has a wrong offset!");
static_assert(offsetof(FCharacterJumpGoalSetting, GoalHeight) == 0x000004, "Member 'FCharacterJumpGoalSetting::GoalHeight' has a wrong offset!");

// ScriptStruct OakGame.OakNPCMailDataEntry
// 0x0050 (0x0058 - 0x0008)
struct FOakNPCMailDataEntry final : public FTableRowBase
{
public:
	class FText                                   SenderDisplayName;                                 // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Subject;                                           // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UItemPoolData*                          ItemPoolReward;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakNPCMailDataEntry) == 0x000008, "Wrong alignment on FOakNPCMailDataEntry");
static_assert(sizeof(FOakNPCMailDataEntry) == 0x000058, "Wrong size on FOakNPCMailDataEntry");
static_assert(offsetof(FOakNPCMailDataEntry, SenderDisplayName) == 0x000008, "Member 'FOakNPCMailDataEntry::SenderDisplayName' has a wrong offset!");
static_assert(offsetof(FOakNPCMailDataEntry, Subject) == 0x000020, "Member 'FOakNPCMailDataEntry::Subject' has a wrong offset!");
static_assert(offsetof(FOakNPCMailDataEntry, Body) == 0x000038, "Member 'FOakNPCMailDataEntry::Body' has a wrong offset!");
static_assert(offsetof(FOakNPCMailDataEntry, ItemPoolReward) == 0x000050, "Member 'FOakNPCMailDataEntry::ItemPoolReward' has a wrong offset!");

// ScriptStruct OakGame.ItemCardElementalDetails
// 0x0040 (0x0040 - 0x0000)
struct FItemCardElementalDetails final
{
public:
	class FText                                   EffectText;                                        // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   ProcChanceText;                                    // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FString                                 IconFrame;                                         // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemCardElementalDetails) == 0x000008, "Wrong alignment on FItemCardElementalDetails");
static_assert(sizeof(FItemCardElementalDetails) == 0x000040, "Wrong size on FItemCardElementalDetails");
static_assert(offsetof(FItemCardElementalDetails, EffectText) == 0x000000, "Member 'FItemCardElementalDetails::EffectText' has a wrong offset!");
static_assert(offsetof(FItemCardElementalDetails, ProcChanceText) == 0x000018, "Member 'FItemCardElementalDetails::ProcChanceText' has a wrong offset!");
static_assert(offsetof(FItemCardElementalDetails, IconFrame) == 0x000030, "Member 'FItemCardElementalDetails::IconFrame' has a wrong offset!");

// ScriptStruct OakGame.DialogParameterValuePair
// 0x0088 (0x0088 - 0x0000)
struct FDialogParameterValuePair final
{
public:
	class UDialogParameter*                       Parameter;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              Value;                                             // 0x0008(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogParameterValuePair) == 0x000008, "Wrong alignment on FDialogParameterValuePair");
static_assert(sizeof(FDialogParameterValuePair) == 0x000088, "Wrong size on FDialogParameterValuePair");
static_assert(offsetof(FDialogParameterValuePair, Parameter) == 0x000000, "Member 'FDialogParameterValuePair::Parameter' has a wrong offset!");
static_assert(offsetof(FDialogParameterValuePair, Value) == 0x000008, "Member 'FDialogParameterValuePair::Value' has a wrong offset!");

// ScriptStruct OakGame.WeaponUseModeAttributeEffectData
// 0x0018 (0x0018 - 0x0000)
struct FWeaponUseModeAttributeEffectData final
{
public:
	EWeaponUseMode                                UseMode;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseModeBitmask;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeEffectData>           AttributeEffects;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponUseModeAttributeEffectData) == 0x000008, "Wrong alignment on FWeaponUseModeAttributeEffectData");
static_assert(sizeof(FWeaponUseModeAttributeEffectData) == 0x000018, "Wrong size on FWeaponUseModeAttributeEffectData");
static_assert(offsetof(FWeaponUseModeAttributeEffectData, UseMode) == 0x000000, "Member 'FWeaponUseModeAttributeEffectData::UseMode' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeAttributeEffectData, UseModeBitmask) == 0x000004, "Member 'FWeaponUseModeAttributeEffectData::UseModeBitmask' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeAttributeEffectData, AttributeEffects) == 0x000008, "Member 'FWeaponUseModeAttributeEffectData::AttributeEffects' has a wrong offset!");

// ScriptStruct OakGame.WeaponBonusData
// 0x0028 (0x0028 - 0x0000)
struct FWeaponBonusData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FWeaponUseModeAttributeEffectData> WeaponUseModeAttributeEffects;                     // 0x0008(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAttributeEffectData>           InstigatorAttributeEffects;                        // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWeaponBonusData) == 0x000008, "Wrong alignment on FWeaponBonusData");
static_assert(sizeof(FWeaponBonusData) == 0x000028, "Wrong size on FWeaponBonusData");
static_assert(offsetof(FWeaponBonusData, Name) == 0x000000, "Member 'FWeaponBonusData::Name' has a wrong offset!");
static_assert(offsetof(FWeaponBonusData, WeaponUseModeAttributeEffects) == 0x000008, "Member 'FWeaponBonusData::WeaponUseModeAttributeEffects' has a wrong offset!");
static_assert(offsetof(FWeaponBonusData, InstigatorAttributeEffects) == 0x000018, "Member 'FWeaponBonusData::InstigatorAttributeEffects' has a wrong offset!");

// ScriptStruct OakGame.PlayerCombatEncounterData
// 0x0014 (0x0014 - 0x0000)
struct FPlayerCombatEncounterData final
{
public:
	int32                                         Experience;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CriticalHits;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Kills;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BadassKills;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RaidBossKills;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPlayerCombatEncounterData) == 0x000004, "Wrong alignment on FPlayerCombatEncounterData");
static_assert(sizeof(FPlayerCombatEncounterData) == 0x000014, "Wrong size on FPlayerCombatEncounterData");
static_assert(offsetof(FPlayerCombatEncounterData, Experience) == 0x000000, "Member 'FPlayerCombatEncounterData::Experience' has a wrong offset!");
static_assert(offsetof(FPlayerCombatEncounterData, CriticalHits) == 0x000004, "Member 'FPlayerCombatEncounterData::CriticalHits' has a wrong offset!");
static_assert(offsetof(FPlayerCombatEncounterData, Kills) == 0x000008, "Member 'FPlayerCombatEncounterData::Kills' has a wrong offset!");
static_assert(offsetof(FPlayerCombatEncounterData, BadassKills) == 0x00000C, "Member 'FPlayerCombatEncounterData::BadassKills' has a wrong offset!");
static_assert(offsetof(FPlayerCombatEncounterData, RaidBossKills) == 0x000010, "Member 'FPlayerCombatEncounterData::RaidBossKills' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleHorn
// 0x0018 (0x0018 - 0x0000)
struct FAIAspectSettings_VehicleHorn final
{
public:
	TArray<struct FHornSequenceEntry>             HornSequence;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bStopWithAction;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_VehicleHorn) == 0x000008, "Wrong alignment on FAIAspectSettings_VehicleHorn");
static_assert(sizeof(FAIAspectSettings_VehicleHorn) == 0x000018, "Wrong size on FAIAspectSettings_VehicleHorn");
static_assert(offsetof(FAIAspectSettings_VehicleHorn, HornSequence) == 0x000000, "Member 'FAIAspectSettings_VehicleHorn::HornSequence' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleHorn, bStopWithAction) == 0x000010, "Member 'FAIAspectSettings_VehicleHorn::bStopWithAction' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuVehicleConfig
// 0x0188 (0x0188 - 0x0000)
struct FOakCARMenuVehicleConfig final
{
public:
	class FString                                 LoadoutSaveName;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehicleData>      Body;                                              // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  Wheel;                                             // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  Armor;                                             // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  CoreMod;                                           // 0x0088(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  GunnerWeapon;                                      // 0x00B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  DriverWeapon;                                      // 0x00D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  Ornament;                                          // 0x0100(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  MaterialDecal;                                     // 0x0128(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOakCARVehiclePartData>  Material;                                          // 0x0150(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex1;                                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex2;                                       // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex3;                                       // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCARMenuVehicleConfig) == 0x000008, "Wrong alignment on FOakCARMenuVehicleConfig");
static_assert(sizeof(FOakCARMenuVehicleConfig) == 0x000188, "Wrong size on FOakCARMenuVehicleConfig");
static_assert(offsetof(FOakCARMenuVehicleConfig, LoadoutSaveName) == 0x000000, "Member 'FOakCARMenuVehicleConfig::LoadoutSaveName' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, Body) == 0x000010, "Member 'FOakCARMenuVehicleConfig::Body' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, Wheel) == 0x000038, "Member 'FOakCARMenuVehicleConfig::Wheel' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, Armor) == 0x000060, "Member 'FOakCARMenuVehicleConfig::Armor' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, CoreMod) == 0x000088, "Member 'FOakCARMenuVehicleConfig::CoreMod' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, GunnerWeapon) == 0x0000B0, "Member 'FOakCARMenuVehicleConfig::GunnerWeapon' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, DriverWeapon) == 0x0000D8, "Member 'FOakCARMenuVehicleConfig::DriverWeapon' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, Ornament) == 0x000100, "Member 'FOakCARMenuVehicleConfig::Ornament' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, MaterialDecal) == 0x000128, "Member 'FOakCARMenuVehicleConfig::MaterialDecal' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, Material) == 0x000150, "Member 'FOakCARMenuVehicleConfig::Material' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, ColorIndex1) == 0x000178, "Member 'FOakCARMenuVehicleConfig::ColorIndex1' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, ColorIndex2) == 0x00017C, "Member 'FOakCARMenuVehicleConfig::ColorIndex2' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfig, ColorIndex3) == 0x000180, "Member 'FOakCARMenuVehicleConfig::ColorIndex3' has a wrong offset!");

// ScriptStruct OakGame.GFxMissionTrackerRewardDisplayData
// 0x0020 (0x0020 - 0x0000)
struct FGFxMissionTrackerRewardDisplayData final
{
public:
	int32                                         Currency;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryCategoryData*                 CurrencyType;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGFxMissionTrackerInventoryItemData> Items;                                             // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMissionTrackerRewardDisplayData) == 0x000008, "Wrong alignment on FGFxMissionTrackerRewardDisplayData");
static_assert(sizeof(FGFxMissionTrackerRewardDisplayData) == 0x000020, "Wrong size on FGFxMissionTrackerRewardDisplayData");
static_assert(offsetof(FGFxMissionTrackerRewardDisplayData, Currency) == 0x000000, "Member 'FGFxMissionTrackerRewardDisplayData::Currency' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerRewardDisplayData, CurrencyType) == 0x000008, "Member 'FGFxMissionTrackerRewardDisplayData::CurrencyType' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerRewardDisplayData, Items) == 0x000010, "Member 'FGFxMissionTrackerRewardDisplayData::Items' has a wrong offset!");

// ScriptStruct OakGame.OakThumbnailManagerLightProperties
// 0x0014 (0x0014 - 0x0000)
struct FOakThumbnailManagerLightProperties final
{
public:
	struct FRotator                               Direction;                                         // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakThumbnailManagerLightProperties) == 0x000004, "Wrong alignment on FOakThumbnailManagerLightProperties");
static_assert(sizeof(FOakThumbnailManagerLightProperties) == 0x000014, "Wrong size on FOakThumbnailManagerLightProperties");
static_assert(offsetof(FOakThumbnailManagerLightProperties, Direction) == 0x000000, "Member 'FOakThumbnailManagerLightProperties::Direction' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerLightProperties, Brightness) == 0x00000C, "Member 'FOakThumbnailManagerLightProperties::Brightness' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerLightProperties, Color) == 0x000010, "Member 'FOakThumbnailManagerLightProperties::Color' has a wrong offset!");

// ScriptStruct OakGame.OakThumbnailManagerRenderProperties
// 0x0670 (0x0670 - 0x0000)
struct FOakThumbnailManagerRenderProperties final
{
public:
	struct FTransform                             ItemTransform;                                     // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FOakThumbnailManagerLightProperties    LightProperties;                                   // 0x0030(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakThumbnailManagerLightProperties> AdditionalLights;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FThumbnailParameters                   ThumbnailParameters;                               // 0x0058(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0070(0x0600)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakThumbnailManagerRenderProperties) == 0x000010, "Wrong alignment on FOakThumbnailManagerRenderProperties");
static_assert(sizeof(FOakThumbnailManagerRenderProperties) == 0x000670, "Wrong size on FOakThumbnailManagerRenderProperties");
static_assert(offsetof(FOakThumbnailManagerRenderProperties, ItemTransform) == 0x000000, "Member 'FOakThumbnailManagerRenderProperties::ItemTransform' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerRenderProperties, LightProperties) == 0x000030, "Member 'FOakThumbnailManagerRenderProperties::LightProperties' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerRenderProperties, AdditionalLights) == 0x000048, "Member 'FOakThumbnailManagerRenderProperties::AdditionalLights' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerRenderProperties, ThumbnailParameters) == 0x000058, "Member 'FOakThumbnailManagerRenderProperties::ThumbnailParameters' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerRenderProperties, PostProcessSettings) == 0x000070, "Member 'FOakThumbnailManagerRenderProperties::PostProcessSettings' has a wrong offset!");

// ScriptStruct OakGame.VaultCardRewardList
// 0x0058 (0x0058 - 0x0000)
struct FVaultCardRewardList final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVaultCardRewardInfo>           UnlockedVaultCardRewards;                          // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVaultCardRewardInfo>           RedeemedVaultCardRewards;                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVaultCardGearRewardInfo>       RedeemedVaultCardGearRewards;                      // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FVaultCardRewardList) == 0x000008, "Wrong alignment on FVaultCardRewardList");
static_assert(sizeof(FVaultCardRewardList) == 0x000058, "Wrong size on FVaultCardRewardList");
static_assert(offsetof(FVaultCardRewardList, UnlockedVaultCardRewards) == 0x000028, "Member 'FVaultCardRewardList::UnlockedVaultCardRewards' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardList, RedeemedVaultCardRewards) == 0x000038, "Member 'FVaultCardRewardList::RedeemedVaultCardRewards' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardList, RedeemedVaultCardGearRewards) == 0x000048, "Member 'FVaultCardRewardList::RedeemedVaultCardGearRewards' has a wrong offset!");

// ScriptStruct OakGame.VaultCardManager
// 0x0128 (0x0128 - 0x0000)
struct FVaultCardManager final
{
public:
	uint8                                         Pad_0[0xD0];                                       // 0x0000(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVaultCardRewardList>           VaultCardRewardEntries;                            // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FInventoryReplicationData              PendingInventoryReward;                            // 0x00E0(0x0010)(Transient, NativeAccessSpecifierPrivate)
	uint32                                        PendingRewardVaultCardID;                          // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVaultCardCurrentChallengeLists> CurrentVaultCardChallenges;                        // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AOakPlayerController*                   Owner;                                             // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVaultCardGeneralData*                  VaultCardGlobalData;                               // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultCardManager) == 0x000008, "Wrong alignment on FVaultCardManager");
static_assert(sizeof(FVaultCardManager) == 0x000128, "Wrong size on FVaultCardManager");
static_assert(offsetof(FVaultCardManager, VaultCardRewardEntries) == 0x0000D0, "Member 'FVaultCardManager::VaultCardRewardEntries' has a wrong offset!");
static_assert(offsetof(FVaultCardManager, PendingInventoryReward) == 0x0000E0, "Member 'FVaultCardManager::PendingInventoryReward' has a wrong offset!");
static_assert(offsetof(FVaultCardManager, PendingRewardVaultCardID) == 0x0000F0, "Member 'FVaultCardManager::PendingRewardVaultCardID' has a wrong offset!");
static_assert(offsetof(FVaultCardManager, CurrentVaultCardChallenges) == 0x000100, "Member 'FVaultCardManager::CurrentVaultCardChallenges' has a wrong offset!");
static_assert(offsetof(FVaultCardManager, Owner) == 0x000110, "Member 'FVaultCardManager::Owner' has a wrong offset!");
static_assert(offsetof(FVaultCardManager, VaultCardGlobalData) == 0x000118, "Member 'FVaultCardManager::VaultCardGlobalData' has a wrong offset!");

// ScriptStruct OakGame.CSBoosterInfo
// 0x0090 (0x0090 - 0x0000)
struct FCSBoosterInfo final
{
public:
	class FName                                   NameId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimName;                                          // 0x0008(0x0010)(ZeroConstructor, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BoosterTextureName;                                // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   UnlockDescription;                                 // 0x0058(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Icon;                                              // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCSBoosterInfo) == 0x000008, "Wrong alignment on FCSBoosterInfo");
static_assert(sizeof(FCSBoosterInfo) == 0x000090, "Wrong size on FCSBoosterInfo");
static_assert(offsetof(FCSBoosterInfo, NameId) == 0x000000, "Member 'FCSBoosterInfo::NameId' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, AnimName) == 0x000008, "Member 'FCSBoosterInfo::AnimName' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, BoosterTextureName) == 0x000018, "Member 'FCSBoosterInfo::BoosterTextureName' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, DisplayName) == 0x000028, "Member 'FCSBoosterInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, Description) == 0x000040, "Member 'FCSBoosterInfo::Description' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, UnlockDescription) == 0x000058, "Member 'FCSBoosterInfo::UnlockDescription' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, Price) == 0x000070, "Member 'FCSBoosterInfo::Price' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, StatusEffectData) == 0x000078, "Member 'FCSBoosterInfo::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, EffectDuration) == 0x000080, "Member 'FCSBoosterInfo::EffectDuration' has a wrong offset!");
static_assert(offsetof(FCSBoosterInfo, Icon) == 0x000088, "Member 'FCSBoosterInfo::Icon' has a wrong offset!");

// ScriptStruct OakGame.PlayerDueling_SavedInfo
// 0x0008 (0x0008 - 0x0000)
struct FPlayerDueling_SavedInfo final
{
public:
	class UTeam*                                  Team;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDueling_SavedInfo) == 0x000008, "Wrong alignment on FPlayerDueling_SavedInfo");
static_assert(sizeof(FPlayerDueling_SavedInfo) == 0x000008, "Wrong size on FPlayerDueling_SavedInfo");
static_assert(offsetof(FPlayerDueling_SavedInfo, Team) == 0x000000, "Member 'FPlayerDueling_SavedInfo::Team' has a wrong offset!");

// ScriptStruct OakGame.CryoFreezeAssetData
// 0x0010 (0x0010 - 0x0000)
struct FCryoFreezeAssetData final
{
public:
	class UDestructibleMesh*                      Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssociatedComponentName;                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCryoFreezeAssetData) == 0x000008, "Wrong alignment on FCryoFreezeAssetData");
static_assert(sizeof(FCryoFreezeAssetData) == 0x000010, "Wrong size on FCryoFreezeAssetData");
static_assert(offsetof(FCryoFreezeAssetData, Mesh) == 0x000000, "Member 'FCryoFreezeAssetData::Mesh' has a wrong offset!");
static_assert(offsetof(FCryoFreezeAssetData, AssociatedComponentName) == 0x000008, "Member 'FCryoFreezeAssetData::AssociatedComponentName' has a wrong offset!");

// ScriptStruct OakGame.GFxDisplayNotificationWidgetTextFields
// 0x0010 (0x0010 - 0x0000)
struct FGFxDisplayNotificationWidgetTextFields final
{
public:
	class FString                                 TextFieldPath;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxDisplayNotificationWidgetTextFields) == 0x000008, "Wrong alignment on FGFxDisplayNotificationWidgetTextFields");
static_assert(sizeof(FGFxDisplayNotificationWidgetTextFields) == 0x000010, "Wrong size on FGFxDisplayNotificationWidgetTextFields");
static_assert(offsetof(FGFxDisplayNotificationWidgetTextFields, TextFieldPath) == 0x000000, "Member 'FGFxDisplayNotificationWidgetTextFields::TextFieldPath' has a wrong offset!");

// ScriptStruct OakGame.PlaythroughDefinedValueRow
// 0x0070 (0x0078 - 0x0008)
struct FPlaythroughDefinedValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           PlaythroughOne;                                    // 0x0008(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           PlaythroughTwoAndBeyond;                           // 0x0040(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlaythroughDefinedValueRow) == 0x000008, "Wrong alignment on FPlaythroughDefinedValueRow");
static_assert(sizeof(FPlaythroughDefinedValueRow) == 0x000078, "Wrong size on FPlaythroughDefinedValueRow");
static_assert(offsetof(FPlaythroughDefinedValueRow, PlaythroughOne) == 0x000008, "Member 'FPlaythroughDefinedValueRow::PlaythroughOne' has a wrong offset!");
static_assert(offsetof(FPlaythroughDefinedValueRow, PlaythroughTwoAndBeyond) == 0x000040, "Member 'FPlaythroughDefinedValueRow::PlaythroughTwoAndBeyond' has a wrong offset!");

// ScriptStruct OakGame.PremiumCurrencyData
// 0x0010 (0x0010 - 0x0000)
struct FPremiumCurrencyData final
{
public:
	class UGbxInventoryCategoryData*              CategoryData;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPremiumCurrencyData) == 0x000008, "Wrong alignment on FPremiumCurrencyData");
static_assert(sizeof(FPremiumCurrencyData) == 0x000010, "Wrong size on FPremiumCurrencyData");
static_assert(offsetof(FPremiumCurrencyData, CategoryData) == 0x000000, "Member 'FPremiumCurrencyData::CategoryData' has a wrong offset!");

// ScriptStruct OakGame.PremiumCurrencyManager
// 0x0020 (0x0020 - 0x0000)
struct FPremiumCurrencyManager final
{
public:
	TArray<struct FPremiumCurrencyData>           Currencies;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AOakPlayerController*                   Owner;                                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPremiumCurrencyManager) == 0x000008, "Wrong alignment on FPremiumCurrencyManager");
static_assert(sizeof(FPremiumCurrencyManager) == 0x000020, "Wrong size on FPremiumCurrencyManager");
static_assert(offsetof(FPremiumCurrencyManager, Currencies) == 0x000000, "Member 'FPremiumCurrencyManager::Currencies' has a wrong offset!");
static_assert(offsetof(FPremiumCurrencyManager, Owner) == 0x000010, "Member 'FPremiumCurrencyManager::Owner' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityTimerSpec
// 0x0018 (0x0018 - 0x0000)
struct FOakAbilityTimerSpec final
{
public:
	class UOakAbilityTimerData*                   Timer;                                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInfinite;                                       // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnPause;                                    // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakAbilityTimerReplacePolicy                 ReplacePolicy;                                     // 0x0014(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakAbilityTimerTickPolicy                    TickPolicy;                                        // 0x0015(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityTimerSpec) == 0x000008, "Wrong alignment on FOakAbilityTimerSpec");
static_assert(sizeof(FOakAbilityTimerSpec) == 0x000018, "Wrong size on FOakAbilityTimerSpec");
static_assert(offsetof(FOakAbilityTimerSpec, Timer) == 0x000000, "Member 'FOakAbilityTimerSpec::Timer' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerSpec, bIsInfinite) == 0x000008, "Member 'FOakAbilityTimerSpec::bIsInfinite' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerSpec, bRemoveOnPause) == 0x000009, "Member 'FOakAbilityTimerSpec::bRemoveOnPause' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerSpec, Duration) == 0x00000C, "Member 'FOakAbilityTimerSpec::Duration' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerSpec, LoopCount) == 0x000010, "Member 'FOakAbilityTimerSpec::LoopCount' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerSpec, ReplacePolicy) == 0x000014, "Member 'FOakAbilityTimerSpec::ReplacePolicy' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerSpec, TickPolicy) == 0x000015, "Member 'FOakAbilityTimerSpec::TickPolicy' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuVehicleConfigSaveData
// 0x00B0 (0x00B0 - 0x0000)
struct FOakCARMenuVehicleConfigSaveData final
{
public:
	class FString                                 LoadoutSaveName;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BodyAssetPath;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WheelAssetPath;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ArmorAssetPath;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CoreModAssetPath;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GunnerWeaponAssetPath;                             // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DriverWeaponAssetPath;                             // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OrnamentAssetPath;                                 // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaterialDecalAssetPath;                            // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaterialAssetPath;                                 // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex1;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex2;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColorIndex3;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCARMenuVehicleConfigSaveData) == 0x000008, "Wrong alignment on FOakCARMenuVehicleConfigSaveData");
static_assert(sizeof(FOakCARMenuVehicleConfigSaveData) == 0x0000B0, "Wrong size on FOakCARMenuVehicleConfigSaveData");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, LoadoutSaveName) == 0x000000, "Member 'FOakCARMenuVehicleConfigSaveData::LoadoutSaveName' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, BodyAssetPath) == 0x000010, "Member 'FOakCARMenuVehicleConfigSaveData::BodyAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, WheelAssetPath) == 0x000020, "Member 'FOakCARMenuVehicleConfigSaveData::WheelAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, ArmorAssetPath) == 0x000030, "Member 'FOakCARMenuVehicleConfigSaveData::ArmorAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, CoreModAssetPath) == 0x000040, "Member 'FOakCARMenuVehicleConfigSaveData::CoreModAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, GunnerWeaponAssetPath) == 0x000050, "Member 'FOakCARMenuVehicleConfigSaveData::GunnerWeaponAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, DriverWeaponAssetPath) == 0x000060, "Member 'FOakCARMenuVehicleConfigSaveData::DriverWeaponAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, OrnamentAssetPath) == 0x000070, "Member 'FOakCARMenuVehicleConfigSaveData::OrnamentAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, MaterialDecalAssetPath) == 0x000080, "Member 'FOakCARMenuVehicleConfigSaveData::MaterialDecalAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, MaterialAssetPath) == 0x000090, "Member 'FOakCARMenuVehicleConfigSaveData::MaterialAssetPath' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, ColorIndex1) == 0x0000A0, "Member 'FOakCARMenuVehicleConfigSaveData::ColorIndex1' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, ColorIndex2) == 0x0000A4, "Member 'FOakCARMenuVehicleConfigSaveData::ColorIndex2' has a wrong offset!");
static_assert(offsetof(FOakCARMenuVehicleConfigSaveData, ColorIndex3) == 0x0000A8, "Member 'FOakCARMenuVehicleConfigSaveData::ColorIndex3' has a wrong offset!");

// ScriptStruct OakGame.LevelTravelDataListPatch
// 0x0020 (0x0020 - 0x0000)
struct FLevelTravelDataListPatch final
{
public:
	class ULevelTravelStationData*                LevelTravelData;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          LevelTravelDataCondition;                          // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          MissionIconCondition;                              // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MovieToPlayDuringTravelMap;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelTravelDataListPatch) == 0x000008, "Wrong alignment on FLevelTravelDataListPatch");
static_assert(sizeof(FLevelTravelDataListPatch) == 0x000020, "Wrong size on FLevelTravelDataListPatch");
static_assert(offsetof(FLevelTravelDataListPatch, LevelTravelData) == 0x000000, "Member 'FLevelTravelDataListPatch::LevelTravelData' has a wrong offset!");
static_assert(offsetof(FLevelTravelDataListPatch, LevelTravelDataCondition) == 0x000008, "Member 'FLevelTravelDataListPatch::LevelTravelDataCondition' has a wrong offset!");
static_assert(offsetof(FLevelTravelDataListPatch, MissionIconCondition) == 0x000010, "Member 'FLevelTravelDataListPatch::MissionIconCondition' has a wrong offset!");
static_assert(offsetof(FLevelTravelDataListPatch, MovieToPlayDuringTravelMap) == 0x000018, "Member 'FLevelTravelDataListPatch::MovieToPlayDuringTravelMap' has a wrong offset!");

// ScriptStruct OakGame.LevelTravelDataListStationPatch
// 0x0020 (0x0020 - 0x0000)
struct FLevelTravelDataListStationPatch final
{
public:
	class FString                                 AssociatedTravelStationName;                       // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelTravelDataListPatch>      PatchedTravelData;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelTravelDataListStationPatch) == 0x000008, "Wrong alignment on FLevelTravelDataListStationPatch");
static_assert(sizeof(FLevelTravelDataListStationPatch) == 0x000020, "Wrong size on FLevelTravelDataListStationPatch");
static_assert(offsetof(FLevelTravelDataListStationPatch, AssociatedTravelStationName) == 0x000000, "Member 'FLevelTravelDataListStationPatch::AssociatedTravelStationName' has a wrong offset!");
static_assert(offsetof(FLevelTravelDataListStationPatch, PatchedTravelData) == 0x000010, "Member 'FLevelTravelDataListStationPatch::PatchedTravelData' has a wrong offset!");

// ScriptStruct OakGame.MessageHandle
// 0x0008 (0x0008 - 0x0000)
struct FMessageHandle final
{
public:
	uint64                                        ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMessageHandle) == 0x000008, "Wrong alignment on FMessageHandle");
static_assert(sizeof(FMessageHandle) == 0x000008, "Wrong size on FMessageHandle");
static_assert(offsetof(FMessageHandle, ID) == 0x000000, "Member 'FMessageHandle::ID' has a wrong offset!");

// ScriptStruct OakGame.LoadGameMenuEntry
// 0x01C8 (0x01C8 - 0x0000)
struct FLoadGameMenuEntry final
{
public:
	class FString                                 SaveGameName;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterClassName;                                // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SaveGameId;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x1A4];                                     // 0x0024(0x01A4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadGameMenuEntry) == 0x000008, "Wrong alignment on FLoadGameMenuEntry");
static_assert(sizeof(FLoadGameMenuEntry) == 0x0001C8, "Wrong size on FLoadGameMenuEntry");
static_assert(offsetof(FLoadGameMenuEntry, SaveGameName) == 0x000000, "Member 'FLoadGameMenuEntry::SaveGameName' has a wrong offset!");
static_assert(offsetof(FLoadGameMenuEntry, CharacterLevel) == 0x000010, "Member 'FLoadGameMenuEntry::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FLoadGameMenuEntry, CharacterClassName) == 0x000018, "Member 'FLoadGameMenuEntry::CharacterClassName' has a wrong offset!");
static_assert(offsetof(FLoadGameMenuEntry, SaveGameId) == 0x000020, "Member 'FLoadGameMenuEntry::SaveGameId' has a wrong offset!");

// ScriptStruct OakGame.GFxEchoNetMailboxMenu_Adjustment
// 0x0010 (0x0010 - 0x0000)
struct FGFxEchoNetMailboxMenu_Adjustment final
{
public:
	struct FVector2D                              ContextMenuOffsetExpandingDown;                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContextMenuOffsetExpandingUp;                      // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxEchoNetMailboxMenu_Adjustment) == 0x000004, "Wrong alignment on FGFxEchoNetMailboxMenu_Adjustment");
static_assert(sizeof(FGFxEchoNetMailboxMenu_Adjustment) == 0x000010, "Wrong size on FGFxEchoNetMailboxMenu_Adjustment");
static_assert(offsetof(FGFxEchoNetMailboxMenu_Adjustment, ContextMenuOffsetExpandingDown) == 0x000000, "Member 'FGFxEchoNetMailboxMenu_Adjustment::ContextMenuOffsetExpandingDown' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMailboxMenu_Adjustment, ContextMenuOffsetExpandingUp) == 0x000008, "Member 'FGFxEchoNetMailboxMenu_Adjustment::ContextMenuOffsetExpandingUp' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersRoomInfo
// 0x0010 (0x0010 - 0x0000)
struct FCrewQuartersRoomInfo final
{
public:
	class UCrewQuartersRoomItemData*              RoomItemData;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrewQuartersRoomInfo) == 0x000008, "Wrong alignment on FCrewQuartersRoomInfo");
static_assert(sizeof(FCrewQuartersRoomInfo) == 0x000010, "Wrong size on FCrewQuartersRoomInfo");
static_assert(offsetof(FCrewQuartersRoomInfo, RoomItemData) == 0x000000, "Member 'FCrewQuartersRoomInfo::RoomItemData' has a wrong offset!");
static_assert(offsetof(FCrewQuartersRoomInfo, IsNew) == 0x000008, "Member 'FCrewQuartersRoomInfo::IsNew' has a wrong offset!");

// ScriptStruct OakGame.ItemInspectionSelectedPartData
// 0x0008 (0x0008 - 0x0000)
struct FItemInspectionSelectedPartData final
{
public:
	TSubclassOf<class UGbxAction_CoordinatedEffect> SelectedPartCE;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemInspectionSelectedPartData) == 0x000008, "Wrong alignment on FItemInspectionSelectedPartData");
static_assert(sizeof(FItemInspectionSelectedPartData) == 0x000008, "Wrong size on FItemInspectionSelectedPartData");
static_assert(offsetof(FItemInspectionSelectedPartData, SelectedPartCE) == 0x000000, "Member 'FItemInspectionSelectedPartData::SelectedPartCE' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectManufacturerChallengeInfo
// 0x0008 (0x0008 - 0x0000)
struct FGFxItemInspectManufacturerChallengeInfo final
{
public:
	TSubclassOf<class UChallenge>                 ChallengeClass;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxItemInspectManufacturerChallengeInfo) == 0x000008, "Wrong alignment on FGFxItemInspectManufacturerChallengeInfo");
static_assert(sizeof(FGFxItemInspectManufacturerChallengeInfo) == 0x000008, "Wrong size on FGFxItemInspectManufacturerChallengeInfo");
static_assert(offsetof(FGFxItemInspectManufacturerChallengeInfo, ChallengeClass) == 0x000000, "Member 'FGFxItemInspectManufacturerChallengeInfo::ChallengeClass' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionPageBase
// 0x0010 (0x0010 - 0x0000)
struct FGFxItemInspectionPageBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          PageWrapper;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGFxItemInspectionPageBase) == 0x000008, "Wrong alignment on FGFxItemInspectionPageBase");
static_assert(sizeof(FGFxItemInspectionPageBase) == 0x000010, "Wrong size on FGFxItemInspectionPageBase");
static_assert(offsetof(FGFxItemInspectionPageBase, PageWrapper) == 0x000008, "Member 'FGFxItemInspectionPageBase::PageWrapper' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionManufacturerPage
// 0x0110 (0x0120 - 0x0010)
struct FGFxItemInspectionManufacturerPage final : public FGFxItemInspectionPageBase
{
public:
	class FText                                   WatchCommericalHintText;                           // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ChallengesHeaderText;                              // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ViewChallengeText;                                 // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          RootClip;                                          // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxHintWidget*                      PlayCommercialHintClip;                            // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxTextField*                          ManufacturerDescriptionTextClip;                   // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxSlider*                          ManufacturerDescriptionScrollbarClip;              // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          ManufacturerDescriptionMaskClip;                   // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGFxItemInspectionManufacturerChallengeObject*> ChallengeClips;                                    // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FGFxItemInspectManufacturerChallengeInfo> ChallengeInfos;                                    // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemInspectionManufacturerPage) == 0x000008, "Wrong alignment on FGFxItemInspectionManufacturerPage");
static_assert(sizeof(FGFxItemInspectionManufacturerPage) == 0x000120, "Wrong size on FGFxItemInspectionManufacturerPage");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, WatchCommericalHintText) == 0x000010, "Member 'FGFxItemInspectionManufacturerPage::WatchCommericalHintText' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ChallengesHeaderText) == 0x000028, "Member 'FGFxItemInspectionManufacturerPage::ChallengesHeaderText' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ViewChallengeText) == 0x000040, "Member 'FGFxItemInspectionManufacturerPage::ViewChallengeText' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, RootClip) == 0x000058, "Member 'FGFxItemInspectionManufacturerPage::RootClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, PlayCommercialHintClip) == 0x000088, "Member 'FGFxItemInspectionManufacturerPage::PlayCommercialHintClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ManufacturerDescriptionTextClip) == 0x0000A8, "Member 'FGFxItemInspectionManufacturerPage::ManufacturerDescriptionTextClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ManufacturerDescriptionScrollbarClip) == 0x0000B0, "Member 'FGFxItemInspectionManufacturerPage::ManufacturerDescriptionScrollbarClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ManufacturerDescriptionMaskClip) == 0x0000B8, "Member 'FGFxItemInspectionManufacturerPage::ManufacturerDescriptionMaskClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ChallengeClips) == 0x0000F0, "Member 'FGFxItemInspectionManufacturerPage::ChallengeClips' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionManufacturerPage, ChallengeInfos) == 0x000100, "Member 'FGFxItemInspectionManufacturerPage::ChallengeInfos' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersDecorationInfo
// 0x0010 (0x0010 - 0x0000)
struct FCrewQuartersDecorationInfo final
{
public:
	class UCrewQuartersDecorationItemData*        DecorationItemData;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrewQuartersDecorationInfo) == 0x000008, "Wrong alignment on FCrewQuartersDecorationInfo");
static_assert(sizeof(FCrewQuartersDecorationInfo) == 0x000010, "Wrong size on FCrewQuartersDecorationInfo");
static_assert(offsetof(FCrewQuartersDecorationInfo, DecorationItemData) == 0x000000, "Member 'FCrewQuartersDecorationInfo::DecorationItemData' has a wrong offset!");
static_assert(offsetof(FCrewQuartersDecorationInfo, IsNew) == 0x000008, "Member 'FCrewQuartersDecorationInfo::IsNew' has a wrong offset!");

// ScriptStruct OakGame.OakNavReverseState
// 0x0018 (0x0018 - 0x0000)
struct FOakNavReverseState final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOakNavComponent*                       NavComp;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakNavReverseState) == 0x000008, "Wrong alignment on FOakNavReverseState");
static_assert(sizeof(FOakNavReverseState) == 0x000018, "Wrong size on FOakNavReverseState");
static_assert(offsetof(FOakNavReverseState, World) == 0x000000, "Member 'FOakNavReverseState::World' has a wrong offset!");
static_assert(offsetof(FOakNavReverseState, NavComp) == 0x000008, "Member 'FOakNavReverseState::NavComp' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryCustomizationPartInfo
// 0x0010 (0x0010 - 0x0000)
struct FOakInventoryCustomizationPartInfo final
{
public:
	class UOakInventoryCustomizationPartData*     CustomizationPart;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakInventoryCustomizationPartInfo) == 0x000008, "Wrong alignment on FOakInventoryCustomizationPartInfo");
static_assert(sizeof(FOakInventoryCustomizationPartInfo) == 0x000010, "Wrong size on FOakInventoryCustomizationPartInfo");
static_assert(offsetof(FOakInventoryCustomizationPartInfo, CustomizationPart) == 0x000000, "Member 'FOakInventoryCustomizationPartInfo::CustomizationPart' has a wrong offset!");
static_assert(offsetof(FOakInventoryCustomizationPartInfo, bIsNew) == 0x000008, "Member 'FOakInventoryCustomizationPartInfo::bIsNew' has a wrong offset!");

// ScriptStruct OakGame.OakCustomizationInfo
// 0x0010 (0x0010 - 0x0000)
struct FOakCustomizationInfo final
{
public:
	class UOakCustomizationData*                  Customization;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCustomizationInfo) == 0x000008, "Wrong alignment on FOakCustomizationInfo");
static_assert(sizeof(FOakCustomizationInfo) == 0x000010, "Wrong size on FOakCustomizationInfo");
static_assert(offsetof(FOakCustomizationInfo, Customization) == 0x000000, "Member 'FOakCustomizationInfo::Customization' has a wrong offset!");
static_assert(offsetof(FOakCustomizationInfo, IsNew) == 0x000008, "Member 'FOakCustomizationInfo::IsNew' has a wrong offset!");

// ScriptStruct OakGame.FrontendStandInAuxiliaryActorData
// 0x0058 (0x0058 - 0x0000)
struct FFrontendStandInAuxiliaryActorData final
{
public:
	TSubclassOf<class AStandInAuxiliaryActor>     ActorClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnimations;                                   // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDigistructIn;                                     // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DigistructDelay;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAuxiliaryActorToCharacter;                  // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AuxiliaryAttachmentSocket;                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyPlayerWeapon;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerTranslation;                                 // 0x003C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlayerRotation;                                    // 0x0048(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFrontendStandInAuxiliaryActorData) == 0x000008, "Wrong alignment on FFrontendStandInAuxiliaryActorData");
static_assert(sizeof(FFrontendStandInAuxiliaryActorData) == 0x000058, "Wrong size on FFrontendStandInAuxiliaryActorData");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, ActorClass) == 0x000000, "Member 'FFrontendStandInAuxiliaryActorData::ActorClass' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, Translation) == 0x000008, "Member 'FFrontendStandInAuxiliaryActorData::Translation' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, Rotation) == 0x000014, "Member 'FFrontendStandInAuxiliaryActorData::Rotation' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, Scale) == 0x000020, "Member 'FFrontendStandInAuxiliaryActorData::Scale' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, bPlayAnimations) == 0x000024, "Member 'FFrontendStandInAuxiliaryActorData::bPlayAnimations' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, bDigistructIn) == 0x000025, "Member 'FFrontendStandInAuxiliaryActorData::bDigistructIn' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, DigistructDelay) == 0x000028, "Member 'FFrontendStandInAuxiliaryActorData::DigistructDelay' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, bAttachAuxiliaryActorToCharacter) == 0x00002C, "Member 'FFrontendStandInAuxiliaryActorData::bAttachAuxiliaryActorToCharacter' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, AuxiliaryAttachmentSocket) == 0x000030, "Member 'FFrontendStandInAuxiliaryActorData::AuxiliaryAttachmentSocket' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, bCopyPlayerWeapon) == 0x000038, "Member 'FFrontendStandInAuxiliaryActorData::bCopyPlayerWeapon' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, PlayerTranslation) == 0x00003C, "Member 'FFrontendStandInAuxiliaryActorData::PlayerTranslation' has a wrong offset!");
static_assert(offsetof(FFrontendStandInAuxiliaryActorData, PlayerRotation) == 0x000048, "Member 'FFrontendStandInAuxiliaryActorData::PlayerRotation' has a wrong offset!");

// ScriptStruct OakGame.StandInAuxiliaryState
// 0x0060 (0x0060 - 0x0000)
struct FStandInAuxiliaryState final
{
public:
	class AStandInAuxiliaryActor*                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrontendStandInAuxiliaryActorData     TemplateData;                                      // 0x0008(0x0058)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInAuxiliaryState) == 0x000008, "Wrong alignment on FStandInAuxiliaryState");
static_assert(sizeof(FStandInAuxiliaryState) == 0x000060, "Wrong size on FStandInAuxiliaryState");
static_assert(offsetof(FStandInAuxiliaryState, Actor) == 0x000000, "Member 'FStandInAuxiliaryState::Actor' has a wrong offset!");
static_assert(offsetof(FStandInAuxiliaryState, TemplateData) == 0x000008, "Member 'FStandInAuxiliaryState::TemplateData' has a wrong offset!");

// ScriptStruct OakGame.AutoplayMissionState
// 0x0030 (0x0030 - 0x0000)
struct FAutoplayMissionState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAutoplayAction>                PossibleActions;                                   // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TSubclassOf<class UMission>                   CurrentMission;                                    // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CurrentObjective;                                  // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoplayMissionState) == 0x000008, "Wrong alignment on FAutoplayMissionState");
static_assert(sizeof(FAutoplayMissionState) == 0x000030, "Wrong size on FAutoplayMissionState");
static_assert(offsetof(FAutoplayMissionState, PossibleActions) == 0x000008, "Member 'FAutoplayMissionState::PossibleActions' has a wrong offset!");
static_assert(offsetof(FAutoplayMissionState, CurrentMission) == 0x000018, "Member 'FAutoplayMissionState::CurrentMission' has a wrong offset!");
static_assert(offsetof(FAutoplayMissionState, CurrentObjective) == 0x000020, "Member 'FAutoplayMissionState::CurrentObjective' has a wrong offset!");

// ScriptStruct OakGame.CSBoosterStatus
// 0x0018 (0x0018 - 0x0000)
struct FCSBoosterStatus final
{
public:
	class UOakStatusEffectManagerComponent*       Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          BoosterStatusIndex;                                // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeDuration;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeRemaining;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCSBoosterStatus) == 0x000008, "Wrong alignment on FCSBoosterStatus");
static_assert(sizeof(FCSBoosterStatus) == 0x000018, "Wrong size on FCSBoosterStatus");
static_assert(offsetof(FCSBoosterStatus, Owner) == 0x000000, "Member 'FCSBoosterStatus::Owner' has a wrong offset!");
static_assert(offsetof(FCSBoosterStatus, BoosterStatusIndex) == 0x000008, "Member 'FCSBoosterStatus::BoosterStatusIndex' has a wrong offset!");
static_assert(offsetof(FCSBoosterStatus, TimeDuration) == 0x00000C, "Member 'FCSBoosterStatus::TimeDuration' has a wrong offset!");
static_assert(offsetof(FCSBoosterStatus, TimeRemaining) == 0x000010, "Member 'FCSBoosterStatus::TimeRemaining' has a wrong offset!");

// ScriptStruct OakGame.ReviveStateInformation
// 0x0002 (0x0002 - 0x0000)
struct FReviveStateInformation final
{
public:
	EReviveState                                  ReviveState;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReviveSuccessful;                                  // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReviveStateInformation) == 0x000001, "Wrong alignment on FReviveStateInformation");
static_assert(sizeof(FReviveStateInformation) == 0x000002, "Wrong size on FReviveStateInformation");
static_assert(offsetof(FReviveStateInformation, ReviveState) == 0x000000, "Member 'FReviveStateInformation::ReviveState' has a wrong offset!");
static_assert(offsetof(FReviveStateInformation, ReviveSuccessful) == 0x000001, "Member 'FReviveStateInformation::ReviveSuccessful' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerPath
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOakPlayerPath final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPlayerPath) == 0x000008, "Wrong alignment on FOakPlayerPath");
static_assert(sizeof(FOakPlayerPath) == 0x000018, "Wrong size on FOakPlayerPath");

// ScriptStruct OakGame.StandInLightingComponentConfig
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FStandInLightingComponentConfig final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocation;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x000C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRotation;                                 // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideIntensity;                                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInLightingComponentConfig) == 0x000008, "Wrong alignment on FStandInLightingComponentConfig");
static_assert(sizeof(FStandInLightingComponentConfig) == 0x000030, "Wrong size on FStandInLightingComponentConfig");
static_assert(offsetof(FStandInLightingComponentConfig, ComponentName) == 0x000000, "Member 'FStandInLightingComponentConfig::ComponentName' has a wrong offset!");
static_assert(offsetof(FStandInLightingComponentConfig, bOverrideLocation) == 0x000008, "Member 'FStandInLightingComponentConfig::bOverrideLocation' has a wrong offset!");
static_assert(offsetof(FStandInLightingComponentConfig, Location) == 0x00000C, "Member 'FStandInLightingComponentConfig::Location' has a wrong offset!");
static_assert(offsetof(FStandInLightingComponentConfig, bOverrideRotation) == 0x000018, "Member 'FStandInLightingComponentConfig::bOverrideRotation' has a wrong offset!");
static_assert(offsetof(FStandInLightingComponentConfig, Rotation) == 0x00001C, "Member 'FStandInLightingComponentConfig::Rotation' has a wrong offset!");
static_assert(offsetof(FStandInLightingComponentConfig, bOverrideIntensity) == 0x000028, "Member 'FStandInLightingComponentConfig::bOverrideIntensity' has a wrong offset!");
static_assert(offsetof(FStandInLightingComponentConfig, Intensity) == 0x00002C, "Member 'FStandInLightingComponentConfig::Intensity' has a wrong offset!");

// ScriptStruct OakGame.StandInLightingConfig
// 0x0018 (0x0018 - 0x0000)
struct FStandInLightingConfig final
{
public:
	TArray<struct FStandInLightingComponentConfig> LightComponents;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AmbientCubemapIntensity;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandInLightingConfig) == 0x000008, "Wrong alignment on FStandInLightingConfig");
static_assert(sizeof(FStandInLightingConfig) == 0x000018, "Wrong size on FStandInLightingConfig");
static_assert(offsetof(FStandInLightingConfig, LightComponents) == 0x000000, "Member 'FStandInLightingConfig::LightComponents' has a wrong offset!");
static_assert(offsetof(FStandInLightingConfig, AmbientCubemapIntensity) == 0x000010, "Member 'FStandInLightingConfig::AmbientCubemapIntensity' has a wrong offset!");

// ScriptStruct OakGame.OakHitRegionModifierData
// 0x0048 (0x0048 - 0x0000)
struct FOakHitRegionModifierData final
{
public:
	struct FAttributeInitializationData           DamageScale;                                       // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakHitRegionModifierData) == 0x000008, "Wrong alignment on FOakHitRegionModifierData");
static_assert(sizeof(FOakHitRegionModifierData) == 0x000048, "Wrong size on FOakHitRegionModifierData");
static_assert(offsetof(FOakHitRegionModifierData, DamageScale) == 0x000000, "Member 'FOakHitRegionModifierData::DamageScale' has a wrong offset!");
static_assert(offsetof(FOakHitRegionModifierData, Condition) == 0x000038, "Member 'FOakHitRegionModifierData::Condition' has a wrong offset!");
static_assert(offsetof(FOakHitRegionModifierData, DamageType) == 0x000040, "Member 'FOakHitRegionModifierData::DamageType' has a wrong offset!");

// ScriptStruct OakGame.TriggerFeedbackState
// 0x0020 (0x0020 - 0x0000)
struct FTriggerFeedbackState final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponTriggerFeedbackAsset*            WeaponTriggerFeedback;                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggerFeedbackState) == 0x000008, "Wrong alignment on FTriggerFeedbackState");
static_assert(sizeof(FTriggerFeedbackState) == 0x000020, "Wrong size on FTriggerFeedbackState");
static_assert(offsetof(FTriggerFeedbackState, WeaponTriggerFeedback) == 0x000018, "Member 'FTriggerFeedbackState::WeaponTriggerFeedback' has a wrong offset!");

// ScriptStruct OakGame.SingularityInitializationBase
// 0x0070 (0x0070 - 0x0000)
struct FSingularityInitializationBase
{
public:
	class UHitReactionTag*                        PullTag;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MinPullRadius;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWwiseAuxBus*                           EffectAuxBus;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectSize;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectFadeDistance;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectDuration;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseRtpc*                             FadeDistanceRtpc;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            AdditionalStartEvent;                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            AdditionalStopEvent;                               // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingularityInitializationBase) == 0x000008, "Wrong alignment on FSingularityInitializationBase");
static_assert(sizeof(FSingularityInitializationBase) == 0x000070, "Wrong size on FSingularityInitializationBase");
static_assert(offsetof(FSingularityInitializationBase, PullTag) == 0x000000, "Member 'FSingularityInitializationBase::PullTag' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, IgnoreTags) == 0x000008, "Member 'FSingularityInitializationBase::IgnoreTags' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, MinPullRadius) == 0x000028, "Member 'FSingularityInitializationBase::MinPullRadius' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, IgnoreActors) == 0x000030, "Member 'FSingularityInitializationBase::IgnoreActors' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, EffectAuxBus) == 0x000040, "Member 'FSingularityInitializationBase::EffectAuxBus' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, EffectSize) == 0x000048, "Member 'FSingularityInitializationBase::EffectSize' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, EffectFadeDistance) == 0x00004C, "Member 'FSingularityInitializationBase::EffectFadeDistance' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, EffectDuration) == 0x000050, "Member 'FSingularityInitializationBase::EffectDuration' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, FadeDistanceRtpc) == 0x000058, "Member 'FSingularityInitializationBase::FadeDistanceRtpc' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, AdditionalStartEvent) == 0x000060, "Member 'FSingularityInitializationBase::AdditionalStartEvent' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationBase, AdditionalStopEvent) == 0x000068, "Member 'FSingularityInitializationBase::AdditionalStopEvent' has a wrong offset!");

// ScriptStruct OakGame.SingularityBurstInfo
// 0x0020 (0x0090 - 0x0070)
struct FSingularityBurstInfo final : public FSingularityInitializationBase
{
public:
	struct FVector                                SingularityLocation;                               // 0x0070(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPullRadius;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SingularityForce;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UExplosionData*                         SingularityExplosion;                              // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingularityBurstInfo) == 0x000008, "Wrong alignment on FSingularityBurstInfo");
static_assert(sizeof(FSingularityBurstInfo) == 0x000090, "Wrong size on FSingularityBurstInfo");
static_assert(offsetof(FSingularityBurstInfo, SingularityLocation) == 0x000070, "Member 'FSingularityBurstInfo::SingularityLocation' has a wrong offset!");
static_assert(offsetof(FSingularityBurstInfo, MaxPullRadius) == 0x00007C, "Member 'FSingularityBurstInfo::MaxPullRadius' has a wrong offset!");
static_assert(offsetof(FSingularityBurstInfo, SingularityForce) == 0x000080, "Member 'FSingularityBurstInfo::SingularityForce' has a wrong offset!");
static_assert(offsetof(FSingularityBurstInfo, SingularityExplosion) == 0x000088, "Member 'FSingularityBurstInfo::SingularityExplosion' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilityAllyQuerySpec
// 0x0010 (0x0010 - 0x0000)
struct FOakPlayerAbilityAllyQuerySpec final
{
public:
	bool                                          bInfiniteRange;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeCompanions;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPlayerAbilityAllyQuerySpec) == 0x000004, "Wrong alignment on FOakPlayerAbilityAllyQuerySpec");
static_assert(sizeof(FOakPlayerAbilityAllyQuerySpec) == 0x000010, "Wrong size on FOakPlayerAbilityAllyQuerySpec");
static_assert(offsetof(FOakPlayerAbilityAllyQuerySpec, bInfiniteRange) == 0x000000, "Member 'FOakPlayerAbilityAllyQuerySpec::bInfiniteRange' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityAllyQuerySpec, Range) == 0x000004, "Member 'FOakPlayerAbilityAllyQuerySpec::Range' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityAllyQuerySpec, bIncludeCompanions) == 0x000008, "Member 'FOakPlayerAbilityAllyQuerySpec::bIncludeCompanions' has a wrong offset!");

// ScriptStruct OakGame.ZoneIDToMissionEventReferenceData
// 0x0018 (0x0018 - 0x0000)
struct FZoneIDToMissionEventReferenceData final
{
public:
	uint8                                         ZoneNameEnumIdx;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMissionEventReference                 MissionEventReference;                             // 0x0008(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FZoneIDToMissionEventReferenceData) == 0x000008, "Wrong alignment on FZoneIDToMissionEventReferenceData");
static_assert(sizeof(FZoneIDToMissionEventReferenceData) == 0x000018, "Wrong size on FZoneIDToMissionEventReferenceData");
static_assert(offsetof(FZoneIDToMissionEventReferenceData, ZoneNameEnumIdx) == 0x000000, "Member 'FZoneIDToMissionEventReferenceData::ZoneNameEnumIdx' has a wrong offset!");
static_assert(offsetof(FZoneIDToMissionEventReferenceData, MissionEventReference) == 0x000008, "Member 'FZoneIDToMissionEventReferenceData::MissionEventReference' has a wrong offset!");

// ScriptStruct OakGame.OrphanedUIStandIn
// 0x0010 (0x0010 - 0x0000)
struct FOrphanedUIStandIn final
{
public:
	class AActor*                                 StandInActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOakUIActorContainer*                   Container;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrphanedUIStandIn) == 0x000008, "Wrong alignment on FOrphanedUIStandIn");
static_assert(sizeof(FOrphanedUIStandIn) == 0x000010, "Wrong size on FOrphanedUIStandIn");
static_assert(offsetof(FOrphanedUIStandIn, StandInActor) == 0x000000, "Member 'FOrphanedUIStandIn::StandInActor' has a wrong offset!");
static_assert(offsetof(FOrphanedUIStandIn, Container) == 0x000008, "Member 'FOrphanedUIStandIn::Container' has a wrong offset!");

// ScriptStruct OakGame.PathSegmentSetting
// 0x0034 (0x0034 - 0x0000)
struct FPathSegmentSetting final
{
public:
	float                                         ReachDistance;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachHeight;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapGroundDistance;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxNavGoalModifiers                   GoalModifiers;                                     // 0x000C(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathSegmentSetting) == 0x000004, "Wrong alignment on FPathSegmentSetting");
static_assert(sizeof(FPathSegmentSetting) == 0x000034, "Wrong size on FPathSegmentSetting");
static_assert(offsetof(FPathSegmentSetting, ReachDistance) == 0x000000, "Member 'FPathSegmentSetting::ReachDistance' has a wrong offset!");
static_assert(offsetof(FPathSegmentSetting, ReachHeight) == 0x000004, "Member 'FPathSegmentSetting::ReachHeight' has a wrong offset!");
static_assert(offsetof(FPathSegmentSetting, SnapGroundDistance) == 0x000008, "Member 'FPathSegmentSetting::SnapGroundDistance' has a wrong offset!");
static_assert(offsetof(FPathSegmentSetting, GoalModifiers) == 0x00000C, "Member 'FPathSegmentSetting::GoalModifiers' has a wrong offset!");

// ScriptStruct OakGame.OutstandingActivityFeedData
// 0x0010 (0x0010 - 0x0000)
struct FOutstandingActivityFeedData final
{
public:
	class UActivityFeedReward*                    FeedData;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeLevelTargetValue;                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeLevelCompleted;                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOutstandingActivityFeedData) == 0x000008, "Wrong alignment on FOutstandingActivityFeedData");
static_assert(sizeof(FOutstandingActivityFeedData) == 0x000010, "Wrong size on FOutstandingActivityFeedData");
static_assert(offsetof(FOutstandingActivityFeedData, FeedData) == 0x000000, "Member 'FOutstandingActivityFeedData::FeedData' has a wrong offset!");
static_assert(offsetof(FOutstandingActivityFeedData, ChallengeLevelTargetValue) == 0x000008, "Member 'FOutstandingActivityFeedData::ChallengeLevelTargetValue' has a wrong offset!");
static_assert(offsetof(FOutstandingActivityFeedData, ChallengeLevelCompleted) == 0x00000C, "Member 'FOutstandingActivityFeedData::ChallengeLevelCompleted' has a wrong offset!");

// ScriptStruct OakGame.PlayerBuyBackableInventory
// 0x0008 (0x0008 - 0x0000)
struct FPlayerBuyBackableInventory final
{
public:
	class AActor*                                 InventoryActor;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerBuyBackableInventory) == 0x000008, "Wrong alignment on FPlayerBuyBackableInventory");
static_assert(sizeof(FPlayerBuyBackableInventory) == 0x000008, "Wrong size on FPlayerBuyBackableInventory");
static_assert(offsetof(FPlayerBuyBackableInventory, InventoryActor) == 0x000000, "Member 'FPlayerBuyBackableInventory::InventoryActor' has a wrong offset!");

// ScriptStruct OakGame.OakSDUSaveGameData
// 0x0018 (0x0018 - 0x0000)
struct FOakSDUSaveGameData final
{
public:
	int32                                         SDULevel;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SDUDataPath;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakSDUSaveGameData) == 0x000008, "Wrong alignment on FOakSDUSaveGameData");
static_assert(sizeof(FOakSDUSaveGameData) == 0x000018, "Wrong size on FOakSDUSaveGameData");
static_assert(offsetof(FOakSDUSaveGameData, SDULevel) == 0x000000, "Member 'FOakSDUSaveGameData::SDULevel' has a wrong offset!");
static_assert(offsetof(FOakSDUSaveGameData, SDUDataPath) == 0x000008, "Member 'FOakSDUSaveGameData::SDUDataPath' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityTreeItemSaveGameData
// 0x0038 (0x0038 - 0x0000)
struct FOakAbilityTreeItemSaveGameData final
{
public:
	TSoftObjectPtr<class UOakPlayerAbilityTreeItemData> ItemAssetPath;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Points;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxPoints;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TreeIdentifier;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityTreeItemSaveGameData) == 0x000008, "Wrong alignment on FOakAbilityTreeItemSaveGameData");
static_assert(sizeof(FOakAbilityTreeItemSaveGameData) == 0x000038, "Wrong size on FOakAbilityTreeItemSaveGameData");
static_assert(offsetof(FOakAbilityTreeItemSaveGameData, ItemAssetPath) == 0x000000, "Member 'FOakAbilityTreeItemSaveGameData::ItemAssetPath' has a wrong offset!");
static_assert(offsetof(FOakAbilityTreeItemSaveGameData, Points) == 0x000028, "Member 'FOakAbilityTreeItemSaveGameData::Points' has a wrong offset!");
static_assert(offsetof(FOakAbilityTreeItemSaveGameData, MaxPoints) == 0x00002C, "Member 'FOakAbilityTreeItemSaveGameData::MaxPoints' has a wrong offset!");
static_assert(offsetof(FOakAbilityTreeItemSaveGameData, TreeIdentifier) == 0x000030, "Member 'FOakAbilityTreeItemSaveGameData::TreeIdentifier' has a wrong offset!");

// ScriptStruct OakGame.OakAbilitySlotSaveGameData
// 0x0050 (0x0050 - 0x0000)
struct FOakAbilitySlotSaveGameData final
{
public:
	TSoftClassPtr<class UClass>                   AbilityClassPath;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UOakPlayerAbilitySlotData> SlotAssetPath;                                     // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakAbilitySlotSaveGameData) == 0x000008, "Wrong alignment on FOakAbilitySlotSaveGameData");
static_assert(sizeof(FOakAbilitySlotSaveGameData) == 0x000050, "Wrong size on FOakAbilitySlotSaveGameData");
static_assert(offsetof(FOakAbilitySlotSaveGameData, AbilityClassPath) == 0x000000, "Member 'FOakAbilitySlotSaveGameData::AbilityClassPath' has a wrong offset!");
static_assert(offsetof(FOakAbilitySlotSaveGameData, SlotAssetPath) == 0x000028, "Member 'FOakAbilitySlotSaveGameData::SlotAssetPath' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentSaveGameData
// 0x0078 (0x0078 - 0x0000)
struct FOakActionAbilityAugmentSaveGameData final
{
public:
	TSoftClassPtr<class UClass>                   ActionAbilityClassPath;                            // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UOakActionAbilityAugmentSlotData> SlotAssetPath;                                     // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UOakActionAbilityAugmentData> AugmentAssetPath;                                  // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentSaveGameData) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentSaveGameData");
static_assert(sizeof(FOakActionAbilityAugmentSaveGameData) == 0x000078, "Wrong size on FOakActionAbilityAugmentSaveGameData");
static_assert(offsetof(FOakActionAbilityAugmentSaveGameData, ActionAbilityClassPath) == 0x000000, "Member 'FOakActionAbilityAugmentSaveGameData::ActionAbilityClassPath' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSaveGameData, SlotAssetPath) == 0x000028, "Member 'FOakActionAbilityAugmentSaveGameData::SlotAssetPath' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSaveGameData, AugmentAssetPath) == 0x000050, "Member 'FOakActionAbilityAugmentSaveGameData::AugmentAssetPath' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentConfigurationSaveGameData
// 0x00A0 (0x00A0 - 0x0000)
struct FOakActionAbilityAugmentConfigurationSaveGameData final
{
public:
	TSoftClassPtr<class UClass>                   AbilityClassPath;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UOakActionAbilityAugmentData> AugmentAssetPath;                                  // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UOakActionAbilityAugmentSlotData> ModSlotAssetPath;                                  // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UOakActionAbilityAugmentData> ModAssetPath;                                      // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentConfigurationSaveGameData) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentConfigurationSaveGameData");
static_assert(sizeof(FOakActionAbilityAugmentConfigurationSaveGameData) == 0x0000A0, "Wrong size on FOakActionAbilityAugmentConfigurationSaveGameData");
static_assert(offsetof(FOakActionAbilityAugmentConfigurationSaveGameData, AbilityClassPath) == 0x000000, "Member 'FOakActionAbilityAugmentConfigurationSaveGameData::AbilityClassPath' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentConfigurationSaveGameData, AugmentAssetPath) == 0x000028, "Member 'FOakActionAbilityAugmentConfigurationSaveGameData::AugmentAssetPath' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentConfigurationSaveGameData, ModSlotAssetPath) == 0x000050, "Member 'FOakActionAbilityAugmentConfigurationSaveGameData::ModSlotAssetPath' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentConfigurationSaveGameData, ModAssetPath) == 0x000078, "Member 'FOakActionAbilityAugmentConfigurationSaveGameData::ModAssetPath' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilitySaveGameData
// 0x0048 (0x0048 - 0x0000)
struct FOakPlayerAbilitySaveGameData final
{
public:
	int32                                         TreeGrade;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityPoints;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOakAbilityTreeItemSaveGameData> TreeItemList;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakAbilitySlotSaveGameData>    AbilitySlotList;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakActionAbilityAugmentSaveGameData> AugmentSlotList;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakActionAbilityAugmentConfigurationSaveGameData> AugmentConfigurationList;                          // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPlayerAbilitySaveGameData) == 0x000008, "Wrong alignment on FOakPlayerAbilitySaveGameData");
static_assert(sizeof(FOakPlayerAbilitySaveGameData) == 0x000048, "Wrong size on FOakPlayerAbilitySaveGameData");
static_assert(offsetof(FOakPlayerAbilitySaveGameData, TreeGrade) == 0x000000, "Member 'FOakPlayerAbilitySaveGameData::TreeGrade' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySaveGameData, AbilityPoints) == 0x000004, "Member 'FOakPlayerAbilitySaveGameData::AbilityPoints' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySaveGameData, TreeItemList) == 0x000008, "Member 'FOakPlayerAbilitySaveGameData::TreeItemList' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySaveGameData, AbilitySlotList) == 0x000018, "Member 'FOakPlayerAbilitySaveGameData::AbilitySlotList' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySaveGameData, AugmentSlotList) == 0x000028, "Member 'FOakPlayerAbilitySaveGameData::AugmentSlotList' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySaveGameData, AugmentConfigurationList) == 0x000038, "Member 'FOakPlayerAbilitySaveGameData::AugmentConfigurationList' has a wrong offset!");

// ScriptStruct OakGame.ClientExpectedSaveGameValues
// 0x0080 (0x0080 - 0x0000)
struct FClientExpectedSaveGameValues final
{
public:
	bool                                          bWaitingForServer;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExperiencePoints;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FResourcePoolSavegameData>      ResourcePools;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOakPlayerAbilitySaveGameData          Abilities;                                         // 0x0018(0x0048)(NativeAccessSpecifierPublic)
	TArray<struct FInventorySaveGameData>         InventoryList;                                     // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakSDUSaveGameData>            SDUList;                                           // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClientExpectedSaveGameValues) == 0x000008, "Wrong alignment on FClientExpectedSaveGameValues");
static_assert(sizeof(FClientExpectedSaveGameValues) == 0x000080, "Wrong size on FClientExpectedSaveGameValues");
static_assert(offsetof(FClientExpectedSaveGameValues, bWaitingForServer) == 0x000000, "Member 'FClientExpectedSaveGameValues::bWaitingForServer' has a wrong offset!");
static_assert(offsetof(FClientExpectedSaveGameValues, ExperiencePoints) == 0x000004, "Member 'FClientExpectedSaveGameValues::ExperiencePoints' has a wrong offset!");
static_assert(offsetof(FClientExpectedSaveGameValues, ResourcePools) == 0x000008, "Member 'FClientExpectedSaveGameValues::ResourcePools' has a wrong offset!");
static_assert(offsetof(FClientExpectedSaveGameValues, Abilities) == 0x000018, "Member 'FClientExpectedSaveGameValues::Abilities' has a wrong offset!");
static_assert(offsetof(FClientExpectedSaveGameValues, InventoryList) == 0x000060, "Member 'FClientExpectedSaveGameValues::InventoryList' has a wrong offset!");
static_assert(offsetof(FClientExpectedSaveGameValues, SDUList) == 0x000070, "Member 'FClientExpectedSaveGameValues::SDUList' has a wrong offset!");

// ScriptStruct OakGame.MatchmakingSearchParameter
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMatchmakingSearchParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetParamName;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchmakingSearchParameterOp                 Op;                                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ValueRange;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingSearchParameter) == 0x000008, "Wrong alignment on FMatchmakingSearchParameter");
static_assert(sizeof(FMatchmakingSearchParameter) == 0x000018, "Wrong size on FMatchmakingSearchParameter");
static_assert(offsetof(FMatchmakingSearchParameter, ParamName) == 0x000000, "Member 'FMatchmakingSearchParameter::ParamName' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchParameter, TargetParamName) == 0x000008, "Member 'FMatchmakingSearchParameter::TargetParamName' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchParameter, Op) == 0x000010, "Member 'FMatchmakingSearchParameter::Op' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchParameter, ValueRange) == 0x000014, "Member 'FMatchmakingSearchParameter::ValueRange' has a wrong offset!");

// ScriptStruct OakGame.MatchmakingSearchParameters
// 0x0028 (0x0028 - 0x0000)
struct FMatchmakingSearchParameters final
{
public:
	class FString                                 SearchName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchGameSettings;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchmakingSearchParameter>    SearchParameters;                                  // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingSearchParameters) == 0x000008, "Wrong alignment on FMatchmakingSearchParameters");
static_assert(sizeof(FMatchmakingSearchParameters) == 0x000028, "Wrong size on FMatchmakingSearchParameters");
static_assert(offsetof(FMatchmakingSearchParameters, SearchName) == 0x000000, "Member 'FMatchmakingSearchParameters::SearchName' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchParameters, bMatchGameSettings) == 0x000010, "Member 'FMatchmakingSearchParameters::bMatchGameSettings' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchParameters, SearchParameters) == 0x000018, "Member 'FMatchmakingSearchParameters::SearchParameters' has a wrong offset!");

// ScriptStruct OakGame.MatchmakingModifierData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FMatchmakingModifierData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetResolverName;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectName;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchmakingModifierData) == 0x000008, "Wrong alignment on FMatchmakingModifierData");
static_assert(sizeof(FMatchmakingModifierData) == 0x000020, "Wrong size on FMatchmakingModifierData");
static_assert(offsetof(FMatchmakingModifierData, Name) == 0x000000, "Member 'FMatchmakingModifierData::Name' has a wrong offset!");
static_assert(offsetof(FMatchmakingModifierData, TargetResolverName) == 0x000008, "Member 'FMatchmakingModifierData::TargetResolverName' has a wrong offset!");
static_assert(offsetof(FMatchmakingModifierData, EffectName) == 0x000010, "Member 'FMatchmakingModifierData::EffectName' has a wrong offset!");
static_assert(offsetof(FMatchmakingModifierData, Value) == 0x000018, "Member 'FMatchmakingModifierData::Value' has a wrong offset!");

// ScriptStruct OakGame.MatchmakingModifierSetData
// 0x0048 (0x0048 - 0x0000)
struct FMatchmakingModifierSetData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   DisplayDesc;                                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FMatchmakingModifierData>       Modifiers;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingModifierSetData) == 0x000008, "Wrong alignment on FMatchmakingModifierSetData");
static_assert(sizeof(FMatchmakingModifierSetData) == 0x000048, "Wrong size on FMatchmakingModifierSetData");
static_assert(offsetof(FMatchmakingModifierSetData, Name) == 0x000000, "Member 'FMatchmakingModifierSetData::Name' has a wrong offset!");
static_assert(offsetof(FMatchmakingModifierSetData, DisplayName) == 0x000008, "Member 'FMatchmakingModifierSetData::DisplayName' has a wrong offset!");
static_assert(offsetof(FMatchmakingModifierSetData, DisplayDesc) == 0x000020, "Member 'FMatchmakingModifierSetData::DisplayDesc' has a wrong offset!");
static_assert(offsetof(FMatchmakingModifierSetData, Modifiers) == 0x000038, "Member 'FMatchmakingModifierSetData::Modifiers' has a wrong offset!");

// ScriptStruct OakGame.MatchmakingSearchDefinition
// 0x00B8 (0x00B8 - 0x0000)
struct FMatchmakingSearchDefinition final
{
public:
	class FString                                 ActivityGuidString;                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentActivityGuidString;                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleKey;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescriptionKey;                                    // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImageId;                                           // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HopperName;                                        // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Version;                                           // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchmakingSearchParameters>   OrderedSearches;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         TravelStationPaths;                                // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchmakingRequirement>        MatchmakingRequirements;                           // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinPlayerCount;                                    // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayerCount;                                    // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchmakingModifierSetData>    ModifierSets;                                      // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingSearchDefinition) == 0x000008, "Wrong alignment on FMatchmakingSearchDefinition");
static_assert(sizeof(FMatchmakingSearchDefinition) == 0x0000B8, "Wrong size on FMatchmakingSearchDefinition");
static_assert(offsetof(FMatchmakingSearchDefinition, ActivityGuidString) == 0x000000, "Member 'FMatchmakingSearchDefinition::ActivityGuidString' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, ParentActivityGuidString) == 0x000010, "Member 'FMatchmakingSearchDefinition::ParentActivityGuidString' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, TitleKey) == 0x000020, "Member 'FMatchmakingSearchDefinition::TitleKey' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, DescriptionKey) == 0x000030, "Member 'FMatchmakingSearchDefinition::DescriptionKey' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, ImageId) == 0x000040, "Member 'FMatchmakingSearchDefinition::ImageId' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, HopperName) == 0x000050, "Member 'FMatchmakingSearchDefinition::HopperName' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, Version) == 0x000060, "Member 'FMatchmakingSearchDefinition::Version' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, OrderedSearches) == 0x000070, "Member 'FMatchmakingSearchDefinition::OrderedSearches' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, TravelStationPaths) == 0x000080, "Member 'FMatchmakingSearchDefinition::TravelStationPaths' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, MatchmakingRequirements) == 0x000090, "Member 'FMatchmakingSearchDefinition::MatchmakingRequirements' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, MinPlayerCount) == 0x0000A0, "Member 'FMatchmakingSearchDefinition::MinPlayerCount' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, MaxPlayerCount) == 0x0000A4, "Member 'FMatchmakingSearchDefinition::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(FMatchmakingSearchDefinition, ModifierSets) == 0x0000A8, "Member 'FMatchmakingSearchDefinition::ModifierSets' has a wrong offset!");

// ScriptStruct OakGame.OakBackpackCapacityThreshold
// 0x0030 (0x0030 - 0x0000)
struct FOakBackpackCapacityThreshold final
{
public:
	float                                         Percentage;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            Color;                                             // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakBackpackCapacityThreshold) == 0x000008, "Wrong alignment on FOakBackpackCapacityThreshold");
static_assert(sizeof(FOakBackpackCapacityThreshold) == 0x000030, "Wrong size on FOakBackpackCapacityThreshold");
static_assert(offsetof(FOakBackpackCapacityThreshold, Percentage) == 0x000000, "Member 'FOakBackpackCapacityThreshold::Percentage' has a wrong offset!");
static_assert(offsetof(FOakBackpackCapacityThreshold, Color) == 0x000008, "Member 'FOakBackpackCapacityThreshold::Color' has a wrong offset!");

// ScriptStruct OakGame.RegionBalanceDataBase
// 0x0010 (0x0010 - 0x0000)
struct FRegionBalanceDataBase
{
public:
	int32                                         MinGameStage;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGameStage;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameStageIncreaseAbovePlayer;                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecifyBoostAbovePlayer;                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegionBalanceDataBase) == 0x000004, "Wrong alignment on FRegionBalanceDataBase");
static_assert(sizeof(FRegionBalanceDataBase) == 0x000010, "Wrong size on FRegionBalanceDataBase");
static_assert(offsetof(FRegionBalanceDataBase, MinGameStage) == 0x000000, "Member 'FRegionBalanceDataBase::MinGameStage' has a wrong offset!");
static_assert(offsetof(FRegionBalanceDataBase, MaxGameStage) == 0x000004, "Member 'FRegionBalanceDataBase::MaxGameStage' has a wrong offset!");
static_assert(offsetof(FRegionBalanceDataBase, GameStageIncreaseAbovePlayer) == 0x000008, "Member 'FRegionBalanceDataBase::GameStageIncreaseAbovePlayer' has a wrong offset!");
static_assert(offsetof(FRegionBalanceDataBase, bSpecifyBoostAbovePlayer) == 0x00000C, "Member 'FRegionBalanceDataBase::bSpecifyBoostAbovePlayer' has a wrong offset!");

// ScriptStruct OakGame.DuelLoserState
// 0x0020 (0x0020 - 0x0000)
struct FDuelLoserState final
{
public:
	class AOakCharacter_Player*                   Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDuelLoseReason                               LoseReason;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x17];                                       // 0x0009(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDuelLoserState) == 0x000008, "Wrong alignment on FDuelLoserState");
static_assert(sizeof(FDuelLoserState) == 0x000020, "Wrong size on FDuelLoserState");
static_assert(offsetof(FDuelLoserState, Player) == 0x000000, "Member 'FDuelLoserState::Player' has a wrong offset!");
static_assert(offsetof(FDuelLoserState, LoseReason) == 0x000008, "Member 'FDuelLoserState::LoseReason' has a wrong offset!");

// ScriptStruct OakGame.ClosedCaptionEntry
// 0x0020 (0x0020 - 0x0000)
struct FClosedCaptionEntry final
{
public:
	class UGbxTextField*                          LineField;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainingLifetime;                                 // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClosedCaptionEntry) == 0x000008, "Wrong alignment on FClosedCaptionEntry");
static_assert(sizeof(FClosedCaptionEntry) == 0x000020, "Wrong size on FClosedCaptionEntry");
static_assert(offsetof(FClosedCaptionEntry, LineField) == 0x000000, "Member 'FClosedCaptionEntry::LineField' has a wrong offset!");
static_assert(offsetof(FClosedCaptionEntry, RemainingLifetime) == 0x000018, "Member 'FClosedCaptionEntry::RemainingLifetime' has a wrong offset!");

// ScriptStruct OakGame.GFxEchoNetMatchmakingActivityData
// 0x00C8 (0x00C8 - 0x0000)
struct FGFxEchoNetMatchmakingActivityData final
{
public:
	struct FGFxEchoNetMathcmakingActivitySubTypeData NormalData;                                        // 0x0000(0x0058)(Transient, NativeAccessSpecifierPublic)
	struct FGFxEchoNetMathcmakingActivitySubTypeData HeroicData;                                        // 0x0058(0x0058)(Transient, NativeAccessSpecifierPublic)
	class FString                                 ImageId;                                           // 0x00B0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtHeroic;                                  // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxEchoNetMatchmakingActivityData) == 0x000008, "Wrong alignment on FGFxEchoNetMatchmakingActivityData");
static_assert(sizeof(FGFxEchoNetMatchmakingActivityData) == 0x0000C8, "Wrong size on FGFxEchoNetMatchmakingActivityData");
static_assert(offsetof(FGFxEchoNetMatchmakingActivityData, NormalData) == 0x000000, "Member 'FGFxEchoNetMatchmakingActivityData::NormalData' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMatchmakingActivityData, HeroicData) == 0x000058, "Member 'FGFxEchoNetMatchmakingActivityData::HeroicData' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMatchmakingActivityData, ImageId) == 0x0000B0, "Member 'FGFxEchoNetMatchmakingActivityData::ImageId' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetMatchmakingActivityData, bLookingAtHeroic) == 0x0000C0, "Member 'FGFxEchoNetMatchmakingActivityData::bLookingAtHeroic' has a wrong offset!");

// ScriptStruct OakGame.GlobalsStandInSettings
// 0x0070 (0x0070 - 0x0000)
struct FGlobalsStandInSettings final
{
public:
	float                                         BaseStandInDepth_EchoRelative;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BaseStandInPosition_EchoRelative;                  // 0x0004(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BaseStandInRotation_EchoRelative;                  // 0x000C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BaseEchoProjectionFXDepth_UIObject;                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPlayerClassIdentifier*, float>    BasePlayerClassScale;                              // 0x0020(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlobalsStandInSettings) == 0x000008, "Wrong alignment on FGlobalsStandInSettings");
static_assert(sizeof(FGlobalsStandInSettings) == 0x000070, "Wrong size on FGlobalsStandInSettings");
static_assert(offsetof(FGlobalsStandInSettings, BaseStandInDepth_EchoRelative) == 0x000000, "Member 'FGlobalsStandInSettings::BaseStandInDepth_EchoRelative' has a wrong offset!");
static_assert(offsetof(FGlobalsStandInSettings, BaseStandInPosition_EchoRelative) == 0x000004, "Member 'FGlobalsStandInSettings::BaseStandInPosition_EchoRelative' has a wrong offset!");
static_assert(offsetof(FGlobalsStandInSettings, BaseStandInRotation_EchoRelative) == 0x00000C, "Member 'FGlobalsStandInSettings::BaseStandInRotation_EchoRelative' has a wrong offset!");
static_assert(offsetof(FGlobalsStandInSettings, BaseEchoProjectionFXDepth_UIObject) == 0x000018, "Member 'FGlobalsStandInSettings::BaseEchoProjectionFXDepth_UIObject' has a wrong offset!");
static_assert(offsetof(FGlobalsStandInSettings, BasePlayerClassScale) == 0x000020, "Member 'FGlobalsStandInSettings::BasePlayerClassScale' has a wrong offset!");

// ScriptStruct OakGame.CarnivoraFakeTurrets
// 0x0060 (0x0060 - 0x0000)
struct FCarnivoraFakeTurrets final
{
public:
	ECarnivoraFakeTurretShootingStyle             ShootingStyle;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDelayBetweenBurstWave;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayInsideBurstShot;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbBulletPerBurst;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightProjectileData>       LightProjectileData;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileSpeed;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrediction;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromPoint;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectHitPct;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadAngle;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugProjectileLine;                           // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentTargetActor;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCarnivoraFakeTurrets) == 0x000008, "Wrong alignment on FCarnivoraFakeTurrets");
static_assert(sizeof(FCarnivoraFakeTurrets) == 0x000060, "Wrong size on FCarnivoraFakeTurrets");
static_assert(offsetof(FCarnivoraFakeTurrets, ShootingStyle) == 0x000000, "Member 'FCarnivoraFakeTurrets::ShootingStyle' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, MinDelayBetweenBurstWave) == 0x000004, "Member 'FCarnivoraFakeTurrets::MinDelayBetweenBurstWave' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, MinDelayInsideBurstShot) == 0x000008, "Member 'FCarnivoraFakeTurrets::MinDelayInsideBurstShot' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, NbBulletPerBurst) == 0x00000C, "Member 'FCarnivoraFakeTurrets::NbBulletPerBurst' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, SocketName) == 0x000010, "Member 'FCarnivoraFakeTurrets::SocketName' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, LightProjectileData) == 0x000018, "Member 'FCarnivoraFakeTurrets::LightProjectileData' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, ProjectileSpeed) == 0x000020, "Member 'FCarnivoraFakeTurrets::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, MaxPrediction) == 0x000024, "Member 'FCarnivoraFakeTurrets::MaxPrediction' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, DamageType) == 0x000028, "Member 'FCarnivoraFakeTurrets::DamageType' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, Range) == 0x000030, "Member 'FCarnivoraFakeTurrets::Range' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, DistanceFromPoint) == 0x000034, "Member 'FCarnivoraFakeTurrets::DistanceFromPoint' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, MaxAngle) == 0x000038, "Member 'FCarnivoraFakeTurrets::MaxAngle' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, DirectHitPct) == 0x00003C, "Member 'FCarnivoraFakeTurrets::DirectHitPct' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, SpreadAngle) == 0x000040, "Member 'FCarnivoraFakeTurrets::SpreadAngle' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, DrawDebugProjectileLine) == 0x000044, "Member 'FCarnivoraFakeTurrets::DrawDebugProjectileLine' has a wrong offset!");
static_assert(offsetof(FCarnivoraFakeTurrets, CurrentTargetActor) == 0x000048, "Member 'FCarnivoraFakeTurrets::CurrentTargetActor' has a wrong offset!");

// ScriptStruct OakGame.LootableMeshSwapData
// 0x0020 (0x0020 - 0x0000)
struct FLootableMeshSwapData final
{
public:
	class USkeletalMesh*                          NewMesh;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRegularOpeningWhenDamaged;                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLootableInteractionResponse           Response;                                          // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootableMeshSwapData) == 0x000008, "Wrong alignment on FLootableMeshSwapData");
static_assert(sizeof(FLootableMeshSwapData) == 0x000020, "Wrong size on FLootableMeshSwapData");
static_assert(offsetof(FLootableMeshSwapData, NewMesh) == 0x000000, "Member 'FLootableMeshSwapData::NewMesh' has a wrong offset!");
static_assert(offsetof(FLootableMeshSwapData, bSkipRegularOpeningWhenDamaged) == 0x000008, "Member 'FLootableMeshSwapData::bSkipRegularOpeningWhenDamaged' has a wrong offset!");
static_assert(offsetof(FLootableMeshSwapData, Response) == 0x000010, "Member 'FLootableMeshSwapData::Response' has a wrong offset!");

// ScriptStruct OakGame.OakPhaseWebSphereBeamData
// 0x0030 (0x0030 - 0x0000)
struct FOakPhaseWebSphereBeamData final
{
public:
	class FName                                   BeamEmitterName;                                   // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BeamParticleSystem;                                // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        BeamSourceComponent;                               // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceSocketName;                                  // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         BeamDestComponent;                                 // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DestSocketName;                                    // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPhaseWebSphereBeamData) == 0x000008, "Wrong alignment on FOakPhaseWebSphereBeamData");
static_assert(sizeof(FOakPhaseWebSphereBeamData) == 0x000030, "Wrong size on FOakPhaseWebSphereBeamData");
static_assert(offsetof(FOakPhaseWebSphereBeamData, BeamEmitterName) == 0x000000, "Member 'FOakPhaseWebSphereBeamData::BeamEmitterName' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereBeamData, BeamParticleSystem) == 0x000008, "Member 'FOakPhaseWebSphereBeamData::BeamParticleSystem' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereBeamData, BeamSourceComponent) == 0x000010, "Member 'FOakPhaseWebSphereBeamData::BeamSourceComponent' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereBeamData, SourceSocketName) == 0x000018, "Member 'FOakPhaseWebSphereBeamData::SourceSocketName' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereBeamData, BeamDestComponent) == 0x000020, "Member 'FOakPhaseWebSphereBeamData::BeamDestComponent' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereBeamData, DestSocketName) == 0x000028, "Member 'FOakPhaseWebSphereBeamData::DestSocketName' has a wrong offset!");

// ScriptStruct OakGame.OakPhaseWebSphereListLock
// 0x0020 (0x0020 - 0x0000)
struct FOakPhaseWebSphereListLock final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakPhaseWebSphere*                     Owner;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AOakCharacter*>                  PendingRemoves;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPhaseWebSphereListLock) == 0x000008, "Wrong alignment on FOakPhaseWebSphereListLock");
static_assert(sizeof(FOakPhaseWebSphereListLock) == 0x000020, "Wrong size on FOakPhaseWebSphereListLock");
static_assert(offsetof(FOakPhaseWebSphereListLock, Owner) == 0x000008, "Member 'FOakPhaseWebSphereListLock::Owner' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereListLock, PendingRemoves) == 0x000010, "Member 'FOakPhaseWebSphereListLock::PendingRemoves' has a wrong offset!");

// ScriptStruct OakGame.PlayerPainSoundData
// 0x0010 (0x0010 - 0x0000)
struct FPlayerPainSoundData final
{
public:
	float                                         HealthPercentThreshold;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSoundTag*                     SoundTag;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerPainSoundData) == 0x000008, "Wrong alignment on FPlayerPainSoundData");
static_assert(sizeof(FPlayerPainSoundData) == 0x000010, "Wrong size on FPlayerPainSoundData");
static_assert(offsetof(FPlayerPainSoundData, HealthPercentThreshold) == 0x000000, "Member 'FPlayerPainSoundData::HealthPercentThreshold' has a wrong offset!");
static_assert(offsetof(FPlayerPainSoundData, SoundTag) == 0x000008, "Member 'FPlayerPainSoundData::SoundTag' has a wrong offset!");

// ScriptStruct OakGame.OakProjectedShield
// 0x0010 (0x0010 - 0x0000)
struct FOakProjectedShield final
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleSystem;                                    // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakProjectedShield) == 0x000008, "Wrong alignment on FOakProjectedShield");
static_assert(sizeof(FOakProjectedShield) == 0x000010, "Wrong size on FOakProjectedShield");
static_assert(offsetof(FOakProjectedShield, StaticMesh) == 0x000000, "Member 'FOakProjectedShield::StaticMesh' has a wrong offset!");
static_assert(offsetof(FOakProjectedShield, ParticleSystem) == 0x000008, "Member 'FOakProjectedShield::ParticleSystem' has a wrong offset!");

// ScriptStruct OakGame.ReplicatedPlayerEchoDeviceState
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FReplicatedPlayerEchoDeviceState final
{
public:
	bool                                          bWantsToBeActive;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEquipType                              EquipType;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ScreenName;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedPlayerEchoDeviceState) == 0x000008, "Wrong alignment on FReplicatedPlayerEchoDeviceState");
static_assert(sizeof(FReplicatedPlayerEchoDeviceState) == 0x000010, "Wrong size on FReplicatedPlayerEchoDeviceState");
static_assert(offsetof(FReplicatedPlayerEchoDeviceState, bWantsToBeActive) == 0x000000, "Member 'FReplicatedPlayerEchoDeviceState::bWantsToBeActive' has a wrong offset!");
static_assert(offsetof(FReplicatedPlayerEchoDeviceState, EquipType) == 0x000001, "Member 'FReplicatedPlayerEchoDeviceState::EquipType' has a wrong offset!");
static_assert(offsetof(FReplicatedPlayerEchoDeviceState, ScreenName) == 0x000008, "Member 'FReplicatedPlayerEchoDeviceState::ScreenName' has a wrong offset!");

// ScriptStruct OakGame.OakSDUEntry
// 0x0014 (0x0020 - 0x000C)
struct FOakSDUEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakSDUData*                            SDUData;                                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SDULevel;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakSDUEntry) == 0x000008, "Wrong alignment on FOakSDUEntry");
static_assert(sizeof(FOakSDUEntry) == 0x000020, "Wrong size on FOakSDUEntry");
static_assert(offsetof(FOakSDUEntry, SDUData) == 0x000010, "Member 'FOakSDUEntry::SDUData' has a wrong offset!");
static_assert(offsetof(FOakSDUEntry, SDULevel) == 0x000018, "Member 'FOakSDUEntry::SDULevel' has a wrong offset!");

// ScriptStruct OakGame.OakSDUContainer
// 0x0048 (0x00F8 - 0x00B0)
struct FOakSDUContainer final : public FFastArraySerializer
{
public:
	TArray<struct FOakSDUEntry>                   SDUList;                                           // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxAttributeModifierHandle>    SDUAttributeModifiers;                             // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakSDUContainer) == 0x000008, "Wrong alignment on FOakSDUContainer");
static_assert(sizeof(FOakSDUContainer) == 0x0000F8, "Wrong size on FOakSDUContainer");
static_assert(offsetof(FOakSDUContainer, SDUList) == 0x0000B0, "Member 'FOakSDUContainer::SDUList' has a wrong offset!");
static_assert(offsetof(FOakSDUContainer, SDUAttributeModifiers) == 0x0000E8, "Member 'FOakSDUContainer::SDUAttributeModifiers' has a wrong offset!");

// ScriptStruct OakGame.ChallengeInWorldIcon
// 0x0018 (0x0018 - 0x0000)
struct FChallengeInWorldIcon final
{
public:
	class UChallengeLevelActorComponent*          LevelActorComponent;                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxInWorldIconContainer*               AssociatedContainer;                               // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxInWorldIcon*                        ChallengeIcon;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeInWorldIcon) == 0x000008, "Wrong alignment on FChallengeInWorldIcon");
static_assert(sizeof(FChallengeInWorldIcon) == 0x000018, "Wrong size on FChallengeInWorldIcon");
static_assert(offsetof(FChallengeInWorldIcon, LevelActorComponent) == 0x000000, "Member 'FChallengeInWorldIcon::LevelActorComponent' has a wrong offset!");
static_assert(offsetof(FChallengeInWorldIcon, AssociatedContainer) == 0x000008, "Member 'FChallengeInWorldIcon::AssociatedContainer' has a wrong offset!");
static_assert(offsetof(FChallengeInWorldIcon, ChallengeIcon) == 0x000010, "Member 'FChallengeInWorldIcon::ChallengeIcon' has a wrong offset!");

// ScriptStruct OakGame.EchoDeviceButtonState
// 0x0008 (0x0008 - 0x0000)
struct FEchoDeviceButtonState final
{
public:
	bool                                          bPressed;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoReleaseDelay;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEchoDeviceButtonState) == 0x000004, "Wrong alignment on FEchoDeviceButtonState");
static_assert(sizeof(FEchoDeviceButtonState) == 0x000008, "Wrong size on FEchoDeviceButtonState");
static_assert(offsetof(FEchoDeviceButtonState, bPressed) == 0x000000, "Member 'FEchoDeviceButtonState::bPressed' has a wrong offset!");
static_assert(offsetof(FEchoDeviceButtonState, AutoReleaseDelay) == 0x000004, "Member 'FEchoDeviceButtonState::AutoReleaseDelay' has a wrong offset!");

// ScriptStruct OakGame.EchoDeviceTargetFXPosition
// 0x0020 (0x0020 - 0x0000)
struct FEchoDeviceTargetFXPosition final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          UIObject;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEchoDeviceTargetFXPosition) == 0x000008, "Wrong alignment on FEchoDeviceTargetFXPosition");
static_assert(sizeof(FEchoDeviceTargetFXPosition) == 0x000020, "Wrong size on FEchoDeviceTargetFXPosition");
static_assert(offsetof(FEchoDeviceTargetFXPosition, UIObject) == 0x000008, "Member 'FEchoDeviceTargetFXPosition::UIObject' has a wrong offset!");

// ScriptStruct OakGame.PlayerEchoDeviceState
// 0x0260 (0x0260 - 0x0000)
struct FPlayerEchoDeviceState final
{
public:
	TSubclassOf<class AEchoDevice>                EchoDeviceBlueprint;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             OverrideScreenDataTable;                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetInterpSpeed;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BaseScreenPositionOffset;                          // 0x0018(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOffset;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEchoDevice*                            EchoDevice;                                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttached;                                       // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x147];                                     // 0x0031(0x0147)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   IdleScreenName;                                    // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentScreenName;                                 // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NextScreenName;                                    // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FEchoDeviceButtonState                 ButtonStates[0x3];                                 // 0x01B0(0x0008)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              DPadAxes;                                          // 0x01C8(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              LastDPadAxes;                                      // 0x01D0(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentMenuName;                                   // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              CurrentScreenPosition;                             // 0x01E0(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               CurrentRotationOffset;                             // 0x01E8(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEchoDeviceTargetFXPosition            ProjectionFXPosition;                              // 0x01F8(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedInMenuFXTransform;                           // 0x0220(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerEchoDeviceState) == 0x000010, "Wrong alignment on FPlayerEchoDeviceState");
static_assert(sizeof(FPlayerEchoDeviceState) == 0x000260, "Wrong size on FPlayerEchoDeviceState");
static_assert(offsetof(FPlayerEchoDeviceState, EchoDeviceBlueprint) == 0x000000, "Member 'FPlayerEchoDeviceState::EchoDeviceBlueprint' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, OverrideScreenDataTable) == 0x000008, "Member 'FPlayerEchoDeviceState::OverrideScreenDataTable' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, OffsetInterpSpeed) == 0x000010, "Member 'FPlayerEchoDeviceState::OffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, RotationInterpSpeed) == 0x000014, "Member 'FPlayerEchoDeviceState::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, BaseScreenPositionOffset) == 0x000018, "Member 'FPlayerEchoDeviceState::BaseScreenPositionOffset' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, DepthOffset) == 0x000020, "Member 'FPlayerEchoDeviceState::DepthOffset' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, EchoDevice) == 0x000028, "Member 'FPlayerEchoDeviceState::EchoDevice' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, bIsAttached) == 0x000030, "Member 'FPlayerEchoDeviceState::bIsAttached' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, IdleScreenName) == 0x000178, "Member 'FPlayerEchoDeviceState::IdleScreenName' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, CurrentScreenName) == 0x000190, "Member 'FPlayerEchoDeviceState::CurrentScreenName' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, NextScreenName) == 0x0001A8, "Member 'FPlayerEchoDeviceState::NextScreenName' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, ButtonStates) == 0x0001B0, "Member 'FPlayerEchoDeviceState::ButtonStates' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, DPadAxes) == 0x0001C8, "Member 'FPlayerEchoDeviceState::DPadAxes' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, LastDPadAxes) == 0x0001D0, "Member 'FPlayerEchoDeviceState::LastDPadAxes' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, CurrentMenuName) == 0x0001D8, "Member 'FPlayerEchoDeviceState::CurrentMenuName' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, CurrentScreenPosition) == 0x0001E0, "Member 'FPlayerEchoDeviceState::CurrentScreenPosition' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, CurrentRotationOffset) == 0x0001E8, "Member 'FPlayerEchoDeviceState::CurrentRotationOffset' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, ProjectionFXPosition) == 0x0001F8, "Member 'FPlayerEchoDeviceState::ProjectionFXPosition' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceState, CachedInMenuFXTransform) == 0x000220, "Member 'FPlayerEchoDeviceState::CachedInMenuFXTransform' has a wrong offset!");

// ScriptStruct OakGame.VaultCardRewardDataBase
// 0x0048 (0x0048 - 0x0000)
struct FVaultCardRewardDataBase
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 PerkFrameName;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VaultCardRewardKeyCost;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultCardRewardDataBase) == 0x000008, "Wrong alignment on FVaultCardRewardDataBase");
static_assert(sizeof(FVaultCardRewardDataBase) == 0x000048, "Wrong size on FVaultCardRewardDataBase");
static_assert(offsetof(FVaultCardRewardDataBase, DisplayName) == 0x000000, "Member 'FVaultCardRewardDataBase::DisplayName' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardDataBase, Description) == 0x000018, "Member 'FVaultCardRewardDataBase::Description' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardDataBase, PerkFrameName) == 0x000030, "Member 'FVaultCardRewardDataBase::PerkFrameName' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardDataBase, VaultCardRewardKeyCost) == 0x000040, "Member 'FVaultCardRewardDataBase::VaultCardRewardKeyCost' has a wrong offset!");

// ScriptStruct OakGame.ShieldEffectStateData
// 0x0020 (0x0020 - 0x0000)
struct FShieldEffectStateData final
{
public:
	class UOakStatusEffectManagerComponent*       Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EShieldEffectState                            State;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    RelativeHitLocation;                               // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NextHitTime;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShieldEffectStateData) == 0x000008, "Wrong alignment on FShieldEffectStateData");
static_assert(sizeof(FShieldEffectStateData) == 0x000020, "Wrong size on FShieldEffectStateData");
static_assert(offsetof(FShieldEffectStateData, Owner) == 0x000000, "Member 'FShieldEffectStateData::Owner' has a wrong offset!");
static_assert(offsetof(FShieldEffectStateData, State) == 0x000008, "Member 'FShieldEffectStateData::State' has a wrong offset!");
static_assert(offsetof(FShieldEffectStateData, RelativeHitLocation) == 0x00000C, "Member 'FShieldEffectStateData::RelativeHitLocation' has a wrong offset!");
static_assert(offsetof(FShieldEffectStateData, NextHitTime) == 0x000018, "Member 'FShieldEffectStateData::NextHitTime' has a wrong offset!");

// ScriptStruct OakGame.AIOCameraEntryTransition
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FAIOCameraEntryTransition final
{
public:
	class FName                                   TransitionName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          AngleRange;                                        // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0010(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocationDuration;                         // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationDurationOverride;                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRotationDuration;                         // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationDurationOverride;                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIOCameraEntryTransition) == 0x000008, "Wrong alignment on FAIOCameraEntryTransition");
static_assert(sizeof(FAIOCameraEntryTransition) == 0x000030, "Wrong size on FAIOCameraEntryTransition");
static_assert(offsetof(FAIOCameraEntryTransition, TransitionName) == 0x000000, "Member 'FAIOCameraEntryTransition::TransitionName' has a wrong offset!");
static_assert(offsetof(FAIOCameraEntryTransition, AngleRange) == 0x000008, "Member 'FAIOCameraEntryTransition::AngleRange' has a wrong offset!");
static_assert(offsetof(FAIOCameraEntryTransition, StartLocation) == 0x000010, "Member 'FAIOCameraEntryTransition::StartLocation' has a wrong offset!");
static_assert(offsetof(FAIOCameraEntryTransition, bOverrideLocationDuration) == 0x00001C, "Member 'FAIOCameraEntryTransition::bOverrideLocationDuration' has a wrong offset!");
static_assert(offsetof(FAIOCameraEntryTransition, LocationDurationOverride) == 0x000020, "Member 'FAIOCameraEntryTransition::LocationDurationOverride' has a wrong offset!");
static_assert(offsetof(FAIOCameraEntryTransition, bOverrideRotationDuration) == 0x000024, "Member 'FAIOCameraEntryTransition::bOverrideRotationDuration' has a wrong offset!");
static_assert(offsetof(FAIOCameraEntryTransition, RotationDurationOverride) == 0x000028, "Member 'FAIOCameraEntryTransition::RotationDurationOverride' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryMenuItemGrouping
// 0x0018 (0x0018 - 0x0000)
struct FOakInventoryMenuItemGrouping final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTypeAsset*                       WeaponTypeData;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManufacturerData*                      ManufacturerData;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakInventoryMenuItemGrouping) == 0x000008, "Wrong alignment on FOakInventoryMenuItemGrouping");
static_assert(sizeof(FOakInventoryMenuItemGrouping) == 0x000018, "Wrong size on FOakInventoryMenuItemGrouping");
static_assert(offsetof(FOakInventoryMenuItemGrouping, ID) == 0x000000, "Member 'FOakInventoryMenuItemGrouping::ID' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuItemGrouping, WeaponTypeData) == 0x000008, "Member 'FOakInventoryMenuItemGrouping::WeaponTypeData' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuItemGrouping, ManufacturerData) == 0x000010, "Member 'FOakInventoryMenuItemGrouping::ManufacturerData' has a wrong offset!");

// ScriptStruct OakGame.ReplicatedStolenProjectileData
// 0x0010 (0x0010 - 0x0000)
struct FReplicatedStolenProjectileData final
{
public:
	class FName                                   Socket;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Projectile;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedStolenProjectileData) == 0x000008, "Wrong alignment on FReplicatedStolenProjectileData");
static_assert(sizeof(FReplicatedStolenProjectileData) == 0x000010, "Wrong size on FReplicatedStolenProjectileData");
static_assert(offsetof(FReplicatedStolenProjectileData, Socket) == 0x000000, "Member 'FReplicatedStolenProjectileData::Socket' has a wrong offset!");
static_assert(offsetof(FReplicatedStolenProjectileData, Projectile) == 0x000008, "Member 'FReplicatedStolenProjectileData::Projectile' has a wrong offset!");

// ScriptStruct OakGame.PhaseTranceActivationComboData
// 0x0018 (0x0018 - 0x0000)
struct FPhaseTranceActivationComboData final
{
public:
	class UOakActionAbilityAugmentData_PhaseTrance_Attack* AttackData;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakActionAbilityAugmentData_PhaseTrance_Effect* EffectData;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakActionAbilityAugmentData_PhaseTrance_Element* ElementData;                                       // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhaseTranceActivationComboData) == 0x000008, "Wrong alignment on FPhaseTranceActivationComboData");
static_assert(sizeof(FPhaseTranceActivationComboData) == 0x000018, "Wrong size on FPhaseTranceActivationComboData");
static_assert(offsetof(FPhaseTranceActivationComboData, AttackData) == 0x000000, "Member 'FPhaseTranceActivationComboData::AttackData' has a wrong offset!");
static_assert(offsetof(FPhaseTranceActivationComboData, EffectData) == 0x000008, "Member 'FPhaseTranceActivationComboData::EffectData' has a wrong offset!");
static_assert(offsetof(FPhaseTranceActivationComboData, ElementData) == 0x000010, "Member 'FPhaseTranceActivationComboData::ElementData' has a wrong offset!");

// ScriptStruct OakGame.OakPhaseTranceEffectSpec
// 0x0030 (0x0030 - 0x0000)
struct FOakPhaseTranceEffectSpec final
{
public:
	int32                                         EffectMask;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhaseTranceActivationComboData        ComboData;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 EffectTarget;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageData;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPhaseTranceEffectSpec) == 0x000008, "Wrong alignment on FOakPhaseTranceEffectSpec");
static_assert(sizeof(FOakPhaseTranceEffectSpec) == 0x000030, "Wrong size on FOakPhaseTranceEffectSpec");
static_assert(offsetof(FOakPhaseTranceEffectSpec, EffectMask) == 0x000000, "Member 'FOakPhaseTranceEffectSpec::EffectMask' has a wrong offset!");
static_assert(offsetof(FOakPhaseTranceEffectSpec, ComboData) == 0x000008, "Member 'FOakPhaseTranceEffectSpec::ComboData' has a wrong offset!");
static_assert(offsetof(FOakPhaseTranceEffectSpec, EffectTarget) == 0x000020, "Member 'FOakPhaseTranceEffectSpec::EffectTarget' has a wrong offset!");
static_assert(offsetof(FOakPhaseTranceEffectSpec, DamageData) == 0x000028, "Member 'FOakPhaseTranceEffectSpec::DamageData' has a wrong offset!");

// ScriptStruct OakGame.LevelBasedExpScale
// 0x000C (0x000C - 0x0000)
struct FLevelBasedExpScale final
{
public:
	int32                                         LevelDifference;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HigherLevelEnemyExpScale;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLevelEnemyExpScale;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelBasedExpScale) == 0x000004, "Wrong alignment on FLevelBasedExpScale");
static_assert(sizeof(FLevelBasedExpScale) == 0x00000C, "Wrong size on FLevelBasedExpScale");
static_assert(offsetof(FLevelBasedExpScale, LevelDifference) == 0x000000, "Member 'FLevelBasedExpScale::LevelDifference' has a wrong offset!");
static_assert(offsetof(FLevelBasedExpScale, HigherLevelEnemyExpScale) == 0x000004, "Member 'FLevelBasedExpScale::HigherLevelEnemyExpScale' has a wrong offset!");
static_assert(offsetof(FLevelBasedExpScale, LowerLevelEnemyExpScale) == 0x000008, "Member 'FLevelBasedExpScale::LowerLevelEnemyExpScale' has a wrong offset!");

// ScriptStruct OakGame.GFxEchoNetRosterMenu_Adjustment
// 0x0010 (0x0010 - 0x0000)
struct FGFxEchoNetRosterMenu_Adjustment final
{
public:
	struct FVector2D                              ContextMenuOffsetExpandingDown;                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContextMenuOffsetExpandingUp;                      // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxEchoNetRosterMenu_Adjustment) == 0x000004, "Wrong alignment on FGFxEchoNetRosterMenu_Adjustment");
static_assert(sizeof(FGFxEchoNetRosterMenu_Adjustment) == 0x000010, "Wrong size on FGFxEchoNetRosterMenu_Adjustment");
static_assert(offsetof(FGFxEchoNetRosterMenu_Adjustment, ContextMenuOffsetExpandingDown) == 0x000000, "Member 'FGFxEchoNetRosterMenu_Adjustment::ContextMenuOffsetExpandingDown' has a wrong offset!");
static_assert(offsetof(FGFxEchoNetRosterMenu_Adjustment, ContextMenuOffsetExpandingUp) == 0x000008, "Member 'FGFxEchoNetRosterMenu_Adjustment::ContextMenuOffsetExpandingUp' has a wrong offset!");

// ScriptStruct OakGame.VendingMachineSequenceTimedEvent
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FVendingMachineSequenceTimedEvent final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingMachineSequenceTimedEvent) == 0x000008, "Wrong alignment on FVendingMachineSequenceTimedEvent");
static_assert(sizeof(FVendingMachineSequenceTimedEvent) == 0x000010, "Wrong size on FVendingMachineSequenceTimedEvent");
static_assert(offsetof(FVendingMachineSequenceTimedEvent, Delay) == 0x000000, "Member 'FVendingMachineSequenceTimedEvent::Delay' has a wrong offset!");
static_assert(offsetof(FVendingMachineSequenceTimedEvent, EventName) == 0x000008, "Member 'FVendingMachineSequenceTimedEvent::EventName' has a wrong offset!");

// ScriptStruct OakGame.MissionSpawnerFailsafeData
// 0x0010 (0x0010 - 0x0000)
struct FMissionSpawnerFailsafeData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailsafeSeconds;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionSpawnerFailsafeData) == 0x000008, "Wrong alignment on FMissionSpawnerFailsafeData");
static_assert(sizeof(FMissionSpawnerFailsafeData) == 0x000010, "Wrong size on FMissionSpawnerFailsafeData");
static_assert(offsetof(FMissionSpawnerFailsafeData, Actor) == 0x000000, "Member 'FMissionSpawnerFailsafeData::Actor' has a wrong offset!");
static_assert(offsetof(FMissionSpawnerFailsafeData, FailsafeSeconds) == 0x000008, "Member 'FMissionSpawnerFailsafeData::FailsafeSeconds' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityTimer
// 0x0028 (0x0028 - 0x0000)
struct FOakAbilityTimer final
{
public:
	struct FOakAbilityTimerSpec                   Spec;                                              // 0x0000(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0xC];                                       // 0x001C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityTimer) == 0x000008, "Wrong alignment on FOakAbilityTimer");
static_assert(sizeof(FOakAbilityTimer) == 0x000028, "Wrong size on FOakAbilityTimer");
static_assert(offsetof(FOakAbilityTimer, Spec) == 0x000000, "Member 'FOakAbilityTimer::Spec' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimer, Value) == 0x000018, "Member 'FOakAbilityTimer::Value' has a wrong offset!");

// ScriptStruct OakGame.GRMLNHoverProfile
// 0x0038 (0x0038 - 0x0000)
struct FGRMLNHoverProfile final
{
public:
	EOakDroneMovementMode                         MovementMode;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableValueHandle                  Radius;                                            // 0x0008(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableValueHandle                  Altitude;                                          // 0x0020(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGRMLNHoverProfile) == 0x000008, "Wrong alignment on FGRMLNHoverProfile");
static_assert(sizeof(FGRMLNHoverProfile) == 0x000038, "Wrong size on FGRMLNHoverProfile");
static_assert(offsetof(FGRMLNHoverProfile, MovementMode) == 0x000000, "Member 'FGRMLNHoverProfile::MovementMode' has a wrong offset!");
static_assert(offsetof(FGRMLNHoverProfile, Radius) == 0x000008, "Member 'FGRMLNHoverProfile::Radius' has a wrong offset!");
static_assert(offsetof(FGRMLNHoverProfile, Altitude) == 0x000020, "Member 'FGRMLNHoverProfile::Altitude' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAnimInstanceProxy
// 0x0010 (0x06E0 - 0x06D0)
struct FOakPlayerAnimInstanceProxy : public FGbxCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_6D0[0x10];                                     // 0x06D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPlayerAnimInstanceProxy) == 0x000010, "Wrong alignment on FOakPlayerAnimInstanceProxy");
static_assert(sizeof(FOakPlayerAnimInstanceProxy) == 0x0006E0, "Wrong size on FOakPlayerAnimInstanceProxy");

// ScriptStruct OakGame.OakElementalAuraEffectData
// 0x0060 (0x0060 - 0x0000)
struct FOakElementalAuraEffectData final
{
public:
	class UOakElementalEffectData*                ElementalEffectData;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamageRadius;                                      // 0x0010(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      DamagedActorModifier;                              // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      DamageCauserModifier;                              // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRate;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakElementalAuraEffectData) == 0x000008, "Wrong alignment on FOakElementalAuraEffectData");
static_assert(sizeof(FOakElementalAuraEffectData) == 0x000060, "Wrong size on FOakElementalAuraEffectData");
static_assert(offsetof(FOakElementalAuraEffectData, ElementalEffectData) == 0x000000, "Member 'FOakElementalAuraEffectData::ElementalEffectData' has a wrong offset!");
static_assert(offsetof(FOakElementalAuraEffectData, DamageData) == 0x000008, "Member 'FOakElementalAuraEffectData::DamageData' has a wrong offset!");
static_assert(offsetof(FOakElementalAuraEffectData, DamageRadius) == 0x000010, "Member 'FOakElementalAuraEffectData::DamageRadius' has a wrong offset!");
static_assert(offsetof(FOakElementalAuraEffectData, DamagedActorModifier) == 0x000048, "Member 'FOakElementalAuraEffectData::DamagedActorModifier' has a wrong offset!");
static_assert(offsetof(FOakElementalAuraEffectData, DamageCauserModifier) == 0x000050, "Member 'FOakElementalAuraEffectData::DamageCauserModifier' has a wrong offset!");
static_assert(offsetof(FOakElementalAuraEffectData, DamageRate) == 0x000058, "Member 'FOakElementalAuraEffectData::DamageRate' has a wrong offset!");

// ScriptStruct OakGame.OakElementalAuraEffectInstance
// 0x0068 (0x0068 - 0x0000)
struct FOakElementalAuraEffectInstance final
{
public:
	struct FOakElementalAuraEffectData            Data;                                              // 0x0000(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakElementalAuraEffectInstance) == 0x000008, "Wrong alignment on FOakElementalAuraEffectInstance");
static_assert(sizeof(FOakElementalAuraEffectInstance) == 0x000068, "Wrong size on FOakElementalAuraEffectInstance");
static_assert(offsetof(FOakElementalAuraEffectInstance, Data) == 0x000000, "Member 'FOakElementalAuraEffectInstance::Data' has a wrong offset!");

// ScriptStruct OakGame.OakInteractiveEventStats
// 0x0020 (0x0020 - 0x0000)
struct FOakInteractiveEventStats final
{
public:
	int32                                         NbRareChestEvents;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareChestEventWinners;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbBadassEvents;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadassViewersKilled;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbPinataEvents;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbMoxxisEvents;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoxxisEventTotalBits;                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbExtractionEvents;                                // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakInteractiveEventStats) == 0x000004, "Wrong alignment on FOakInteractiveEventStats");
static_assert(sizeof(FOakInteractiveEventStats) == 0x000020, "Wrong size on FOakInteractiveEventStats");
static_assert(offsetof(FOakInteractiveEventStats, NbRareChestEvents) == 0x000000, "Member 'FOakInteractiveEventStats::NbRareChestEvents' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, RareChestEventWinners) == 0x000004, "Member 'FOakInteractiveEventStats::RareChestEventWinners' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, NbBadassEvents) == 0x000008, "Member 'FOakInteractiveEventStats::NbBadassEvents' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, BadassViewersKilled) == 0x00000C, "Member 'FOakInteractiveEventStats::BadassViewersKilled' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, NbPinataEvents) == 0x000010, "Member 'FOakInteractiveEventStats::NbPinataEvents' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, NbMoxxisEvents) == 0x000014, "Member 'FOakInteractiveEventStats::NbMoxxisEvents' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, MoxxisEventTotalBits) == 0x000018, "Member 'FOakInteractiveEventStats::MoxxisEventTotalBits' has a wrong offset!");
static_assert(offsetof(FOakInteractiveEventStats, NbExtractionEvents) == 0x00001C, "Member 'FOakInteractiveEventStats::NbExtractionEvents' has a wrong offset!");

// ScriptStruct OakGame.ExpAwardWeight
// 0x000C (0x000C - 0x0000)
struct FExpAwardWeight final
{
public:
	int32                                         Players;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerExpBonus;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpWeight;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExpAwardWeight) == 0x000004, "Wrong alignment on FExpAwardWeight");
static_assert(sizeof(FExpAwardWeight) == 0x00000C, "Wrong size on FExpAwardWeight");
static_assert(offsetof(FExpAwardWeight, Players) == 0x000000, "Member 'FExpAwardWeight::Players' has a wrong offset!");
static_assert(offsetof(FExpAwardWeight, KillerExpBonus) == 0x000004, "Member 'FExpAwardWeight::KillerExpBonus' has a wrong offset!");
static_assert(offsetof(FExpAwardWeight, ExpWeight) == 0x000008, "Member 'FExpAwardWeight::ExpWeight' has a wrong offset!");

// ScriptStruct OakGame.StreamerBoosterStatus
// 0x0018 (0x0018 - 0x0000)
struct FStreamerBoosterStatus final
{
public:
	class UOakStatusEffectManagerComponent*       Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          PrimaryBoosterStatusIndex;                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          SecondaryBoosterStatusIndex;                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeDuration;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeRemaining;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamerBoosterStatus) == 0x000008, "Wrong alignment on FStreamerBoosterStatus");
static_assert(sizeof(FStreamerBoosterStatus) == 0x000018, "Wrong size on FStreamerBoosterStatus");
static_assert(offsetof(FStreamerBoosterStatus, Owner) == 0x000000, "Member 'FStreamerBoosterStatus::Owner' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterStatus, PrimaryBoosterStatusIndex) == 0x000008, "Member 'FStreamerBoosterStatus::PrimaryBoosterStatusIndex' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterStatus, SecondaryBoosterStatusIndex) == 0x000009, "Member 'FStreamerBoosterStatus::SecondaryBoosterStatusIndex' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterStatus, TimeDuration) == 0x00000C, "Member 'FStreamerBoosterStatus::TimeDuration' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterStatus, TimeRemaining) == 0x000010, "Member 'FStreamerBoosterStatus::TimeRemaining' has a wrong offset!");

// ScriptStruct OakGame.AILootDropOverride
// 0x0018 (0x0018 - 0x0000)
struct FAILootDropOverride final
{
public:
	uint8                                         bOverrideDropPattern : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideSocketName : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisabledByDefault : 1;                            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULootSpawnPatternData*                  OverrideDropPattern;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAILootDropOverride) == 0x000008, "Wrong alignment on FAILootDropOverride");
static_assert(sizeof(FAILootDropOverride) == 0x000018, "Wrong size on FAILootDropOverride");
static_assert(offsetof(FAILootDropOverride, SocketName) == 0x000008, "Member 'FAILootDropOverride::SocketName' has a wrong offset!");
static_assert(offsetof(FAILootDropOverride, OverrideDropPattern) == 0x000010, "Member 'FAILootDropOverride::OverrideDropPattern' has a wrong offset!");

// ScriptStruct OakGame.StandInLightingSetting
// 0x0068 (0x0068 - 0x0000)
struct FStandInLightingSetting final
{
public:
	struct FStandInLightingConfig                 DefaultLighting;                                   // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TMap<class UPlayerClassIdentifier*, struct FStandInLightingConfig> PlayerClassLighting;                               // 0x0018(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInLightingSetting) == 0x000008, "Wrong alignment on FStandInLightingSetting");
static_assert(sizeof(FStandInLightingSetting) == 0x000068, "Wrong size on FStandInLightingSetting");
static_assert(offsetof(FStandInLightingSetting, DefaultLighting) == 0x000000, "Member 'FStandInLightingSetting::DefaultLighting' has a wrong offset!");
static_assert(offsetof(FStandInLightingSetting, PlayerClassLighting) == 0x000018, "Member 'FStandInLightingSetting::PlayerClassLighting' has a wrong offset!");

// ScriptStruct OakGame.StandInScaleSetting
// 0x0068 (0x0068 - 0x0000)
struct FStandInScaleSetting final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPlayerClassIdentifier*, float>    PlayerClassScale;                                  // 0x0008(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EStandInAutoScaleMode                         AutoScaleMode;                                     // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AutoScaleExtent;                                   // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInScaleSetting) == 0x000008, "Wrong alignment on FStandInScaleSetting");
static_assert(sizeof(FStandInScaleSetting) == 0x000068, "Wrong size on FStandInScaleSetting");
static_assert(offsetof(FStandInScaleSetting, Scale) == 0x000000, "Member 'FStandInScaleSetting::Scale' has a wrong offset!");
static_assert(offsetof(FStandInScaleSetting, PlayerClassScale) == 0x000008, "Member 'FStandInScaleSetting::PlayerClassScale' has a wrong offset!");
static_assert(offsetof(FStandInScaleSetting, AutoScaleMode) == 0x000058, "Member 'FStandInScaleSetting::AutoScaleMode' has a wrong offset!");
static_assert(offsetof(FStandInScaleSetting, AutoScaleExtent) == 0x00005C, "Member 'FStandInScaleSetting::AutoScaleExtent' has a wrong offset!");

// ScriptStruct OakGame.StandInPlayerClassSpecificPositionSettingContextOverride
// 0x0018 (0x0018 - 0x0000)
struct FStandInPlayerClassSpecificPositionSettingContextOverride final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultRotation;                                   // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInPlayerClassSpecificPositionSettingContextOverride) == 0x000004, "Wrong alignment on FStandInPlayerClassSpecificPositionSettingContextOverride");
static_assert(sizeof(FStandInPlayerClassSpecificPositionSettingContextOverride) == 0x000018, "Wrong size on FStandInPlayerClassSpecificPositionSettingContextOverride");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSettingContextOverride, ScreenPosition) == 0x000000, "Member 'FStandInPlayerClassSpecificPositionSettingContextOverride::ScreenPosition' has a wrong offset!");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSettingContextOverride, DefaultRotation) == 0x000008, "Member 'FStandInPlayerClassSpecificPositionSettingContextOverride::DefaultRotation' has a wrong offset!");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSettingContextOverride, Depth) == 0x000014, "Member 'FStandInPlayerClassSpecificPositionSettingContextOverride::Depth' has a wrong offset!");

// ScriptStruct OakGame.StandInPlayerClassSpecificPositionSetting
// 0x0068 (0x0068 - 0x0000)
struct FStandInPlayerClassSpecificPositionSetting final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultRotation;                                   // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FStandInPlayerClassSpecificPositionSettingContextOverride> ContextOverrides;                                  // 0x0018(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInPlayerClassSpecificPositionSetting) == 0x000008, "Wrong alignment on FStandInPlayerClassSpecificPositionSetting");
static_assert(sizeof(FStandInPlayerClassSpecificPositionSetting) == 0x000068, "Wrong size on FStandInPlayerClassSpecificPositionSetting");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSetting, ScreenPosition) == 0x000000, "Member 'FStandInPlayerClassSpecificPositionSetting::ScreenPosition' has a wrong offset!");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSetting, DefaultRotation) == 0x000008, "Member 'FStandInPlayerClassSpecificPositionSetting::DefaultRotation' has a wrong offset!");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSetting, Depth) == 0x000014, "Member 'FStandInPlayerClassSpecificPositionSetting::Depth' has a wrong offset!");
static_assert(offsetof(FStandInPlayerClassSpecificPositionSetting, ContextOverrides) == 0x000018, "Member 'FStandInPlayerClassSpecificPositionSetting::ContextOverrides' has a wrong offset!");

// ScriptStruct OakGame.StandInPositionSetting
// 0x0078 (0x0078 - 0x0000)
struct FStandInPositionSetting final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultRotation;                                   // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientProjectionFX;                               // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ProjectionFXOffset;                                // 0x001C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectionFXDepthOffset;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UPlayerClassIdentifier*, struct FStandInPlayerClassSpecificPositionSetting> PlayerClassPosition;                               // 0x0028(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStandInPositionSetting) == 0x000008, "Wrong alignment on FStandInPositionSetting");
static_assert(sizeof(FStandInPositionSetting) == 0x000078, "Wrong size on FStandInPositionSetting");
static_assert(offsetof(FStandInPositionSetting, ScreenPosition) == 0x000000, "Member 'FStandInPositionSetting::ScreenPosition' has a wrong offset!");
static_assert(offsetof(FStandInPositionSetting, DefaultRotation) == 0x000008, "Member 'FStandInPositionSetting::DefaultRotation' has a wrong offset!");
static_assert(offsetof(FStandInPositionSetting, Depth) == 0x000014, "Member 'FStandInPositionSetting::Depth' has a wrong offset!");
static_assert(offsetof(FStandInPositionSetting, bOrientProjectionFX) == 0x000018, "Member 'FStandInPositionSetting::bOrientProjectionFX' has a wrong offset!");
static_assert(offsetof(FStandInPositionSetting, ProjectionFXOffset) == 0x00001C, "Member 'FStandInPositionSetting::ProjectionFXOffset' has a wrong offset!");
static_assert(offsetof(FStandInPositionSetting, ProjectionFXDepthOffset) == 0x000024, "Member 'FStandInPositionSetting::ProjectionFXDepthOffset' has a wrong offset!");
static_assert(offsetof(FStandInPositionSetting, PlayerClassPosition) == 0x000028, "Member 'FStandInPositionSetting::PlayerClassPosition' has a wrong offset!");

// ScriptStruct OakGame.StandInUIConfigData
// 0x0410 (0x0418 - 0x0008)
struct FStandInUIConfigData final : public FTableRowBase
{
public:
	bool                                          bPositionRelativeToEchoDeviceProjectionSocket;     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomPivotSocket;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockStandInPositionOnFadeOut;                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStandInLightingSetting                Lighting;                                          // 0x0020(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FStandInScaleSetting                   Scale;                                             // 0x0088(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FStandInPositionSetting                Positioning;                                       // 0x00F0(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FStandInScaleSetting                   ScaleSplitScreen;                                  // 0x0168(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FStandInScaleSetting                   ScaleVerticalSplitScreen;                          // 0x01D0(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FStandInScaleSetting                   ScaleQuadSplitScreen;                              // 0x0238(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FStandInPositionSetting                PositioningSplitScreen;                            // 0x02A0(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FStandInPositionSetting                PositioningVerticalSplitScreen;                    // 0x0318(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FStandInPositionSetting                PositioningQuadSplitScreen;                        // 0x0390(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bMayAlterRotationDamping;                          // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationDamping;                                   // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationDamping;                                   // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandInUIConfigData) == 0x000008, "Wrong alignment on FStandInUIConfigData");
static_assert(sizeof(FStandInUIConfigData) == 0x000418, "Wrong size on FStandInUIConfigData");
static_assert(offsetof(FStandInUIConfigData, bPositionRelativeToEchoDeviceProjectionSocket) == 0x000008, "Member 'FStandInUIConfigData::bPositionRelativeToEchoDeviceProjectionSocket' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, CustomPivotSocket) == 0x000010, "Member 'FStandInUIConfigData::CustomPivotSocket' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, bLockStandInPositionOnFadeOut) == 0x000018, "Member 'FStandInUIConfigData::bLockStandInPositionOnFadeOut' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, Lighting) == 0x000020, "Member 'FStandInUIConfigData::Lighting' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, Scale) == 0x000088, "Member 'FStandInUIConfigData::Scale' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, Positioning) == 0x0000F0, "Member 'FStandInUIConfigData::Positioning' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, ScaleSplitScreen) == 0x000168, "Member 'FStandInUIConfigData::ScaleSplitScreen' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, ScaleVerticalSplitScreen) == 0x0001D0, "Member 'FStandInUIConfigData::ScaleVerticalSplitScreen' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, ScaleQuadSplitScreen) == 0x000238, "Member 'FStandInUIConfigData::ScaleQuadSplitScreen' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, PositioningSplitScreen) == 0x0002A0, "Member 'FStandInUIConfigData::PositioningSplitScreen' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, PositioningVerticalSplitScreen) == 0x000318, "Member 'FStandInUIConfigData::PositioningVerticalSplitScreen' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, PositioningQuadSplitScreen) == 0x000390, "Member 'FStandInUIConfigData::PositioningQuadSplitScreen' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, bMayAlterRotationDamping) == 0x000408, "Member 'FStandInUIConfigData::bMayAlterRotationDamping' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, RotationDamping) == 0x00040C, "Member 'FStandInUIConfigData::RotationDamping' has a wrong offset!");
static_assert(offsetof(FStandInUIConfigData, LocationDamping) == 0x000410, "Member 'FStandInUIConfigData::LocationDamping' has a wrong offset!");

// ScriptStruct OakGame.InteractiveObjectTrapEntry
// 0x0010 (0x0010 - 0x0000)
struct FInteractiveObjectTrapEntry final
{
public:
	class AInteractiveObject*                     TrapActor;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractiveObjectTrapActivationType          ActivationType;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstructionDelay;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractiveObjectTrapEntry) == 0x000008, "Wrong alignment on FInteractiveObjectTrapEntry");
static_assert(sizeof(FInteractiveObjectTrapEntry) == 0x000010, "Wrong size on FInteractiveObjectTrapEntry");
static_assert(offsetof(FInteractiveObjectTrapEntry, TrapActor) == 0x000000, "Member 'FInteractiveObjectTrapEntry::TrapActor' has a wrong offset!");
static_assert(offsetof(FInteractiveObjectTrapEntry, ActivationType) == 0x000008, "Member 'FInteractiveObjectTrapEntry::ActivationType' has a wrong offset!");
static_assert(offsetof(FInteractiveObjectTrapEntry, InstructionDelay) == 0x00000C, "Member 'FInteractiveObjectTrapEntry::InstructionDelay' has a wrong offset!");

// ScriptStruct OakGame.GrenadeAttachedTrail
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGrenadeAttachedTrail final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrenadeAttachedTrail) == 0x000008, "Wrong alignment on FGrenadeAttachedTrail");
static_assert(sizeof(FGrenadeAttachedTrail) == 0x000010, "Wrong size on FGrenadeAttachedTrail");

// ScriptStruct OakGame.ZoneMapChallengeEntry
// 0x0060 (0x0060 - 0x0000)
struct FZoneMapChallengeEntry final
{
public:
	class FString                                 ChallengeActorName;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ChallengeWaypointTransform;                        // 0x0010(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPoint                              ChallengeWaypointFODTexelCoords;                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UChallenge>                 ChallengeClass;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ChallengeGUID;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapChallengeEntry) == 0x000010, "Wrong alignment on FZoneMapChallengeEntry");
static_assert(sizeof(FZoneMapChallengeEntry) == 0x000060, "Wrong size on FZoneMapChallengeEntry");
static_assert(offsetof(FZoneMapChallengeEntry, ChallengeActorName) == 0x000000, "Member 'FZoneMapChallengeEntry::ChallengeActorName' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeEntry, ChallengeWaypointTransform) == 0x000010, "Member 'FZoneMapChallengeEntry::ChallengeWaypointTransform' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeEntry, ChallengeWaypointFODTexelCoords) == 0x000040, "Member 'FZoneMapChallengeEntry::ChallengeWaypointFODTexelCoords' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeEntry, ChallengeClass) == 0x000048, "Member 'FZoneMapChallengeEntry::ChallengeClass' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeEntry, ChallengeGUID) == 0x000050, "Member 'FZoneMapChallengeEntry::ChallengeGUID' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapMissionWaypointEntry
// 0x00F0 (0x00F0 - 0x0000)
struct FZoneMapMissionWaypointEntry final
{
public:
	class UZoneMapPOITypeData*                    PointOfInterestType;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MissionWaypointObjectName;                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MissionWaypointTransform;                          // 0x0020(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MissionWaypointRadius;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMissionObjectiveReferenceWeak> MissionObjectives;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FGbxUIFormattedText                    MissionDirectorName;                               // 0x0068(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           DirectorMissions;                                  // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         BlacklistIndex;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutOfMap;                                         // 0x00E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideMissionAreaWaypoint;                          // 0x00E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPrimitiveComponent>        AreaComponentClassOverride;                        // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapMissionWaypointEntry) == 0x000010, "Wrong alignment on FZoneMapMissionWaypointEntry");
static_assert(sizeof(FZoneMapMissionWaypointEntry) == 0x0000F0, "Wrong size on FZoneMapMissionWaypointEntry");
static_assert(offsetof(FZoneMapMissionWaypointEntry, PointOfInterestType) == 0x000000, "Member 'FZoneMapMissionWaypointEntry::PointOfInterestType' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, MissionWaypointObjectName) == 0x000008, "Member 'FZoneMapMissionWaypointEntry::MissionWaypointObjectName' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, MissionWaypointTransform) == 0x000020, "Member 'FZoneMapMissionWaypointEntry::MissionWaypointTransform' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, MissionWaypointRadius) == 0x000050, "Member 'FZoneMapMissionWaypointEntry::MissionWaypointRadius' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, MissionObjectives) == 0x000058, "Member 'FZoneMapMissionWaypointEntry::MissionObjectives' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, MissionDirectorName) == 0x000068, "Member 'FZoneMapMissionWaypointEntry::MissionDirectorName' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, DirectorMissions) == 0x0000D0, "Member 'FZoneMapMissionWaypointEntry::DirectorMissions' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, BlacklistIndex) == 0x0000E0, "Member 'FZoneMapMissionWaypointEntry::BlacklistIndex' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, bOutOfMap) == 0x0000E4, "Member 'FZoneMapMissionWaypointEntry::bOutOfMap' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, bHideMissionAreaWaypoint) == 0x0000E5, "Member 'FZoneMapMissionWaypointEntry::bHideMissionAreaWaypoint' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionWaypointEntry, AreaComponentClassOverride) == 0x0000E8, "Member 'FZoneMapMissionWaypointEntry::AreaComponentClassOverride' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapPOIEntry
// 0x0060 (0x0060 - 0x0000)
struct FZoneMapPOIEntry final
{
public:
	class UZoneMapPOITypeData*                    PointOfInterestType;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PointOfInterestObjectName;                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PointOfInterestTransform;                          // 0x0020(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPoint                              PointOfInterestFODTexelCoords;                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CustomPOIData;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapPOIEntry) == 0x000010, "Wrong alignment on FZoneMapPOIEntry");
static_assert(sizeof(FZoneMapPOIEntry) == 0x000060, "Wrong size on FZoneMapPOIEntry");
static_assert(offsetof(FZoneMapPOIEntry, PointOfInterestType) == 0x000000, "Member 'FZoneMapPOIEntry::PointOfInterestType' has a wrong offset!");
static_assert(offsetof(FZoneMapPOIEntry, PointOfInterestObjectName) == 0x000008, "Member 'FZoneMapPOIEntry::PointOfInterestObjectName' has a wrong offset!");
static_assert(offsetof(FZoneMapPOIEntry, PointOfInterestTransform) == 0x000020, "Member 'FZoneMapPOIEntry::PointOfInterestTransform' has a wrong offset!");
static_assert(offsetof(FZoneMapPOIEntry, PointOfInterestFODTexelCoords) == 0x000050, "Member 'FZoneMapPOIEntry::PointOfInterestFODTexelCoords' has a wrong offset!");
static_assert(offsetof(FZoneMapPOIEntry, CustomPOIData) == 0x000058, "Member 'FZoneMapPOIEntry::CustomPOIData' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapIconInfo
// 0x0270 (0x0270 - 0x0000)
struct FZoneMapIconInfo final
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapIconAnchor*                         IconAnchor;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    IconPOIComponent;                                  // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AOakZoneMapIcon_POI>     IconActor;                                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 IconClass;                                         // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  IconGuid;                                          // 0x0028(0x0010)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconLocation;                                      // 0x0038(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               IconRotation;                                      // 0x0044(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UChallengeLevelActorComponent*          ChallengeComponent;                                // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0070(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 IconFrameName;                                     // 0x0088(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDynamic;                                        // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDynamicInNonCurrentMap;                       // 0x0099(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayer;                                         // 0x009A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMiniMap;                                    // 0x009B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInZoneMap;                                    // 0x009C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FZoneMapPOIEntry                       POIEntry;                                          // 0x00A0(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FZoneMapMissionWaypointEntry           MissionWaypointEntry;                              // 0x0100(0x00F0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FZoneMapChallengeEntry                 ChallengeEntry;                                    // 0x01F0(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AOakVehicle*                            TargetedVehicle;                                   // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZoneMapMissionStatus                         WaypointStatus;                                    // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissionTrackerIcon;                               // 0x0259(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutOfMapWaypoint;                                 // 0x025A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZoneMapChallengeStatus                       ChallengeStatus;                                   // 0x025B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ChallengeRadius;                                   // 0x025C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UChallenge>                 ChallengeClass;                                    // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneMapIconInfo) == 0x000010, "Wrong alignment on FZoneMapIconInfo");
static_assert(sizeof(FZoneMapIconInfo) == 0x000270, "Wrong size on FZoneMapIconInfo");
static_assert(offsetof(FZoneMapIconInfo, TargetActor) == 0x000000, "Member 'FZoneMapIconInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconAnchor) == 0x000008, "Member 'FZoneMapIconInfo::IconAnchor' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconPOIComponent) == 0x000010, "Member 'FZoneMapIconInfo::IconPOIComponent' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconActor) == 0x000018, "Member 'FZoneMapIconInfo::IconActor' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconClass) == 0x000020, "Member 'FZoneMapIconInfo::IconClass' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconGuid) == 0x000028, "Member 'FZoneMapIconInfo::IconGuid' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconLocation) == 0x000038, "Member 'FZoneMapIconInfo::IconLocation' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconRotation) == 0x000044, "Member 'FZoneMapIconInfo::IconRotation' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, ChallengeComponent) == 0x000050, "Member 'FZoneMapIconInfo::ChallengeComponent' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, DisplayName) == 0x000058, "Member 'FZoneMapIconInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, Description) == 0x000070, "Member 'FZoneMapIconInfo::Description' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, IconFrameName) == 0x000088, "Member 'FZoneMapIconInfo::IconFrameName' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bIsDynamic) == 0x000098, "Member 'FZoneMapIconInfo::bIsDynamic' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bShowDynamicInNonCurrentMap) == 0x000099, "Member 'FZoneMapIconInfo::bShowDynamicInNonCurrentMap' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bIsPlayer) == 0x00009A, "Member 'FZoneMapIconInfo::bIsPlayer' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bShowInMiniMap) == 0x00009B, "Member 'FZoneMapIconInfo::bShowInMiniMap' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bShowInZoneMap) == 0x00009C, "Member 'FZoneMapIconInfo::bShowInZoneMap' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, POIEntry) == 0x0000A0, "Member 'FZoneMapIconInfo::POIEntry' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, MissionWaypointEntry) == 0x000100, "Member 'FZoneMapIconInfo::MissionWaypointEntry' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, ChallengeEntry) == 0x0001F0, "Member 'FZoneMapIconInfo::ChallengeEntry' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, TargetedVehicle) == 0x000250, "Member 'FZoneMapIconInfo::TargetedVehicle' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, WaypointStatus) == 0x000258, "Member 'FZoneMapIconInfo::WaypointStatus' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bMissionTrackerIcon) == 0x000259, "Member 'FZoneMapIconInfo::bMissionTrackerIcon' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, bOutOfMapWaypoint) == 0x00025A, "Member 'FZoneMapIconInfo::bOutOfMapWaypoint' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, ChallengeStatus) == 0x00025B, "Member 'FZoneMapIconInfo::ChallengeStatus' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, ChallengeRadius) == 0x00025C, "Member 'FZoneMapIconInfo::ChallengeRadius' has a wrong offset!");
static_assert(offsetof(FZoneMapIconInfo, ChallengeClass) == 0x000260, "Member 'FZoneMapIconInfo::ChallengeClass' has a wrong offset!");

// ScriptStruct OakGame.ElementalInteractionDamageValuesData
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FElementalInteractionDamageValuesData final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementalInteractionDamageValuesData) == 0x000004, "Wrong alignment on FElementalInteractionDamageValuesData");
static_assert(sizeof(FElementalInteractionDamageValuesData) == 0x000014, "Wrong size on FElementalInteractionDamageValuesData");

// ScriptStruct OakGame.ShieldTriggeredElementalEffect
// 0x0080 (0x0080 - 0x0000)
struct FShieldTriggeredElementalEffect final
{
public:
	bool                                          bShieldMustBeActiveToTrigger;                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamagePerSecond;                                   // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ResourceEffectValue;                               // 0x0040(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UOakDamageType>             DamageType;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldTriggeredElementalEffect) == 0x000008, "Wrong alignment on FShieldTriggeredElementalEffect");
static_assert(sizeof(FShieldTriggeredElementalEffect) == 0x000080, "Wrong size on FShieldTriggeredElementalEffect");
static_assert(offsetof(FShieldTriggeredElementalEffect, bShieldMustBeActiveToTrigger) == 0x000000, "Member 'FShieldTriggeredElementalEffect::bShieldMustBeActiveToTrigger' has a wrong offset!");
static_assert(offsetof(FShieldTriggeredElementalEffect, DamagePerSecond) == 0x000008, "Member 'FShieldTriggeredElementalEffect::DamagePerSecond' has a wrong offset!");
static_assert(offsetof(FShieldTriggeredElementalEffect, ResourceEffectValue) == 0x000040, "Member 'FShieldTriggeredElementalEffect::ResourceEffectValue' has a wrong offset!");
static_assert(offsetof(FShieldTriggeredElementalEffect, DamageType) == 0x000078, "Member 'FShieldTriggeredElementalEffect::DamageType' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapChallengeQuery
// 0x0018 (0x0018 - 0x0000)
struct FZoneMapChallengeQuery final
{
public:
	TSubclassOf<class UChallenge>                 ChallengeClass;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZoneMapChallengeStatus                       ChallengeStatus;                                   // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakZoneMapIcon_POI*                    IconActor;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapChallengeQuery) == 0x000008, "Wrong alignment on FZoneMapChallengeQuery");
static_assert(sizeof(FZoneMapChallengeQuery) == 0x000018, "Wrong size on FZoneMapChallengeQuery");
static_assert(offsetof(FZoneMapChallengeQuery, ChallengeClass) == 0x000000, "Member 'FZoneMapChallengeQuery::ChallengeClass' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeQuery, ChallengeStatus) == 0x000008, "Member 'FZoneMapChallengeQuery::ChallengeStatus' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeQuery, IconActor) == 0x000010, "Member 'FZoneMapChallengeQuery::IconActor' has a wrong offset!");

// ScriptStruct OakGame.DefaultCrosshairData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDefaultCrosshairData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XSpread;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YSpread;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultCrosshairData) == 0x000008, "Wrong alignment on FDefaultCrosshairData");
static_assert(sizeof(FDefaultCrosshairData) == 0x000010, "Wrong size on FDefaultCrosshairData");
static_assert(offsetof(FDefaultCrosshairData, Name) == 0x000000, "Member 'FDefaultCrosshairData::Name' has a wrong offset!");
static_assert(offsetof(FDefaultCrosshairData, XSpread) == 0x000008, "Member 'FDefaultCrosshairData::XSpread' has a wrong offset!");
static_assert(offsetof(FDefaultCrosshairData, YSpread) == 0x00000C, "Member 'FDefaultCrosshairData::YSpread' has a wrong offset!");

// ScriptStruct OakGame.OakUIControllerConnectedState
// 0x0010 (0x0010 - 0x0000)
struct FOakUIControllerConnectedState final
{
public:
	TWeakObjectPtr<class ULocalPlayer>            LocalPlayer;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxControllerDisconnectMovie*          DisconnectMovie;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakUIControllerConnectedState) == 0x000008, "Wrong alignment on FOakUIControllerConnectedState");
static_assert(sizeof(FOakUIControllerConnectedState) == 0x000010, "Wrong size on FOakUIControllerConnectedState");
static_assert(offsetof(FOakUIControllerConnectedState, LocalPlayer) == 0x000000, "Member 'FOakUIControllerConnectedState::LocalPlayer' has a wrong offset!");
static_assert(offsetof(FOakUIControllerConnectedState, DisconnectMovie) == 0x000008, "Member 'FOakUIControllerConnectedState::DisconnectMovie' has a wrong offset!");

// ScriptStruct OakGame.PlayerIconInfo
// 0x0030 (0x0030 - 0x0000)
struct FPlayerIconInfo final
{
public:
	class AOakPlayerState*                        AssociatedPlayer;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOakCharacter_Player*                   AssociatedCharacter;                               // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PlayerIconMesh;                                    // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastPlayerLocation;                                // 0x0018(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastPlayerRotation;                                // 0x0024(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerIconInfo) == 0x000008, "Wrong alignment on FPlayerIconInfo");
static_assert(sizeof(FPlayerIconInfo) == 0x000030, "Wrong size on FPlayerIconInfo");
static_assert(offsetof(FPlayerIconInfo, AssociatedPlayer) == 0x000000, "Member 'FPlayerIconInfo::AssociatedPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerIconInfo, AssociatedCharacter) == 0x000008, "Member 'FPlayerIconInfo::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FPlayerIconInfo, PlayerIconMesh) == 0x000010, "Member 'FPlayerIconInfo::PlayerIconMesh' has a wrong offset!");
static_assert(offsetof(FPlayerIconInfo, LastPlayerLocation) == 0x000018, "Member 'FPlayerIconInfo::LastPlayerLocation' has a wrong offset!");
static_assert(offsetof(FPlayerIconInfo, LastPlayerRotation) == 0x000024, "Member 'FPlayerIconInfo::LastPlayerRotation' has a wrong offset!");

// ScriptStruct OakGame.BranchColorInfo
// 0x0060 (0x0060 - 0x0000)
struct FBranchColorInfo final
{
public:
	class FString                                 FrameColorName;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FrameColorHeader;                                  // 0x0010(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FrameColorBackground;                              // 0x0020(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColor;                                         // 0x0030(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconBackgroundColor;                               // 0x0040(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IllustrationName;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchColorInfo) == 0x000008, "Wrong alignment on FBranchColorInfo");
static_assert(sizeof(FBranchColorInfo) == 0x000060, "Wrong size on FBranchColorInfo");
static_assert(offsetof(FBranchColorInfo, FrameColorName) == 0x000000, "Member 'FBranchColorInfo::FrameColorName' has a wrong offset!");
static_assert(offsetof(FBranchColorInfo, FrameColorHeader) == 0x000010, "Member 'FBranchColorInfo::FrameColorHeader' has a wrong offset!");
static_assert(offsetof(FBranchColorInfo, FrameColorBackground) == 0x000020, "Member 'FBranchColorInfo::FrameColorBackground' has a wrong offset!");
static_assert(offsetof(FBranchColorInfo, IconColor) == 0x000030, "Member 'FBranchColorInfo::IconColor' has a wrong offset!");
static_assert(offsetof(FBranchColorInfo, IconBackgroundColor) == 0x000040, "Member 'FBranchColorInfo::IconBackgroundColor' has a wrong offset!");
static_assert(offsetof(FBranchColorInfo, IllustrationName) == 0x000050, "Member 'FBranchColorInfo::IllustrationName' has a wrong offset!");

// ScriptStruct OakGame.PassiveAbilityBuffData
// 0x0108 (0x0108 - 0x0000)
struct FPassiveAbilityBuffData final
{
public:
	struct FSoftObjectPath                        PassiveAbilityClassPath;                           // 0x0000(0x0018)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PassiveAbilityClassPtr;                            // 0x0018(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchColorInfo                       TreeBranchColorInfo;                               // 0x0040(0x0060)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FString                                 ItemFrameName;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AbilityNameLocNamespace;                           // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AbilityNameLocKey;                                 // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           GradeBonusInitializer;                             // 0x00D0(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveAbilityBuffData) == 0x000008, "Wrong alignment on FPassiveAbilityBuffData");
static_assert(sizeof(FPassiveAbilityBuffData) == 0x000108, "Wrong size on FPassiveAbilityBuffData");
static_assert(offsetof(FPassiveAbilityBuffData, PassiveAbilityClassPath) == 0x000000, "Member 'FPassiveAbilityBuffData::PassiveAbilityClassPath' has a wrong offset!");
static_assert(offsetof(FPassiveAbilityBuffData, PassiveAbilityClassPtr) == 0x000018, "Member 'FPassiveAbilityBuffData::PassiveAbilityClassPtr' has a wrong offset!");
static_assert(offsetof(FPassiveAbilityBuffData, TreeBranchColorInfo) == 0x000040, "Member 'FPassiveAbilityBuffData::TreeBranchColorInfo' has a wrong offset!");
static_assert(offsetof(FPassiveAbilityBuffData, ItemFrameName) == 0x0000A0, "Member 'FPassiveAbilityBuffData::ItemFrameName' has a wrong offset!");
static_assert(offsetof(FPassiveAbilityBuffData, AbilityNameLocNamespace) == 0x0000B0, "Member 'FPassiveAbilityBuffData::AbilityNameLocNamespace' has a wrong offset!");
static_assert(offsetof(FPassiveAbilityBuffData, AbilityNameLocKey) == 0x0000C0, "Member 'FPassiveAbilityBuffData::AbilityNameLocKey' has a wrong offset!");
static_assert(offsetof(FPassiveAbilityBuffData, GradeBonusInitializer) == 0x0000D0, "Member 'FPassiveAbilityBuffData::GradeBonusInitializer' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapLevelMeshInfo
// 0x0028 (0x0028 - 0x0000)
struct FZoneMapLevelMeshInfo final
{
public:
	class UStaticMeshComponent*                   MapMesh;                                           // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MapMeshDMI;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MapTranslucentMesh;                                // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MapTranslucentMeshDMI;                             // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          MeshDisplayCondition;                              // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapLevelMeshInfo) == 0x000008, "Wrong alignment on FZoneMapLevelMeshInfo");
static_assert(sizeof(FZoneMapLevelMeshInfo) == 0x000028, "Wrong size on FZoneMapLevelMeshInfo");
static_assert(offsetof(FZoneMapLevelMeshInfo, MapMesh) == 0x000000, "Member 'FZoneMapLevelMeshInfo::MapMesh' has a wrong offset!");
static_assert(offsetof(FZoneMapLevelMeshInfo, MapMeshDMI) == 0x000008, "Member 'FZoneMapLevelMeshInfo::MapMeshDMI' has a wrong offset!");
static_assert(offsetof(FZoneMapLevelMeshInfo, MapTranslucentMesh) == 0x000010, "Member 'FZoneMapLevelMeshInfo::MapTranslucentMesh' has a wrong offset!");
static_assert(offsetof(FZoneMapLevelMeshInfo, MapTranslucentMeshDMI) == 0x000018, "Member 'FZoneMapLevelMeshInfo::MapTranslucentMeshDMI' has a wrong offset!");
static_assert(offsetof(FZoneMapLevelMeshInfo, MeshDisplayCondition) == 0x000020, "Member 'FZoneMapLevelMeshInfo::MeshDisplayCondition' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityDebugMenuSpecList
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOakAbilityDebugMenuSpecList final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityDebugMenuSpecList) == 0x000008, "Wrong alignment on FOakAbilityDebugMenuSpecList");
static_assert(sizeof(FOakAbilityDebugMenuSpecList) == 0x000010, "Wrong size on FOakAbilityDebugMenuSpecList");

// ScriptStruct OakGame.LootablePileInteractionResponse
// 0x0010 (0x0010 - 0x0000)
struct FLootablePileInteractionResponse final
{
public:
	class ULootSpawnPatternData*                  LootPatternOverride;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisturbBoneForce;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootablePileInteractionResponse) == 0x000008, "Wrong alignment on FLootablePileInteractionResponse");
static_assert(sizeof(FLootablePileInteractionResponse) == 0x000010, "Wrong size on FLootablePileInteractionResponse");
static_assert(offsetof(FLootablePileInteractionResponse, LootPatternOverride) == 0x000000, "Member 'FLootablePileInteractionResponse::LootPatternOverride' has a wrong offset!");
static_assert(offsetof(FLootablePileInteractionResponse, DisturbBoneForce) == 0x000008, "Member 'FLootablePileInteractionResponse::DisturbBoneForce' has a wrong offset!");

// ScriptStruct OakGame.ElementalInteractionDamageOverlapData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FElementalInteractionDamageOverlapData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementalInteractionDamageOverlapData) == 0x000004, "Wrong alignment on FElementalInteractionDamageOverlapData");
static_assert(sizeof(FElementalInteractionDamageOverlapData) == 0x000008, "Wrong size on FElementalInteractionDamageOverlapData");

// ScriptStruct OakGame.OrganizationInfo
// 0x0028 (0x0028 - 0x0000)
struct FOrganizationInfo final
{
public:
	class FName                                   OrganizationId;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextStyle;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextEntry;                                         // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrganizationInfo) == 0x000008, "Wrong alignment on FOrganizationInfo");
static_assert(sizeof(FOrganizationInfo) == 0x000028, "Wrong size on FOrganizationInfo");
static_assert(offsetof(FOrganizationInfo, OrganizationId) == 0x000000, "Member 'FOrganizationInfo::OrganizationId' has a wrong offset!");
static_assert(offsetof(FOrganizationInfo, TextStyle) == 0x000008, "Member 'FOrganizationInfo::TextStyle' has a wrong offset!");
static_assert(offsetof(FOrganizationInfo, TextEntry) == 0x000010, "Member 'FOrganizationInfo::TextEntry' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapDynamicPOIEntry
// 0x0010 (0x0010 - 0x0000)
struct FZoneMapDynamicPOIEntry final
{
public:
	class UZoneMapPOITypeData*                    POIType;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMiniMap;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInZoneMap;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneMapDynamicPOIEntry) == 0x000008, "Wrong alignment on FZoneMapDynamicPOIEntry");
static_assert(sizeof(FZoneMapDynamicPOIEntry) == 0x000010, "Wrong size on FZoneMapDynamicPOIEntry");
static_assert(offsetof(FZoneMapDynamicPOIEntry, POIType) == 0x000000, "Member 'FZoneMapDynamicPOIEntry::POIType' has a wrong offset!");
static_assert(offsetof(FZoneMapDynamicPOIEntry, bShowInMiniMap) == 0x000008, "Member 'FZoneMapDynamicPOIEntry::bShowInMiniMap' has a wrong offset!");
static_assert(offsetof(FZoneMapDynamicPOIEntry, bShowInZoneMap) == 0x000009, "Member 'FZoneMapDynamicPOIEntry::bShowInZoneMap' has a wrong offset!");

// ScriptStruct OakGame.BrushInfo
// 0x0090 (0x0090 - 0x0000)
struct FBrushInfo final
{
public:
	struct FSlateBrush                            SlateBrush;                                        // 0x0000(0x0088)(NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrushInfo) == 0x000008, "Wrong alignment on FBrushInfo");
static_assert(sizeof(FBrushInfo) == 0x000090, "Wrong size on FBrushInfo");
static_assert(offsetof(FBrushInfo, SlateBrush) == 0x000000, "Member 'FBrushInfo::SlateBrush' has a wrong offset!");

// ScriptStruct OakGame.UIManagerMessage
// 0x0168 (0x0168 - 0x0000)
struct FUIManagerMessage final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   PlayerName;                                        // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0030(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   Glyph;                                             // 0x0048(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   CommandText;                                       // 0x0060(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FString                                 IconFrame;                                         // 0x0078(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IntroSound;                                        // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutroSound;                                        // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocking;                                       // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimedMessage;                                     // 0x0099(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeCreated;                                       // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplaySpinner;                                   // 0x00A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMessageSpecialType                           SpecialType;                                       // 0x00A5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0xA];                                       // 0x00A6(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrushInfo                             BrushInfo;                                         // 0x00B0(0x0090)(NativeAccessSpecifierPublic)
	struct FMessageHandle                         Handle;                                            // 0x0140(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakPlayerState*                        OtherPlayerState;                                  // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIManagerMessage) == 0x000008, "Wrong alignment on FUIManagerMessage");
static_assert(sizeof(FUIManagerMessage) == 0x000168, "Wrong size on FUIManagerMessage");
static_assert(offsetof(FUIManagerMessage, Title) == 0x000000, "Member 'FUIManagerMessage::Title' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, PlayerName) == 0x000018, "Member 'FUIManagerMessage::PlayerName' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, Description) == 0x000030, "Member 'FUIManagerMessage::Description' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, Glyph) == 0x000048, "Member 'FUIManagerMessage::Glyph' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, CommandText) == 0x000060, "Member 'FUIManagerMessage::CommandText' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, IconFrame) == 0x000078, "Member 'FUIManagerMessage::IconFrame' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, IntroSound) == 0x000088, "Member 'FUIManagerMessage::IntroSound' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, OutroSound) == 0x000090, "Member 'FUIManagerMessage::OutroSound' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, bIsBlocking) == 0x000098, "Member 'FUIManagerMessage::bIsBlocking' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, bTimedMessage) == 0x000099, "Member 'FUIManagerMessage::bTimedMessage' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, TimeCreated) == 0x00009C, "Member 'FUIManagerMessage::TimeCreated' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, TimeRemaining) == 0x0000A0, "Member 'FUIManagerMessage::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, bDisplaySpinner) == 0x0000A4, "Member 'FUIManagerMessage::bDisplaySpinner' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, SpecialType) == 0x0000A5, "Member 'FUIManagerMessage::SpecialType' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, BrushInfo) == 0x0000B0, "Member 'FUIManagerMessage::BrushInfo' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, Handle) == 0x000140, "Member 'FUIManagerMessage::Handle' has a wrong offset!");
static_assert(offsetof(FUIManagerMessage, OtherPlayerState) == 0x000158, "Member 'FUIManagerMessage::OtherPlayerState' has a wrong offset!");

// ScriptStruct OakGame.VendingMachineRefillAmmoData
// 0x0020 (0x0020 - 0x0000)
struct FVendingMachineRefillAmmoData final
{
public:
	class UGbxAttributeData*                      AmmoMax;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      AmmoCurrent;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      AmmoStackCount;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      AmmoStackCost;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingMachineRefillAmmoData) == 0x000008, "Wrong alignment on FVendingMachineRefillAmmoData");
static_assert(sizeof(FVendingMachineRefillAmmoData) == 0x000020, "Wrong size on FVendingMachineRefillAmmoData");
static_assert(offsetof(FVendingMachineRefillAmmoData, AmmoMax) == 0x000000, "Member 'FVendingMachineRefillAmmoData::AmmoMax' has a wrong offset!");
static_assert(offsetof(FVendingMachineRefillAmmoData, AmmoCurrent) == 0x000008, "Member 'FVendingMachineRefillAmmoData::AmmoCurrent' has a wrong offset!");
static_assert(offsetof(FVendingMachineRefillAmmoData, AmmoStackCount) == 0x000010, "Member 'FVendingMachineRefillAmmoData::AmmoStackCount' has a wrong offset!");
static_assert(offsetof(FVendingMachineRefillAmmoData, AmmoStackCost) == 0x000018, "Member 'FVendingMachineRefillAmmoData::AmmoStackCost' has a wrong offset!");

// ScriptStruct OakGame.SectorFromBP
// 0x0078 (0x0078 - 0x0000)
struct FSectorFromBP final
{
public:
	class USceneComponent*                        SectorRoot;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FakeEmissiveWholeFloor;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseAudioComponent*                   PropaneAudioComponent;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           HeatingElements;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           FakeEmissives;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           DamageZones;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       Bursts;                                            // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       HeatHazes;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       Anticipations;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSectorFromBP) == 0x000008, "Wrong alignment on FSectorFromBP");
static_assert(sizeof(FSectorFromBP) == 0x000078, "Wrong size on FSectorFromBP");
static_assert(offsetof(FSectorFromBP, SectorRoot) == 0x000000, "Member 'FSectorFromBP::SectorRoot' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, FakeEmissiveWholeFloor) == 0x000008, "Member 'FSectorFromBP::FakeEmissiveWholeFloor' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, PropaneAudioComponent) == 0x000010, "Member 'FSectorFromBP::PropaneAudioComponent' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, HeatingElements) == 0x000018, "Member 'FSectorFromBP::HeatingElements' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, FakeEmissives) == 0x000028, "Member 'FSectorFromBP::FakeEmissives' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, DamageZones) == 0x000038, "Member 'FSectorFromBP::DamageZones' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, Bursts) == 0x000048, "Member 'FSectorFromBP::Bursts' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, HeatHazes) == 0x000058, "Member 'FSectorFromBP::HeatHazes' has a wrong offset!");
static_assert(offsetof(FSectorFromBP, Anticipations) == 0x000068, "Member 'FSectorFromBP::Anticipations' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuStatValue
// 0x0010 (0x0010 - 0x0000)
struct FOakCARMenuStatValue final
{
public:
	class UOakCARVehiclePartStat*                 StatData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCARMenuStatValue) == 0x000008, "Wrong alignment on FOakCARMenuStatValue");
static_assert(sizeof(FOakCARMenuStatValue) == 0x000010, "Wrong size on FOakCARMenuStatValue");
static_assert(offsetof(FOakCARMenuStatValue, StatData) == 0x000000, "Member 'FOakCARMenuStatValue::StatData' has a wrong offset!");
static_assert(offsetof(FOakCARMenuStatValue, Value) == 0x000008, "Member 'FOakCARMenuStatValue::Value' has a wrong offset!");

// ScriptStruct OakGame.CARPreviewParticleSystem
// 0x0080 (0x0080 - 0x0000)
struct FCARPreviewParticleSystem final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         Particle;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECARPartType                                  ParentPart;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentSocket;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCARPreviewParticleSystem) == 0x000010, "Wrong alignment on FCARPreviewParticleSystem");
static_assert(sizeof(FCARPreviewParticleSystem) == 0x000080, "Wrong size on FCARPreviewParticleSystem");
static_assert(offsetof(FCARPreviewParticleSystem, ComponentName) == 0x000000, "Member 'FCARPreviewParticleSystem::ComponentName' has a wrong offset!");
static_assert(offsetof(FCARPreviewParticleSystem, Offset) == 0x000010, "Member 'FCARPreviewParticleSystem::Offset' has a wrong offset!");
static_assert(offsetof(FCARPreviewParticleSystem, Particle) == 0x000040, "Member 'FCARPreviewParticleSystem::Particle' has a wrong offset!");
static_assert(offsetof(FCARPreviewParticleSystem, ParentPart) == 0x000068, "Member 'FCARPreviewParticleSystem::ParentPart' has a wrong offset!");
static_assert(offsetof(FCARPreviewParticleSystem, ParentSocket) == 0x000070, "Member 'FCARPreviewParticleSystem::ParentSocket' has a wrong offset!");

// ScriptStruct OakGame.OakCARVehicleUIInfo
// 0x06E0 (0x06E0 - 0x0000)
struct FOakCARVehicleUIInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                PartIconTexture;                                   // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOakCARMenuStatValue>           DisplayStats;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLoading;                                        // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmpty;                                          // 0x0069(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x006A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCARPreviewMesh>                PreviewMesh;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCARPreviewParticleSystem>      PreviewParticles;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            OnEquipSound;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverridePreviewLookAtTransform;                    // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreviewLookAtTransform;                            // 0x00A0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          BlendPostProcess;                                  // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0xF];                                       // 0x00D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSetting;                                // 0x00E0(0x0600)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCARVehicleUIInfo) == 0x000010, "Wrong alignment on FOakCARVehicleUIInfo");
static_assert(sizeof(FOakCARVehicleUIInfo) == 0x0006E0, "Wrong size on FOakCARVehicleUIInfo");
static_assert(offsetof(FOakCARVehicleUIInfo, DisplayName) == 0x000000, "Member 'FOakCARVehicleUIInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, Description) == 0x000018, "Member 'FOakCARVehicleUIInfo::Description' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, PartIconTexture) == 0x000030, "Member 'FOakCARVehicleUIInfo::PartIconTexture' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, DisplayStats) == 0x000058, "Member 'FOakCARVehicleUIInfo::DisplayStats' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, bIsLoading) == 0x000068, "Member 'FOakCARVehicleUIInfo::bIsLoading' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, bIsEmpty) == 0x000069, "Member 'FOakCARVehicleUIInfo::bIsEmpty' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, bIsLocked) == 0x00006A, "Member 'FOakCARVehicleUIInfo::bIsLocked' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, PreviewMesh) == 0x000070, "Member 'FOakCARVehicleUIInfo::PreviewMesh' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, PreviewParticles) == 0x000080, "Member 'FOakCARVehicleUIInfo::PreviewParticles' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, OnEquipSound) == 0x000090, "Member 'FOakCARVehicleUIInfo::OnEquipSound' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, OverridePreviewLookAtTransform) == 0x000098, "Member 'FOakCARVehicleUIInfo::OverridePreviewLookAtTransform' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, PreviewLookAtTransform) == 0x0000A0, "Member 'FOakCARVehicleUIInfo::PreviewLookAtTransform' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, BlendPostProcess) == 0x0000D0, "Member 'FOakCARVehicleUIInfo::BlendPostProcess' has a wrong offset!");
static_assert(offsetof(FOakCARVehicleUIInfo, PostProcessSetting) == 0x0000E0, "Member 'FOakCARVehicleUIInfo::PostProcessSetting' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentSlot
// 0x001C (0x0028 - 0x000C)
struct FOakActionAbilityAugmentSlot final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOakActionAbility>          ActionAbilityClass;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOakActionAbilityAugmentSlotData*       SlotData;                                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOakActionAbilityAugmentData*           AugmentData;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentSlot) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentSlot");
static_assert(sizeof(FOakActionAbilityAugmentSlot) == 0x000028, "Wrong size on FOakActionAbilityAugmentSlot");
static_assert(offsetof(FOakActionAbilityAugmentSlot, ActionAbilityClass) == 0x000010, "Member 'FOakActionAbilityAugmentSlot::ActionAbilityClass' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSlot, SlotData) == 0x000018, "Member 'FOakActionAbilityAugmentSlot::SlotData' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSlot, AugmentData) == 0x000020, "Member 'FOakActionAbilityAugmentSlot::AugmentData' has a wrong offset!");

// ScriptStruct OakGame.Sector
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FSector final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSector) == 0x000008, "Wrong alignment on FSector");
static_assert(sizeof(FSector) == 0x000068, "Wrong size on FSector");

// ScriptStruct OakGame.PawnInterpolationInfo
// 0x0008 (0x0008 - 0x0000)
struct FPawnInterpolationInfo final
{
public:
	float                                         TranslationTime;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTime;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnInterpolationInfo) == 0x000004, "Wrong alignment on FPawnInterpolationInfo");
static_assert(sizeof(FPawnInterpolationInfo) == 0x000008, "Wrong size on FPawnInterpolationInfo");
static_assert(offsetof(FPawnInterpolationInfo, TranslationTime) == 0x000000, "Member 'FPawnInterpolationInfo::TranslationTime' has a wrong offset!");
static_assert(offsetof(FPawnInterpolationInfo, RotationTime) == 0x000004, "Member 'FPawnInterpolationInfo::RotationTime' has a wrong offset!");

// ScriptStruct OakGame.Ring
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FRing final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRing) == 0x000008, "Wrong alignment on FRing");
static_assert(sizeof(FRing) == 0x000070, "Wrong size on FRing");

// ScriptStruct OakGame.AIOOrientedParticleTarget
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAIOOrientedParticleTarget final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIOOrientedParticleTarget) == 0x000004, "Wrong alignment on FAIOOrientedParticleTarget");
static_assert(sizeof(FAIOOrientedParticleTarget) == 0x00000C, "Wrong size on FAIOOrientedParticleTarget");

// ScriptStruct OakGame.AIOOrientedParticleData
// 0x0040 (0x0040 - 0x0000)
struct FAIOOrientedParticleData final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OriginSocket;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParticleBeamTargetParameterName;                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultBeamTargetPosition;                         // 0x0018(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIOOrientedParticleTarget             Target;                                            // 0x0030(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIOOrientedParticleData) == 0x000008, "Wrong alignment on FAIOOrientedParticleData");
static_assert(sizeof(FAIOOrientedParticleData) == 0x000040, "Wrong size on FAIOOrientedParticleData");
static_assert(offsetof(FAIOOrientedParticleData, ParticleSystem) == 0x000000, "Member 'FAIOOrientedParticleData::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FAIOOrientedParticleData, OriginSocket) == 0x000008, "Member 'FAIOOrientedParticleData::OriginSocket' has a wrong offset!");
static_assert(offsetof(FAIOOrientedParticleData, ParticleBeamTargetParameterName) == 0x000010, "Member 'FAIOOrientedParticleData::ParticleBeamTargetParameterName' has a wrong offset!");
static_assert(offsetof(FAIOOrientedParticleData, DefaultBeamTargetPosition) == 0x000018, "Member 'FAIOOrientedParticleData::DefaultBeamTargetPosition' has a wrong offset!");
static_assert(offsetof(FAIOOrientedParticleData, ParticleComponent) == 0x000028, "Member 'FAIOOrientedParticleData::ParticleComponent' has a wrong offset!");
static_assert(offsetof(FAIOOrientedParticleData, Target) == 0x000030, "Member 'FAIOOrientedParticleData::Target' has a wrong offset!");

// ScriptStruct OakGame.VehicleAttachWeaponAdditionalData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FVehicleAttachWeaponAdditionalData final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Data;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleAttachWeaponAdditionalData) == 0x000008, "Wrong alignment on FVehicleAttachWeaponAdditionalData");
static_assert(sizeof(FVehicleAttachWeaponAdditionalData) == 0x000010, "Wrong size on FVehicleAttachWeaponAdditionalData");
static_assert(offsetof(FVehicleAttachWeaponAdditionalData, Key) == 0x000000, "Member 'FVehicleAttachWeaponAdditionalData::Key' has a wrong offset!");
static_assert(offsetof(FVehicleAttachWeaponAdditionalData, Data) == 0x000008, "Member 'FVehicleAttachWeaponAdditionalData::Data' has a wrong offset!");

// ScriptStruct OakGame.AgonizerAttackDataTableRow
// 0x0008 (0x0010 - 0x0008)
struct FAgonizerAttackDataTableRow final : public FTableRowBase
{
public:
	float                                         CooldownMin;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownMax;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAgonizerAttackDataTableRow) == 0x000008, "Wrong alignment on FAgonizerAttackDataTableRow");
static_assert(sizeof(FAgonizerAttackDataTableRow) == 0x000010, "Wrong size on FAgonizerAttackDataTableRow");
static_assert(offsetof(FAgonizerAttackDataTableRow, CooldownMin) == 0x000008, "Member 'FAgonizerAttackDataTableRow::CooldownMin' has a wrong offset!");
static_assert(offsetof(FAgonizerAttackDataTableRow, CooldownMax) == 0x00000C, "Member 'FAgonizerAttackDataTableRow::CooldownMax' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakGib
// 0x0000 (0x00D0 - 0x00D0)
struct FActionState_OakGib final : public FActionState_Gib
{
};
static_assert(alignof(FActionState_OakGib) == 0x000008, "Wrong alignment on FActionState_OakGib");
static_assert(sizeof(FActionState_OakGib) == 0x0000D0, "Wrong size on FActionState_OakGib");

// ScriptStruct OakGame.FloorSector
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FFloorSector final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloorSector) == 0x000008, "Wrong alignment on FFloorSector");
static_assert(sizeof(FFloorSector) == 0x000068, "Wrong size on FFloorSector");

// ScriptStruct OakGame.CreditsTextureCache
// 0x0010 (0x0010 - 0x0000)
struct FCreditsTextureCache final
{
public:
	class UTexture2D*                             CreditsTexture;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditsTextureCache) == 0x000008, "Wrong alignment on FCreditsTextureCache");
static_assert(sizeof(FCreditsTextureCache) == 0x000010, "Wrong size on FCreditsTextureCache");
static_assert(offsetof(FCreditsTextureCache, CreditsTexture) == 0x000000, "Member 'FCreditsTextureCache::CreditsTexture' has a wrong offset!");

// ScriptStruct OakGame.FloorSectorRing
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FFloorSectorRing final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloorSectorRing) == 0x000008, "Wrong alignment on FFloorSectorRing");
static_assert(sizeof(FFloorSectorRing) == 0x000068, "Wrong size on FFloorSectorRing");

// ScriptStruct OakGame.AIAspectSettings_DialogCondition
// 0x0088 (0x0088 - 0x0000)
struct FAIAspectSettings_DialogCondition final
{
public:
	struct FGbxParam                              Condition;                                         // 0x0000(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDialogEvent*                           DialogEvent;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_DialogCondition) == 0x000008, "Wrong alignment on FAIAspectSettings_DialogCondition");
static_assert(sizeof(FAIAspectSettings_DialogCondition) == 0x000088, "Wrong size on FAIAspectSettings_DialogCondition");
static_assert(offsetof(FAIAspectSettings_DialogCondition, Condition) == 0x000000, "Member 'FAIAspectSettings_DialogCondition::Condition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_DialogCondition, DialogEvent) == 0x000080, "Member 'FAIAspectSettings_DialogCondition::DialogEvent' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_Dialog
// 0x0140 (0x0140 - 0x0000)
struct FAIAspectSettings_Dialog final
{
public:
	TArray<struct FAIAspectSettings_DialogCondition> ConditionalDialogEvents;                           // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UDialogEvent*                           DialogEvent;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxNamedParam>                 DialogParams;                                      // 0x0018(0x0010)(Edit, EditFixedSize, ZeroConstructor, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UDialogParameter*>               DialogParamAssets;                                 // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              DialogStartDelay;                                  // 0x0038(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              DialogCooldownTime;                                // 0x00B8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseDialogCooldownTime;                            // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnStop;                                       // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x6];                                      // 0x013A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Dialog) == 0x000008, "Wrong alignment on FAIAspectSettings_Dialog");
static_assert(sizeof(FAIAspectSettings_Dialog) == 0x000140, "Wrong size on FAIAspectSettings_Dialog");
static_assert(offsetof(FAIAspectSettings_Dialog, ConditionalDialogEvents) == 0x000000, "Member 'FAIAspectSettings_Dialog::ConditionalDialogEvents' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, DialogEvent) == 0x000010, "Member 'FAIAspectSettings_Dialog::DialogEvent' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, DialogParams) == 0x000018, "Member 'FAIAspectSettings_Dialog::DialogParams' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, DialogParamAssets) == 0x000028, "Member 'FAIAspectSettings_Dialog::DialogParamAssets' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, DialogStartDelay) == 0x000038, "Member 'FAIAspectSettings_Dialog::DialogStartDelay' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, DialogCooldownTime) == 0x0000B8, "Member 'FAIAspectSettings_Dialog::DialogCooldownTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, bUseDialogCooldownTime) == 0x000138, "Member 'FAIAspectSettings_Dialog::bUseDialogCooldownTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Dialog, bPlayOnStop) == 0x000139, "Member 'FAIAspectSettings_Dialog::bPlayOnStop' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilityTreeBranchInfo
// 0x0010 (0x0010 - 0x0000)
struct FOakPlayerAbilityTreeBranchInfo final
{
public:
	class UOakPlayerAbilityTreeBranchData*        BranchData;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPlayerAbilityTreeBranchInfo) == 0x000008, "Wrong alignment on FOakPlayerAbilityTreeBranchInfo");
static_assert(sizeof(FOakPlayerAbilityTreeBranchInfo) == 0x000010, "Wrong size on FOakPlayerAbilityTreeBranchInfo");
static_assert(offsetof(FOakPlayerAbilityTreeBranchInfo, BranchData) == 0x000000, "Member 'FOakPlayerAbilityTreeBranchInfo::BranchData' has a wrong offset!");

// ScriptStruct OakGame.LadderBehaviorGoalParams
// 0x0068 (0x0068 - 0x0000)
struct FLadderBehaviorGoalParams final
{
public:
	uint8                                         bControlPitch : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bControlYaw : 1;                                   // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterruptedByInput : 1;                           // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableInput : 1;                                 // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInitialRotationAxisParams             Pitch;                                             // 0x0008(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FInitialRotationAxisParams             Yaw;                                               // 0x0038(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLadderBehaviorGoalParams) == 0x000008, "Wrong alignment on FLadderBehaviorGoalParams");
static_assert(sizeof(FLadderBehaviorGoalParams) == 0x000068, "Wrong size on FLadderBehaviorGoalParams");
static_assert(offsetof(FLadderBehaviorGoalParams, Pitch) == 0x000008, "Member 'FLadderBehaviorGoalParams::Pitch' has a wrong offset!");
static_assert(offsetof(FLadderBehaviorGoalParams, Yaw) == 0x000038, "Member 'FLadderBehaviorGoalParams::Yaw' has a wrong offset!");

// ScriptStruct OakGame.VendingMachineTrayTile
// 0x0040 (0x0040 - 0x0000)
struct FVendingMachineTrayTile final
{
public:
	class APickupableMeshActor*                   PhysicalActor;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InventoryActor;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryBalanceStateComponent*        InventoryBalance;                                  // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendingMachineTrayTile) == 0x000008, "Wrong alignment on FVendingMachineTrayTile");
static_assert(sizeof(FVendingMachineTrayTile) == 0x000040, "Wrong size on FVendingMachineTrayTile");
static_assert(offsetof(FVendingMachineTrayTile, PhysicalActor) == 0x000000, "Member 'FVendingMachineTrayTile::PhysicalActor' has a wrong offset!");
static_assert(offsetof(FVendingMachineTrayTile, InventoryActor) == 0x000008, "Member 'FVendingMachineTrayTile::InventoryActor' has a wrong offset!");
static_assert(offsetof(FVendingMachineTrayTile, InventoryBalance) == 0x000010, "Member 'FVendingMachineTrayTile::InventoryBalance' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_MovePath
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FAIAspectSettings_MovePath final
{
public:
	class FName                                   NodeTag;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPathSegment;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPathSegmentSetting                    IntermediatePath;                                  // 0x000C(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_MovePath) == 0x000008, "Wrong alignment on FAIAspectSettings_MovePath");
static_assert(sizeof(FAIAspectSettings_MovePath) == 0x000040, "Wrong size on FAIAspectSettings_MovePath");
static_assert(offsetof(FAIAspectSettings_MovePath, NodeTag) == 0x000000, "Member 'FAIAspectSettings_MovePath::NodeTag' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MovePath, bAllowPathSegment) == 0x000008, "Member 'FAIAspectSettings_MovePath::bAllowPathSegment' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MovePath, IntermediatePath) == 0x00000C, "Member 'FAIAspectSettings_MovePath::IntermediatePath' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_Revive
// 0x0090 (0x0090 - 0x0000)
struct FAIAspectSettings_Revive final
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              ReviveDistance;                                    // 0x0010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_Revive) == 0x000008, "Wrong alignment on FAIAspectSettings_Revive");
static_assert(sizeof(FAIAspectSettings_Revive) == 0x000090, "Wrong size on FAIAspectSettings_Revive");
static_assert(offsetof(FAIAspectSettings_Revive, Target) == 0x000000, "Member 'FAIAspectSettings_Revive::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Revive, ReviveDistance) == 0x000010, "Member 'FAIAspectSettings_Revive::ReviveDistance' has a wrong offset!");

// ScriptStruct OakGame.ZoneIdToMapIdMappingData
// 0x0002 (0x0002 - 0x0000)
struct FZoneIdToMapIdMappingData final
{
public:
	uint8                                         ZoneNameEnumIdx;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MapNameEnumIdx;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FZoneIdToMapIdMappingData) == 0x000001, "Wrong alignment on FZoneIdToMapIdMappingData");
static_assert(sizeof(FZoneIdToMapIdMappingData) == 0x000002, "Wrong size on FZoneIdToMapIdMappingData");
static_assert(offsetof(FZoneIdToMapIdMappingData, ZoneNameEnumIdx) == 0x000000, "Member 'FZoneIdToMapIdMappingData::ZoneNameEnumIdx' has a wrong offset!");
static_assert(offsetof(FZoneIdToMapIdMappingData, MapNameEnumIdx) == 0x000001, "Member 'FZoneIdToMapIdMappingData::MapNameEnumIdx' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleArchetype
// 0x0002 (0x0002 - 0x0000)
struct FAIAspectSettings_VehicleArchetype final
{
public:
	EVehicleAchetypeNative                        VehicleArchetype;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverted;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_VehicleArchetype) == 0x000001, "Wrong alignment on FAIAspectSettings_VehicleArchetype");
static_assert(sizeof(FAIAspectSettings_VehicleArchetype) == 0x000002, "Wrong size on FAIAspectSettings_VehicleArchetype");
static_assert(offsetof(FAIAspectSettings_VehicleArchetype, VehicleArchetype) == 0x000000, "Member 'FAIAspectSettings_VehicleArchetype::VehicleArchetype' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleArchetype, bInverted) == 0x000001, "Member 'FAIAspectSettings_VehicleArchetype::bInverted' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleAttitude
// 0x0002 (0x0002 - 0x0000)
struct FAIAspectSettings_VehicleAttitude final
{
public:
	ETeamAttitude                                 Attitude;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Inverted;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_VehicleAttitude) == 0x000001, "Wrong alignment on FAIAspectSettings_VehicleAttitude");
static_assert(sizeof(FAIAspectSettings_VehicleAttitude) == 0x000002, "Wrong size on FAIAspectSettings_VehicleAttitude");
static_assert(offsetof(FAIAspectSettings_VehicleAttitude, Attitude) == 0x000000, "Member 'FAIAspectSettings_VehicleAttitude::Attitude' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleAttitude, Inverted) == 0x000001, "Member 'FAIAspectSettings_VehicleAttitude::Inverted' has a wrong offset!");

// ScriptStruct OakGame.ManufacturerWeaponSightData
// 0x0010 (0x0010 - 0x0000)
struct FManufacturerWeaponSightData final
{
public:
	class UManufacturerData*                      Manufacturer;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RarityTable;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManufacturerWeaponSightData) == 0x000008, "Wrong alignment on FManufacturerWeaponSightData");
static_assert(sizeof(FManufacturerWeaponSightData) == 0x000010, "Wrong size on FManufacturerWeaponSightData");
static_assert(offsetof(FManufacturerWeaponSightData, Manufacturer) == 0x000000, "Member 'FManufacturerWeaponSightData::Manufacturer' has a wrong offset!");
static_assert(offsetof(FManufacturerWeaponSightData, RarityTable) == 0x000008, "Member 'FManufacturerWeaponSightData::RarityTable' has a wrong offset!");

// ScriptStruct OakGame.MainMenuCameraBlendParams
// 0x0010 (0x0010 - 0x0000)
struct FMainMenuCameraBlendParams final
{
public:
	float                                         BlendTime;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         BlendEasing;                                       // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuCameraBlendParams) == 0x000004, "Wrong alignment on FMainMenuCameraBlendParams");
static_assert(sizeof(FMainMenuCameraBlendParams) == 0x000010, "Wrong size on FMainMenuCameraBlendParams");
static_assert(offsetof(FMainMenuCameraBlendParams, BlendTime) == 0x000000, "Member 'FMainMenuCameraBlendParams::BlendTime' has a wrong offset!");
static_assert(offsetof(FMainMenuCameraBlendParams, BlendEasing) == 0x000004, "Member 'FMainMenuCameraBlendParams::BlendEasing' has a wrong offset!");

// ScriptStruct OakGame.MainMenuCameraBlendParamsSet
// 0x0034 (0x0034 - 0x0000)
struct FMainMenuCameraBlendParamsSet final
{
public:
	struct FMainMenuCameraBlendParams             DefaultParams;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverrideLocationParams : 1;                       // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideRotationParams : 1;                       // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMainMenuCameraBlendParams             LocationParams;                                    // 0x0014(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FMainMenuCameraBlendParams             RotationParams;                                    // 0x0024(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuCameraBlendParamsSet) == 0x000004, "Wrong alignment on FMainMenuCameraBlendParamsSet");
static_assert(sizeof(FMainMenuCameraBlendParamsSet) == 0x000034, "Wrong size on FMainMenuCameraBlendParamsSet");
static_assert(offsetof(FMainMenuCameraBlendParamsSet, DefaultParams) == 0x000000, "Member 'FMainMenuCameraBlendParamsSet::DefaultParams' has a wrong offset!");
static_assert(offsetof(FMainMenuCameraBlendParamsSet, LocationParams) == 0x000014, "Member 'FMainMenuCameraBlendParamsSet::LocationParams' has a wrong offset!");
static_assert(offsetof(FMainMenuCameraBlendParamsSet, RotationParams) == 0x000024, "Member 'FMainMenuCameraBlendParamsSet::RotationParams' has a wrong offset!");

// ScriptStruct OakGame.GbxInputEvent_OakLookAxis
// 0x0010 (0x0080 - 0x0070)
struct FGbxInputEvent_OakLookAxis final : public FGbxInputEvent_Axis_Core
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxInputEvent_OakLookAxis) == 0x000008, "Wrong alignment on FGbxInputEvent_OakLookAxis");
static_assert(sizeof(FGbxInputEvent_OakLookAxis) == 0x000080, "Wrong size on FGbxInputEvent_OakLookAxis");

// ScriptStruct OakGame.AIAspectSettings_VehicleDriverLeaves
// 0x0001 (0x0001 - 0x0000)
struct FAIAspectSettings_VehicleDriverLeaves final
{
public:
	bool                                          bInverted;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_VehicleDriverLeaves) == 0x000001, "Wrong alignment on FAIAspectSettings_VehicleDriverLeaves");
static_assert(sizeof(FAIAspectSettings_VehicleDriverLeaves) == 0x000001, "Wrong size on FAIAspectSettings_VehicleDriverLeaves");
static_assert(offsetof(FAIAspectSettings_VehicleDriverLeaves, bInverted) == 0x000000, "Member 'FAIAspectSettings_VehicleDriverLeaves::bInverted' has a wrong offset!");

// ScriptStruct OakGame.CheatManagerItemPool
// 0x0018 (0x0018 - 0x0000)
struct FCheatManagerItemPool final
{
public:
	class FString                                 ItemPool;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCheatManagerItemPool) == 0x000008, "Wrong alignment on FCheatManagerItemPool");
static_assert(sizeof(FCheatManagerItemPool) == 0x000018, "Wrong size on FCheatManagerItemPool");
static_assert(offsetof(FCheatManagerItemPool, ItemPool) == 0x000000, "Member 'FCheatManagerItemPool::ItemPool' has a wrong offset!");
static_assert(offsetof(FCheatManagerItemPool, Quantity) == 0x000010, "Member 'FCheatManagerItemPool::Quantity' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleDriving
// 0x0080 (0x0080 - 0x0000)
struct FAIAspectSettings_VehicleDriving final
{
public:
	struct FGbxParam                              DisableTurnHandBrake;                              // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_VehicleDriving) == 0x000008, "Wrong alignment on FAIAspectSettings_VehicleDriving");
static_assert(sizeof(FAIAspectSettings_VehicleDriving) == 0x000080, "Wrong size on FAIAspectSettings_VehicleDriving");
static_assert(offsetof(FAIAspectSettings_VehicleDriving, DisableTurnHandBrake) == 0x000000, "Member 'FAIAspectSettings_VehicleDriving::DisableTurnHandBrake' has a wrong offset!");

// ScriptStruct OakGame.EscortPathValidation
// 0x0014 (0x0014 - 0x0000)
struct FEscortPathValidation final
{
public:
	float                                         RotateAngleToSearchPath;                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidatePathAnticipationTime;                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidatePathFowardDistance;                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValidatePathIteration;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanGoIfValidationFailed;                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEscortPathValidation) == 0x000004, "Wrong alignment on FEscortPathValidation");
static_assert(sizeof(FEscortPathValidation) == 0x000014, "Wrong size on FEscortPathValidation");
static_assert(offsetof(FEscortPathValidation, RotateAngleToSearchPath) == 0x000000, "Member 'FEscortPathValidation::RotateAngleToSearchPath' has a wrong offset!");
static_assert(offsetof(FEscortPathValidation, ValidatePathAnticipationTime) == 0x000004, "Member 'FEscortPathValidation::ValidatePathAnticipationTime' has a wrong offset!");
static_assert(offsetof(FEscortPathValidation, ValidatePathFowardDistance) == 0x000008, "Member 'FEscortPathValidation::ValidatePathFowardDistance' has a wrong offset!");
static_assert(offsetof(FEscortPathValidation, ValidatePathIteration) == 0x00000C, "Member 'FEscortPathValidation::ValidatePathIteration' has a wrong offset!");
static_assert(offsetof(FEscortPathValidation, bCanGoIfValidationFailed) == 0x000010, "Member 'FEscortPathValidation::bCanGoIfValidationFailed' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleEscortSpeed
// 0x01A0 (0x01A0 - 0x0000)
struct FAIAspectSettings_VehicleEscortSpeed final
{
public:
	struct FGbxParam                              NearDistance;                                      // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              FarDistance;                                       // 0x0080(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              CatchUpSpeed;                                      // 0x0100(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         GoalUpdateDistance;                                // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnticipationTime;                                  // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidatePath;                                     // 0x0188(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEscortPathValidation                  EscortPathValidation;                              // 0x018C(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_VehicleEscortSpeed) == 0x000008, "Wrong alignment on FAIAspectSettings_VehicleEscortSpeed");
static_assert(sizeof(FAIAspectSettings_VehicleEscortSpeed) == 0x0001A0, "Wrong size on FAIAspectSettings_VehicleEscortSpeed");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, NearDistance) == 0x000000, "Member 'FAIAspectSettings_VehicleEscortSpeed::NearDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, FarDistance) == 0x000080, "Member 'FAIAspectSettings_VehicleEscortSpeed::FarDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, CatchUpSpeed) == 0x000100, "Member 'FAIAspectSettings_VehicleEscortSpeed::CatchUpSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, GoalUpdateDistance) == 0x000180, "Member 'FAIAspectSettings_VehicleEscortSpeed::GoalUpdateDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, AnticipationTime) == 0x000184, "Member 'FAIAspectSettings_VehicleEscortSpeed::AnticipationTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, bValidatePath) == 0x000188, "Member 'FAIAspectSettings_VehicleEscortSpeed::bValidatePath' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleEscortSpeed, EscortPathValidation) == 0x00018C, "Member 'FAIAspectSettings_VehicleEscortSpeed::EscortPathValidation' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuPartType
// 0x0002 (0x0002 - 0x0000)
struct FOakCARMenuPartType final
{
public:
	bool                                          bIsBody;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECARPartType                                  PartType;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakCARMenuPartType) == 0x000001, "Wrong alignment on FOakCARMenuPartType");
static_assert(sizeof(FOakCARMenuPartType) == 0x000002, "Wrong size on FOakCARMenuPartType");
static_assert(offsetof(FOakCARMenuPartType, bIsBody) == 0x000000, "Member 'FOakCARMenuPartType::bIsBody' has a wrong offset!");
static_assert(offsetof(FOakCARMenuPartType, PartType) == 0x000001, "Member 'FOakCARMenuPartType::PartType' has a wrong offset!");

// ScriptStruct OakGame.GFxCARMenuPartInfo
// 0x00E8 (0x00E8 - 0x0000)
struct FGFxCARMenuPartInfo final
{
public:
	class FText                                   PartName;                                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FOakCARMenuPartType                    PartType;                                          // 0x0018(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StageName;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ListName;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomizePanelFrameName;                           // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFocusableWidgetAdjacencyNames      AdjacentWidgets;                                   // 0x0050(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FGbxFocusableWidgetAdjacencyNames      AdjacentWidgetsSplitscreen;                        // 0x0090(0x0040)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCanSelectEmpty;                                   // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGFxCARMenuPartButton*                  BUTTON;                                            // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxCARMenuCustomizePage*               Page;                                              // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxCARMenuPartInfo) == 0x000008, "Wrong alignment on FGFxCARMenuPartInfo");
static_assert(sizeof(FGFxCARMenuPartInfo) == 0x0000E8, "Wrong size on FGFxCARMenuPartInfo");
static_assert(offsetof(FGFxCARMenuPartInfo, PartName) == 0x000000, "Member 'FGFxCARMenuPartInfo::PartName' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, PartType) == 0x000018, "Member 'FGFxCARMenuPartInfo::PartType' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, StageName) == 0x000020, "Member 'FGFxCARMenuPartInfo::StageName' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, ListName) == 0x000030, "Member 'FGFxCARMenuPartInfo::ListName' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, CustomizePanelFrameName) == 0x000040, "Member 'FGFxCARMenuPartInfo::CustomizePanelFrameName' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, AdjacentWidgets) == 0x000050, "Member 'FGFxCARMenuPartInfo::AdjacentWidgets' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, AdjacentWidgetsSplitscreen) == 0x000090, "Member 'FGFxCARMenuPartInfo::AdjacentWidgetsSplitscreen' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, bCanSelectEmpty) == 0x0000D0, "Member 'FGFxCARMenuPartInfo::bCanSelectEmpty' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, BUTTON) == 0x0000D8, "Member 'FGFxCARMenuPartInfo::BUTTON' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuPartInfo, Page) == 0x0000E0, "Member 'FGFxCARMenuPartInfo::Page' has a wrong offset!");

// ScriptStruct OakGame.ShieldBarrierTrackedBuffTarget
// 0x0048 (0x0048 - 0x0000)
struct FShieldBarrierTrackedBuffTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectInstanceReference         Mod1Reference;                                     // 0x0008(0x0018)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FStatusEffectInstanceReference         Mod5Reference;                                     // 0x0020(0x0018)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShieldBarrierTrackedBuffTarget) == 0x000008, "Wrong alignment on FShieldBarrierTrackedBuffTarget");
static_assert(sizeof(FShieldBarrierTrackedBuffTarget) == 0x000048, "Wrong size on FShieldBarrierTrackedBuffTarget");
static_assert(offsetof(FShieldBarrierTrackedBuffTarget, Target) == 0x000000, "Member 'FShieldBarrierTrackedBuffTarget::Target' has a wrong offset!");
static_assert(offsetof(FShieldBarrierTrackedBuffTarget, Mod1Reference) == 0x000008, "Member 'FShieldBarrierTrackedBuffTarget::Mod1Reference' has a wrong offset!");
static_assert(offsetof(FShieldBarrierTrackedBuffTarget, Mod5Reference) == 0x000020, "Member 'FShieldBarrierTrackedBuffTarget::Mod5Reference' has a wrong offset!");

// ScriptStruct OakGame.LingeringDamageTypeInfo
// 0x0048 (0x0048 - 0x0000)
struct FLingeringDamageTypeInfo final
{
public:
	ELingeringDamageStyle                         DamageStyle;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ElementalEmitter;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightBeamData>             LightBeam;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeamSocketName;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LingeringRadius;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MirvChildLingeringRadius;                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainChildLingeringRadius;                          // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeInitializationData>   StackValues;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLingeringDamageTypeInfo) == 0x000008, "Wrong alignment on FLingeringDamageTypeInfo");
static_assert(sizeof(FLingeringDamageTypeInfo) == 0x000048, "Wrong size on FLingeringDamageTypeInfo");
static_assert(offsetof(FLingeringDamageTypeInfo, DamageStyle) == 0x000000, "Member 'FLingeringDamageTypeInfo::DamageStyle' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, ElementalEmitter) == 0x000008, "Member 'FLingeringDamageTypeInfo::ElementalEmitter' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, LightBeam) == 0x000010, "Member 'FLingeringDamageTypeInfo::LightBeam' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, BeamSocketName) == 0x000018, "Member 'FLingeringDamageTypeInfo::BeamSocketName' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, DamageData) == 0x000020, "Member 'FLingeringDamageTypeInfo::DamageData' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, DamageScale) == 0x000028, "Member 'FLingeringDamageTypeInfo::DamageScale' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, LingeringRadius) == 0x00002C, "Member 'FLingeringDamageTypeInfo::LingeringRadius' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, MirvChildLingeringRadius) == 0x000030, "Member 'FLingeringDamageTypeInfo::MirvChildLingeringRadius' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, RainChildLingeringRadius) == 0x000034, "Member 'FLingeringDamageTypeInfo::RainChildLingeringRadius' has a wrong offset!");
static_assert(offsetof(FLingeringDamageTypeInfo, StackValues) == 0x000038, "Member 'FLingeringDamageTypeInfo::StackValues' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleParts
// 0x0018 (0x0018 - 0x0000)
struct FAIAspectSettings_VehicleParts final
{
public:
	TArray<TSoftObjectPtr<class UVehiclePartData>> Parts;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bInverted;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_VehicleParts) == 0x000008, "Wrong alignment on FAIAspectSettings_VehicleParts");
static_assert(sizeof(FAIAspectSettings_VehicleParts) == 0x000018, "Wrong size on FAIAspectSettings_VehicleParts");
static_assert(offsetof(FAIAspectSettings_VehicleParts, Parts) == 0x000000, "Member 'FAIAspectSettings_VehicleParts::Parts' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleParts, bInverted) == 0x000010, "Member 'FAIAspectSettings_VehicleParts::bInverted' has a wrong offset!");

// ScriptStruct OakGame.RubberbandSpeed
// 0x0218 (0x0218 - 0x0000)
struct FRubberbandSpeed final
{
public:
	struct FGbxBlackboardKeySelector              RubberbandTargetKey;                               // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              MinDistance;                                       // 0x0010(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              MaxDistance;                                       // 0x0090(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              MaxSpeed;                                          // 0x0110(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              MinSpeed;                                          // 0x0190(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bBehindOnly;                                       // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRubberbandSpeed) == 0x000008, "Wrong alignment on FRubberbandSpeed");
static_assert(sizeof(FRubberbandSpeed) == 0x000218, "Wrong size on FRubberbandSpeed");
static_assert(offsetof(FRubberbandSpeed, RubberbandTargetKey) == 0x000000, "Member 'FRubberbandSpeed::RubberbandTargetKey' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeed, MinDistance) == 0x000010, "Member 'FRubberbandSpeed::MinDistance' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeed, MaxDistance) == 0x000090, "Member 'FRubberbandSpeed::MaxDistance' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeed, MaxSpeed) == 0x000110, "Member 'FRubberbandSpeed::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeed, MinSpeed) == 0x000190, "Member 'FRubberbandSpeed::MinSpeed' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeed, bBehindOnly) == 0x000210, "Member 'FRubberbandSpeed::bBehindOnly' has a wrong offset!");

// ScriptStruct OakGame.AIAspectSettings_VehicleSpeed
// 0x06B8 (0x06B8 - 0x0000)
struct FAIAspectSettings_VehicleSpeed final
{
public:
	struct FGbxParam                              WantedSpeed;                                       // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseWantedSpeed;                                   // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              WantedSteering;                                    // 0x0088(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseWantedSteering;                                // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              MaxSpeed;                                          // 0x0110(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              UseBoost;                                          // 0x0190(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              ForceReverse;                                      // 0x0210(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              GoBackward;                                        // 0x0290(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              ForceHandbrake;                                    // 0x0310(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              SpeedHack;                                         // 0x0390(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRubberbandSpeed                       RubberbandSpeed;                                   // 0x0410(0x0218)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseRubberbandSpeed;                               // 0x0628(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Duration;                                          // 0x0630(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseDuration;                                      // 0x06B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B1[0x7];                                      // 0x06B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_VehicleSpeed) == 0x000008, "Wrong alignment on FAIAspectSettings_VehicleSpeed");
static_assert(sizeof(FAIAspectSettings_VehicleSpeed) == 0x0006B8, "Wrong size on FAIAspectSettings_VehicleSpeed");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, WantedSpeed) == 0x000000, "Member 'FAIAspectSettings_VehicleSpeed::WantedSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, bUseWantedSpeed) == 0x000080, "Member 'FAIAspectSettings_VehicleSpeed::bUseWantedSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, WantedSteering) == 0x000088, "Member 'FAIAspectSettings_VehicleSpeed::WantedSteering' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, bUseWantedSteering) == 0x000108, "Member 'FAIAspectSettings_VehicleSpeed::bUseWantedSteering' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, MaxSpeed) == 0x000110, "Member 'FAIAspectSettings_VehicleSpeed::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, UseBoost) == 0x000190, "Member 'FAIAspectSettings_VehicleSpeed::UseBoost' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, ForceReverse) == 0x000210, "Member 'FAIAspectSettings_VehicleSpeed::ForceReverse' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, GoBackward) == 0x000290, "Member 'FAIAspectSettings_VehicleSpeed::GoBackward' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, ForceHandbrake) == 0x000310, "Member 'FAIAspectSettings_VehicleSpeed::ForceHandbrake' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, SpeedHack) == 0x000390, "Member 'FAIAspectSettings_VehicleSpeed::SpeedHack' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, RubberbandSpeed) == 0x000410, "Member 'FAIAspectSettings_VehicleSpeed::RubberbandSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, bUseRubberbandSpeed) == 0x000628, "Member 'FAIAspectSettings_VehicleSpeed::bUseRubberbandSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, Duration) == 0x000630, "Member 'FAIAspectSettings_VehicleSpeed::Duration' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_VehicleSpeed, bUseDuration) == 0x0006B0, "Member 'FAIAspectSettings_VehicleSpeed::bUseDuration' has a wrong offset!");

// ScriptStruct OakGame.ChallengeInWorldIconQueueEntry
// 0x0010 (0x0010 - 0x0000)
struct FChallengeInWorldIconQueueEntry final
{
public:
	class UChallengeLevelActorComponent*          LevelActorComponent;                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   PlayerToRegister;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeInWorldIconQueueEntry) == 0x000008, "Wrong alignment on FChallengeInWorldIconQueueEntry");
static_assert(sizeof(FChallengeInWorldIconQueueEntry) == 0x000010, "Wrong size on FChallengeInWorldIconQueueEntry");
static_assert(offsetof(FChallengeInWorldIconQueueEntry, LevelActorComponent) == 0x000000, "Member 'FChallengeInWorldIconQueueEntry::LevelActorComponent' has a wrong offset!");
static_assert(offsetof(FChallengeInWorldIconQueueEntry, PlayerToRegister) == 0x000008, "Member 'FChallengeInWorldIconQueueEntry::PlayerToRegister' has a wrong offset!");

// ScriptStruct OakGame.OakUIChallengeListData
// 0x00C0 (0x00C0 - 0x0000)
struct FOakUIChallengeListData final
{
public:
	class UChallengeCategoryData*                 HeaderCategory;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumHeaderChildren;                                 // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumHeaderChildrenCompleted;                        // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChallengeInstanceData                 ChallengeInstanceData;                             // 0x0010(0x0080)(Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UZoneMapData>            ZoneMapData;                                       // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChildren;                                       // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChildrenComplete;                               // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUndiscovered;                                   // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UChallenge>                 ChallengeClass;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOakUIChallengeDataProvider> OwnerDataProvider;                                 // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAllChallenges;                                // 0x00B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakUIChallengeListData) == 0x000008, "Wrong alignment on FOakUIChallengeListData");
static_assert(sizeof(FOakUIChallengeListData) == 0x0000C0, "Wrong size on FOakUIChallengeListData");
static_assert(offsetof(FOakUIChallengeListData, HeaderCategory) == 0x000000, "Member 'FOakUIChallengeListData::HeaderCategory' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, NumHeaderChildren) == 0x000008, "Member 'FOakUIChallengeListData::NumHeaderChildren' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, NumHeaderChildrenCompleted) == 0x00000C, "Member 'FOakUIChallengeListData::NumHeaderChildrenCompleted' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, ChallengeInstanceData) == 0x000010, "Member 'FOakUIChallengeListData::ChallengeInstanceData' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, ZoneMapData) == 0x000090, "Member 'FOakUIChallengeListData::ZoneMapData' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, NumChildren) == 0x000098, "Member 'FOakUIChallengeListData::NumChildren' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, NumChildrenComplete) == 0x00009C, "Member 'FOakUIChallengeListData::NumChildrenComplete' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, bIsUndiscovered) == 0x0000A0, "Member 'FOakUIChallengeListData::bIsUndiscovered' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, ChallengeClass) == 0x0000A8, "Member 'FOakUIChallengeListData::ChallengeClass' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, OwnerDataProvider) == 0x0000B0, "Member 'FOakUIChallengeListData::OwnerDataProvider' has a wrong offset!");
static_assert(offsetof(FOakUIChallengeListData, bShowAllChallenges) == 0x0000B8, "Member 'FOakUIChallengeListData::bShowAllChallenges' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryMenuTypePriorityInfo
// 0x0018 (0x0018 - 0x0000)
struct FOakInventoryMenuTypePriorityInfo final
{
public:
	class UInventoryCategoryData*                 ItemType;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTypeAsset*                       WeaponTypeData;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriorityValue;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakInventoryMenuTypePriorityInfo) == 0x000008, "Wrong alignment on FOakInventoryMenuTypePriorityInfo");
static_assert(sizeof(FOakInventoryMenuTypePriorityInfo) == 0x000018, "Wrong size on FOakInventoryMenuTypePriorityInfo");
static_assert(offsetof(FOakInventoryMenuTypePriorityInfo, ItemType) == 0x000000, "Member 'FOakInventoryMenuTypePriorityInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuTypePriorityInfo, WeaponTypeData) == 0x000008, "Member 'FOakInventoryMenuTypePriorityInfo::WeaponTypeData' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuTypePriorityInfo, PriorityValue) == 0x000010, "Member 'FOakInventoryMenuTypePriorityInfo::PriorityValue' has a wrong offset!");

// ScriptStruct OakGame.AnointedEnemyData
// 0x0010 (0x0010 - 0x0000)
struct FAnointedEnemyData final
{
public:
	TSubclassOf<class UGbxAction>                 PreFreezeAction;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FailsafeDestroyDelay;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressItemPoolsForFailsafeShatter;              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnointedEnemyData) == 0x000008, "Wrong alignment on FAnointedEnemyData");
static_assert(sizeof(FAnointedEnemyData) == 0x000010, "Wrong size on FAnointedEnemyData");
static_assert(offsetof(FAnointedEnemyData, PreFreezeAction) == 0x000000, "Member 'FAnointedEnemyData::PreFreezeAction' has a wrong offset!");
static_assert(offsetof(FAnointedEnemyData, FailsafeDestroyDelay) == 0x000008, "Member 'FAnointedEnemyData::FailsafeDestroyDelay' has a wrong offset!");
static_assert(offsetof(FAnointedEnemyData, bSuppressItemPoolsForFailsafeShatter) == 0x00000C, "Member 'FAnointedEnemyData::bSuppressItemPoolsForFailsafeShatter' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityResourceSpec_WeaponShotModifier
// 0x0018 (0x0028 - 0x0010)
struct FOakAbilityResourceSpec_WeaponShotModifier final : public FGbxAbilityResourceSpec
{
public:
	class UOakDamageCauserComponent*              DamageCauserComponent;                             // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponShotModifier*                    ShotModifier;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextOverride;                                   // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakAbilityResourceSpec_WeaponShotModifier) == 0x000008, "Wrong alignment on FOakAbilityResourceSpec_WeaponShotModifier");
static_assert(sizeof(FOakAbilityResourceSpec_WeaponShotModifier) == 0x000028, "Wrong size on FOakAbilityResourceSpec_WeaponShotModifier");
static_assert(offsetof(FOakAbilityResourceSpec_WeaponShotModifier, DamageCauserComponent) == 0x000010, "Member 'FOakAbilityResourceSpec_WeaponShotModifier::DamageCauserComponent' has a wrong offset!");
static_assert(offsetof(FOakAbilityResourceSpec_WeaponShotModifier, ShotModifier) == 0x000018, "Member 'FOakAbilityResourceSpec_WeaponShotModifier::ShotModifier' has a wrong offset!");
static_assert(offsetof(FOakAbilityResourceSpec_WeaponShotModifier, ContextOverride) == 0x000020, "Member 'FOakAbilityResourceSpec_WeaponShotModifier::ContextOverride' has a wrong offset!");

// ScriptStruct OakGame.WeaponSkinSectionData
// 0x0030 (0x0030 - 0x0000)
struct FWeaponSkinSectionData final
{
public:
	int32                                         SectionIndex;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSkinSectionData) == 0x000008, "Wrong alignment on FWeaponSkinSectionData");
static_assert(sizeof(FWeaponSkinSectionData) == 0x000030, "Wrong size on FWeaponSkinSectionData");
static_assert(offsetof(FWeaponSkinSectionData, SectionIndex) == 0x000000, "Member 'FWeaponSkinSectionData::SectionIndex' has a wrong offset!");
static_assert(offsetof(FWeaponSkinSectionData, Material) == 0x000008, "Member 'FWeaponSkinSectionData::Material' has a wrong offset!");

// ScriptStruct OakGame.WeaponSkinWeaponTypeData
// 0x0018 (0x0018 - 0x0000)
struct FWeaponSkinWeaponTypeData final
{
public:
	class UWeaponTypeData*                        WeaponType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeaponSkinSectionData>         Materials;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSkinWeaponTypeData) == 0x000008, "Wrong alignment on FWeaponSkinWeaponTypeData");
static_assert(sizeof(FWeaponSkinWeaponTypeData) == 0x000018, "Wrong size on FWeaponSkinWeaponTypeData");
static_assert(offsetof(FWeaponSkinWeaponTypeData, WeaponType) == 0x000000, "Member 'FWeaponSkinWeaponTypeData::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponSkinWeaponTypeData, Materials) == 0x000008, "Member 'FWeaponSkinWeaponTypeData::Materials' has a wrong offset!");

// ScriptStruct OakGame.AIPlayThroughData
// 0x00B0 (0x00B0 - 0x0000)
struct FAIPlayThroughData final
{
public:
	uint8                                         bOverrideUIDisplayName : 1;                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDisplayName : 1;                          // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDropOnDeathItemPools : 1;                 // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideEquippedItems : 1;                        // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideHealthInformation : 1;                    // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxUIName*                             DisplayUIName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	struct FItemPoolCollection                    DropOnDeathItemPools;                              // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FItemPoolCollection                    EquippedItemPoolCollection;                        // 0x0048(0x0020)(Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FItemPoolCollection>            EquippedItemPoolCollections;                       // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEquipSingleItemFromCollection;                    // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeBaseValueData>        AttributeStartingValues;                           // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    BalanceTableRow;                                   // 0x0090(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHealthType>                    HealthInformation;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIPlayThroughData) == 0x000008, "Wrong alignment on FAIPlayThroughData");
static_assert(sizeof(FAIPlayThroughData) == 0x0000B0, "Wrong size on FAIPlayThroughData");
static_assert(offsetof(FAIPlayThroughData, DisplayUIName) == 0x000008, "Member 'FAIPlayThroughData::DisplayUIName' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, DisplayName) == 0x000010, "Member 'FAIPlayThroughData::DisplayName' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, DropOnDeathItemPools) == 0x000028, "Member 'FAIPlayThroughData::DropOnDeathItemPools' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, EquippedItemPoolCollection) == 0x000048, "Member 'FAIPlayThroughData::EquippedItemPoolCollection' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, EquippedItemPoolCollections) == 0x000068, "Member 'FAIPlayThroughData::EquippedItemPoolCollections' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, bEquipSingleItemFromCollection) == 0x000078, "Member 'FAIPlayThroughData::bEquipSingleItemFromCollection' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, AttributeStartingValues) == 0x000080, "Member 'FAIPlayThroughData::AttributeStartingValues' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, BalanceTableRow) == 0x000090, "Member 'FAIPlayThroughData::BalanceTableRow' has a wrong offset!");
static_assert(offsetof(FAIPlayThroughData, HealthInformation) == 0x0000A0, "Member 'FAIPlayThroughData::HealthInformation' has a wrong offset!");

// ScriptStruct OakGame.DodgeVOInfo
// 0x0010 (0x0010 - 0x0000)
struct FDodgeVOInfo final
{
public:
	class UDialogEvent*                           DialogEvent;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterSoundTag*                     VocalizationTag;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDodgeVOInfo) == 0x000008, "Wrong alignment on FDodgeVOInfo");
static_assert(sizeof(FDodgeVOInfo) == 0x000010, "Wrong size on FDodgeVOInfo");
static_assert(offsetof(FDodgeVOInfo, DialogEvent) == 0x000000, "Member 'FDodgeVOInfo::DialogEvent' has a wrong offset!");
static_assert(offsetof(FDodgeVOInfo, VocalizationTag) == 0x000008, "Member 'FDodgeVOInfo::VocalizationTag' has a wrong offset!");

// ScriptStruct OakGame.DamageTypeParticleProperty
// 0x0060 (0x0060 - 0x0000)
struct FDamageTypeParticleProperty final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPropertyValue;                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UGbxDamageType>, float> DamageTypeValueAssociations;                       // 0x0010(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeParticleProperty) == 0x000008, "Wrong alignment on FDamageTypeParticleProperty");
static_assert(sizeof(FDamageTypeParticleProperty) == 0x000060, "Wrong size on FDamageTypeParticleProperty");
static_assert(offsetof(FDamageTypeParticleProperty, PropertyName) == 0x000000, "Member 'FDamageTypeParticleProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(FDamageTypeParticleProperty, DefaultPropertyValue) == 0x000008, "Member 'FDamageTypeParticleProperty::DefaultPropertyValue' has a wrong offset!");
static_assert(offsetof(FDamageTypeParticleProperty, DamageTypeValueAssociations) == 0x000010, "Member 'FDamageTypeParticleProperty::DamageTypeValueAssociations' has a wrong offset!");

// ScriptStruct OakGame.Donator
// 0x0020 (0x0020 - 0x0000)
struct FDonator final
{
public:
	bool                                          bIsFirstDonator;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DonatorName;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDonations;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BitsDonatedTotal;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDonator) == 0x000008, "Wrong alignment on FDonator");
static_assert(sizeof(FDonator) == 0x000020, "Wrong size on FDonator");
static_assert(offsetof(FDonator, bIsFirstDonator) == 0x000000, "Member 'FDonator::bIsFirstDonator' has a wrong offset!");
static_assert(offsetof(FDonator, DonatorName) == 0x000008, "Member 'FDonator::DonatorName' has a wrong offset!");
static_assert(offsetof(FDonator, NumberOfDonations) == 0x000018, "Member 'FDonator::NumberOfDonations' has a wrong offset!");
static_assert(offsetof(FDonator, BitsDonatedTotal) == 0x00001C, "Member 'FDonator::BitsDonatedTotal' has a wrong offset!");

// ScriptStruct OakGame.PaintedTarget
// 0x0060 (0x0060 - 0x0000)
struct FPaintedTarget final
{
public:
	TWeakObjectPtr<class AActor>                  PaintedTarget;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHUDInWorldIconTargetInfo              HUDIconInfo;                                       // 0x0008(0x0058)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPaintedTarget) == 0x000008, "Wrong alignment on FPaintedTarget");
static_assert(sizeof(FPaintedTarget) == 0x000060, "Wrong size on FPaintedTarget");
static_assert(offsetof(FPaintedTarget, PaintedTarget) == 0x000000, "Member 'FPaintedTarget::PaintedTarget' has a wrong offset!");
static_assert(offsetof(FPaintedTarget, HUDIconInfo) == 0x000008, "Member 'FPaintedTarget::HUDIconInfo' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_Carnivora
// 0x1A10 (0x1B50 - 0x0140)
struct alignas(0x10) FAnimNode_Carnivora final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         MaxYawFrontWheel;                                  // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinYawFrontWheel;                                  // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawTireTrack;                                   // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinYawTireTrack;                                   // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTrackShaftBoneScale;                            // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTrackShaftBoneScale;                            // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontWheelsMinHeight;                              // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontWheelsMaxHeight;                              // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireTrackMinHeight;                                // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireTrackMaxHeight;                                // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontWheelRadius;                                  // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireTrackWheelsRadius;                             // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallGearRadius;                                   // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigAxleRadius;                                     // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainAxleRadius;                                    // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x19D4];                                   // 0x017C(0x19D4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_Carnivora) == 0x000010, "Wrong alignment on FAnimNode_Carnivora");
static_assert(sizeof(FAnimNode_Carnivora) == 0x001B50, "Wrong size on FAnimNode_Carnivora");
static_assert(offsetof(FAnimNode_Carnivora, MaxYawFrontWheel) == 0x000140, "Member 'FAnimNode_Carnivora::MaxYawFrontWheel' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, MinYawFrontWheel) == 0x000144, "Member 'FAnimNode_Carnivora::MinYawFrontWheel' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, MaxYawTireTrack) == 0x000148, "Member 'FAnimNode_Carnivora::MaxYawTireTrack' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, MinYawTireTrack) == 0x00014C, "Member 'FAnimNode_Carnivora::MinYawTireTrack' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, MinTrackShaftBoneScale) == 0x000150, "Member 'FAnimNode_Carnivora::MinTrackShaftBoneScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, MaxTrackShaftBoneScale) == 0x000154, "Member 'FAnimNode_Carnivora::MaxTrackShaftBoneScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, FrontWheelsMinHeight) == 0x000158, "Member 'FAnimNode_Carnivora::FrontWheelsMinHeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, FrontWheelsMaxHeight) == 0x00015C, "Member 'FAnimNode_Carnivora::FrontWheelsMaxHeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, TireTrackMinHeight) == 0x000160, "Member 'FAnimNode_Carnivora::TireTrackMinHeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, TireTrackMaxHeight) == 0x000164, "Member 'FAnimNode_Carnivora::TireTrackMaxHeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, FrontWheelRadius) == 0x000168, "Member 'FAnimNode_Carnivora::FrontWheelRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, TireTrackWheelsRadius) == 0x00016C, "Member 'FAnimNode_Carnivora::TireTrackWheelsRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, SmallGearRadius) == 0x000170, "Member 'FAnimNode_Carnivora::SmallGearRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, BigAxleRadius) == 0x000174, "Member 'FAnimNode_Carnivora::BigAxleRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_Carnivora, MainAxleRadius) == 0x000178, "Member 'FAnimNode_Carnivora::MainAxleRadius' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_EmperorHandler
// 0x1990 (0x1AD0 - 0x0140)
struct alignas(0x10) FAnimNode_EmperorHandler final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         SuspensionDropMaxSpeed;                            // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingInterpolationSpeed;                         // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SlidingDisplacement;                               // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinPeriod1;                                        // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinPeriod2;                                        // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinPeriod3;                                        // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAmplitude1;                                     // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAmplitude2;                                     // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAmplitude3;                                     // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelConeX;                                       // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelConeY;                                       // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverIntrepSpeed;                                  // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverBodyHeigth;                                   // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InoccupiedHoverBodyHeigth;                         // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x1954];                                   // 0x017C(0x1954)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_EmperorHandler) == 0x000010, "Wrong alignment on FAnimNode_EmperorHandler");
static_assert(sizeof(FAnimNode_EmperorHandler) == 0x001AD0, "Wrong size on FAnimNode_EmperorHandler");
static_assert(offsetof(FAnimNode_EmperorHandler, SuspensionDropMaxSpeed) == 0x000140, "Member 'FAnimNode_EmperorHandler::SuspensionDropMaxSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SlidingInterpolationSpeed) == 0x000144, "Member 'FAnimNode_EmperorHandler::SlidingInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SlidingDisplacement) == 0x000148, "Member 'FAnimNode_EmperorHandler::SlidingDisplacement' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SinPeriod1) == 0x000150, "Member 'FAnimNode_EmperorHandler::SinPeriod1' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SinPeriod2) == 0x000154, "Member 'FAnimNode_EmperorHandler::SinPeriod2' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SinPeriod3) == 0x000158, "Member 'FAnimNode_EmperorHandler::SinPeriod3' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SinAmplitude1) == 0x00015C, "Member 'FAnimNode_EmperorHandler::SinAmplitude1' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SinAmplitude2) == 0x000160, "Member 'FAnimNode_EmperorHandler::SinAmplitude2' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SinAmplitude3) == 0x000164, "Member 'FAnimNode_EmperorHandler::SinAmplitude3' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SwivelConeX) == 0x000168, "Member 'FAnimNode_EmperorHandler::SwivelConeX' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, SwivelConeY) == 0x00016C, "Member 'FAnimNode_EmperorHandler::SwivelConeY' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, HoverIntrepSpeed) == 0x000170, "Member 'FAnimNode_EmperorHandler::HoverIntrepSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, HoverBodyHeigth) == 0x000174, "Member 'FAnimNode_EmperorHandler::HoverBodyHeigth' has a wrong offset!");
static_assert(offsetof(FAnimNode_EmperorHandler, InoccupiedHoverBodyHeigth) == 0x000178, "Member 'FAnimNode_EmperorHandler::InoccupiedHoverBodyHeigth' has a wrong offset!");

// ScriptStruct OakGame.ChallengeReward
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FChallengeReward final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeReward) == 0x000008, "Wrong alignment on FChallengeReward");
static_assert(sizeof(FChallengeReward) == 0x000020, "Wrong size on FChallengeReward");

// ScriptStruct OakGame.ManagedActorCountData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FManagedActorCountData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedActorCountData) == 0x000008, "Wrong alignment on FManagedActorCountData");
static_assert(sizeof(FManagedActorCountData) == 0x000010, "Wrong size on FManagedActorCountData");

// ScriptStruct OakGame.CrewQuartersDecorationSaveData
// 0x0018 (0x0018 - 0x0000)
struct FCrewQuartersDecorationSaveData final
{
public:
	int32                                         DecorationIndex;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DecorationDataPath;                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCrewQuartersDecorationSaveData) == 0x000008, "Wrong alignment on FCrewQuartersDecorationSaveData");
static_assert(sizeof(FCrewQuartersDecorationSaveData) == 0x000018, "Wrong size on FCrewQuartersDecorationSaveData");
static_assert(offsetof(FCrewQuartersDecorationSaveData, DecorationIndex) == 0x000000, "Member 'FCrewQuartersDecorationSaveData::DecorationIndex' has a wrong offset!");
static_assert(offsetof(FCrewQuartersDecorationSaveData, DecorationDataPath) == 0x000008, "Member 'FCrewQuartersDecorationSaveData::DecorationDataPath' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersSaveData
// 0x0028 (0x0028 - 0x0000)
struct FCrewQuartersSaveData final
{
public:
	int32                                         PreferredRoomAssignment;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrewQuartersDecorationSaveData> Decorations;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RoomDataPath;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCrewQuartersSaveData) == 0x000008, "Wrong alignment on FCrewQuartersSaveData");
static_assert(sizeof(FCrewQuartersSaveData) == 0x000028, "Wrong size on FCrewQuartersSaveData");
static_assert(offsetof(FCrewQuartersSaveData, PreferredRoomAssignment) == 0x000000, "Member 'FCrewQuartersSaveData::PreferredRoomAssignment' has a wrong offset!");
static_assert(offsetof(FCrewQuartersSaveData, Decorations) == 0x000008, "Member 'FCrewQuartersSaveData::Decorations' has a wrong offset!");
static_assert(offsetof(FCrewQuartersSaveData, RoomDataPath) == 0x000018, "Member 'FCrewQuartersSaveData::RoomDataPath' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_OutrunnerBooster
// 0x0870 (0x09B0 - 0x0140)
struct alignas(0x10) FAnimNode_OutrunnerBooster final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_140[0x870];                                    // 0x0140(0x0870)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_OutrunnerBooster) == 0x000010, "Wrong alignment on FAnimNode_OutrunnerBooster");
static_assert(sizeof(FAnimNode_OutrunnerBooster) == 0x0009B0, "Wrong size on FAnimNode_OutrunnerBooster");

// ScriptStruct OakGame.AnimNode_RevolverBooster
// 0x0340 (0x0480 - 0x0140)
struct alignas(0x10) FAnimNode_RevolverBooster final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_140[0x314];                                    // 0x0140(0x0314)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyCycleFromEngineCycleRatio;                     // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRPM;                                           // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineRunningAmplitude;                            // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineIdleAmplitude;                               // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MufflerAmplitudeMutliplier;                        // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineRunningFrequency;                            // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineIdleFrequency;                               // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MufflerFrequencyMutliplier;                        // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0xC];                                      // 0x0474(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RevolverBooster) == 0x000010, "Wrong alignment on FAnimNode_RevolverBooster");
static_assert(sizeof(FAnimNode_RevolverBooster) == 0x000480, "Wrong size on FAnimNode_RevolverBooster");
static_assert(offsetof(FAnimNode_RevolverBooster, BodyCycleFromEngineCycleRatio) == 0x000454, "Member 'FAnimNode_RevolverBooster::BodyCycleFromEngineCycleRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, IdleRPM) == 0x000458, "Member 'FAnimNode_RevolverBooster::IdleRPM' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, EngineRunningAmplitude) == 0x00045C, "Member 'FAnimNode_RevolverBooster::EngineRunningAmplitude' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, EngineIdleAmplitude) == 0x000460, "Member 'FAnimNode_RevolverBooster::EngineIdleAmplitude' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, MufflerAmplitudeMutliplier) == 0x000464, "Member 'FAnimNode_RevolverBooster::MufflerAmplitudeMutliplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, EngineRunningFrequency) == 0x000468, "Member 'FAnimNode_RevolverBooster::EngineRunningFrequency' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, EngineIdleFrequency) == 0x00046C, "Member 'FAnimNode_RevolverBooster::EngineIdleFrequency' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverBooster, MufflerFrequencyMutliplier) == 0x000470, "Member 'FAnimNode_RevolverBooster::MufflerFrequencyMutliplier' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_RevolverHandler
// 0x0460 (0x05A0 - 0x0140)
struct alignas(0x10) FAnimNode_RevolverHandler final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         MaxSteeringAngle;                                  // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinPeriod1;                                        // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinPeriod2;                                        // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinPeriod3;                                        // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAmplitude1;                                     // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAmplitude2;                                     // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAmplitude3;                                     // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelConeX;                                       // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelConeY;                                       // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelPeriodX;                                     // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwivelPeriodY;                                     // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverIntrepSpeed;                                  // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyCompensationInterpSpeed;                       // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverBodyCompensationInterpSpeed;                  // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyOffsetInterpSpeed;                             // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyHoverOffset;                                   // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionOffsetFromRotation;                        // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxPitchAngle;                                // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxRollAngle;                                 // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverPitchInterpSpeed;                             // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverPitchBoostingInterpSpeed;                     // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverRollInterpSpeed;                              // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AccelerationCurve;                                 // 0x0198(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x390];                                    // 0x0210(0x0390)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RevolverHandler) == 0x000010, "Wrong alignment on FAnimNode_RevolverHandler");
static_assert(sizeof(FAnimNode_RevolverHandler) == 0x0005A0, "Wrong size on FAnimNode_RevolverHandler");
static_assert(offsetof(FAnimNode_RevolverHandler, MaxSteeringAngle) == 0x000140, "Member 'FAnimNode_RevolverHandler::MaxSteeringAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SinPeriod1) == 0x000144, "Member 'FAnimNode_RevolverHandler::SinPeriod1' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SinPeriod2) == 0x000148, "Member 'FAnimNode_RevolverHandler::SinPeriod2' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SinPeriod3) == 0x00014C, "Member 'FAnimNode_RevolverHandler::SinPeriod3' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SinAmplitude1) == 0x000150, "Member 'FAnimNode_RevolverHandler::SinAmplitude1' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SinAmplitude2) == 0x000154, "Member 'FAnimNode_RevolverHandler::SinAmplitude2' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SinAmplitude3) == 0x000158, "Member 'FAnimNode_RevolverHandler::SinAmplitude3' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SwivelConeX) == 0x00015C, "Member 'FAnimNode_RevolverHandler::SwivelConeX' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SwivelConeY) == 0x000160, "Member 'FAnimNode_RevolverHandler::SwivelConeY' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SwivelPeriodX) == 0x000164, "Member 'FAnimNode_RevolverHandler::SwivelPeriodX' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, SwivelPeriodY) == 0x000168, "Member 'FAnimNode_RevolverHandler::SwivelPeriodY' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverIntrepSpeed) == 0x00016C, "Member 'FAnimNode_RevolverHandler::HoverIntrepSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, BodyCompensationInterpSpeed) == 0x000170, "Member 'FAnimNode_RevolverHandler::BodyCompensationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverBodyCompensationInterpSpeed) == 0x000174, "Member 'FAnimNode_RevolverHandler::HoverBodyCompensationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, BodyOffsetInterpSpeed) == 0x000178, "Member 'FAnimNode_RevolverHandler::BodyOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, BodyHoverOffset) == 0x00017C, "Member 'FAnimNode_RevolverHandler::BodyHoverOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, PositionOffsetFromRotation) == 0x000180, "Member 'FAnimNode_RevolverHandler::PositionOffsetFromRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverMaxPitchAngle) == 0x000184, "Member 'FAnimNode_RevolverHandler::HoverMaxPitchAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverMaxRollAngle) == 0x000188, "Member 'FAnimNode_RevolverHandler::HoverMaxRollAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverPitchInterpSpeed) == 0x00018C, "Member 'FAnimNode_RevolverHandler::HoverPitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverPitchBoostingInterpSpeed) == 0x000190, "Member 'FAnimNode_RevolverHandler::HoverPitchBoostingInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, HoverRollInterpSpeed) == 0x000194, "Member 'FAnimNode_RevolverHandler::HoverRollInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_RevolverHandler, AccelerationCurve) == 0x000198, "Member 'FAnimNode_RevolverHandler::AccelerationCurve' has a wrong offset!");

// ScriptStruct OakGame.GFxDuelTimerTotemData
// 0x0018 (0x0018 - 0x0000)
struct FGFxDuelTimerTotemData final
{
public:
	class UGFxDuelTimerTotemObject*               TimerClip;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOakDuelingWidgetTotemComponent> AttachedDuelTotemComponent;                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInUse;                                            // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxDuelTimerTotemData) == 0x000008, "Wrong alignment on FGFxDuelTimerTotemData");
static_assert(sizeof(FGFxDuelTimerTotemData) == 0x000018, "Wrong size on FGFxDuelTimerTotemData");
static_assert(offsetof(FGFxDuelTimerTotemData, TimerClip) == 0x000000, "Member 'FGFxDuelTimerTotemData::TimerClip' has a wrong offset!");
static_assert(offsetof(FGFxDuelTimerTotemData, AttachedDuelTotemComponent) == 0x000008, "Member 'FGFxDuelTimerTotemData::AttachedDuelTotemComponent' has a wrong offset!");
static_assert(offsetof(FGFxDuelTimerTotemData, bInUse) == 0x000010, "Member 'FGFxDuelTimerTotemData::bInUse' has a wrong offset!");

// ScriptStruct OakGame.RoadBumpinessData
// 0x0008 (0x0008 - 0x0000)
struct FRoadBumpinessData final
{
public:
	EPhysicalSurface                              SurfaceType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Bumpiness;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoadBumpinessData) == 0x000004, "Wrong alignment on FRoadBumpinessData");
static_assert(sizeof(FRoadBumpinessData) == 0x000008, "Wrong size on FRoadBumpinessData");
static_assert(offsetof(FRoadBumpinessData, SurfaceType) == 0x000000, "Member 'FRoadBumpinessData::SurfaceType' has a wrong offset!");
static_assert(offsetof(FRoadBumpinessData, Bumpiness) == 0x000004, "Member 'FRoadBumpinessData::Bumpiness' has a wrong offset!");

// ScriptStruct OakGame.HoverBodySinus
// 0x001C (0x001C - 0x0000)
struct FHoverBodySinus final
{
public:
	struct FVector                                HoverScale;                                        // 0x0000(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetX;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetY;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoverBodySinus) == 0x000004, "Wrong alignment on FHoverBodySinus");
static_assert(sizeof(FHoverBodySinus) == 0x00001C, "Wrong size on FHoverBodySinus");
static_assert(offsetof(FHoverBodySinus, HoverScale) == 0x000000, "Member 'FHoverBodySinus::HoverScale' has a wrong offset!");
static_assert(offsetof(FHoverBodySinus, OffsetX) == 0x00000C, "Member 'FHoverBodySinus::OffsetX' has a wrong offset!");
static_assert(offsetof(FHoverBodySinus, OffsetY) == 0x000010, "Member 'FHoverBodySinus::OffsetY' has a wrong offset!");
static_assert(offsetof(FHoverBodySinus, Frequency) == 0x000014, "Member 'FHoverBodySinus::Frequency' has a wrong offset!");
static_assert(offsetof(FHoverBodySinus, Amplitude) == 0x000018, "Member 'FHoverBodySinus::Amplitude' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_TechnicalHandler
// 0x2BF0 (0x2D30 - 0x0140)
struct alignas(0x10) FAnimNode_TechnicalHandler final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         SuspensionDropMaxSpeed;                            // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SuspensionCamberCurve;                             // 0x0148(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         CamberIntensity;                                   // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigWheelsBodyZ;                                    // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTreshold;                              // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningVelocityTreshold;                           // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchInterpSpeed;                                  // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollInterpSpeed;                                   // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMaxAngle;                                      // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BankingBoostAlpha;                                 // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     PitchAccelerationCurve;                            // 0x01E0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         BoostBodyPitchAdd;                                 // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostBodyUpAdd;                                    // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSteeringAngle;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceAmplitudePitchHighFreq;                 // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceFrequencyPitchHighFreq;                 // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceFrequencyRollFreq;                      // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfacePersistencePitchHighFreq;               // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoadSurfaceOctavesPitchHighFreq;                   // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceAmplitudePitchLowFreq;                  // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfaceFrequencyPitchLowFreq;                  // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoadSurfacePersistencePitchLowFreq;                // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoadSurfaceOctavesPitchLowFreq;                    // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyFollowSpeedOfPitch;                            // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyFollowAmplitudeMultiplier;                     // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToSwitch;                                   // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToSwitch;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBumpTimeValue;                                  // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBumpTimeValue;                                  // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAlphaValue;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAlphaValue;                                     // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInterpSpeed;                                    // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInterpSpeed;                                    // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultRoadBumpiness;                              // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRoadBumpinessData>             RoadBumpinessOverrides;                            // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         EngineAmplitude;                                   // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyCycleFromEngineCycleRatio;                     // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRPM;                                           // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverWheelAngle;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpinSpeedIdle;                                // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpinSpeedFullTrottle;                         // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverOffsetZ;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverFrontWheelAdd;                                // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxVelocity;                                  // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSuspensionIntensityUp;                        // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSuspensionIntensityDown;                      // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHoverBodySinus>                HoverBodySin;                                      // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SwivelCone;                                        // 0x0308(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxPitchAngle;                                // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverMaxRollAngle;                                 // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverPitchInterpSpeed;                             // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverPitchBoostingInterpSpeed;                     // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverRollInterpSpeed;                              // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverWheelRotationIntensity;                       // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverWheelRotationIntensityY;                      // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     HoverBodyTransitionCurve;                          // 0x0330(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x2988];                                   // 0x03A8(0x2988)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TechnicalHandler) == 0x000010, "Wrong alignment on FAnimNode_TechnicalHandler");
static_assert(sizeof(FAnimNode_TechnicalHandler) == 0x002D30, "Wrong size on FAnimNode_TechnicalHandler");
static_assert(offsetof(FAnimNode_TechnicalHandler, SuspensionDropMaxSpeed) == 0x000140, "Member 'FAnimNode_TechnicalHandler::SuspensionDropMaxSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, SuspensionCamberCurve) == 0x000148, "Member 'FAnimNode_TechnicalHandler::SuspensionCamberCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, CamberIntensity) == 0x0001C0, "Member 'FAnimNode_TechnicalHandler::CamberIntensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BigWheelsBodyZ) == 0x0001C4, "Member 'FAnimNode_TechnicalHandler::BigWheelsBodyZ' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, AccelerationTreshold) == 0x0001C8, "Member 'FAnimNode_TechnicalHandler::AccelerationTreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, TurningVelocityTreshold) == 0x0001CC, "Member 'FAnimNode_TechnicalHandler::TurningVelocityTreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, PitchInterpSpeed) == 0x0001D0, "Member 'FAnimNode_TechnicalHandler::PitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RollInterpSpeed) == 0x0001D4, "Member 'FAnimNode_TechnicalHandler::RollInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RollMaxAngle) == 0x0001D8, "Member 'FAnimNode_TechnicalHandler::RollMaxAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BankingBoostAlpha) == 0x0001DC, "Member 'FAnimNode_TechnicalHandler::BankingBoostAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, PitchAccelerationCurve) == 0x0001E0, "Member 'FAnimNode_TechnicalHandler::PitchAccelerationCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BoostBodyPitchAdd) == 0x000258, "Member 'FAnimNode_TechnicalHandler::BoostBodyPitchAdd' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BoostBodyUpAdd) == 0x00025C, "Member 'FAnimNode_TechnicalHandler::BoostBodyUpAdd' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MaxSteeringAngle) == 0x000260, "Member 'FAnimNode_TechnicalHandler::MaxSteeringAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceAmplitudePitchHighFreq) == 0x000264, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceAmplitudePitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceFrequencyPitchHighFreq) == 0x000268, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceFrequencyPitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceFrequencyRollFreq) == 0x00026C, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceFrequencyRollFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfacePersistencePitchHighFreq) == 0x000270, "Member 'FAnimNode_TechnicalHandler::RoadSurfacePersistencePitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceOctavesPitchHighFreq) == 0x000274, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceOctavesPitchHighFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceAmplitudePitchLowFreq) == 0x000278, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceAmplitudePitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceFrequencyPitchLowFreq) == 0x00027C, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceFrequencyPitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfacePersistencePitchLowFreq) == 0x000280, "Member 'FAnimNode_TechnicalHandler::RoadSurfacePersistencePitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadSurfaceOctavesPitchLowFreq) == 0x000284, "Member 'FAnimNode_TechnicalHandler::RoadSurfaceOctavesPitchLowFreq' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BodyFollowSpeedOfPitch) == 0x000288, "Member 'FAnimNode_TechnicalHandler::BodyFollowSpeedOfPitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BodyFollowAmplitudeMultiplier) == 0x00028C, "Member 'FAnimNode_TechnicalHandler::BodyFollowAmplitudeMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MinTimeToSwitch) == 0x000290, "Member 'FAnimNode_TechnicalHandler::MinTimeToSwitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MaxTimeToSwitch) == 0x000294, "Member 'FAnimNode_TechnicalHandler::MaxTimeToSwitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MinBumpTimeValue) == 0x000298, "Member 'FAnimNode_TechnicalHandler::MinBumpTimeValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MaxBumpTimeValue) == 0x00029C, "Member 'FAnimNode_TechnicalHandler::MaxBumpTimeValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MinAlphaValue) == 0x0002A0, "Member 'FAnimNode_TechnicalHandler::MinAlphaValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MaxAlphaValue) == 0x0002A4, "Member 'FAnimNode_TechnicalHandler::MaxAlphaValue' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MinInterpSpeed) == 0x0002A8, "Member 'FAnimNode_TechnicalHandler::MinInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, MaxInterpSpeed) == 0x0002AC, "Member 'FAnimNode_TechnicalHandler::MaxInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, DefaultRoadBumpiness) == 0x0002B0, "Member 'FAnimNode_TechnicalHandler::DefaultRoadBumpiness' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, RoadBumpinessOverrides) == 0x0002B8, "Member 'FAnimNode_TechnicalHandler::RoadBumpinessOverrides' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, EngineAmplitude) == 0x0002C8, "Member 'FAnimNode_TechnicalHandler::EngineAmplitude' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, BodyCycleFromEngineCycleRatio) == 0x0002CC, "Member 'FAnimNode_TechnicalHandler::BodyCycleFromEngineCycleRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, IdleRPM) == 0x0002D0, "Member 'FAnimNode_TechnicalHandler::IdleRPM' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverWheelAngle) == 0x0002D4, "Member 'FAnimNode_TechnicalHandler::HoverWheelAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverSpinSpeedIdle) == 0x0002D8, "Member 'FAnimNode_TechnicalHandler::HoverSpinSpeedIdle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverSpinSpeedFullTrottle) == 0x0002DC, "Member 'FAnimNode_TechnicalHandler::HoverSpinSpeedFullTrottle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverOffsetZ) == 0x0002E0, "Member 'FAnimNode_TechnicalHandler::HoverOffsetZ' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverFrontWheelAdd) == 0x0002E4, "Member 'FAnimNode_TechnicalHandler::HoverFrontWheelAdd' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverMaxVelocity) == 0x0002E8, "Member 'FAnimNode_TechnicalHandler::HoverMaxVelocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverSuspensionIntensityUp) == 0x0002EC, "Member 'FAnimNode_TechnicalHandler::HoverSuspensionIntensityUp' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverSuspensionIntensityDown) == 0x0002F0, "Member 'FAnimNode_TechnicalHandler::HoverSuspensionIntensityDown' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverBodySin) == 0x0002F8, "Member 'FAnimNode_TechnicalHandler::HoverBodySin' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, SwivelCone) == 0x000308, "Member 'FAnimNode_TechnicalHandler::SwivelCone' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverMaxPitchAngle) == 0x000310, "Member 'FAnimNode_TechnicalHandler::HoverMaxPitchAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverMaxRollAngle) == 0x000314, "Member 'FAnimNode_TechnicalHandler::HoverMaxRollAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverPitchInterpSpeed) == 0x000318, "Member 'FAnimNode_TechnicalHandler::HoverPitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverPitchBoostingInterpSpeed) == 0x00031C, "Member 'FAnimNode_TechnicalHandler::HoverPitchBoostingInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverRollInterpSpeed) == 0x000320, "Member 'FAnimNode_TechnicalHandler::HoverRollInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverWheelRotationIntensity) == 0x000324, "Member 'FAnimNode_TechnicalHandler::HoverWheelRotationIntensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverWheelRotationIntensityY) == 0x000328, "Member 'FAnimNode_TechnicalHandler::HoverWheelRotationIntensityY' has a wrong offset!");
static_assert(offsetof(FAnimNode_TechnicalHandler, HoverBodyTransitionCurve) == 0x000330, "Member 'FAnimNode_TechnicalHandler::HoverBodyTransitionCurve' has a wrong offset!");

// ScriptStruct OakGame.AmputateLimbData
// 0x00C0 (0x00C0 - 0x0000)
struct FAmputateLimbData final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneScale;                                         // 0x0008(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StumpMesh;                                         // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StumpParticles;                                    // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              StumpMaterialOverride;                             // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              StumpDecal;                                        // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StumpDecalSize;                                    // 0x0038(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStumpReceivesDecal;                               // 0x0044(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            StumpSound;                                        // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             StumpTransform;                                    // 0x0050(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                LimbMesh;                                          // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LimbParticles;                                     // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     LimbActorClass;                                    // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              LimbMaterialOverride;                              // 0x0098(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritStumpMaterialParameters;                   // 0x00A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterCopyMethod                  InheritStumpMaterialParametersMethod;              // 0x00A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritLimbMaterialParameters;                    // 0x00A2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterCopyMethod                  InheritLimbMaterialParametersMethod;               // 0x00A3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleLimbToStump;                                 // 0x00A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LimbSocket;                                        // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbScale;                                         // 0x00B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbMassScale;                                     // 0x00B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceMaterialIndex;                               // 0x00B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAmputateLimbData) == 0x000010, "Wrong alignment on FAmputateLimbData");
static_assert(sizeof(FAmputateLimbData) == 0x0000C0, "Wrong size on FAmputateLimbData");
static_assert(offsetof(FAmputateLimbData, BoneName) == 0x000000, "Member 'FAmputateLimbData::BoneName' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, BoneScale) == 0x000008, "Member 'FAmputateLimbData::BoneScale' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpMesh) == 0x000018, "Member 'FAmputateLimbData::StumpMesh' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpParticles) == 0x000020, "Member 'FAmputateLimbData::StumpParticles' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpMaterialOverride) == 0x000028, "Member 'FAmputateLimbData::StumpMaterialOverride' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpDecal) == 0x000030, "Member 'FAmputateLimbData::StumpDecal' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpDecalSize) == 0x000038, "Member 'FAmputateLimbData::StumpDecalSize' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, bStumpReceivesDecal) == 0x000044, "Member 'FAmputateLimbData::bStumpReceivesDecal' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpSound) == 0x000048, "Member 'FAmputateLimbData::StumpSound' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, StumpTransform) == 0x000050, "Member 'FAmputateLimbData::StumpTransform' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbMesh) == 0x000080, "Member 'FAmputateLimbData::LimbMesh' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbParticles) == 0x000088, "Member 'FAmputateLimbData::LimbParticles' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbActorClass) == 0x000090, "Member 'FAmputateLimbData::LimbActorClass' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbMaterialOverride) == 0x000098, "Member 'FAmputateLimbData::LimbMaterialOverride' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, bInheritStumpMaterialParameters) == 0x0000A0, "Member 'FAmputateLimbData::bInheritStumpMaterialParameters' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, InheritStumpMaterialParametersMethod) == 0x0000A1, "Member 'FAmputateLimbData::InheritStumpMaterialParametersMethod' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, bInheritLimbMaterialParameters) == 0x0000A2, "Member 'FAmputateLimbData::bInheritLimbMaterialParameters' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, InheritLimbMaterialParametersMethod) == 0x0000A3, "Member 'FAmputateLimbData::InheritLimbMaterialParametersMethod' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, bScaleLimbToStump) == 0x0000A4, "Member 'FAmputateLimbData::bScaleLimbToStump' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbSocket) == 0x0000A8, "Member 'FAmputateLimbData::LimbSocket' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbScale) == 0x0000B0, "Member 'FAmputateLimbData::LimbScale' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, LimbMassScale) == 0x0000B4, "Member 'FAmputateLimbData::LimbMassScale' has a wrong offset!");
static_assert(offsetof(FAmputateLimbData, SourceMaterialIndex) == 0x0000B8, "Member 'FAmputateLimbData::SourceMaterialIndex' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionPageElementalStarRatings
// 0x000C (0x000C - 0x0000)
struct FGFxItemInspectionPageElementalStarRatings final
{
public:
	float                                         VsFlesh;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VsShield;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VsArmor;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxItemInspectionPageElementalStarRatings) == 0x000004, "Wrong alignment on FGFxItemInspectionPageElementalStarRatings");
static_assert(sizeof(FGFxItemInspectionPageElementalStarRatings) == 0x00000C, "Wrong size on FGFxItemInspectionPageElementalStarRatings");
static_assert(offsetof(FGFxItemInspectionPageElementalStarRatings, VsFlesh) == 0x000000, "Member 'FGFxItemInspectionPageElementalStarRatings::VsFlesh' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPageElementalStarRatings, VsShield) == 0x000004, "Member 'FGFxItemInspectionPageElementalStarRatings::VsShield' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPageElementalStarRatings, VsArmor) == 0x000008, "Member 'FGFxItemInspectionPageElementalStarRatings::VsArmor' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionElementalPage
// 0x0208 (0x0218 - 0x0010)
struct FGFxItemInspectionElementalPage final : public FGFxItemInspectionPageBase
{
public:
	class FText                                   HealthHeaderLabel;                                 // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ShieldHeaderLabel;                                 // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ArmorHeaderLabel;                                  // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class FText>                           ChangeViewLables;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EOakElementalType, struct FGFxItemInspectionPageElementalStarRatings> StarRatingMapping;                                 // 0x0068(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FallbackDamageType;                                // 0x00B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          RootClip;                                          // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x110];                                     // 0x00E8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxHintWidget*                      ChangeViewHintClip;                                // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxDamageType*>                 ElementalTypes;                                    // 0x0200(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CurrentElementalIndex;                             // 0x0210(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemInspectionElementalPage) == 0x000008, "Wrong alignment on FGFxItemInspectionElementalPage");
static_assert(sizeof(FGFxItemInspectionElementalPage) == 0x000218, "Wrong size on FGFxItemInspectionElementalPage");
static_assert(offsetof(FGFxItemInspectionElementalPage, HealthHeaderLabel) == 0x000010, "Member 'FGFxItemInspectionElementalPage::HealthHeaderLabel' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, ShieldHeaderLabel) == 0x000028, "Member 'FGFxItemInspectionElementalPage::ShieldHeaderLabel' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, ArmorHeaderLabel) == 0x000040, "Member 'FGFxItemInspectionElementalPage::ArmorHeaderLabel' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, ChangeViewLables) == 0x000058, "Member 'FGFxItemInspectionElementalPage::ChangeViewLables' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, StarRatingMapping) == 0x000068, "Member 'FGFxItemInspectionElementalPage::StarRatingMapping' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, FallbackDamageType) == 0x0000B8, "Member 'FGFxItemInspectionElementalPage::FallbackDamageType' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, RootClip) == 0x0000E0, "Member 'FGFxItemInspectionElementalPage::RootClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, ChangeViewHintClip) == 0x0001F8, "Member 'FGFxItemInspectionElementalPage::ChangeViewHintClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, ElementalTypes) == 0x000200, "Member 'FGFxItemInspectionElementalPage::ElementalTypes' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionElementalPage, CurrentElementalIndex) == 0x000210, "Member 'FGFxItemInspectionElementalPage::CurrentElementalIndex' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuStatCardStatInfo
// 0x0010 (0x0010 - 0x0000)
struct FOakCARMenuStatCardStatInfo final
{
public:
	class UOakCARVehiclePartStat*                 Stat;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggregatedValue;                                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakCARMenuStatCardStatInfo) == 0x000008, "Wrong alignment on FOakCARMenuStatCardStatInfo");
static_assert(sizeof(FOakCARMenuStatCardStatInfo) == 0x000010, "Wrong size on FOakCARMenuStatCardStatInfo");
static_assert(offsetof(FOakCARMenuStatCardStatInfo, Stat) == 0x000000, "Member 'FOakCARMenuStatCardStatInfo::Stat' has a wrong offset!");
static_assert(offsetof(FOakCARMenuStatCardStatInfo, AggregatedValue) == 0x000008, "Member 'FOakCARMenuStatCardStatInfo::AggregatedValue' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_TrailerHandler
// 0x0760 (0x08A0 - 0x0140)
struct alignas(0x10) FAnimNode_TrailerHandler final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         SuspensionDropMaxSpeed;                            // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x75C];                                    // 0x0144(0x075C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TrailerHandler) == 0x000010, "Wrong alignment on FAnimNode_TrailerHandler");
static_assert(sizeof(FAnimNode_TrailerHandler) == 0x0008A0, "Wrong size on FAnimNode_TrailerHandler");
static_assert(offsetof(FAnimNode_TrailerHandler, SuspensionDropMaxSpeed) == 0x000140, "Member 'FAnimNode_TrailerHandler::SuspensionDropMaxSpeed' has a wrong offset!");

// ScriptStruct OakGame.OakLightBeamInitializationData
// 0x0010 (0x0138 - 0x0128)
struct FOakLightBeamInitializationData final : public FLightBeamInitializationData
{
public:
	float                                         BaseStatusEffectChance;                            // 0x0128(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseStatusEffectDamage;                            // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseStatusEffectDuration;                          // 0x0130(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakLightBeamInitializationData) == 0x000008, "Wrong alignment on FOakLightBeamInitializationData");
static_assert(sizeof(FOakLightBeamInitializationData) == 0x000138, "Wrong size on FOakLightBeamInitializationData");
static_assert(offsetof(FOakLightBeamInitializationData, BaseStatusEffectChance) == 0x000128, "Member 'FOakLightBeamInitializationData::BaseStatusEffectChance' has a wrong offset!");
static_assert(offsetof(FOakLightBeamInitializationData, BaseStatusEffectDamage) == 0x00012C, "Member 'FOakLightBeamInitializationData::BaseStatusEffectDamage' has a wrong offset!");
static_assert(offsetof(FOakLightBeamInitializationData, BaseStatusEffectDuration) == 0x000130, "Member 'FOakLightBeamInitializationData::BaseStatusEffectDuration' has a wrong offset!");

// ScriptStruct OakGame.AnimNode_WeaponVehicleHandler
// 0x1480 (0x15C0 - 0x0140)
struct alignas(0x10) FAnimNode_WeaponVehicleHandler final : public FAnimNode_SkeletalControlBase
{
public:
	bool                                          bUseYawBone;                                       // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePitchBone;                                     // 0x0141(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchMinAngleClamp;                                // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMaxAngleClamp;                                // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProjectileBone;                                // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDualWeapon;                                     // 0x014D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoneReTargeting;                               // 0x014E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F[0x1];                                      // 0x014F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         SourceBone;                                        // 0x0150(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         DestBone;                                          // 0x0168(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x1440];                                   // 0x0180(0x1440)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_WeaponVehicleHandler) == 0x000010, "Wrong alignment on FAnimNode_WeaponVehicleHandler");
static_assert(sizeof(FAnimNode_WeaponVehicleHandler) == 0x0015C0, "Wrong size on FAnimNode_WeaponVehicleHandler");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, bUseYawBone) == 0x000140, "Member 'FAnimNode_WeaponVehicleHandler::bUseYawBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, bUsePitchBone) == 0x000141, "Member 'FAnimNode_WeaponVehicleHandler::bUsePitchBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, PitchMinAngleClamp) == 0x000144, "Member 'FAnimNode_WeaponVehicleHandler::PitchMinAngleClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, PitchMaxAngleClamp) == 0x000148, "Member 'FAnimNode_WeaponVehicleHandler::PitchMaxAngleClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, bUseProjectileBone) == 0x00014C, "Member 'FAnimNode_WeaponVehicleHandler::bUseProjectileBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, bIsDualWeapon) == 0x00014D, "Member 'FAnimNode_WeaponVehicleHandler::bIsDualWeapon' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, bUseBoneReTargeting) == 0x00014E, "Member 'FAnimNode_WeaponVehicleHandler::bUseBoneReTargeting' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, SourceBone) == 0x000150, "Member 'FAnimNode_WeaponVehicleHandler::SourceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeaponVehicleHandler, DestBone) == 0x000168, "Member 'FAnimNode_WeaponVehicleHandler::DestBone' has a wrong offset!");

// ScriptStruct OakGame.BeastmasterPetStencilData
// 0x0014 (0x0014 - 0x0000)
struct FBeastmasterPetStencilData final
{
public:
	struct FLinearColor                           OutlineColor;                                      // 0x0000(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutlineThickness;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeastmasterPetStencilData) == 0x000004, "Wrong alignment on FBeastmasterPetStencilData");
static_assert(sizeof(FBeastmasterPetStencilData) == 0x000014, "Wrong size on FBeastmasterPetStencilData");
static_assert(offsetof(FBeastmasterPetStencilData, OutlineColor) == 0x000000, "Member 'FBeastmasterPetStencilData::OutlineColor' has a wrong offset!");
static_assert(offsetof(FBeastmasterPetStencilData, OutlineThickness) == 0x000010, "Member 'FBeastmasterPetStencilData::OutlineThickness' has a wrong offset!");

// ScriptStruct OakGame.WindVectorField
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FWindVectorField final
{
public:
	struct FIntVector                             VectorFieldSize;                                   // 0x0000(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x000C(0x001C)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWindVectorField) == 0x000008, "Wrong alignment on FWindVectorField");
static_assert(sizeof(FWindVectorField) == 0x000040, "Wrong size on FWindVectorField");
static_assert(offsetof(FWindVectorField, VectorFieldSize) == 0x000000, "Member 'FWindVectorField::VectorFieldSize' has a wrong offset!");
static_assert(offsetof(FWindVectorField, Bounds) == 0x00000C, "Member 'FWindVectorField::Bounds' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionPartStat
// 0x0020 (0x0020 - 0x0000)
struct FGFxItemInspectionPartStat final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	EUIStatComparisonResult                       CompareResult;                                     // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemInspectionPartStat) == 0x000008, "Wrong alignment on FGFxItemInspectionPartStat");
static_assert(sizeof(FGFxItemInspectionPartStat) == 0x000020, "Wrong size on FGFxItemInspectionPartStat");
static_assert(offsetof(FGFxItemInspectionPartStat, Description) == 0x000000, "Member 'FGFxItemInspectionPartStat::Description' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartStat, CompareResult) == 0x000018, "Member 'FGFxItemInspectionPartStat::CompareResult' has a wrong offset!");

// ScriptStruct OakGame.OakActionState_CoordinatedEffect
// 0x0000 (0x01C0 - 0x01C0)
struct FOakActionState_CoordinatedEffect : public FActionState_CoordinatedEffect
{
};
static_assert(alignof(FOakActionState_CoordinatedEffect) == 0x000008, "Wrong alignment on FOakActionState_CoordinatedEffect");
static_assert(sizeof(FOakActionState_CoordinatedEffect) == 0x0001C0, "Wrong size on FOakActionState_CoordinatedEffect");

// ScriptStruct OakGame.OakActionState_CoordinatedEffect_ActionAbility
// 0x0000 (0x01C0 - 0x01C0)
struct FOakActionState_CoordinatedEffect_ActionAbility final : public FOakActionState_CoordinatedEffect
{
};
static_assert(alignof(FOakActionState_CoordinatedEffect_ActionAbility) == 0x000008, "Wrong alignment on FOakActionState_CoordinatedEffect_ActionAbility");
static_assert(sizeof(FOakActionState_CoordinatedEffect_ActionAbility) == 0x0001C0, "Wrong size on FOakActionState_CoordinatedEffect_ActionAbility");

// ScriptStruct OakGame.MissionStarterGear
// 0x0058 (0x0058 - 0x0000)
struct FMissionStarterGear final
{
public:
	class UMissionObjective*                      Objective;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemPoolData>           StarterGearItemPool;                               // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInventoryCategoryData>  InventoryCategory;                                 // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionStarterGear) == 0x000008, "Wrong alignment on FMissionStarterGear");
static_assert(sizeof(FMissionStarterGear) == 0x000058, "Wrong size on FMissionStarterGear");
static_assert(offsetof(FMissionStarterGear, Objective) == 0x000000, "Member 'FMissionStarterGear::Objective' has a wrong offset!");
static_assert(offsetof(FMissionStarterGear, StarterGearItemPool) == 0x000008, "Member 'FMissionStarterGear::StarterGearItemPool' has a wrong offset!");
static_assert(offsetof(FMissionStarterGear, InventoryCategory) == 0x000030, "Member 'FMissionStarterGear::InventoryCategory' has a wrong offset!");

// ScriptStruct OakGame.BeastmasterStandInActionSkillData
// 0x00D8 (0x00D8 - 0x0000)
struct FBeastmasterStandInActionSkillData final
{
public:
	TSoftClassPtr<class UClass>                   ActionSkillClass;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AStandInAuxiliaryActor>     CustomActor;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomActorTranslationOffset;                      // 0x0030(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 CustomCE;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 SkillAnimation;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 PetAnimation;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PetAnimationDelay;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     PetScaleCurve;                                     // 0x0060(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeastmasterStandInActionSkillData) == 0x000008, "Wrong alignment on FBeastmasterStandInActionSkillData");
static_assert(sizeof(FBeastmasterStandInActionSkillData) == 0x0000D8, "Wrong size on FBeastmasterStandInActionSkillData");
static_assert(offsetof(FBeastmasterStandInActionSkillData, ActionSkillClass) == 0x000000, "Member 'FBeastmasterStandInActionSkillData::ActionSkillClass' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, CustomActor) == 0x000028, "Member 'FBeastmasterStandInActionSkillData::CustomActor' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, CustomActorTranslationOffset) == 0x000030, "Member 'FBeastmasterStandInActionSkillData::CustomActorTranslationOffset' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, CustomCE) == 0x000040, "Member 'FBeastmasterStandInActionSkillData::CustomCE' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, SkillAnimation) == 0x000048, "Member 'FBeastmasterStandInActionSkillData::SkillAnimation' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, PetAnimation) == 0x000050, "Member 'FBeastmasterStandInActionSkillData::PetAnimation' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, PetAnimationDelay) == 0x000058, "Member 'FBeastmasterStandInActionSkillData::PetAnimationDelay' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInActionSkillData, PetScaleCurve) == 0x000060, "Member 'FBeastmasterStandInActionSkillData::PetScaleCurve' has a wrong offset!");

// ScriptStruct OakGame.BeastmasterStandInPetData
// 0x0058 (0x0058 - 0x0000)
struct FBeastmasterStandInPetData final
{
public:
	TSoftObjectPtr<class UOakPlayerCharacterAugmentData_Pet> PetAugmentData;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AStandInAuxiliaryActor_Pet> PetBlueprint;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction_CoordinatedEffect> CustomPetSpawnCE;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnrageScale;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x003C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBeastmasterStandInPetData) == 0x000008, "Wrong alignment on FBeastmasterStandInPetData");
static_assert(sizeof(FBeastmasterStandInPetData) == 0x000058, "Wrong size on FBeastmasterStandInPetData");
static_assert(offsetof(FBeastmasterStandInPetData, PetAugmentData) == 0x000000, "Member 'FBeastmasterStandInPetData::PetAugmentData' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInPetData, PetBlueprint) == 0x000028, "Member 'FBeastmasterStandInPetData::PetBlueprint' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInPetData, CustomPetSpawnCE) == 0x000030, "Member 'FBeastmasterStandInPetData::CustomPetSpawnCE' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInPetData, EnrageScale) == 0x000038, "Member 'FBeastmasterStandInPetData::EnrageScale' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInPetData, Translation) == 0x00003C, "Member 'FBeastmasterStandInPetData::Translation' has a wrong offset!");
static_assert(offsetof(FBeastmasterStandInPetData, Rotation) == 0x000048, "Member 'FBeastmasterStandInPetData::Rotation' has a wrong offset!");

// ScriptStruct OakGame.RegionSaveGameData
// 0x0038 (0x0038 - 0x0000)
struct FRegionSaveGameData final
{
public:
	int32                                         GameStage;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayThroughIdx;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class URegionData>             RegionPath;                                        // 0x0008(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        DlcPackageId;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRegionSaveGameData) == 0x000008, "Wrong alignment on FRegionSaveGameData");
static_assert(sizeof(FRegionSaveGameData) == 0x000038, "Wrong size on FRegionSaveGameData");
static_assert(offsetof(FRegionSaveGameData, GameStage) == 0x000000, "Member 'FRegionSaveGameData::GameStage' has a wrong offset!");
static_assert(offsetof(FRegionSaveGameData, PlayThroughIdx) == 0x000004, "Member 'FRegionSaveGameData::PlayThroughIdx' has a wrong offset!");
static_assert(offsetof(FRegionSaveGameData, RegionPath) == 0x000008, "Member 'FRegionSaveGameData::RegionPath' has a wrong offset!");
static_assert(offsetof(FRegionSaveGameData, DlcPackageId) == 0x000030, "Member 'FRegionSaveGameData::DlcPackageId' has a wrong offset!");

// ScriptStruct OakGame.BehindTheScenesItem
// 0x0050 (0x0050 - 0x0000)
struct FBehindTheScenesItem final
{
public:
	class UBehindTheScenesMediaContainer*         Content;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MediaLabelText;                                    // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                ThumbnailTexture;                                  // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBehindTheScenesItemType                      ItemType;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBehindTheScenesItem) == 0x000008, "Wrong alignment on FBehindTheScenesItem");
static_assert(sizeof(FBehindTheScenesItem) == 0x000050, "Wrong size on FBehindTheScenesItem");
static_assert(offsetof(FBehindTheScenesItem, Content) == 0x000000, "Member 'FBehindTheScenesItem::Content' has a wrong offset!");
static_assert(offsetof(FBehindTheScenesItem, MediaLabelText) == 0x000008, "Member 'FBehindTheScenesItem::MediaLabelText' has a wrong offset!");
static_assert(offsetof(FBehindTheScenesItem, ThumbnailTexture) == 0x000020, "Member 'FBehindTheScenesItem::ThumbnailTexture' has a wrong offset!");
static_assert(offsetof(FBehindTheScenesItem, ItemType) == 0x000048, "Member 'FBehindTheScenesItem::ItemType' has a wrong offset!");

// ScriptStruct OakGame.BehindTheScenesCategory
// 0x0028 (0x0028 - 0x0000)
struct FBehindTheScenesCategory final
{
public:
	class FText                                   CategoryName;                                      // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FBehindTheScenesItem>           Items;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBehindTheScenesCategory) == 0x000008, "Wrong alignment on FBehindTheScenesCategory");
static_assert(sizeof(FBehindTheScenesCategory) == 0x000028, "Wrong size on FBehindTheScenesCategory");
static_assert(offsetof(FBehindTheScenesCategory, CategoryName) == 0x000000, "Member 'FBehindTheScenesCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FBehindTheScenesCategory, Items) == 0x000018, "Member 'FBehindTheScenesCategory::Items' has a wrong offset!");

// ScriptStruct OakGame.BlackJackCardDefinition
// 0x0020 (0x0020 - 0x0000)
struct FBlackJackCardDefinition final
{
public:
	class FString                                 DebugString;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardValue;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuitIndex;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardIndex;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlackJackCardDefinition) == 0x000008, "Wrong alignment on FBlackJackCardDefinition");
static_assert(sizeof(FBlackJackCardDefinition) == 0x000020, "Wrong size on FBlackJackCardDefinition");
static_assert(offsetof(FBlackJackCardDefinition, DebugString) == 0x000000, "Member 'FBlackJackCardDefinition::DebugString' has a wrong offset!");
static_assert(offsetof(FBlackJackCardDefinition, CardValue) == 0x000010, "Member 'FBlackJackCardDefinition::CardValue' has a wrong offset!");
static_assert(offsetof(FBlackJackCardDefinition, SuitIndex) == 0x000014, "Member 'FBlackJackCardDefinition::SuitIndex' has a wrong offset!");
static_assert(offsetof(FBlackJackCardDefinition, CardIndex) == 0x000018, "Member 'FBlackJackCardDefinition::CardIndex' has a wrong offset!");

// ScriptStruct OakGame.CameraIntroBlend
// 0x0098 (0x0098 - 0x0000)
struct FCameraIntroBlend final
{
public:
	float                                         TimeBeforeAllowingMovingCamera;                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartBlend;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndBlend;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseACurve;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BlendByCurve;                                      // 0x0010(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DampingLocation;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingRotation;                                   // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraIntroBlend) == 0x000008, "Wrong alignment on FCameraIntroBlend");
static_assert(sizeof(FCameraIntroBlend) == 0x000098, "Wrong size on FCameraIntroBlend");
static_assert(offsetof(FCameraIntroBlend, TimeBeforeAllowingMovingCamera) == 0x000000, "Member 'FCameraIntroBlend::TimeBeforeAllowingMovingCamera' has a wrong offset!");
static_assert(offsetof(FCameraIntroBlend, StartBlend) == 0x000004, "Member 'FCameraIntroBlend::StartBlend' has a wrong offset!");
static_assert(offsetof(FCameraIntroBlend, EndBlend) == 0x000008, "Member 'FCameraIntroBlend::EndBlend' has a wrong offset!");
static_assert(offsetof(FCameraIntroBlend, bUseACurve) == 0x00000C, "Member 'FCameraIntroBlend::bUseACurve' has a wrong offset!");
static_assert(offsetof(FCameraIntroBlend, BlendByCurve) == 0x000010, "Member 'FCameraIntroBlend::BlendByCurve' has a wrong offset!");
static_assert(offsetof(FCameraIntroBlend, DampingLocation) == 0x000088, "Member 'FCameraIntroBlend::DampingLocation' has a wrong offset!");
static_assert(offsetof(FCameraIntroBlend, DampingRotation) == 0x00008C, "Member 'FCameraIntroBlend::DampingRotation' has a wrong offset!");

// ScriptStruct OakGame.ContextMenuContextInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FContextMenuContextInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextMenuContextInfo) == 0x000008, "Wrong alignment on FContextMenuContextInfo");
static_assert(sizeof(FContextMenuContextInfo) == 0x000018, "Wrong size on FContextMenuContextInfo");

// ScriptStruct OakGame.ContextMenu
// 0x0040 (0x0040 - 0x0000)
struct FContextMenu final
{
public:
	class UGbxGFxObject*                          ContainerWrapper;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxGridScrollingList*               MenuList;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FContextMenuContextInfo                ContextInfo;                                       // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextMenu) == 0x000008, "Wrong alignment on FContextMenu");
static_assert(sizeof(FContextMenu) == 0x000040, "Wrong size on FContextMenu");
static_assert(offsetof(FContextMenu, ContainerWrapper) == 0x000000, "Member 'FContextMenu::ContainerWrapper' has a wrong offset!");
static_assert(offsetof(FContextMenu, MenuList) == 0x000018, "Member 'FContextMenu::MenuList' has a wrong offset!");
static_assert(offsetof(FContextMenu, ContextInfo) == 0x000020, "Member 'FContextMenu::ContextInfo' has a wrong offset!");
static_assert(offsetof(FContextMenu, bIsVisible) == 0x000038, "Member 'FContextMenu::bIsVisible' has a wrong offset!");

// ScriptStruct OakGame.CameraPitchOffset
// 0x0014 (0x0014 - 0x0000)
struct FCameraPitchOffset final
{
public:
	float                                         KeyYawAngle;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffset;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardOffset;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingBankingRatio;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CloneSymmetricalKey;                               // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraPitchOffset) == 0x000004, "Wrong alignment on FCameraPitchOffset");
static_assert(sizeof(FCameraPitchOffset) == 0x000014, "Wrong size on FCameraPitchOffset");
static_assert(offsetof(FCameraPitchOffset, KeyYawAngle) == 0x000000, "Member 'FCameraPitchOffset::KeyYawAngle' has a wrong offset!");
static_assert(offsetof(FCameraPitchOffset, ForwardOffset) == 0x000004, "Member 'FCameraPitchOffset::ForwardOffset' has a wrong offset!");
static_assert(offsetof(FCameraPitchOffset, UpwardOffset) == 0x000008, "Member 'FCameraPitchOffset::UpwardOffset' has a wrong offset!");
static_assert(offsetof(FCameraPitchOffset, DampingBankingRatio) == 0x00000C, "Member 'FCameraPitchOffset::DampingBankingRatio' has a wrong offset!");
static_assert(offsetof(FCameraPitchOffset, CloneSymmetricalKey) == 0x000010, "Member 'FCameraPitchOffset::CloneSymmetricalKey' has a wrong offset!");

// ScriptStruct OakGame.RecommendedFriendInviteStatus
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FRecommendedFriendInviteStatus final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecommendedFriendInviteStatus) == 0x000008, "Wrong alignment on FRecommendedFriendInviteStatus");
static_assert(sizeof(FRecommendedFriendInviteStatus) == 0x000020, "Wrong size on FRecommendedFriendInviteStatus");

// ScriptStruct OakGame.OakInventorySortData
// 0x0028 (0x0028 - 0x0000)
struct FOakInventorySortData final
{
public:
	EOakInventoryMenuSortMode                     SortMode;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakInventoryMenuTypePriorityInfo> SortPriorities;                                    // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bDoEquippedTypeFirst;                              // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EquippedItemGrouping;                              // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakInventorySortData) == 0x000008, "Wrong alignment on FOakInventorySortData");
static_assert(sizeof(FOakInventorySortData) == 0x000028, "Wrong size on FOakInventorySortData");
static_assert(offsetof(FOakInventorySortData, SortMode) == 0x000000, "Member 'FOakInventorySortData::SortMode' has a wrong offset!");
static_assert(offsetof(FOakInventorySortData, SortPriorities) == 0x000008, "Member 'FOakInventorySortData::SortPriorities' has a wrong offset!");
static_assert(offsetof(FOakInventorySortData, bDoEquippedTypeFirst) == 0x000018, "Member 'FOakInventorySortData::bDoEquippedTypeFirst' has a wrong offset!");
static_assert(offsetof(FOakInventorySortData, EquippedItemGrouping) == 0x000020, "Member 'FOakInventorySortData::EquippedItemGrouping' has a wrong offset!");

// ScriptStruct OakGame.CameraKeyOffset
// 0x002C (0x002C - 0x0000)
struct FCameraKeyOffset final
{
public:
	bool                                          TeleportFromStart;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtLocationOffset;                              // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalCameraLocationOffset;                         // 0x0010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LocalCameraRotationOffset;                         // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AddedFOV;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraKeyOffset) == 0x000004, "Wrong alignment on FCameraKeyOffset");
static_assert(sizeof(FCameraKeyOffset) == 0x00002C, "Wrong size on FCameraKeyOffset");
static_assert(offsetof(FCameraKeyOffset, TeleportFromStart) == 0x000000, "Member 'FCameraKeyOffset::TeleportFromStart' has a wrong offset!");
static_assert(offsetof(FCameraKeyOffset, LookAtLocationOffset) == 0x000004, "Member 'FCameraKeyOffset::LookAtLocationOffset' has a wrong offset!");
static_assert(offsetof(FCameraKeyOffset, LocalCameraLocationOffset) == 0x000010, "Member 'FCameraKeyOffset::LocalCameraLocationOffset' has a wrong offset!");
static_assert(offsetof(FCameraKeyOffset, LocalCameraRotationOffset) == 0x00001C, "Member 'FCameraKeyOffset::LocalCameraRotationOffset' has a wrong offset!");
static_assert(offsetof(FCameraKeyOffset, AddedFOV) == 0x000028, "Member 'FCameraKeyOffset::AddedFOV' has a wrong offset!");

// ScriptStruct OakGame.SplineTriggers
// 0x0058 (0x0058 - 0x0000)
struct FSplineTriggers final
{
public:
	TSoftObjectPtr<class AOakTriggerBox>          Trigger;                                           // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ACarnivoraTrackBuilder>  Spline;                                            // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReverse;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NextSplineTriggerId;                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineTriggers) == 0x000008, "Wrong alignment on FSplineTriggers");
static_assert(sizeof(FSplineTriggers) == 0x000058, "Wrong size on FSplineTriggers");
static_assert(offsetof(FSplineTriggers, Trigger) == 0x000000, "Member 'FSplineTriggers::Trigger' has a wrong offset!");
static_assert(offsetof(FSplineTriggers, Spline) == 0x000028, "Member 'FSplineTriggers::Spline' has a wrong offset!");
static_assert(offsetof(FSplineTriggers, bIsReverse) == 0x000050, "Member 'FSplineTriggers::bIsReverse' has a wrong offset!");
static_assert(offsetof(FSplineTriggers, NextSplineTriggerId) == 0x000054, "Member 'FSplineTriggers::NextSplineTriggerId' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakPhysicalDeath
// 0x0000 (0x0538 - 0x0538)
struct FActionState_OakPhysicalDeath final : public FActionState_PhysicalDeath
{
};
static_assert(alignof(FActionState_OakPhysicalDeath) == 0x000008, "Wrong alignment on FActionState_OakPhysicalDeath");
static_assert(sizeof(FActionState_OakPhysicalDeath) == 0x000538, "Wrong size on FActionState_OakPhysicalDeath");

// ScriptStruct OakGame.StatusItem
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FStatusItem final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusItem) == 0x000008, "Wrong alignment on FStatusItem");
static_assert(sizeof(FStatusItem) == 0x000058, "Wrong size on FStatusItem");

// ScriptStruct OakGame.WheelState
// 0x000C (0x000C - 0x0000)
struct FWheelState final
{
public:
	float                                         RelativeSpeed;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x8];                                        // 0x0004(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWheelState) == 0x000004, "Wrong alignment on FWheelState");
static_assert(sizeof(FWheelState) == 0x00000C, "Wrong size on FWheelState");
static_assert(offsetof(FWheelState, RelativeSpeed) == 0x000000, "Member 'FWheelState::RelativeSpeed' has a wrong offset!");

// ScriptStruct OakGame.CarnivoraAnimInstanceProxy
// 0x0020 (0x06E0 - 0x06C0)
struct FCarnivoraAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_6C0[0x20];                                     // 0x06C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCarnivoraAnimInstanceProxy) == 0x000010, "Wrong alignment on FCarnivoraAnimInstanceProxy");
static_assert(sizeof(FCarnivoraAnimInstanceProxy) == 0x0006E0, "Wrong size on FCarnivoraAnimInstanceProxy");

// ScriptStruct OakGame.OakPlayerAbilityHUDItemValue
// 0x0008 (0x0008 - 0x0000)
struct FOakPlayerAbilityHUDItemValue final
{
public:
	int32                                         StackCount;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PercentComplete;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPlayerAbilityHUDItemValue) == 0x000004, "Wrong alignment on FOakPlayerAbilityHUDItemValue");
static_assert(sizeof(FOakPlayerAbilityHUDItemValue) == 0x000008, "Wrong size on FOakPlayerAbilityHUDItemValue");
static_assert(offsetof(FOakPlayerAbilityHUDItemValue, StackCount) == 0x000000, "Member 'FOakPlayerAbilityHUDItemValue::StackCount' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityHUDItemValue, PercentComplete) == 0x000004, "Member 'FOakPlayerAbilityHUDItemValue::PercentComplete' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilityHUDItem
// 0x002C (0x0038 - 0x000C)
struct FOakPlayerAbilityHUDItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IOakPlayerAbilityHUDItemValueProviderInterface> Provider;                                          // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UOakPlayerAbilityHUDItemData*           HUDItemData;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOakPlayerAbilityHUDItemValue          Value;                                             // 0x0028(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPlayerAbilityHUDItem) == 0x000008, "Wrong alignment on FOakPlayerAbilityHUDItem");
static_assert(sizeof(FOakPlayerAbilityHUDItem) == 0x000038, "Wrong size on FOakPlayerAbilityHUDItem");
static_assert(offsetof(FOakPlayerAbilityHUDItem, Provider) == 0x000010, "Member 'FOakPlayerAbilityHUDItem::Provider' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityHUDItem, HUDItemData) == 0x000020, "Member 'FOakPlayerAbilityHUDItem::HUDItemData' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityHUDItem, Value) == 0x000028, "Member 'FOakPlayerAbilityHUDItem::Value' has a wrong offset!");

// ScriptStruct OakGame.ChallengeFilterType
// 0x0028 (0x0028 - 0x0000)
struct FChallengeFilterType final
{
public:
	class FText                                   FilterName;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<class UChallengeCategoryData*>         IncludedCategories;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeFilterType) == 0x000008, "Wrong alignment on FChallengeFilterType");
static_assert(sizeof(FChallengeFilterType) == 0x000028, "Wrong size on FChallengeFilterType");
static_assert(offsetof(FChallengeFilterType, FilterName) == 0x000000, "Member 'FChallengeFilterType::FilterName' has a wrong offset!");
static_assert(offsetof(FChallengeFilterType, IncludedCategories) == 0x000018, "Member 'FChallengeFilterType::IncludedCategories' has a wrong offset!");

// ScriptStruct OakGame.CharacterGroundSlamGradeData
// 0x0028 (0x0028 - 0x0000)
struct FCharacterGroundSlamGradeData final
{
public:
	float                                         MinimumHeight;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 StartAction;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingDistance;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 LandingAction;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterGroundSlamGradeData) == 0x000008, "Wrong alignment on FCharacterGroundSlamGradeData");
static_assert(sizeof(FCharacterGroundSlamGradeData) == 0x000028, "Wrong size on FCharacterGroundSlamGradeData");
static_assert(offsetof(FCharacterGroundSlamGradeData, MinimumHeight) == 0x000000, "Member 'FCharacterGroundSlamGradeData::MinimumHeight' has a wrong offset!");
static_assert(offsetof(FCharacterGroundSlamGradeData, ControlledMove) == 0x000008, "Member 'FCharacterGroundSlamGradeData::ControlledMove' has a wrong offset!");
static_assert(offsetof(FCharacterGroundSlamGradeData, StartAction) == 0x000010, "Member 'FCharacterGroundSlamGradeData::StartAction' has a wrong offset!");
static_assert(offsetof(FCharacterGroundSlamGradeData, LandingDistance) == 0x000018, "Member 'FCharacterGroundSlamGradeData::LandingDistance' has a wrong offset!");
static_assert(offsetof(FCharacterGroundSlamGradeData, LandingAction) == 0x000020, "Member 'FCharacterGroundSlamGradeData::LandingAction' has a wrong offset!");

// ScriptStruct OakGame.CharacterItemPoolExpansionInfo
// 0x0020 (0x0020 - 0x0000)
struct FCharacterItemPoolExpansionInfo final
{
public:
	TArray<struct FItemPoolInfo>                  DropOnDeathItemPools;                              // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UItemPoolExpansionData>> ItemPoolExpansions;                                // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCharacterItemPoolExpansionInfo) == 0x000008, "Wrong alignment on FCharacterItemPoolExpansionInfo");
static_assert(sizeof(FCharacterItemPoolExpansionInfo) == 0x000020, "Wrong size on FCharacterItemPoolExpansionInfo");
static_assert(offsetof(FCharacterItemPoolExpansionInfo, DropOnDeathItemPools) == 0x000000, "Member 'FCharacterItemPoolExpansionInfo::DropOnDeathItemPools' has a wrong offset!");
static_assert(offsetof(FCharacterItemPoolExpansionInfo, ItemPoolExpansions) == 0x000010, "Member 'FCharacterItemPoolExpansionInfo::ItemPoolExpansions' has a wrong offset!");

// ScriptStruct OakGame.ElementalSlideEffect
// 0x0150 (0x0150 - 0x0000)
struct FElementalSlideEffect final
{
public:
	struct FImpactResponseEffect                  DefaultResponse;                                   // 0x0000(0x0140)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FImpactResponseInfo>            ImpactResponses;                                   // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElementalSlideEffect) == 0x000010, "Wrong alignment on FElementalSlideEffect");
static_assert(sizeof(FElementalSlideEffect) == 0x000150, "Wrong size on FElementalSlideEffect");
static_assert(offsetof(FElementalSlideEffect, DefaultResponse) == 0x000000, "Member 'FElementalSlideEffect::DefaultResponse' has a wrong offset!");
static_assert(offsetof(FElementalSlideEffect, ImpactResponses) == 0x000140, "Member 'FElementalSlideEffect::ImpactResponses' has a wrong offset!");

// ScriptStruct OakGame.GRMLNHardPointDamageData
// 0x0018 (0x0018 - 0x0000)
struct FGRMLNHardPointDamageData final
{
public:
	TSubclassOf<class UGbxDamageType>             DamageTypeClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            WeaponFireEvent;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MuzzleFlash;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGRMLNHardPointDamageData) == 0x000008, "Wrong alignment on FGRMLNHardPointDamageData");
static_assert(sizeof(FGRMLNHardPointDamageData) == 0x000018, "Wrong size on FGRMLNHardPointDamageData");
static_assert(offsetof(FGRMLNHardPointDamageData, DamageTypeClass) == 0x000000, "Member 'FGRMLNHardPointDamageData::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(FGRMLNHardPointDamageData, WeaponFireEvent) == 0x000008, "Member 'FGRMLNHardPointDamageData::WeaponFireEvent' has a wrong offset!");
static_assert(offsetof(FGRMLNHardPointDamageData, MuzzleFlash) == 0x000010, "Member 'FGRMLNHardPointDamageData::MuzzleFlash' has a wrong offset!");

// ScriptStruct OakGame.GRMLNHardpointData
// 0x0168 (0x0168 - 0x0000)
struct FGRMLNHardpointData final
{
public:
	EGRMLNHardpointType                           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsModUnlockedHardpoint;                           // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGRMLNModType                                 ModUnlock;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           FireRate;                                          // 0x0008(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAttributeInitializationData           Ammunition;                                        // 0x0040(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAttributeInitializationData           BurstRefireRate;                                   // 0x0078(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAttributeInitializationData           Damage;                                            // 0x00B0(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UOakLightProjectileData>    LightProjectileDataClass;                          // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGRMLNHardPointDamageData              NormalDamageData;                                  // 0x00F0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGRMLNHardPointDamageData              CryoDamageData;                                    // 0x0108(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           WeaponFireSockets;                                 // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         RandomRangeMin;                                    // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RandomRangeMax;                                    // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOakDroneProjectile_GRMLN*              Owner;                                             // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x28];                                     // 0x0140(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGRMLNHardpointData) == 0x000008, "Wrong alignment on FGRMLNHardpointData");
static_assert(sizeof(FGRMLNHardpointData) == 0x000168, "Wrong size on FGRMLNHardpointData");
static_assert(offsetof(FGRMLNHardpointData, Type) == 0x000000, "Member 'FGRMLNHardpointData::Type' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, bIsModUnlockedHardpoint) == 0x000001, "Member 'FGRMLNHardpointData::bIsModUnlockedHardpoint' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, ModUnlock) == 0x000002, "Member 'FGRMLNHardpointData::ModUnlock' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, FireRate) == 0x000008, "Member 'FGRMLNHardpointData::FireRate' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, Ammunition) == 0x000040, "Member 'FGRMLNHardpointData::Ammunition' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, BurstRefireRate) == 0x000078, "Member 'FGRMLNHardpointData::BurstRefireRate' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, Damage) == 0x0000B0, "Member 'FGRMLNHardpointData::Damage' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, LightProjectileDataClass) == 0x0000E8, "Member 'FGRMLNHardpointData::LightProjectileDataClass' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, NormalDamageData) == 0x0000F0, "Member 'FGRMLNHardpointData::NormalDamageData' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, CryoDamageData) == 0x000108, "Member 'FGRMLNHardpointData::CryoDamageData' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, WeaponFireSockets) == 0x000120, "Member 'FGRMLNHardpointData::WeaponFireSockets' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, RandomRangeMin) == 0x000130, "Member 'FGRMLNHardpointData::RandomRangeMin' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, RandomRangeMax) == 0x000134, "Member 'FGRMLNHardpointData::RandomRangeMax' has a wrong offset!");
static_assert(offsetof(FGRMLNHardpointData, Owner) == 0x000138, "Member 'FGRMLNHardpointData::Owner' has a wrong offset!");

// ScriptStruct OakGame.LastCollisionDamageInfo
// 0x0018 (0x0018 - 0x0000)
struct FLastCollisionDamageInfo final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerIsCollider;                                  // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativeVelocity;                                  // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLastCollisionDamageInfo) == 0x000008, "Wrong alignment on FLastCollisionDamageInfo");
static_assert(sizeof(FLastCollisionDamageInfo) == 0x000018, "Wrong size on FLastCollisionDamageInfo");
static_assert(offsetof(FLastCollisionDamageInfo, HitActor) == 0x000000, "Member 'FLastCollisionDamageInfo::HitActor' has a wrong offset!");
static_assert(offsetof(FLastCollisionDamageInfo, bOwnerIsCollider) == 0x000008, "Member 'FLastCollisionDamageInfo::bOwnerIsCollider' has a wrong offset!");
static_assert(offsetof(FLastCollisionDamageInfo, RelativeVelocity) == 0x00000C, "Member 'FLastCollisionDamageInfo::RelativeVelocity' has a wrong offset!");

// ScriptStruct OakGame.GFxMinimapWidgetIcon
// 0x00D0 (0x00D0 - 0x0000)
struct FGFxMinimapWidgetIcon final
{
public:
	struct FZoneMapPOIEntry                       ZoneMapPOIData;                                    // 0x0000(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIsAreaWaypoint;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampRadarEdge;                                   // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxClampDistance;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeVisibleIfInRange;                         // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IconLocation;                                      // 0x006C(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStaticIconLocation;                               // 0x0078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        WaypointRadius;                                    // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  TargetGuid;                                        // 0x0088(0x0010)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 TargetMinimapIconComponent;                        // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          IconInstance;                                      // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCachedVisible;                                    // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxMinimapWidgetIconTrackedType              TrackedType;                                       // 0x00A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AreaWaypointIconSize;                              // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTransitionTime;                             // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TransitionStartingLocation;                        // 0x00B4(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconFrameName;                                     // 0x00C0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMinimapWidgetIcon) == 0x000010, "Wrong alignment on FGFxMinimapWidgetIcon");
static_assert(sizeof(FGFxMinimapWidgetIcon) == 0x0000D0, "Wrong size on FGFxMinimapWidgetIcon");
static_assert(offsetof(FGFxMinimapWidgetIcon, ZoneMapPOIData) == 0x000000, "Member 'FGFxMinimapWidgetIcon::ZoneMapPOIData' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, bIsAreaWaypoint) == 0x000060, "Member 'FGFxMinimapWidgetIcon::bIsAreaWaypoint' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, bClampRadarEdge) == 0x000061, "Member 'FGFxMinimapWidgetIcon::bClampRadarEdge' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, MaxClampDistance) == 0x000064, "Member 'FGFxMinimapWidgetIcon::MaxClampDistance' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, bShouldBeVisibleIfInRange) == 0x000068, "Member 'FGFxMinimapWidgetIcon::bShouldBeVisibleIfInRange' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, IconLocation) == 0x00006C, "Member 'FGFxMinimapWidgetIcon::IconLocation' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, bStaticIconLocation) == 0x000078, "Member 'FGFxMinimapWidgetIcon::bStaticIconLocation' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, WaypointRadius) == 0x00007C, "Member 'FGFxMinimapWidgetIcon::WaypointRadius' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, TargetActor) == 0x000080, "Member 'FGFxMinimapWidgetIcon::TargetActor' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, TargetGuid) == 0x000088, "Member 'FGFxMinimapWidgetIcon::TargetGuid' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, TargetMinimapIconComponent) == 0x000098, "Member 'FGFxMinimapWidgetIcon::TargetMinimapIconComponent' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, IconInstance) == 0x0000A0, "Member 'FGFxMinimapWidgetIcon::IconInstance' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, bCachedVisible) == 0x0000A8, "Member 'FGFxMinimapWidgetIcon::bCachedVisible' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, TrackedType) == 0x0000A9, "Member 'FGFxMinimapWidgetIcon::TrackedType' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, AreaWaypointIconSize) == 0x0000AC, "Member 'FGFxMinimapWidgetIcon::AreaWaypointIconSize' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, CurrentTransitionTime) == 0x0000B0, "Member 'FGFxMinimapWidgetIcon::CurrentTransitionTime' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, TransitionStartingLocation) == 0x0000B4, "Member 'FGFxMinimapWidgetIcon::TransitionStartingLocation' has a wrong offset!");
static_assert(offsetof(FGFxMinimapWidgetIcon, IconFrameName) == 0x0000C0, "Member 'FGFxMinimapWidgetIcon::IconFrameName' has a wrong offset!");

// ScriptStruct OakGame.TextElementCondition
// 0x0020 (0x0020 - 0x0000)
struct FTextElementCondition final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TextToAdd;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextElementCondition) == 0x000008, "Wrong alignment on FTextElementCondition");
static_assert(sizeof(FTextElementCondition) == 0x000020, "Wrong size on FTextElementCondition");
static_assert(offsetof(FTextElementCondition, Condition) == 0x000000, "Member 'FTextElementCondition::Condition' has a wrong offset!");
static_assert(offsetof(FTextElementCondition, TextToAdd) == 0x000008, "Member 'FTextElementCondition::TextToAdd' has a wrong offset!");

// ScriptStruct OakGame.CorpseRecord
// 0x0010 (0x0010 - 0x0000)
struct FCorpseRecord final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CorpseStartTime;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCorpseRecord) == 0x000008, "Wrong alignment on FCorpseRecord");
static_assert(sizeof(FCorpseRecord) == 0x000010, "Wrong size on FCorpseRecord");
static_assert(offsetof(FCorpseRecord, Actor) == 0x000000, "Member 'FCorpseRecord::Actor' has a wrong offset!");
static_assert(offsetof(FCorpseRecord, CorpseStartTime) == 0x000008, "Member 'FCorpseRecord::CorpseStartTime' has a wrong offset!");

// ScriptStruct OakGame.CosmeticDamageEventDetails
// 0x0038 (0x0038 - 0x0000)
struct FCosmeticDamageEventDetails final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosmeticDamageEventDetails) == 0x000008, "Wrong alignment on FCosmeticDamageEventDetails");
static_assert(sizeof(FCosmeticDamageEventDetails) == 0x000038, "Wrong size on FCosmeticDamageEventDetails");
static_assert(offsetof(FCosmeticDamageEventDetails, Damage) == 0x000000, "Member 'FCosmeticDamageEventDetails::Damage' has a wrong offset!");
static_assert(offsetof(FCosmeticDamageEventDetails, HitLocation) == 0x000004, "Member 'FCosmeticDamageEventDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FCosmeticDamageEventDetails, HitDirection) == 0x000010, "Member 'FCosmeticDamageEventDetails::HitDirection' has a wrong offset!");
static_assert(offsetof(FCosmeticDamageEventDetails, Instigator) == 0x000020, "Member 'FCosmeticDamageEventDetails::Instigator' has a wrong offset!");
static_assert(offsetof(FCosmeticDamageEventDetails, DamageType) == 0x000028, "Member 'FCosmeticDamageEventDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FCosmeticDamageEventDetails, DamageSource) == 0x000030, "Member 'FCosmeticDamageEventDetails::DamageSource' has a wrong offset!");

// ScriptStruct OakGame.PlayerItemDisplayInfo
// 0x0018 (0x0018 - 0x0000)
struct FPlayerItemDisplayInfo final
{
public:
	class AOakPlayerController*                   AssociatedPlayer;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AssociatedItem;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AssociatedDisplayItem;                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerItemDisplayInfo) == 0x000008, "Wrong alignment on FPlayerItemDisplayInfo");
static_assert(sizeof(FPlayerItemDisplayInfo) == 0x000018, "Wrong size on FPlayerItemDisplayInfo");
static_assert(offsetof(FPlayerItemDisplayInfo, AssociatedPlayer) == 0x000000, "Member 'FPlayerItemDisplayInfo::AssociatedPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerItemDisplayInfo, AssociatedItem) == 0x000008, "Member 'FPlayerItemDisplayInfo::AssociatedItem' has a wrong offset!");
static_assert(offsetof(FPlayerItemDisplayInfo, AssociatedDisplayItem) == 0x000010, "Member 'FPlayerItemDisplayInfo::AssociatedDisplayItem' has a wrong offset!");

// ScriptStruct OakGame.OakChallengeStatSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FOakChallengeStatSaveGameData final
{
public:
	int32                                         CurrentStatValue;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGameStatData>           ChallengeStatPath;                                 // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakChallengeStatSaveGameData) == 0x000008, "Wrong alignment on FOakChallengeStatSaveGameData");
static_assert(sizeof(FOakChallengeStatSaveGameData) == 0x000030, "Wrong size on FOakChallengeStatSaveGameData");
static_assert(offsetof(FOakChallengeStatSaveGameData, CurrentStatValue) == 0x000000, "Member 'FOakChallengeStatSaveGameData::CurrentStatValue' has a wrong offset!");
static_assert(offsetof(FOakChallengeStatSaveGameData, ChallengeStatPath) == 0x000008, "Member 'FOakChallengeStatSaveGameData::ChallengeStatPath' has a wrong offset!");

// ScriptStruct OakGame.CachedPlanetZonePOI
// 0x0030 (0x0030 - 0x0000)
struct FCachedPlanetZonePOI final
{
public:
	class UZoneMapData*                           ZoneReference;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ZoneMeshOnPlanet;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedPlanetZonePOI) == 0x000008, "Wrong alignment on FCachedPlanetZonePOI");
static_assert(sizeof(FCachedPlanetZonePOI) == 0x000030, "Wrong size on FCachedPlanetZonePOI");
static_assert(offsetof(FCachedPlanetZonePOI, ZoneReference) == 0x000000, "Member 'FCachedPlanetZonePOI::ZoneReference' has a wrong offset!");
static_assert(offsetof(FCachedPlanetZonePOI, ZoneMeshOnPlanet) == 0x000008, "Member 'FCachedPlanetZonePOI::ZoneMeshOnPlanet' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersDecorationItemSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FCrewQuartersDecorationItemSaveGameData final
{
public:
	bool                                          IsNew;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCrewQuartersDecorationItemData> DecorationItemAssetPath;                           // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCrewQuartersDecorationItemSaveGameData) == 0x000008, "Wrong alignment on FCrewQuartersDecorationItemSaveGameData");
static_assert(sizeof(FCrewQuartersDecorationItemSaveGameData) == 0x000030, "Wrong size on FCrewQuartersDecorationItemSaveGameData");
static_assert(offsetof(FCrewQuartersDecorationItemSaveGameData, IsNew) == 0x000000, "Member 'FCrewQuartersDecorationItemSaveGameData::IsNew' has a wrong offset!");
static_assert(offsetof(FCrewQuartersDecorationItemSaveGameData, DecorationItemAssetPath) == 0x000008, "Member 'FCrewQuartersDecorationItemSaveGameData::DecorationItemAssetPath' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersRoomAssignment
// 0x0010 (0x0010 - 0x0000)
struct FCrewQuartersRoomAssignment final
{
public:
	class UPlayerClassIdentifier*                 AssociatedPlayerClass;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicRoomBaseData*                   AssociatedRoom;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrewQuartersRoomAssignment) == 0x000008, "Wrong alignment on FCrewQuartersRoomAssignment");
static_assert(sizeof(FCrewQuartersRoomAssignment) == 0x000010, "Wrong size on FCrewQuartersRoomAssignment");
static_assert(offsetof(FCrewQuartersRoomAssignment, AssociatedPlayerClass) == 0x000000, "Member 'FCrewQuartersRoomAssignment::AssociatedPlayerClass' has a wrong offset!");
static_assert(offsetof(FCrewQuartersRoomAssignment, AssociatedRoom) == 0x000008, "Member 'FCrewQuartersRoomAssignment::AssociatedRoom' has a wrong offset!");

// ScriptStruct OakGame.DevMapToMapId
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDevMapToMapId final
{
public:
	class FName                                   DevMapName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MapID;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDevMapToMapId) == 0x000008, "Wrong alignment on FDevMapToMapId");
static_assert(sizeof(FDevMapToMapId) == 0x000010, "Wrong size on FDevMapToMapId");
static_assert(offsetof(FDevMapToMapId, DevMapName) == 0x000000, "Member 'FDevMapToMapId::DevMapName' has a wrong offset!");
static_assert(offsetof(FDevMapToMapId, MapID) == 0x000008, "Member 'FDevMapToMapId::MapID' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersGunRackItemSaveData
// 0x0088 (0x0088 - 0x0000)
struct FCrewQuartersGunRackItemSaveData final
{
public:
	TArray<uint8>                                 EncryptedSerialNumber;                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FInventoryBalanceStateInitializationData DevelopmentSaveData;                               // 0x0010(0x0068)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FString                                 SlotAssetPath;                                     // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCrewQuartersGunRackItemSaveData) == 0x000008, "Wrong alignment on FCrewQuartersGunRackItemSaveData");
static_assert(sizeof(FCrewQuartersGunRackItemSaveData) == 0x000088, "Wrong size on FCrewQuartersGunRackItemSaveData");
static_assert(offsetof(FCrewQuartersGunRackItemSaveData, EncryptedSerialNumber) == 0x000000, "Member 'FCrewQuartersGunRackItemSaveData::EncryptedSerialNumber' has a wrong offset!");
static_assert(offsetof(FCrewQuartersGunRackItemSaveData, DevelopmentSaveData) == 0x000010, "Member 'FCrewQuartersGunRackItemSaveData::DevelopmentSaveData' has a wrong offset!");
static_assert(offsetof(FCrewQuartersGunRackItemSaveData, SlotAssetPath) == 0x000078, "Member 'FCrewQuartersGunRackItemSaveData::SlotAssetPath' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersGunRackSaveData
// 0x0010 (0x0010 - 0x0000)
struct FCrewQuartersGunRackSaveData final
{
public:
	TArray<struct FCrewQuartersGunRackItemSaveData> RackSaveData;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrewQuartersGunRackSaveData) == 0x000008, "Wrong alignment on FCrewQuartersGunRackSaveData");
static_assert(sizeof(FCrewQuartersGunRackSaveData) == 0x000010, "Wrong size on FCrewQuartersGunRackSaveData");
static_assert(offsetof(FCrewQuartersGunRackSaveData, RackSaveData) == 0x000000, "Member 'FCrewQuartersGunRackSaveData::RackSaveData' has a wrong offset!");

// ScriptStruct OakGame.BaseQuickChangeMenuStateData
// 0x0068 (0x0068 - 0x0000)
struct FBaseQuickChangeMenuStateData final
{
public:
	class FText                                   MenuStateName;                                     // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MenuStateDescription;                              // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ContentFrameName;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFrameName;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StandInConfig;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceProjectionFXOn;                              // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBaseQuickChangeMenuState                     MenuState;                                         // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCustomizationTypeData*              CustomizationType;                                 // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseQuickChangeMenuStateData) == 0x000008, "Wrong alignment on FBaseQuickChangeMenuStateData");
static_assert(sizeof(FBaseQuickChangeMenuStateData) == 0x000068, "Wrong size on FBaseQuickChangeMenuStateData");
static_assert(offsetof(FBaseQuickChangeMenuStateData, MenuStateName) == 0x000000, "Member 'FBaseQuickChangeMenuStateData::MenuStateName' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, MenuStateDescription) == 0x000018, "Member 'FBaseQuickChangeMenuStateData::MenuStateDescription' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, ContentFrameName) == 0x000030, "Member 'FBaseQuickChangeMenuStateData::ContentFrameName' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, IconFrameName) == 0x000040, "Member 'FBaseQuickChangeMenuStateData::IconFrameName' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, StandInConfig) == 0x000050, "Member 'FBaseQuickChangeMenuStateData::StandInConfig' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, bForceProjectionFXOn) == 0x000058, "Member 'FBaseQuickChangeMenuStateData::bForceProjectionFXOn' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, MenuState) == 0x000059, "Member 'FBaseQuickChangeMenuStateData::MenuState' has a wrong offset!");
static_assert(offsetof(FBaseQuickChangeMenuStateData, CustomizationType) == 0x000060, "Member 'FBaseQuickChangeMenuStateData::CustomizationType' has a wrong offset!");

// ScriptStruct OakGame.LootAudioStinger
// 0x0010 (0x0010 - 0x0000)
struct FLootAudioStinger final
{
public:
	TWeakObjectPtr<class AActor>                  SoundActor;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            Sound;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootAudioStinger) == 0x000008, "Wrong alignment on FLootAudioStinger");
static_assert(sizeof(FLootAudioStinger) == 0x000010, "Wrong size on FLootAudioStinger");
static_assert(offsetof(FLootAudioStinger, SoundActor) == 0x000000, "Member 'FLootAudioStinger::SoundActor' has a wrong offset!");
static_assert(offsetof(FLootAudioStinger, Sound) == 0x000008, "Member 'FLootAudioStinger::Sound' has a wrong offset!");

// ScriptStruct OakGame.MapCharacterPhysicsSettings
// 0x0004 (0x0004 - 0x0000)
struct FMapCharacterPhysicsSettings final
{
public:
	float                                         PlayerAirControlScale;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapCharacterPhysicsSettings) == 0x000004, "Wrong alignment on FMapCharacterPhysicsSettings");
static_assert(sizeof(FMapCharacterPhysicsSettings) == 0x000004, "Wrong size on FMapCharacterPhysicsSettings");
static_assert(offsetof(FMapCharacterPhysicsSettings, PlayerAirControlScale) == 0x000000, "Member 'FMapCharacterPhysicsSettings::PlayerAirControlScale' has a wrong offset!");

// ScriptStruct OakGame.CrewQuartersRoomItemSaveGameData
// 0x0018 (0x0018 - 0x0000)
struct FCrewQuartersRoomItemSaveGameData final
{
public:
	bool                                          IsNew;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RoomItemAssetPath;                                 // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCrewQuartersRoomItemSaveGameData) == 0x000008, "Wrong alignment on FCrewQuartersRoomItemSaveGameData");
static_assert(sizeof(FCrewQuartersRoomItemSaveGameData) == 0x000018, "Wrong size on FCrewQuartersRoomItemSaveGameData");
static_assert(offsetof(FCrewQuartersRoomItemSaveGameData, IsNew) == 0x000000, "Member 'FCrewQuartersRoomItemSaveGameData::IsNew' has a wrong offset!");
static_assert(offsetof(FCrewQuartersRoomItemSaveGameData, RoomItemAssetPath) == 0x000008, "Member 'FCrewQuartersRoomItemSaveGameData::RoomItemAssetPath' has a wrong offset!");

// ScriptStruct OakGame.OakProfileLastInventoryFilterInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOakProfileLastInventoryFilterInfo final
{
public:
	class FName                                   SlotTypeId;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastFilterIndex;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakProfileLastInventoryFilterInfo) == 0x000008, "Wrong alignment on FOakProfileLastInventoryFilterInfo");
static_assert(sizeof(FOakProfileLastInventoryFilterInfo) == 0x000010, "Wrong size on FOakProfileLastInventoryFilterInfo");
static_assert(offsetof(FOakProfileLastInventoryFilterInfo, SlotTypeId) == 0x000000, "Member 'FOakProfileLastInventoryFilterInfo::SlotTypeId' has a wrong offset!");
static_assert(offsetof(FOakProfileLastInventoryFilterInfo, LastFilterIndex) == 0x000008, "Member 'FOakProfileLastInventoryFilterInfo::LastFilterIndex' has a wrong offset!");

// ScriptStruct OakGame.IncomingDamagePresentationData
// 0x00E0 (0x00E0 - 0x0000)
struct FIncomingDamagePresentationData final
{
public:
	struct FAttributeInitializationData           DamageThreshold;                                   // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamageScore;                                       // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamageScoreThreshold;                              // 0x0070(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UFeedbackData*                          FeedbackData;                                      // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            HealthAudioEvent;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            ShieldAudioEvent;                                  // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            ArmorAudioEvent;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityParticleParamValue;                  // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAnimationFlinchStrength;                       // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRadialBlur;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurSelection                   RadialBlur;                                        // 0x00D4(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIncomingDamagePresentationData) == 0x000008, "Wrong alignment on FIncomingDamagePresentationData");
static_assert(sizeof(FIncomingDamagePresentationData) == 0x0000E0, "Wrong size on FIncomingDamagePresentationData");
static_assert(offsetof(FIncomingDamagePresentationData, DamageThreshold) == 0x000000, "Member 'FIncomingDamagePresentationData::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, DamageScore) == 0x000038, "Member 'FIncomingDamagePresentationData::DamageScore' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, DamageScoreThreshold) == 0x000070, "Member 'FIncomingDamagePresentationData::DamageScoreThreshold' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, FeedbackData) == 0x0000A8, "Member 'FIncomingDamagePresentationData::FeedbackData' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, HealthAudioEvent) == 0x0000B0, "Member 'FIncomingDamagePresentationData::HealthAudioEvent' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, ShieldAudioEvent) == 0x0000B8, "Member 'FIncomingDamagePresentationData::ShieldAudioEvent' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, ArmorAudioEvent) == 0x0000C0, "Member 'FIncomingDamagePresentationData::ArmorAudioEvent' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, DamageSeverityParticleParamValue) == 0x0000C8, "Member 'FIncomingDamagePresentationData::DamageSeverityParticleParamValue' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, ArmsAnimationFlinchStrength) == 0x0000CC, "Member 'FIncomingDamagePresentationData::ArmsAnimationFlinchStrength' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, bUseRadialBlur) == 0x0000D0, "Member 'FIncomingDamagePresentationData::bUseRadialBlur' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationData, RadialBlur) == 0x0000D4, "Member 'FIncomingDamagePresentationData::RadialBlur' has a wrong offset!");

// ScriptStruct OakGame.IncomingDamagePresentationGroup
// 0x0380 (0x0380 - 0x0000)
struct FIncomingDamagePresentationGroup final
{
public:
	struct FIncomingDamagePresentationData        PresentationLevels[0x4];                           // 0x0000(0x00E0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIncomingDamagePresentationGroup) == 0x000008, "Wrong alignment on FIncomingDamagePresentationGroup");
static_assert(sizeof(FIncomingDamagePresentationGroup) == 0x000380, "Wrong size on FIncomingDamagePresentationGroup");
static_assert(offsetof(FIncomingDamagePresentationGroup, PresentationLevels) == 0x000000, "Member 'FIncomingDamagePresentationGroup::PresentationLevels' has a wrong offset!");

// ScriptStruct OakGame.IncomingDamagePresentationSource
// 0x0390 (0x0390 - 0x0000)
struct FIncomingDamagePresentationSource final
{
public:
	TArray<TSubclassOf<class UDamageSource>>      DamageSources;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FIncomingDamagePresentationGroup       PresentationGroup;                                 // 0x0010(0x0380)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIncomingDamagePresentationSource) == 0x000008, "Wrong alignment on FIncomingDamagePresentationSource");
static_assert(sizeof(FIncomingDamagePresentationSource) == 0x000390, "Wrong size on FIncomingDamagePresentationSource");
static_assert(offsetof(FIncomingDamagePresentationSource, DamageSources) == 0x000000, "Member 'FIncomingDamagePresentationSource::DamageSources' has a wrong offset!");
static_assert(offsetof(FIncomingDamagePresentationSource, PresentationGroup) == 0x000010, "Member 'FIncomingDamagePresentationSource::PresentationGroup' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentConfiguration
// 0x0018 (0x0018 - 0x0000)
struct FOakActionAbilityAugmentConfiguration final
{
public:
	class UOakActionAbilityAugmentData*           AugmentData;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakActionAbilityAugmentConfigurationSetting> Settings;                                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentConfiguration) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentConfiguration");
static_assert(sizeof(FOakActionAbilityAugmentConfiguration) == 0x000018, "Wrong size on FOakActionAbilityAugmentConfiguration");
static_assert(offsetof(FOakActionAbilityAugmentConfiguration, AugmentData) == 0x000000, "Member 'FOakActionAbilityAugmentConfiguration::AugmentData' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentConfiguration, Settings) == 0x000008, "Member 'FOakActionAbilityAugmentConfiguration::Settings' has a wrong offset!");

// ScriptStruct OakGame.MissionLogEchoDeviceSettings
// 0x0040 (0x0040 - 0x0000)
struct FMissionLogEchoDeviceSettings final
{
public:
	EStandInActorType                             StandInType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   StandInActorClass;                                 // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StandInConfigName;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EchoDeviceIdleScreenName;                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionLogEchoDeviceSettings) == 0x000008, "Wrong alignment on FMissionLogEchoDeviceSettings");
static_assert(sizeof(FMissionLogEchoDeviceSettings) == 0x000040, "Wrong size on FMissionLogEchoDeviceSettings");
static_assert(offsetof(FMissionLogEchoDeviceSettings, StandInType) == 0x000000, "Member 'FMissionLogEchoDeviceSettings::StandInType' has a wrong offset!");
static_assert(offsetof(FMissionLogEchoDeviceSettings, StandInActorClass) == 0x000008, "Member 'FMissionLogEchoDeviceSettings::StandInActorClass' has a wrong offset!");
static_assert(offsetof(FMissionLogEchoDeviceSettings, StandInConfigName) == 0x000030, "Member 'FMissionLogEchoDeviceSettings::StandInConfigName' has a wrong offset!");
static_assert(offsetof(FMissionLogEchoDeviceSettings, EchoDeviceIdleScreenName) == 0x000038, "Member 'FMissionLogEchoDeviceSettings::EchoDeviceIdleScreenName' has a wrong offset!");

// ScriptStruct OakGame.GFxVaultHunterProfileCardStatConfig
// 0x0018 (0x0018 - 0x0000)
struct FGFxVaultHunterProfileCardStatConfig final
{
public:
	TArray<struct FStatConfigInfo>                StatsInfo;                                         // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint32                                        TimePlayedHours;                                   // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TimePlayedMinutes;                                 // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxVaultHunterProfileCardStatConfig) == 0x000008, "Wrong alignment on FGFxVaultHunterProfileCardStatConfig");
static_assert(sizeof(FGFxVaultHunterProfileCardStatConfig) == 0x000018, "Wrong size on FGFxVaultHunterProfileCardStatConfig");
static_assert(offsetof(FGFxVaultHunterProfileCardStatConfig, StatsInfo) == 0x000000, "Member 'FGFxVaultHunterProfileCardStatConfig::StatsInfo' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardStatConfig, TimePlayedHours) == 0x000010, "Member 'FGFxVaultHunterProfileCardStatConfig::TimePlayedHours' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardStatConfig, TimePlayedMinutes) == 0x000014, "Member 'FGFxVaultHunterProfileCardStatConfig::TimePlayedMinutes' has a wrong offset!");

// ScriptStruct OakGame.DebugMenuCommandItemData
// 0x0048 (0x0048 - 0x0000)
struct FDebugMenuCommandItemData final
{
public:
	class FName                                   Category;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 ExecCommand;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugMenuCommandItemData) == 0x000008, "Wrong alignment on FDebugMenuCommandItemData");
static_assert(sizeof(FDebugMenuCommandItemData) == 0x000048, "Wrong size on FDebugMenuCommandItemData");
static_assert(offsetof(FDebugMenuCommandItemData, Category) == 0x000000, "Member 'FDebugMenuCommandItemData::Category' has a wrong offset!");
static_assert(offsetof(FDebugMenuCommandItemData, Label) == 0x000008, "Member 'FDebugMenuCommandItemData::Label' has a wrong offset!");
static_assert(offsetof(FDebugMenuCommandItemData, Description) == 0x000020, "Member 'FDebugMenuCommandItemData::Description' has a wrong offset!");
static_assert(offsetof(FDebugMenuCommandItemData, ExecCommand) == 0x000038, "Member 'FDebugMenuCommandItemData::ExecCommand' has a wrong offset!");

// ScriptStruct OakGame.DebugMenuGradebox
// 0x0028 (0x0028 - 0x0000)
struct FDebugMenuGradebox final
{
public:
	class UCanvasPanel*                           Panel;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image;                                             // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Description;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTextBlock*>                     Atts;                                              // 0x0018(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugMenuGradebox) == 0x000008, "Wrong alignment on FDebugMenuGradebox");
static_assert(sizeof(FDebugMenuGradebox) == 0x000028, "Wrong size on FDebugMenuGradebox");
static_assert(offsetof(FDebugMenuGradebox, Panel) == 0x000000, "Member 'FDebugMenuGradebox::Panel' has a wrong offset!");
static_assert(offsetof(FDebugMenuGradebox, Image) == 0x000008, "Member 'FDebugMenuGradebox::Image' has a wrong offset!");
static_assert(offsetof(FDebugMenuGradebox, Description) == 0x000010, "Member 'FDebugMenuGradebox::Description' has a wrong offset!");
static_assert(offsetof(FDebugMenuGradebox, Atts) == 0x000018, "Member 'FDebugMenuGradebox::Atts' has a wrong offset!");

// ScriptStruct OakGame.PlayerEchoLogStatus
// 0x0010 (0x0010 - 0x0000)
struct FPlayerEchoLogStatus final
{
public:
	class UEchoLogData*                           EchoLogData;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerEchoLogStatus) == 0x000008, "Wrong alignment on FPlayerEchoLogStatus");
static_assert(sizeof(FPlayerEchoLogStatus) == 0x000010, "Wrong size on FPlayerEchoLogStatus");
static_assert(offsetof(FPlayerEchoLogStatus, EchoLogData) == 0x000000, "Member 'FPlayerEchoLogStatus::EchoLogData' has a wrong offset!");

// ScriptStruct OakGame.GbxReportTag
// 0x0030 (0x0030 - 0x0000)
struct FGbxReportTag final
{
public:
	bool                                          bShowInMenu;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxReportTag) == 0x000008, "Wrong alignment on FGbxReportTag");
static_assert(sizeof(FGbxReportTag) == 0x000030, "Wrong size on FGbxReportTag");
static_assert(offsetof(FGbxReportTag, bShowInMenu) == 0x000000, "Member 'FGbxReportTag::bShowInMenu' has a wrong offset!");
static_assert(offsetof(FGbxReportTag, Tag) == 0x000008, "Member 'FGbxReportTag::Tag' has a wrong offset!");
static_assert(offsetof(FGbxReportTag, Description) == 0x000018, "Member 'FGbxReportTag::Description' has a wrong offset!");

// ScriptStruct OakGame.DlcLevelTravelPair
// 0x0010 (0x0010 - 0x0000)
struct FDlcLevelTravelPair final
{
public:
	class UTravelStationData*                     NonDlcStationData;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTravelStationData*                     DlcStationData;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDlcLevelTravelPair) == 0x000008, "Wrong alignment on FDlcLevelTravelPair");
static_assert(sizeof(FDlcLevelTravelPair) == 0x000010, "Wrong size on FDlcLevelTravelPair");
static_assert(offsetof(FDlcLevelTravelPair, NonDlcStationData) == 0x000000, "Member 'FDlcLevelTravelPair::NonDlcStationData' has a wrong offset!");
static_assert(offsetof(FDlcLevelTravelPair, DlcStationData) == 0x000008, "Member 'FDlcLevelTravelPair::DlcStationData' has a wrong offset!");

// ScriptStruct OakGame.PlayerDuelArenaState
// 0x0010 (0x0010 - 0x0000)
struct FPlayerDuelArenaState final
{
public:
	class AOakCharacter_Player*                   Player;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDuelArenaState) == 0x000008, "Wrong alignment on FPlayerDuelArenaState");
static_assert(sizeof(FPlayerDuelArenaState) == 0x000010, "Wrong size on FPlayerDuelArenaState");
static_assert(offsetof(FPlayerDuelArenaState, Player) == 0x000000, "Member 'FPlayerDuelArenaState::Player' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuLoadoutCustomizer
// 0x0310 (0x0310 - 0x0000)
struct FOakCARMenuLoadoutCustomizer final
{
public:
	struct FOakCARMenuVehicleConfig               CurrentConfig;                                     // 0x0000(0x0188)(Transient, NativeAccessSpecifierPrivate)
	struct FOakCARMenuVehicleConfig               PreviewConfig;                                     // 0x0188(0x0188)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakCARMenuLoadoutCustomizer) == 0x000008, "Wrong alignment on FOakCARMenuLoadoutCustomizer");
static_assert(sizeof(FOakCARMenuLoadoutCustomizer) == 0x000310, "Wrong size on FOakCARMenuLoadoutCustomizer");
static_assert(offsetof(FOakCARMenuLoadoutCustomizer, CurrentConfig) == 0x000000, "Member 'FOakCARMenuLoadoutCustomizer::CurrentConfig' has a wrong offset!");
static_assert(offsetof(FOakCARMenuLoadoutCustomizer, PreviewConfig) == 0x000188, "Member 'FOakCARMenuLoadoutCustomizer::PreviewConfig' has a wrong offset!");

// ScriptStruct OakGame.DuelingNumParticipantsInfo
// 0x000C (0x000C - 0x0000)
struct FDuelingNumParticipantsInfo final
{
public:
	int32                                         NumPlayers;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxArenaSize;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DuelLength;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDuelingNumParticipantsInfo) == 0x000004, "Wrong alignment on FDuelingNumParticipantsInfo");
static_assert(sizeof(FDuelingNumParticipantsInfo) == 0x00000C, "Wrong size on FDuelingNumParticipantsInfo");
static_assert(offsetof(FDuelingNumParticipantsInfo, NumPlayers) == 0x000000, "Member 'FDuelingNumParticipantsInfo::NumPlayers' has a wrong offset!");
static_assert(offsetof(FDuelingNumParticipantsInfo, MaxArenaSize) == 0x000004, "Member 'FDuelingNumParticipantsInfo::MaxArenaSize' has a wrong offset!");
static_assert(offsetof(FDuelingNumParticipantsInfo, DuelLength) == 0x000008, "Member 'FDuelingNumParticipantsInfo::DuelLength' has a wrong offset!");

// ScriptStruct OakGame.DuelModeSettings
// 0x0030 (0x0030 - 0x0000)
struct FDuelModeSettings final
{
public:
	float                                         DuelArenaTimeout;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DuelChallengeTimeout;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDuelStartDelay;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DuelStartDelay;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDuelingNumParticipantsInfo>    NumParticipantsInfo;                               // 0x0010(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DuelTotemSpawnTraceVertOffset;                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DuelTotemSpawnInFrontDistance;                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DuelTotemSpawnFindGroundDistance;                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDuelModeSettings) == 0x000008, "Wrong alignment on FDuelModeSettings");
static_assert(sizeof(FDuelModeSettings) == 0x000030, "Wrong size on FDuelModeSettings");
static_assert(offsetof(FDuelModeSettings, DuelArenaTimeout) == 0x000000, "Member 'FDuelModeSettings::DuelArenaTimeout' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, DuelChallengeTimeout) == 0x000004, "Member 'FDuelModeSettings::DuelChallengeTimeout' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, bUseDuelStartDelay) == 0x000008, "Member 'FDuelModeSettings::bUseDuelStartDelay' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, DuelStartDelay) == 0x00000C, "Member 'FDuelModeSettings::DuelStartDelay' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, NumParticipantsInfo) == 0x000010, "Member 'FDuelModeSettings::NumParticipantsInfo' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, DuelTotemSpawnTraceVertOffset) == 0x000020, "Member 'FDuelModeSettings::DuelTotemSpawnTraceVertOffset' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, DuelTotemSpawnInFrontDistance) == 0x000024, "Member 'FDuelModeSettings::DuelTotemSpawnInFrontDistance' has a wrong offset!");
static_assert(offsetof(FDuelModeSettings, DuelTotemSpawnFindGroundDistance) == 0x000028, "Member 'FDuelModeSettings::DuelTotemSpawnFindGroundDistance' has a wrong offset!");

// ScriptStruct OakGame.GFxStatusMenuNavBarInfo
// 0x0018 (0x0018 - 0x0000)
struct FGFxStatusMenuNavBarInfo final
{
public:
	class FString                                 IconFrameName;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MenuID;                                            // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxStatusMenuNavBarInfo) == 0x000008, "Wrong alignment on FGFxStatusMenuNavBarInfo");
static_assert(sizeof(FGFxStatusMenuNavBarInfo) == 0x000018, "Wrong size on FGFxStatusMenuNavBarInfo");
static_assert(offsetof(FGFxStatusMenuNavBarInfo, IconFrameName) == 0x000000, "Member 'FGFxStatusMenuNavBarInfo::IconFrameName' has a wrong offset!");
static_assert(offsetof(FGFxStatusMenuNavBarInfo, MenuID) == 0x000010, "Member 'FGFxStatusMenuNavBarInfo::MenuID' has a wrong offset!");

// ScriptStruct OakGame.DuelTeamGroup
// 0x0010 (0x0010 - 0x0000)
struct FDuelTeamGroup final
{
public:
	TArray<class UTeam*>                          PlayerIndexToTeam;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDuelTeamGroup) == 0x000008, "Wrong alignment on FDuelTeamGroup");
static_assert(sizeof(FDuelTeamGroup) == 0x000010, "Wrong size on FDuelTeamGroup");
static_assert(offsetof(FDuelTeamGroup, PlayerIndexToTeam) == 0x000000, "Member 'FDuelTeamGroup::PlayerIndexToTeam' has a wrong offset!");

// ScriptStruct OakGame.PlayerActiveDuelState
// 0x0020 (0x0020 - 0x0000)
struct FPlayerActiveDuelState final
{
public:
	class AOakCharacter_Player*                   PlayerCharacter;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMainPlayer;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeam*                                  DuelTeam;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerDueling_SavedInfo               SavedInfo;                                         // 0x0018(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerActiveDuelState) == 0x000008, "Wrong alignment on FPlayerActiveDuelState");
static_assert(sizeof(FPlayerActiveDuelState) == 0x000020, "Wrong size on FPlayerActiveDuelState");
static_assert(offsetof(FPlayerActiveDuelState, PlayerCharacter) == 0x000000, "Member 'FPlayerActiveDuelState::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FPlayerActiveDuelState, bIsMainPlayer) == 0x000008, "Member 'FPlayerActiveDuelState::bIsMainPlayer' has a wrong offset!");
static_assert(offsetof(FPlayerActiveDuelState, DuelTeam) == 0x000010, "Member 'FPlayerActiveDuelState::DuelTeam' has a wrong offset!");
static_assert(offsetof(FPlayerActiveDuelState, SavedInfo) == 0x000018, "Member 'FPlayerActiveDuelState::SavedInfo' has a wrong offset!");

// ScriptStruct OakGame.TeamActiveDuelState
// 0x0018 (0x0018 - 0x0000)
struct FTeamActiveDuelState final
{
public:
	class UTeam*                                  DuelTeam;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerActiveDuelState>         Players;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamActiveDuelState) == 0x000008, "Wrong alignment on FTeamActiveDuelState");
static_assert(sizeof(FTeamActiveDuelState) == 0x000018, "Wrong size on FTeamActiveDuelState");
static_assert(offsetof(FTeamActiveDuelState, DuelTeam) == 0x000000, "Member 'FTeamActiveDuelState::DuelTeam' has a wrong offset!");
static_assert(offsetof(FTeamActiveDuelState, Players) == 0x000008, "Member 'FTeamActiveDuelState::Players' has a wrong offset!");

// ScriptStruct OakGame.ActiveDuelState
// 0x0050 (0x0050 - 0x0000)
struct FActiveDuelState final
{
public:
	TArray<struct FTeamActiveDuelState>           ParticipatingTeams;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class ADuelArena*                             DuelArena;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADuelTotem*                             DuelTotem;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOakCharacter_Player*                   DuelInstigator;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeam*                                  WinningTeam;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDuelLoserState>                DuelLosers;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class APlayerTradeManager*                    TradeManager;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveIndex;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDuelClassification                           Classification;                                    // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveDuelState) == 0x000008, "Wrong alignment on FActiveDuelState");
static_assert(sizeof(FActiveDuelState) == 0x000050, "Wrong size on FActiveDuelState");
static_assert(offsetof(FActiveDuelState, ParticipatingTeams) == 0x000000, "Member 'FActiveDuelState::ParticipatingTeams' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, DuelArena) == 0x000010, "Member 'FActiveDuelState::DuelArena' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, DuelTotem) == 0x000018, "Member 'FActiveDuelState::DuelTotem' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, DuelInstigator) == 0x000020, "Member 'FActiveDuelState::DuelInstigator' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, WinningTeam) == 0x000028, "Member 'FActiveDuelState::WinningTeam' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, DuelLosers) == 0x000030, "Member 'FActiveDuelState::DuelLosers' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, TradeManager) == 0x000040, "Member 'FActiveDuelState::TradeManager' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, ActiveIndex) == 0x000048, "Member 'FActiveDuelState::ActiveIndex' has a wrong offset!");
static_assert(offsetof(FActiveDuelState, Classification) == 0x00004C, "Member 'FActiveDuelState::Classification' has a wrong offset!");

// ScriptStruct OakGame.ManagedActorOwnerEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FManagedActorOwnerEntry final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FManagedActorOwnerEntry) == 0x000008, "Wrong alignment on FManagedActorOwnerEntry");
static_assert(sizeof(FManagedActorOwnerEntry) == 0x000018, "Wrong size on FManagedActorOwnerEntry");

// ScriptStruct OakGame.GoreSelectionResults
// 0x0090 (0x0090 - 0x0000)
struct FGoreSelectionResults final
{
public:
	class FName                                   StumpSocket;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StumpBoneScale;                                    // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StumpDecalSize;                                    // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StumpMesh;                                         // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StumpParticles;                                    // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              StumpMaterialOverride;                             // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              StumpDecal;                                        // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StumpSound;                                        // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStumpReceivesDecal;                               // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritStumpMaterialParameters;                   // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterCopyMethod                  InheritStumpMaterialParametersMethod;              // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritLimbMaterialParameters;                    // 0x004B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterCopyMethod                  InheritLimbMaterialParametersMethod;               // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LimbSocket;                                        // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                LimbMesh;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LimbParticles;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     LimbActorClass;                                    // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              LimbMaterialOverride;                              // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbForce;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleLimbToStump;                                 // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimbScale;                                         // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbMassScale;                                     // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceMaterialIndex;                               // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGoreSelectionResults) == 0x000008, "Wrong alignment on FGoreSelectionResults");
static_assert(sizeof(FGoreSelectionResults) == 0x000090, "Wrong size on FGoreSelectionResults");
static_assert(offsetof(FGoreSelectionResults, StumpSocket) == 0x000000, "Member 'FGoreSelectionResults::StumpSocket' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpBoneScale) == 0x000008, "Member 'FGoreSelectionResults::StumpBoneScale' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpDecalSize) == 0x000014, "Member 'FGoreSelectionResults::StumpDecalSize' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpMesh) == 0x000020, "Member 'FGoreSelectionResults::StumpMesh' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpParticles) == 0x000028, "Member 'FGoreSelectionResults::StumpParticles' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpMaterialOverride) == 0x000030, "Member 'FGoreSelectionResults::StumpMaterialOverride' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpDecal) == 0x000038, "Member 'FGoreSelectionResults::StumpDecal' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, StumpSound) == 0x000040, "Member 'FGoreSelectionResults::StumpSound' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, bStumpReceivesDecal) == 0x000048, "Member 'FGoreSelectionResults::bStumpReceivesDecal' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, bInheritStumpMaterialParameters) == 0x000049, "Member 'FGoreSelectionResults::bInheritStumpMaterialParameters' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, InheritStumpMaterialParametersMethod) == 0x00004A, "Member 'FGoreSelectionResults::InheritStumpMaterialParametersMethod' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, bInheritLimbMaterialParameters) == 0x00004B, "Member 'FGoreSelectionResults::bInheritLimbMaterialParameters' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, InheritLimbMaterialParametersMethod) == 0x00004C, "Member 'FGoreSelectionResults::InheritLimbMaterialParametersMethod' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbSocket) == 0x000050, "Member 'FGoreSelectionResults::LimbSocket' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbMesh) == 0x000058, "Member 'FGoreSelectionResults::LimbMesh' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbParticles) == 0x000060, "Member 'FGoreSelectionResults::LimbParticles' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbActorClass) == 0x000068, "Member 'FGoreSelectionResults::LimbActorClass' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbMaterialOverride) == 0x000070, "Member 'FGoreSelectionResults::LimbMaterialOverride' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbForce) == 0x000078, "Member 'FGoreSelectionResults::LimbForce' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, bScaleLimbToStump) == 0x00007C, "Member 'FGoreSelectionResults::bScaleLimbToStump' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbScale) == 0x000080, "Member 'FGoreSelectionResults::LimbScale' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, LimbMassScale) == 0x000084, "Member 'FGoreSelectionResults::LimbMassScale' has a wrong offset!");
static_assert(offsetof(FGoreSelectionResults, SourceMaterialIndex) == 0x000088, "Member 'FGoreSelectionResults::SourceMaterialIndex' has a wrong offset!");

// ScriptStruct OakGame.OakOnlineLobbyInfo
// 0x0030 (0x0030 - 0x0000)
struct FOakOnlineLobbyInfo final
{
public:
	ENetworkType                                  NetworkType;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInviteType                                   InviteType;                                        // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CurrentActivity;                                   // 0x0008(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	EOakOnlineLobbyConnectivityState              ConnectivityState;                                 // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentConnectedPlayerCount;                       // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConnectedPlayerCount;                           // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakOnlineLobbyInfo) == 0x000008, "Wrong alignment on FOakOnlineLobbyInfo");
static_assert(sizeof(FOakOnlineLobbyInfo) == 0x000030, "Wrong size on FOakOnlineLobbyInfo");
static_assert(offsetof(FOakOnlineLobbyInfo, NetworkType) == 0x000000, "Member 'FOakOnlineLobbyInfo::NetworkType' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyInfo, InviteType) == 0x000001, "Member 'FOakOnlineLobbyInfo::InviteType' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyInfo, CurrentActivity) == 0x000008, "Member 'FOakOnlineLobbyInfo::CurrentActivity' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyInfo, ConnectivityState) == 0x000020, "Member 'FOakOnlineLobbyInfo::ConnectivityState' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyInfo, CurrentConnectedPlayerCount) == 0x000024, "Member 'FOakOnlineLobbyInfo::CurrentConnectedPlayerCount' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyInfo, MaxConnectedPlayerCount) == 0x000028, "Member 'FOakOnlineLobbyInfo::MaxConnectedPlayerCount' has a wrong offset!");

// ScriptStruct OakGame.GFxVendingMenuConfig
// 0x0070 (0x0070 - 0x0000)
struct FGFxVendingMenuConfig final
{
public:
	class UInventoryCategoryData*                 GoldenKeyResourceData;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 ErediumResourceData;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInventoryCategoryData*>         InventoryCategoriesAllowed;                        // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuFilter>        PageFilters;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuItemGrouping>  ItemGroupingsByType;                               // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuItemGrouping>  ItemGroupingsByManufacturer;                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuTypePriorityInfo> ItemTypeSortPriorities;                            // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakBackpackCapacityThreshold>  BackpackThresholds;                                // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxVendingMenuConfig) == 0x000008, "Wrong alignment on FGFxVendingMenuConfig");
static_assert(sizeof(FGFxVendingMenuConfig) == 0x000070, "Wrong size on FGFxVendingMenuConfig");
static_assert(offsetof(FGFxVendingMenuConfig, GoldenKeyResourceData) == 0x000000, "Member 'FGFxVendingMenuConfig::GoldenKeyResourceData' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, ErediumResourceData) == 0x000008, "Member 'FGFxVendingMenuConfig::ErediumResourceData' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, InventoryCategoriesAllowed) == 0x000010, "Member 'FGFxVendingMenuConfig::InventoryCategoriesAllowed' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, PageFilters) == 0x000020, "Member 'FGFxVendingMenuConfig::PageFilters' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, ItemGroupingsByType) == 0x000030, "Member 'FGFxVendingMenuConfig::ItemGroupingsByType' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, ItemGroupingsByManufacturer) == 0x000040, "Member 'FGFxVendingMenuConfig::ItemGroupingsByManufacturer' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, ItemTypeSortPriorities) == 0x000050, "Member 'FGFxVendingMenuConfig::ItemTypeSortPriorities' has a wrong offset!");
static_assert(offsetof(FGFxVendingMenuConfig, BackpackThresholds) == 0x000060, "Member 'FGFxVendingMenuConfig::BackpackThresholds' has a wrong offset!");

// ScriptStruct OakGame.PlayerCountAndPlaythroughDefinedValueRow
// 0x01C0 (0x01C8 - 0x0008)
struct FPlayerCountAndPlaythroughDefinedValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           OnePlayer_PT1;                                     // 0x0008(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           TwoPlayers_PT1;                                    // 0x0040(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           ThreePlayers_PT1;                                  // 0x0078(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           FourPlayers_PT1;                                   // 0x00B0(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           OnePlayer_PT2;                                     // 0x00E8(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           TwoPlayers_PT2;                                    // 0x0120(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           ThreePlayers_PT2;                                  // 0x0158(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           FourPlayers_PT2;                                   // 0x0190(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayerCountAndPlaythroughDefinedValueRow) == 0x000008, "Wrong alignment on FPlayerCountAndPlaythroughDefinedValueRow");
static_assert(sizeof(FPlayerCountAndPlaythroughDefinedValueRow) == 0x0001C8, "Wrong size on FPlayerCountAndPlaythroughDefinedValueRow");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, OnePlayer_PT1) == 0x000008, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::OnePlayer_PT1' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, TwoPlayers_PT1) == 0x000040, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::TwoPlayers_PT1' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, ThreePlayers_PT1) == 0x000078, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::ThreePlayers_PT1' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, FourPlayers_PT1) == 0x0000B0, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::FourPlayers_PT1' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, OnePlayer_PT2) == 0x0000E8, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::OnePlayer_PT2' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, TwoPlayers_PT2) == 0x000120, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::TwoPlayers_PT2' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, ThreePlayers_PT2) == 0x000158, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::ThreePlayers_PT2' has a wrong offset!");
static_assert(offsetof(FPlayerCountAndPlaythroughDefinedValueRow, FourPlayers_PT2) == 0x000190, "Member 'FPlayerCountAndPlaythroughDefinedValueRow::FourPlayers_PT2' has a wrong offset!");

// ScriptStruct OakGame.EquippedInventorySaveGameData
// 0x0058 (0x0058 - 0x0000)
struct FEquippedInventorySaveGameData final
{
public:
	int32                                         InventoryListIndex;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UInventorySlotData>      SlotDataPath;                                      // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UWeaponTrinketPartData>  TrinketDataPath;                                   // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FEquippedInventorySaveGameData) == 0x000008, "Wrong alignment on FEquippedInventorySaveGameData");
static_assert(sizeof(FEquippedInventorySaveGameData) == 0x000058, "Wrong size on FEquippedInventorySaveGameData");
static_assert(offsetof(FEquippedInventorySaveGameData, InventoryListIndex) == 0x000000, "Member 'FEquippedInventorySaveGameData::InventoryListIndex' has a wrong offset!");
static_assert(offsetof(FEquippedInventorySaveGameData, Enabled) == 0x000004, "Member 'FEquippedInventorySaveGameData::Enabled' has a wrong offset!");
static_assert(offsetof(FEquippedInventorySaveGameData, SlotDataPath) == 0x000008, "Member 'FEquippedInventorySaveGameData::SlotDataPath' has a wrong offset!");
static_assert(offsetof(FEquippedInventorySaveGameData, TrinketDataPath) == 0x000030, "Member 'FEquippedInventorySaveGameData::TrinketDataPath' has a wrong offset!");

// ScriptStruct OakGame.EchoDeviceScreenData
// 0x0020 (0x0028 - 0x0008)
struct FEchoDeviceScreenData final : public FTableRowBase
{
public:
	class UMaterialInstance*                      MaterialInstance;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            Sound;                                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextScreenName;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEchoDeviceScreenData) == 0x000008, "Wrong alignment on FEchoDeviceScreenData");
static_assert(sizeof(FEchoDeviceScreenData) == 0x000028, "Wrong size on FEchoDeviceScreenData");
static_assert(offsetof(FEchoDeviceScreenData, MaterialInstance) == 0x000008, "Member 'FEchoDeviceScreenData::MaterialInstance' has a wrong offset!");
static_assert(offsetof(FEchoDeviceScreenData, Rate) == 0x000010, "Member 'FEchoDeviceScreenData::Rate' has a wrong offset!");
static_assert(offsetof(FEchoDeviceScreenData, Sound) == 0x000018, "Member 'FEchoDeviceScreenData::Sound' has a wrong offset!");
static_assert(offsetof(FEchoDeviceScreenData, NextScreenName) == 0x000020, "Member 'FEchoDeviceScreenData::NextScreenName' has a wrong offset!");

// ScriptStruct OakGame.VehicleConfigurationRtpc
// 0x0020 (0x0020 - 0x0000)
struct FVehicleConfigurationRtpc final
{
public:
	class UWwiseRtpc*                             RtpcParam;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultValue;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAttributeData*                      ValueAttribute;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdateEveryFrame;                                 // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleConfigurationRtpc) == 0x000008, "Wrong alignment on FVehicleConfigurationRtpc");
static_assert(sizeof(FVehicleConfigurationRtpc) == 0x000020, "Wrong size on FVehicleConfigurationRtpc");
static_assert(offsetof(FVehicleConfigurationRtpc, RtpcParam) == 0x000000, "Member 'FVehicleConfigurationRtpc::RtpcParam' has a wrong offset!");
static_assert(offsetof(FVehicleConfigurationRtpc, DefaultValue) == 0x000008, "Member 'FVehicleConfigurationRtpc::DefaultValue' has a wrong offset!");
static_assert(offsetof(FVehicleConfigurationRtpc, ValueAttribute) == 0x000010, "Member 'FVehicleConfigurationRtpc::ValueAttribute' has a wrong offset!");
static_assert(offsetof(FVehicleConfigurationRtpc, bUpdateEveryFrame) == 0x000018, "Member 'FVehicleConfigurationRtpc::bUpdateEveryFrame' has a wrong offset!");

// ScriptStruct OakGame.MusicSection
// 0x0058 (0x0058 - 0x0000)
struct FMusicSection final
{
public:
	float                                         CombatMin;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatMax;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EOakMusicPart, struct FMusicPart>        AssociatedMusicParts;                              // 0x0008(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicSection) == 0x000008, "Wrong alignment on FMusicSection");
static_assert(sizeof(FMusicSection) == 0x000058, "Wrong size on FMusicSection");
static_assert(offsetof(FMusicSection, CombatMin) == 0x000000, "Member 'FMusicSection::CombatMin' has a wrong offset!");
static_assert(offsetof(FMusicSection, CombatMax) == 0x000004, "Member 'FMusicSection::CombatMax' has a wrong offset!");
static_assert(offsetof(FMusicSection, AssociatedMusicParts) == 0x000008, "Member 'FMusicSection::AssociatedMusicParts' has a wrong offset!");

// ScriptStruct OakGame.PlayerEchoDeviceOrientationData
// 0x0058 (0x0060 - 0x0008)
struct FPlayerEchoDeviceOrientationData final : public FTableRowBase
{
public:
	bool                                          bHideEchoInFirstPerson;                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalSplitscreenHideEchoInFirstPerson;         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuadSplitscreenHideEchoInFirstPerson;             // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenPosition;                                    // 0x000C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SplitScreenScreenPosition;                         // 0x0014(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VerticalSplitScreenScreenPosition;                 // 0x001C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              QuadSplitScreenScreenPosition;                     // 0x0024(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x002C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SplitScreenRotationOffset;                         // 0x0038(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               VerticalSplitScreenRotationOffset;                 // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               QuadSplitScreenRotationOffset;                     // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerEchoDeviceOrientationData) == 0x000008, "Wrong alignment on FPlayerEchoDeviceOrientationData");
static_assert(sizeof(FPlayerEchoDeviceOrientationData) == 0x000060, "Wrong size on FPlayerEchoDeviceOrientationData");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, bHideEchoInFirstPerson) == 0x000008, "Member 'FPlayerEchoDeviceOrientationData::bHideEchoInFirstPerson' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, bVerticalSplitscreenHideEchoInFirstPerson) == 0x000009, "Member 'FPlayerEchoDeviceOrientationData::bVerticalSplitscreenHideEchoInFirstPerson' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, bQuadSplitscreenHideEchoInFirstPerson) == 0x00000A, "Member 'FPlayerEchoDeviceOrientationData::bQuadSplitscreenHideEchoInFirstPerson' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, ScreenPosition) == 0x00000C, "Member 'FPlayerEchoDeviceOrientationData::ScreenPosition' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, SplitScreenScreenPosition) == 0x000014, "Member 'FPlayerEchoDeviceOrientationData::SplitScreenScreenPosition' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, VerticalSplitScreenScreenPosition) == 0x00001C, "Member 'FPlayerEchoDeviceOrientationData::VerticalSplitScreenScreenPosition' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, QuadSplitScreenScreenPosition) == 0x000024, "Member 'FPlayerEchoDeviceOrientationData::QuadSplitScreenScreenPosition' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, RotationOffset) == 0x00002C, "Member 'FPlayerEchoDeviceOrientationData::RotationOffset' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, SplitScreenRotationOffset) == 0x000038, "Member 'FPlayerEchoDeviceOrientationData::SplitScreenRotationOffset' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, VerticalSplitScreenRotationOffset) == 0x000044, "Member 'FPlayerEchoDeviceOrientationData::VerticalSplitScreenRotationOffset' has a wrong offset!");
static_assert(offsetof(FPlayerEchoDeviceOrientationData, QuadSplitScreenRotationOffset) == 0x000050, "Member 'FPlayerEchoDeviceOrientationData::QuadSplitScreenRotationOffset' has a wrong offset!");

// ScriptStruct OakGame.VendingTabOrder
// 0x0018 (0x0018 - 0x0000)
struct FVendingTabOrder final
{
public:
	EGFxVendingMachineDisplayMode                 BuyTab;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxVendingMachineDisplayMode                 BuyBackTab;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxVendingMachineDisplayMode                 SellTab;                                           // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGFxVendingMachineDisplayMode>         TabOrder;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingTabOrder) == 0x000008, "Wrong alignment on FVendingTabOrder");
static_assert(sizeof(FVendingTabOrder) == 0x000018, "Wrong size on FVendingTabOrder");
static_assert(offsetof(FVendingTabOrder, BuyTab) == 0x000000, "Member 'FVendingTabOrder::BuyTab' has a wrong offset!");
static_assert(offsetof(FVendingTabOrder, BuyBackTab) == 0x000001, "Member 'FVendingTabOrder::BuyBackTab' has a wrong offset!");
static_assert(offsetof(FVendingTabOrder, SellTab) == 0x000002, "Member 'FVendingTabOrder::SellTab' has a wrong offset!");
static_assert(offsetof(FVendingTabOrder, TabOrder) == 0x000008, "Member 'FVendingTabOrder::TabOrder' has a wrong offset!");

// ScriptStruct OakGame.EchoDeviceUIController
// 0x0020 (0x0020 - 0x0000)
struct FEchoDeviceUIController final
{
public:
	class UEchoDeviceUIData*                      Config;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipEchoDevice;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AOakCharacter_Player>    PrimaryCharacter;                                  // 0x000C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEchoDeviceUIController) == 0x000008, "Wrong alignment on FEchoDeviceUIController");
static_assert(sizeof(FEchoDeviceUIController) == 0x000020, "Wrong size on FEchoDeviceUIController");
static_assert(offsetof(FEchoDeviceUIController, Config) == 0x000000, "Member 'FEchoDeviceUIController::Config' has a wrong offset!");
static_assert(offsetof(FEchoDeviceUIController, bEquipEchoDevice) == 0x000008, "Member 'FEchoDeviceUIController::bEquipEchoDevice' has a wrong offset!");
static_assert(offsetof(FEchoDeviceUIController, PrimaryCharacter) == 0x00000C, "Member 'FEchoDeviceUIController::PrimaryCharacter' has a wrong offset!");

// ScriptStruct OakGame.AutoplayCombatState
// 0x0030 (0x0030 - 0x0000)
struct FAutoplayCombatState final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EnemyTarget;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoplayCombatState) == 0x000008, "Wrong alignment on FAutoplayCombatState");
static_assert(sizeof(FAutoplayCombatState) == 0x000030, "Wrong size on FAutoplayCombatState");
static_assert(offsetof(FAutoplayCombatState, EnemyTarget) == 0x000010, "Member 'FAutoplayCombatState::EnemyTarget' has a wrong offset!");

// ScriptStruct OakGame.EchoInfo
// 0x0060 (0x0060 - 0x0000)
struct FEchoInfo final
{
public:
	int32                                         DialogPlayingID;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxDialogComponent*                    Caller;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterEchoData*                     CharacterData;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPerformanceEchoData*                   PerformanceData;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWwisePlaybackInstance                 AudioInstance;                                     // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FString                                 MoodKeyframeToUse;                                 // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoGMoodKeyToUse;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoiceOfGodSpeaker                            VoGSpeakerID;                                      // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEchoOnly;                                    // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEchoInfo) == 0x000008, "Wrong alignment on FEchoInfo");
static_assert(sizeof(FEchoInfo) == 0x000060, "Wrong size on FEchoInfo");
static_assert(offsetof(FEchoInfo, DialogPlayingID) == 0x000000, "Member 'FEchoInfo::DialogPlayingID' has a wrong offset!");
static_assert(offsetof(FEchoInfo, Caller) == 0x000008, "Member 'FEchoInfo::Caller' has a wrong offset!");
static_assert(offsetof(FEchoInfo, CharacterData) == 0x000010, "Member 'FEchoInfo::CharacterData' has a wrong offset!");
static_assert(offsetof(FEchoInfo, PerformanceData) == 0x000018, "Member 'FEchoInfo::PerformanceData' has a wrong offset!");
static_assert(offsetof(FEchoInfo, AudioInstance) == 0x000020, "Member 'FEchoInfo::AudioInstance' has a wrong offset!");
static_assert(offsetof(FEchoInfo, MoodKeyframeToUse) == 0x000038, "Member 'FEchoInfo::MoodKeyframeToUse' has a wrong offset!");
static_assert(offsetof(FEchoInfo, VoGMoodKeyToUse) == 0x000048, "Member 'FEchoInfo::VoGMoodKeyToUse' has a wrong offset!");
static_assert(offsetof(FEchoInfo, VoGSpeakerID) == 0x000058, "Member 'FEchoInfo::VoGSpeakerID' has a wrong offset!");
static_assert(offsetof(FEchoInfo, bForceEchoOnly) == 0x000059, "Member 'FEchoInfo::bForceEchoOnly' has a wrong offset!");

// ScriptStruct OakGame.ElementalDamageTriggeredInteractionData
// 0x0028 (0x0028 - 0x0000)
struct FElementalDamageTriggeredInteractionData final
{
public:
	class UElementalInteractionData*              Interaction;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0008(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatorController;                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementalDamageTriggeredInteractionData) == 0x000008, "Wrong alignment on FElementalDamageTriggeredInteractionData");
static_assert(sizeof(FElementalDamageTriggeredInteractionData) == 0x000028, "Wrong size on FElementalDamageTriggeredInteractionData");
static_assert(offsetof(FElementalDamageTriggeredInteractionData, Interaction) == 0x000000, "Member 'FElementalDamageTriggeredInteractionData::Interaction' has a wrong offset!");
static_assert(offsetof(FElementalDamageTriggeredInteractionData, HitLocation) == 0x000008, "Member 'FElementalDamageTriggeredInteractionData::HitLocation' has a wrong offset!");
static_assert(offsetof(FElementalDamageTriggeredInteractionData, InstigatorController) == 0x000018, "Member 'FElementalDamageTriggeredInteractionData::InstigatorController' has a wrong offset!");

// ScriptStruct OakGame.SupportedElementalInteractionData
// 0x00F8 (0x00F8 - 0x0000)
struct FSupportedElementalInteractionData final
{
public:
	class UElementalInteractionData*              State;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeScale;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTriggeredTransitionTimeScale;                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideDamageTriggeredSourceDuration;             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideDamageAmount : 1;                         // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideBaseStatusEffectChance : 1;               // 0x0014(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideBaseStatusEffectDamage : 1;               // 0x0014(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideBaseStatusEffectDuration : 1;             // 0x0014(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           OverrideDamageAmount;                              // 0x0018(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           OverrideBaseStatusEffectChance;                    // 0x0050(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           OverrideBaseStatusEffectDamage;                    // 0x0088(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           OverrideBaseStatusEffectDuration;                  // 0x00C0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportedElementalInteractionData) == 0x000008, "Wrong alignment on FSupportedElementalInteractionData");
static_assert(sizeof(FSupportedElementalInteractionData) == 0x0000F8, "Wrong size on FSupportedElementalInteractionData");
static_assert(offsetof(FSupportedElementalInteractionData, State) == 0x000000, "Member 'FSupportedElementalInteractionData::State' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, TransitionTimeScale) == 0x000008, "Member 'FSupportedElementalInteractionData::TransitionTimeScale' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, DamageTriggeredTransitionTimeScale) == 0x00000C, "Member 'FSupportedElementalInteractionData::DamageTriggeredTransitionTimeScale' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, OverrideDamageTriggeredSourceDuration) == 0x000010, "Member 'FSupportedElementalInteractionData::OverrideDamageTriggeredSourceDuration' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, OverrideDamageAmount) == 0x000018, "Member 'FSupportedElementalInteractionData::OverrideDamageAmount' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, OverrideBaseStatusEffectChance) == 0x000050, "Member 'FSupportedElementalInteractionData::OverrideBaseStatusEffectChance' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, OverrideBaseStatusEffectDamage) == 0x000088, "Member 'FSupportedElementalInteractionData::OverrideBaseStatusEffectDamage' has a wrong offset!");
static_assert(offsetof(FSupportedElementalInteractionData, OverrideBaseStatusEffectDuration) == 0x0000C0, "Member 'FSupportedElementalInteractionData::OverrideBaseStatusEffectDuration' has a wrong offset!");

// ScriptStruct OakGame.ElementalInteractionTransitionData
// 0x0018 (0x0018 - 0x0000)
struct FElementalInteractionTransitionData final
{
public:
	class UElementalInteractionData*              SourceInteraction;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UElementalInteractionData*              TargetInteraction;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionTime;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageTriggeredTransitionTime;                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FElementalInteractionTransitionData) == 0x000008, "Wrong alignment on FElementalInteractionTransitionData");
static_assert(sizeof(FElementalInteractionTransitionData) == 0x000018, "Wrong size on FElementalInteractionTransitionData");
static_assert(offsetof(FElementalInteractionTransitionData, SourceInteraction) == 0x000000, "Member 'FElementalInteractionTransitionData::SourceInteraction' has a wrong offset!");
static_assert(offsetof(FElementalInteractionTransitionData, TargetInteraction) == 0x000008, "Member 'FElementalInteractionTransitionData::TargetInteraction' has a wrong offset!");
static_assert(offsetof(FElementalInteractionTransitionData, TransitionTime) == 0x000010, "Member 'FElementalInteractionTransitionData::TransitionTime' has a wrong offset!");
static_assert(offsetof(FElementalInteractionTransitionData, DamageTriggeredTransitionTime) == 0x000014, "Member 'FElementalInteractionTransitionData::DamageTriggeredTransitionTime' has a wrong offset!");

// ScriptStruct OakGame.ElementalInteractionManagerPostPhysicsTickFunction
// 0x0008 (0x0058 - 0x0050)
struct FElementalInteractionManagerPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FElementalInteractionManagerPostPhysicsTickFunction) == 0x000008, "Wrong alignment on FElementalInteractionManagerPostPhysicsTickFunction");
static_assert(sizeof(FElementalInteractionManagerPostPhysicsTickFunction) == 0x000058, "Wrong size on FElementalInteractionManagerPostPhysicsTickFunction");

// ScriptStruct OakGame.ActorElementalInteractionDamageData
// 0x0088 (0x0088 - 0x0000)
struct FActorElementalInteractionDamageData final
{
public:
	TMap<class UElementalInteractionComponent*, struct FElementalInteractionDamageValuesData> DamageMap;                                         // 0x0000(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatorController;                              // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorElementalInteractionDamageData) == 0x000008, "Wrong alignment on FActorElementalInteractionDamageData");
static_assert(sizeof(FActorElementalInteractionDamageData) == 0x000088, "Wrong size on FActorElementalInteractionDamageData");
static_assert(offsetof(FActorElementalInteractionDamageData, DamageMap) == 0x000000, "Member 'FActorElementalInteractionDamageData::DamageMap' has a wrong offset!");
static_assert(offsetof(FActorElementalInteractionDamageData, InstigatorController) == 0x000078, "Member 'FActorElementalInteractionDamageData::InstigatorController' has a wrong offset!");

// ScriptStruct OakGame.ActorElementalDamageData
// 0x0058 (0x0058 - 0x0000)
struct FActorElementalDamageData final
{
public:
	TMap<TSubclassOf<class UGbxDamageType>, struct FActorElementalInteractionDamageData> DamageInteractions;                                // 0x0000(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         DamageCount;                                       // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorElementalDamageData) == 0x000008, "Wrong alignment on FActorElementalDamageData");
static_assert(sizeof(FActorElementalDamageData) == 0x000058, "Wrong size on FActorElementalDamageData");
static_assert(offsetof(FActorElementalDamageData, DamageInteractions) == 0x000000, "Member 'FActorElementalDamageData::DamageInteractions' has a wrong offset!");
static_assert(offsetof(FActorElementalDamageData, DamageCount) == 0x000050, "Member 'FActorElementalDamageData::DamageCount' has a wrong offset!");

// ScriptStruct OakGame.CustomPlayerColorSaveGameData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FCustomPlayerColorSaveGameData final
{
public:
	class FName                                   ColorParameter;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AppliedColor;                                      // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplitColor;                                        // 0x0014(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultColor;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultSplitColor;                             // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomPlayerColorSaveGameData) == 0x000008, "Wrong alignment on FCustomPlayerColorSaveGameData");
static_assert(sizeof(FCustomPlayerColorSaveGameData) == 0x000028, "Wrong size on FCustomPlayerColorSaveGameData");
static_assert(offsetof(FCustomPlayerColorSaveGameData, ColorParameter) == 0x000000, "Member 'FCustomPlayerColorSaveGameData::ColorParameter' has a wrong offset!");
static_assert(offsetof(FCustomPlayerColorSaveGameData, AppliedColor) == 0x000008, "Member 'FCustomPlayerColorSaveGameData::AppliedColor' has a wrong offset!");
static_assert(offsetof(FCustomPlayerColorSaveGameData, SplitColor) == 0x000014, "Member 'FCustomPlayerColorSaveGameData::SplitColor' has a wrong offset!");
static_assert(offsetof(FCustomPlayerColorSaveGameData, bUseDefaultColor) == 0x000020, "Member 'FCustomPlayerColorSaveGameData::bUseDefaultColor' has a wrong offset!");
static_assert(offsetof(FCustomPlayerColorSaveGameData, bUseDefaultSplitColor) == 0x000021, "Member 'FCustomPlayerColorSaveGameData::bUseDefaultSplitColor' has a wrong offset!");

// ScriptStruct OakGame.GFxGameModeNotificationWidgetInfo
// 0x0060 (0x0060 - 0x0000)
struct FGFxGameModeNotificationWidgetInfo final
{
public:
	EGameModeNotificationType                     NotificationType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TimelinePosition;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentPath;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextFieldPath;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextFieldShadowPath;                               // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayedText;                                     // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxGameModeNotificationWidgetInfo) == 0x000008, "Wrong alignment on FGFxGameModeNotificationWidgetInfo");
static_assert(sizeof(FGFxGameModeNotificationWidgetInfo) == 0x000060, "Wrong size on FGFxGameModeNotificationWidgetInfo");
static_assert(offsetof(FGFxGameModeNotificationWidgetInfo, NotificationType) == 0x000000, "Member 'FGFxGameModeNotificationWidgetInfo::NotificationType' has a wrong offset!");
static_assert(offsetof(FGFxGameModeNotificationWidgetInfo, TimelinePosition) == 0x000008, "Member 'FGFxGameModeNotificationWidgetInfo::TimelinePosition' has a wrong offset!");
static_assert(offsetof(FGFxGameModeNotificationWidgetInfo, ContentPath) == 0x000018, "Member 'FGFxGameModeNotificationWidgetInfo::ContentPath' has a wrong offset!");
static_assert(offsetof(FGFxGameModeNotificationWidgetInfo, TextFieldPath) == 0x000028, "Member 'FGFxGameModeNotificationWidgetInfo::TextFieldPath' has a wrong offset!");
static_assert(offsetof(FGFxGameModeNotificationWidgetInfo, TextFieldShadowPath) == 0x000038, "Member 'FGFxGameModeNotificationWidgetInfo::TextFieldShadowPath' has a wrong offset!");
static_assert(offsetof(FGFxGameModeNotificationWidgetInfo, DisplayedText) == 0x000048, "Member 'FGFxGameModeNotificationWidgetInfo::DisplayedText' has a wrong offset!");

// ScriptStruct OakGame.ElementalPuddleTransitionConfigurationData
// 0x0030 (0x0030 - 0x0000)
struct FElementalPuddleTransitionConfigurationData final
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshMaterial;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWwiseEvent*                            AudioLoop;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      PhysMatOverride;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           EmitterNames;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FElementalPuddleTransitionConfigurationData) == 0x000008, "Wrong alignment on FElementalPuddleTransitionConfigurationData");
static_assert(sizeof(FElementalPuddleTransitionConfigurationData) == 0x000030, "Wrong size on FElementalPuddleTransitionConfigurationData");
static_assert(offsetof(FElementalPuddleTransitionConfigurationData, DecalMaterial) == 0x000000, "Member 'FElementalPuddleTransitionConfigurationData::DecalMaterial' has a wrong offset!");
static_assert(offsetof(FElementalPuddleTransitionConfigurationData, MeshMaterial) == 0x000008, "Member 'FElementalPuddleTransitionConfigurationData::MeshMaterial' has a wrong offset!");
static_assert(offsetof(FElementalPuddleTransitionConfigurationData, AudioLoop) == 0x000010, "Member 'FElementalPuddleTransitionConfigurationData::AudioLoop' has a wrong offset!");
static_assert(offsetof(FElementalPuddleTransitionConfigurationData, PhysMatOverride) == 0x000018, "Member 'FElementalPuddleTransitionConfigurationData::PhysMatOverride' has a wrong offset!");
static_assert(offsetof(FElementalPuddleTransitionConfigurationData, EmitterNames) == 0x000020, "Member 'FElementalPuddleTransitionConfigurationData::EmitterNames' has a wrong offset!");

// ScriptStruct OakGame.MusicInterestASR
// 0x0010 (0x0010 - 0x0000)
struct FMusicInterestASR final
{
public:
	float                                         SustainValue;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTimeSeconds;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SustainTimeSeconds;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayTimeSeconds;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicInterestASR) == 0x000004, "Wrong alignment on FMusicInterestASR");
static_assert(sizeof(FMusicInterestASR) == 0x000010, "Wrong size on FMusicInterestASR");
static_assert(offsetof(FMusicInterestASR, SustainValue) == 0x000000, "Member 'FMusicInterestASR::SustainValue' has a wrong offset!");
static_assert(offsetof(FMusicInterestASR, AttackTimeSeconds) == 0x000004, "Member 'FMusicInterestASR::AttackTimeSeconds' has a wrong offset!");
static_assert(offsetof(FMusicInterestASR, SustainTimeSeconds) == 0x000008, "Member 'FMusicInterestASR::SustainTimeSeconds' has a wrong offset!");
static_assert(offsetof(FMusicInterestASR, DecayTimeSeconds) == 0x00000C, "Member 'FMusicInterestASR::DecayTimeSeconds' has a wrong offset!");

// ScriptStruct OakGame.EmperorVehicleAnimInstanceProxy
// 0x0070 (0x07F0 - 0x0780)
struct FEmperorVehicleAnimInstanceProxy final : public FOakVehicleAnimInstanceProxy
{
public:
	uint8                                         Pad_780[0x70];                                     // 0x0780(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmperorVehicleAnimInstanceProxy) == 0x000010, "Wrong alignment on FEmperorVehicleAnimInstanceProxy");
static_assert(sizeof(FEmperorVehicleAnimInstanceProxy) == 0x0007F0, "Wrong size on FEmperorVehicleAnimInstanceProxy");

// ScriptStruct OakGame.GFxSkillScreenLoadoutChoiceInfo
// 0x0058 (0x0058 - 0x0000)
struct FGFxSkillScreenLoadoutChoiceInfo final
{
public:
	class UOakPlayerAbilityTreeItemData*          ItemData;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ChoiceSelectedName;                                // 0x0008(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   ChoiceSelectionName;                               // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   ChoiceDescription;                                 // 0x0038(0x0018)(Transient, NativeAccessSpecifierPublic)
	EGFxSkillScreenLoadoutChoiceEquipState        EquipState;                                        // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxSkillScreenLoadoutChoiceInfo) == 0x000008, "Wrong alignment on FGFxSkillScreenLoadoutChoiceInfo");
static_assert(sizeof(FGFxSkillScreenLoadoutChoiceInfo) == 0x000058, "Wrong size on FGFxSkillScreenLoadoutChoiceInfo");
static_assert(offsetof(FGFxSkillScreenLoadoutChoiceInfo, ItemData) == 0x000000, "Member 'FGFxSkillScreenLoadoutChoiceInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenLoadoutChoiceInfo, ChoiceSelectedName) == 0x000008, "Member 'FGFxSkillScreenLoadoutChoiceInfo::ChoiceSelectedName' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenLoadoutChoiceInfo, ChoiceSelectionName) == 0x000020, "Member 'FGFxSkillScreenLoadoutChoiceInfo::ChoiceSelectionName' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenLoadoutChoiceInfo, ChoiceDescription) == 0x000038, "Member 'FGFxSkillScreenLoadoutChoiceInfo::ChoiceDescription' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenLoadoutChoiceInfo, EquipState) == 0x000050, "Member 'FGFxSkillScreenLoadoutChoiceInfo::EquipState' has a wrong offset!");

// ScriptStruct OakGame.VendingIDToSocketNameMap
// 0x0050 (0x0050 - 0x0000)
struct FVendingIDToSocketNameMap final
{
public:
	TMap<class FString, struct FVendingMachineSocketLocationAndOffset> SocketMap;                                         // 0x0000(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingIDToSocketNameMap) == 0x000008, "Wrong alignment on FVendingIDToSocketNameMap");
static_assert(sizeof(FVendingIDToSocketNameMap) == 0x000050, "Wrong size on FVendingIDToSocketNameMap");
static_assert(offsetof(FVendingIDToSocketNameMap, SocketMap) == 0x000000, "Member 'FVendingIDToSocketNameMap::SocketMap' has a wrong offset!");

// ScriptStruct OakGame.SDUBonusLevelData
// 0x0060 (0x0068 - 0x0008)
struct FSDUBonusLevelData final : public FTableRowBase
{
public:
	int32                                         SDUPrice;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryCategoryData*                 Currency;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeEffectData                   AttributeModifyInfo;                               // 0x0018(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UInventoryRarityData*                   SDURarity;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSDUBonusLevelData) == 0x000008, "Wrong alignment on FSDUBonusLevelData");
static_assert(sizeof(FSDUBonusLevelData) == 0x000068, "Wrong size on FSDUBonusLevelData");
static_assert(offsetof(FSDUBonusLevelData, SDUPrice) == 0x000008, "Member 'FSDUBonusLevelData::SDUPrice' has a wrong offset!");
static_assert(offsetof(FSDUBonusLevelData, Currency) == 0x000010, "Member 'FSDUBonusLevelData::Currency' has a wrong offset!");
static_assert(offsetof(FSDUBonusLevelData, AttributeModifyInfo) == 0x000018, "Member 'FSDUBonusLevelData::AttributeModifyInfo' has a wrong offset!");
static_assert(offsetof(FSDUBonusLevelData, SDURarity) == 0x000060, "Member 'FSDUBonusLevelData::SDURarity' has a wrong offset!");

// ScriptStruct OakGame.PlayerVaultCardLevelFormula
// 0x0014 (0x0014 - 0x0000)
struct FPlayerVaultCardLevelFormula final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMultiplier;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerVaultCardLevelFormula) == 0x000004, "Wrong alignment on FPlayerVaultCardLevelFormula");
static_assert(sizeof(FPlayerVaultCardLevelFormula) == 0x000014, "Wrong size on FPlayerVaultCardLevelFormula");
static_assert(offsetof(FPlayerVaultCardLevelFormula, BaseValue) == 0x000000, "Member 'FPlayerVaultCardLevelFormula::BaseValue' has a wrong offset!");
static_assert(offsetof(FPlayerVaultCardLevelFormula, BaseMultiplier) == 0x000004, "Member 'FPlayerVaultCardLevelFormula::BaseMultiplier' has a wrong offset!");
static_assert(offsetof(FPlayerVaultCardLevelFormula, Multiplier) == 0x000008, "Member 'FPlayerVaultCardLevelFormula::Multiplier' has a wrong offset!");
static_assert(offsetof(FPlayerVaultCardLevelFormula, Power) == 0x00000C, "Member 'FPlayerVaultCardLevelFormula::Power' has a wrong offset!");
static_assert(offsetof(FPlayerVaultCardLevelFormula, Offset) == 0x000010, "Member 'FPlayerVaultCardLevelFormula::Offset' has a wrong offset!");

// ScriptStruct OakGame.CreditsTableRow
// 0x0048 (0x0050 - 0x0008)
struct FCreditsTableRow final : public FTableRowBase
{
public:
	class FString                                 FirstName;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastName;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Title;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Organization;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExtraText;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtraTextStyle;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditsTableRow) == 0x000008, "Wrong alignment on FCreditsTableRow");
static_assert(sizeof(FCreditsTableRow) == 0x000050, "Wrong size on FCreditsTableRow");
static_assert(offsetof(FCreditsTableRow, FirstName) == 0x000008, "Member 'FCreditsTableRow::FirstName' has a wrong offset!");
static_assert(offsetof(FCreditsTableRow, LastName) == 0x000018, "Member 'FCreditsTableRow::LastName' has a wrong offset!");
static_assert(offsetof(FCreditsTableRow, Title) == 0x000028, "Member 'FCreditsTableRow::Title' has a wrong offset!");
static_assert(offsetof(FCreditsTableRow, Organization) == 0x000030, "Member 'FCreditsTableRow::Organization' has a wrong offset!");
static_assert(offsetof(FCreditsTableRow, ExtraText) == 0x000038, "Member 'FCreditsTableRow::ExtraText' has a wrong offset!");
static_assert(offsetof(FCreditsTableRow, ExtraTextStyle) == 0x000048, "Member 'FCreditsTableRow::ExtraTextStyle' has a wrong offset!");

// ScriptStruct OakGame.WeightedOakModifierSet
// 0x0068 (0x0068 - 0x0000)
struct FWeightedOakModifierSet final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakModifierSet                        ModifierSet;                                       // 0x0008(0x0050)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MutualExclusionTags;                               // 0x0058(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedOakModifierSet) == 0x000008, "Wrong alignment on FWeightedOakModifierSet");
static_assert(sizeof(FWeightedOakModifierSet) == 0x000068, "Wrong size on FWeightedOakModifierSet");
static_assert(offsetof(FWeightedOakModifierSet, Weight) == 0x000000, "Member 'FWeightedOakModifierSet::Weight' has a wrong offset!");
static_assert(offsetof(FWeightedOakModifierSet, ModifierSet) == 0x000008, "Member 'FWeightedOakModifierSet::ModifierSet' has a wrong offset!");
static_assert(offsetof(FWeightedOakModifierSet, MutualExclusionTags) == 0x000058, "Member 'FWeightedOakModifierSet::MutualExclusionTags' has a wrong offset!");

// ScriptStruct OakGame.PlayerGuardianRankFormula
// 0x0014 (0x0014 - 0x0000)
struct FPlayerGuardianRankFormula final
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMultiplier;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerGuardianRankFormula) == 0x000004, "Wrong alignment on FPlayerGuardianRankFormula");
static_assert(sizeof(FPlayerGuardianRankFormula) == 0x000014, "Wrong size on FPlayerGuardianRankFormula");
static_assert(offsetof(FPlayerGuardianRankFormula, BaseValue) == 0x000000, "Member 'FPlayerGuardianRankFormula::BaseValue' has a wrong offset!");
static_assert(offsetof(FPlayerGuardianRankFormula, BaseMultiplier) == 0x000004, "Member 'FPlayerGuardianRankFormula::BaseMultiplier' has a wrong offset!");
static_assert(offsetof(FPlayerGuardianRankFormula, Multiplier) == 0x000008, "Member 'FPlayerGuardianRankFormula::Multiplier' has a wrong offset!");
static_assert(offsetof(FPlayerGuardianRankFormula, Power) == 0x00000C, "Member 'FPlayerGuardianRankFormula::Power' has a wrong offset!");
static_assert(offsetof(FPlayerGuardianRankFormula, Offset) == 0x000010, "Member 'FPlayerGuardianRankFormula::Offset' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakEmote
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakEmote final : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakEmote) == 0x000008, "Wrong alignment on FActionState_OakEmote");
static_assert(sizeof(FActionState_OakEmote) == 0x000520, "Wrong size on FActionState_OakEmote");

// ScriptStruct OakGame.OakPhaseTranceLockEffectSpec
// 0x0008 (0x0008 - 0x0000)
struct FOakPhaseTranceLockEffectSpec final
{
public:
	bool                                          bIsLocked;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectMask;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPhaseTranceLockEffectSpec) == 0x000004, "Wrong alignment on FOakPhaseTranceLockEffectSpec");
static_assert(sizeof(FOakPhaseTranceLockEffectSpec) == 0x000008, "Wrong size on FOakPhaseTranceLockEffectSpec");
static_assert(offsetof(FOakPhaseTranceLockEffectSpec, bIsLocked) == 0x000000, "Member 'FOakPhaseTranceLockEffectSpec::bIsLocked' has a wrong offset!");
static_assert(offsetof(FOakPhaseTranceLockEffectSpec, EffectMask) == 0x000004, "Member 'FOakPhaseTranceLockEffectSpec::EffectMask' has a wrong offset!");

// ScriptStruct OakGame.DrivingOverride
// 0x0002 (0x0002 - 0x0000)
struct FDrivingOverride final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDrivingOverride) == 0x000001, "Wrong alignment on FDrivingOverride");
static_assert(sizeof(FDrivingOverride) == 0x000002, "Wrong size on FDrivingOverride");

// ScriptStruct OakGame.PlayerExperienceFormula
// 0x000C (0x000C - 0x0000)
struct FPlayerExperienceFormula final
{
public:
	float                                         Multiplier;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerExperienceFormula) == 0x000004, "Wrong alignment on FPlayerExperienceFormula");
static_assert(sizeof(FPlayerExperienceFormula) == 0x00000C, "Wrong size on FPlayerExperienceFormula");
static_assert(offsetof(FPlayerExperienceFormula, Multiplier) == 0x000000, "Member 'FPlayerExperienceFormula::Multiplier' has a wrong offset!");
static_assert(offsetof(FPlayerExperienceFormula, Power) == 0x000004, "Member 'FPlayerExperienceFormula::Power' has a wrong offset!");
static_assert(offsetof(FPlayerExperienceFormula, Offset) == 0x000008, "Member 'FPlayerExperienceFormula::Offset' has a wrong offset!");

// ScriptStruct OakGame.RecentIncomingDamageData
// 0x0048 (0x0048 - 0x0000)
struct FRecentIncomingDamageData final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageComponent*                       DamageInstigatorDamageComponent;                   // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageInstigatorLocation;                          // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialDuration;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverity;                                    // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasJolt;                                          // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecentDamageFlags                            Flags;                                             // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InstanceId;                                        // 0x0046(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecentIncomingDamageData) == 0x000008, "Wrong alignment on FRecentIncomingDamageData");
static_assert(sizeof(FRecentIncomingDamageData) == 0x000048, "Wrong size on FRecentIncomingDamageData");
static_assert(offsetof(FRecentIncomingDamageData, DamageInstigator) == 0x000000, "Member 'FRecentIncomingDamageData::DamageInstigator' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, DamageInstigatorDamageComponent) == 0x000018, "Member 'FRecentIncomingDamageData::DamageInstigatorDamageComponent' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, DamageInstigatorLocation) == 0x000020, "Member 'FRecentIncomingDamageData::DamageInstigatorLocation' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, InitialDuration) == 0x000038, "Member 'FRecentIncomingDamageData::InitialDuration' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, DamageSeverity) == 0x00003C, "Member 'FRecentIncomingDamageData::DamageSeverity' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, TimeRemaining) == 0x000040, "Member 'FRecentIncomingDamageData::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, bWasJolt) == 0x000044, "Member 'FRecentIncomingDamageData::bWasJolt' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, Flags) == 0x000045, "Member 'FRecentIncomingDamageData::Flags' has a wrong offset!");
static_assert(offsetof(FRecentIncomingDamageData, InstanceId) == 0x000046, "Member 'FRecentIncomingDamageData::InstanceId' has a wrong offset!");

// ScriptStruct OakGame.FriendEventDataEntry
// 0x0040 (0x0048 - 0x0008)
struct FFriendEventDataEntry final : public FTableRowBase
{
public:
	EFriendEventType                              FriendEventType;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFriendEventPriority                          Priority;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Ordinal;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ContainsSpoiler;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BroadcastToSingleFriend;                           // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplayNotificationOnFriendHUD;                    // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowNotification;                           // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplayEventOnTimeline;                            // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventTitleText;                                    // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   EventText;                                         // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendEventDataEntry) == 0x000008, "Wrong alignment on FFriendEventDataEntry");
static_assert(sizeof(FFriendEventDataEntry) == 0x000048, "Wrong size on FFriendEventDataEntry");
static_assert(offsetof(FFriendEventDataEntry, FriendEventType) == 0x000008, "Member 'FFriendEventDataEntry::FriendEventType' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, Priority) == 0x000009, "Member 'FFriendEventDataEntry::Priority' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, Ordinal) == 0x00000C, "Member 'FFriendEventDataEntry::Ordinal' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, ContainsSpoiler) == 0x000010, "Member 'FFriendEventDataEntry::ContainsSpoiler' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, BroadcastToSingleFriend) == 0x000011, "Member 'FFriendEventDataEntry::BroadcastToSingleFriend' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, DisplayNotificationOnFriendHUD) == 0x000012, "Member 'FFriendEventDataEntry::DisplayNotificationOnFriendHUD' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, bAlwaysShowNotification) == 0x000013, "Member 'FFriendEventDataEntry::bAlwaysShowNotification' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, DisplayEventOnTimeline) == 0x000014, "Member 'FFriendEventDataEntry::DisplayEventOnTimeline' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, EventTitleText) == 0x000018, "Member 'FFriendEventDataEntry::EventTitleText' has a wrong offset!");
static_assert(offsetof(FFriendEventDataEntry, EventText) == 0x000030, "Member 'FFriendEventDataEntry::EventText' has a wrong offset!");

// ScriptStruct OakGame.MapIDToPlanetDataMappingData
// 0x0010 (0x0010 - 0x0000)
struct FMapIDToPlanetDataMappingData final
{
public:
	uint8                                         MapID;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlanetData*                            PlanetData;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMapIDToPlanetDataMappingData) == 0x000008, "Wrong alignment on FMapIDToPlanetDataMappingData");
static_assert(sizeof(FMapIDToPlanetDataMappingData) == 0x000010, "Wrong size on FMapIDToPlanetDataMappingData");
static_assert(offsetof(FMapIDToPlanetDataMappingData, MapID) == 0x000000, "Member 'FMapIDToPlanetDataMappingData::MapID' has a wrong offset!");
static_assert(offsetof(FMapIDToPlanetDataMappingData, PlanetData) == 0x000008, "Member 'FMapIDToPlanetDataMappingData::PlanetData' has a wrong offset!");

// ScriptStruct OakGame.PlanetMapDataToPlanetIdMappingData
// 0x0010 (0x0010 - 0x0000)
struct FPlanetMapDataToPlanetIdMappingData final
{
public:
	class UPlanetData*                            PlanetData;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PlanetID;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanetMapDataToPlanetIdMappingData) == 0x000008, "Wrong alignment on FPlanetMapDataToPlanetIdMappingData");
static_assert(sizeof(FPlanetMapDataToPlanetIdMappingData) == 0x000010, "Wrong size on FPlanetMapDataToPlanetIdMappingData");
static_assert(offsetof(FPlanetMapDataToPlanetIdMappingData, PlanetData) == 0x000000, "Member 'FPlanetMapDataToPlanetIdMappingData::PlanetData' has a wrong offset!");
static_assert(offsetof(FPlanetMapDataToPlanetIdMappingData, PlanetID) == 0x000008, "Member 'FPlanetMapDataToPlanetIdMappingData::PlanetID' has a wrong offset!");

// ScriptStruct OakGame.GalaxySkyboxData
// 0x0040 (0x0040 - 0x0000)
struct FGalaxySkyboxData final
{
public:
	TSoftObjectPtr<class UWorld>                  WorldAsset;                                        // 0x0000(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MapNameEnumIdx;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ZoneNameEnumIdx;                                   // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxLevelSequence*                      ArriveSequence;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxLevelSequence*                      ExitSequence;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGalaxySkyboxData) == 0x000008, "Wrong alignment on FGalaxySkyboxData");
static_assert(sizeof(FGalaxySkyboxData) == 0x000040, "Wrong size on FGalaxySkyboxData");
static_assert(offsetof(FGalaxySkyboxData, WorldAsset) == 0x000000, "Member 'FGalaxySkyboxData::WorldAsset' has a wrong offset!");
static_assert(offsetof(FGalaxySkyboxData, MapNameEnumIdx) == 0x000028, "Member 'FGalaxySkyboxData::MapNameEnumIdx' has a wrong offset!");
static_assert(offsetof(FGalaxySkyboxData, ZoneNameEnumIdx) == 0x000029, "Member 'FGalaxySkyboxData::ZoneNameEnumIdx' has a wrong offset!");
static_assert(offsetof(FGalaxySkyboxData, ArriveSequence) == 0x000030, "Member 'FGalaxySkyboxData::ArriveSequence' has a wrong offset!");
static_assert(offsetof(FGalaxySkyboxData, ExitSequence) == 0x000038, "Member 'FGalaxySkyboxData::ExitSequence' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryMenuPaperDollSlotInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FOakInventoryMenuPaperDollSlotInfo final
{
public:
	class FString                                 WidgetName;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrinketName;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventorySlotData*                     SlotData;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotFilterId;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlotIconWidgetName;                                // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlotIconFrame;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGbxInputKeyRebindData_Button> ButtonBinding;                                     // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NoKeyBoundFrameName;                               // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotIconInputAction;                               // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakInventoryMenuPaperDollSlotAdjacency       Adjancency;                                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlockedIsBeastmaster;                            // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlockedIsExtraArtifacts;                         // 0x0095(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SplitScreenPage;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakInventoryMenuPaperDollSlotInfo) == 0x000008, "Wrong alignment on FOakInventoryMenuPaperDollSlotInfo");
static_assert(sizeof(FOakInventoryMenuPaperDollSlotInfo) == 0x0000A0, "Wrong size on FOakInventoryMenuPaperDollSlotInfo");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, WidgetName) == 0x000000, "Member 'FOakInventoryMenuPaperDollSlotInfo::WidgetName' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, TrinketName) == 0x000010, "Member 'FOakInventoryMenuPaperDollSlotInfo::TrinketName' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, SlotData) == 0x000020, "Member 'FOakInventoryMenuPaperDollSlotInfo::SlotData' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, SlotFilterId) == 0x000028, "Member 'FOakInventoryMenuPaperDollSlotInfo::SlotFilterId' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, SlotIconWidgetName) == 0x000030, "Member 'FOakInventoryMenuPaperDollSlotInfo::SlotIconWidgetName' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, SlotIconFrame) == 0x000040, "Member 'FOakInventoryMenuPaperDollSlotInfo::SlotIconFrame' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, ButtonBinding) == 0x000050, "Member 'FOakInventoryMenuPaperDollSlotInfo::ButtonBinding' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, NoKeyBoundFrameName) == 0x000078, "Member 'FOakInventoryMenuPaperDollSlotInfo::NoKeyBoundFrameName' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, SlotIconInputAction) == 0x000088, "Member 'FOakInventoryMenuPaperDollSlotInfo::SlotIconInputAction' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, Adjancency) == 0x000090, "Member 'FOakInventoryMenuPaperDollSlotInfo::Adjancency' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, bUnlockedIsBeastmaster) == 0x000094, "Member 'FOakInventoryMenuPaperDollSlotInfo::bUnlockedIsBeastmaster' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, bUnlockedIsExtraArtifacts) == 0x000095, "Member 'FOakInventoryMenuPaperDollSlotInfo::bUnlockedIsExtraArtifacts' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuPaperDollSlotInfo, SplitScreenPage) == 0x000098, "Member 'FOakInventoryMenuPaperDollSlotInfo::SplitScreenPage' has a wrong offset!");

// ScriptStruct OakGame.VaultCardExportChallengeLists
// 0x0020 (0x0020 - 0x0000)
struct FVaultCardExportChallengeLists final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDownloadableContentData*               AssociatedDLC;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UChallenge>>         Challenges;                                        // 0x0010(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardExportChallengeLists) == 0x000008, "Wrong alignment on FVaultCardExportChallengeLists");
static_assert(sizeof(FVaultCardExportChallengeLists) == 0x000020, "Wrong size on FVaultCardExportChallengeLists");
static_assert(offsetof(FVaultCardExportChallengeLists, AssociatedDLC) == 0x000008, "Member 'FVaultCardExportChallengeLists::AssociatedDLC' has a wrong offset!");
static_assert(offsetof(FVaultCardExportChallengeLists, Challenges) == 0x000010, "Member 'FVaultCardExportChallengeLists::Challenges' has a wrong offset!");

// ScriptStruct OakGame.PayloadInstanceData
// 0x0030 (0x0030 - 0x0000)
struct FPayloadInstanceData final
{
public:
	int32                                         StackCount;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstanceBool;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstanceFloat;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceInt;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InstanceVector;                                    // 0x0010(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InstanceActor;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerCount;                                      // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPayloadInstanceData) == 0x000008, "Wrong alignment on FPayloadInstanceData");
static_assert(sizeof(FPayloadInstanceData) == 0x000030, "Wrong size on FPayloadInstanceData");
static_assert(offsetof(FPayloadInstanceData, StackCount) == 0x000000, "Member 'FPayloadInstanceData::StackCount' has a wrong offset!");
static_assert(offsetof(FPayloadInstanceData, bInstanceBool) == 0x000004, "Member 'FPayloadInstanceData::bInstanceBool' has a wrong offset!");
static_assert(offsetof(FPayloadInstanceData, InstanceFloat) == 0x000008, "Member 'FPayloadInstanceData::InstanceFloat' has a wrong offset!");
static_assert(offsetof(FPayloadInstanceData, InstanceInt) == 0x00000C, "Member 'FPayloadInstanceData::InstanceInt' has a wrong offset!");
static_assert(offsetof(FPayloadInstanceData, InstanceVector) == 0x000010, "Member 'FPayloadInstanceData::InstanceVector' has a wrong offset!");
static_assert(offsetof(FPayloadInstanceData, InstanceActor) == 0x000020, "Member 'FPayloadInstanceData::InstanceActor' has a wrong offset!");
static_assert(offsetof(FPayloadInstanceData, TriggerCount) == 0x000028, "Member 'FPayloadInstanceData::TriggerCount' has a wrong offset!");

// ScriptStruct OakGame.InventoryDataUnlockedInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FInventoryDataUnlockedInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryDataUnlockedInfo) == 0x000008, "Wrong alignment on FInventoryDataUnlockedInfo");
static_assert(sizeof(FInventoryDataUnlockedInfo) == 0x000030, "Wrong size on FInventoryDataUnlockedInfo");

// ScriptStruct OakGame.VaultCardActiveChallengeList
// 0x0018 (0x0018 - 0x0000)
struct FVaultCardActiveChallengeList final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                VaultCardChallenges;                               // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardActiveChallengeList) == 0x000008, "Wrong alignment on FVaultCardActiveChallengeList");
static_assert(sizeof(FVaultCardActiveChallengeList) == 0x000018, "Wrong size on FVaultCardActiveChallengeList");
static_assert(offsetof(FVaultCardActiveChallengeList, VaultCardChallenges) == 0x000008, "Member 'FVaultCardActiveChallengeList::VaultCardChallenges' has a wrong offset!");

// ScriptStruct OakGame.OakPassiveAbilitySirenGhostArmControllerSpec
// 0x0018 (0x0018 - 0x0000)
struct FOakPassiveAbilitySirenGhostArmControllerSpec final
{
public:
	EOakPassiveAbilitySirenArmDurationType        DurationType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakAbilityTimerData*                   TimerData;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPassiveAbilitySirenGhostArmControllerSpec) == 0x000008, "Wrong alignment on FOakPassiveAbilitySirenGhostArmControllerSpec");
static_assert(sizeof(FOakPassiveAbilitySirenGhostArmControllerSpec) == 0x000018, "Wrong size on FOakPassiveAbilitySirenGhostArmControllerSpec");
static_assert(offsetof(FOakPassiveAbilitySirenGhostArmControllerSpec, DurationType) == 0x000000, "Member 'FOakPassiveAbilitySirenGhostArmControllerSpec::DurationType' has a wrong offset!");
static_assert(offsetof(FOakPassiveAbilitySirenGhostArmControllerSpec, TimerData) == 0x000008, "Member 'FOakPassiveAbilitySirenGhostArmControllerSpec::TimerData' has a wrong offset!");
static_assert(offsetof(FOakPassiveAbilitySirenGhostArmControllerSpec, StatusEffectData) == 0x000010, "Member 'FOakPassiveAbilitySirenGhostArmControllerSpec::StatusEffectData' has a wrong offset!");

// ScriptStruct OakGame.AmpedShotSettings
// 0x0018 (0x0018 - 0x0000)
struct FAmpedShotSettings final
{
public:
	TSubclassOf<class UEffectCollectionData>      AmpedShotTracerFX;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      AmpedShotBeamFX;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            AmpedShotSound;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAmpedShotSettings) == 0x000008, "Wrong alignment on FAmpedShotSettings");
static_assert(sizeof(FAmpedShotSettings) == 0x000018, "Wrong size on FAmpedShotSettings");
static_assert(offsetof(FAmpedShotSettings, AmpedShotTracerFX) == 0x000000, "Member 'FAmpedShotSettings::AmpedShotTracerFX' has a wrong offset!");
static_assert(offsetof(FAmpedShotSettings, AmpedShotBeamFX) == 0x000008, "Member 'FAmpedShotSettings::AmpedShotBeamFX' has a wrong offset!");
static_assert(offsetof(FAmpedShotSettings, AmpedShotSound) == 0x000010, "Member 'FAmpedShotSettings::AmpedShotSound' has a wrong offset!");

// ScriptStruct OakGame.OakVehicleManagerSettings
// 0x0020 (0x0020 - 0x0000)
struct FOakVehicleManagerSettings final
{
public:
	float                                         OakVehicleManagerUpdateTime;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBeforeStartDamaging;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePercentBySecond;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBeforeDigistructOut;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBeforeExplode;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToDigistruct;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavCorrecterSearchRadius;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavCorrecterDestroyDelay;                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakVehicleManagerSettings) == 0x000004, "Wrong alignment on FOakVehicleManagerSettings");
static_assert(sizeof(FOakVehicleManagerSettings) == 0x000020, "Wrong size on FOakVehicleManagerSettings");
static_assert(offsetof(FOakVehicleManagerSettings, OakVehicleManagerUpdateTime) == 0x000000, "Member 'FOakVehicleManagerSettings::OakVehicleManagerUpdateTime' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, TimeBeforeStartDamaging) == 0x000004, "Member 'FOakVehicleManagerSettings::TimeBeforeStartDamaging' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, DamagePercentBySecond) == 0x000008, "Member 'FOakVehicleManagerSettings::DamagePercentBySecond' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, TimeBeforeDigistructOut) == 0x00000C, "Member 'FOakVehicleManagerSettings::TimeBeforeDigistructOut' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, TimeBeforeExplode) == 0x000010, "Member 'FOakVehicleManagerSettings::TimeBeforeExplode' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, DistanceToDigistruct) == 0x000014, "Member 'FOakVehicleManagerSettings::DistanceToDigistruct' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, NavCorrecterSearchRadius) == 0x000018, "Member 'FOakVehicleManagerSettings::NavCorrecterSearchRadius' has a wrong offset!");
static_assert(offsetof(FOakVehicleManagerSettings, NavCorrecterDestroyDelay) == 0x00001C, "Member 'FOakVehicleManagerSettings::NavCorrecterDestroyDelay' has a wrong offset!");

// ScriptStruct OakGame.PickupEvaluationSettings
// 0x0038 (0x0038 - 0x0000)
struct FPickupEvaluationSettings final
{
public:
	float                                         MinEvaluationHeight;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvaluationWidth;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxExtentZFactor;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectedWidthBoost;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectedHeightBoost;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectedBoxZFactorBoost;                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectedBoxZFactorBoost_Attached;                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachedPickupPreferredBoxMaxHeight;               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachedPickupTracedMeshPriorityBoost;             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupStickiness;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLookAtTolerance;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkipVisibilityTraceTestRange;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemCardBottomPickupOffset;                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemCardUpperLootBeamHeight;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupEvaluationSettings) == 0x000004, "Wrong alignment on FPickupEvaluationSettings");
static_assert(sizeof(FPickupEvaluationSettings) == 0x000038, "Wrong size on FPickupEvaluationSettings");
static_assert(offsetof(FPickupEvaluationSettings, MinEvaluationHeight) == 0x000000, "Member 'FPickupEvaluationSettings::MinEvaluationHeight' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, EvaluationWidth) == 0x000004, "Member 'FPickupEvaluationSettings::EvaluationWidth' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, BoxExtentZFactor) == 0x000008, "Member 'FPickupEvaluationSettings::BoxExtentZFactor' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, SelectedWidthBoost) == 0x00000C, "Member 'FPickupEvaluationSettings::SelectedWidthBoost' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, SelectedHeightBoost) == 0x000010, "Member 'FPickupEvaluationSettings::SelectedHeightBoost' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, SelectedBoxZFactorBoost) == 0x000014, "Member 'FPickupEvaluationSettings::SelectedBoxZFactorBoost' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, SelectedBoxZFactorBoost_Attached) == 0x000018, "Member 'FPickupEvaluationSettings::SelectedBoxZFactorBoost_Attached' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, AttachedPickupPreferredBoxMaxHeight) == 0x00001C, "Member 'FPickupEvaluationSettings::AttachedPickupPreferredBoxMaxHeight' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, AttachedPickupTracedMeshPriorityBoost) == 0x000020, "Member 'FPickupEvaluationSettings::AttachedPickupTracedMeshPriorityBoost' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, PickupStickiness) == 0x000024, "Member 'FPickupEvaluationSettings::PickupStickiness' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, MinLookAtTolerance) == 0x000028, "Member 'FPickupEvaluationSettings::MinLookAtTolerance' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, SkipVisibilityTraceTestRange) == 0x00002C, "Member 'FPickupEvaluationSettings::SkipVisibilityTraceTestRange' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, ItemCardBottomPickupOffset) == 0x000030, "Member 'FPickupEvaluationSettings::ItemCardBottomPickupOffset' has a wrong offset!");
static_assert(offsetof(FPickupEvaluationSettings, ItemCardUpperLootBeamHeight) == 0x000034, "Member 'FPickupEvaluationSettings::ItemCardUpperLootBeamHeight' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakRandomAnim
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakRandomAnim : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakRandomAnim) == 0x000008, "Wrong alignment on FActionState_OakRandomAnim");
static_assert(sizeof(FActionState_OakRandomAnim) == 0x000520, "Wrong size on FActionState_OakRandomAnim");

// ScriptStruct OakGame.COVRepairType
// 0x0048 (0x0048 - 0x0000)
struct FCOVRepairType final
{
public:
	struct FAttributeInitializationData           BrokenEffectIndex;                                 // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RepairTime;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepairCompletePercent;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownCompletePercent;                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionWeight;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCOVRepairType) == 0x000008, "Wrong alignment on FCOVRepairType");
static_assert(sizeof(FCOVRepairType) == 0x000048, "Wrong size on FCOVRepairType");
static_assert(offsetof(FCOVRepairType, BrokenEffectIndex) == 0x000000, "Member 'FCOVRepairType::BrokenEffectIndex' has a wrong offset!");
static_assert(offsetof(FCOVRepairType, RepairTime) == 0x000038, "Member 'FCOVRepairType::RepairTime' has a wrong offset!");
static_assert(offsetof(FCOVRepairType, RepairCompletePercent) == 0x00003C, "Member 'FCOVRepairType::RepairCompletePercent' has a wrong offset!");
static_assert(offsetof(FCOVRepairType, CooldownCompletePercent) == 0x000040, "Member 'FCOVRepairType::CooldownCompletePercent' has a wrong offset!");
static_assert(offsetof(FCOVRepairType, SelectionWeight) == 0x000044, "Member 'FCOVRepairType::SelectionWeight' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilitySlot
// 0x0014 (0x0020 - 0x000C)
struct FOakPlayerAbilitySlot final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakPlayerAbilitySlotData*              SlotData;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UOakPlayerAbility>          AbilityClass;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPlayerAbilitySlot) == 0x000008, "Wrong alignment on FOakPlayerAbilitySlot");
static_assert(sizeof(FOakPlayerAbilitySlot) == 0x000020, "Wrong size on FOakPlayerAbilitySlot");
static_assert(offsetof(FOakPlayerAbilitySlot, SlotData) == 0x000010, "Member 'FOakPlayerAbilitySlot::SlotData' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySlot, AbilityClass) == 0x000018, "Member 'FOakPlayerAbilitySlot::AbilityClass' has a wrong offset!");

// ScriptStruct OakGame.GbxGFxDialogBoxChoiceInfo
// 0x0030 (0x0030 - 0x0000)
struct FGbxGFxDialogBoxChoiceInfo final
{
public:
	class FText                                   LabelText;                                         // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputAction;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloseDialogOnSelection;                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressToHoldChoice;                                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxDialogBoxChoiceInfo) == 0x000008, "Wrong alignment on FGbxGFxDialogBoxChoiceInfo");
static_assert(sizeof(FGbxGFxDialogBoxChoiceInfo) == 0x000030, "Wrong size on FGbxGFxDialogBoxChoiceInfo");
static_assert(offsetof(FGbxGFxDialogBoxChoiceInfo, LabelText) == 0x000000, "Member 'FGbxGFxDialogBoxChoiceInfo::LabelText' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxChoiceInfo, ActionName) == 0x000018, "Member 'FGbxGFxDialogBoxChoiceInfo::ActionName' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxChoiceInfo, InputAction) == 0x000020, "Member 'FGbxGFxDialogBoxChoiceInfo::InputAction' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxChoiceInfo, bCloseDialogOnSelection) == 0x000028, "Member 'FGbxGFxDialogBoxChoiceInfo::bCloseDialogOnSelection' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxChoiceInfo, bPressToHoldChoice) == 0x000029, "Member 'FGbxGFxDialogBoxChoiceInfo::bPressToHoldChoice' has a wrong offset!");

// ScriptStruct OakGame.GbxGFxDialogBoxInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FGbxGFxDialogBoxInfo final
{
public:
	class FText                                   HeaderText;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FGbxGFxDialogBoxChoiceInfo>     Choices;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxDialogBox* SourceDialog, class FName ChoiceNameId, struct FGbxMenuInputEvent& InputInfo)> OnChoiceMade;                                      // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bKeybindingAllowGamepadInputs;                     // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeybindingAllowMouseKeyboardInputs;               // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxDialogBoxStyle                         DialogBoxStyle;                                    // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InputText;                                         // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCanCloseWhenChoicesArrayIsEmpty;                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputTextField;                                   // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPasswordTextField;                                // 0x0082(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyUserCanInteract;                               // 0x0083(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCancel;                                        // 0x0084(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressSpawnSound;                               // 0x0085(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InitialChoice;                                     // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialChoiceIndex;                                // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxDialogBoxButtonType                    ButtonType;                                        // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxPlayerController*                   TargetPC;                                          // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCloseWhenAnotherLocalPlayerLeaves;           // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxDialogBoxData*                   OverrideDefaultTemplate;                           // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x40];                                      // 0x00B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxDialogBoxInfo) == 0x000008, "Wrong alignment on FGbxGFxDialogBoxInfo");
static_assert(sizeof(FGbxGFxDialogBoxInfo) == 0x0000F0, "Wrong size on FGbxGFxDialogBoxInfo");
static_assert(offsetof(FGbxGFxDialogBoxInfo, HeaderText) == 0x000000, "Member 'FGbxGFxDialogBoxInfo::HeaderText' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, BodyText) == 0x000018, "Member 'FGbxGFxDialogBoxInfo::BodyText' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, Choices) == 0x000030, "Member 'FGbxGFxDialogBoxInfo::Choices' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, OnChoiceMade) == 0x000040, "Member 'FGbxGFxDialogBoxInfo::OnChoiceMade' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bKeybindingAllowGamepadInputs) == 0x000060, "Member 'FGbxGFxDialogBoxInfo::bKeybindingAllowGamepadInputs' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bKeybindingAllowMouseKeyboardInputs) == 0x000061, "Member 'FGbxGFxDialogBoxInfo::bKeybindingAllowMouseKeyboardInputs' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, DialogBoxStyle) == 0x000062, "Member 'FGbxGFxDialogBoxInfo::DialogBoxStyle' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, InputText) == 0x000068, "Member 'FGbxGFxDialogBoxInfo::InputText' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bCanCloseWhenChoicesArrayIsEmpty) == 0x000080, "Member 'FGbxGFxDialogBoxInfo::bCanCloseWhenChoicesArrayIsEmpty' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bInputTextField) == 0x000081, "Member 'FGbxGFxDialogBoxInfo::bInputTextField' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bPasswordTextField) == 0x000082, "Member 'FGbxGFxDialogBoxInfo::bPasswordTextField' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bAnyUserCanInteract) == 0x000083, "Member 'FGbxGFxDialogBoxInfo::bAnyUserCanInteract' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bCanCancel) == 0x000084, "Member 'FGbxGFxDialogBoxInfo::bCanCancel' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bSuppressSpawnSound) == 0x000085, "Member 'FGbxGFxDialogBoxInfo::bSuppressSpawnSound' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, InitialChoice) == 0x000088, "Member 'FGbxGFxDialogBoxInfo::InitialChoice' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, InitialChoiceIndex) == 0x000090, "Member 'FGbxGFxDialogBoxInfo::InitialChoiceIndex' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, ButtonType) == 0x000094, "Member 'FGbxGFxDialogBoxInfo::ButtonType' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, TargetPC) == 0x000098, "Member 'FGbxGFxDialogBoxInfo::TargetPC' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, bAllowCloseWhenAnotherLocalPlayerLeaves) == 0x0000A0, "Member 'FGbxGFxDialogBoxInfo::bAllowCloseWhenAnotherLocalPlayerLeaves' has a wrong offset!");
static_assert(offsetof(FGbxGFxDialogBoxInfo, OverrideDefaultTemplate) == 0x0000A8, "Member 'FGbxGFxDialogBoxInfo::OverrideDefaultTemplate' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityResourceController_SirenRushStack
// 0x0010 (0x0028 - 0x0018)
struct FOakAbilityResourceController_SirenRushStack final : public FGbxAbilityResourceController
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityResourceController_SirenRushStack) == 0x000008, "Wrong alignment on FOakAbilityResourceController_SirenRushStack");
static_assert(sizeof(FOakAbilityResourceController_SirenRushStack) == 0x000028, "Wrong size on FOakAbilityResourceController_SirenRushStack");

// ScriptStruct OakGame.GFxCrewQuartersMoodMenuMoodInfo
// 0x000C (0x000C - 0x0000)
struct FGFxCrewQuartersMoodMenuMoodInfo final
{
public:
	TWeakObjectPtr<class UDynamicRoomBaseData>    RoomBaseData;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxCrewQuartersMoodMenuMoodInfo) == 0x000004, "Wrong alignment on FGFxCrewQuartersMoodMenuMoodInfo");
static_assert(sizeof(FGFxCrewQuartersMoodMenuMoodInfo) == 0x00000C, "Wrong size on FGFxCrewQuartersMoodMenuMoodInfo");
static_assert(offsetof(FGFxCrewQuartersMoodMenuMoodInfo, RoomBaseData) == 0x000000, "Member 'FGFxCrewQuartersMoodMenuMoodInfo::RoomBaseData' has a wrong offset!");
static_assert(offsetof(FGFxCrewQuartersMoodMenuMoodInfo, bIsLocked) == 0x000008, "Member 'FGFxCrewQuartersMoodMenuMoodInfo::bIsLocked' has a wrong offset!");
static_assert(offsetof(FGFxCrewQuartersMoodMenuMoodInfo, bIsNew) == 0x000009, "Member 'FGFxCrewQuartersMoodMenuMoodInfo::bIsNew' has a wrong offset!");

// ScriptStruct OakGame.OakProfileMenuTutorialInfo
// 0x0018 (0x0018 - 0x0000)
struct FOakProfileMenuTutorialInfo final
{
public:
	TArray<class FName>                           SeenTutorials;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTutorialsDisabled;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTutorialsAllowedInNonGameModes;                   // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenFastTravelPrompt;                          // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakProfileMenuTutorialInfo) == 0x000008, "Wrong alignment on FOakProfileMenuTutorialInfo");
static_assert(sizeof(FOakProfileMenuTutorialInfo) == 0x000018, "Wrong size on FOakProfileMenuTutorialInfo");
static_assert(offsetof(FOakProfileMenuTutorialInfo, SeenTutorials) == 0x000000, "Member 'FOakProfileMenuTutorialInfo::SeenTutorials' has a wrong offset!");
static_assert(offsetof(FOakProfileMenuTutorialInfo, bTutorialsDisabled) == 0x000010, "Member 'FOakProfileMenuTutorialInfo::bTutorialsDisabled' has a wrong offset!");
static_assert(offsetof(FOakProfileMenuTutorialInfo, bTutorialsAllowedInNonGameModes) == 0x000011, "Member 'FOakProfileMenuTutorialInfo::bTutorialsAllowedInNonGameModes' has a wrong offset!");
static_assert(offsetof(FOakProfileMenuTutorialInfo, bHasSeenFastTravelPrompt) == 0x000012, "Member 'FOakProfileMenuTutorialInfo::bHasSeenFastTravelPrompt' has a wrong offset!");

// ScriptStruct OakGame.GbxInputEvent_OakMoveAxis
// 0x0000 (0x0070 - 0x0070)
struct FGbxInputEvent_OakMoveAxis final : public FGbxInputEvent_Axis_Core
{
};
static_assert(alignof(FGbxInputEvent_OakMoveAxis) == 0x000008, "Wrong alignment on FGbxInputEvent_OakMoveAxis");
static_assert(sizeof(FGbxInputEvent_OakMoveAxis) == 0x000070, "Wrong size on FGbxInputEvent_OakMoveAxis");

// ScriptStruct OakGame.WeightedWeaponUIStat
// 0x0020 (0x0020 - 0x0000)
struct FWeightedWeaponUIStat final
{
public:
	struct FFloatInterval                         NormalizationRange;                                // 0x0000(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      Attribute;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIStatValueStyle                             ValueStyle;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviewPercentWeight;                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedWeaponUIStat) == 0x000008, "Wrong alignment on FWeightedWeaponUIStat");
static_assert(sizeof(FWeightedWeaponUIStat) == 0x000020, "Wrong size on FWeightedWeaponUIStat");
static_assert(offsetof(FWeightedWeaponUIStat, NormalizationRange) == 0x000000, "Member 'FWeightedWeaponUIStat::NormalizationRange' has a wrong offset!");
static_assert(offsetof(FWeightedWeaponUIStat, Attribute) == 0x000008, "Member 'FWeightedWeaponUIStat::Attribute' has a wrong offset!");
static_assert(offsetof(FWeightedWeaponUIStat, ValueStyle) == 0x000010, "Member 'FWeightedWeaponUIStat::ValueStyle' has a wrong offset!");
static_assert(offsetof(FWeightedWeaponUIStat, Weight) == 0x000014, "Member 'FWeightedWeaponUIStat::Weight' has a wrong offset!");
static_assert(offsetof(FWeightedWeaponUIStat, PreviewPercentWeight) == 0x000018, "Member 'FWeightedWeaponUIStat::PreviewPercentWeight' has a wrong offset!");

// ScriptStruct OakGame.GbxInputEvent_OakUIAxis
// 0x0010 (0x0080 - 0x0070)
struct FGbxInputEvent_OakUIAxis final : public FGbxInputEvent_Axis_Core
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldTime;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxInputEvent_OakUIAxis) == 0x000008, "Wrong alignment on FGbxInputEvent_OakUIAxis");
static_assert(sizeof(FGbxInputEvent_OakUIAxis) == 0x000080, "Wrong size on FGbxInputEvent_OakUIAxis");
static_assert(offsetof(FGbxInputEvent_OakUIAxis, HoldTime) == 0x000078, "Member 'FGbxInputEvent_OakUIAxis::HoldTime' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakPlayerMelee
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakPlayerMelee final : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakPlayerMelee) == 0x000008, "Wrong alignment on FActionState_OakPlayerMelee");
static_assert(sizeof(FActionState_OakPlayerMelee) == 0x000520, "Wrong size on FActionState_OakPlayerMelee");

// ScriptStruct OakGame.DeathCircleStageData
// 0x00A8 (0x00A8 - 0x0000)
struct FDeathCircleStageData final
{
public:
	struct FAttributeInitializationData           Radius;                                            // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           StableSeconds;                                     // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           TransitionSeconds;                                 // 0x0070(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathCircleStageData) == 0x000008, "Wrong alignment on FDeathCircleStageData");
static_assert(sizeof(FDeathCircleStageData) == 0x0000A8, "Wrong size on FDeathCircleStageData");
static_assert(offsetof(FDeathCircleStageData, Radius) == 0x000000, "Member 'FDeathCircleStageData::Radius' has a wrong offset!");
static_assert(offsetof(FDeathCircleStageData, StableSeconds) == 0x000038, "Member 'FDeathCircleStageData::StableSeconds' has a wrong offset!");
static_assert(offsetof(FDeathCircleStageData, TransitionSeconds) == 0x000070, "Member 'FDeathCircleStageData::TransitionSeconds' has a wrong offset!");

// ScriptStruct OakGame.InventoryPartDataUnlockedInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FInventoryPartDataUnlockedInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryPartDataUnlockedInfo) == 0x000008, "Wrong alignment on FInventoryPartDataUnlockedInfo");
static_assert(sizeof(FInventoryPartDataUnlockedInfo) == 0x000030, "Wrong size on FInventoryPartDataUnlockedInfo");

// ScriptStruct OakGame.IronBearAnimInstanceProxy_FirstPerson
// 0x0000 (0x06E0 - 0x06E0)
struct FIronBearAnimInstanceProxy_FirstPerson final : public FOakPlayerAnimInstanceProxy
{
};
static_assert(alignof(FIronBearAnimInstanceProxy_FirstPerson) == 0x000010, "Wrong alignment on FIronBearAnimInstanceProxy_FirstPerson");
static_assert(sizeof(FIronBearAnimInstanceProxy_FirstPerson) == 0x0006E0, "Wrong size on FIronBearAnimInstanceProxy_FirstPerson");

// ScriptStruct OakGame.GFxBackpackWidgetConfig
// 0x0118 (0x0118 - 0x0000)
struct FGFxBackpackWidgetConfig final
{
public:
	class FString                                 GridWidgetPath;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxGFxListConfig                      GridWidgetConfig;                                  // 0x0010(0x0090)(Edit, NativeAccessSpecifierPublic)
	int32                                         ItemBackpackSpaceMinIfInfinite;                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBackpackIconsToKeep;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemBackpackSpaceMinLocked;                        // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinVisibleCells;                                   // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCellsToPreCreate;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BackpackItemScaleformClass;                        // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EmptyBackpackItemScaleformClass;                   // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGFxBackpackWidgetItem>     ListItemNativeClass;                               // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ButtonHelpText;                                    // 0x00E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseTrashButtonStates;                             // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AOakPlayerController>    OakPC;                                             // 0x00FC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxGFxMovie>            OwningMovie;                                       // 0x0104(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxGFxObject>           GridWidgetParent;                                  // 0x010C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxBackpackWidgetConfig) == 0x000008, "Wrong alignment on FGFxBackpackWidgetConfig");
static_assert(sizeof(FGFxBackpackWidgetConfig) == 0x000118, "Wrong size on FGFxBackpackWidgetConfig");
static_assert(offsetof(FGFxBackpackWidgetConfig, GridWidgetPath) == 0x000000, "Member 'FGFxBackpackWidgetConfig::GridWidgetPath' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, GridWidgetConfig) == 0x000010, "Member 'FGFxBackpackWidgetConfig::GridWidgetConfig' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, ItemBackpackSpaceMinIfInfinite) == 0x0000A0, "Member 'FGFxBackpackWidgetConfig::ItemBackpackSpaceMinIfInfinite' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, NumBackpackIconsToKeep) == 0x0000A4, "Member 'FGFxBackpackWidgetConfig::NumBackpackIconsToKeep' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, ItemBackpackSpaceMinLocked) == 0x0000A8, "Member 'FGFxBackpackWidgetConfig::ItemBackpackSpaceMinLocked' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, MinVisibleCells) == 0x0000AC, "Member 'FGFxBackpackWidgetConfig::MinVisibleCells' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, NumCellsToPreCreate) == 0x0000B0, "Member 'FGFxBackpackWidgetConfig::NumCellsToPreCreate' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, BackpackItemScaleformClass) == 0x0000B8, "Member 'FGFxBackpackWidgetConfig::BackpackItemScaleformClass' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, EmptyBackpackItemScaleformClass) == 0x0000C8, "Member 'FGFxBackpackWidgetConfig::EmptyBackpackItemScaleformClass' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, ListItemNativeClass) == 0x0000D8, "Member 'FGFxBackpackWidgetConfig::ListItemNativeClass' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, ButtonHelpText) == 0x0000E0, "Member 'FGFxBackpackWidgetConfig::ButtonHelpText' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, bUseTrashButtonStates) == 0x0000F8, "Member 'FGFxBackpackWidgetConfig::bUseTrashButtonStates' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, OakPC) == 0x0000FC, "Member 'FGFxBackpackWidgetConfig::OakPC' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, OwningMovie) == 0x000104, "Member 'FGFxBackpackWidgetConfig::OwningMovie' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidgetConfig, GridWidgetParent) == 0x00010C, "Member 'FGFxBackpackWidgetConfig::GridWidgetParent' has a wrong offset!");

// ScriptStruct OakGame.GFxBackpackWidget
// 0x0198 (0x0198 - 0x0000)
struct FGFxBackpackWidget final
{
public:
	UMulticastDelegateProperty_                   ItemSelectedDelegate;                              // 0x0000(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ItemClickedDelegate;                               // 0x0010(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ItemPressedDelegate;                               // 0x0020(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOakThumbnailManager>    ThumbnailManager;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bThumbnailMangerIsExternal;                        // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIGlobals>              UIGlobals;                                         // 0x003C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGFxBackpackWidgetConfig               Config;                                            // 0x0048(0x0118)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FOakUIInventoryItemDisplayInfo> Items;                                             // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UGbxGFxGridScrollingList*               GridWidget;                                        // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxBackpackWidgetListener*             Listener;                                          // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInited;                                         // 0x0180(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FirstBackpackItemOfInterest;                       // 0x0184(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UGFxBackpackWidgetItem>  LastSelectedBackpackItem;                          // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedsThumbnailsRefreshed;                         // 0x0190(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoNotManageThumbnailSweeping;                     // 0x0191(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedsSweep;                                       // 0x0192(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_193[0x5];                                      // 0x0193(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxBackpackWidget) == 0x000008, "Wrong alignment on FGFxBackpackWidget");
static_assert(sizeof(FGFxBackpackWidget) == 0x000198, "Wrong size on FGFxBackpackWidget");
static_assert(offsetof(FGFxBackpackWidget, ItemSelectedDelegate) == 0x000000, "Member 'FGFxBackpackWidget::ItemSelectedDelegate' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, ItemClickedDelegate) == 0x000010, "Member 'FGFxBackpackWidget::ItemClickedDelegate' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, ItemPressedDelegate) == 0x000020, "Member 'FGFxBackpackWidget::ItemPressedDelegate' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, ThumbnailManager) == 0x000030, "Member 'FGFxBackpackWidget::ThumbnailManager' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, bThumbnailMangerIsExternal) == 0x000038, "Member 'FGFxBackpackWidget::bThumbnailMangerIsExternal' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, UIGlobals) == 0x00003C, "Member 'FGFxBackpackWidget::UIGlobals' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, Config) == 0x000048, "Member 'FGFxBackpackWidget::Config' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, Items) == 0x000160, "Member 'FGFxBackpackWidget::Items' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, GridWidget) == 0x000170, "Member 'FGFxBackpackWidget::GridWidget' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, Listener) == 0x000178, "Member 'FGFxBackpackWidget::Listener' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, bIsInited) == 0x000180, "Member 'FGFxBackpackWidget::bIsInited' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, FirstBackpackItemOfInterest) == 0x000184, "Member 'FGFxBackpackWidget::FirstBackpackItemOfInterest' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, LastSelectedBackpackItem) == 0x000188, "Member 'FGFxBackpackWidget::LastSelectedBackpackItem' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, bNeedsThumbnailsRefreshed) == 0x000190, "Member 'FGFxBackpackWidget::bNeedsThumbnailsRefreshed' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, bDoNotManageThumbnailSweeping) == 0x000191, "Member 'FGFxBackpackWidget::bDoNotManageThumbnailSweeping' has a wrong offset!");
static_assert(offsetof(FGFxBackpackWidget, bNeedsSweep) == 0x000192, "Member 'FGFxBackpackWidget::bNeedsSweep' has a wrong offset!");

// ScriptStruct OakGame.GFxCARMenuListData
// 0x0198 (0x0198 - 0x0000)
struct FGFxCARMenuListData final
{
public:
	class FString                                 ListClipName;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxGFxPooledGridListFullConfig        ListConfig;                                        // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
	struct FGbxGFxPooledGridListFullConfig        ListConfigSplitScreen;                             // 0x00D0(0x00C0)(Edit, NativeAccessSpecifierPublic)
	class UGbxGFxPooledGridList*                  List;                                              // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxCARMenuListData) == 0x000008, "Wrong alignment on FGFxCARMenuListData");
static_assert(sizeof(FGFxCARMenuListData) == 0x000198, "Wrong size on FGFxCARMenuListData");
static_assert(offsetof(FGFxCARMenuListData, ListClipName) == 0x000000, "Member 'FGFxCARMenuListData::ListClipName' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuListData, ListConfig) == 0x000010, "Member 'FGFxCARMenuListData::ListConfig' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuListData, ListConfigSplitScreen) == 0x0000D0, "Member 'FGFxCARMenuListData::ListConfigSplitScreen' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuListData, List) == 0x000190, "Member 'FGFxCARMenuListData::List' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityEnumMaskHelper
// 0x0004 (0x0004 - 0x0000)
struct FOakActionAbilityEnumMaskHelper final
{
public:
	uint32                                        Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityEnumMaskHelper) == 0x000004, "Wrong alignment on FOakActionAbilityEnumMaskHelper");
static_assert(sizeof(FOakActionAbilityEnumMaskHelper) == 0x000004, "Wrong size on FOakActionAbilityEnumMaskHelper");
static_assert(offsetof(FOakActionAbilityEnumMaskHelper, Value) == 0x000000, "Member 'FOakActionAbilityEnumMaskHelper::Value' has a wrong offset!");

// ScriptStruct OakGame.GFxBuddyWidgetAnimQueueItem
// 0x0010 (0x0010 - 0x0000)
struct FGFxBuddyWidgetAnimQueueItem final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxBuddyWidgetAnimQueueItem) == 0x000008, "Wrong alignment on FGFxBuddyWidgetAnimQueueItem");
static_assert(sizeof(FGFxBuddyWidgetAnimQueueItem) == 0x000010, "Wrong size on FGFxBuddyWidgetAnimQueueItem");
static_assert(offsetof(FGFxBuddyWidgetAnimQueueItem, TargetActor) == 0x000000, "Member 'FGFxBuddyWidgetAnimQueueItem::TargetActor' has a wrong offset!");

// ScriptStruct OakGame.GFxCARPreviewData
// 0x0060 (0x0060 - 0x0000)
struct FGFxCARPreviewData final
{
public:
	class UOakCARVehicleData*                     Vehicle;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOakCARVehiclePartData*>         Parts;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UOakCARVehicleData*                     SelectedVehicle;                                   // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakCARVehiclePartData*                 SelectedPart;                                      // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CEToPlay;                                          // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxCARPreviewData) == 0x000008, "Wrong alignment on FGFxCARPreviewData");
static_assert(sizeof(FGFxCARPreviewData) == 0x000060, "Wrong size on FGFxCARPreviewData");
static_assert(offsetof(FGFxCARPreviewData, Vehicle) == 0x000000, "Member 'FGFxCARPreviewData::Vehicle' has a wrong offset!");
static_assert(offsetof(FGFxCARPreviewData, Parts) == 0x000008, "Member 'FGFxCARPreviewData::Parts' has a wrong offset!");
static_assert(offsetof(FGFxCARPreviewData, SelectedVehicle) == 0x000018, "Member 'FGFxCARPreviewData::SelectedVehicle' has a wrong offset!");
static_assert(offsetof(FGFxCARPreviewData, SelectedPart) == 0x000020, "Member 'FGFxCARPreviewData::SelectedPart' has a wrong offset!");
static_assert(offsetof(FGFxCARPreviewData, CEToPlay) == 0x000028, "Member 'FGFxCARPreviewData::CEToPlay' has a wrong offset!");

// ScriptStruct OakGame.GFxCARMenuLoadAssetInfo
// 0x0028 (0x0028 - 0x0000)
struct FGFxCARMenuLoadAssetInfo final
{
public:
	struct FSoftObjectPath                        StringAssetRef;                                    // 0x0000(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxCARMenuLoadAssetInfo) == 0x000008, "Wrong alignment on FGFxCARMenuLoadAssetInfo");
static_assert(sizeof(FGFxCARMenuLoadAssetInfo) == 0x000028, "Wrong size on FGFxCARMenuLoadAssetInfo");
static_assert(offsetof(FGFxCARMenuLoadAssetInfo, StringAssetRef) == 0x000000, "Member 'FGFxCARMenuLoadAssetInfo::StringAssetRef' has a wrong offset!");

// ScriptStruct OakGame.GFxCARMenuCustomizePageConfig
// 0x0020 (0x0020 - 0x0000)
struct FGFxCARMenuCustomizePageConfig final
{
public:
	class UGFxCARMenu*                            CARMenuOwner;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVehicleSpawnerComponent*               VehicleSpawner;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxPooledGridList*                  ItemList;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOakCARMenuPartType                    PartType;                                          // 0x0018(0x0002)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanSelectEmpty;                                   // 0x001A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxCARMenuCustomizePageConfig) == 0x000008, "Wrong alignment on FGFxCARMenuCustomizePageConfig");
static_assert(sizeof(FGFxCARMenuCustomizePageConfig) == 0x000020, "Wrong size on FGFxCARMenuCustomizePageConfig");
static_assert(offsetof(FGFxCARMenuCustomizePageConfig, CARMenuOwner) == 0x000000, "Member 'FGFxCARMenuCustomizePageConfig::CARMenuOwner' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuCustomizePageConfig, VehicleSpawner) == 0x000008, "Member 'FGFxCARMenuCustomizePageConfig::VehicleSpawner' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuCustomizePageConfig, ItemList) == 0x000010, "Member 'FGFxCARMenuCustomizePageConfig::ItemList' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuCustomizePageConfig, PartType) == 0x000018, "Member 'FGFxCARMenuCustomizePageConfig::PartType' has a wrong offset!");
static_assert(offsetof(FGFxCARMenuCustomizePageConfig, bCanSelectEmpty) == 0x00001A, "Member 'FGFxCARMenuCustomizePageConfig::bCanSelectEmpty' has a wrong offset!");

// ScriptStruct OakGame.GFxChallengeProgressItem
// 0x00B8 (0x00B8 - 0x0000)
struct FGFxChallengeProgressItem final
{
public:
	class FText                                   FirstChallengeName;                                // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   SecondChallengeName;                               // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	bool                                          bHasNameTransitioned;                              // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FirstDescription;                                  // 0x0038(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   SecondDescription;                                 // 0x0050(0x0018)(Transient, NativeAccessSpecifierPublic)
	bool                                          bHasDescriptionTransitioned;                       // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FirstTypeIconFrame;                                // 0x0070(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecondTypeIconFrame;                               // 0x0080(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasIconTransitioned;                              // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewAsPercent;                                    // 0x0091(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewOneOffCompletionNotProgress;                  // 0x0092(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressPctToStartAnimFrom;                        // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressOutOfValue;                                // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressOutOfMax;                                  // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChallengeWasCompleted;                            // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPercentCompleteTransitioned;                   // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UChallenge>                 ChallengeClass;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddedAsProgressOfChildChallenge;                  // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParentRanking;                                     // 0x00B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxChallengeProgressItem) == 0x000008, "Wrong alignment on FGFxChallengeProgressItem");
static_assert(sizeof(FGFxChallengeProgressItem) == 0x0000B8, "Wrong size on FGFxChallengeProgressItem");
static_assert(offsetof(FGFxChallengeProgressItem, FirstChallengeName) == 0x000000, "Member 'FGFxChallengeProgressItem::FirstChallengeName' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, SecondChallengeName) == 0x000018, "Member 'FGFxChallengeProgressItem::SecondChallengeName' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bHasNameTransitioned) == 0x000030, "Member 'FGFxChallengeProgressItem::bHasNameTransitioned' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, FirstDescription) == 0x000038, "Member 'FGFxChallengeProgressItem::FirstDescription' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, SecondDescription) == 0x000050, "Member 'FGFxChallengeProgressItem::SecondDescription' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bHasDescriptionTransitioned) == 0x000068, "Member 'FGFxChallengeProgressItem::bHasDescriptionTransitioned' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, FirstTypeIconFrame) == 0x000070, "Member 'FGFxChallengeProgressItem::FirstTypeIconFrame' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, SecondTypeIconFrame) == 0x000080, "Member 'FGFxChallengeProgressItem::SecondTypeIconFrame' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bHasIconTransitioned) == 0x000090, "Member 'FGFxChallengeProgressItem::bHasIconTransitioned' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bViewAsPercent) == 0x000091, "Member 'FGFxChallengeProgressItem::bViewAsPercent' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bViewOneOffCompletionNotProgress) == 0x000092, "Member 'FGFxChallengeProgressItem::bViewOneOffCompletionNotProgress' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, ProgressPctToStartAnimFrom) == 0x000094, "Member 'FGFxChallengeProgressItem::ProgressPctToStartAnimFrom' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, ProgressOutOfValue) == 0x000098, "Member 'FGFxChallengeProgressItem::ProgressOutOfValue' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, ProgressOutOfMax) == 0x00009C, "Member 'FGFxChallengeProgressItem::ProgressOutOfMax' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bChallengeWasCompleted) == 0x0000A0, "Member 'FGFxChallengeProgressItem::bChallengeWasCompleted' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bHasPercentCompleteTransitioned) == 0x0000A1, "Member 'FGFxChallengeProgressItem::bHasPercentCompleteTransitioned' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, ChallengeClass) == 0x0000A8, "Member 'FGFxChallengeProgressItem::ChallengeClass' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, bAddedAsProgressOfChildChallenge) == 0x0000B0, "Member 'FGFxChallengeProgressItem::bAddedAsProgressOfChildChallenge' has a wrong offset!");
static_assert(offsetof(FGFxChallengeProgressItem, ParentRanking) == 0x0000B4, "Member 'FGFxChallengeProgressItem::ParentRanking' has a wrong offset!");

// ScriptStruct OakGame.CreditsImageData
// 0x0020 (0x0020 - 0x0000)
struct FCreditsImageData final
{
public:
	struct FSoftObjectPath                        CreditsImage;                                      // 0x0000(0x0018)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImageShowTime;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImageMaxTime;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditsImageData) == 0x000008, "Wrong alignment on FCreditsImageData");
static_assert(sizeof(FCreditsImageData) == 0x000020, "Wrong size on FCreditsImageData");
static_assert(offsetof(FCreditsImageData, CreditsImage) == 0x000000, "Member 'FCreditsImageData::CreditsImage' has a wrong offset!");
static_assert(offsetof(FCreditsImageData, ImageShowTime) == 0x000018, "Member 'FCreditsImageData::ImageShowTime' has a wrong offset!");
static_assert(offsetof(FCreditsImageData, ImageMaxTime) == 0x00001C, "Member 'FCreditsImageData::ImageMaxTime' has a wrong offset!");

// ScriptStruct OakGame.CreditsSection
// 0x0050 (0x0050 - 0x0000)
struct FCreditsSection final
{
public:
	TArray<class UCreditsDataAsset*>              CreditsDataAssets;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCreditsImageData>              CreditsImageDataList;                              // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TransitionTimeBetweenImages;                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSpacing;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserAnimationSpeed;                                // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultAnimationSpeed;                             // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseTime;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowScrollingCredits;                            // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollingDelay;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAfterLastCredit;                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            BackgroundMusicStartEvent;                         // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            BackgroundMusicEndEvent;                           // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditsSection) == 0x000008, "Wrong alignment on FCreditsSection");
static_assert(sizeof(FCreditsSection) == 0x000050, "Wrong size on FCreditsSection");
static_assert(offsetof(FCreditsSection, CreditsDataAssets) == 0x000000, "Member 'FCreditsSection::CreditsDataAssets' has a wrong offset!");
static_assert(offsetof(FCreditsSection, CreditsImageDataList) == 0x000010, "Member 'FCreditsSection::CreditsImageDataList' has a wrong offset!");
static_assert(offsetof(FCreditsSection, TransitionTimeBetweenImages) == 0x000020, "Member 'FCreditsSection::TransitionTimeBetweenImages' has a wrong offset!");
static_assert(offsetof(FCreditsSection, HorizontalSpacing) == 0x000024, "Member 'FCreditsSection::HorizontalSpacing' has a wrong offset!");
static_assert(offsetof(FCreditsSection, UserAnimationSpeed) == 0x000028, "Member 'FCreditsSection::UserAnimationSpeed' has a wrong offset!");
static_assert(offsetof(FCreditsSection, DefaultAnimationSpeed) == 0x00002C, "Member 'FCreditsSection::DefaultAnimationSpeed' has a wrong offset!");
static_assert(offsetof(FCreditsSection, PauseTime) == 0x000030, "Member 'FCreditsSection::PauseTime' has a wrong offset!");
static_assert(offsetof(FCreditsSection, bAllowScrollingCredits) == 0x000034, "Member 'FCreditsSection::bAllowScrollingCredits' has a wrong offset!");
static_assert(offsetof(FCreditsSection, ScrollingDelay) == 0x000038, "Member 'FCreditsSection::ScrollingDelay' has a wrong offset!");
static_assert(offsetof(FCreditsSection, DelayAfterLastCredit) == 0x00003C, "Member 'FCreditsSection::DelayAfterLastCredit' has a wrong offset!");
static_assert(offsetof(FCreditsSection, BackgroundMusicStartEvent) == 0x000040, "Member 'FCreditsSection::BackgroundMusicStartEvent' has a wrong offset!");
static_assert(offsetof(FCreditsSection, BackgroundMusicEndEvent) == 0x000048, "Member 'FCreditsSection::BackgroundMusicEndEvent' has a wrong offset!");

// ScriptStruct OakGame.BodyMeshLinkedParameters
// 0x0020 (0x0020 - 0x0000)
struct FBodyMeshLinkedParameters final
{
public:
	TArray<TSubclassOf<class AOakCharacter>>      OwnerClasses;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationLinkedParameter>  LinkedParameters;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodyMeshLinkedParameters) == 0x000008, "Wrong alignment on FBodyMeshLinkedParameters");
static_assert(sizeof(FBodyMeshLinkedParameters) == 0x000020, "Wrong size on FBodyMeshLinkedParameters");
static_assert(offsetof(FBodyMeshLinkedParameters, OwnerClasses) == 0x000000, "Member 'FBodyMeshLinkedParameters::OwnerClasses' has a wrong offset!");
static_assert(offsetof(FBodyMeshLinkedParameters, LinkedParameters) == 0x000010, "Member 'FBodyMeshLinkedParameters::LinkedParameters' has a wrong offset!");

// ScriptStruct OakGame.MissionStatusPlayerSaveGameData
// 0x0078 (0x0078 - 0x0000)
struct FMissionStatusPlayerSaveGameData final
{
public:
	EMissionStatus                                Status;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenViewedInLog;                               // 0x0001(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickoffPlayed;                                    // 0x0002(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                ObjectivesProgress;                                // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         LeagueInstance;                                    // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   MissionClassPath;                                  // 0x0020(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UMissionObjectiveSet>    ActiveObjectiveSetPath;                            // 0x0048(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        DlcPackageId;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionStatusPlayerSaveGameData) == 0x000008, "Wrong alignment on FMissionStatusPlayerSaveGameData");
static_assert(sizeof(FMissionStatusPlayerSaveGameData) == 0x000078, "Wrong size on FMissionStatusPlayerSaveGameData");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, Status) == 0x000000, "Member 'FMissionStatusPlayerSaveGameData::Status' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, bHasBeenViewedInLog) == 0x000001, "Member 'FMissionStatusPlayerSaveGameData::bHasBeenViewedInLog' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, bKickoffPlayed) == 0x000002, "Member 'FMissionStatusPlayerSaveGameData::bKickoffPlayed' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, ObjectivesProgress) == 0x000008, "Member 'FMissionStatusPlayerSaveGameData::ObjectivesProgress' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, LeagueInstance) == 0x000018, "Member 'FMissionStatusPlayerSaveGameData::LeagueInstance' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, MissionClassPath) == 0x000020, "Member 'FMissionStatusPlayerSaveGameData::MissionClassPath' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, ActiveObjectiveSetPath) == 0x000048, "Member 'FMissionStatusPlayerSaveGameData::ActiveObjectiveSetPath' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerSaveGameData, DlcPackageId) == 0x000070, "Member 'FMissionStatusPlayerSaveGameData::DlcPackageId' has a wrong offset!");

// ScriptStruct OakGame.MissionPlaythroughSaveGameData
// 0x0038 (0x0038 - 0x0000)
struct FMissionPlaythroughSaveGameData final
{
public:
	TArray<struct FMissionStatusPlayerSaveGameData> MissionList;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TrackedMissionClassPath;                           // 0x0010(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMissionPlaythroughSaveGameData) == 0x000008, "Wrong alignment on FMissionPlaythroughSaveGameData");
static_assert(sizeof(FMissionPlaythroughSaveGameData) == 0x000038, "Wrong size on FMissionPlaythroughSaveGameData");
static_assert(offsetof(FMissionPlaythroughSaveGameData, MissionList) == 0x000000, "Member 'FMissionPlaythroughSaveGameData::MissionList' has a wrong offset!");
static_assert(offsetof(FMissionPlaythroughSaveGameData, TrackedMissionClassPath) == 0x000010, "Member 'FMissionPlaythroughSaveGameData::TrackedMissionClassPath' has a wrong offset!");

// ScriptStruct OakGame.ClaptrapSkitSublevel
// 0x0010 (0x0010 - 0x0000)
struct FClaptrapSkitSublevel final
{
public:
	class FName                                   SublevelName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          LoadCondition;                                     // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClaptrapSkitSublevel) == 0x000008, "Wrong alignment on FClaptrapSkitSublevel");
static_assert(sizeof(FClaptrapSkitSublevel) == 0x000010, "Wrong size on FClaptrapSkitSublevel");
static_assert(offsetof(FClaptrapSkitSublevel, SublevelName) == 0x000000, "Member 'FClaptrapSkitSublevel::SublevelName' has a wrong offset!");
static_assert(offsetof(FClaptrapSkitSublevel, LoadCondition) == 0x000008, "Member 'FClaptrapSkitSublevel::LoadCondition' has a wrong offset!");

// ScriptStruct OakGame.CreditsRangeIndex
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FCreditsRangeIndex final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditsRangeIndex) == 0x000004, "Wrong alignment on FCreditsRangeIndex");
static_assert(sizeof(FCreditsRangeIndex) == 0x000010, "Wrong size on FCreditsRangeIndex");

// ScriptStruct OakGame.CreditsTextFieldInfo
// 0x0010 (0x0010 - 0x0000)
struct FCreditsTextFieldInfo final
{
public:
	class FName                                   StyleId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxTextField*                          TextField;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreditsTextFieldInfo) == 0x000008, "Wrong alignment on FCreditsTextFieldInfo");
static_assert(sizeof(FCreditsTextFieldInfo) == 0x000010, "Wrong size on FCreditsTextFieldInfo");
static_assert(offsetof(FCreditsTextFieldInfo, StyleId) == 0x000000, "Member 'FCreditsTextFieldInfo::StyleId' has a wrong offset!");
static_assert(offsetof(FCreditsTextFieldInfo, TextField) == 0x000008, "Member 'FCreditsTextFieldInfo::TextField' has a wrong offset!");

// ScriptStruct OakGame.GFxCurrencyCounterCategoryData
// 0x0010 (0x0010 - 0x0000)
struct FGFxCurrencyCounterCategoryData final
{
public:
	class UInventoryCategoryData*                 ItemCategory;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastValue;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxCurrencyCounterCategoryData) == 0x000008, "Wrong alignment on FGFxCurrencyCounterCategoryData");
static_assert(sizeof(FGFxCurrencyCounterCategoryData) == 0x000010, "Wrong size on FGFxCurrencyCounterCategoryData");
static_assert(offsetof(FGFxCurrencyCounterCategoryData, ItemCategory) == 0x000000, "Member 'FGFxCurrencyCounterCategoryData::ItemCategory' has a wrong offset!");
static_assert(offsetof(FGFxCurrencyCounterCategoryData, LastValue) == 0x000008, "Member 'FGFxCurrencyCounterCategoryData::LastValue' has a wrong offset!");

// ScriptStruct OakGame.StreamingStatusInfo
// 0x0040 (0x0040 - 0x0000)
struct FStreamingStatusInfo final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	bool                                          bIsDescriptionRelevant;                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamingStatusInfo) == 0x000008, "Wrong alignment on FStreamingStatusInfo");
static_assert(sizeof(FStreamingStatusInfo) == 0x000040, "Wrong size on FStreamingStatusInfo");
static_assert(offsetof(FStreamingStatusInfo, Text) == 0x000000, "Member 'FStreamingStatusInfo::Text' has a wrong offset!");
static_assert(offsetof(FStreamingStatusInfo, Color) == 0x000018, "Member 'FStreamingStatusInfo::Color' has a wrong offset!");
static_assert(offsetof(FStreamingStatusInfo, Description) == 0x000020, "Member 'FStreamingStatusInfo::Description' has a wrong offset!");
static_assert(offsetof(FStreamingStatusInfo, bIsDescriptionRelevant) == 0x000038, "Member 'FStreamingStatusInfo::bIsDescriptionRelevant' has a wrong offset!");

// ScriptStruct OakGame.GFxDeulingNotificationRewardWin
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x08) FGFxDeulingNotificationRewardWin final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxDeulingNotificationRewardWin) == 0x000008, "Wrong alignment on FGFxDeulingNotificationRewardWin");
static_assert(sizeof(FGFxDeulingNotificationRewardWin) == 0x0000E0, "Wrong size on FGFxDeulingNotificationRewardWin");

// ScriptStruct OakGame.LocalizationStatus
// 0x00A8 (0x00A8 - 0x0000)
struct FLocalizationStatus final
{
public:
	class FText                                   PanelTitle;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ShiftAccountLabel;                                 // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   StreamingServiceLabel;                             // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AccountNameLabel;                                  // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ExtensionVersionLabel;                             // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ChannelTitleLabel;                                 // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CurrentViewerLabel;                                // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalizationStatus) == 0x000008, "Wrong alignment on FLocalizationStatus");
static_assert(sizeof(FLocalizationStatus) == 0x0000A8, "Wrong size on FLocalizationStatus");
static_assert(offsetof(FLocalizationStatus, PanelTitle) == 0x000000, "Member 'FLocalizationStatus::PanelTitle' has a wrong offset!");
static_assert(offsetof(FLocalizationStatus, ShiftAccountLabel) == 0x000018, "Member 'FLocalizationStatus::ShiftAccountLabel' has a wrong offset!");
static_assert(offsetof(FLocalizationStatus, StreamingServiceLabel) == 0x000030, "Member 'FLocalizationStatus::StreamingServiceLabel' has a wrong offset!");
static_assert(offsetof(FLocalizationStatus, AccountNameLabel) == 0x000048, "Member 'FLocalizationStatus::AccountNameLabel' has a wrong offset!");
static_assert(offsetof(FLocalizationStatus, ExtensionVersionLabel) == 0x000060, "Member 'FLocalizationStatus::ExtensionVersionLabel' has a wrong offset!");
static_assert(offsetof(FLocalizationStatus, ChannelTitleLabel) == 0x000078, "Member 'FLocalizationStatus::ChannelTitleLabel' has a wrong offset!");
static_assert(offsetof(FLocalizationStatus, CurrentViewerLabel) == 0x000090, "Member 'FLocalizationStatus::CurrentViewerLabel' has a wrong offset!");

// ScriptStruct OakGame.GFxGrenadeIndicatorSortItem
// 0x0010 (0x0010 - 0x0000)
struct FGFxGrenadeIndicatorSortItem final
{
public:
	class AOakProjectile*                         Grenade;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistSq;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxGrenadeIndicatorSortItem) == 0x000008, "Wrong alignment on FGFxGrenadeIndicatorSortItem");
static_assert(sizeof(FGFxGrenadeIndicatorSortItem) == 0x000010, "Wrong size on FGFxGrenadeIndicatorSortItem");
static_assert(offsetof(FGFxGrenadeIndicatorSortItem, Grenade) == 0x000000, "Member 'FGFxGrenadeIndicatorSortItem::Grenade' has a wrong offset!");
static_assert(offsetof(FGFxGrenadeIndicatorSortItem, DistSq) == 0x000008, "Member 'FGFxGrenadeIndicatorSortItem::DistSq' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakLeapOnVehicle
// 0x0010 (0x0570 - 0x0560)
struct FActionState_OakLeapOnVehicle final : public FActionState_NavHomingJump
{
public:
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakLeapOnVehicle) == 0x000008, "Wrong alignment on FActionState_OakLeapOnVehicle");
static_assert(sizeof(FActionState_OakLeapOnVehicle) == 0x000570, "Wrong size on FActionState_OakLeapOnVehicle");

// ScriptStruct OakGame.ChallengeCategoryProgressSaveData
// 0x0010 (0x0010 - 0x0000)
struct FChallengeCategoryProgressSaveData final
{
public:
	TArray<uint8>                                 CategoryProgress;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeCategoryProgressSaveData) == 0x000008, "Wrong alignment on FChallengeCategoryProgressSaveData");
static_assert(sizeof(FChallengeCategoryProgressSaveData) == 0x000010, "Wrong size on FChallengeCategoryProgressSaveData");
static_assert(offsetof(FChallengeCategoryProgressSaveData, CategoryProgress) == 0x000000, "Member 'FChallengeCategoryProgressSaveData::CategoryProgress' has a wrong offset!");

// ScriptStruct OakGame.GFxInventoryMenuUnlockLookupItem
// 0x0040 (0x0040 - 0x0000)
struct FGFxInventoryMenuUnlockLookupItem final
{
public:
	TSoftObjectPtr<class UInventoryCategoryData>  InventoryCategory;                                 // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxInventoryMenuUnlockLookupItem) == 0x000008, "Wrong alignment on FGFxInventoryMenuUnlockLookupItem");
static_assert(sizeof(FGFxInventoryMenuUnlockLookupItem) == 0x000040, "Wrong size on FGFxInventoryMenuUnlockLookupItem");
static_assert(offsetof(FGFxInventoryMenuUnlockLookupItem, InventoryCategory) == 0x000000, "Member 'FGFxInventoryMenuUnlockLookupItem::InventoryCategory' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuUnlockLookupItem, DisplayText) == 0x000028, "Member 'FGFxInventoryMenuUnlockLookupItem::DisplayText' has a wrong offset!");

// ScriptStruct OakGame.GFxInventoryMenuEquipToSlot
// 0x00D8 (0x00D8 - 0x0000)
struct FGFxInventoryMenuEquipToSlot final
{
public:
	class UGFxInventoryItemWidget*                ItemWidget;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxInventoryMenuTrinketButton*         TrinketWidget;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          IconWidget;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTrinketEnabled;                                   // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakInventoryMenuPaperDollSlotInfo     SlotInfo;                                          // 0x0038(0x00A0)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxInventoryMenuEquipToSlot) == 0x000008, "Wrong alignment on FGFxInventoryMenuEquipToSlot");
static_assert(sizeof(FGFxInventoryMenuEquipToSlot) == 0x0000D8, "Wrong size on FGFxInventoryMenuEquipToSlot");
static_assert(offsetof(FGFxInventoryMenuEquipToSlot, ItemWidget) == 0x000000, "Member 'FGFxInventoryMenuEquipToSlot::ItemWidget' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuEquipToSlot, TrinketWidget) == 0x000008, "Member 'FGFxInventoryMenuEquipToSlot::TrinketWidget' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuEquipToSlot, IconWidget) == 0x000010, "Member 'FGFxInventoryMenuEquipToSlot::IconWidget' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuEquipToSlot, bTrinketEnabled) == 0x000030, "Member 'FGFxInventoryMenuEquipToSlot::bTrinketEnabled' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuEquipToSlot, SlotInfo) == 0x000038, "Member 'FGFxInventoryMenuEquipToSlot::SlotInfo' has a wrong offset!");

// ScriptStruct OakGame.VaultCardRewardData
// 0x0028 (0x0070 - 0x0048)
struct FVaultCardRewardData final : public FVaultCardRewardDataBase
{
public:
	TArray<class UOakCustomizationData*>          VaultCardRewardCustomizations;                     // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWeaponSkinPartData*                    VaultCardRewardWeaponSkin;                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTrinketPartData*                 VaultCardRewardWeaponTrinket;                      // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrewQuartersDecorationItemData*        VaultCardRewardQuartersDeco;                       // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardRewardData) == 0x000008, "Wrong alignment on FVaultCardRewardData");
static_assert(sizeof(FVaultCardRewardData) == 0x000070, "Wrong size on FVaultCardRewardData");
static_assert(offsetof(FVaultCardRewardData, VaultCardRewardCustomizations) == 0x000048, "Member 'FVaultCardRewardData::VaultCardRewardCustomizations' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardData, VaultCardRewardWeaponSkin) == 0x000058, "Member 'FVaultCardRewardData::VaultCardRewardWeaponSkin' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardData, VaultCardRewardWeaponTrinket) == 0x000060, "Member 'FVaultCardRewardData::VaultCardRewardWeaponTrinket' has a wrong offset!");
static_assert(offsetof(FVaultCardRewardData, VaultCardRewardQuartersDeco) == 0x000068, "Member 'FVaultCardRewardData::VaultCardRewardQuartersDeco' has a wrong offset!");

// ScriptStruct OakGame.VaultCardColumnData
// 0x0010 (0x0010 - 0x0000)
struct FVaultCardColumnData final
{
public:
	TArray<struct FVaultCardRewardData>           VaultCardRewardRows;                               // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardColumnData) == 0x000008, "Wrong alignment on FVaultCardColumnData");
static_assert(sizeof(FVaultCardColumnData) == 0x000010, "Wrong size on FVaultCardColumnData");
static_assert(offsetof(FVaultCardColumnData, VaultCardRewardRows) == 0x000000, "Member 'FVaultCardColumnData::VaultCardRewardRows' has a wrong offset!");

// ScriptStruct OakGame.WeightedLoadingTooltip
// 0x0020 (0x0020 - 0x0000)
struct FWeightedLoadingTooltip final
{
public:
	class FText                                   ToolTipText;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedLoadingTooltip) == 0x000008, "Wrong alignment on FWeightedLoadingTooltip");
static_assert(sizeof(FWeightedLoadingTooltip) == 0x000020, "Wrong size on FWeightedLoadingTooltip");
static_assert(offsetof(FWeightedLoadingTooltip, ToolTipText) == 0x000000, "Member 'FWeightedLoadingTooltip::ToolTipText' has a wrong offset!");
static_assert(offsetof(FWeightedLoadingTooltip, Weight) == 0x000018, "Member 'FWeightedLoadingTooltip::Weight' has a wrong offset!");

// ScriptStruct OakGame.GFxInventoryMenuSwapItem
// 0x0014 (0x0014 - 0x0000)
struct FGFxInventoryMenuSwapItem final
{
public:
	EGFxInventoryMenuFocusSide                    Side;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGFxInventoryItemWidget> ItemWidget;                                        // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UObject>                 ItemObject;                                        // 0x000C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGFxInventoryMenuSwapItem) == 0x000004, "Wrong alignment on FGFxInventoryMenuSwapItem");
static_assert(sizeof(FGFxInventoryMenuSwapItem) == 0x000014, "Wrong size on FGFxInventoryMenuSwapItem");
static_assert(offsetof(FGFxInventoryMenuSwapItem, Side) == 0x000000, "Member 'FGFxInventoryMenuSwapItem::Side' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuSwapItem, ItemWidget) == 0x000004, "Member 'FGFxInventoryMenuSwapItem::ItemWidget' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuSwapItem, ItemObject) == 0x00000C, "Member 'FGFxInventoryMenuSwapItem::ItemObject' has a wrong offset!");

// ScriptStruct OakGame.GFxInventoryMenuConfig
// 0x0298 (0x0298 - 0x0000)
struct FGFxInventoryMenuConfig final
{
public:
	class UInventoryCategoryData*                 WeaponCategory;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 GrenadeCategory;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 ShieldCategory;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 GoldenKeyResourceData;                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 ErediumResourceData;                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 MoneyResourceData;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 VaultCoinResourceData;                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReturnToBackpackWhenEquippingFromIt;              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearAllNewnessWhenLeavingMenu;                   // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInspect;                                    // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SelectionHighlightColorForItemCard;                // 0x003C(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SelectionComparisonColorForItemCard;               // 0x004C(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemCardLineThickness;                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuFilter>        PageFilters;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuTypePriorityInfo> ItemTypeSortPriorities;                            // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuItemGrouping>  ItemGroupingsByType;                               // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuItemGrouping>  ItemGroupingsByManufacturer;                       // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   InputAction_Drop;                                  // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputAction_DropByHolding;                         // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputAction_TrashFavorite;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputAction_Inspect;                               // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputAction_Unequip;                               // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryMenuPaperDollSlotInfo> PaperDollSlotSetup;                                // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGbxAmmoTypeData*>               AmmoTypes;                                         // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxAmmoTypeData*                       GrenadeAmmoType;                                   // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxMenuData*                           ItemInspectionMenuData;                            // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USwfMovie*                              ItemCardMovie;                                     // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ItemCardOffset;                                    // 0x0100(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemCardScale;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CompareItemCardOffset;                             // 0x010C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompareItemCardScale;                              // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGFxBackpackWidgetConfig               BackpackConfig;                                    // 0x0118(0x0118)(Edit, NativeAccessSpecifierPublic)
	int32                                         TrinketIconsReserveCount;                          // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalCurrencySpinnerHeightOverride;                // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrencyWidgetPauseOnNewValueTime;                 // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrencyWidgetCostSpinTime;                        // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TrinketsText;                                      // 0x0240(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FGFxMenuTutorialCollection             Tutorials;                                         // 0x0258(0x0020)(Edit, NativeAccessSpecifierPublic)
	class FName                                   FirstBootTutorial;                                 // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GearUpModeTutorial;                                // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LargeBackpackVisibleCells;                         // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmallBackpackVisibleCells;                         // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResortBackpackWhenAddingAndRemovingItems;         // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeDragStart;                              // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxInventoryMenuConfig) == 0x000008, "Wrong alignment on FGFxInventoryMenuConfig");
static_assert(sizeof(FGFxInventoryMenuConfig) == 0x000298, "Wrong size on FGFxInventoryMenuConfig");
static_assert(offsetof(FGFxInventoryMenuConfig, WeaponCategory) == 0x000000, "Member 'FGFxInventoryMenuConfig::WeaponCategory' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, GrenadeCategory) == 0x000008, "Member 'FGFxInventoryMenuConfig::GrenadeCategory' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ShieldCategory) == 0x000010, "Member 'FGFxInventoryMenuConfig::ShieldCategory' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, GoldenKeyResourceData) == 0x000018, "Member 'FGFxInventoryMenuConfig::GoldenKeyResourceData' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ErediumResourceData) == 0x000020, "Member 'FGFxInventoryMenuConfig::ErediumResourceData' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, MoneyResourceData) == 0x000028, "Member 'FGFxInventoryMenuConfig::MoneyResourceData' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, VaultCoinResourceData) == 0x000030, "Member 'FGFxInventoryMenuConfig::VaultCoinResourceData' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, bReturnToBackpackWhenEquippingFromIt) == 0x000038, "Member 'FGFxInventoryMenuConfig::bReturnToBackpackWhenEquippingFromIt' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, bClearAllNewnessWhenLeavingMenu) == 0x000039, "Member 'FGFxInventoryMenuConfig::bClearAllNewnessWhenLeavingMenu' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, bEnableInspect) == 0x00003A, "Member 'FGFxInventoryMenuConfig::bEnableInspect' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, SelectionHighlightColorForItemCard) == 0x00003C, "Member 'FGFxInventoryMenuConfig::SelectionHighlightColorForItemCard' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, SelectionComparisonColorForItemCard) == 0x00004C, "Member 'FGFxInventoryMenuConfig::SelectionComparisonColorForItemCard' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemCardLineThickness) == 0x00005C, "Member 'FGFxInventoryMenuConfig::ItemCardLineThickness' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, PageFilters) == 0x000060, "Member 'FGFxInventoryMenuConfig::PageFilters' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemTypeSortPriorities) == 0x000070, "Member 'FGFxInventoryMenuConfig::ItemTypeSortPriorities' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemGroupingsByType) == 0x000080, "Member 'FGFxInventoryMenuConfig::ItemGroupingsByType' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemGroupingsByManufacturer) == 0x000090, "Member 'FGFxInventoryMenuConfig::ItemGroupingsByManufacturer' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, InputAction_Drop) == 0x0000A0, "Member 'FGFxInventoryMenuConfig::InputAction_Drop' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, InputAction_DropByHolding) == 0x0000A8, "Member 'FGFxInventoryMenuConfig::InputAction_DropByHolding' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, InputAction_TrashFavorite) == 0x0000B0, "Member 'FGFxInventoryMenuConfig::InputAction_TrashFavorite' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, InputAction_Inspect) == 0x0000B8, "Member 'FGFxInventoryMenuConfig::InputAction_Inspect' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, InputAction_Unequip) == 0x0000C0, "Member 'FGFxInventoryMenuConfig::InputAction_Unequip' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, PaperDollSlotSetup) == 0x0000C8, "Member 'FGFxInventoryMenuConfig::PaperDollSlotSetup' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, AmmoTypes) == 0x0000D8, "Member 'FGFxInventoryMenuConfig::AmmoTypes' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, GrenadeAmmoType) == 0x0000E8, "Member 'FGFxInventoryMenuConfig::GrenadeAmmoType' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemInspectionMenuData) == 0x0000F0, "Member 'FGFxInventoryMenuConfig::ItemInspectionMenuData' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemCardMovie) == 0x0000F8, "Member 'FGFxInventoryMenuConfig::ItemCardMovie' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemCardOffset) == 0x000100, "Member 'FGFxInventoryMenuConfig::ItemCardOffset' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, ItemCardScale) == 0x000108, "Member 'FGFxInventoryMenuConfig::ItemCardScale' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, CompareItemCardOffset) == 0x00010C, "Member 'FGFxInventoryMenuConfig::CompareItemCardOffset' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, CompareItemCardScale) == 0x000114, "Member 'FGFxInventoryMenuConfig::CompareItemCardScale' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, BackpackConfig) == 0x000118, "Member 'FGFxInventoryMenuConfig::BackpackConfig' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, TrinketIconsReserveCount) == 0x000230, "Member 'FGFxInventoryMenuConfig::TrinketIconsReserveCount' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, TotalCurrencySpinnerHeightOverride) == 0x000234, "Member 'FGFxInventoryMenuConfig::TotalCurrencySpinnerHeightOverride' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, CurrencyWidgetPauseOnNewValueTime) == 0x000238, "Member 'FGFxInventoryMenuConfig::CurrencyWidgetPauseOnNewValueTime' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, CurrencyWidgetCostSpinTime) == 0x00023C, "Member 'FGFxInventoryMenuConfig::CurrencyWidgetCostSpinTime' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, TrinketsText) == 0x000240, "Member 'FGFxInventoryMenuConfig::TrinketsText' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, Tutorials) == 0x000258, "Member 'FGFxInventoryMenuConfig::Tutorials' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, FirstBootTutorial) == 0x000278, "Member 'FGFxInventoryMenuConfig::FirstBootTutorial' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, GearUpModeTutorial) == 0x000280, "Member 'FGFxInventoryMenuConfig::GearUpModeTutorial' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, LargeBackpackVisibleCells) == 0x000288, "Member 'FGFxInventoryMenuConfig::LargeBackpackVisibleCells' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, SmallBackpackVisibleCells) == 0x00028C, "Member 'FGFxInventoryMenuConfig::SmallBackpackVisibleCells' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, bResortBackpackWhenAddingAndRemovingItems) == 0x000290, "Member 'FGFxInventoryMenuConfig::bResortBackpackWhenAddingAndRemovingItems' has a wrong offset!");
static_assert(offsetof(FGFxInventoryMenuConfig, DelayBeforeDragStart) == 0x000294, "Member 'FGFxInventoryMenuConfig::DelayBeforeDragStart' has a wrong offset!");

// ScriptStruct OakGame.UIHardpointData
// 0x0070 (0x0070 - 0x0000)
struct FUIHardpointData final
{
public:
	EIronBearUIHardpointType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProgressBarName;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProgressBarFrameName;                              // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFrameName;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ElementalIconName;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FallbackElementalIconFrameName;                    // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BarText;                                           // 0x0058(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIHardpointData) == 0x000008, "Wrong alignment on FUIHardpointData");
static_assert(sizeof(FUIHardpointData) == 0x000070, "Wrong size on FUIHardpointData");
static_assert(offsetof(FUIHardpointData, Type) == 0x000000, "Member 'FUIHardpointData::Type' has a wrong offset!");
static_assert(offsetof(FUIHardpointData, ProgressBarName) == 0x000008, "Member 'FUIHardpointData::ProgressBarName' has a wrong offset!");
static_assert(offsetof(FUIHardpointData, ProgressBarFrameName) == 0x000018, "Member 'FUIHardpointData::ProgressBarFrameName' has a wrong offset!");
static_assert(offsetof(FUIHardpointData, IconFrameName) == 0x000028, "Member 'FUIHardpointData::IconFrameName' has a wrong offset!");
static_assert(offsetof(FUIHardpointData, ElementalIconName) == 0x000038, "Member 'FUIHardpointData::ElementalIconName' has a wrong offset!");
static_assert(offsetof(FUIHardpointData, FallbackElementalIconFrameName) == 0x000048, "Member 'FUIHardpointData::FallbackElementalIconFrameName' has a wrong offset!");
static_assert(offsetof(FUIHardpointData, BarText) == 0x000058, "Member 'FUIHardpointData::BarText' has a wrong offset!");

// ScriptStruct OakGame.GFxItemCardAbbreviatedObject
// 0x01D8 (0x01D8 - 0x0000)
struct FGFxItemCardAbbreviatedObject
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   ElementalUpdatedDelegate;                          // 0x0008(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AOakPlayerController>    OwningPC;                                          // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          ItemCardRootClip;                                  // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryShopComponent*                CachedInventoryShop;                               // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0xD8];                                      // 0x0030(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGFxItemCardMainStat*>           MainStatWidgets;                                   // 0x0108(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UGFxItemCardMainStat*>           MainStatMirroredWidgets;                           // 0x0118(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          ArtifactRarityIcon;                                // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          AbbreviatedAmmoIcon;                               // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateElementalInfoTime;                           // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBalanceStateComponent*        CurrentBalanceComponent;                           // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBalanceStateComponent*        CurrentComparisonItem;                             // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemCardElementalDetails>      ElementalEffects;                                  // 0x0158(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastElementalFrame;                                // 0x0178(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGFxItemCardArtifactLine*>       ArtifactMainStats;                                 // 0x0188(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGFxItemCardSkillEntry*>         ClassModSkillEntries;                              // 0x01A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class USwfMovie*                              SkillIconSWF;                                      // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        CurrentSkillIconSWFPath;                           // 0x01B8(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x8];                                      // 0x01D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemCardAbbreviatedObject) == 0x000008, "Wrong alignment on FGFxItemCardAbbreviatedObject");
static_assert(sizeof(FGFxItemCardAbbreviatedObject) == 0x0001D8, "Wrong size on FGFxItemCardAbbreviatedObject");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, ElementalUpdatedDelegate) == 0x000008, "Member 'FGFxItemCardAbbreviatedObject::ElementalUpdatedDelegate' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, OwningPC) == 0x000018, "Member 'FGFxItemCardAbbreviatedObject::OwningPC' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, ItemCardRootClip) == 0x000020, "Member 'FGFxItemCardAbbreviatedObject::ItemCardRootClip' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, CachedInventoryShop) == 0x000028, "Member 'FGFxItemCardAbbreviatedObject::CachedInventoryShop' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, MainStatWidgets) == 0x000108, "Member 'FGFxItemCardAbbreviatedObject::MainStatWidgets' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, MainStatMirroredWidgets) == 0x000118, "Member 'FGFxItemCardAbbreviatedObject::MainStatMirroredWidgets' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, ArtifactRarityIcon) == 0x000128, "Member 'FGFxItemCardAbbreviatedObject::ArtifactRarityIcon' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, AbbreviatedAmmoIcon) == 0x000130, "Member 'FGFxItemCardAbbreviatedObject::AbbreviatedAmmoIcon' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, UpdateElementalInfoTime) == 0x000138, "Member 'FGFxItemCardAbbreviatedObject::UpdateElementalInfoTime' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, CurrentBalanceComponent) == 0x000140, "Member 'FGFxItemCardAbbreviatedObject::CurrentBalanceComponent' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, CurrentComparisonItem) == 0x000150, "Member 'FGFxItemCardAbbreviatedObject::CurrentComparisonItem' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, ElementalEffects) == 0x000158, "Member 'FGFxItemCardAbbreviatedObject::ElementalEffects' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, LastElementalFrame) == 0x000178, "Member 'FGFxItemCardAbbreviatedObject::LastElementalFrame' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, ArtifactMainStats) == 0x000188, "Member 'FGFxItemCardAbbreviatedObject::ArtifactMainStats' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, ClassModSkillEntries) == 0x0001A0, "Member 'FGFxItemCardAbbreviatedObject::ClassModSkillEntries' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, SkillIconSWF) == 0x0001B0, "Member 'FGFxItemCardAbbreviatedObject::SkillIconSWF' has a wrong offset!");
static_assert(offsetof(FGFxItemCardAbbreviatedObject, CurrentSkillIconSWFPath) == 0x0001B8, "Member 'FGFxItemCardAbbreviatedObject::CurrentSkillIconSWFPath' has a wrong offset!");

// ScriptStruct OakGame.GFxItemCardObject
// 0x0360 (0x0538 - 0x01D8)
struct FGFxItemCardObject final : public FGFxItemCardAbbreviatedObject
{
public:
	class FString                                 DescriptionHighlightColor;                         // 0x01D8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSpinnerHeightOverride;                        // 0x01E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostSpinTime;                                      // 0x01EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseOnNewValueTime;                               // 0x01F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryStatsBottomSpacer;                        // 0x01F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClassModSpacingHeight;                             // 0x01F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegendaryArtifactSpacingHeight;                    // 0x01FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalVerticalAdjustment;                           // 0x0200(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGFxCurrencyCounterClip*                CurrencyWidget;                                    // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0xA0];                                     // 0x0210(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxTextField*                          ItemName;                                          // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0xE0];                                     // 0x02B8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          MainStatBackground;                                // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          MainStatBackgroundRaritySides;                     // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxTextField*                          TextStats;                                         // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxTextField*                          SDUTextStats;                                      // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxTextField*                          PickupTextStats;                                   // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0xC0];                                     // 0x03C0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumTextStats;                                   // 0x0480(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x1C];                                     // 0x0484(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxTextField*                          TextStatsTextfieldToUse;                           // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x28];                                     // 0x04A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          ManufacturerWrapper;                               // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          ManufacturerFill;                                  // 0x04F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxTextField*                          ManufacturerStats;                                 // 0x04F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          ManufacturerTextTint;                              // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          ItemCardBottom;                                    // 0x0508(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x28];                                     // 0x0510(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemCardObject) == 0x000008, "Wrong alignment on FGFxItemCardObject");
static_assert(sizeof(FGFxItemCardObject) == 0x000538, "Wrong size on FGFxItemCardObject");
static_assert(offsetof(FGFxItemCardObject, DescriptionHighlightColor) == 0x0001D8, "Member 'FGFxItemCardObject::DescriptionHighlightColor' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, TotalSpinnerHeightOverride) == 0x0001E8, "Member 'FGFxItemCardObject::TotalSpinnerHeightOverride' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, CostSpinTime) == 0x0001EC, "Member 'FGFxItemCardObject::CostSpinTime' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, PauseOnNewValueTime) == 0x0001F0, "Member 'FGFxItemCardObject::PauseOnNewValueTime' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, SecondaryStatsBottomSpacer) == 0x0001F4, "Member 'FGFxItemCardObject::SecondaryStatsBottomSpacer' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ClassModSpacingHeight) == 0x0001F8, "Member 'FGFxItemCardObject::ClassModSpacingHeight' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, LegendaryArtifactSpacingHeight) == 0x0001FC, "Member 'FGFxItemCardObject::LegendaryArtifactSpacingHeight' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, TotalVerticalAdjustment) == 0x000200, "Member 'FGFxItemCardObject::TotalVerticalAdjustment' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, CurrencyWidget) == 0x000208, "Member 'FGFxItemCardObject::CurrencyWidget' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ItemName) == 0x0002B0, "Member 'FGFxItemCardObject::ItemName' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, MainStatBackground) == 0x000398, "Member 'FGFxItemCardObject::MainStatBackground' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, MainStatBackgroundRaritySides) == 0x0003A0, "Member 'FGFxItemCardObject::MainStatBackgroundRaritySides' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, TextStats) == 0x0003A8, "Member 'FGFxItemCardObject::TextStats' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, SDUTextStats) == 0x0003B0, "Member 'FGFxItemCardObject::SDUTextStats' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, PickupTextStats) == 0x0003B8, "Member 'FGFxItemCardObject::PickupTextStats' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, MaxNumTextStats) == 0x000480, "Member 'FGFxItemCardObject::MaxNumTextStats' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, TextStatsTextfieldToUse) == 0x0004A0, "Member 'FGFxItemCardObject::TextStatsTextfieldToUse' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ManufacturerWrapper) == 0x0004D0, "Member 'FGFxItemCardObject::ManufacturerWrapper' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ManufacturerFill) == 0x0004F0, "Member 'FGFxItemCardObject::ManufacturerFill' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ManufacturerStats) == 0x0004F8, "Member 'FGFxItemCardObject::ManufacturerStats' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ManufacturerTextTint) == 0x000500, "Member 'FGFxItemCardObject::ManufacturerTextTint' has a wrong offset!");
static_assert(offsetof(FGFxItemCardObject, ItemCardBottom) == 0x000508, "Member 'FGFxItemCardObject::ItemCardBottom' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankSaveGameData
// 0x000C (0x000C - 0x0000)
struct FGuardianRankSaveGameData final
{
public:
	int32                                         GuardianRank;                                      // 0x0000(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingExperience;                                // 0x0004(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardianExperience;                                // 0x0008(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuardianRankSaveGameData) == 0x000004, "Wrong alignment on FGuardianRankSaveGameData");
static_assert(sizeof(FGuardianRankSaveGameData) == 0x00000C, "Wrong size on FGuardianRankSaveGameData");
static_assert(offsetof(FGuardianRankSaveGameData, GuardianRank) == 0x000000, "Member 'FGuardianRankSaveGameData::GuardianRank' has a wrong offset!");
static_assert(offsetof(FGuardianRankSaveGameData, StartingExperience) == 0x000004, "Member 'FGuardianRankSaveGameData::StartingExperience' has a wrong offset!");
static_assert(offsetof(FGuardianRankSaveGameData, GuardianExperience) == 0x000008, "Member 'FGuardianRankSaveGameData::GuardianExperience' has a wrong offset!");

// ScriptStruct OakGame.GFxMapMenuStateInfo
// 0x0028 (0x0028 - 0x0000)
struct FGFxMapMenuStateInfo final
{
public:
	class FText                                   StateName;                                         // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 StateFrame;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMapMenuStateInfo) == 0x000008, "Wrong alignment on FGFxMapMenuStateInfo");
static_assert(sizeof(FGFxMapMenuStateInfo) == 0x000028, "Wrong size on FGFxMapMenuStateInfo");
static_assert(offsetof(FGFxMapMenuStateInfo, StateName) == 0x000000, "Member 'FGFxMapMenuStateInfo::StateName' has a wrong offset!");
static_assert(offsetof(FGFxMapMenuStateInfo, StateFrame) == 0x000018, "Member 'FGFxMapMenuStateInfo::StateFrame' has a wrong offset!");

// ScriptStruct OakGame.WeaponBonusDataTableAttributeMappingData
// 0x0030 (0x0030 - 0x0000)
struct FWeaponBonusDataTableAttributeMappingData final
{
public:
	bool                                          bInstigatorAttribute;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ColumnName;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxAttributeData*                      Attribute;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponBonusDataTableAttributeValueResolver* DataTableAttributeValueResolver;                   // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWeaponBonusDataTableAttributeMappingData) == 0x000008, "Wrong alignment on FWeaponBonusDataTableAttributeMappingData");
static_assert(sizeof(FWeaponBonusDataTableAttributeMappingData) == 0x000030, "Wrong size on FWeaponBonusDataTableAttributeMappingData");
static_assert(offsetof(FWeaponBonusDataTableAttributeMappingData, bInstigatorAttribute) == 0x000000, "Member 'FWeaponBonusDataTableAttributeMappingData::bInstigatorAttribute' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableAttributeMappingData, ColumnName) == 0x000008, "Member 'FWeaponBonusDataTableAttributeMappingData::ColumnName' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableAttributeMappingData, Attribute) == 0x000018, "Member 'FWeaponBonusDataTableAttributeMappingData::Attribute' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableAttributeMappingData, ModifierType) == 0x000020, "Member 'FWeaponBonusDataTableAttributeMappingData::ModifierType' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableAttributeMappingData, DataTableAttributeValueResolver) == 0x000028, "Member 'FWeaponBonusDataTableAttributeMappingData::DataTableAttributeValueResolver' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionLocator
// 0x0120 (0x0120 - 0x0000)
struct alignas(0x10) FGFxItemInspectionLocator final
{
public:
	float                                         RotateFactor;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PanFactor;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomFactor;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemFOV;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferenceItemScale;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScaleRange;                                        // 0x0014(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseToPanFactor;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseToRotateFactor;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseWheelFactor;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeyboardZoomFactor;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightThreshold;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntroDuration;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               IntroRotation;                                     // 0x0034(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               IntroRotationRandomness;                           // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IntroRotationAlphaPowerRandomness;                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxItemInspectionMenu*                 MenuOuter;                                         // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0xC8];                                      // 0x0058(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemInspectionLocator) == 0x000010, "Wrong alignment on FGFxItemInspectionLocator");
static_assert(sizeof(FGFxItemInspectionLocator) == 0x000120, "Wrong size on FGFxItemInspectionLocator");
static_assert(offsetof(FGFxItemInspectionLocator, RotateFactor) == 0x000000, "Member 'FGFxItemInspectionLocator::RotateFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, PanFactor) == 0x000004, "Member 'FGFxItemInspectionLocator::PanFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, ZoomFactor) == 0x000008, "Member 'FGFxItemInspectionLocator::ZoomFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, ItemFOV) == 0x00000C, "Member 'FGFxItemInspectionLocator::ItemFOV' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, ReferenceItemScale) == 0x000010, "Member 'FGFxItemInspectionLocator::ReferenceItemScale' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, ScaleRange) == 0x000014, "Member 'FGFxItemInspectionLocator::ScaleRange' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, MouseToPanFactor) == 0x00001C, "Member 'FGFxItemInspectionLocator::MouseToPanFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, MouseToRotateFactor) == 0x000020, "Member 'FGFxItemInspectionLocator::MouseToRotateFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, MouseWheelFactor) == 0x000024, "Member 'FGFxItemInspectionLocator::MouseWheelFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, KeyboardZoomFactor) == 0x000028, "Member 'FGFxItemInspectionLocator::KeyboardZoomFactor' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, HeightThreshold) == 0x00002C, "Member 'FGFxItemInspectionLocator::HeightThreshold' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, IntroDuration) == 0x000030, "Member 'FGFxItemInspectionLocator::IntroDuration' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, IntroRotation) == 0x000034, "Member 'FGFxItemInspectionLocator::IntroRotation' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, IntroRotationRandomness) == 0x000040, "Member 'FGFxItemInspectionLocator::IntroRotationRandomness' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, IntroRotationAlphaPowerRandomness) == 0x00004C, "Member 'FGFxItemInspectionLocator::IntroRotationAlphaPowerRandomness' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionLocator, MenuOuter) == 0x000050, "Member 'FGFxItemInspectionLocator::MenuOuter' has a wrong offset!");

// ScriptStruct OakGame.GFxNewsMenuFullscreenData
// 0x0040 (0x0040 - 0x0000)
struct FGFxNewsMenuFullscreenData final
{
public:
	class FText                                   NewsLabel;                                         // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NewsImage;                                         // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxNewsMenuFullscreenData) == 0x000008, "Wrong alignment on FGFxNewsMenuFullscreenData");
static_assert(sizeof(FGFxNewsMenuFullscreenData) == 0x000040, "Wrong size on FGFxNewsMenuFullscreenData");
static_assert(offsetof(FGFxNewsMenuFullscreenData, NewsLabel) == 0x000000, "Member 'FGFxNewsMenuFullscreenData::NewsLabel' has a wrong offset!");
static_assert(offsetof(FGFxNewsMenuFullscreenData, NewsImage) == 0x000018, "Member 'FGFxNewsMenuFullscreenData::NewsImage' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionCategoryInfo
// 0x0040 (0x0040 - 0x0000)
struct FGFxItemInspectionCategoryInfo final
{
public:
	class UInventoryCategoryData*                 CategoryData;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxItemInspectionCategoryInfo) == 0x000010, "Wrong alignment on FGFxItemInspectionCategoryInfo");
static_assert(sizeof(FGFxItemInspectionCategoryInfo) == 0x000040, "Wrong size on FGFxItemInspectionCategoryInfo");
static_assert(offsetof(FGFxItemInspectionCategoryInfo, CategoryData) == 0x000000, "Member 'FGFxItemInspectionCategoryInfo::CategoryData' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionCategoryInfo, BaseTransform) == 0x000010, "Member 'FGFxItemInspectionCategoryInfo::BaseTransform' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionPageData
// 0x0038 (0x0038 - 0x0000)
struct FGFxItemInspectionPageData final
{
public:
	EGFxItemInspectionPages                       Page;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NavId;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FrameName;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PageTitle;                                         // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxItemInspectionPageData) == 0x000008, "Wrong alignment on FGFxItemInspectionPageData");
static_assert(sizeof(FGFxItemInspectionPageData) == 0x000038, "Wrong size on FGFxItemInspectionPageData");
static_assert(offsetof(FGFxItemInspectionPageData, Page) == 0x000000, "Member 'FGFxItemInspectionPageData::Page' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPageData, NavId) == 0x000008, "Member 'FGFxItemInspectionPageData::NavId' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPageData, FrameName) == 0x000010, "Member 'FGFxItemInspectionPageData::FrameName' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPageData, PageTitle) == 0x000020, "Member 'FGFxItemInspectionPageData::PageTitle' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionMenuEnumIdMap
// 0x0018 (0x0018 - 0x0000)
struct FGFxItemInspectionMenuEnumIdMap final
{
public:
	class UEnum*                                  EnumType;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         IdValues;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxItemInspectionMenuEnumIdMap) == 0x000008, "Wrong alignment on FGFxItemInspectionMenuEnumIdMap");
static_assert(sizeof(FGFxItemInspectionMenuEnumIdMap) == 0x000018, "Wrong size on FGFxItemInspectionMenuEnumIdMap");
static_assert(offsetof(FGFxItemInspectionMenuEnumIdMap, EnumType) == 0x000000, "Member 'FGFxItemInspectionMenuEnumIdMap::EnumType' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionMenuEnumIdMap, IdValues) == 0x000008, "Member 'FGFxItemInspectionMenuEnumIdMap::IdValues' has a wrong offset!");

// ScriptStruct OakGame.GFXItemInspectionPartEnumTable
// 0x0010 (0x0010 - 0x0000)
struct FGFXItemInspectionPartEnumTable final
{
public:
	TArray<struct FGFxItemInspectionMenuEnumIdMap> IdMap;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFXItemInspectionPartEnumTable) == 0x000008, "Wrong alignment on FGFXItemInspectionPartEnumTable");
static_assert(sizeof(FGFXItemInspectionPartEnumTable) == 0x000010, "Wrong size on FGFXItemInspectionPartEnumTable");
static_assert(offsetof(FGFXItemInspectionPartEnumTable, IdMap) == 0x000000, "Member 'FGFXItemInspectionPartEnumTable::IdMap' has a wrong offset!");

// ScriptStruct OakGame.CurrentOperativeStandInAbilitySlotInfo
// 0x0020 (0x0020 - 0x0000)
struct FCurrentOperativeStandInAbilitySlotInfo final
{
public:
	TSubclassOf<class UOakActionAbility>          ActionAbility;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AStandInAuxiliaryActor*                 AuxiliaryActor;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurrentOperativeStandInAbilitySlotInfo) == 0x000008, "Wrong alignment on FCurrentOperativeStandInAbilitySlotInfo");
static_assert(sizeof(FCurrentOperativeStandInAbilitySlotInfo) == 0x000020, "Wrong size on FCurrentOperativeStandInAbilitySlotInfo");
static_assert(offsetof(FCurrentOperativeStandInAbilitySlotInfo, ActionAbility) == 0x000000, "Member 'FCurrentOperativeStandInAbilitySlotInfo::ActionAbility' has a wrong offset!");
static_assert(offsetof(FCurrentOperativeStandInAbilitySlotInfo, AuxiliaryActor) == 0x000008, "Member 'FCurrentOperativeStandInAbilitySlotInfo::AuxiliaryActor' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakAttachedAnim
// 0x0008 (0x0528 - 0x0520)
struct FActionState_OakAttachedAnim final : public FActionState_OakAnim
{
public:
	uint8                                         Pad_520[0x8];                                      // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakAttachedAnim) == 0x000008, "Wrong alignment on FActionState_OakAttachedAnim");
static_assert(sizeof(FActionState_OakAttachedAnim) == 0x000528, "Wrong size on FActionState_OakAttachedAnim");

// ScriptStruct OakGame.SirenGhostArmConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FSirenGhostArmConfiguration final
{
public:
	ESirenGhostArmConfigurationType               GhostArmConfiguration;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      MaterialInstance;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSirenGhostArmConfiguration) == 0x000008, "Wrong alignment on FSirenGhostArmConfiguration");
static_assert(sizeof(FSirenGhostArmConfiguration) == 0x000010, "Wrong size on FSirenGhostArmConfiguration");
static_assert(offsetof(FSirenGhostArmConfiguration, GhostArmConfiguration) == 0x000000, "Member 'FSirenGhostArmConfiguration::GhostArmConfiguration' has a wrong offset!");
static_assert(offsetof(FSirenGhostArmConfiguration, MaterialInstance) == 0x000008, "Member 'FSirenGhostArmConfiguration::MaterialInstance' has a wrong offset!");

// ScriptStruct OakGame.SirenArmAppearanceState
// 0x0058 (0x0058 - 0x0000)
struct FSirenArmAppearanceState final
{
public:
	struct FSirenGhostArmConfiguration            PassiveGhostArmConfiguration;                      // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bTattooFlare;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPhaseTranceElementalType                     ElementalType;                                     // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSirenGhostArmConfiguration            ActiveGhostArmConfiguration;                       // 0x0018(0x0010)(RepSkip, NoDestructor, NativeAccessSpecifierPrivate)
	class USirenCharacterComponent*               Owner;                                             // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class ISirenArmControllerInterface>> PassiveArmControllers;                             // 0x0038(0x0010)(ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class ISirenArmControllerInterface>> ActionArmControllers;                              // 0x0048(0x0010)(ZeroConstructor, RepSkip, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSirenArmAppearanceState) == 0x000008, "Wrong alignment on FSirenArmAppearanceState");
static_assert(sizeof(FSirenArmAppearanceState) == 0x000058, "Wrong size on FSirenArmAppearanceState");
static_assert(offsetof(FSirenArmAppearanceState, PassiveGhostArmConfiguration) == 0x000000, "Member 'FSirenArmAppearanceState::PassiveGhostArmConfiguration' has a wrong offset!");
static_assert(offsetof(FSirenArmAppearanceState, bTattooFlare) == 0x000010, "Member 'FSirenArmAppearanceState::bTattooFlare' has a wrong offset!");
static_assert(offsetof(FSirenArmAppearanceState, ElementalType) == 0x000011, "Member 'FSirenArmAppearanceState::ElementalType' has a wrong offset!");
static_assert(offsetof(FSirenArmAppearanceState, ActiveGhostArmConfiguration) == 0x000018, "Member 'FSirenArmAppearanceState::ActiveGhostArmConfiguration' has a wrong offset!");
static_assert(offsetof(FSirenArmAppearanceState, Owner) == 0x000028, "Member 'FSirenArmAppearanceState::Owner' has a wrong offset!");
static_assert(offsetof(FSirenArmAppearanceState, PassiveArmControllers) == 0x000038, "Member 'FSirenArmAppearanceState::PassiveArmControllers' has a wrong offset!");
static_assert(offsetof(FSirenArmAppearanceState, ActionArmControllers) == 0x000048, "Member 'FSirenArmAppearanceState::ActionArmControllers' has a wrong offset!");

// ScriptStruct OakGame.GFxVendingMachineMenuFilter
// 0x0020 (0x0020 - 0x0000)
struct FGFxVendingMachineMenuFilter final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 DataTypeFilter;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxVendingMachineMenuFilter) == 0x000008, "Wrong alignment on FGFxVendingMachineMenuFilter");
static_assert(sizeof(FGFxVendingMachineMenuFilter) == 0x000020, "Wrong size on FGFxVendingMachineMenuFilter");
static_assert(offsetof(FGFxVendingMachineMenuFilter, Name) == 0x000000, "Member 'FGFxVendingMachineMenuFilter::Name' has a wrong offset!");
static_assert(offsetof(FGFxVendingMachineMenuFilter, DataTypeFilter) == 0x000018, "Member 'FGFxVendingMachineMenuFilter::DataTypeFilter' has a wrong offset!");

// ScriptStruct OakGame.WeaponTypeAttributeStatWeighting
// 0x0018 (0x0018 - 0x0000)
struct FWeaponTypeAttributeStatWeighting final
{
public:
	class UWeaponTypeData*                        WeaponType;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeightedWeaponUIStat>          WeightedStats;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponTypeAttributeStatWeighting) == 0x000008, "Wrong alignment on FWeaponTypeAttributeStatWeighting");
static_assert(sizeof(FWeaponTypeAttributeStatWeighting) == 0x000018, "Wrong size on FWeaponTypeAttributeStatWeighting");
static_assert(offsetof(FWeaponTypeAttributeStatWeighting, WeaponType) == 0x000000, "Member 'FWeaponTypeAttributeStatWeighting::WeaponType' has a wrong offset!");
static_assert(offsetof(FWeaponTypeAttributeStatWeighting, WeightedStats) == 0x000008, "Member 'FWeaponTypeAttributeStatWeighting::WeightedStats' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionSkinsPage
// 0x0170 (0x0180 - 0x0010)
struct FGFxItemInspectionSkinsPage final : public FGFxItemInspectionPageBase
{
public:
	struct FGbxGFxPooledGridListFullConfig        SkinsListConfig;                                   // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
	int32                                         SplitScreenSkinListRowCount;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultSkinName;                                   // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   WeaponSkinTextName;                                // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UGFxItemInspectionSkinsList*            SkinsList;                                         // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxSlider*                          ScrollBarSkinsClip;                                // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxButton*                          NavArrowLeftButton;                                // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxButton*                          NavArrowRightButton;                               // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x58];                                     // 0x0128(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemInspectionSkinsPage) == 0x000008, "Wrong alignment on FGFxItemInspectionSkinsPage");
static_assert(sizeof(FGFxItemInspectionSkinsPage) == 0x000180, "Wrong size on FGFxItemInspectionSkinsPage");
static_assert(offsetof(FGFxItemInspectionSkinsPage, SkinsListConfig) == 0x000010, "Member 'FGFxItemInspectionSkinsPage::SkinsListConfig' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, SplitScreenSkinListRowCount) == 0x0000D0, "Member 'FGFxItemInspectionSkinsPage::SplitScreenSkinListRowCount' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, DefaultSkinName) == 0x0000D8, "Member 'FGFxItemInspectionSkinsPage::DefaultSkinName' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, WeaponSkinTextName) == 0x0000F0, "Member 'FGFxItemInspectionSkinsPage::WeaponSkinTextName' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, SkinsList) == 0x000108, "Member 'FGFxItemInspectionSkinsPage::SkinsList' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, ScrollBarSkinsClip) == 0x000110, "Member 'FGFxItemInspectionSkinsPage::ScrollBarSkinsClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, NavArrowLeftButton) == 0x000118, "Member 'FGFxItemInspectionSkinsPage::NavArrowLeftButton' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionSkinsPage, NavArrowRightButton) == 0x000120, "Member 'FGFxItemInspectionSkinsPage::NavArrowRightButton' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakAnimActionAbilityOperative
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakAnimActionAbilityOperative final : public FActionState_OakAnimActionAbility
{
};
static_assert(alignof(FActionState_OakAnimActionAbilityOperative) == 0x000008, "Wrong alignment on FActionState_OakAnimActionAbilityOperative");
static_assert(sizeof(FActionState_OakAnimActionAbilityOperative) == 0x000520, "Wrong size on FActionState_OakAnimActionAbilityOperative");

// ScriptStruct OakGame.OakPlayerCharacterSlotItem
// 0x0014 (0x0020 - 0x000C)
struct FOakPlayerCharacterSlotItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerCharacterComponentSlotData*      SlotData;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerCharacterComponentAugmentData*   AugmentData;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPlayerCharacterSlotItem) == 0x000008, "Wrong alignment on FOakPlayerCharacterSlotItem");
static_assert(sizeof(FOakPlayerCharacterSlotItem) == 0x000020, "Wrong size on FOakPlayerCharacterSlotItem");
static_assert(offsetof(FOakPlayerCharacterSlotItem, SlotData) == 0x000010, "Member 'FOakPlayerCharacterSlotItem::SlotData' has a wrong offset!");
static_assert(offsetof(FOakPlayerCharacterSlotItem, AugmentData) == 0x000018, "Member 'FOakPlayerCharacterSlotItem::AugmentData' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerCharacterSlotItemList
// 0x0018 (0x00C8 - 0x00B0)
struct FOakPlayerCharacterSlotItemList final : public FFastArraySerializer
{
public:
	class UPlayerCharacterComponent*              Owner;                                             // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakPlayerCharacterSlotItem>    Items;                                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPlayerCharacterSlotItemList) == 0x000008, "Wrong alignment on FOakPlayerCharacterSlotItemList");
static_assert(sizeof(FOakPlayerCharacterSlotItemList) == 0x0000C8, "Wrong size on FOakPlayerCharacterSlotItemList");
static_assert(offsetof(FOakPlayerCharacterSlotItemList, Owner) == 0x0000B0, "Member 'FOakPlayerCharacterSlotItemList::Owner' has a wrong offset!");
static_assert(offsetof(FOakPlayerCharacterSlotItemList, Items) == 0x0000B8, "Member 'FOakPlayerCharacterSlotItemList::Items' has a wrong offset!");

// ScriptStruct OakGame.DesiredStandInActorData
// 0x0050 (0x0050 - 0x0000)
struct FDesiredStandInActorData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     CustomStandInClass;                                // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxDataAsset*                          DataAsset;                                         // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesiredStandInActorData) == 0x000008, "Wrong alignment on FDesiredStandInActorData");
static_assert(sizeof(FDesiredStandInActorData) == 0x000050, "Wrong size on FDesiredStandInActorData");
static_assert(offsetof(FDesiredStandInActorData, CustomStandInClass) == 0x000008, "Member 'FDesiredStandInActorData::CustomStandInClass' has a wrong offset!");
static_assert(offsetof(FDesiredStandInActorData, DataAsset) == 0x000040, "Member 'FDesiredStandInActorData::DataAsset' has a wrong offset!");

// ScriptStruct OakGame.GFxLeaguesMenuStandInState
// 0x0080 (0x0080 - 0x0000)
struct FGFxLeaguesMenuStandInState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesiredStandInActorData               ActorData;                                         // 0x0008(0x0050)(Transient, NativeAccessSpecifierPublic)
	class UOakCustomizationData*                  Customization;                                     // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTrinketPartData*                 WeaponTrinket;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSkinPartData*                    WeaponSkin;                                        // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ActorReward;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StandInConfig;                                     // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxLeaguesMenuStandInState) == 0x000008, "Wrong alignment on FGFxLeaguesMenuStandInState");
static_assert(sizeof(FGFxLeaguesMenuStandInState) == 0x000080, "Wrong size on FGFxLeaguesMenuStandInState");
static_assert(offsetof(FGFxLeaguesMenuStandInState, ActorData) == 0x000008, "Member 'FGFxLeaguesMenuStandInState::ActorData' has a wrong offset!");
static_assert(offsetof(FGFxLeaguesMenuStandInState, Customization) == 0x000058, "Member 'FGFxLeaguesMenuStandInState::Customization' has a wrong offset!");
static_assert(offsetof(FGFxLeaguesMenuStandInState, WeaponTrinket) == 0x000060, "Member 'FGFxLeaguesMenuStandInState::WeaponTrinket' has a wrong offset!");
static_assert(offsetof(FGFxLeaguesMenuStandInState, WeaponSkin) == 0x000068, "Member 'FGFxLeaguesMenuStandInState::WeaponSkin' has a wrong offset!");
static_assert(offsetof(FGFxLeaguesMenuStandInState, ActorReward) == 0x000070, "Member 'FGFxLeaguesMenuStandInState::ActorReward' has a wrong offset!");
static_assert(offsetof(FGFxLeaguesMenuStandInState, StandInConfig) == 0x000078, "Member 'FGFxLeaguesMenuStandInState::StandInConfig' has a wrong offset!");

// ScriptStruct OakGame.OakWeaponNamingAttributeThresholdData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOakWeaponNamingAttributeThresholdData final
{
public:
	class FName                                   AttributeName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstThreshold;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondThreshold;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakWeaponNamingAttributeThresholdData) == 0x000008, "Wrong alignment on FOakWeaponNamingAttributeThresholdData");
static_assert(sizeof(FOakWeaponNamingAttributeThresholdData) == 0x000010, "Wrong size on FOakWeaponNamingAttributeThresholdData");
static_assert(offsetof(FOakWeaponNamingAttributeThresholdData, AttributeName) == 0x000000, "Member 'FOakWeaponNamingAttributeThresholdData::AttributeName' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamingAttributeThresholdData, FirstThreshold) == 0x000008, "Member 'FOakWeaponNamingAttributeThresholdData::FirstThreshold' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamingAttributeThresholdData, SecondThreshold) == 0x00000C, "Member 'FOakWeaponNamingAttributeThresholdData::SecondThreshold' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionPartsPage
// 0x01A0 (0x01B0 - 0x0010)
struct FGFxItemInspectionPartsPage final : public FGFxItemInspectionPageBase
{
public:
	struct FGbxGFxPooledGridListFullConfig        PartsListConfig;                                   // 0x0010(0x00C0)(Edit, NativeAccessSpecifierPublic)
	int32                                         SplitScreenPartsListSize;                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStatRows;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   WeaponPartEffectsText;                             // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   WeaponPartsText;                                   // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          WeaponPartsContainerClip;                          // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x48];                                     // 0x0110(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGFxItemInspectionPartList*             PartsListClip;                                     // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxSlider*                          ScrollBarClip;                                     // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGFxItemInspectionStatRowObject*> StatRowClips;                                      // 0x0188(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxItemInspectionPartsPage) == 0x000008, "Wrong alignment on FGFxItemInspectionPartsPage");
static_assert(sizeof(FGFxItemInspectionPartsPage) == 0x0001B0, "Wrong size on FGFxItemInspectionPartsPage");
static_assert(offsetof(FGFxItemInspectionPartsPage, PartsListConfig) == 0x000010, "Member 'FGFxItemInspectionPartsPage::PartsListConfig' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, SplitScreenPartsListSize) == 0x0000D0, "Member 'FGFxItemInspectionPartsPage::SplitScreenPartsListSize' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, NumStatRows) == 0x0000D4, "Member 'FGFxItemInspectionPartsPage::NumStatRows' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, WeaponPartEffectsText) == 0x0000D8, "Member 'FGFxItemInspectionPartsPage::WeaponPartEffectsText' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, WeaponPartsText) == 0x0000F0, "Member 'FGFxItemInspectionPartsPage::WeaponPartsText' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, WeaponPartsContainerClip) == 0x000108, "Member 'FGFxItemInspectionPartsPage::WeaponPartsContainerClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, PartsListClip) == 0x000158, "Member 'FGFxItemInspectionPartsPage::PartsListClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, ScrollBarClip) == 0x000160, "Member 'FGFxItemInspectionPartsPage::ScrollBarClip' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionPartsPage, StatRowClips) == 0x000188, "Member 'FGFxItemInspectionPartsPage::StatRowClips' has a wrong offset!");

// ScriptStruct OakGame.TriggeredPassiveAbilityEffect
// 0x0048 (0x0048 - 0x0000)
struct FTriggeredPassiveAbilityEffect final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           Duration;                                          // 0x0008(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApplyToPlayer;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdditionalTriggeredEffectTargets             AdditionalEffectTargets;                           // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlayerForAdditionalEffectTargetContext;        // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsEffectEndedEvent;                            // 0x0043(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTriggerMultipleTimesPerFrame;                  // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriggeredPassiveAbilityEffect) == 0x000008, "Wrong alignment on FTriggeredPassiveAbilityEffect");
static_assert(sizeof(FTriggeredPassiveAbilityEffect) == 0x000048, "Wrong size on FTriggeredPassiveAbilityEffect");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, StatusEffectData) == 0x000000, "Member 'FTriggeredPassiveAbilityEffect::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, Duration) == 0x000008, "Member 'FTriggeredPassiveAbilityEffect::Duration' has a wrong offset!");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, bApplyToPlayer) == 0x000040, "Member 'FTriggeredPassiveAbilityEffect::bApplyToPlayer' has a wrong offset!");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, AdditionalEffectTargets) == 0x000041, "Member 'FTriggeredPassiveAbilityEffect::AdditionalEffectTargets' has a wrong offset!");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, bUsePlayerForAdditionalEffectTargetContext) == 0x000042, "Member 'FTriggeredPassiveAbilityEffect::bUsePlayerForAdditionalEffectTargetContext' has a wrong offset!");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, bWantsEffectEndedEvent) == 0x000043, "Member 'FTriggeredPassiveAbilityEffect::bWantsEffectEndedEvent' has a wrong offset!");
static_assert(offsetof(FTriggeredPassiveAbilityEffect, bCanTriggerMultipleTimesPerFrame) == 0x000044, "Member 'FTriggeredPassiveAbilityEffect::bCanTriggerMultipleTimesPerFrame' has a wrong offset!");

// ScriptStruct OakGame.GFxItemInspectionInspectPage
// 0x0080 (0x0090 - 0x0010)
struct FGFxItemInspectionInspectPage final : public FGFxItemInspectionPageBase
{
public:
	class FText                                   SkinTitleText;                                     // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxHintWidget*                      SkinsHintClip;                                     // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxItemInspectionInspectPage) == 0x000008, "Wrong alignment on FGFxItemInspectionInspectPage");
static_assert(sizeof(FGFxItemInspectionInspectPage) == 0x000090, "Wrong size on FGFxItemInspectionInspectPage");
static_assert(offsetof(FGFxItemInspectionInspectPage, SkinTitleText) == 0x000010, "Member 'FGFxItemInspectionInspectPage::SkinTitleText' has a wrong offset!");
static_assert(offsetof(FGFxItemInspectionInspectPage, SkinsHintClip) == 0x000088, "Member 'FGFxItemInspectionInspectPage::SkinsHintClip' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakVehicleSpawnAnim
// 0x0020 (0x0518 - 0x04F8)
struct FActionState_OakVehicleSpawnAnim final : public FActionState_SpawnAnim
{
public:
	uint8                                         Pad_4F8[0x20];                                     // 0x04F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakVehicleSpawnAnim) == 0x000008, "Wrong alignment on FActionState_OakVehicleSpawnAnim");
static_assert(sizeof(FActionState_OakVehicleSpawnAnim) == 0x000518, "Wrong size on FActionState_OakVehicleSpawnAnim");

// ScriptStruct OakGame.HornSequence
// 0x0020 (0x0020 - 0x0000)
struct FHornSequence final
{
public:
	TArray<struct FHornSequenceEntry>             HornSequence;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHornSequence) == 0x000008, "Wrong alignment on FHornSequence");
static_assert(sizeof(FHornSequence) == 0x000020, "Wrong size on FHornSequence");
static_assert(offsetof(FHornSequence, HornSequence) == 0x000000, "Member 'FHornSequence::HornSequence' has a wrong offset!");

// ScriptStruct OakGame.MenuItemButton
// 0x0038 (0x0038 - 0x0000)
struct FMenuItemButton final
{
public:
	class UGbxGFxButton*                          MenuItem;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxTextField*                          LabelDropShadow;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          SocialWrapper;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          ListIconContainer;                                 // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          ListIcon;                                          // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxTextField*                          ListIconText;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          NeedHelpIcon;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuItemButton) == 0x000008, "Wrong alignment on FMenuItemButton");
static_assert(sizeof(FMenuItemButton) == 0x000038, "Wrong size on FMenuItemButton");
static_assert(offsetof(FMenuItemButton, MenuItem) == 0x000000, "Member 'FMenuItemButton::MenuItem' has a wrong offset!");
static_assert(offsetof(FMenuItemButton, LabelDropShadow) == 0x000008, "Member 'FMenuItemButton::LabelDropShadow' has a wrong offset!");
static_assert(offsetof(FMenuItemButton, SocialWrapper) == 0x000010, "Member 'FMenuItemButton::SocialWrapper' has a wrong offset!");
static_assert(offsetof(FMenuItemButton, ListIconContainer) == 0x000018, "Member 'FMenuItemButton::ListIconContainer' has a wrong offset!");
static_assert(offsetof(FMenuItemButton, ListIcon) == 0x000020, "Member 'FMenuItemButton::ListIcon' has a wrong offset!");
static_assert(offsetof(FMenuItemButton, ListIconText) == 0x000028, "Member 'FMenuItemButton::ListIconText' has a wrong offset!");
static_assert(offsetof(FMenuItemButton, NeedHelpIcon) == 0x000030, "Member 'FMenuItemButton::NeedHelpIcon' has a wrong offset!");

// ScriptStruct OakGame.DonorInfo
// 0x0018 (0x0018 - 0x0000)
struct FDonorInfo final
{
public:
	class FString                                 DonorName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDonation;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDonorInfo) == 0x000008, "Wrong alignment on FDonorInfo");
static_assert(sizeof(FDonorInfo) == 0x000018, "Wrong size on FDonorInfo");
static_assert(offsetof(FDonorInfo, DonorName) == 0x000000, "Member 'FDonorInfo::DonorName' has a wrong offset!");
static_assert(offsetof(FDonorInfo, TotalDonation) == 0x000010, "Member 'FDonorInfo::TotalDonation' has a wrong offset!");

// ScriptStruct OakGame.OakChallengeTierRewards
// 0x00E0 (0x00E0 - 0x0000)
struct FOakChallengeTierRewards final
{
public:
	struct FAttributeInitializationData           ExperienceReward;                                  // 0x0000(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           CashReward;                                        // 0x0038(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           EridiumReward;                                     // 0x0070(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UItemPoolData*                          RewardItemPool;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOakCustomizationData*>          RewardCustomizations;                              // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UWeaponSkinPartData*>            RewardWeaponSkins;                                 // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UWeaponTrinketPartData*>         RewardWeaponTrinkets;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakChallengeTierRewards) == 0x000008, "Wrong alignment on FOakChallengeTierRewards");
static_assert(sizeof(FOakChallengeTierRewards) == 0x0000E0, "Wrong size on FOakChallengeTierRewards");
static_assert(offsetof(FOakChallengeTierRewards, ExperienceReward) == 0x000000, "Member 'FOakChallengeTierRewards::ExperienceReward' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewards, CashReward) == 0x000038, "Member 'FOakChallengeTierRewards::CashReward' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewards, EridiumReward) == 0x000070, "Member 'FOakChallengeTierRewards::EridiumReward' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewards, RewardItemPool) == 0x0000A8, "Member 'FOakChallengeTierRewards::RewardItemPool' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewards, RewardCustomizations) == 0x0000B0, "Member 'FOakChallengeTierRewards::RewardCustomizations' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewards, RewardWeaponSkins) == 0x0000C0, "Member 'FOakChallengeTierRewards::RewardWeaponSkins' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewards, RewardWeaponTrinkets) == 0x0000D0, "Member 'FOakChallengeTierRewards::RewardWeaponTrinkets' has a wrong offset!");

// ScriptStruct OakGame.GFxMapMenu_Adjustment
// 0x0010 (0x0010 - 0x0000)
struct FGFxMapMenu_Adjustment final
{
public:
	struct FVector2D                              ContextMenuOffsetExpandingDown;                    // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ContextMenuOffsetExpandingUp;                      // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxMapMenu_Adjustment) == 0x000004, "Wrong alignment on FGFxMapMenu_Adjustment");
static_assert(sizeof(FGFxMapMenu_Adjustment) == 0x000010, "Wrong size on FGFxMapMenu_Adjustment");
static_assert(offsetof(FGFxMapMenu_Adjustment, ContextMenuOffsetExpandingDown) == 0x000000, "Member 'FGFxMapMenu_Adjustment::ContextMenuOffsetExpandingDown' has a wrong offset!");
static_assert(offsetof(FGFxMapMenu_Adjustment, ContextMenuOffsetExpandingUp) == 0x000008, "Member 'FGFxMapMenu_Adjustment::ContextMenuOffsetExpandingUp' has a wrong offset!");

// ScriptStruct OakGame.FriendIconNameAndIndex
// 0x0018 (0x0018 - 0x0000)
struct FFriendIconNameAndIndex final
{
public:
	int32                                         IconFlashIndex;                                    // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconTextureName;                                   // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendIconNameAndIndex) == 0x000008, "Wrong alignment on FFriendIconNameAndIndex");
static_assert(sizeof(FFriendIconNameAndIndex) == 0x000018, "Wrong size on FFriendIconNameAndIndex");
static_assert(offsetof(FFriendIconNameAndIndex, IconFlashIndex) == 0x000000, "Member 'FFriendIconNameAndIndex::IconFlashIndex' has a wrong offset!");
static_assert(offsetof(FFriendIconNameAndIndex, IconTextureName) == 0x000008, "Member 'FFriendIconNameAndIndex::IconTextureName' has a wrong offset!");

// ScriptStruct OakGame.StandInLightComponentInstance
// 0x0028 (0x0028 - 0x0000)
struct FStandInLightComponentInstance final
{
public:
	class ULightComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandInLightComponentInstance) == 0x000008, "Wrong alignment on FStandInLightComponentInstance");
static_assert(sizeof(FStandInLightComponentInstance) == 0x000028, "Wrong size on FStandInLightComponentInstance");
static_assert(offsetof(FStandInLightComponentInstance, Component) == 0x000000, "Member 'FStandInLightComponentInstance::Component' has a wrong offset!");

// ScriptStruct OakGame.WeaponSightEffectTableData
// 0x0010 (0x0018 - 0x0008)
struct FWeaponSightEffectTableData final : public FTableRowBase
{
public:
	struct FLinearColor                           CrosshairColor;                                    // 0x0008(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSightEffectTableData) == 0x000008, "Wrong alignment on FWeaponSightEffectTableData");
static_assert(sizeof(FWeaponSightEffectTableData) == 0x000018, "Wrong size on FWeaponSightEffectTableData");
static_assert(offsetof(FWeaponSightEffectTableData, CrosshairColor) == 0x000008, "Member 'FWeaponSightEffectTableData::CrosshairColor' has a wrong offset!");

// ScriptStruct OakGame.MinimapBoundingCircle
// 0x000C (0x000C - 0x0000)
struct FMinimapBoundingCircle final
{
public:
	struct FVector2D                              CenterPoint;                                       // 0x0000(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinimapBoundingCircle) == 0x000004, "Wrong alignment on FMinimapBoundingCircle");
static_assert(sizeof(FMinimapBoundingCircle) == 0x00000C, "Wrong size on FMinimapBoundingCircle");
static_assert(offsetof(FMinimapBoundingCircle, CenterPoint) == 0x000000, "Member 'FMinimapBoundingCircle::CenterPoint' has a wrong offset!");

// ScriptStruct OakGame.MeleeReverseImpactEntry
// 0x0008 (0x0008 - 0x0000)
struct FMeleeReverseImpactEntry final
{
public:
	float                                         TargetMass;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactForce;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeReverseImpactEntry) == 0x000004, "Wrong alignment on FMeleeReverseImpactEntry");
static_assert(sizeof(FMeleeReverseImpactEntry) == 0x000008, "Wrong size on FMeleeReverseImpactEntry");
static_assert(offsetof(FMeleeReverseImpactEntry, TargetMass) == 0x000000, "Member 'FMeleeReverseImpactEntry::TargetMass' has a wrong offset!");
static_assert(offsetof(FMeleeReverseImpactEntry, ImpactForce) == 0x000004, "Member 'FMeleeReverseImpactEntry::ImpactForce' has a wrong offset!");

// ScriptStruct OakGame.GFxMissionLogMissionItem
// 0x0050 (0x0050 - 0x0000)
struct FGFxMissionLogMissionItem final
{
public:
	bool                                          bValid;                                            // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayText;                                       // 0x0008(0x0018)(Transient, NativeAccessSpecifierPublic)
	EGFxMissionLogMissionItemType                 Type;                                              // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakMission*                            AsOakMission;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UEchoLogData>            EchoLogData;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakMissionType                               MissionType;                                       // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTracked;                                        // 0x0041(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocked;                                        // 0x0042(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCompleted;                                      // 0x0043(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCurrentZone;                                  // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenViewed;                                    // 0x0045(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxMissionLogMissionIconType                 IconType;                                          // 0x0046(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumFriendsPlayingThisMission;                      // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxMissionLogMissionItem) == 0x000008, "Wrong alignment on FGFxMissionLogMissionItem");
static_assert(sizeof(FGFxMissionLogMissionItem) == 0x000050, "Wrong size on FGFxMissionLogMissionItem");
static_assert(offsetof(FGFxMissionLogMissionItem, bValid) == 0x000000, "Member 'FGFxMissionLogMissionItem::bValid' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, DisplayText) == 0x000008, "Member 'FGFxMissionLogMissionItem::DisplayText' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, Type) == 0x000020, "Member 'FGFxMissionLogMissionItem::Type' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, MissionClass) == 0x000028, "Member 'FGFxMissionLogMissionItem::MissionClass' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, AsOakMission) == 0x000030, "Member 'FGFxMissionLogMissionItem::AsOakMission' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, EchoLogData) == 0x000038, "Member 'FGFxMissionLogMissionItem::EchoLogData' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, MissionType) == 0x000040, "Member 'FGFxMissionLogMissionItem::MissionType' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, bIsTracked) == 0x000041, "Member 'FGFxMissionLogMissionItem::bIsTracked' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, bIsBlocked) == 0x000042, "Member 'FGFxMissionLogMissionItem::bIsBlocked' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, bIsCompleted) == 0x000043, "Member 'FGFxMissionLogMissionItem::bIsCompleted' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, bIsInCurrentZone) == 0x000044, "Member 'FGFxMissionLogMissionItem::bIsInCurrentZone' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, bHasBeenViewed) == 0x000045, "Member 'FGFxMissionLogMissionItem::bHasBeenViewed' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, IconType) == 0x000046, "Member 'FGFxMissionLogMissionItem::IconType' has a wrong offset!");
static_assert(offsetof(FGFxMissionLogMissionItem, NumFriendsPlayingThisMission) == 0x000048, "Member 'FGFxMissionLogMissionItem::NumFriendsPlayingThisMission' has a wrong offset!");

// ScriptStruct OakGame.GFxMissionTrackerRewardQueueData
// 0x0030 (0x0030 - 0x0000)
struct FGFxMissionTrackerRewardQueueData final
{
public:
	struct FGFxMissionTrackerRewardDisplayData    RewardData;                                        // 0x0000(0x0020)(Transient, NativeAccessSpecifierPublic)
	TSubclassOf<class UMission>                   Mission;                                           // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxMissionTrackerRewardQueueData) == 0x000008, "Wrong alignment on FGFxMissionTrackerRewardQueueData");
static_assert(sizeof(FGFxMissionTrackerRewardQueueData) == 0x000030, "Wrong size on FGFxMissionTrackerRewardQueueData");
static_assert(offsetof(FGFxMissionTrackerRewardQueueData, RewardData) == 0x000000, "Member 'FGFxMissionTrackerRewardQueueData::RewardData' has a wrong offset!");
static_assert(offsetof(FGFxMissionTrackerRewardQueueData, Mission) == 0x000020, "Member 'FGFxMissionTrackerRewardQueueData::Mission' has a wrong offset!");

// ScriptStruct OakGame.Transition
// 0x0020 (0x0020 - 0x0000)
struct FTransition final
{
public:
	class UGFxNewsItem*                           Curr;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxNewsItem*                           Next;                                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransition) == 0x000008, "Wrong alignment on FTransition");
static_assert(sizeof(FTransition) == 0x000020, "Wrong size on FTransition");
static_assert(offsetof(FTransition, Curr) == 0x000000, "Member 'FTransition::Curr' has a wrong offset!");
static_assert(offsetof(FTransition, Next) == 0x000008, "Member 'FTransition::Next' has a wrong offset!");

// ScriptStruct OakGame.GFxOakMenuHelpers
// 0x0001 (0x0001 - 0x0000)
struct FGFxOakMenuHelpers final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxOakMenuHelpers) == 0x000001, "Wrong alignment on FGFxOakMenuHelpers");
static_assert(sizeof(FGFxOakMenuHelpers) == 0x000001, "Wrong size on FGFxOakMenuHelpers");

// ScriptStruct OakGame.ChallengeMinimapIcon
// 0x0028 (0x0028 - 0x0000)
struct FChallengeMinimapIcon final
{
public:
	class UChallengeLevelActorComponent*          LevelActorComponent;                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxMinimapWidget*                      MinimapIconWidget;                                 // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MinimapIconGUID;                                   // 0x0010(0x0010)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeMinimapIcon) == 0x000008, "Wrong alignment on FChallengeMinimapIcon");
static_assert(sizeof(FChallengeMinimapIcon) == 0x000028, "Wrong size on FChallengeMinimapIcon");
static_assert(offsetof(FChallengeMinimapIcon, LevelActorComponent) == 0x000000, "Member 'FChallengeMinimapIcon::LevelActorComponent' has a wrong offset!");
static_assert(offsetof(FChallengeMinimapIcon, MinimapIconWidget) == 0x000008, "Member 'FChallengeMinimapIcon::MinimapIconWidget' has a wrong offset!");
static_assert(offsetof(FChallengeMinimapIcon, MinimapIconGUID) == 0x000010, "Member 'FChallengeMinimapIcon::MinimapIconGUID' has a wrong offset!");
static_assert(offsetof(FChallengeMinimapIcon, bCompleted) == 0x000020, "Member 'FChallengeMinimapIcon::bCompleted' has a wrong offset!");

// ScriptStruct OakGame.SubtitleBarItems
// 0x0040 (0x0040 - 0x0000)
struct FSubtitleBarItems final
{
public:
	class UGbxGFxGridScrollingList*               ControlsSubtitlesSL;                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxHintWidget*                      LeftNavButton;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxListCell*                        BasicTab;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxListCell*                        AdvancedTab;                                       // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxListCell*                        BenchmarkTab;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxListCell*                        KeyboardMappings;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxListCell*                        GamepadMappings;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxHintWidget*                      RightNavButton;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubtitleBarItems) == 0x000008, "Wrong alignment on FSubtitleBarItems");
static_assert(sizeof(FSubtitleBarItems) == 0x000040, "Wrong size on FSubtitleBarItems");
static_assert(offsetof(FSubtitleBarItems, ControlsSubtitlesSL) == 0x000000, "Member 'FSubtitleBarItems::ControlsSubtitlesSL' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, LeftNavButton) == 0x000008, "Member 'FSubtitleBarItems::LeftNavButton' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, BasicTab) == 0x000010, "Member 'FSubtitleBarItems::BasicTab' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, AdvancedTab) == 0x000018, "Member 'FSubtitleBarItems::AdvancedTab' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, BenchmarkTab) == 0x000020, "Member 'FSubtitleBarItems::BenchmarkTab' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, KeyboardMappings) == 0x000028, "Member 'FSubtitleBarItems::KeyboardMappings' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, GamepadMappings) == 0x000030, "Member 'FSubtitleBarItems::GamepadMappings' has a wrong offset!");
static_assert(offsetof(FSubtitleBarItems, RightNavButton) == 0x000038, "Member 'FSubtitleBarItems::RightNavButton' has a wrong offset!");

// ScriptStruct OakGame.SirenStandInFlourish
// 0x0028 (0x0028 - 0x0000)
struct FSirenStandInFlourish final
{
public:
	TArray<TSoftObjectPtr<class UOakActionAbilityAugmentData>> SlotDatas;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bHideCharacterDuringFlourish;                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartAuxiliaryActorHidden;                        // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AStandInAuxiliaryActor_Siren> AuxiliaryActor;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 Animation;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSirenStandInFlourish) == 0x000008, "Wrong alignment on FSirenStandInFlourish");
static_assert(sizeof(FSirenStandInFlourish) == 0x000028, "Wrong size on FSirenStandInFlourish");
static_assert(offsetof(FSirenStandInFlourish, SlotDatas) == 0x000000, "Member 'FSirenStandInFlourish::SlotDatas' has a wrong offset!");
static_assert(offsetof(FSirenStandInFlourish, bHideCharacterDuringFlourish) == 0x000010, "Member 'FSirenStandInFlourish::bHideCharacterDuringFlourish' has a wrong offset!");
static_assert(offsetof(FSirenStandInFlourish, bStartAuxiliaryActorHidden) == 0x000011, "Member 'FSirenStandInFlourish::bStartAuxiliaryActorHidden' has a wrong offset!");
static_assert(offsetof(FSirenStandInFlourish, AuxiliaryActor) == 0x000018, "Member 'FSirenStandInFlourish::AuxiliaryActor' has a wrong offset!");
static_assert(offsetof(FSirenStandInFlourish, Animation) == 0x000020, "Member 'FSirenStandInFlourish::Animation' has a wrong offset!");

// ScriptStruct OakGame.VendingObjectToSocketLocationMap
// 0x0050 (0x0050 - 0x0000)
struct FVendingObjectToSocketLocationMap final
{
public:
	TMap<class UGbxGFxObject*, struct FVendingMachineSocketLocationAndOffset> SocketMap;                                         // 0x0000(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingObjectToSocketLocationMap) == 0x000008, "Wrong alignment on FVendingObjectToSocketLocationMap");
static_assert(sizeof(FVendingObjectToSocketLocationMap) == 0x000050, "Wrong size on FVendingObjectToSocketLocationMap");
static_assert(offsetof(FVendingObjectToSocketLocationMap, SocketMap) == 0x000000, "Member 'FVendingObjectToSocketLocationMap::SocketMap' has a wrong offset!");

// ScriptStruct OakGame.RepWindDirection
// 0x0008 (0x0008 - 0x0000)
struct FRepWindDirection final
{
public:
	float                                         TargetYaw;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepWindDirection) == 0x000004, "Wrong alignment on FRepWindDirection");
static_assert(sizeof(FRepWindDirection) == 0x000008, "Wrong size on FRepWindDirection");
static_assert(offsetof(FRepWindDirection, TargetYaw) == 0x000000, "Member 'FRepWindDirection::TargetYaw' has a wrong offset!");
static_assert(offsetof(FRepWindDirection, Duration) == 0x000004, "Member 'FRepWindDirection::Duration' has a wrong offset!");

// ScriptStruct OakGame.GFxPassiveSkillWidgetSlotData
// 0x0010 (0x0010 - 0x0000)
struct FGFxPassiveSkillWidgetSlotData final
{
public:
	class UOakPlayerAbilityHUDItemData*           HUDItemData;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxPassiveSkillIcon*                   Icon;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxPassiveSkillWidgetSlotData) == 0x000008, "Wrong alignment on FGFxPassiveSkillWidgetSlotData");
static_assert(sizeof(FGFxPassiveSkillWidgetSlotData) == 0x000010, "Wrong size on FGFxPassiveSkillWidgetSlotData");
static_assert(offsetof(FGFxPassiveSkillWidgetSlotData, HUDItemData) == 0x000000, "Member 'FGFxPassiveSkillWidgetSlotData::HUDItemData' has a wrong offset!");
static_assert(offsetof(FGFxPassiveSkillWidgetSlotData, Icon) == 0x000008, "Member 'FGFxPassiveSkillWidgetSlotData::Icon' has a wrong offset!");

// ScriptStruct OakGame.PauseMenuTickFunction
// 0x0010 (0x0060 - 0x0050)
struct FPauseMenuTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPauseMenuTickFunction) == 0x000008, "Wrong alignment on FPauseMenuTickFunction");
static_assert(sizeof(FPauseMenuTickFunction) == 0x000060, "Wrong size on FPauseMenuTickFunction");

// ScriptStruct OakGame.OakChallengeSaveGameData
// 0x0060 (0x0060 - 0x0000)
struct FOakChallengeSaveGameData final
{
public:
	int32                                         CompletedCount;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyCompleted;                               // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompletedProgressLevel;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressCounter;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOakChallengeStatSaveGameData>  StatInstanceState;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  RewardTiersClaimed;                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ChallengeClassPath;                                // 0x0030(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChallenge*                             DefaultChallengeObj;                               // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakChallengeSaveGameData) == 0x000008, "Wrong alignment on FOakChallengeSaveGameData");
static_assert(sizeof(FOakChallengeSaveGameData) == 0x000060, "Wrong size on FOakChallengeSaveGameData");
static_assert(offsetof(FOakChallengeSaveGameData, CompletedCount) == 0x000000, "Member 'FOakChallengeSaveGameData::CompletedCount' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, bIsActive) == 0x000004, "Member 'FOakChallengeSaveGameData::bIsActive' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, bCurrentlyCompleted) == 0x000005, "Member 'FOakChallengeSaveGameData::bCurrentlyCompleted' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, CompletedProgressLevel) == 0x000008, "Member 'FOakChallengeSaveGameData::CompletedProgressLevel' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, ProgressCounter) == 0x00000C, "Member 'FOakChallengeSaveGameData::ProgressCounter' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, StatInstanceState) == 0x000010, "Member 'FOakChallengeSaveGameData::StatInstanceState' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, RewardTiersClaimed) == 0x000020, "Member 'FOakChallengeSaveGameData::RewardTiersClaimed' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, ChallengeClassPath) == 0x000030, "Member 'FOakChallengeSaveGameData::ChallengeClassPath' has a wrong offset!");
static_assert(offsetof(FOakChallengeSaveGameData, DefaultChallengeObj) == 0x000058, "Member 'FOakChallengeSaveGameData::DefaultChallengeObj' has a wrong offset!");

// ScriptStruct OakGame.PlaythroughSelectionModeEntry
// 0x0050 (0x0050 - 0x0000)
struct FPlaythroughSelectionModeEntry final
{
public:
	class FText                                   ModeName;                                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ModeDescription;                                   // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ModeFrameName;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaythroughNum;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ModeSelectionSound;                                // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlaythroughSelectionModeEntry) == 0x000008, "Wrong alignment on FPlaythroughSelectionModeEntry");
static_assert(sizeof(FPlaythroughSelectionModeEntry) == 0x000050, "Wrong size on FPlaythroughSelectionModeEntry");
static_assert(offsetof(FPlaythroughSelectionModeEntry, ModeName) == 0x000000, "Member 'FPlaythroughSelectionModeEntry::ModeName' has a wrong offset!");
static_assert(offsetof(FPlaythroughSelectionModeEntry, ModeDescription) == 0x000018, "Member 'FPlaythroughSelectionModeEntry::ModeDescription' has a wrong offset!");
static_assert(offsetof(FPlaythroughSelectionModeEntry, ModeFrameName) == 0x000030, "Member 'FPlaythroughSelectionModeEntry::ModeFrameName' has a wrong offset!");
static_assert(offsetof(FPlaythroughSelectionModeEntry, PlaythroughNum) == 0x000040, "Member 'FPlaythroughSelectionModeEntry::PlaythroughNum' has a wrong offset!");
static_assert(offsetof(FPlaythroughSelectionModeEntry, ModeSelectionSound) == 0x000048, "Member 'FPlaythroughSelectionModeEntry::ModeSelectionSound' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilitySlotList
// 0x0018 (0x00C8 - 0x00B0)
struct FOakPlayerAbilitySlotList final : public FFastArraySerializer
{
public:
	class UOakPlayerAbilityManagerComponent*      Owner;                                             // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakPlayerAbilitySlot>          Items;                                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPlayerAbilitySlotList) == 0x000008, "Wrong alignment on FOakPlayerAbilitySlotList");
static_assert(sizeof(FOakPlayerAbilitySlotList) == 0x0000C8, "Wrong size on FOakPlayerAbilitySlotList");
static_assert(offsetof(FOakPlayerAbilitySlotList, Owner) == 0x0000B0, "Member 'FOakPlayerAbilitySlotList::Owner' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilitySlotList, Items) == 0x0000B8, "Member 'FOakPlayerAbilitySlotList::Items' has a wrong offset!");

// ScriptStruct OakGame.QuickChangeRespecTreeBranchRow
// 0x0020 (0x0020 - 0x0000)
struct FQuickChangeRespecTreeBranchRow final
{
public:
	TArray<class UGbxGFxObject*>                  Entries;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          RespecAnim;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuickChangeRespecTreeBranchRow) == 0x000008, "Wrong alignment on FQuickChangeRespecTreeBranchRow");
static_assert(sizeof(FQuickChangeRespecTreeBranchRow) == 0x000020, "Wrong size on FQuickChangeRespecTreeBranchRow");
static_assert(offsetof(FQuickChangeRespecTreeBranchRow, Entries) == 0x000000, "Member 'FQuickChangeRespecTreeBranchRow::Entries' has a wrong offset!");
static_assert(offsetof(FQuickChangeRespecTreeBranchRow, RespecAnim) == 0x000010, "Member 'FQuickChangeRespecTreeBranchRow::RespecAnim' has a wrong offset!");

// ScriptStruct OakGame.IconNameAndIndex
// 0x0018 (0x0018 - 0x0000)
struct FIconNameAndIndex final
{
public:
	int32                                         IconFlashIndex;                                    // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IconTextureName;                                   // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIconNameAndIndex) == 0x000008, "Wrong alignment on FIconNameAndIndex");
static_assert(sizeof(FIconNameAndIndex) == 0x000018, "Wrong size on FIconNameAndIndex");
static_assert(offsetof(FIconNameAndIndex, IconFlashIndex) == 0x000000, "Member 'FIconNameAndIndex::IconFlashIndex' has a wrong offset!");
static_assert(offsetof(FIconNameAndIndex, IconTextureName) == 0x000008, "Member 'FIconNameAndIndex::IconTextureName' has a wrong offset!");

// ScriptStruct OakGame.GFxSkillScreenSkillInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FGFxSkillScreenSkillInfo final
{
public:
	ESkillItemDisplayType                         ItemType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxSkillScreenSkillInfo) == 0x000008, "Wrong alignment on FGFxSkillScreenSkillInfo");
static_assert(sizeof(FGFxSkillScreenSkillInfo) == 0x0000C8, "Wrong size on FGFxSkillScreenSkillInfo");
static_assert(offsetof(FGFxSkillScreenSkillInfo, ItemType) == 0x000000, "Member 'FGFxSkillScreenSkillInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenSkillInfo, ItemName) == 0x000008, "Member 'FGFxSkillScreenSkillInfo::ItemName' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenSkillInfo, ItemDescription) == 0x000020, "Member 'FGFxSkillScreenSkillInfo::ItemDescription' has a wrong offset!");

// ScriptStruct OakGame.GFxSkillScreenBranchContainer
// 0x0040 (0x0040 - 0x0000)
struct FGFxSkillScreenBranchContainer final
{
public:
	class UGbxGFxObject*                          Root;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          BranchObject;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxSkillScreenBranch*                  Branch;                                            // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxSkillScreenBranch*                  OriginalBranch;                                    // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxSkillScreenBranchContainer) == 0x000008, "Wrong alignment on FGFxSkillScreenBranchContainer");
static_assert(sizeof(FGFxSkillScreenBranchContainer) == 0x000040, "Wrong size on FGFxSkillScreenBranchContainer");
static_assert(offsetof(FGFxSkillScreenBranchContainer, Root) == 0x000000, "Member 'FGFxSkillScreenBranchContainer::Root' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenBranchContainer, BranchObject) == 0x000008, "Member 'FGFxSkillScreenBranchContainer::BranchObject' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenBranchContainer, Branch) == 0x000010, "Member 'FGFxSkillScreenBranchContainer::Branch' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenBranchContainer, OriginalBranch) == 0x000018, "Member 'FGFxSkillScreenBranchContainer::OriginalBranch' has a wrong offset!");

// ScriptStruct OakGame.GFxSkillScreenInfoCardContainer
// 0x0160 (0x0160 - 0x0000)
struct FGFxSkillScreenInfoCardContainer final
{
public:
	class UGbxGFxObject*                          Root;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x110];                                      // 0x0008(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxButton*                          InfoCardButton;                                    // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          IconArt;                                           // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxTextField*                          DescriptionText;                                   // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxSlider*                          ScrollBar;                                         // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          ScrollMask;                                        // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AvailablePointsString;                             // 0x0140(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxSkillScreenInfoCardContainer) == 0x000008, "Wrong alignment on FGFxSkillScreenInfoCardContainer");
static_assert(sizeof(FGFxSkillScreenInfoCardContainer) == 0x000160, "Wrong size on FGFxSkillScreenInfoCardContainer");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, Root) == 0x000000, "Member 'FGFxSkillScreenInfoCardContainer::Root' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, InfoCardButton) == 0x000118, "Member 'FGFxSkillScreenInfoCardContainer::InfoCardButton' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, IconArt) == 0x000120, "Member 'FGFxSkillScreenInfoCardContainer::IconArt' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, DescriptionText) == 0x000128, "Member 'FGFxSkillScreenInfoCardContainer::DescriptionText' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, ScrollBar) == 0x000130, "Member 'FGFxSkillScreenInfoCardContainer::ScrollBar' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, ScrollMask) == 0x000138, "Member 'FGFxSkillScreenInfoCardContainer::ScrollMask' has a wrong offset!");
static_assert(offsetof(FGFxSkillScreenInfoCardContainer, AvailablePointsString) == 0x000140, "Member 'FGFxSkillScreenInfoCardContainer::AvailablePointsString' has a wrong offset!");

// ScriptStruct OakGame.GFxStatusMenuSubmenuKeyMap
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGFxStatusMenuSubmenuKeyMap final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubMenuId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxStatusMenuSubmenuKeyMap) == 0x000008, "Wrong alignment on FGFxStatusMenuSubmenuKeyMap");
static_assert(sizeof(FGFxStatusMenuSubmenuKeyMap) == 0x000010, "Wrong size on FGFxStatusMenuSubmenuKeyMap");
static_assert(offsetof(FGFxStatusMenuSubmenuKeyMap, InputAction) == 0x000000, "Member 'FGFxStatusMenuSubmenuKeyMap::InputAction' has a wrong offset!");
static_assert(offsetof(FGFxStatusMenuSubmenuKeyMap, SubMenuId) == 0x000008, "Member 'FGFxStatusMenuSubmenuKeyMap::SubMenuId' has a wrong offset!");

// ScriptStruct OakGame.GFxStoreMenuDLCItem
// 0x0050 (0x0050 - 0x0000)
struct FGFxStoreMenuDLCItem final
{
public:
	EGFxStoreMenuTabType                          Type;                                              // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0008(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FString                                 PreviewImageUrl;                                   // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPurchased;                                        // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDownloaded;                                       // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DiscountPercent;                                   // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxStoreMenuDLCItem) == 0x000008, "Wrong alignment on FGFxStoreMenuDLCItem");
static_assert(sizeof(FGFxStoreMenuDLCItem) == 0x000050, "Wrong size on FGFxStoreMenuDLCItem");
static_assert(offsetof(FGFxStoreMenuDLCItem, Type) == 0x000000, "Member 'FGFxStoreMenuDLCItem::Type' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuDLCItem, Name) == 0x000008, "Member 'FGFxStoreMenuDLCItem::Name' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuDLCItem, Description) == 0x000020, "Member 'FGFxStoreMenuDLCItem::Description' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuDLCItem, PreviewImageUrl) == 0x000038, "Member 'FGFxStoreMenuDLCItem::PreviewImageUrl' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuDLCItem, bPurchased) == 0x000048, "Member 'FGFxStoreMenuDLCItem::bPurchased' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuDLCItem, bDownloaded) == 0x000049, "Member 'FGFxStoreMenuDLCItem::bDownloaded' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuDLCItem, DiscountPercent) == 0x00004C, "Member 'FGFxStoreMenuDLCItem::DiscountPercent' has a wrong offset!");

// ScriptStruct OakGame.GFxStoreMenuPage
// 0x0068 (0x0068 - 0x0000)
struct FGFxStoreMenuPage final
{
public:
	EGFxStoreMenuTabType                          PageType;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGFxStoreMenuDLCItem                   FeaturedItem;                                      // 0x0008(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FGFxStoreMenuDLCItem>           NonFeaturedItems;                                  // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxStoreMenuPage) == 0x000008, "Wrong alignment on FGFxStoreMenuPage");
static_assert(sizeof(FGFxStoreMenuPage) == 0x000068, "Wrong size on FGFxStoreMenuPage");
static_assert(offsetof(FGFxStoreMenuPage, PageType) == 0x000000, "Member 'FGFxStoreMenuPage::PageType' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuPage, FeaturedItem) == 0x000008, "Member 'FGFxStoreMenuPage::FeaturedItem' has a wrong offset!");
static_assert(offsetof(FGFxStoreMenuPage, NonFeaturedItems) == 0x000058, "Member 'FGFxStoreMenuPage::NonFeaturedItems' has a wrong offset!");

// ScriptStruct OakGame.SubtitleLine
// 0x0020 (0x0020 - 0x0000)
struct FSubtitleLine final
{
public:
	class FText                                   TextToDisplay;                                     // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubtitleLine) == 0x000008, "Wrong alignment on FSubtitleLine");
static_assert(sizeof(FSubtitleLine) == 0x000020, "Wrong size on FSubtitleLine");
static_assert(offsetof(FSubtitleLine, TextToDisplay) == 0x000000, "Member 'FSubtitleLine::TextToDisplay' has a wrong offset!");
static_assert(offsetof(FSubtitleLine, Duration) == 0x000018, "Member 'FSubtitleLine::Duration' has a wrong offset!");
static_assert(offsetof(FSubtitleLine, bForce) == 0x00001C, "Member 'FSubtitleLine::bForce' has a wrong offset!");

// ScriptStruct OakGame.GFxVaultHunterProfileCardInventoryConfig
// 0x00C8 (0x00C8 - 0x0000)
struct FGFxVaultHunterProfileCardInventoryConfig final
{
public:
	class FString                                 WeaponRarityFrames[0x4];                           // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponTypeFrames[0x4];                             // 0x0040(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GrenadeRarityFrame;                                // 0x0080(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShieldRarityFrame;                                 // 0x0090(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClassModRarityFrame;                               // 0x00A0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RelicRarityFrame;                                  // 0x00B0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRelic2;                                         // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGFxVaultHunterProfileCardInventoryConfig) == 0x000008, "Wrong alignment on FGFxVaultHunterProfileCardInventoryConfig");
static_assert(sizeof(FGFxVaultHunterProfileCardInventoryConfig) == 0x0000C8, "Wrong size on FGFxVaultHunterProfileCardInventoryConfig");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, WeaponRarityFrames) == 0x000000, "Member 'FGFxVaultHunterProfileCardInventoryConfig::WeaponRarityFrames' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, WeaponTypeFrames) == 0x000040, "Member 'FGFxVaultHunterProfileCardInventoryConfig::WeaponTypeFrames' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, GrenadeRarityFrame) == 0x000080, "Member 'FGFxVaultHunterProfileCardInventoryConfig::GrenadeRarityFrame' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, ShieldRarityFrame) == 0x000090, "Member 'FGFxVaultHunterProfileCardInventoryConfig::ShieldRarityFrame' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, ClassModRarityFrame) == 0x0000A0, "Member 'FGFxVaultHunterProfileCardInventoryConfig::ClassModRarityFrame' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, RelicRarityFrame) == 0x0000B0, "Member 'FGFxVaultHunterProfileCardInventoryConfig::RelicRarityFrame' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardInventoryConfig, bIsRelic2) == 0x0000C0, "Member 'FGFxVaultHunterProfileCardInventoryConfig::bIsRelic2' has a wrong offset!");

// ScriptStruct OakGame.GFxVaultHunterProfileCardSkillsConfig
// 0x0020 (0x0020 - 0x0000)
struct FGFxVaultHunterProfileCardSkillsConfig final
{
public:
	float                                         GreenProgress;                                     // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlueProgress;                                      // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedProgress;                                       // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PurpleProgress;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ClassFrameName;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGFxVaultHunterProfileCardSkillsConfig) == 0x000008, "Wrong alignment on FGFxVaultHunterProfileCardSkillsConfig");
static_assert(sizeof(FGFxVaultHunterProfileCardSkillsConfig) == 0x000020, "Wrong size on FGFxVaultHunterProfileCardSkillsConfig");
static_assert(offsetof(FGFxVaultHunterProfileCardSkillsConfig, GreenProgress) == 0x000000, "Member 'FGFxVaultHunterProfileCardSkillsConfig::GreenProgress' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardSkillsConfig, BlueProgress) == 0x000004, "Member 'FGFxVaultHunterProfileCardSkillsConfig::BlueProgress' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardSkillsConfig, RedProgress) == 0x000008, "Member 'FGFxVaultHunterProfileCardSkillsConfig::RedProgress' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardSkillsConfig, PurpleProgress) == 0x00000C, "Member 'FGFxVaultHunterProfileCardSkillsConfig::PurpleProgress' has a wrong offset!");
static_assert(offsetof(FGFxVaultHunterProfileCardSkillsConfig, ClassFrameName) == 0x000010, "Member 'FGFxVaultHunterProfileCardSkillsConfig::ClassFrameName' has a wrong offset!");

// ScriptStruct OakGame.ConditionalAudioSwitch
// 0x0010 (0x0010 - 0x0000)
struct FConditionalAudioSwitch final
{
public:
	class UGbxCondition*                          SwitchCondition;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseSwitch*                           SwitchToSet;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalAudioSwitch) == 0x000008, "Wrong alignment on FConditionalAudioSwitch");
static_assert(sizeof(FConditionalAudioSwitch) == 0x000010, "Wrong size on FConditionalAudioSwitch");
static_assert(offsetof(FConditionalAudioSwitch, SwitchCondition) == 0x000000, "Member 'FConditionalAudioSwitch::SwitchCondition' has a wrong offset!");
static_assert(offsetof(FConditionalAudioSwitch, SwitchToSet) == 0x000008, "Member 'FConditionalAudioSwitch::SwitchToSet' has a wrong offset!");

// ScriptStruct OakGame.VehicleEffectData
// 0x0068 (0x0068 - 0x0000)
struct FVehicleEffectData final
{
public:
	class FName                                   Event;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleEffect;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayerOnly : 1;                                   // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoActivate : 1;                                 // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayAudioAtLocation : 1;                          // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativeLocation;                                  // 0x001C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0028(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RelativeScale;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StartAudioEvent;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StopAudioEvent;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConditionalAudioSwitch>        ConditionalAudioSwitches;                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AudioComponentName;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioEmitterRadius;                                // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleEffectData) == 0x000008, "Wrong alignment on FVehicleEffectData");
static_assert(sizeof(FVehicleEffectData) == 0x000068, "Wrong size on FVehicleEffectData");
static_assert(offsetof(FVehicleEffectData, Event) == 0x000000, "Member 'FVehicleEffectData::Event' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, ParticleEffect) == 0x000008, "Member 'FVehicleEffectData::ParticleEffect' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, Socket) == 0x000010, "Member 'FVehicleEffectData::Socket' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, RelativeLocation) == 0x00001C, "Member 'FVehicleEffectData::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, RelativeRotation) == 0x000028, "Member 'FVehicleEffectData::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, RelativeScale) == 0x000034, "Member 'FVehicleEffectData::RelativeScale' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, StartAudioEvent) == 0x000038, "Member 'FVehicleEffectData::StartAudioEvent' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, StopAudioEvent) == 0x000040, "Member 'FVehicleEffectData::StopAudioEvent' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, ConditionalAudioSwitches) == 0x000048, "Member 'FVehicleEffectData::ConditionalAudioSwitches' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, AudioComponentName) == 0x000058, "Member 'FVehicleEffectData::AudioComponentName' has a wrong offset!");
static_assert(offsetof(FVehicleEffectData, AudioEmitterRadius) == 0x000060, "Member 'FVehicleEffectData::AudioEmitterRadius' has a wrong offset!");

// ScriptStruct OakGame.GoreSizeSelectionData
// 0x00A0 (0x00A0 - 0x0000)
struct FGoreSizeSelectionData final
{
public:
	uint8                                         bSpecifiedMinScale : 1;                            // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpecifiedMaxScale : 1;                            // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinScale;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    StumpMeshes;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                StumpParticles;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceConstant*>      StumpDecals;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StumpSound;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              StumpMaterialOverride;                             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        LimbMeshes;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                LimbParticles;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              LimbMaterialOverride;                              // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        LimbForce;                                         // 0x0078(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bScaleLimbToStump;                                 // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimbScale;                                         // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGoreSizeSelectionData) == 0x000008, "Wrong alignment on FGoreSizeSelectionData");
static_assert(sizeof(FGoreSizeSelectionData) == 0x0000A0, "Wrong size on FGoreSizeSelectionData");
static_assert(offsetof(FGoreSizeSelectionData, MinScale) == 0x000004, "Member 'FGoreSizeSelectionData::MinScale' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, MaxScale) == 0x000008, "Member 'FGoreSizeSelectionData::MaxScale' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, StumpMeshes) == 0x000010, "Member 'FGoreSizeSelectionData::StumpMeshes' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, StumpParticles) == 0x000020, "Member 'FGoreSizeSelectionData::StumpParticles' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, StumpDecals) == 0x000030, "Member 'FGoreSizeSelectionData::StumpDecals' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, StumpSound) == 0x000040, "Member 'FGoreSizeSelectionData::StumpSound' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, StumpMaterialOverride) == 0x000048, "Member 'FGoreSizeSelectionData::StumpMaterialOverride' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, LimbMeshes) == 0x000050, "Member 'FGoreSizeSelectionData::LimbMeshes' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, LimbParticles) == 0x000060, "Member 'FGoreSizeSelectionData::LimbParticles' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, LimbMaterialOverride) == 0x000070, "Member 'FGoreSizeSelectionData::LimbMaterialOverride' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, LimbForce) == 0x000078, "Member 'FGoreSizeSelectionData::LimbForce' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, bScaleLimbToStump) == 0x000098, "Member 'FGoreSizeSelectionData::bScaleLimbToStump' has a wrong offset!");
static_assert(offsetof(FGoreSizeSelectionData, LimbScale) == 0x00009C, "Member 'FGoreSizeSelectionData::LimbScale' has a wrong offset!");

// ScriptStruct OakGame.ConditionalLootableInteractionResponse
// 0x0018 (0x0018 - 0x0000)
struct FConditionalLootableInteractionResponse final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLootableInteractionResponse           Interaction;                                       // 0x0008(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalLootableInteractionResponse) == 0x000008, "Wrong alignment on FConditionalLootableInteractionResponse");
static_assert(sizeof(FConditionalLootableInteractionResponse) == 0x000018, "Wrong size on FConditionalLootableInteractionResponse");
static_assert(offsetof(FConditionalLootableInteractionResponse, Condition) == 0x000000, "Member 'FConditionalLootableInteractionResponse::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalLootableInteractionResponse, Interaction) == 0x000008, "Member 'FConditionalLootableInteractionResponse::Interaction' has a wrong offset!");

// ScriptStruct OakGame.MoneyStackValues
// 0x0010 (0x0010 - 0x0000)
struct FMoneyStackValues final
{
public:
	class UWwiseEvent*                            AudioEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemPoolListInterface*                 ItemPool;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoneyStackValues) == 0x000008, "Wrong alignment on FMoneyStackValues");
static_assert(sizeof(FMoneyStackValues) == 0x000010, "Wrong size on FMoneyStackValues");
static_assert(offsetof(FMoneyStackValues, AudioEvent) == 0x000000, "Member 'FMoneyStackValues::AudioEvent' has a wrong offset!");
static_assert(offsetof(FMoneyStackValues, ItemPool) == 0x000008, "Member 'FMoneyStackValues::ItemPool' has a wrong offset!");

// ScriptStruct OakGame.SingularityTargetInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSingularityTargetInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSingularityTargetInfo) == 0x000008, "Wrong alignment on FSingularityTargetInfo");
static_assert(sizeof(FSingularityTargetInfo) == 0x000010, "Wrong size on FSingularityTargetInfo");

// ScriptStruct OakGame.FrontendStandInSlotTransitionSettings
// 0x0010 (0x0010 - 0x0000)
struct FFrontendStandInSlotTransitionSettings final
{
public:
	TArray<int32>                                 SlotsToHideDuringInspection;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrontendStandInSlotTransitionSettings) == 0x000008, "Wrong alignment on FFrontendStandInSlotTransitionSettings");
static_assert(sizeof(FFrontendStandInSlotTransitionSettings) == 0x000010, "Wrong size on FFrontendStandInSlotTransitionSettings");
static_assert(offsetof(FFrontendStandInSlotTransitionSettings, SlotsToHideDuringInspection) == 0x000000, "Member 'FFrontendStandInSlotTransitionSettings::SlotsToHideDuringInspection' has a wrong offset!");

// ScriptStruct OakGame.SingularityInitializationInfo
// 0x0050 (0x00C0 - 0x0070)
struct FSingularityInitializationInfo final : public FSingularityInitializationBase
{
public:
	float                                         Duration;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForcePerSecond;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpinDirection                                SpinDirection;                                     // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpinMinDistance;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinMaxDistance;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinHorizontalScalar;                              // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinVerticalScalar;                                // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x008C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToOwnerRoot;                                // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistantComponent;                              // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        SingularityParticles;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDestructibleChunkMass;                         // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageSource>              SingularitySource;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFalloffScalar;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSingularityInitializationInfo) == 0x000008, "Wrong alignment on FSingularityInitializationInfo");
static_assert(sizeof(FSingularityInitializationInfo) == 0x0000C0, "Wrong size on FSingularityInitializationInfo");
static_assert(offsetof(FSingularityInitializationInfo, Duration) == 0x000070, "Member 'FSingularityInitializationInfo::Duration' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, ForcePerSecond) == 0x000074, "Member 'FSingularityInitializationInfo::ForcePerSecond' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SpinDirection) == 0x000078, "Member 'FSingularityInitializationInfo::SpinDirection' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SpinMinDistance) == 0x00007C, "Member 'FSingularityInitializationInfo::SpinMinDistance' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SpinMaxDistance) == 0x000080, "Member 'FSingularityInitializationInfo::SpinMaxDistance' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SpinHorizontalScalar) == 0x000084, "Member 'FSingularityInitializationInfo::SpinHorizontalScalar' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SpinVerticalScalar) == 0x000088, "Member 'FSingularityInitializationInfo::SpinVerticalScalar' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, LocationOffset) == 0x00008C, "Member 'FSingularityInitializationInfo::LocationOffset' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, bAttachToOwnerRoot) == 0x000098, "Member 'FSingularityInitializationInfo::bAttachToOwnerRoot' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, bPersistantComponent) == 0x000099, "Member 'FSingularityInitializationInfo::bPersistantComponent' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SingularityParticles) == 0x0000A0, "Member 'FSingularityInitializationInfo::SingularityParticles' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, BaseDestructibleChunkMass) == 0x0000A8, "Member 'FSingularityInitializationInfo::BaseDestructibleChunkMass' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, SingularitySource) == 0x0000B0, "Member 'FSingularityInitializationInfo::SingularitySource' has a wrong offset!");
static_assert(offsetof(FSingularityInitializationInfo, MinFalloffScalar) == 0x0000B8, "Member 'FSingularityInitializationInfo::MinFalloffScalar' has a wrong offset!");

// ScriptStruct OakGame.LevelPersistence_Actor_SaveGameData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLevelPersistence_Actor_SaveGameData final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimerRemaining;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelPersistence_Actor_SaveGameData) == 0x000008, "Wrong alignment on FLevelPersistence_Actor_SaveGameData");
static_assert(sizeof(FLevelPersistence_Actor_SaveGameData) == 0x000010, "Wrong size on FLevelPersistence_Actor_SaveGameData");
static_assert(offsetof(FLevelPersistence_Actor_SaveGameData, ActorName) == 0x000000, "Member 'FLevelPersistence_Actor_SaveGameData::ActorName' has a wrong offset!");
static_assert(offsetof(FLevelPersistence_Actor_SaveGameData, TimerRemaining) == 0x000008, "Member 'FLevelPersistence_Actor_SaveGameData::TimerRemaining' has a wrong offset!");

// ScriptStruct OakGame.OakCharacterMassData
// 0x0010 (0x0018 - 0x0008)
struct FOakCharacterMassData final : public FTableRowBase
{
public:
	float                                         Mass;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchThreshold;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaggerThreshold;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchThreshold;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCharacterMassData) == 0x000008, "Wrong alignment on FOakCharacterMassData");
static_assert(sizeof(FOakCharacterMassData) == 0x000018, "Wrong size on FOakCharacterMassData");
static_assert(offsetof(FOakCharacterMassData, Mass) == 0x000008, "Member 'FOakCharacterMassData::Mass' has a wrong offset!");
static_assert(offsetof(FOakCharacterMassData, FlinchThreshold) == 0x00000C, "Member 'FOakCharacterMassData::FlinchThreshold' has a wrong offset!");
static_assert(offsetof(FOakCharacterMassData, StaggerThreshold) == 0x000010, "Member 'FOakCharacterMassData::StaggerThreshold' has a wrong offset!");
static_assert(offsetof(FOakCharacterMassData, LaunchThreshold) == 0x000014, "Member 'FOakCharacterMassData::LaunchThreshold' has a wrong offset!");

// ScriptStruct OakGame.OakAISwarmMovement
// 0x0188 (0x0188 - 0x0000)
struct FOakAISwarmMovement final
{
public:
	struct FGbxParam                              MaxSpeed;                                          // 0x0000(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              Acceleration;                                      // 0x0080(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              RotationRate;                                      // 0x0100(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EOakAISwarmRotation                           RotationType;                                      // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAISwarmMovement) == 0x000008, "Wrong alignment on FOakAISwarmMovement");
static_assert(sizeof(FOakAISwarmMovement) == 0x000188, "Wrong size on FOakAISwarmMovement");
static_assert(offsetof(FOakAISwarmMovement, MaxSpeed) == 0x000000, "Member 'FOakAISwarmMovement::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FOakAISwarmMovement, Acceleration) == 0x000080, "Member 'FOakAISwarmMovement::Acceleration' has a wrong offset!");
static_assert(offsetof(FOakAISwarmMovement, RotationRate) == 0x000100, "Member 'FOakAISwarmMovement::RotationRate' has a wrong offset!");
static_assert(offsetof(FOakAISwarmMovement, RotationType) == 0x000180, "Member 'FOakAISwarmMovement::RotationType' has a wrong offset!");

// ScriptStruct OakGame.VehiclePartListData
// 0x0000 (0x0028 - 0x0028)
struct FVehiclePartListData final : public FActorPartListData
{
};
static_assert(alignof(FVehiclePartListData) == 0x000008, "Wrong alignment on FVehiclePartListData");
static_assert(sizeof(FVehiclePartListData) == 0x000028, "Wrong size on FVehiclePartListData");

// ScriptStruct OakGame.HolsteredGearSlotOptions
// 0x0010 (0x0010 - 0x0000)
struct FHolsteredGearSlotOptions final
{
public:
	class UInventoryCategoryData*                 InventoryCategory;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHolsteredGearSlotOptions) == 0x000008, "Wrong alignment on FHolsteredGearSlotOptions");
static_assert(sizeof(FHolsteredGearSlotOptions) == 0x000010, "Wrong size on FHolsteredGearSlotOptions");
static_assert(offsetof(FHolsteredGearSlotOptions, InventoryCategory) == 0x000000, "Member 'FHolsteredGearSlotOptions::InventoryCategory' has a wrong offset!");

// ScriptStruct OakGame.HolsteredGearAttachmentSlot
// 0x0018 (0x0018 - 0x0000)
struct FHolsteredGearAttachmentSlot final
{
public:
	class AHolsteredGearSlot*                     OuterSlot;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         Mesh;                                              // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHolsteredGearAttachmentSlot) == 0x000008, "Wrong alignment on FHolsteredGearAttachmentSlot");
static_assert(sizeof(FHolsteredGearAttachmentSlot) == 0x000018, "Wrong size on FHolsteredGearAttachmentSlot");
static_assert(offsetof(FHolsteredGearAttachmentSlot, OuterSlot) == 0x000000, "Member 'FHolsteredGearAttachmentSlot::OuterSlot' has a wrong offset!");
static_assert(offsetof(FHolsteredGearAttachmentSlot, Mesh) == 0x000008, "Member 'FHolsteredGearAttachmentSlot::Mesh' has a wrong offset!");

// ScriptStruct OakGame.LargeLiquidBodySurfaceSectionClippingVolume
// 0x0010 (0x0010 - 0x0000)
struct FLargeLiquidBodySurfaceSectionClippingVolume final
{
public:
	TArray<struct FPlane>                         ClippingPlanes;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLargeLiquidBodySurfaceSectionClippingVolume) == 0x000008, "Wrong alignment on FLargeLiquidBodySurfaceSectionClippingVolume");
static_assert(sizeof(FLargeLiquidBodySurfaceSectionClippingVolume) == 0x000010, "Wrong size on FLargeLiquidBodySurfaceSectionClippingVolume");
static_assert(offsetof(FLargeLiquidBodySurfaceSectionClippingVolume, ClippingPlanes) == 0x000000, "Member 'FLargeLiquidBodySurfaceSectionClippingVolume::ClippingPlanes' has a wrong offset!");

// ScriptStruct OakGame.LargeLiquidBodySurfaceSection
// 0x0018 (0x0018 - 0x0000)
struct FLargeLiquidBodySurfaceSection final
{
public:
	float                                         WorldZ;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLargeLiquidBodySurfaceSectionClippingVolume> ClippingVolumes;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLargeLiquidBodySurfaceSection) == 0x000008, "Wrong alignment on FLargeLiquidBodySurfaceSection");
static_assert(sizeof(FLargeLiquidBodySurfaceSection) == 0x000018, "Wrong size on FLargeLiquidBodySurfaceSection");
static_assert(offsetof(FLargeLiquidBodySurfaceSection, WorldZ) == 0x000000, "Member 'FLargeLiquidBodySurfaceSection::WorldZ' has a wrong offset!");
static_assert(offsetof(FLargeLiquidBodySurfaceSection, ClippingVolumes) == 0x000008, "Member 'FLargeLiquidBodySurfaceSection::ClippingVolumes' has a wrong offset!");

// ScriptStruct OakGame.WeaponSkinManufacturerData
// 0x0018 (0x0018 - 0x0000)
struct FWeaponSkinManufacturerData final
{
public:
	class UManufacturerData*                      Manufacturer;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeaponSkinWeaponTypeData>      WeaponTypes;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponSkinManufacturerData) == 0x000008, "Wrong alignment on FWeaponSkinManufacturerData");
static_assert(sizeof(FWeaponSkinManufacturerData) == 0x000018, "Wrong size on FWeaponSkinManufacturerData");
static_assert(offsetof(FWeaponSkinManufacturerData, Manufacturer) == 0x000000, "Member 'FWeaponSkinManufacturerData::Manufacturer' has a wrong offset!");
static_assert(offsetof(FWeaponSkinManufacturerData, WeaponTypes) == 0x000008, "Member 'FWeaponSkinManufacturerData::WeaponTypes' has a wrong offset!");

// ScriptStruct OakGame.OakThumbnailManagerConfig
// 0x0018 (0x0018 - 0x0000)
struct FOakThumbnailManagerConfig final
{
public:
	float                                         ThumbnailLoadFrequency;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxThumbnails;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ThumbnailSize;                                     // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ThumbnailMaterial;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakThumbnailManagerConfig) == 0x000008, "Wrong alignment on FOakThumbnailManagerConfig");
static_assert(sizeof(FOakThumbnailManagerConfig) == 0x000018, "Wrong size on FOakThumbnailManagerConfig");
static_assert(offsetof(FOakThumbnailManagerConfig, ThumbnailLoadFrequency) == 0x000000, "Member 'FOakThumbnailManagerConfig::ThumbnailLoadFrequency' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerConfig, MaxThumbnails) == 0x000004, "Member 'FOakThumbnailManagerConfig::MaxThumbnails' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerConfig, ThumbnailSize) == 0x000008, "Member 'FOakThumbnailManagerConfig::ThumbnailSize' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerConfig, ThumbnailMaterial) == 0x000010, "Member 'FOakThumbnailManagerConfig::ThumbnailMaterial' has a wrong offset!");

// ScriptStruct OakGame.LevelAssetList
// 0x0018 (0x0018 - 0x0000)
struct FLevelAssetList final
{
public:
	class FName                                   LevelPackage;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AssetNames;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelAssetList) == 0x000008, "Wrong alignment on FLevelAssetList");
static_assert(sizeof(FLevelAssetList) == 0x000018, "Wrong size on FLevelAssetList");
static_assert(offsetof(FLevelAssetList, LevelPackage) == 0x000000, "Member 'FLevelAssetList::LevelPackage' has a wrong offset!");
static_assert(offsetof(FLevelAssetList, AssetNames) == 0x000008, "Member 'FLevelAssetList::AssetNames' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakAnim_WeaponReload
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakAnim_WeaponReload final : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakAnim_WeaponReload) == 0x000008, "Wrong alignment on FActionState_OakAnim_WeaponReload");
static_assert(sizeof(FActionState_OakAnim_WeaponReload) == 0x000520, "Wrong size on FActionState_OakAnim_WeaponReload");

// ScriptStruct OakGame.LootablePersistenceData
// 0x0008 (0x0008 - 0x0000)
struct FLootablePersistenceData final
{
public:
	float                                         ResetDelay;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreInSaveGame;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLootablePersistenceData) == 0x000004, "Wrong alignment on FLootablePersistenceData");
static_assert(sizeof(FLootablePersistenceData) == 0x000008, "Wrong size on FLootablePersistenceData");
static_assert(offsetof(FLootablePersistenceData, ResetDelay) == 0x000000, "Member 'FLootablePersistenceData::ResetDelay' has a wrong offset!");
static_assert(offsetof(FLootablePersistenceData, bStoreInSaveGame) == 0x000004, "Member 'FLootablePersistenceData::bStoreInSaveGame' has a wrong offset!");

// ScriptStruct OakGame.LootablePileDamageInteraction
// 0x0020 (0x0020 - 0x0000)
struct FLootablePileDamageInteraction final
{
public:
	TArray<TSubclassOf<class UDamageSource>>      DamageSources;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FLootablePileInteractionResponse       Response;                                          // 0x0010(0x0010)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootablePileDamageInteraction) == 0x000008, "Wrong alignment on FLootablePileDamageInteraction");
static_assert(sizeof(FLootablePileDamageInteraction) == 0x000020, "Wrong size on FLootablePileDamageInteraction");
static_assert(offsetof(FLootablePileDamageInteraction, DamageSources) == 0x000000, "Member 'FLootablePileDamageInteraction::DamageSources' has a wrong offset!");
static_assert(offsetof(FLootablePileDamageInteraction, Response) == 0x000010, "Member 'FLootablePileDamageInteraction::Response' has a wrong offset!");

// ScriptStruct OakGame.LootableObjectDamageEventDetails
// 0x0040 (0x0040 - 0x0000)
struct FLootableObjectDamageEventDetails final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitForce;                                          // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootableObjectDamageEventDetails) == 0x000008, "Wrong alignment on FLootableObjectDamageEventDetails");
static_assert(sizeof(FLootableObjectDamageEventDetails) == 0x000040, "Wrong size on FLootableObjectDamageEventDetails");
static_assert(offsetof(FLootableObjectDamageEventDetails, Damage) == 0x000000, "Member 'FLootableObjectDamageEventDetails::Damage' has a wrong offset!");
static_assert(offsetof(FLootableObjectDamageEventDetails, HitLocation) == 0x000004, "Member 'FLootableObjectDamageEventDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FLootableObjectDamageEventDetails, HitDirection) == 0x000010, "Member 'FLootableObjectDamageEventDetails::HitDirection' has a wrong offset!");
static_assert(offsetof(FLootableObjectDamageEventDetails, HitForce) == 0x00001C, "Member 'FLootableObjectDamageEventDetails::HitForce' has a wrong offset!");
static_assert(offsetof(FLootableObjectDamageEventDetails, Instigator) == 0x000028, "Member 'FLootableObjectDamageEventDetails::Instigator' has a wrong offset!");
static_assert(offsetof(FLootableObjectDamageEventDetails, DamageType) == 0x000030, "Member 'FLootableObjectDamageEventDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FLootableObjectDamageEventDetails, DamageSource) == 0x000038, "Member 'FLootableObjectDamageEventDetails::DamageSource' has a wrong offset!");

// ScriptStruct OakGame.AvailableManufacturer
// 0x0018 (0x0018 - 0x0000)
struct FAvailableManufacturer final
{
public:
	class UManufacturerData*                      Manufacturer;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakDebugWeaponBuilderButton*           OptionButton;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailableManufacturer) == 0x000008, "Wrong alignment on FAvailableManufacturer");
static_assert(sizeof(FAvailableManufacturer) == 0x000018, "Wrong size on FAvailableManufacturer");
static_assert(offsetof(FAvailableManufacturer, Manufacturer) == 0x000000, "Member 'FAvailableManufacturer::Manufacturer' has a wrong offset!");
static_assert(offsetof(FAvailableManufacturer, OptionButton) == 0x000008, "Member 'FAvailableManufacturer::OptionButton' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentSlotConfiguration
// 0x0020 (0x0020 - 0x0000)
struct FOakActionAbilityAugmentSlotConfiguration final
{
public:
	TSubclassOf<class UOakActionAbility>          ActionAbilityClass;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOakActionAbilityAugmentSlotData*       SlotData;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakActionAbilityAugmentConfiguration> AugmentConfigurations;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentSlotConfiguration) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentSlotConfiguration");
static_assert(sizeof(FOakActionAbilityAugmentSlotConfiguration) == 0x000020, "Wrong size on FOakActionAbilityAugmentSlotConfiguration");
static_assert(offsetof(FOakActionAbilityAugmentSlotConfiguration, ActionAbilityClass) == 0x000000, "Member 'FOakActionAbilityAugmentSlotConfiguration::ActionAbilityClass' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSlotConfiguration, SlotData) == 0x000008, "Member 'FOakActionAbilityAugmentSlotConfiguration::SlotData' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSlotConfiguration, AugmentConfigurations) == 0x000010, "Member 'FOakActionAbilityAugmentSlotConfiguration::AugmentConfigurations' has a wrong offset!");

// ScriptStruct OakGame.LootableAnimState
// 0x0010 (0x0010 - 0x0000)
struct FLootableAnimState final
{
public:
	bool                                          bLooping;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Animation;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootableAnimState) == 0x000008, "Wrong alignment on FLootableAnimState");
static_assert(sizeof(FLootableAnimState) == 0x000010, "Wrong size on FLootableAnimState");
static_assert(offsetof(FLootableAnimState, bLooping) == 0x000000, "Member 'FLootableAnimState::bLooping' has a wrong offset!");
static_assert(offsetof(FLootableAnimState, Animation) == 0x000008, "Member 'FLootableAnimState::Animation' has a wrong offset!");

// ScriptStruct OakGame.MayhemCoreSetUIStats
// 0x0030 (0x0030 - 0x0000)
struct FMayhemCoreSetUIStats final
{
public:
	class UUIStatData*                            UIStat_FleshHealthScale;                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStatData*                            UIStat_ShieldHealthScale;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStatData*                            UIStat_ArmorHealthScale;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStatData*                            UIStat_ExperienceScale;                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStatData*                            UIStat_CurrencyScale;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStatData*                            UIStat_LootDropRateScale;                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemCoreSetUIStats) == 0x000008, "Wrong alignment on FMayhemCoreSetUIStats");
static_assert(sizeof(FMayhemCoreSetUIStats) == 0x000030, "Wrong size on FMayhemCoreSetUIStats");
static_assert(offsetof(FMayhemCoreSetUIStats, UIStat_FleshHealthScale) == 0x000000, "Member 'FMayhemCoreSetUIStats::UIStat_FleshHealthScale' has a wrong offset!");
static_assert(offsetof(FMayhemCoreSetUIStats, UIStat_ShieldHealthScale) == 0x000008, "Member 'FMayhemCoreSetUIStats::UIStat_ShieldHealthScale' has a wrong offset!");
static_assert(offsetof(FMayhemCoreSetUIStats, UIStat_ArmorHealthScale) == 0x000010, "Member 'FMayhemCoreSetUIStats::UIStat_ArmorHealthScale' has a wrong offset!");
static_assert(offsetof(FMayhemCoreSetUIStats, UIStat_ExperienceScale) == 0x000018, "Member 'FMayhemCoreSetUIStats::UIStat_ExperienceScale' has a wrong offset!");
static_assert(offsetof(FMayhemCoreSetUIStats, UIStat_CurrencyScale) == 0x000020, "Member 'FMayhemCoreSetUIStats::UIStat_CurrencyScale' has a wrong offset!");
static_assert(offsetof(FMayhemCoreSetUIStats, UIStat_LootDropRateScale) == 0x000028, "Member 'FMayhemCoreSetUIStats::UIStat_LootDropRateScale' has a wrong offset!");

// ScriptStruct OakGame.MayhemCoreModifierSet
// 0x0040 (0x0040 - 0x0000)
struct FMayhemCoreModifierSet final
{
public:
	TArray<struct FMayhemModifier>                Modifiers;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMayhemCoreSetUIStats                  UIStats;                                           // 0x0010(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemCoreModifierSet) == 0x000008, "Wrong alignment on FMayhemCoreModifierSet");
static_assert(sizeof(FMayhemCoreModifierSet) == 0x000040, "Wrong size on FMayhemCoreModifierSet");
static_assert(offsetof(FMayhemCoreModifierSet, Modifiers) == 0x000000, "Member 'FMayhemCoreModifierSet::Modifiers' has a wrong offset!");
static_assert(offsetof(FMayhemCoreModifierSet, UIStats) == 0x000010, "Member 'FMayhemCoreModifierSet::UIStats' has a wrong offset!");

// ScriptStruct OakGame.MayhemModeTwoLevelOverride
// 0x0068 (0x0068 - 0x0000)
struct FMayhemModeTwoLevelOverride final
{
public:
	int32                                         LevelRangeMin;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelRangeMax;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCoreModifierSet;                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMayhemCoreModifierSet                 CoreModifierSetOverride;                           // 0x0010(0x0040)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRandomModifiersSlots;                     // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMayhemModifierSlotInterface*>   RandomModifierSlotsOverride;                       // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemModeTwoLevelOverride) == 0x000008, "Wrong alignment on FMayhemModeTwoLevelOverride");
static_assert(sizeof(FMayhemModeTwoLevelOverride) == 0x000068, "Wrong size on FMayhemModeTwoLevelOverride");
static_assert(offsetof(FMayhemModeTwoLevelOverride, LevelRangeMin) == 0x000000, "Member 'FMayhemModeTwoLevelOverride::LevelRangeMin' has a wrong offset!");
static_assert(offsetof(FMayhemModeTwoLevelOverride, LevelRangeMax) == 0x000004, "Member 'FMayhemModeTwoLevelOverride::LevelRangeMax' has a wrong offset!");
static_assert(offsetof(FMayhemModeTwoLevelOverride, bOverrideCoreModifierSet) == 0x000008, "Member 'FMayhemModeTwoLevelOverride::bOverrideCoreModifierSet' has a wrong offset!");
static_assert(offsetof(FMayhemModeTwoLevelOverride, CoreModifierSetOverride) == 0x000010, "Member 'FMayhemModeTwoLevelOverride::CoreModifierSetOverride' has a wrong offset!");
static_assert(offsetof(FMayhemModeTwoLevelOverride, bOverrideRandomModifiersSlots) == 0x000050, "Member 'FMayhemModeTwoLevelOverride::bOverrideRandomModifiersSlots' has a wrong offset!");
static_assert(offsetof(FMayhemModeTwoLevelOverride, RandomModifierSlotsOverride) == 0x000058, "Member 'FMayhemModeTwoLevelOverride::RandomModifierSlotsOverride' has a wrong offset!");

// ScriptStruct OakGame.MainMenuCameraViewpointBlendPair
// 0x0038 (0x0038 - 0x0000)
struct FMainMenuCameraViewpointBlendPair final
{
public:
	EMainMenuViewpointType                        ViewpointA;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMainMenuViewpointType                        ViewpointB;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMainMenuCameraBlendParamsSet          BlendParamsOverride;                               // 0x0004(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuCameraViewpointBlendPair) == 0x000004, "Wrong alignment on FMainMenuCameraViewpointBlendPair");
static_assert(sizeof(FMainMenuCameraViewpointBlendPair) == 0x000038, "Wrong size on FMainMenuCameraViewpointBlendPair");
static_assert(offsetof(FMainMenuCameraViewpointBlendPair, ViewpointA) == 0x000000, "Member 'FMainMenuCameraViewpointBlendPair::ViewpointA' has a wrong offset!");
static_assert(offsetof(FMainMenuCameraViewpointBlendPair, ViewpointB) == 0x000001, "Member 'FMainMenuCameraViewpointBlendPair::ViewpointB' has a wrong offset!");
static_assert(offsetof(FMainMenuCameraViewpointBlendPair, BlendParamsOverride) == 0x000004, "Member 'FMainMenuCameraViewpointBlendPair::BlendParamsOverride' has a wrong offset!");

// ScriptStruct OakGame.MainMenuCameraViewpoint
// 0x0008 (0x0008 - 0x0000)
struct FMainMenuCameraViewpoint final
{
public:
	class ACameraActor*                           CameraActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuCameraViewpoint) == 0x000008, "Wrong alignment on FMainMenuCameraViewpoint");
static_assert(sizeof(FMainMenuCameraViewpoint) == 0x000008, "Wrong size on FMainMenuCameraViewpoint");
static_assert(offsetof(FMainMenuCameraViewpoint, CameraActor) == 0x000000, "Member 'FMainMenuCameraViewpoint::CameraActor' has a wrong offset!");

// ScriptStruct OakGame.MainMenuCameraViewpointGroup
// 0x0018 (0x0018 - 0x0000)
struct FMainMenuCameraViewpointGroup final
{
public:
	struct FMainMenuCameraViewpoint               PrimaryViewpoint;                                  // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FMainMenuCameraViewpoint>       SecondaryViewpoints;                               // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMainMenuCameraViewpointGroup) == 0x000008, "Wrong alignment on FMainMenuCameraViewpointGroup");
static_assert(sizeof(FMainMenuCameraViewpointGroup) == 0x000018, "Wrong size on FMainMenuCameraViewpointGroup");
static_assert(offsetof(FMainMenuCameraViewpointGroup, PrimaryViewpoint) == 0x000000, "Member 'FMainMenuCameraViewpointGroup::PrimaryViewpoint' has a wrong offset!");
static_assert(offsetof(FMainMenuCameraViewpointGroup, SecondaryViewpoints) == 0x000008, "Member 'FMainMenuCameraViewpointGroup::SecondaryViewpoints' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityDebugMenuListItemSpec
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FOakAbilityDebugMenuListItemSpec final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityDebugMenuListItemSpec) == 0x000004, "Wrong alignment on FOakAbilityDebugMenuListItemSpec");
static_assert(sizeof(FOakAbilityDebugMenuListItemSpec) == 0x000014, "Wrong size on FOakAbilityDebugMenuListItemSpec");

// ScriptStruct OakGame.VendingMachineInteractSequence
// 0x0090 (0x0090 - 0x0000)
struct FVendingMachineInteractSequence final
{
public:
	struct FRuntimeFloatCurve                     DigistructCurve;                                   // 0x0000(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVendingMachineSequenceTimedEvent> Events;                                            // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVendingMachineInteractSequence) == 0x000008, "Wrong alignment on FVendingMachineInteractSequence");
static_assert(sizeof(FVendingMachineInteractSequence) == 0x000090, "Wrong size on FVendingMachineInteractSequence");
static_assert(offsetof(FVendingMachineInteractSequence, DigistructCurve) == 0x000000, "Member 'FVendingMachineInteractSequence::DigistructCurve' has a wrong offset!");
static_assert(offsetof(FVendingMachineInteractSequence, Duration) == 0x000078, "Member 'FVendingMachineInteractSequence::Duration' has a wrong offset!");
static_assert(offsetof(FVendingMachineInteractSequence, Events) == 0x000080, "Member 'FVendingMachineInteractSequence::Events' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityResourceController_WeaponShotModifier
// 0x0010 (0x0028 - 0x0018)
struct FOakAbilityResourceController_WeaponShotModifier final : public FGbxAbilityResourceController
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAbilityResourceController_WeaponShotModifier) == 0x000008, "Wrong alignment on FOakAbilityResourceController_WeaponShotModifier");
static_assert(sizeof(FOakAbilityResourceController_WeaponShotModifier) == 0x000028, "Wrong size on FOakAbilityResourceController_WeaponShotModifier");

// ScriptStruct OakGame.OakPlayerAbilityTreeItemInfo
// 0x0020 (0x0020 - 0x0000)
struct FOakPlayerAbilityTreeItemInfo final
{
public:
	class UOakPlayerAbilityTreeItemData*          ItemData;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakPlayerAbilityTreeBranchData*        BranchData;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPlayerAbilityTreeItemInfo) == 0x000008, "Wrong alignment on FOakPlayerAbilityTreeItemInfo");
static_assert(sizeof(FOakPlayerAbilityTreeItemInfo) == 0x000020, "Wrong size on FOakPlayerAbilityTreeItemInfo");
static_assert(offsetof(FOakPlayerAbilityTreeItemInfo, ItemData) == 0x000000, "Member 'FOakPlayerAbilityTreeItemInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityTreeItemInfo, BranchData) == 0x000018, "Member 'FOakPlayerAbilityTreeItemInfo::BranchData' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilityTreeTierInfo
// 0x0010 (0x0010 - 0x0000)
struct FOakPlayerAbilityTreeTierInfo final
{
public:
	class UOakPlayerAbilityTreeTierData*          TierData;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPlayerAbilityTreeTierInfo) == 0x000008, "Wrong alignment on FOakPlayerAbilityTreeTierInfo");
static_assert(sizeof(FOakPlayerAbilityTreeTierInfo) == 0x000010, "Wrong size on FOakPlayerAbilityTreeTierInfo");
static_assert(offsetof(FOakPlayerAbilityTreeTierInfo, TierData) == 0x000000, "Member 'FOakPlayerAbilityTreeTierInfo::TierData' has a wrong offset!");

// ScriptStruct OakGame.OakAbilityTimerResult
// 0x000C (0x000C - 0x0000)
struct FOakAbilityTimerResult final
{
public:
	EOakAbilityTimerResult                        Result;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PulsesThisFrame;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalPulseTime;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakAbilityTimerResult) == 0x000004, "Wrong alignment on FOakAbilityTimerResult");
static_assert(sizeof(FOakAbilityTimerResult) == 0x00000C, "Wrong size on FOakAbilityTimerResult");
static_assert(offsetof(FOakAbilityTimerResult, Result) == 0x000000, "Member 'FOakAbilityTimerResult::Result' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerResult, PulsesThisFrame) == 0x000004, "Member 'FOakAbilityTimerResult::PulsesThisFrame' has a wrong offset!");
static_assert(offsetof(FOakAbilityTimerResult, TotalPulseTime) == 0x000008, "Member 'FOakAbilityTimerResult::TotalPulseTime' has a wrong offset!");

// ScriptStruct OakGame.WeaponBonusDataTableSelectionData
// 0x0048 (0x0048 - 0x0000)
struct FWeaponBonusDataTableSelectionData final
{
public:
	int32                                         UseModeBitmask;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponBonusDataTableData*              WeaponBonusDataTable;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RowName;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         ColumnNames;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ColumnCollections;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponBonusDataTableSelectionData) == 0x000008, "Wrong alignment on FWeaponBonusDataTableSelectionData");
static_assert(sizeof(FWeaponBonusDataTableSelectionData) == 0x000048, "Wrong size on FWeaponBonusDataTableSelectionData");
static_assert(offsetof(FWeaponBonusDataTableSelectionData, UseModeBitmask) == 0x000000, "Member 'FWeaponBonusDataTableSelectionData::UseModeBitmask' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableSelectionData, WeaponBonusDataTable) == 0x000008, "Member 'FWeaponBonusDataTableSelectionData::WeaponBonusDataTable' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableSelectionData, RowName) == 0x000010, "Member 'FWeaponBonusDataTableSelectionData::RowName' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableSelectionData, ColumnNames) == 0x000018, "Member 'FWeaponBonusDataTableSelectionData::ColumnNames' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableSelectionData, ColumnCollections) == 0x000028, "Member 'FWeaponBonusDataTableSelectionData::ColumnCollections' has a wrong offset!");

// ScriptStruct OakGame.TouchPickupEvaluationResult
// 0x0010 (0x0010 - 0x0000)
struct FTouchPickupEvaluationResult final
{
public:
	TArray<class AOakInventoryItemPickup*>        Pickups;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTouchPickupEvaluationResult) == 0x000008, "Wrong alignment on FTouchPickupEvaluationResult");
static_assert(sizeof(FTouchPickupEvaluationResult) == 0x000010, "Wrong size on FTouchPickupEvaluationResult");
static_assert(offsetof(FTouchPickupEvaluationResult, Pickups) == 0x000000, "Member 'FTouchPickupEvaluationResult::Pickups' has a wrong offset!");

// ScriptStruct OakGame.ActionSkillFailureCodeDescription
// 0x0020 (0x0020 - 0x0000)
struct FActionSkillFailureCodeDescription final
{
public:
	uint8                                         FailureCode;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FailureCodeText;                                   // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionSkillFailureCodeDescription) == 0x000008, "Wrong alignment on FActionSkillFailureCodeDescription");
static_assert(sizeof(FActionSkillFailureCodeDescription) == 0x000020, "Wrong size on FActionSkillFailureCodeDescription");
static_assert(offsetof(FActionSkillFailureCodeDescription, FailureCode) == 0x000000, "Member 'FActionSkillFailureCodeDescription::FailureCode' has a wrong offset!");
static_assert(offsetof(FActionSkillFailureCodeDescription, FailureCodeText) == 0x000008, "Member 'FActionSkillFailureCodeDescription::FailureCodeText' has a wrong offset!");

// ScriptStruct OakGame.OakAnimActionAbilityEndAction
// 0x0010 (0x0010 - 0x0000)
struct FOakAnimActionAbilityEndAction final
{
public:
	EOakAnimActionAbilityEndAction                EndAction;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          Condition;                                         // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakAnimActionAbilityEndAction) == 0x000008, "Wrong alignment on FOakAnimActionAbilityEndAction");
static_assert(sizeof(FOakAnimActionAbilityEndAction) == 0x000010, "Wrong size on FOakAnimActionAbilityEndAction");
static_assert(offsetof(FOakAnimActionAbilityEndAction, EndAction) == 0x000000, "Member 'FOakAnimActionAbilityEndAction::EndAction' has a wrong offset!");
static_assert(offsetof(FOakAnimActionAbilityEndAction, Condition) == 0x000008, "Member 'FOakAnimActionAbilityEndAction::Condition' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakAnimActionAbilityPhaseTrance
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakAnimActionAbilityPhaseTrance final : public FActionState_OakAnimActionAbility
{
};
static_assert(alignof(FActionState_OakAnimActionAbilityPhaseTrance) == 0x000008, "Wrong alignment on FActionState_OakAnimActionAbilityPhaseTrance");
static_assert(sizeof(FActionState_OakAnimActionAbilityPhaseTrance) == 0x000520, "Wrong size on FActionState_OakAnimActionAbilityPhaseTrance");

// ScriptStruct OakGame.ActionState_OakAnimPhaseTranceArms
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakAnimPhaseTranceArms final : public FActionState_OakAnim
{
};
static_assert(alignof(FActionState_OakAnimPhaseTranceArms) == 0x000008, "Wrong alignment on FActionState_OakAnimPhaseTranceArms");
static_assert(sizeof(FActionState_OakAnimPhaseTranceArms) == 0x000520, "Wrong size on FActionState_OakAnimPhaseTranceArms");

// ScriptStruct OakGame.ActionState_OakDetachFromSeat
// 0x0008 (0x00D0 - 0x00C8)
struct FActionState_OakDetachFromSeat final : public FActionState_Base
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakDetachFromSeat) == 0x000008, "Wrong alignment on FActionState_OakDetachFromSeat");
static_assert(sizeof(FActionState_OakDetachFromSeat) == 0x0000D0, "Wrong size on FActionState_OakDetachFromSeat");

// ScriptStruct OakGame.ActionState_OakFrozenDeath
// 0x0000 (0x00C8 - 0x00C8)
struct FActionState_OakFrozenDeath final : public FActionState_Base
{
};
static_assert(alignof(FActionState_OakFrozenDeath) == 0x000008, "Wrong alignment on FActionState_OakFrozenDeath");
static_assert(sizeof(FActionState_OakFrozenDeath) == 0x0000C8, "Wrong size on FActionState_OakFrozenDeath");

// ScriptStruct OakGame.ActionState_OakHostileAttach
// 0x0088 (0x04F0 - 0x0468)
struct FActionState_OakHostileAttach final : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x88];                                     // 0x0468(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakHostileAttach) == 0x000008, "Wrong alignment on FActionState_OakHostileAttach");
static_assert(sizeof(FActionState_OakHostileAttach) == 0x0004F0, "Wrong size on FActionState_OakHostileAttach");

// ScriptStruct OakGame.FilteredImpactData
// 0x0090 (0x0090 - 0x0000)
struct FFilteredImpactData final
{
public:
	TArray<class UImpactData*>                    ImpactData;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFeedbackData*                          DefaultVehicleOccupantsFeedback;                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UPhysicalMaterial*, class UFeedbackData*> VehicleOccupantsFeedback;                          // 0x0018(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FeedbackScale;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalOnlyFeedback;                                // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ClassesToTarget;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ClassesToExclude;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilteredImpactData) == 0x000008, "Wrong alignment on FFilteredImpactData");
static_assert(sizeof(FFilteredImpactData) == 0x000090, "Wrong size on FFilteredImpactData");
static_assert(offsetof(FFilteredImpactData, ImpactData) == 0x000000, "Member 'FFilteredImpactData::ImpactData' has a wrong offset!");
static_assert(offsetof(FFilteredImpactData, DefaultVehicleOccupantsFeedback) == 0x000010, "Member 'FFilteredImpactData::DefaultVehicleOccupantsFeedback' has a wrong offset!");
static_assert(offsetof(FFilteredImpactData, VehicleOccupantsFeedback) == 0x000018, "Member 'FFilteredImpactData::VehicleOccupantsFeedback' has a wrong offset!");
static_assert(offsetof(FFilteredImpactData, FeedbackScale) == 0x000068, "Member 'FFilteredImpactData::FeedbackScale' has a wrong offset!");
static_assert(offsetof(FFilteredImpactData, bLocalOnlyFeedback) == 0x00006C, "Member 'FFilteredImpactData::bLocalOnlyFeedback' has a wrong offset!");
static_assert(offsetof(FFilteredImpactData, ClassesToTarget) == 0x000070, "Member 'FFilteredImpactData::ClassesToTarget' has a wrong offset!");
static_assert(offsetof(FFilteredImpactData, ClassesToExclude) == 0x000080, "Member 'FFilteredImpactData::ClassesToExclude' has a wrong offset!");

// ScriptStruct OakGame.ReplicatedEject
// 0x000C (0x000C - 0x0000)
struct FReplicatedEject final
{
public:
	struct FVector                                EjectVel;                                          // 0x0000(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedEject) == 0x000004, "Wrong alignment on FReplicatedEject");
static_assert(sizeof(FReplicatedEject) == 0x00000C, "Wrong size on FReplicatedEject");
static_assert(offsetof(FReplicatedEject, EjectVel) == 0x000000, "Member 'FReplicatedEject::EjectVel' has a wrong offset!");

// ScriptStruct OakGame.ActionState_OakPetUltimateAbility
// 0x0000 (0x0520 - 0x0520)
struct FActionState_OakPetUltimateAbility final : public FActionState_OakRandomAnim
{
};
static_assert(alignof(FActionState_OakPetUltimateAbility) == 0x000008, "Wrong alignment on FActionState_OakPetUltimateAbility");
static_assert(sizeof(FActionState_OakPetUltimateAbility) == 0x000520, "Wrong size on FActionState_OakPetUltimateAbility");

// ScriptStruct OakGame.ActionState_OakPhaseMove
// 0x0060 (0x0598 - 0x0538)
struct FActionState_OakPhaseMove final : public FActionState_Loop
{
public:
	uint8                                         Pad_538[0x60];                                     // 0x0538(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakPhaseMove) == 0x000008, "Wrong alignment on FActionState_OakPhaseMove");
static_assert(sizeof(FActionState_OakPhaseMove) == 0x000598, "Wrong size on FActionState_OakPhaseMove");

// ScriptStruct OakGame.ActionState_OakVehicleInteractionAnim
// 0x0010 (0x0530 - 0x0520)
struct FActionState_OakVehicleInteractionAnim final : public FActionState_OakAnim
{
public:
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakVehicleInteractionAnim) == 0x000008, "Wrong alignment on FActionState_OakVehicleInteractionAnim");
static_assert(sizeof(FActionState_OakVehicleInteractionAnim) == 0x000530, "Wrong size on FActionState_OakVehicleInteractionAnim");

// ScriptStruct OakGame.ActionState_OakVehicleMoveTo
// 0x0018 (0x00E0 - 0x00C8)
struct FActionState_OakVehicleMoveTo final : public FActionState_Base
{
public:
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_OakVehicleMoveTo) == 0x000008, "Wrong alignment on FActionState_OakVehicleMoveTo");
static_assert(sizeof(FActionState_OakVehicleMoveTo) == 0x0000E0, "Wrong size on FActionState_OakVehicleMoveTo");

// ScriptStruct OakGame.ActionState_OakCloak
// 0x0000 (0x01C0 - 0x01C0)
struct FActionState_OakCloak final : public FOakActionState_CoordinatedEffect
{
};
static_assert(alignof(FActionState_OakCloak) == 0x000008, "Wrong alignment on FActionState_OakCloak");
static_assert(sizeof(FActionState_OakCloak) == 0x0001C0, "Wrong size on FActionState_OakCloak");

// ScriptStruct OakGame.OakActionCloak_TrackedTargetState
// 0x0020 (0x0020 - 0x0000)
struct FOakActionCloak_TrackedTargetState final
{
public:
	class AActor*                                 TrackedTarget;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsecutiveShotCount;                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsRemaining;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakActionCloak_TrackedTargetState) == 0x000008, "Wrong alignment on FOakActionCloak_TrackedTargetState");
static_assert(sizeof(FOakActionCloak_TrackedTargetState) == 0x000020, "Wrong size on FOakActionCloak_TrackedTargetState");
static_assert(offsetof(FOakActionCloak_TrackedTargetState, TrackedTarget) == 0x000000, "Member 'FOakActionCloak_TrackedTargetState::TrackedTarget' has a wrong offset!");
static_assert(offsetof(FOakActionCloak_TrackedTargetState, ConsecutiveShotCount) == 0x000010, "Member 'FOakActionCloak_TrackedTargetState::ConsecutiveShotCount' has a wrong offset!");
static_assert(offsetof(FOakActionCloak_TrackedTargetState, ShotsRemaining) == 0x000014, "Member 'FOakActionCloak_TrackedTargetState::ShotsRemaining' has a wrong offset!");

// ScriptStruct OakGame.OakAISwarmActor
// 0x01D0 (0x01D0 - 0x0000)
struct FOakAISwarmActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DestinationComponent;                              // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Destination;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOakAISwarmMovement                    Movement;                                          // 0x0018(0x0188)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x30];                                     // 0x01A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakAISwarmActor) == 0x000008, "Wrong alignment on FOakAISwarmActor");
static_assert(sizeof(FOakAISwarmActor) == 0x0001D0, "Wrong size on FOakAISwarmActor");
static_assert(offsetof(FOakAISwarmActor, Actor) == 0x000000, "Member 'FOakAISwarmActor::Actor' has a wrong offset!");
static_assert(offsetof(FOakAISwarmActor, DestinationComponent) == 0x000008, "Member 'FOakAISwarmActor::DestinationComponent' has a wrong offset!");
static_assert(offsetof(FOakAISwarmActor, Destination) == 0x000010, "Member 'FOakAISwarmActor::Destination' has a wrong offset!");
static_assert(offsetof(FOakAISwarmActor, Movement) == 0x000018, "Member 'FOakAISwarmActor::Movement' has a wrong offset!");

// ScriptStruct OakGame.ChunkIdAssetClassesData
// 0x0018 (0x0018 - 0x0000)
struct FChunkIdAssetClassesData final
{
public:
	int32                                         ChunkId;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftClassPath>                 AssetClasses;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChunkIdAssetClassesData) == 0x000008, "Wrong alignment on FChunkIdAssetClassesData");
static_assert(sizeof(FChunkIdAssetClassesData) == 0x000018, "Wrong size on FChunkIdAssetClassesData");
static_assert(offsetof(FChunkIdAssetClassesData, ChunkId) == 0x000000, "Member 'FChunkIdAssetClassesData::ChunkId' has a wrong offset!");
static_assert(offsetof(FChunkIdAssetClassesData, AssetClasses) == 0x000008, "Member 'FChunkIdAssetClassesData::AssetClasses' has a wrong offset!");

// ScriptStruct OakGame.LevelMultiplierDefinedValueRow
// 0x00A8 (0x00B0 - 0x0008)
struct FLevelMultiplierDefinedValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           Multiplier;                                        // 0x0008(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Level;                                             // 0x0040(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Offset;                                            // 0x0078(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLevelMultiplierDefinedValueRow) == 0x000008, "Wrong alignment on FLevelMultiplierDefinedValueRow");
static_assert(sizeof(FLevelMultiplierDefinedValueRow) == 0x0000B0, "Wrong size on FLevelMultiplierDefinedValueRow");
static_assert(offsetof(FLevelMultiplierDefinedValueRow, Multiplier) == 0x000008, "Member 'FLevelMultiplierDefinedValueRow::Multiplier' has a wrong offset!");
static_assert(offsetof(FLevelMultiplierDefinedValueRow, Level) == 0x000040, "Member 'FLevelMultiplierDefinedValueRow::Level' has a wrong offset!");
static_assert(offsetof(FLevelMultiplierDefinedValueRow, Offset) == 0x000078, "Member 'FLevelMultiplierDefinedValueRow::Offset' has a wrong offset!");

// ScriptStruct OakGame.PlayerCountDefinedValueRow
// 0x00E0 (0x00E8 - 0x0008)
struct FPlayerCountDefinedValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           OnePlayer;                                         // 0x0008(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           TwoPlayers;                                        // 0x0040(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           ThreePlayers;                                      // 0x0078(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           FourPlayers;                                       // 0x00B0(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPlayerCountDefinedValueRow) == 0x000008, "Wrong alignment on FPlayerCountDefinedValueRow");
static_assert(sizeof(FPlayerCountDefinedValueRow) == 0x0000E8, "Wrong size on FPlayerCountDefinedValueRow");
static_assert(offsetof(FPlayerCountDefinedValueRow, OnePlayer) == 0x000008, "Member 'FPlayerCountDefinedValueRow::OnePlayer' has a wrong offset!");
static_assert(offsetof(FPlayerCountDefinedValueRow, TwoPlayers) == 0x000040, "Member 'FPlayerCountDefinedValueRow::TwoPlayers' has a wrong offset!");
static_assert(offsetof(FPlayerCountDefinedValueRow, ThreePlayers) == 0x000078, "Member 'FPlayerCountDefinedValueRow::ThreePlayers' has a wrong offset!");
static_assert(offsetof(FPlayerCountDefinedValueRow, FourPlayers) == 0x0000B0, "Member 'FPlayerCountDefinedValueRow::FourPlayers' has a wrong offset!");

// ScriptStruct OakGame.OakCARMenuStatLineData
// 0x0008 (0x0008 - 0x0000)
struct FOakCARMenuStatLineData final
{
public:
	class UOakCARVehiclePartStat*                 PartStat;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakCARMenuStatLineData) == 0x000008, "Wrong alignment on FOakCARMenuStatLineData");
static_assert(sizeof(FOakCARMenuStatLineData) == 0x000008, "Wrong size on FOakCARMenuStatLineData");
static_assert(offsetof(FOakCARMenuStatLineData, PartStat) == 0x000000, "Member 'FOakCARMenuStatLineData::PartStat' has a wrong offset!");

// ScriptStruct OakGame.RegionMissionBalanceData
// 0x0008 (0x0018 - 0x0010)
struct FRegionMissionBalanceData final : public FRegionBalanceDataBase
{
public:
	TSubclassOf<class UMission>                   Mission;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegionMissionBalanceData) == 0x000008, "Wrong alignment on FRegionMissionBalanceData");
static_assert(sizeof(FRegionMissionBalanceData) == 0x000018, "Wrong size on FRegionMissionBalanceData");
static_assert(offsetof(FRegionMissionBalanceData, Mission) == 0x000010, "Member 'FRegionMissionBalanceData::Mission' has a wrong offset!");

// ScriptStruct OakGame.RegionBalanceData
// 0x0018 (0x0028 - 0x0010)
struct FRegionBalanceData final : public FRegionBalanceDataBase
{
public:
	class URegionData*                            REGION;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRegionMissionBalanceData>      MissionOverrides;                                  // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegionBalanceData) == 0x000008, "Wrong alignment on FRegionBalanceData");
static_assert(sizeof(FRegionBalanceData) == 0x000028, "Wrong size on FRegionBalanceData");
static_assert(offsetof(FRegionBalanceData, REGION) == 0x000010, "Member 'FRegionBalanceData::REGION' has a wrong offset!");
static_assert(offsetof(FRegionBalanceData, MissionOverrides) == 0x000018, "Member 'FRegionBalanceData::MissionOverrides' has a wrong offset!");

// ScriptStruct OakGame.OakChallengeTierRewardsPerInstance
// 0x0018 (0x0018 - 0x0000)
struct FOakChallengeTierRewardsPerInstance final
{
public:
	uint8                                         LeagueInstance;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakChallengeTierRewards>       TierRewards;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakChallengeTierRewardsPerInstance) == 0x000008, "Wrong alignment on FOakChallengeTierRewardsPerInstance");
static_assert(sizeof(FOakChallengeTierRewardsPerInstance) == 0x000018, "Wrong size on FOakChallengeTierRewardsPerInstance");
static_assert(offsetof(FOakChallengeTierRewardsPerInstance, LeagueInstance) == 0x000000, "Member 'FOakChallengeTierRewardsPerInstance::LeagueInstance' has a wrong offset!");
static_assert(offsetof(FOakChallengeTierRewardsPerInstance, TierRewards) == 0x000008, "Member 'FOakChallengeTierRewardsPerInstance::TierRewards' has a wrong offset!");

// ScriptStruct OakGame.DamageChallengeData
// 0x0028 (0x0028 - 0x0000)
struct FDamageChallengeData final
{
public:
	class UWeaponTypeData*                        WeaponType;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManufacturerData*                      Manufacturer;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageTypeClass;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageChallengeData) == 0x000008, "Wrong alignment on FDamageChallengeData");
static_assert(sizeof(FDamageChallengeData) == 0x000028, "Wrong size on FDamageChallengeData");
static_assert(offsetof(FDamageChallengeData, WeaponType) == 0x000000, "Member 'FDamageChallengeData::WeaponType' has a wrong offset!");
static_assert(offsetof(FDamageChallengeData, Manufacturer) == 0x000008, "Member 'FDamageChallengeData::Manufacturer' has a wrong offset!");
static_assert(offsetof(FDamageChallengeData, DamageTypeClass) == 0x000010, "Member 'FDamageChallengeData::DamageTypeClass' has a wrong offset!");

// ScriptStruct OakGame.AvailableAmmoType
// 0x0018 (0x0018 - 0x0000)
struct FAvailableAmmoType final
{
public:
	class UGbxAmmoTypeData*                       AmmoType;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakDebugWeaponBuilderButton*           OptionButton;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailableAmmoType) == 0x000008, "Wrong alignment on FAvailableAmmoType");
static_assert(sizeof(FAvailableAmmoType) == 0x000018, "Wrong size on FAvailableAmmoType");
static_assert(offsetof(FAvailableAmmoType, AmmoType) == 0x000000, "Member 'FAvailableAmmoType::AmmoType' has a wrong offset!");
static_assert(offsetof(FAvailableAmmoType, OptionButton) == 0x000008, "Member 'FAvailableAmmoType::OptionButton' has a wrong offset!");

// ScriptStruct OakGame.CameraManViewPoint
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FCameraManViewPoint final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraManViewPoint) == 0x000004, "Wrong alignment on FCameraManViewPoint");
static_assert(sizeof(FCameraManViewPoint) == 0x000018, "Wrong size on FCameraManViewPoint");

// ScriptStruct OakGame.ZoneMapDisplayInfo
// 0x0038 (0x0038 - 0x0000)
struct FZoneMapDisplayInfo final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapDisplayInfo) == 0x000008, "Wrong alignment on FZoneMapDisplayInfo");
static_assert(sizeof(FZoneMapDisplayInfo) == 0x000038, "Wrong size on FZoneMapDisplayInfo");
static_assert(offsetof(FZoneMapDisplayInfo, LevelName) == 0x000000, "Member 'FZoneMapDisplayInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FZoneMapDisplayInfo, DisplayName) == 0x000008, "Member 'FZoneMapDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FZoneMapDisplayInfo, Description) == 0x000020, "Member 'FZoneMapDisplayInfo::Description' has a wrong offset!");

// ScriptStruct OakGame.PlayerTeleportState
// 0x0038 (0x0038 - 0x0000)
struct FPlayerTeleportState final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UOakPlayerTeleportData*                 TeleportData;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerTeleportState) == 0x000008, "Wrong alignment on FPlayerTeleportState");
static_assert(sizeof(FPlayerTeleportState) == 0x000038, "Wrong size on FPlayerTeleportState");
static_assert(offsetof(FPlayerTeleportState, TeleportData) == 0x000030, "Member 'FPlayerTeleportState::TeleportData' has a wrong offset!");

// ScriptStruct OakGame.CinematicState
// 0x0010 (0x0010 - 0x0000)
struct FCinematicState final
{
public:
	class UOakCinematicTag*                       CinematicTag;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceTime;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECinematicState                               CurrentState;                                      // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCinematicState) == 0x000008, "Wrong alignment on FCinematicState");
static_assert(sizeof(FCinematicState) == 0x000010, "Wrong size on FCinematicState");
static_assert(offsetof(FCinematicState, CinematicTag) == 0x000000, "Member 'FCinematicState::CinematicTag' has a wrong offset!");
static_assert(offsetof(FCinematicState, SequenceTime) == 0x000008, "Member 'FCinematicState::SequenceTime' has a wrong offset!");
static_assert(offsetof(FCinematicState, CurrentState) == 0x00000C, "Member 'FCinematicState::CurrentState' has a wrong offset!");

// ScriptStruct OakGame.CinematicData
// 0x0068 (0x0068 - 0x0000)
struct FCinematicData final
{
public:
	class UOakCinematicTag*                       CinematicTag;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         Sequence;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaSource*                           Movie;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCinematicModeData*                     IntroCinematicMode;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatable;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisallowCutsceneSkip;                             // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntroTime;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        IntroScreenParticle;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCinematicModeData*                     PlayingCinematicMode;                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMissionObjectiveReference             MissionObjective;                                  // 0x0038(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCinematicData) == 0x000008, "Wrong alignment on FCinematicData");
static_assert(sizeof(FCinematicData) == 0x000068, "Wrong size on FCinematicData");
static_assert(offsetof(FCinematicData, CinematicTag) == 0x000000, "Member 'FCinematicData::CinematicTag' has a wrong offset!");
static_assert(offsetof(FCinematicData, Sequence) == 0x000008, "Member 'FCinematicData::Sequence' has a wrong offset!");
static_assert(offsetof(FCinematicData, Movie) == 0x000010, "Member 'FCinematicData::Movie' has a wrong offset!");
static_assert(offsetof(FCinematicData, IntroCinematicMode) == 0x000018, "Member 'FCinematicData::IntroCinematicMode' has a wrong offset!");
static_assert(offsetof(FCinematicData, bRepeatable) == 0x000020, "Member 'FCinematicData::bRepeatable' has a wrong offset!");
static_assert(offsetof(FCinematicData, bDisallowCutsceneSkip) == 0x000021, "Member 'FCinematicData::bDisallowCutsceneSkip' has a wrong offset!");
static_assert(offsetof(FCinematicData, IntroTime) == 0x000024, "Member 'FCinematicData::IntroTime' has a wrong offset!");
static_assert(offsetof(FCinematicData, IntroScreenParticle) == 0x000028, "Member 'FCinematicData::IntroScreenParticle' has a wrong offset!");
static_assert(offsetof(FCinematicData, PlayingCinematicMode) == 0x000030, "Member 'FCinematicData::PlayingCinematicMode' has a wrong offset!");
static_assert(offsetof(FCinematicData, MissionObjective) == 0x000038, "Member 'FCinematicData::MissionObjective' has a wrong offset!");

// ScriptStruct OakGame.OakCustomizationSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FOakCustomizationSaveGameData final
{
public:
	bool                                          IsNew;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOakCustomizationData>   CustomizationAssetPath;                            // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakCustomizationSaveGameData) == 0x000008, "Wrong alignment on FOakCustomizationSaveGameData");
static_assert(sizeof(FOakCustomizationSaveGameData) == 0x000030, "Wrong size on FOakCustomizationSaveGameData");
static_assert(offsetof(FOakCustomizationSaveGameData, IsNew) == 0x000000, "Member 'FOakCustomizationSaveGameData::IsNew' has a wrong offset!");
static_assert(offsetof(FOakCustomizationSaveGameData, CustomizationAssetPath) == 0x000008, "Member 'FOakCustomizationSaveGameData::CustomizationAssetPath' has a wrong offset!");

// ScriptStruct OakGame.OakMailItem
// 0x00B8 (0x00B8 - 0x0000)
struct FOakMailItem final
{
public:
	EMailItemType                                 MailItemType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SenderDisplayName;                                 // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Subject;                                           // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0038(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 GearSerialNumber;                                  // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MissionHash;                                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MailGuid;                                          // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateSent;                                          // 0x0078(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpirationDate;                                    // 0x0080(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       FromPlayerId;                                      // 0x0088(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenRead;                                      // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakMailItem) == 0x000008, "Wrong alignment on FOakMailItem");
static_assert(sizeof(FOakMailItem) == 0x0000B8, "Wrong size on FOakMailItem");
static_assert(offsetof(FOakMailItem, MailItemType) == 0x000000, "Member 'FOakMailItem::MailItemType' has a wrong offset!");
static_assert(offsetof(FOakMailItem, SenderDisplayName) == 0x000008, "Member 'FOakMailItem::SenderDisplayName' has a wrong offset!");
static_assert(offsetof(FOakMailItem, Subject) == 0x000020, "Member 'FOakMailItem::Subject' has a wrong offset!");
static_assert(offsetof(FOakMailItem, Body) == 0x000038, "Member 'FOakMailItem::Body' has a wrong offset!");
static_assert(offsetof(FOakMailItem, GearSerialNumber) == 0x000050, "Member 'FOakMailItem::GearSerialNumber' has a wrong offset!");
static_assert(offsetof(FOakMailItem, MissionHash) == 0x000060, "Member 'FOakMailItem::MissionHash' has a wrong offset!");
static_assert(offsetof(FOakMailItem, MailGuid) == 0x000068, "Member 'FOakMailItem::MailGuid' has a wrong offset!");
static_assert(offsetof(FOakMailItem, DateSent) == 0x000078, "Member 'FOakMailItem::DateSent' has a wrong offset!");
static_assert(offsetof(FOakMailItem, ExpirationDate) == 0x000080, "Member 'FOakMailItem::ExpirationDate' has a wrong offset!");
static_assert(offsetof(FOakMailItem, FromPlayerId) == 0x000088, "Member 'FOakMailItem::FromPlayerId' has a wrong offset!");
static_assert(offsetof(FOakMailItem, bHasBeenRead) == 0x0000B0, "Member 'FOakMailItem::bHasBeenRead' has a wrong offset!");

// ScriptStruct OakGame.OakVaultCardPreviousChallengeData
// 0x0008 (0x0008 - 0x0000)
struct FOakVaultCardPreviousChallengeData final
{
public:
	int32                                         PreviousChallengeSeed;                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PreviousChallengeID;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakVaultCardPreviousChallengeData) == 0x000004, "Wrong alignment on FOakVaultCardPreviousChallengeData");
static_assert(sizeof(FOakVaultCardPreviousChallengeData) == 0x000008, "Wrong size on FOakVaultCardPreviousChallengeData");
static_assert(offsetof(FOakVaultCardPreviousChallengeData, PreviousChallengeSeed) == 0x000000, "Member 'FOakVaultCardPreviousChallengeData::PreviousChallengeSeed' has a wrong offset!");
static_assert(offsetof(FOakVaultCardPreviousChallengeData, PreviousChallengeID) == 0x000004, "Member 'FOakVaultCardPreviousChallengeData::PreviousChallengeID' has a wrong offset!");

// ScriptStruct OakGame.OakProfileCloudData
// 0x0100 (0x0100 - 0x0000)
struct FOakProfileCloudData final
{
public:
	TArray<struct FGameStatSaveGameData>          ProfileStatsData;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInventorySaveGameData>         BankInventoryList;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInventorySaveGameData>         LostLootInventoryList;                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakMailItem>                   NPCMailItems;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         MailGuids;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakSDUSaveGameData>            ProfileSDUList;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakCustomizationSaveGameData>  UnlockedCustomizations;                            // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakInventoryCustomizationPartInfo> UnlockedInventoryCustomizationParts;               // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         GuardianExperience;                                // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrewQuartersDecorationItemSaveGameData> UnlockedCrewQuartersDecorations;                   // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCrewQuartersRoomItemSaveGameData> UnlockedCrewQuartersRooms;                         // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakChallengeSaveGameData>      OakProfileChallengeData;                           // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CitizenScienceLevelProgression;                    // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CitizenScienceCSBucksAmount;                       // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCitizenScienceHasSeenIntroVideo;                  // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCitizenScienceTutorialDone;                       // 0x00CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        LastActiveVaultCardID;                             // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentVaultCardDaySeed;                           // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentVaultCardWeekSeed;                          // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVaultCardRewardList>           VaultCardRewards;                                  // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOakVaultCardPreviousChallengeData> VaultCardPreviousChallenges;                       // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakProfileCloudData) == 0x000008, "Wrong alignment on FOakProfileCloudData");
static_assert(sizeof(FOakProfileCloudData) == 0x000100, "Wrong size on FOakProfileCloudData");
static_assert(offsetof(FOakProfileCloudData, ProfileStatsData) == 0x000000, "Member 'FOakProfileCloudData::ProfileStatsData' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, BankInventoryList) == 0x000010, "Member 'FOakProfileCloudData::BankInventoryList' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, LostLootInventoryList) == 0x000020, "Member 'FOakProfileCloudData::LostLootInventoryList' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, NPCMailItems) == 0x000030, "Member 'FOakProfileCloudData::NPCMailItems' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, MailGuids) == 0x000040, "Member 'FOakProfileCloudData::MailGuids' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, ProfileSDUList) == 0x000050, "Member 'FOakProfileCloudData::ProfileSDUList' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, UnlockedCustomizations) == 0x000060, "Member 'FOakProfileCloudData::UnlockedCustomizations' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, UnlockedInventoryCustomizationParts) == 0x000070, "Member 'FOakProfileCloudData::UnlockedInventoryCustomizationParts' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, GuardianExperience) == 0x000080, "Member 'FOakProfileCloudData::GuardianExperience' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, UnlockedCrewQuartersDecorations) == 0x000088, "Member 'FOakProfileCloudData::UnlockedCrewQuartersDecorations' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, UnlockedCrewQuartersRooms) == 0x000098, "Member 'FOakProfileCloudData::UnlockedCrewQuartersRooms' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, OakProfileChallengeData) == 0x0000A8, "Member 'FOakProfileCloudData::OakProfileChallengeData' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, CitizenScienceLevelProgression) == 0x0000B8, "Member 'FOakProfileCloudData::CitizenScienceLevelProgression' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, CitizenScienceCSBucksAmount) == 0x0000C8, "Member 'FOakProfileCloudData::CitizenScienceCSBucksAmount' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, bCitizenScienceHasSeenIntroVideo) == 0x0000CC, "Member 'FOakProfileCloudData::bCitizenScienceHasSeenIntroVideo' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, bCitizenScienceTutorialDone) == 0x0000CD, "Member 'FOakProfileCloudData::bCitizenScienceTutorialDone' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, LastActiveVaultCardID) == 0x0000D0, "Member 'FOakProfileCloudData::LastActiveVaultCardID' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, CurrentVaultCardDaySeed) == 0x0000D4, "Member 'FOakProfileCloudData::CurrentVaultCardDaySeed' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, CurrentVaultCardWeekSeed) == 0x0000D8, "Member 'FOakProfileCloudData::CurrentVaultCardWeekSeed' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, VaultCardRewards) == 0x0000E0, "Member 'FOakProfileCloudData::VaultCardRewards' has a wrong offset!");
static_assert(offsetof(FOakProfileCloudData, VaultCardPreviousChallenges) == 0x0000F0, "Member 'FOakProfileCloudData::VaultCardPreviousChallenges' has a wrong offset!");

// ScriptStruct OakGame.GoreRegionEventSummary
// 0x002C (0x002C - 0x0000)
struct FGoreRegionEventSummary final
{
public:
	struct FVector_NetQuantize                    HitLocation;                                       // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              HitDirection;                                      // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Origin;                                            // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoreRegionIndex;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGoreRegionEventSummary) == 0x000004, "Wrong alignment on FGoreRegionEventSummary");
static_assert(sizeof(FGoreRegionEventSummary) == 0x00002C, "Wrong size on FGoreRegionEventSummary");
static_assert(offsetof(FGoreRegionEventSummary, HitLocation) == 0x000000, "Member 'FGoreRegionEventSummary::HitLocation' has a wrong offset!");
static_assert(offsetof(FGoreRegionEventSummary, HitDirection) == 0x00000C, "Member 'FGoreRegionEventSummary::HitDirection' has a wrong offset!");
static_assert(offsetof(FGoreRegionEventSummary, Origin) == 0x000018, "Member 'FGoreRegionEventSummary::Origin' has a wrong offset!");
static_assert(offsetof(FGoreRegionEventSummary, Radius) == 0x000024, "Member 'FGoreRegionEventSummary::Radius' has a wrong offset!");
static_assert(offsetof(FGoreRegionEventSummary, GoreRegionIndex) == 0x000028, "Member 'FGoreRegionEventSummary::GoreRegionIndex' has a wrong offset!");

// ScriptStruct OakGame.GoreRegionState
// 0x0060 (0x0060 - 0x0000)
struct FGoreRegionState final
{
public:
	class UGoreDamageData*                        GoreData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideStumpSocket : 1;                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideRootDamageBone : 1;                       // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideStumpBoneScale : 1;                       // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLimbSocket : 1;                           // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StumpSocket;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StumpBoneScale;                                    // 0x0018(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RootDamageBone;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimbSocket;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbScale;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventName;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGoreRegionState) == 0x000008, "Wrong alignment on FGoreRegionState");
static_assert(sizeof(FGoreRegionState) == 0x000060, "Wrong size on FGoreRegionState");
static_assert(offsetof(FGoreRegionState, GoreData) == 0x000000, "Member 'FGoreRegionState::GoreData' has a wrong offset!");
static_assert(offsetof(FGoreRegionState, StumpSocket) == 0x000010, "Member 'FGoreRegionState::StumpSocket' has a wrong offset!");
static_assert(offsetof(FGoreRegionState, StumpBoneScale) == 0x000018, "Member 'FGoreRegionState::StumpBoneScale' has a wrong offset!");
static_assert(offsetof(FGoreRegionState, RootDamageBone) == 0x000028, "Member 'FGoreRegionState::RootDamageBone' has a wrong offset!");
static_assert(offsetof(FGoreRegionState, LimbSocket) == 0x000030, "Member 'FGoreRegionState::LimbSocket' has a wrong offset!");
static_assert(offsetof(FGoreRegionState, LimbScale) == 0x000038, "Member 'FGoreRegionState::LimbScale' has a wrong offset!");
static_assert(offsetof(FGoreRegionState, EventName) == 0x000040, "Member 'FGoreRegionState::EventName' has a wrong offset!");

// ScriptStruct OakGame.PlayerDifficultyBalanceInfo
// 0x0004 (0x0004 - 0x0000)
struct FPlayerDifficultyBalanceInfo final
{
public:
	float                                         PlayerDamageTakenMultiplier;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDifficultyBalanceInfo) == 0x000004, "Wrong alignment on FPlayerDifficultyBalanceInfo");
static_assert(sizeof(FPlayerDifficultyBalanceInfo) == 0x000004, "Wrong size on FPlayerDifficultyBalanceInfo");
static_assert(offsetof(FPlayerDifficultyBalanceInfo, PlayerDamageTakenMultiplier) == 0x000000, "Member 'FPlayerDifficultyBalanceInfo::PlayerDamageTakenMultiplier' has a wrong offset!");

// ScriptStruct OakGame.PhotoModeState
// 0x0670 (0x0670 - 0x0000)
struct FPhotoModeState final
{
public:
	bool                                          bPhotoModeUIVisible;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHUDVisible;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamePausedState;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoFocusState;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0010(0x0600)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	float                                         Contrast;                                          // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DOFIntensity;                                      // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilmToneMapperState;                              // 0x061C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FilterIndex;                                       // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterIntensity;                                   // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocalDistance;                                     // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocalRegion;                                       // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FringeIntensity;                                   // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain;                                              // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gamma;                                             // 0x0638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrainIntensity;                                    // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayerState;                                  // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Quality;                                           // 0x0644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saturation;                                        // 0x0648(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shoulder;                                          // 0x064C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Slope;                                             // 0x0650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuperSharpModeState;                              // 0x0654(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Toe;                                               // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewRoll;                                          // 0x065C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteIntensity;                                 // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteFeathering;                                // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDay;                                         // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPausable;                                         // 0x066C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDamageNumbersState;                           // 0x066D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFocusState;                               // 0x066E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchGameState;                                   // 0x066F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhotoModeState) == 0x000010, "Wrong alignment on FPhotoModeState");
static_assert(sizeof(FPhotoModeState) == 0x000670, "Wrong size on FPhotoModeState");
static_assert(offsetof(FPhotoModeState, bPhotoModeUIVisible) == 0x000000, "Member 'FPhotoModeState::bPhotoModeUIVisible' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bHUDVisible) == 0x000001, "Member 'FPhotoModeState::bHUDVisible' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bGamePausedState) == 0x000002, "Member 'FPhotoModeState::bGamePausedState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bAutoFocusState) == 0x000003, "Member 'FPhotoModeState::bAutoFocusState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, PostProcessSettings) == 0x000010, "Member 'FPhotoModeState::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Contrast) == 0x000610, "Member 'FPhotoModeState::Contrast' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, DOFIntensity) == 0x000614, "Member 'FPhotoModeState::DOFIntensity' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, FOV) == 0x000618, "Member 'FPhotoModeState::FOV' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bFilmToneMapperState) == 0x00061C, "Member 'FPhotoModeState::bFilmToneMapperState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, FilterIndex) == 0x000620, "Member 'FPhotoModeState::FilterIndex' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, FilterIntensity) == 0x000624, "Member 'FPhotoModeState::FilterIntensity' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, FocalDistance) == 0x000628, "Member 'FPhotoModeState::FocalDistance' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, FocalRegion) == 0x00062C, "Member 'FPhotoModeState::FocalRegion' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, FringeIntensity) == 0x000630, "Member 'FPhotoModeState::FringeIntensity' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Gain) == 0x000634, "Member 'FPhotoModeState::Gain' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Gamma) == 0x000638, "Member 'FPhotoModeState::Gamma' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, GrainIntensity) == 0x00063C, "Member 'FPhotoModeState::GrainIntensity' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bHidePlayerState) == 0x000640, "Member 'FPhotoModeState::bHidePlayerState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Quality) == 0x000644, "Member 'FPhotoModeState::Quality' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Saturation) == 0x000648, "Member 'FPhotoModeState::Saturation' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Shoulder) == 0x00064C, "Member 'FPhotoModeState::Shoulder' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Slope) == 0x000650, "Member 'FPhotoModeState::Slope' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bSuperSharpModeState) == 0x000654, "Member 'FPhotoModeState::bSuperSharpModeState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, Toe) == 0x000658, "Member 'FPhotoModeState::Toe' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, ViewRoll) == 0x00065C, "Member 'FPhotoModeState::ViewRoll' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, VignetteIntensity) == 0x000660, "Member 'FPhotoModeState::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, VignetteFeathering) == 0x000664, "Member 'FPhotoModeState::VignetteFeathering' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, TimeOfDay) == 0x000668, "Member 'FPhotoModeState::TimeOfDay' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bPausable) == 0x00066C, "Member 'FPhotoModeState::bPausable' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bHideDamageNumbersState) == 0x00066D, "Member 'FPhotoModeState::bHideDamageNumbersState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bOverrideFocusState) == 0x00066E, "Member 'FPhotoModeState::bOverrideFocusState' has a wrong offset!");
static_assert(offsetof(FPhotoModeState, bMatchGameState) == 0x00066F, "Member 'FPhotoModeState::bMatchGameState' has a wrong offset!");

// ScriptStruct OakGame.NumPlayersDamageBalanceInfo
// 0x0008 (0x0008 - 0x0000)
struct FNumPlayersDamageBalanceInfo final
{
public:
	int32                                         NumPlayers;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationMultiplier;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNumPlayersDamageBalanceInfo) == 0x000004, "Wrong alignment on FNumPlayersDamageBalanceInfo");
static_assert(sizeof(FNumPlayersDamageBalanceInfo) == 0x000008, "Wrong size on FNumPlayersDamageBalanceInfo");
static_assert(offsetof(FNumPlayersDamageBalanceInfo, NumPlayers) == 0x000000, "Member 'FNumPlayersDamageBalanceInfo::NumPlayers' has a wrong offset!");
static_assert(offsetof(FNumPlayersDamageBalanceInfo, RadiationMultiplier) == 0x000004, "Member 'FNumPlayersDamageBalanceInfo::RadiationMultiplier' has a wrong offset!");

// ScriptStruct OakGame.IncomingDamageDisplayInfo
// 0x0270 (0x0270 - 0x0000)
struct FIncomingDamageDisplayInfo final
{
public:
	class UStaticMesh*                            HealthDamageIndicatorStaticMesh;                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ShieldDamageIndicatorStaticMesh;                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ArmorDamageIndicatorStaticMesh;                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageIndicatorRelativeLocation;                   // 0x0018(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorScale;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinForegroundFOVToDrawIndicators;                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorDuration;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorFadeDuration;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ScaleDurationBySeverityCurve;                      // 0x0038(0x0078)(Edit, NativeAccessSpecifierPublic)
	int32                                         MaxDamageIndicators;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageIndicatorSphereRelativeLocation;             // 0x00B4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIndicatorSphereRelativePitch;                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageIndicatorSphereRadius;                       // 0x00C4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageIndicatorOpacityAlphaParameterName;          // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageIndicatorPercentOfLifeMaterialParameterName; // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          DamageIndicatorCenterFadeScreenPercent;            // 0x00E0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   DamageIndicatorCenterFadeMaterialParameterName;    // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DamageIndicatorYawRemappingCurve;                  // 0x00F0(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DamageIndicatorPitchRemappingCurve;                // 0x0168(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxPitchToApplyYawRemapping;                       // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeJoltRange;                                    // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     MeleeJoltLocationCurve;                            // 0x01E8(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         AttackerLocationCrouchEasing;                      // 0x0260(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AttackerLocationCrouchTransitionDuration;          // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIncomingDamageDisplayInfo) == 0x000008, "Wrong alignment on FIncomingDamageDisplayInfo");
static_assert(sizeof(FIncomingDamageDisplayInfo) == 0x000270, "Wrong size on FIncomingDamageDisplayInfo");
static_assert(offsetof(FIncomingDamageDisplayInfo, HealthDamageIndicatorStaticMesh) == 0x000000, "Member 'FIncomingDamageDisplayInfo::HealthDamageIndicatorStaticMesh' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, ShieldDamageIndicatorStaticMesh) == 0x000008, "Member 'FIncomingDamageDisplayInfo::ShieldDamageIndicatorStaticMesh' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, ArmorDamageIndicatorStaticMesh) == 0x000010, "Member 'FIncomingDamageDisplayInfo::ArmorDamageIndicatorStaticMesh' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorRelativeLocation) == 0x000018, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorRelativeLocation' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorScale) == 0x000024, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorScale' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, MinForegroundFOVToDrawIndicators) == 0x000028, "Member 'FIncomingDamageDisplayInfo::MinForegroundFOVToDrawIndicators' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorDuration) == 0x00002C, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorDuration' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorFadeDuration) == 0x000030, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorFadeDuration' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, ScaleDurationBySeverityCurve) == 0x000038, "Member 'FIncomingDamageDisplayInfo::ScaleDurationBySeverityCurve' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, MaxDamageIndicators) == 0x0000B0, "Member 'FIncomingDamageDisplayInfo::MaxDamageIndicators' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorSphereRelativeLocation) == 0x0000B4, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorSphereRelativeLocation' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorSphereRelativePitch) == 0x0000C0, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorSphereRelativePitch' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorSphereRadius) == 0x0000C4, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorSphereRadius' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorOpacityAlphaParameterName) == 0x0000D0, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorOpacityAlphaParameterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorPercentOfLifeMaterialParameterName) == 0x0000D8, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorPercentOfLifeMaterialParameterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorCenterFadeScreenPercent) == 0x0000E0, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorCenterFadeScreenPercent' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorCenterFadeMaterialParameterName) == 0x0000E8, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorCenterFadeMaterialParameterName' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorYawRemappingCurve) == 0x0000F0, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorYawRemappingCurve' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, DamageIndicatorPitchRemappingCurve) == 0x000168, "Member 'FIncomingDamageDisplayInfo::DamageIndicatorPitchRemappingCurve' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, MaxPitchToApplyYawRemapping) == 0x0001E0, "Member 'FIncomingDamageDisplayInfo::MaxPitchToApplyYawRemapping' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, MeleeJoltRange) == 0x0001E4, "Member 'FIncomingDamageDisplayInfo::MeleeJoltRange' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, MeleeJoltLocationCurve) == 0x0001E8, "Member 'FIncomingDamageDisplayInfo::MeleeJoltLocationCurve' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, AttackerLocationCrouchEasing) == 0x000260, "Member 'FIncomingDamageDisplayInfo::AttackerLocationCrouchEasing' has a wrong offset!");
static_assert(offsetof(FIncomingDamageDisplayInfo, AttackerLocationCrouchTransitionDuration) == 0x00026C, "Member 'FIncomingDamageDisplayInfo::AttackerLocationCrouchTransitionDuration' has a wrong offset!");

// ScriptStruct OakGame.StatusEffectApplicationDamageDefaultSettings
// 0x0018 (0x0018 - 0x0000)
struct FStatusEffectApplicationDamageDefaultSettings final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentBaseDamage;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentChance;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectApplicationDamageDefaultSettings) == 0x000008, "Wrong alignment on FStatusEffectApplicationDamageDefaultSettings");
static_assert(sizeof(FStatusEffectApplicationDamageDefaultSettings) == 0x000018, "Wrong size on FStatusEffectApplicationDamageDefaultSettings");
static_assert(offsetof(FStatusEffectApplicationDamageDefaultSettings, StatusEffectData) == 0x000000, "Member 'FStatusEffectApplicationDamageDefaultSettings::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectApplicationDamageDefaultSettings, Duration) == 0x000008, "Member 'FStatusEffectApplicationDamageDefaultSettings::Duration' has a wrong offset!");
static_assert(offsetof(FStatusEffectApplicationDamageDefaultSettings, PercentBaseDamage) == 0x00000C, "Member 'FStatusEffectApplicationDamageDefaultSettings::PercentBaseDamage' has a wrong offset!");
static_assert(offsetof(FStatusEffectApplicationDamageDefaultSettings, PercentChance) == 0x000010, "Member 'FStatusEffectApplicationDamageDefaultSettings::PercentChance' has a wrong offset!");

// ScriptStruct OakGame.DamageDisplayInfo
// 0x0038 (0x0038 - 0x0000)
struct FDamageDisplayInfo final
{
public:
	class UParticleSystem*                        DamageNumberParticleSystem;                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageNumberParticleEventName;                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageNumberCritParticleEventName;                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageNumberResistParticleEventName;               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageNumberImmuneParticleEventName;               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageNumberVehicleLocationOffset;                 // 0x0028(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageDisplayInfo) == 0x000008, "Wrong alignment on FDamageDisplayInfo");
static_assert(sizeof(FDamageDisplayInfo) == 0x000038, "Wrong size on FDamageDisplayInfo");
static_assert(offsetof(FDamageDisplayInfo, DamageNumberParticleSystem) == 0x000000, "Member 'FDamageDisplayInfo::DamageNumberParticleSystem' has a wrong offset!");
static_assert(offsetof(FDamageDisplayInfo, DamageNumberParticleEventName) == 0x000008, "Member 'FDamageDisplayInfo::DamageNumberParticleEventName' has a wrong offset!");
static_assert(offsetof(FDamageDisplayInfo, DamageNumberCritParticleEventName) == 0x000010, "Member 'FDamageDisplayInfo::DamageNumberCritParticleEventName' has a wrong offset!");
static_assert(offsetof(FDamageDisplayInfo, DamageNumberResistParticleEventName) == 0x000018, "Member 'FDamageDisplayInfo::DamageNumberResistParticleEventName' has a wrong offset!");
static_assert(offsetof(FDamageDisplayInfo, DamageNumberImmuneParticleEventName) == 0x000020, "Member 'FDamageDisplayInfo::DamageNumberImmuneParticleEventName' has a wrong offset!");
static_assert(offsetof(FDamageDisplayInfo, DamageNumberVehicleLocationOffset) == 0x000028, "Member 'FDamageDisplayInfo::DamageNumberVehicleLocationOffset' has a wrong offset!");

// ScriptStruct OakGame.OakPipelineDamageInput
// 0x0050 (0x0200 - 0x01B0)
struct FOakPipelineDamageInput final : public FPipelineDamageInput
{
public:
	uint8                                         Pad_1B0[0x40];                                     // 0x01B0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameStatData*                          KillStat;                                          // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPipelineDamageInput) == 0x000010, "Wrong alignment on FOakPipelineDamageInput");
static_assert(sizeof(FOakPipelineDamageInput) == 0x000200, "Wrong size on FOakPipelineDamageInput");
static_assert(offsetof(FOakPipelineDamageInput, KillStat) == 0x0001F0, "Member 'FOakPipelineDamageInput::KillStat' has a wrong offset!");

// ScriptStruct OakGame.OakHealthTypeBalanceData
// 0x0038 (0x0040 - 0x0008)
struct FOakHealthTypeBalanceData final : public FHealthTypeBalanceData
{
public:
	float                                         NonelementalModifier;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CorrosiveModifier;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CryoModifier;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireModifier;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShockModifier;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationModifier;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    PlayThroughTwoOverride;                            // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    MayhemLevel4Override;                              // 0x0030(0x0010)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakHealthTypeBalanceData) == 0x000008, "Wrong alignment on FOakHealthTypeBalanceData");
static_assert(sizeof(FOakHealthTypeBalanceData) == 0x000040, "Wrong size on FOakHealthTypeBalanceData");
static_assert(offsetof(FOakHealthTypeBalanceData, NonelementalModifier) == 0x000008, "Member 'FOakHealthTypeBalanceData::NonelementalModifier' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, CorrosiveModifier) == 0x00000C, "Member 'FOakHealthTypeBalanceData::CorrosiveModifier' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, CryoModifier) == 0x000010, "Member 'FOakHealthTypeBalanceData::CryoModifier' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, FireModifier) == 0x000014, "Member 'FOakHealthTypeBalanceData::FireModifier' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, ShockModifier) == 0x000018, "Member 'FOakHealthTypeBalanceData::ShockModifier' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, RadiationModifier) == 0x00001C, "Member 'FOakHealthTypeBalanceData::RadiationModifier' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, PlayThroughTwoOverride) == 0x000020, "Member 'FOakHealthTypeBalanceData::PlayThroughTwoOverride' has a wrong offset!");
static_assert(offsetof(FOakHealthTypeBalanceData, MayhemLevel4Override) == 0x000030, "Member 'FOakHealthTypeBalanceData::MayhemLevel4Override' has a wrong offset!");

// ScriptStruct OakGame.CauseDamageStatusEffectOverrides
// 0x001C (0x001C - 0x0000)
struct FCauseDamageStatusEffectOverrides final
{
public:
	float                                         BaseChance;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDuration;                                      // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseDamageAsPercent;                              // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceScalar;                                      // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationScalar;                                    // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScalar;                                      // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCauseDamageStatusEffectOverrides) == 0x000004, "Wrong alignment on FCauseDamageStatusEffectOverrides");
static_assert(sizeof(FCauseDamageStatusEffectOverrides) == 0x00001C, "Wrong size on FCauseDamageStatusEffectOverrides");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, BaseChance) == 0x000000, "Member 'FCauseDamageStatusEffectOverrides::BaseChance' has a wrong offset!");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, BaseDuration) == 0x000004, "Member 'FCauseDamageStatusEffectOverrides::BaseDuration' has a wrong offset!");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, BaseDamage) == 0x000008, "Member 'FCauseDamageStatusEffectOverrides::BaseDamage' has a wrong offset!");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, bBaseDamageAsPercent) == 0x00000C, "Member 'FCauseDamageStatusEffectOverrides::bBaseDamageAsPercent' has a wrong offset!");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, ChanceScalar) == 0x000010, "Member 'FCauseDamageStatusEffectOverrides::ChanceScalar' has a wrong offset!");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, DurationScalar) == 0x000014, "Member 'FCauseDamageStatusEffectOverrides::DurationScalar' has a wrong offset!");
static_assert(offsetof(FCauseDamageStatusEffectOverrides, DamageScalar) == 0x000018, "Member 'FCauseDamageStatusEffectOverrides::DamageScalar' has a wrong offset!");

// ScriptStruct OakGame.AvailablePartData
// 0x0050 (0x0050 - 0x0000)
struct FAvailablePartData final
{
public:
	struct FWeightedActorPartData                 PartData;                                          // 0x0000(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	class UOakDebugWeaponBuilderButton*           OptionButton;                                      // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailablePartData) == 0x000008, "Wrong alignment on FAvailablePartData");
static_assert(sizeof(FAvailablePartData) == 0x000050, "Wrong size on FAvailablePartData");
static_assert(offsetof(FAvailablePartData, PartData) == 0x000000, "Member 'FAvailablePartData::PartData' has a wrong offset!");
static_assert(offsetof(FAvailablePartData, OptionButton) == 0x000040, "Member 'FAvailablePartData::OptionButton' has a wrong offset!");

// ScriptStruct OakGame.IronBearHardPointAugmentInfo
// 0x0040 (0x0040 - 0x0000)
struct FIronBearHardPointAugmentInfo final
{
public:
	TSoftObjectPtr<class UOakActionAbilityAugmentData> HardPointAugment;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Mesh;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 LeftFlourishAnimation;                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 RightFlourishAnimation;                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIronBearHardPointAugmentInfo) == 0x000008, "Wrong alignment on FIronBearHardPointAugmentInfo");
static_assert(sizeof(FIronBearHardPointAugmentInfo) == 0x000040, "Wrong size on FIronBearHardPointAugmentInfo");
static_assert(offsetof(FIronBearHardPointAugmentInfo, HardPointAugment) == 0x000000, "Member 'FIronBearHardPointAugmentInfo::HardPointAugment' has a wrong offset!");
static_assert(offsetof(FIronBearHardPointAugmentInfo, Mesh) == 0x000028, "Member 'FIronBearHardPointAugmentInfo::Mesh' has a wrong offset!");
static_assert(offsetof(FIronBearHardPointAugmentInfo, LeftFlourishAnimation) == 0x000030, "Member 'FIronBearHardPointAugmentInfo::LeftFlourishAnimation' has a wrong offset!");
static_assert(offsetof(FIronBearHardPointAugmentInfo, RightFlourishAnimation) == 0x000038, "Member 'FIronBearHardPointAugmentInfo::RightFlourishAnimation' has a wrong offset!");

// ScriptStruct OakGame.AvailableInventoryBalanceData
// 0x0018 (0x0018 - 0x0000)
struct FAvailableInventoryBalanceData final
{
public:
	class UInventoryBalanceData*                  InventoryBalance;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakDebugWeaponBuilderButton*           OptionButton;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAvailableInventoryBalanceData) == 0x000008, "Wrong alignment on FAvailableInventoryBalanceData");
static_assert(sizeof(FAvailableInventoryBalanceData) == 0x000018, "Wrong size on FAvailableInventoryBalanceData");
static_assert(offsetof(FAvailableInventoryBalanceData, InventoryBalance) == 0x000000, "Member 'FAvailableInventoryBalanceData::InventoryBalance' has a wrong offset!");
static_assert(offsetof(FAvailableInventoryBalanceData, OptionButton) == 0x000008, "Member 'FAvailableInventoryBalanceData::OptionButton' has a wrong offset!");

// ScriptStruct OakGame.DeveloperPerk
// 0x0018 (0x0018 - 0x0000)
struct FDeveloperPerk final
{
public:
	TArray<struct FKey>                           KeyCombo;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         PerkTypeEnumIdx;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeveloperPerk) == 0x000008, "Wrong alignment on FDeveloperPerk");
static_assert(sizeof(FDeveloperPerk) == 0x000018, "Wrong size on FDeveloperPerk");
static_assert(offsetof(FDeveloperPerk, KeyCombo) == 0x000000, "Member 'FDeveloperPerk::KeyCombo' has a wrong offset!");
static_assert(offsetof(FDeveloperPerk, PerkTypeEnumIdx) == 0x000010, "Member 'FDeveloperPerk::PerkTypeEnumIdx' has a wrong offset!");

// ScriptStruct OakGame.EchoLogTrackingInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FEchoLogTrackingInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             Event;                                             // 0x0010(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEchoLogTrackingInfo) == 0x000008, "Wrong alignment on FEchoLogTrackingInfo");
static_assert(sizeof(FEchoLogTrackingInfo) == 0x000020, "Wrong size on FEchoLogTrackingInfo");
static_assert(offsetof(FEchoLogTrackingInfo, Event) == 0x000010, "Member 'FEchoLogTrackingInfo::Event' has a wrong offset!");

// ScriptStruct OakGame.DialogScriptToLoadEntry
// 0x0038 (0x0038 - 0x0000)
struct FDialogScriptToLoadEntry final
{
public:
	class FString                                 DialogScriptLevelName;                             // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDialogScriptData>       DialogScriptToLoad;                                // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogScriptToLoadEntry) == 0x000008, "Wrong alignment on FDialogScriptToLoadEntry");
static_assert(sizeof(FDialogScriptToLoadEntry) == 0x000038, "Wrong size on FDialogScriptToLoadEntry");
static_assert(offsetof(FDialogScriptToLoadEntry, DialogScriptLevelName) == 0x000000, "Member 'FDialogScriptToLoadEntry::DialogScriptLevelName' has a wrong offset!");
static_assert(offsetof(FDialogScriptToLoadEntry, DialogScriptToLoad) == 0x000010, "Member 'FDialogScriptToLoadEntry::DialogScriptToLoad' has a wrong offset!");

// ScriptStruct OakGame.OakDownloadableEntitlementCurrencyType
// 0x0010 (0x0010 - 0x0000)
struct FOakDownloadableEntitlementCurrencyType final
{
public:
	class FName                                   CurrencyName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDownloadableEntitlementPartData_Currency* CurrencyPartData;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakDownloadableEntitlementCurrencyType) == 0x000008, "Wrong alignment on FOakDownloadableEntitlementCurrencyType");
static_assert(sizeof(FOakDownloadableEntitlementCurrencyType) == 0x000010, "Wrong size on FOakDownloadableEntitlementCurrencyType");
static_assert(offsetof(FOakDownloadableEntitlementCurrencyType, CurrencyName) == 0x000000, "Member 'FOakDownloadableEntitlementCurrencyType::CurrencyName' has a wrong offset!");
static_assert(offsetof(FOakDownloadableEntitlementCurrencyType, CurrencyPartData) == 0x000008, "Member 'FOakDownloadableEntitlementCurrencyType::CurrencyPartData' has a wrong offset!");

// ScriptStruct OakGame.DownloadableEntitlementSetItem
// 0x0030 (0x0030 - 0x0000)
struct FDownloadableEntitlementSetItem final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FString                                 SerialNumber;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDownloadableEntitlementSetItem) == 0x000008, "Wrong alignment on FDownloadableEntitlementSetItem");
static_assert(sizeof(FDownloadableEntitlementSetItem) == 0x000030, "Wrong size on FDownloadableEntitlementSetItem");
static_assert(offsetof(FDownloadableEntitlementSetItem, ID) == 0x000000, "Member 'FDownloadableEntitlementSetItem::ID' has a wrong offset!");
static_assert(offsetof(FDownloadableEntitlementSetItem, Count) == 0x000004, "Member 'FDownloadableEntitlementSetItem::Count' has a wrong offset!");
static_assert(offsetof(FDownloadableEntitlementSetItem, Description) == 0x000008, "Member 'FDownloadableEntitlementSetItem::Description' has a wrong offset!");
static_assert(offsetof(FDownloadableEntitlementSetItem, SerialNumber) == 0x000020, "Member 'FDownloadableEntitlementSetItem::SerialNumber' has a wrong offset!");

// ScriptStruct OakGame.GRMLNBeamConfiguration
// 0x0128 (0x0128 - 0x0000)
struct FGRMLNBeamConfiguration final
{
public:
	struct FEnvQueryParams                        TargetQuery;                                       // 0x0000(0x00B8)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           BeamDuration;                                      // 0x00B8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           CooldownDuration;                                  // 0x00F0(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGRMLNBeamConfiguration) == 0x000008, "Wrong alignment on FGRMLNBeamConfiguration");
static_assert(sizeof(FGRMLNBeamConfiguration) == 0x000128, "Wrong size on FGRMLNBeamConfiguration");
static_assert(offsetof(FGRMLNBeamConfiguration, TargetQuery) == 0x000000, "Member 'FGRMLNBeamConfiguration::TargetQuery' has a wrong offset!");
static_assert(offsetof(FGRMLNBeamConfiguration, BeamDuration) == 0x0000B8, "Member 'FGRMLNBeamConfiguration::BeamDuration' has a wrong offset!");
static_assert(offsetof(FGRMLNBeamConfiguration, CooldownDuration) == 0x0000F0, "Member 'FGRMLNBeamConfiguration::CooldownDuration' has a wrong offset!");

// ScriptStruct OakGame.GRMLNBeamData
// 0x00F8 (0x00F8 - 0x0000)
struct FGRMLNBeamData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakDroneProjectile_GRMLN*              Owner;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CurrentTarget;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       TargetDamageComponent;                             // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FEnvQueryParams                        TargetQueryParams;                                 // 0x0020(0x00B8)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGRMLNBeamData) == 0x000008, "Wrong alignment on FGRMLNBeamData");
static_assert(sizeof(FGRMLNBeamData) == 0x0000F8, "Wrong size on FGRMLNBeamData");
static_assert(offsetof(FGRMLNBeamData, Owner) == 0x000008, "Member 'FGRMLNBeamData::Owner' has a wrong offset!");
static_assert(offsetof(FGRMLNBeamData, CurrentTarget) == 0x000010, "Member 'FGRMLNBeamData::CurrentTarget' has a wrong offset!");
static_assert(offsetof(FGRMLNBeamData, TargetDamageComponent) == 0x000018, "Member 'FGRMLNBeamData::TargetDamageComponent' has a wrong offset!");
static_assert(offsetof(FGRMLNBeamData, TargetQueryParams) == 0x000020, "Member 'FGRMLNBeamData::TargetQueryParams' has a wrong offset!");

// ScriptStruct OakGame.GRMLNStaticFieldData
// 0x0028 (0x0120 - 0x00F8)
struct FGRMLNStaticFieldData final : public FGRMLNBeamData
{
public:
	TScriptInterface<class IShieldProviderInterface> ShieldProviderInterface;                           // 0x00F8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGRMLNStaticFieldData) == 0x000008, "Wrong alignment on FGRMLNStaticFieldData");
static_assert(sizeof(FGRMLNStaticFieldData) == 0x000120, "Wrong size on FGRMLNStaticFieldData");
static_assert(offsetof(FGRMLNStaticFieldData, ShieldProviderInterface) == 0x0000F8, "Member 'FGRMLNStaticFieldData::ShieldProviderInterface' has a wrong offset!");

// ScriptStruct OakGame.GRMLNBadDoseData
// 0x0000 (0x00F8 - 0x00F8)
struct FGRMLNBadDoseData final : public FGRMLNBeamData
{
};
static_assert(alignof(FGRMLNBadDoseData) == 0x000008, "Wrong alignment on FGRMLNBadDoseData");
static_assert(sizeof(FGRMLNBadDoseData) == 0x0000F8, "Wrong size on FGRMLNBadDoseData");

// ScriptStruct OakGame.OperativeStandInActionAbility
// 0x0080 (0x0080 - 0x0000)
struct FOperativeStandInActionAbility final
{
public:
	TSoftClassPtr<class UClass>                   Ability;                                           // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 CharacterFlourishAnimation;                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AStandInAuxiliaryActor>     AuxiliaryActor;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AuxiliaryTranslationOffset;                        // 0x0038(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AuxiliaryRotationOffset;                           // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AuxiliaryScale;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 AuxiliaryFlourishAnimation;                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 AuxiliaryIdleAnimation;                            // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachAuxiliaryActorToCharacter;                  // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AuxiliaryAttachmentSocket;                         // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyPlayerAnims;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyPlayerWeapon;                                 // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeInFlourishVisibleDelay;                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOperativeStandInActionAbility) == 0x000008, "Wrong alignment on FOperativeStandInActionAbility");
static_assert(sizeof(FOperativeStandInActionAbility) == 0x000080, "Wrong size on FOperativeStandInActionAbility");
static_assert(offsetof(FOperativeStandInActionAbility, Ability) == 0x000000, "Member 'FOperativeStandInActionAbility::Ability' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, CharacterFlourishAnimation) == 0x000028, "Member 'FOperativeStandInActionAbility::CharacterFlourishAnimation' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryActor) == 0x000030, "Member 'FOperativeStandInActionAbility::AuxiliaryActor' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryTranslationOffset) == 0x000038, "Member 'FOperativeStandInActionAbility::AuxiliaryTranslationOffset' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryRotationOffset) == 0x000044, "Member 'FOperativeStandInActionAbility::AuxiliaryRotationOffset' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryScale) == 0x000050, "Member 'FOperativeStandInActionAbility::AuxiliaryScale' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryFlourishAnimation) == 0x000058, "Member 'FOperativeStandInActionAbility::AuxiliaryFlourishAnimation' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryIdleAnimation) == 0x000060, "Member 'FOperativeStandInActionAbility::AuxiliaryIdleAnimation' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, bAttachAuxiliaryActorToCharacter) == 0x000068, "Member 'FOperativeStandInActionAbility::bAttachAuxiliaryActorToCharacter' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, AuxiliaryAttachmentSocket) == 0x000070, "Member 'FOperativeStandInActionAbility::AuxiliaryAttachmentSocket' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, bCopyPlayerAnims) == 0x000078, "Member 'FOperativeStandInActionAbility::bCopyPlayerAnims' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, bCopyPlayerWeapon) == 0x000079, "Member 'FOperativeStandInActionAbility::bCopyPlayerWeapon' has a wrong offset!");
static_assert(offsetof(FOperativeStandInActionAbility, FadeInFlourishVisibleDelay) == 0x00007C, "Member 'FOperativeStandInActionAbility::FadeInFlourishVisibleDelay' has a wrong offset!");

// ScriptStruct OakGame.RushStackInstance
// 0x0010 (0x0010 - 0x0000)
struct FRushStackInstance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USirenRushStackData*                    StackData;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRushStackInstance) == 0x000008, "Wrong alignment on FRushStackInstance");
static_assert(sizeof(FRushStackInstance) == 0x000010, "Wrong size on FRushStackInstance");
static_assert(offsetof(FRushStackInstance, StackData) == 0x000008, "Member 'FRushStackInstance::StackData' has a wrong offset!");

// ScriptStruct OakGame.PlayerClassToClassId
// 0x0018 (0x0018 - 0x0000)
struct FPlayerClassToClassId final
{
public:
	class FString                                 PlayerClassName;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ClassId;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerClassToClassId) == 0x000008, "Wrong alignment on FPlayerClassToClassId");
static_assert(sizeof(FPlayerClassToClassId) == 0x000018, "Wrong size on FPlayerClassToClassId");
static_assert(offsetof(FPlayerClassToClassId, PlayerClassName) == 0x000000, "Member 'FPlayerClassToClassId::PlayerClassName' has a wrong offset!");
static_assert(offsetof(FPlayerClassToClassId, ClassId) == 0x000010, "Member 'FPlayerClassToClassId::ClassId' has a wrong offset!");

// ScriptStruct OakGame.ConditionalSavegameExpression
// 0x0018 (0x0018 - 0x0000)
struct FConditionalSavegameExpression final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOakSaveGame>               SaveGame;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOakProfile>                Profile;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalSavegameExpression) == 0x000008, "Wrong alignment on FConditionalSavegameExpression");
static_assert(sizeof(FConditionalSavegameExpression) == 0x000018, "Wrong size on FConditionalSavegameExpression");
static_assert(offsetof(FConditionalSavegameExpression, Condition) == 0x000000, "Member 'FConditionalSavegameExpression::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalSavegameExpression, SaveGame) == 0x000008, "Member 'FConditionalSavegameExpression::SaveGame' has a wrong offset!");
static_assert(offsetof(FConditionalSavegameExpression, Profile) == 0x000010, "Member 'FConditionalSavegameExpression::Profile' has a wrong offset!");

// ScriptStruct OakGame.GameStateSaveData
// 0x000C (0x000C - 0x0000)
struct FGameStateSaveData final
{
public:
	struct FMapIDData                             LastTraveledMapID;                                 // 0x0000(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MayhemLevel;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MayhemRandomSeed;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStateSaveData) == 0x000004, "Wrong alignment on FGameStateSaveData");
static_assert(sizeof(FGameStateSaveData) == 0x00000C, "Wrong size on FGameStateSaveData");
static_assert(offsetof(FGameStateSaveData, LastTraveledMapID) == 0x000000, "Member 'FGameStateSaveData::LastTraveledMapID' has a wrong offset!");
static_assert(offsetof(FGameStateSaveData, MayhemLevel) == 0x000004, "Member 'FGameStateSaveData::MayhemLevel' has a wrong offset!");
static_assert(offsetof(FGameStateSaveData, MayhemRandomSeed) == 0x000008, "Member 'FGameStateSaveData::MayhemRandomSeed' has a wrong offset!");

// ScriptStruct OakGame.GbxInputEventHelper_SigFunc_OakMoveLookAxis_Data
// 0x0010 (0x0010 - 0x0000)
struct FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data final
{
public:
	struct FVector                                Val;                                               // 0x0000(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamePad;                                          // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data) == 0x000004, "Wrong alignment on FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data");
static_assert(sizeof(FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data) == 0x000010, "Wrong size on FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data");
static_assert(offsetof(FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data, Val) == 0x000000, "Member 'FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data::Val' has a wrong offset!");
static_assert(offsetof(FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data, bGamePad) == 0x00000C, "Member 'FGbxInputEventHelper_SigFunc_OakMoveLookAxis_Data::bGamePad' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryItemSaveGameData
// 0x00B0 (0x00B0 - 0x0000)
struct FOakInventoryItemSaveGameData final
{
public:
	struct FInventorySaveGameData                 Item;                                              // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	int32                                         PickupOrderIndex;                                  // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags;                                             // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWeaponSkinPartData>     WeaponSkinPath;                                    // 0x0088(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakInventoryItemSaveGameData) == 0x000008, "Wrong alignment on FOakInventoryItemSaveGameData");
static_assert(sizeof(FOakInventoryItemSaveGameData) == 0x0000B0, "Wrong size on FOakInventoryItemSaveGameData");
static_assert(offsetof(FOakInventoryItemSaveGameData, Item) == 0x000000, "Member 'FOakInventoryItemSaveGameData::Item' has a wrong offset!");
static_assert(offsetof(FOakInventoryItemSaveGameData, PickupOrderIndex) == 0x000080, "Member 'FOakInventoryItemSaveGameData::PickupOrderIndex' has a wrong offset!");
static_assert(offsetof(FOakInventoryItemSaveGameData, Flags) == 0x000084, "Member 'FOakInventoryItemSaveGameData::Flags' has a wrong offset!");
static_assert(offsetof(FOakInventoryItemSaveGameData, WeaponSkinPath) == 0x000088, "Member 'FOakInventoryItemSaveGameData::WeaponSkinPath' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryMenuCounts
// 0x0028 (0x0028 - 0x0000)
struct FOakInventoryMenuCounts final
{
public:
	int32                                         ItemCount;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemMax;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemCountColor;                                    // 0x0008(0x0010)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldenKeyCount;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErediumCount;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoneyCount;                                        // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VaultCoinCount;                                    // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakInventoryMenuCounts) == 0x000004, "Wrong alignment on FOakInventoryMenuCounts");
static_assert(sizeof(FOakInventoryMenuCounts) == 0x000028, "Wrong size on FOakInventoryMenuCounts");
static_assert(offsetof(FOakInventoryMenuCounts, ItemCount) == 0x000000, "Member 'FOakInventoryMenuCounts::ItemCount' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuCounts, ItemMax) == 0x000004, "Member 'FOakInventoryMenuCounts::ItemMax' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuCounts, ItemCountColor) == 0x000008, "Member 'FOakInventoryMenuCounts::ItemCountColor' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuCounts, GoldenKeyCount) == 0x000018, "Member 'FOakInventoryMenuCounts::GoldenKeyCount' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuCounts, ErediumCount) == 0x00001C, "Member 'FOakInventoryMenuCounts::ErediumCount' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuCounts, MoneyCount) == 0x000020, "Member 'FOakInventoryMenuCounts::MoneyCount' has a wrong offset!");
static_assert(offsetof(FOakInventoryMenuCounts, VaultCoinCount) == 0x000024, "Member 'FOakInventoryMenuCounts::VaultCoinCount' has a wrong offset!");

// ScriptStruct OakGame.ExtractedOakInventoryCombinationNameData
// 0x0018 (0x0018 - 0x0000)
struct FExtractedOakInventoryCombinationNameData final
{
public:
	class FName                                   FirstPartTag;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SecondPartTag;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryNamePartData*                 NamePart;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FExtractedOakInventoryCombinationNameData) == 0x000008, "Wrong alignment on FExtractedOakInventoryCombinationNameData");
static_assert(sizeof(FExtractedOakInventoryCombinationNameData) == 0x000018, "Wrong size on FExtractedOakInventoryCombinationNameData");
static_assert(offsetof(FExtractedOakInventoryCombinationNameData, FirstPartTag) == 0x000000, "Member 'FExtractedOakInventoryCombinationNameData::FirstPartTag' has a wrong offset!");
static_assert(offsetof(FExtractedOakInventoryCombinationNameData, SecondPartTag) == 0x000008, "Member 'FExtractedOakInventoryCombinationNameData::SecondPartTag' has a wrong offset!");
static_assert(offsetof(FExtractedOakInventoryCombinationNameData, NamePart) == 0x000010, "Member 'FExtractedOakInventoryCombinationNameData::NamePart' has a wrong offset!");

// ScriptStruct OakGame.OakInventoryNameData
// 0x0010 (0x0010 - 0x0000)
struct FOakInventoryNameData final
{
public:
	class UInventoryPartData*                     Part;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryNamePartData*                 NamePart;                                          // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakInventoryNameData) == 0x000008, "Wrong alignment on FOakInventoryNameData");
static_assert(sizeof(FOakInventoryNameData) == 0x000010, "Wrong size on FOakInventoryNameData");
static_assert(offsetof(FOakInventoryNameData, Part) == 0x000000, "Member 'FOakInventoryNameData::Part' has a wrong offset!");
static_assert(offsetof(FOakInventoryNameData, NamePart) == 0x000008, "Member 'FOakInventoryNameData::NamePart' has a wrong offset!");

// ScriptStruct OakGame.WheelRandomSwitchPack
// 0x0020 (0x0020 - 0x0000)
struct FWheelRandomSwitchPack final
{
public:
	TArray<class UWwiseSwitch*>                   WheelSwitches;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 WheelsToIgnoreForSwitches;                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWheelRandomSwitchPack) == 0x000008, "Wrong alignment on FWheelRandomSwitchPack");
static_assert(sizeof(FWheelRandomSwitchPack) == 0x000020, "Wrong size on FWheelRandomSwitchPack");
static_assert(offsetof(FWheelRandomSwitchPack, WheelSwitches) == 0x000000, "Member 'FWheelRandomSwitchPack::WheelSwitches' has a wrong offset!");
static_assert(offsetof(FWheelRandomSwitchPack, WheelsToIgnoreForSwitches) == 0x000010, "Member 'FWheelRandomSwitchPack::WheelsToIgnoreForSwitches' has a wrong offset!");

// ScriptStruct OakGame.OakJAKFeedbackData
// 0x0010 (0x0010 - 0x0000)
struct FOakJAKFeedbackData final
{
public:
	class UParticleSystem*                        ParticleEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            SoundEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakJAKFeedbackData) == 0x000008, "Wrong alignment on FOakJAKFeedbackData");
static_assert(sizeof(FOakJAKFeedbackData) == 0x000010, "Wrong size on FOakJAKFeedbackData");
static_assert(offsetof(FOakJAKFeedbackData, ParticleEffect) == 0x000000, "Member 'FOakJAKFeedbackData::ParticleEffect' has a wrong offset!");
static_assert(offsetof(FOakJAKFeedbackData, SoundEvent) == 0x000008, "Member 'FOakJAKFeedbackData::SoundEvent' has a wrong offset!");

// ScriptStruct OakGame.OakLightProjectileInitializationData
// 0x0018 (0x0158 - 0x0140)
struct FOakLightProjectileInitializationData final : public FLightProjectileInitializationData
{
public:
	float                                         BaseStatusEffectChance;                            // 0x0140(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseStatusEffectDamage;                            // 0x0144(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseStatusEffectDuration;                          // 0x0148(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusEffectChanceScalar;                          // 0x014C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusEffectDamageScalar;                          // 0x0150(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StatusEffectDurationScalar;                        // 0x0154(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakLightProjectileInitializationData) == 0x000008, "Wrong alignment on FOakLightProjectileInitializationData");
static_assert(sizeof(FOakLightProjectileInitializationData) == 0x000158, "Wrong size on FOakLightProjectileInitializationData");
static_assert(offsetof(FOakLightProjectileInitializationData, BaseStatusEffectChance) == 0x000140, "Member 'FOakLightProjectileInitializationData::BaseStatusEffectChance' has a wrong offset!");
static_assert(offsetof(FOakLightProjectileInitializationData, BaseStatusEffectDamage) == 0x000144, "Member 'FOakLightProjectileInitializationData::BaseStatusEffectDamage' has a wrong offset!");
static_assert(offsetof(FOakLightProjectileInitializationData, BaseStatusEffectDuration) == 0x000148, "Member 'FOakLightProjectileInitializationData::BaseStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(FOakLightProjectileInitializationData, StatusEffectChanceScalar) == 0x00014C, "Member 'FOakLightProjectileInitializationData::StatusEffectChanceScalar' has a wrong offset!");
static_assert(offsetof(FOakLightProjectileInitializationData, StatusEffectDamageScalar) == 0x000150, "Member 'FOakLightProjectileInitializationData::StatusEffectDamageScalar' has a wrong offset!");
static_assert(offsetof(FOakLightProjectileInitializationData, StatusEffectDurationScalar) == 0x000154, "Member 'FOakLightProjectileInitializationData::StatusEffectDurationScalar' has a wrong offset!");

// ScriptStruct OakGame.ManagedActorEntry
// 0x0018 (0x0018 - 0x0000)
struct FManagedActorEntry final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedActorEntry) == 0x000008, "Wrong alignment on FManagedActorEntry");
static_assert(sizeof(FManagedActorEntry) == 0x000018, "Wrong size on FManagedActorEntry");
static_assert(offsetof(FManagedActorEntry, Actors) == 0x000008, "Member 'FManagedActorEntry::Actors' has a wrong offset!");

// ScriptStruct OakGame.MayhemModifierDifficultyLevel
// 0x0070 (0x0070 - 0x0000)
struct FMayhemModifierDifficultyLevel final
{
public:
	int32                                         MayhemLevel;                                       // 0x0000(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakModifierSet                        StaticModifiers;                                   // 0x0008(0x0050)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomModifierCount;                               // 0x0058(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedOakModifierSet>        RandomModifierSets;                                // 0x0060(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayhemModifierDifficultyLevel) == 0x000008, "Wrong alignment on FMayhemModifierDifficultyLevel");
static_assert(sizeof(FMayhemModifierDifficultyLevel) == 0x000070, "Wrong size on FMayhemModifierDifficultyLevel");
static_assert(offsetof(FMayhemModifierDifficultyLevel, MayhemLevel) == 0x000000, "Member 'FMayhemModifierDifficultyLevel::MayhemLevel' has a wrong offset!");
static_assert(offsetof(FMayhemModifierDifficultyLevel, StaticModifiers) == 0x000008, "Member 'FMayhemModifierDifficultyLevel::StaticModifiers' has a wrong offset!");
static_assert(offsetof(FMayhemModifierDifficultyLevel, RandomModifierCount) == 0x000058, "Member 'FMayhemModifierDifficultyLevel::RandomModifierCount' has a wrong offset!");
static_assert(offsetof(FMayhemModifierDifficultyLevel, RandomModifierSets) == 0x000060, "Member 'FMayhemModifierDifficultyLevel::RandomModifierSets' has a wrong offset!");

// ScriptStruct OakGame.InstancedPlayerOwnerInfo
// 0x0018 (0x0018 - 0x0000)
struct FInstancedPlayerOwnerInfo final
{
public:
	TWeakObjectPtr<class AOakPlayerController>    InstancedPlayerOwner;                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyShowOnPlayerOwner;                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UZoneMapPOITypeData*                    PointOfInterestType;                               // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstancedPlayerOwnerInfo) == 0x000008, "Wrong alignment on FInstancedPlayerOwnerInfo");
static_assert(sizeof(FInstancedPlayerOwnerInfo) == 0x000018, "Wrong size on FInstancedPlayerOwnerInfo");
static_assert(offsetof(FInstancedPlayerOwnerInfo, InstancedPlayerOwner) == 0x000000, "Member 'FInstancedPlayerOwnerInfo::InstancedPlayerOwner' has a wrong offset!");
static_assert(offsetof(FInstancedPlayerOwnerInfo, bOnlyShowOnPlayerOwner) == 0x000008, "Member 'FInstancedPlayerOwnerInfo::bOnlyShowOnPlayerOwner' has a wrong offset!");
static_assert(offsetof(FInstancedPlayerOwnerInfo, PointOfInterestType) == 0x000010, "Member 'FInstancedPlayerOwnerInfo::PointOfInterestType' has a wrong offset!");

// ScriptStruct OakGame.LevelSyncCompletedMission
// 0x0010 (0x0010 - 0x0000)
struct FLevelSyncCompletedMission final
{
public:
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelSyncCompletedMission) == 0x000008, "Wrong alignment on FLevelSyncCompletedMission");
static_assert(sizeof(FLevelSyncCompletedMission) == 0x000010, "Wrong size on FLevelSyncCompletedMission");
static_assert(offsetof(FLevelSyncCompletedMission, MissionClass) == 0x000000, "Member 'FLevelSyncCompletedMission::MissionClass' has a wrong offset!");
static_assert(offsetof(FLevelSyncCompletedMission, Level) == 0x000008, "Member 'FLevelSyncCompletedMission::Level' has a wrong offset!");

// ScriptStruct OakGame.OakModifierData
// 0x0028 (0x0030 - 0x0008)
struct FOakModifierData final : public FTableRowBase
{
public:
	struct FDataTableRowHandle                    TargetResolver;                                    // 0x0008(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Effect;                                            // 0x0018(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakModifierData) == 0x000008, "Wrong alignment on FOakModifierData");
static_assert(sizeof(FOakModifierData) == 0x000030, "Wrong size on FOakModifierData");
static_assert(offsetof(FOakModifierData, TargetResolver) == 0x000008, "Member 'FOakModifierData::TargetResolver' has a wrong offset!");
static_assert(offsetof(FOakModifierData, Effect) == 0x000018, "Member 'FOakModifierData::Effect' has a wrong offset!");
static_assert(offsetof(FOakModifierData, MinValue) == 0x000028, "Member 'FOakModifierData::MinValue' has a wrong offset!");
static_assert(offsetof(FOakModifierData, MaxValue) == 0x00002C, "Member 'FOakModifierData::MaxValue' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankRewardCharacterSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FGuardianRankRewardCharacterSaveGameData final
{
public:
	int32                                         NumTokens;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGuardianRankRewardData> RewardDataPath;                                    // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGuardianRankRewardCharacterSaveGameData) == 0x000008, "Wrong alignment on FGuardianRankRewardCharacterSaveGameData");
static_assert(sizeof(FGuardianRankRewardCharacterSaveGameData) == 0x000030, "Wrong size on FGuardianRankRewardCharacterSaveGameData");
static_assert(offsetof(FGuardianRankRewardCharacterSaveGameData, NumTokens) == 0x000000, "Member 'FGuardianRankRewardCharacterSaveGameData::NumTokens' has a wrong offset!");
static_assert(offsetof(FGuardianRankRewardCharacterSaveGameData, bEnabled) == 0x000004, "Member 'FGuardianRankRewardCharacterSaveGameData::bEnabled' has a wrong offset!");
static_assert(offsetof(FGuardianRankRewardCharacterSaveGameData, RewardDataPath) == 0x000008, "Member 'FGuardianRankRewardCharacterSaveGameData::RewardDataPath' has a wrong offset!");

// ScriptStruct OakGame.OakModifierSetWithMutexTags
// 0x0060 (0x0060 - 0x0000)
struct FOakModifierSetWithMutexTags final
{
public:
	struct FOakModifierSet                        ModifierSet;                                       // 0x0000(0x0050)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MutexTags;                                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakModifierSetWithMutexTags) == 0x000008, "Wrong alignment on FOakModifierSetWithMutexTags");
static_assert(sizeof(FOakModifierSetWithMutexTags) == 0x000060, "Wrong size on FOakModifierSetWithMutexTags");
static_assert(offsetof(FOakModifierSetWithMutexTags, ModifierSet) == 0x000000, "Member 'FOakModifierSetWithMutexTags::ModifierSet' has a wrong offset!");
static_assert(offsetof(FOakModifierSetWithMutexTags, MutexTags) == 0x000050, "Member 'FOakModifierSetWithMutexTags::MutexTags' has a wrong offset!");

// ScriptStruct OakGame.OakModifierStatusEffectData
// 0x0018 (0x0020 - 0x0008)
struct FOakModifierStatusEffectData final : public FTableRowBase
{
public:
	class UGbxAttributeData*                      AttributeData;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValue;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakModifierStatusEffectData) == 0x000008, "Wrong alignment on FOakModifierStatusEffectData");
static_assert(sizeof(FOakModifierStatusEffectData) == 0x000020, "Wrong size on FOakModifierStatusEffectData");
static_assert(offsetof(FOakModifierStatusEffectData, AttributeData) == 0x000008, "Member 'FOakModifierStatusEffectData::AttributeData' has a wrong offset!");
static_assert(offsetof(FOakModifierStatusEffectData, ModifierType) == 0x000010, "Member 'FOakModifierStatusEffectData::ModifierType' has a wrong offset!");
static_assert(offsetof(FOakModifierStatusEffectData, MaxValue) == 0x000014, "Member 'FOakModifierStatusEffectData::MaxValue' has a wrong offset!");
static_assert(offsetof(FOakModifierStatusEffectData, MinValue) == 0x000018, "Member 'FOakModifierStatusEffectData::MinValue' has a wrong offset!");

// ScriptStruct OakGame.OakModifierTargetResolverData
// 0x0018 (0x0020 - 0x0008)
struct FOakModifierTargetResolverData final : public FTableRowBase
{
public:
	TArray<class UGbxAbilityEffectTargetResolutionData*> TargetResolvers;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGbxAbilityEffectTargetResolutionData*  TargetResolver;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakModifierTargetResolverData) == 0x000008, "Wrong alignment on FOakModifierTargetResolverData");
static_assert(sizeof(FOakModifierTargetResolverData) == 0x000020, "Wrong size on FOakModifierTargetResolverData");
static_assert(offsetof(FOakModifierTargetResolverData, TargetResolvers) == 0x000008, "Member 'FOakModifierTargetResolverData::TargetResolvers' has a wrong offset!");
static_assert(offsetof(FOakModifierTargetResolverData, TargetResolver) == 0x000018, "Member 'FOakModifierTargetResolverData::TargetResolver' has a wrong offset!");

// ScriptStruct OakGame.MusicLayerInfo
// 0x0020 (0x0020 - 0x0000)
struct FMusicLayerInfo final
{
public:
	class UWwiseState*                            NoneState;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseState*                            OnState;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseState*                            OffState;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseState*                            ExitCombatState;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicLayerInfo) == 0x000008, "Wrong alignment on FMusicLayerInfo");
static_assert(sizeof(FMusicLayerInfo) == 0x000020, "Wrong size on FMusicLayerInfo");
static_assert(offsetof(FMusicLayerInfo, NoneState) == 0x000000, "Member 'FMusicLayerInfo::NoneState' has a wrong offset!");
static_assert(offsetof(FMusicLayerInfo, OnState) == 0x000008, "Member 'FMusicLayerInfo::OnState' has a wrong offset!");
static_assert(offsetof(FMusicLayerInfo, OffState) == 0x000010, "Member 'FMusicLayerInfo::OffState' has a wrong offset!");
static_assert(offsetof(FMusicLayerInfo, ExitCombatState) == 0x000018, "Member 'FMusicLayerInfo::ExitCombatState' has a wrong offset!");

// ScriptStruct OakGame.ScriptedVehicleMove
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FScriptedVehicleMove final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScriptedVehicleMove) == 0x000004, "Wrong alignment on FScriptedVehicleMove");
static_assert(sizeof(FScriptedVehicleMove) == 0x000024, "Wrong size on FScriptedVehicleMove");

// ScriptStruct OakGame.SpeedOverride
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FSpeedOverride final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpeedOverride) == 0x000008, "Wrong alignment on FSpeedOverride");
static_assert(sizeof(FSpeedOverride) == 0x000060, "Wrong size on FSpeedOverride");

// ScriptStruct OakGame.RubberbandSpeedData
// 0x0040 (0x0040 - 0x0000)
struct FRubberbandSpeedData final
{
public:
	TWeakObjectPtr<class AActor>                  RubberBandTarget;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceSpeed;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceSpeed;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBehindOnly;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SplineReference;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineDistanceOffset;                              // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSpline;                                        // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       CachedSplineComponent;                             // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRubberbandSpeedData) == 0x000008, "Wrong alignment on FRubberbandSpeedData");
static_assert(sizeof(FRubberbandSpeedData) == 0x000040, "Wrong size on FRubberbandSpeedData");
static_assert(offsetof(FRubberbandSpeedData, RubberBandTarget) == 0x000000, "Member 'FRubberbandSpeedData::RubberBandTarget' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, MinDistance) == 0x000008, "Member 'FRubberbandSpeedData::MinDistance' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, MaxDistance) == 0x00000C, "Member 'FRubberbandSpeedData::MaxDistance' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, MinDistanceSpeed) == 0x000010, "Member 'FRubberbandSpeedData::MinDistanceSpeed' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, MaxDistanceSpeed) == 0x000014, "Member 'FRubberbandSpeedData::MaxDistanceSpeed' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, bBehindOnly) == 0x000018, "Member 'FRubberbandSpeedData::bBehindOnly' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, SplineReference) == 0x000020, "Member 'FRubberbandSpeedData::SplineReference' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, SplineDistanceOffset) == 0x000028, "Member 'FRubberbandSpeedData::SplineDistanceOffset' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, bUseSpline) == 0x00002C, "Member 'FRubberbandSpeedData::bUseSpline' has a wrong offset!");
static_assert(offsetof(FRubberbandSpeedData, CachedSplineComponent) == 0x000030, "Member 'FRubberbandSpeedData::CachedSplineComponent' has a wrong offset!");

// ScriptStruct OakGame.OakOnlineLobbyPlayerInfo
// 0x0080 (0x0080 - 0x0000)
struct FOakOnlineLobbyPlayerInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EOakOnlineLobbyPlayerPlateState               PlateState;                                        // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLobbyLead;                                      // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MissionDisplayName;                                // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MapDisplayName;                                    // 0x0048(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   PlayerClassDisplayName;                            // 0x0060(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakOnlineLobbyConnectivityState              ConnectivityState;                                 // 0x007C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakOnlineLobbyTalkingState                   TalkingState;                                      // 0x007D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakOnlineLobbyPlayerInfo) == 0x000008, "Wrong alignment on FOakOnlineLobbyPlayerInfo");
static_assert(sizeof(FOakOnlineLobbyPlayerInfo) == 0x000080, "Wrong size on FOakOnlineLobbyPlayerInfo");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, PlateState) == 0x000010, "Member 'FOakOnlineLobbyPlayerInfo::PlateState' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, bIsLobbyLead) == 0x000011, "Member 'FOakOnlineLobbyPlayerInfo::bIsLobbyLead' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, DisplayName) == 0x000018, "Member 'FOakOnlineLobbyPlayerInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, MissionDisplayName) == 0x000030, "Member 'FOakOnlineLobbyPlayerInfo::MissionDisplayName' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, MapDisplayName) == 0x000048, "Member 'FOakOnlineLobbyPlayerInfo::MapDisplayName' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, PlayerClassDisplayName) == 0x000060, "Member 'FOakOnlineLobbyPlayerInfo::PlayerClassDisplayName' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, CharacterLevel) == 0x000078, "Member 'FOakOnlineLobbyPlayerInfo::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, ConnectivityState) == 0x00007C, "Member 'FOakOnlineLobbyPlayerInfo::ConnectivityState' has a wrong offset!");
static_assert(offsetof(FOakOnlineLobbyPlayerInfo, TalkingState) == 0x00007D, "Member 'FOakOnlineLobbyPlayerInfo::TalkingState' has a wrong offset!");

// ScriptStruct OakGame.OakPassiveAbilityHUDIconData
// 0x0020 (0x0020 - 0x0000)
struct FOakPassiveAbilityHUDIconData final
{
public:
	EOakPassiveAbilityHUDIconActivationType       ActivationType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffectData*                      CustomStatusEffectData;                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakAbilityTimerData*                   AbilityTimerData;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakPlayerAbilityHUDItemData*           HUDItemData;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPassiveAbilityHUDIconData) == 0x000008, "Wrong alignment on FOakPassiveAbilityHUDIconData");
static_assert(sizeof(FOakPassiveAbilityHUDIconData) == 0x000020, "Wrong size on FOakPassiveAbilityHUDIconData");
static_assert(offsetof(FOakPassiveAbilityHUDIconData, ActivationType) == 0x000000, "Member 'FOakPassiveAbilityHUDIconData::ActivationType' has a wrong offset!");
static_assert(offsetof(FOakPassiveAbilityHUDIconData, CustomStatusEffectData) == 0x000008, "Member 'FOakPassiveAbilityHUDIconData::CustomStatusEffectData' has a wrong offset!");
static_assert(offsetof(FOakPassiveAbilityHUDIconData, AbilityTimerData) == 0x000010, "Member 'FOakPassiveAbilityHUDIconData::AbilityTimerData' has a wrong offset!");
static_assert(offsetof(FOakPassiveAbilityHUDIconData, HUDItemData) == 0x000018, "Member 'FOakPassiveAbilityHUDIconData::HUDItemData' has a wrong offset!");

// ScriptStruct OakGame.BonusAttributeModifierUpgrade
// 0x0040 (0x0040 - 0x0000)
struct FBonusAttributeModifierUpgrade final
{
public:
	int32                                         GradeToApplyAt;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           BonusUpgrade;                                      // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonusAttributeModifierUpgrade) == 0x000008, "Wrong alignment on FBonusAttributeModifierUpgrade");
static_assert(sizeof(FBonusAttributeModifierUpgrade) == 0x000040, "Wrong size on FBonusAttributeModifierUpgrade");
static_assert(offsetof(FBonusAttributeModifierUpgrade, GradeToApplyAt) == 0x000000, "Member 'FBonusAttributeModifierUpgrade::GradeToApplyAt' has a wrong offset!");
static_assert(offsetof(FBonusAttributeModifierUpgrade, BonusUpgrade) == 0x000008, "Member 'FBonusAttributeModifierUpgrade::BonusUpgrade' has a wrong offset!");

// ScriptStruct OakGame.OakPhaseWebSphereLinkedTargetItem
// 0x0054 (0x0060 - 0x000C)
struct FOakPhaseWebSphereLinkedTargetItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakCharacter*                          LinkedTarget;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOakPhaseWebSphereBeamData             BeamData;                                          // 0x0018(0x0030)(RepSkip, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               BeamComponent;                                     // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakPhaseWebSphereLinkedTargetItem) == 0x000008, "Wrong alignment on FOakPhaseWebSphereLinkedTargetItem");
static_assert(sizeof(FOakPhaseWebSphereLinkedTargetItem) == 0x000060, "Wrong size on FOakPhaseWebSphereLinkedTargetItem");
static_assert(offsetof(FOakPhaseWebSphereLinkedTargetItem, LinkedTarget) == 0x000010, "Member 'FOakPhaseWebSphereLinkedTargetItem::LinkedTarget' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereLinkedTargetItem, BeamData) == 0x000018, "Member 'FOakPhaseWebSphereLinkedTargetItem::BeamData' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereLinkedTargetItem, BeamComponent) == 0x000048, "Member 'FOakPhaseWebSphereLinkedTargetItem::BeamComponent' has a wrong offset!");

// ScriptStruct OakGame.OakPhaseWebSphereLinkedTargetList
// 0x0018 (0x00C8 - 0x00B0)
struct FOakPhaseWebSphereLinkedTargetList final : public FFastArraySerializer
{
public:
	class AOakPhaseWebSphere*                     Owner;                                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakPhaseWebSphereLinkedTargetItem> Items;                                             // 0x00B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPhaseWebSphereLinkedTargetList) == 0x000008, "Wrong alignment on FOakPhaseWebSphereLinkedTargetList");
static_assert(sizeof(FOakPhaseWebSphereLinkedTargetList) == 0x0000C8, "Wrong size on FOakPhaseWebSphereLinkedTargetList");
static_assert(offsetof(FOakPhaseWebSphereLinkedTargetList, Owner) == 0x0000B0, "Member 'FOakPhaseWebSphereLinkedTargetList::Owner' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphereLinkedTargetList, Items) == 0x0000B8, "Member 'FOakPhaseWebSphereLinkedTargetList::Items' has a wrong offset!");

// ScriptStruct OakGame.OakPhaseWebSphere_SharedDamageData
// 0x0018 (0x0018 - 0x0000)
struct FOakPhaseWebSphere_SharedDamageData final
{
public:
	float                                         SharedDamage;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPhaseWebSphere_SharedDamageData) == 0x000008, "Wrong alignment on FOakPhaseWebSphere_SharedDamageData");
static_assert(sizeof(FOakPhaseWebSphere_SharedDamageData) == 0x000018, "Wrong size on FOakPhaseWebSphere_SharedDamageData");
static_assert(offsetof(FOakPhaseWebSphere_SharedDamageData, SharedDamage) == 0x000000, "Member 'FOakPhaseWebSphere_SharedDamageData::SharedDamage' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphere_SharedDamageData, DamageType) == 0x000008, "Member 'FOakPhaseWebSphere_SharedDamageData::DamageType' has a wrong offset!");
static_assert(offsetof(FOakPhaseWebSphere_SharedDamageData, DamageSource) == 0x000010, "Member 'FOakPhaseWebSphere_SharedDamageData::DamageSource' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentSlotConfigurationList
// 0x0018 (0x0018 - 0x0000)
struct FOakActionAbilityAugmentSlotConfigurationList final
{
public:
	class UOakPlayerAbilityManagerComponent*      Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakActionAbilityAugmentSlotConfiguration> SlotConfigurations;                                // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentSlotConfigurationList) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentSlotConfigurationList");
static_assert(sizeof(FOakActionAbilityAugmentSlotConfigurationList) == 0x000018, "Wrong size on FOakActionAbilityAugmentSlotConfigurationList");
static_assert(offsetof(FOakActionAbilityAugmentSlotConfigurationList, Owner) == 0x000000, "Member 'FOakActionAbilityAugmentSlotConfigurationList::Owner' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSlotConfigurationList, SlotConfigurations) == 0x000008, "Member 'FOakActionAbilityAugmentSlotConfigurationList::SlotConfigurations' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilityAugmentSlotList
// 0x0018 (0x00C8 - 0x00B0)
struct FOakActionAbilityAugmentSlotList final : public FFastArraySerializer
{
public:
	class UOakPlayerAbilityManagerComponent*      Owner;                                             // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakActionAbilityAugmentSlot>   Items;                                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakActionAbilityAugmentSlotList) == 0x000008, "Wrong alignment on FOakActionAbilityAugmentSlotList");
static_assert(sizeof(FOakActionAbilityAugmentSlotList) == 0x0000C8, "Wrong size on FOakActionAbilityAugmentSlotList");
static_assert(offsetof(FOakActionAbilityAugmentSlotList, Owner) == 0x0000B0, "Member 'FOakActionAbilityAugmentSlotList::Owner' has a wrong offset!");
static_assert(offsetof(FOakActionAbilityAugmentSlotList, Items) == 0x0000B8, "Member 'FOakActionAbilityAugmentSlotList::Items' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilityHUDItemList
// 0x0018 (0x00C8 - 0x00B0)
struct FOakPlayerAbilityHUDItemList final : public FFastArraySerializer
{
public:
	class UOakPlayerAbilityManagerComponent*      Owner;                                             // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOakPlayerAbilityHUDItem>       Items;                                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPlayerAbilityHUDItemList) == 0x000008, "Wrong alignment on FOakPlayerAbilityHUDItemList");
static_assert(sizeof(FOakPlayerAbilityHUDItemList) == 0x0000C8, "Wrong size on FOakPlayerAbilityHUDItemList");
static_assert(offsetof(FOakPlayerAbilityHUDItemList, Owner) == 0x0000B0, "Member 'FOakPlayerAbilityHUDItemList::Owner' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityHUDItemList, Items) == 0x0000B8, "Member 'FOakPlayerAbilityHUDItemList::Items' has a wrong offset!");

// ScriptStruct OakGame.OakAbilitySlot
// 0x0014 (0x0014 - 0x0000)
struct FOakAbilitySlot
{
public:
	int32                                         LevelUnlock;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SlotID;                                            // 0x0004(0x0010)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakAbilitySlot) == 0x000004, "Wrong alignment on FOakAbilitySlot");
static_assert(sizeof(FOakAbilitySlot) == 0x000014, "Wrong size on FOakAbilitySlot");
static_assert(offsetof(FOakAbilitySlot, LevelUnlock) == 0x000000, "Member 'FOakAbilitySlot::LevelUnlock' has a wrong offset!");
static_assert(offsetof(FOakAbilitySlot, SlotID) == 0x000004, "Member 'FOakAbilitySlot::SlotID' has a wrong offset!");

// ScriptStruct OakGame.OakActionAbilitySlot
// 0x0014 (0x0028 - 0x0014)
struct FOakActionAbilitySlot final : public FOakAbilitySlot
{
public:
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOakAbilitySlot>                AugmentSlots;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakActionAbilitySlot) == 0x000008, "Wrong alignment on FOakActionAbilitySlot");
static_assert(sizeof(FOakActionAbilitySlot) == 0x000028, "Wrong size on FOakActionAbilitySlot");
static_assert(offsetof(FOakActionAbilitySlot, AugmentSlots) == 0x000018, "Member 'FOakActionAbilitySlot::AugmentSlots' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerAbilityAllyQueryResult
// 0x0020 (0x0020 - 0x0000)
struct FOakPlayerAbilityAllyQueryResult final
{
public:
	TArray<class AOakCharacter_Player*>           Allies;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Companions;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPlayerAbilityAllyQueryResult) == 0x000008, "Wrong alignment on FOakPlayerAbilityAllyQueryResult");
static_assert(sizeof(FOakPlayerAbilityAllyQueryResult) == 0x000020, "Wrong size on FOakPlayerAbilityAllyQueryResult");
static_assert(offsetof(FOakPlayerAbilityAllyQueryResult, Allies) == 0x000000, "Member 'FOakPlayerAbilityAllyQueryResult::Allies' has a wrong offset!");
static_assert(offsetof(FOakPlayerAbilityAllyQueryResult, Companions) == 0x000010, "Member 'FOakPlayerAbilityAllyQueryResult::Companions' has a wrong offset!");

// ScriptStruct OakGame.AbilityTreeItem
// 0x0030 (0x0030 - 0x0000)
struct FAbilityTreeItem final
{
public:
	class UOakPlayerAbilityTree*                  Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakPlayerAbilityTreeItemData*          ItemData;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityTreeItem) == 0x000008, "Wrong alignment on FAbilityTreeItem");
static_assert(sizeof(FAbilityTreeItem) == 0x000030, "Wrong size on FAbilityTreeItem");
static_assert(offsetof(FAbilityTreeItem, Owner) == 0x000000, "Member 'FAbilityTreeItem::Owner' has a wrong offset!");
static_assert(offsetof(FAbilityTreeItem, ItemData) == 0x000008, "Member 'FAbilityTreeItem::ItemData' has a wrong offset!");

// ScriptStruct OakGame.AbilityTreeBranch
// 0x0028 (0x0028 - 0x0000)
struct FAbilityTreeBranch final
{
public:
	class UOakPlayerAbilityTree*                  Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakPlayerAbilityTreeBranchData*        BranchData;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityTreeBranch) == 0x000008, "Wrong alignment on FAbilityTreeBranch");
static_assert(sizeof(FAbilityTreeBranch) == 0x000028, "Wrong size on FAbilityTreeBranch");
static_assert(offsetof(FAbilityTreeBranch, Owner) == 0x000000, "Member 'FAbilityTreeBranch::Owner' has a wrong offset!");
static_assert(offsetof(FAbilityTreeBranch, BranchData) == 0x000008, "Member 'FAbilityTreeBranch::BranchData' has a wrong offset!");

// ScriptStruct OakGame.ViewLeadingInfo
// 0x0068 (0x0068 - 0x0000)
struct FViewLeadingInfo final
{
public:
	struct FViewLeadingTranslationInfo            Translation;                                       // 0x0000(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FViewLeadingRotationInfo               Rotation;                                          // 0x002C(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewLeadingInfo) == 0x000004, "Wrong alignment on FViewLeadingInfo");
static_assert(sizeof(FViewLeadingInfo) == 0x000068, "Wrong size on FViewLeadingInfo");
static_assert(offsetof(FViewLeadingInfo, Translation) == 0x000000, "Member 'FViewLeadingInfo::Translation' has a wrong offset!");
static_assert(offsetof(FViewLeadingInfo, Rotation) == 0x00002C, "Member 'FViewLeadingInfo::Rotation' has a wrong offset!");

// ScriptStruct OakGame.AutoAimDebugData
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x04) FAutoAimDebugData final
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoAimDebugData) == 0x000004, "Wrong alignment on FAutoAimDebugData");
static_assert(sizeof(FAutoAimDebugData) == 0x000088, "Wrong size on FAutoAimDebugData");

// ScriptStruct OakGame.MissionDeliveryData
// 0x0018 (0x0018 - 0x0000)
struct FMissionDeliveryData final
{
public:
	TArray<TSubclassOf<class UMission>>           Missions;                                          // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AActor*                                 MissionGiver;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionDeliveryData) == 0x000008, "Wrong alignment on FMissionDeliveryData");
static_assert(sizeof(FMissionDeliveryData) == 0x000018, "Wrong size on FMissionDeliveryData");
static_assert(offsetof(FMissionDeliveryData, Missions) == 0x000000, "Member 'FMissionDeliveryData::Missions' has a wrong offset!");
static_assert(offsetof(FMissionDeliveryData, MissionGiver) == 0x000010, "Member 'FMissionDeliveryData::MissionGiver' has a wrong offset!");

// ScriptStruct OakGame.OakFriendEncounterData
// 0x0010 (0x0010 - 0x0000)
struct FOakFriendEncounterData final
{
public:
	uint32                                        NumEncounters;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         TimeLastEncounter;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakFriendEncounterData) == 0x000008, "Wrong alignment on FOakFriendEncounterData");
static_assert(sizeof(FOakFriendEncounterData) == 0x000010, "Wrong size on FOakFriendEncounterData");
static_assert(offsetof(FOakFriendEncounterData, NumEncounters) == 0x000000, "Member 'FOakFriendEncounterData::NumEncounters' has a wrong offset!");
static_assert(offsetof(FOakFriendEncounterData, TimeLastEncounter) == 0x000008, "Member 'FOakFriendEncounterData::TimeLastEncounter' has a wrong offset!");

// ScriptStruct OakGame.TriggeredDamagePresentation
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FTriggeredDamagePresentation final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriggeredDamagePresentation) == 0x000004, "Wrong alignment on FTriggeredDamagePresentation");
static_assert(sizeof(FTriggeredDamagePresentation) == 0x000028, "Wrong size on FTriggeredDamagePresentation");

// ScriptStruct OakGame.SpawnInventoryLootRequest
// 0x0038 (0x0038 - 0x0000)
struct FSpawnInventoryLootRequest
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSelectedInventoryInfo>         SelectedInventoryInfos;                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ELootInstancingPolicy                         InstancingPolicy;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakPlayerController*                   PlayerToInstanceFor;                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnInventoryLootRequest) == 0x000008, "Wrong alignment on FSpawnInventoryLootRequest");
static_assert(sizeof(FSpawnInventoryLootRequest) == 0x000038, "Wrong size on FSpawnInventoryLootRequest");
static_assert(offsetof(FSpawnInventoryLootRequest, ContextActor) == 0x000000, "Member 'FSpawnInventoryLootRequest::ContextActor' has a wrong offset!");
static_assert(offsetof(FSpawnInventoryLootRequest, SelectedInventoryInfos) == 0x000008, "Member 'FSpawnInventoryLootRequest::SelectedInventoryInfos' has a wrong offset!");
static_assert(offsetof(FSpawnInventoryLootRequest, InstancingPolicy) == 0x000018, "Member 'FSpawnInventoryLootRequest::InstancingPolicy' has a wrong offset!");
static_assert(offsetof(FSpawnInventoryLootRequest, PlayerToInstanceFor) == 0x000020, "Member 'FSpawnInventoryLootRequest::PlayerToInstanceFor' has a wrong offset!");

// ScriptStruct OakGame.SpawnInventoryLootRequestEntry
// 0x0008 (0x0040 - 0x0038)
struct FSpawnInventoryLootRequestEntry final : public FSpawnInventoryLootRequest
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnInventoryLootRequestEntry) == 0x000008, "Wrong alignment on FSpawnInventoryLootRequestEntry");
static_assert(sizeof(FSpawnInventoryLootRequestEntry) == 0x000040, "Wrong size on FSpawnInventoryLootRequestEntry");

// ScriptStruct OakGame.RecentlyResistedAttackData
// 0x0010 (0x0010 - 0x0000)
struct FRecentlyResistedAttackData final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecentlyResistedAttackData) == 0x000008, "Wrong alignment on FRecentlyResistedAttackData");
static_assert(sizeof(FRecentlyResistedAttackData) == 0x000010, "Wrong size on FRecentlyResistedAttackData");
static_assert(offsetof(FRecentlyResistedAttackData, DamagedActor) == 0x000000, "Member 'FRecentlyResistedAttackData::DamagedActor' has a wrong offset!");

// ScriptStruct OakGame.PlaythroughActiveFastTravelSaveData
// 0x0010 (0x0010 - 0x0000)
struct FPlaythroughActiveFastTravelSaveData final
{
public:
	TArray<struct FActiveFastTravelSaveData>      ActiveTravelStations;                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlaythroughActiveFastTravelSaveData) == 0x000008, "Wrong alignment on FPlaythroughActiveFastTravelSaveData");
static_assert(sizeof(FPlaythroughActiveFastTravelSaveData) == 0x000010, "Wrong size on FPlaythroughActiveFastTravelSaveData");
static_assert(offsetof(FPlaythroughActiveFastTravelSaveData, ActiveTravelStations) == 0x000000, "Member 'FPlaythroughActiveFastTravelSaveData::ActiveTravelStations' has a wrong offset!");

// ScriptStruct OakGame.LevelPersistence_Level_SaveGameData
// 0x0018 (0x0018 - 0x0000)
struct FLevelPersistence_Level_SaveGameData final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelPersistence_Actor_SaveGameData> SavedActors;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelPersistence_Level_SaveGameData) == 0x000008, "Wrong alignment on FLevelPersistence_Level_SaveGameData");
static_assert(sizeof(FLevelPersistence_Level_SaveGameData) == 0x000018, "Wrong size on FLevelPersistence_Level_SaveGameData");
static_assert(offsetof(FLevelPersistence_Level_SaveGameData, LevelName) == 0x000000, "Member 'FLevelPersistence_Level_SaveGameData::LevelName' has a wrong offset!");
static_assert(offsetof(FLevelPersistence_Level_SaveGameData, SavedActors) == 0x000008, "Member 'FLevelPersistence_Level_SaveGameData::SavedActors' has a wrong offset!");

// ScriptStruct OakGame.UITrackingSaveGameData
// 0x0028 (0x0028 - 0x0000)
struct FUITrackingSaveGameData final
{
public:
	bool                                          bHasSeenSkillMenuUnlock;                           // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenGuardianRankMenuUnlock;                    // 0x0001(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenEchoBoot_AmmoBar;                          // 0x0002(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenEchoBoot_ShieldBar;                        // 0x0003(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSeenEchoBoot_Grenades;                         // 0x0004(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestTHVMBreadcrumbSeen;                         // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UInventorySlotData>> InventorySlotUnlocksSeen;                          // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SavedSpinOffset;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUITrackingSaveGameData) == 0x000008, "Wrong alignment on FUITrackingSaveGameData");
static_assert(sizeof(FUITrackingSaveGameData) == 0x000028, "Wrong size on FUITrackingSaveGameData");
static_assert(offsetof(FUITrackingSaveGameData, bHasSeenSkillMenuUnlock) == 0x000000, "Member 'FUITrackingSaveGameData::bHasSeenSkillMenuUnlock' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, bHasSeenGuardianRankMenuUnlock) == 0x000001, "Member 'FUITrackingSaveGameData::bHasSeenGuardianRankMenuUnlock' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, bHasSeenEchoBoot_AmmoBar) == 0x000002, "Member 'FUITrackingSaveGameData::bHasSeenEchoBoot_AmmoBar' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, bHasSeenEchoBoot_ShieldBar) == 0x000003, "Member 'FUITrackingSaveGameData::bHasSeenEchoBoot_ShieldBar' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, bHasSeenEchoBoot_Grenades) == 0x000004, "Member 'FUITrackingSaveGameData::bHasSeenEchoBoot_Grenades' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, HighestTHVMBreadcrumbSeen) == 0x000008, "Member 'FUITrackingSaveGameData::HighestTHVMBreadcrumbSeen' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, InventorySlotUnlocksSeen) == 0x000010, "Member 'FUITrackingSaveGameData::InventorySlotUnlocksSeen' has a wrong offset!");
static_assert(offsetof(FUITrackingSaveGameData, SavedSpinOffset) == 0x000020, "Member 'FUITrackingSaveGameData::SavedSpinOffset' has a wrong offset!");

// ScriptStruct OakGame.EchoLogSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FEchoLogSaveGameData final
{
public:
	bool                                          bHasBeenSeenInLog;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UEchoLogData>            EchoLogPath;                                       // 0x0008(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FEchoLogSaveGameData) == 0x000008, "Wrong alignment on FEchoLogSaveGameData");
static_assert(sizeof(FEchoLogSaveGameData) == 0x000030, "Wrong size on FEchoLogSaveGameData");
static_assert(offsetof(FEchoLogSaveGameData, bHasBeenSeenInLog) == 0x000000, "Member 'FEchoLogSaveGameData::bHasBeenSeenInLog' has a wrong offset!");
static_assert(offsetof(FEchoLogSaveGameData, EchoLogPath) == 0x000008, "Member 'FEchoLogSaveGameData::EchoLogPath' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerCharacterAugmentSaveGameData
// 0x0050 (0x0050 - 0x0000)
struct FOakPlayerCharacterAugmentSaveGameData final
{
public:
	TSoftObjectPtr<class UPlayerCharacterComponentSlotData> SlotAssetPath;                                     // 0x0000(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UPlayerCharacterComponentAugmentData> AugmentAssetPath;                                  // 0x0028(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOakPlayerCharacterAugmentSaveGameData) == 0x000008, "Wrong alignment on FOakPlayerCharacterAugmentSaveGameData");
static_assert(sizeof(FOakPlayerCharacterAugmentSaveGameData) == 0x000050, "Wrong size on FOakPlayerCharacterAugmentSaveGameData");
static_assert(offsetof(FOakPlayerCharacterAugmentSaveGameData, SlotAssetPath) == 0x000000, "Member 'FOakPlayerCharacterAugmentSaveGameData::SlotAssetPath' has a wrong offset!");
static_assert(offsetof(FOakPlayerCharacterAugmentSaveGameData, AugmentAssetPath) == 0x000028, "Member 'FOakPlayerCharacterAugmentSaveGameData::AugmentAssetPath' has a wrong offset!");

// ScriptStruct OakGame.OakPlayerCharacterSlotSaveGameData
// 0x0010 (0x0010 - 0x0000)
struct FOakPlayerCharacterSlotSaveGameData final
{
public:
	TArray<struct FOakPlayerCharacterAugmentSaveGameData> AugmentSlotList;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakPlayerCharacterSlotSaveGameData) == 0x000008, "Wrong alignment on FOakPlayerCharacterSlotSaveGameData");
static_assert(sizeof(FOakPlayerCharacterSlotSaveGameData) == 0x000010, "Wrong size on FOakPlayerCharacterSlotSaveGameData");
static_assert(offsetof(FOakPlayerCharacterSlotSaveGameData, AugmentSlotList) == 0x000000, "Member 'FOakPlayerCharacterSlotSaveGameData::AugmentSlotList' has a wrong offset!");

// ScriptStruct OakGame.PlayerClassSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FPlayerClassSaveGameData final
{
public:
	TSoftObjectPtr<class UPlayerClassIdentifier>  PlayerClassPath;                                   // 0x0000(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        DlcPackageId;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerClassSaveGameData) == 0x000008, "Wrong alignment on FPlayerClassSaveGameData");
static_assert(sizeof(FPlayerClassSaveGameData) == 0x000030, "Wrong size on FPlayerClassSaveGameData");
static_assert(offsetof(FPlayerClassSaveGameData, PlayerClassPath) == 0x000000, "Member 'FPlayerClassSaveGameData::PlayerClassPath' has a wrong offset!");
static_assert(offsetof(FPlayerClassSaveGameData, DlcPackageId) == 0x000028, "Member 'FPlayerClassSaveGameData::DlcPackageId' has a wrong offset!");

// ScriptStruct OakGame.SpawnPointEffect
// 0x0010 (0x0010 - 0x0000)
struct FSpawnPointEffect final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOakAction_CoordinatedEffect> SpecialEffect;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnPointEffect) == 0x000008, "Wrong alignment on FSpawnPointEffect");
static_assert(sizeof(FSpawnPointEffect) == 0x000010, "Wrong size on FSpawnPointEffect");
static_assert(offsetof(FSpawnPointEffect, Condition) == 0x000000, "Member 'FSpawnPointEffect::Condition' has a wrong offset!");
static_assert(offsetof(FSpawnPointEffect, SpecialEffect) == 0x000008, "Member 'FSpawnPointEffect::SpecialEffect' has a wrong offset!");

// ScriptStruct OakGame.OakStatusEffectPresentation_Audio
// 0x0018 (0x0018 - 0x0000)
struct FOakStatusEffectPresentation_Audio final
{
public:
	bool                                          bUsesAudioEvents;                                  // 0x0000(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            StartEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StopEvent;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakStatusEffectPresentation_Audio) == 0x000008, "Wrong alignment on FOakStatusEffectPresentation_Audio");
static_assert(sizeof(FOakStatusEffectPresentation_Audio) == 0x000018, "Wrong size on FOakStatusEffectPresentation_Audio");
static_assert(offsetof(FOakStatusEffectPresentation_Audio, bUsesAudioEvents) == 0x000000, "Member 'FOakStatusEffectPresentation_Audio::bUsesAudioEvents' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Audio, StartEvent) == 0x000008, "Member 'FOakStatusEffectPresentation_Audio::StartEvent' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Audio, StopEvent) == 0x000010, "Member 'FOakStatusEffectPresentation_Audio::StopEvent' has a wrong offset!");

// ScriptStruct OakGame.OakStatusEffectPresentation_Material
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FOakStatusEffectPresentation_Material final
{
public:
	bool                                          bUsesMaterialParameter;                            // 0x0000(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialParameterName;                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionDuration;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x14];                                      // 0x0014(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakStatusEffectPresentation_Material) == 0x000008, "Wrong alignment on FOakStatusEffectPresentation_Material");
static_assert(sizeof(FOakStatusEffectPresentation_Material) == 0x000028, "Wrong size on FOakStatusEffectPresentation_Material");
static_assert(offsetof(FOakStatusEffectPresentation_Material, bUsesMaterialParameter) == 0x000000, "Member 'FOakStatusEffectPresentation_Material::bUsesMaterialParameter' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Material, MaterialParameterName) == 0x000008, "Member 'FOakStatusEffectPresentation_Material::MaterialParameterName' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Material, TransitionDuration) == 0x000010, "Member 'FOakStatusEffectPresentation_Material::TransitionDuration' has a wrong offset!");

// ScriptStruct OakGame.OakStatusEffectPresentation_Material_TransitionData
// 0x0008 (0x0008 - 0x0000)
struct FOakStatusEffectPresentation_Material_TransitionData final
{
public:
	float                                         TransitionTriggerValue;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialTargetValue;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakStatusEffectPresentation_Material_TransitionData) == 0x000004, "Wrong alignment on FOakStatusEffectPresentation_Material_TransitionData");
static_assert(sizeof(FOakStatusEffectPresentation_Material_TransitionData) == 0x000008, "Wrong size on FOakStatusEffectPresentation_Material_TransitionData");
static_assert(offsetof(FOakStatusEffectPresentation_Material_TransitionData, TransitionTriggerValue) == 0x000000, "Member 'FOakStatusEffectPresentation_Material_TransitionData::TransitionTriggerValue' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Material_TransitionData, MaterialTargetValue) == 0x000004, "Member 'FOakStatusEffectPresentation_Material_TransitionData::MaterialTargetValue' has a wrong offset!");

// ScriptStruct OakGame.OakStatusEffectPresentation_ScreenParticle
// 0x0020 (0x0020 - 0x0000)
struct FOakStatusEffectPresentation_ScreenParticle final
{
public:
	bool                                          bUsesScreenParticle;                               // 0x0000(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionDuration;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FirstPersonScreenEffect;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenParticleDepth;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakStatusEffectPresentation_ScreenParticle) == 0x000008, "Wrong alignment on FOakStatusEffectPresentation_ScreenParticle");
static_assert(sizeof(FOakStatusEffectPresentation_ScreenParticle) == 0x000020, "Wrong size on FOakStatusEffectPresentation_ScreenParticle");
static_assert(offsetof(FOakStatusEffectPresentation_ScreenParticle, bUsesScreenParticle) == 0x000000, "Member 'FOakStatusEffectPresentation_ScreenParticle::bUsesScreenParticle' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_ScreenParticle, TransitionDuration) == 0x000004, "Member 'FOakStatusEffectPresentation_ScreenParticle::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_ScreenParticle, ParamName) == 0x000008, "Member 'FOakStatusEffectPresentation_ScreenParticle::ParamName' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_ScreenParticle, FirstPersonScreenEffect) == 0x000010, "Member 'FOakStatusEffectPresentation_ScreenParticle::FirstPersonScreenEffect' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_ScreenParticle, ScreenParticleDepth) == 0x000018, "Member 'FOakStatusEffectPresentation_ScreenParticle::ScreenParticleDepth' has a wrong offset!");

// ScriptStruct OakGame.SpawnDroppedPickupLootRequest
// 0x00B8 (0x00B8 - 0x0000)
struct FSpawnDroppedPickupLootRequest
{
public:
	class AActor*                                 ContextActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSelectedInventoryInfo>         SelectedInventoryInfos;                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UItemPoolListInterface*                 ItemPools;                                         // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELootInstancingPolicy                         InstancingPolicy;                                  // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakPlayerController*                   PlayerToInstanceFor;                               // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartHidden;                                      // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeActivateDelay;                           // 0x0031(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateDelay;                                     // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpawnDelay;                                     // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialLootMassScale;                              // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 LootSpawnAction;                                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnDroppedPickupLootRequestType            RequestType;                                       // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeEffectData>           AttributeEffects;                                  // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDroppedFromAI;                                    // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULootSpawnPatternData*                  DropPattern;                                       // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachComponent;                                   // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPickupLootAttachmentMode                     AttachmentMode;                                    // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class ADroppedInventoryItemPickup* Pickup)> PickupSpawned;                                     // 0x0098(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnDroppedPickupLootRequest) == 0x000008, "Wrong alignment on FSpawnDroppedPickupLootRequest");
static_assert(sizeof(FSpawnDroppedPickupLootRequest) == 0x0000B8, "Wrong size on FSpawnDroppedPickupLootRequest");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, ContextActor) == 0x000000, "Member 'FSpawnDroppedPickupLootRequest::ContextActor' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, SelectedInventoryInfos) == 0x000008, "Member 'FSpawnDroppedPickupLootRequest::SelectedInventoryInfos' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, ItemPools) == 0x000018, "Member 'FSpawnDroppedPickupLootRequest::ItemPools' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, InstancingPolicy) == 0x000020, "Member 'FSpawnDroppedPickupLootRequest::InstancingPolicy' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, PlayerToInstanceFor) == 0x000028, "Member 'FSpawnDroppedPickupLootRequest::PlayerToInstanceFor' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, bStartHidden) == 0x000030, "Member 'FSpawnDroppedPickupLootRequest::bStartHidden' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, bRandomizeActivateDelay) == 0x000031, "Member 'FSpawnDroppedPickupLootRequest::bRandomizeActivateDelay' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, ActivateDelay) == 0x000034, "Member 'FSpawnDroppedPickupLootRequest::ActivateDelay' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, MaxSpawnDelay) == 0x000038, "Member 'FSpawnDroppedPickupLootRequest::MaxSpawnDelay' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, InitialLootMassScale) == 0x00003C, "Member 'FSpawnDroppedPickupLootRequest::InitialLootMassScale' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, LootSpawnAction) == 0x000040, "Member 'FSpawnDroppedPickupLootRequest::LootSpawnAction' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, SocketName) == 0x000048, "Member 'FSpawnDroppedPickupLootRequest::SocketName' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, RequestType) == 0x000050, "Member 'FSpawnDroppedPickupLootRequest::RequestType' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, AttributeEffects) == 0x000058, "Member 'FSpawnDroppedPickupLootRequest::AttributeEffects' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, bDroppedFromAI) == 0x000068, "Member 'FSpawnDroppedPickupLootRequest::bDroppedFromAI' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, DropPattern) == 0x000070, "Member 'FSpawnDroppedPickupLootRequest::DropPattern' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, AttachComponent) == 0x000088, "Member 'FSpawnDroppedPickupLootRequest::AttachComponent' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, AttachmentMode) == 0x000090, "Member 'FSpawnDroppedPickupLootRequest::AttachmentMode' has a wrong offset!");
static_assert(offsetof(FSpawnDroppedPickupLootRequest, PickupSpawned) == 0x000098, "Member 'FSpawnDroppedPickupLootRequest::PickupSpawned' has a wrong offset!");

// ScriptStruct OakGame.OakStatusEffectPresentation_Particle
// 0x0030 (0x0030 - 0x0000)
struct FOakStatusEffectPresentation_Particle final
{
public:
	bool                                          bUsesThirdPersonParticles;                         // 0x0000(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParticlePresentationName;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThirdPersonParameterName;                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ThirdPersonParticleSystem;                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SupportedEmitters;                                 // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakStatusEffectPresentation_Particle) == 0x000008, "Wrong alignment on FOakStatusEffectPresentation_Particle");
static_assert(sizeof(FOakStatusEffectPresentation_Particle) == 0x000030, "Wrong size on FOakStatusEffectPresentation_Particle");
static_assert(offsetof(FOakStatusEffectPresentation_Particle, bUsesThirdPersonParticles) == 0x000000, "Member 'FOakStatusEffectPresentation_Particle::bUsesThirdPersonParticles' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Particle, ParticlePresentationName) == 0x000008, "Member 'FOakStatusEffectPresentation_Particle::ParticlePresentationName' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Particle, ThirdPersonParameterName) == 0x000010, "Member 'FOakStatusEffectPresentation_Particle::ThirdPersonParameterName' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Particle, ThirdPersonParticleSystem) == 0x000018, "Member 'FOakStatusEffectPresentation_Particle::ThirdPersonParticleSystem' has a wrong offset!");
static_assert(offsetof(FOakStatusEffectPresentation_Particle, SupportedEmitters) == 0x000020, "Member 'FOakStatusEffectPresentation_Particle::SupportedEmitters' has a wrong offset!");

// ScriptStruct OakGame.DonationTier
// 0x0040 (0x0040 - 0x0000)
struct FDonationTier final
{
public:
	float                                         PercentOfMinProductCost;                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TierTitle;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   TierDescription;                                   // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         TierDuration;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDonationTier) == 0x000008, "Wrong alignment on FDonationTier");
static_assert(sizeof(FDonationTier) == 0x000040, "Wrong size on FDonationTier");
static_assert(offsetof(FDonationTier, PercentOfMinProductCost) == 0x000000, "Member 'FDonationTier::PercentOfMinProductCost' has a wrong offset!");
static_assert(offsetof(FDonationTier, TierTitle) == 0x000008, "Member 'FDonationTier::TierTitle' has a wrong offset!");
static_assert(offsetof(FDonationTier, TierDescription) == 0x000020, "Member 'FDonationTier::TierDescription' has a wrong offset!");
static_assert(offsetof(FDonationTier, TierDuration) == 0x000038, "Member 'FDonationTier::TierDuration' has a wrong offset!");

// ScriptStruct OakGame.BitProduct
// 0x0040 (0x0040 - 0x0000)
struct FBitProduct final
{
public:
	class FText                                   ProductName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ProductSKU;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProductDevSKU;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BitsCost;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBitProduct) == 0x000008, "Wrong alignment on FBitProduct");
static_assert(sizeof(FBitProduct) == 0x000040, "Wrong size on FBitProduct");
static_assert(offsetof(FBitProduct, ProductName) == 0x000000, "Member 'FBitProduct::ProductName' has a wrong offset!");
static_assert(offsetof(FBitProduct, ProductSKU) == 0x000018, "Member 'FBitProduct::ProductSKU' has a wrong offset!");
static_assert(offsetof(FBitProduct, ProductDevSKU) == 0x000028, "Member 'FBitProduct::ProductDevSKU' has a wrong offset!");
static_assert(offsetof(FBitProduct, BitsCost) == 0x000038, "Member 'FBitProduct::BitsCost' has a wrong offset!");

// ScriptStruct OakGame.OakInteractiveSessionStats
// 0x0020 (0x0020 - 0x0000)
struct FOakInteractiveSessionStats final
{
public:
	float                                         SessionLifetimeInSeconds;                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DamageCaused;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbEnemiesKilled;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbTimeInjured;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbTimeDead;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbLegendaries;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakInteractiveSessionStats) == 0x000008, "Wrong alignment on FOakInteractiveSessionStats");
static_assert(sizeof(FOakInteractiveSessionStats) == 0x000020, "Wrong size on FOakInteractiveSessionStats");
static_assert(offsetof(FOakInteractiveSessionStats, SessionLifetimeInSeconds) == 0x000000, "Member 'FOakInteractiveSessionStats::SessionLifetimeInSeconds' has a wrong offset!");
static_assert(offsetof(FOakInteractiveSessionStats, DamageCaused) == 0x000008, "Member 'FOakInteractiveSessionStats::DamageCaused' has a wrong offset!");
static_assert(offsetof(FOakInteractiveSessionStats, NbEnemiesKilled) == 0x000010, "Member 'FOakInteractiveSessionStats::NbEnemiesKilled' has a wrong offset!");
static_assert(offsetof(FOakInteractiveSessionStats, NbTimeInjured) == 0x000014, "Member 'FOakInteractiveSessionStats::NbTimeInjured' has a wrong offset!");
static_assert(offsetof(FOakInteractiveSessionStats, NbTimeDead) == 0x000018, "Member 'FOakInteractiveSessionStats::NbTimeDead' has a wrong offset!");
static_assert(offsetof(FOakInteractiveSessionStats, NbLegendaries) == 0x00001C, "Member 'FOakInteractiveSessionStats::NbLegendaries' has a wrong offset!");

// ScriptStruct OakGame.PollActionInfo
// 0x0060 (0x0060 - 0x0000)
struct FPollActionInfo final
{
public:
	class UStreamingPoolActionInfo*               PollAction;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PollActionClass;                                   // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SelectionText;                                     // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUsagePerEvent;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionID;                                          // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbTimeUsedInEvent;                                 // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSelectedValue;                                 // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoteCount;                                         // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPollActionInfo) == 0x000008, "Wrong alignment on FPollActionInfo");
static_assert(sizeof(FPollActionInfo) == 0x000060, "Wrong size on FPollActionInfo");
static_assert(offsetof(FPollActionInfo, PollAction) == 0x000000, "Member 'FPollActionInfo::PollAction' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, PollActionClass) == 0x000008, "Member 'FPollActionInfo::PollActionClass' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, SelectionText) == 0x000030, "Member 'FPollActionInfo::SelectionText' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, Weight) == 0x000048, "Member 'FPollActionInfo::Weight' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, MaxUsagePerEvent) == 0x00004C, "Member 'FPollActionInfo::MaxUsagePerEvent' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, ActionID) == 0x000050, "Member 'FPollActionInfo::ActionID' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, NbTimeUsedInEvent) == 0x000054, "Member 'FPollActionInfo::NbTimeUsedInEvent' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, LastSelectedValue) == 0x000058, "Member 'FPollActionInfo::LastSelectedValue' has a wrong offset!");
static_assert(offsetof(FPollActionInfo, VoteCount) == 0x00005C, "Member 'FPollActionInfo::VoteCount' has a wrong offset!");

// ScriptStruct OakGame.OakThumbnailManagerIcon
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FOakThumbnailManagerIcon final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakThumbnailManagerIcon) == 0x000008, "Wrong alignment on FOakThumbnailManagerIcon");
static_assert(sizeof(FOakThumbnailManagerIcon) == 0x000028, "Wrong size on FOakThumbnailManagerIcon");

// ScriptStruct OakGame.OakThumbnailManagerItemInfo
// 0x0710 (0x0710 - 0x0000)
struct FOakThumbnailManagerItemInfo final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 URL;                                               // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakThumbnailManagerIcon               IconData;                                          // 0x0058(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOakThumbnailManagerRenderProperties   RenderProperties;                                  // 0x0090(0x0670)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_700[0x10];                                     // 0x0700(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakThumbnailManagerItemInfo) == 0x000010, "Wrong alignment on FOakThumbnailManagerItemInfo");
static_assert(sizeof(FOakThumbnailManagerItemInfo) == 0x000710, "Wrong size on FOakThumbnailManagerItemInfo");
static_assert(offsetof(FOakThumbnailManagerItemInfo, URL) == 0x000040, "Member 'FOakThumbnailManagerItemInfo::URL' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerItemInfo, IconData) == 0x000058, "Member 'FOakThumbnailManagerItemInfo::IconData' has a wrong offset!");
static_assert(offsetof(FOakThumbnailManagerItemInfo, RenderProperties) == 0x000090, "Member 'FOakThumbnailManagerItemInfo::RenderProperties' has a wrong offset!");

// ScriptStruct OakGame.PlayerStandIn_Augment
// 0x0088 (0x0088 - 0x0000)
struct FPlayerStandIn_Augment final
{
public:
	TSoftObjectPtr<class UGbxDataAsset>           Augment;                                           // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrontendStandInAuxiliaryActorData     ActorData;                                         // 0x0028(0x0058)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideDefault;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStandIn_Augment) == 0x000008, "Wrong alignment on FPlayerStandIn_Augment");
static_assert(sizeof(FPlayerStandIn_Augment) == 0x000088, "Wrong size on FPlayerStandIn_Augment");
static_assert(offsetof(FPlayerStandIn_Augment, Augment) == 0x000000, "Member 'FPlayerStandIn_Augment::Augment' has a wrong offset!");
static_assert(offsetof(FPlayerStandIn_Augment, ActorData) == 0x000028, "Member 'FPlayerStandIn_Augment::ActorData' has a wrong offset!");
static_assert(offsetof(FPlayerStandIn_Augment, bOverrideDefault) == 0x000080, "Member 'FPlayerStandIn_Augment::bOverrideDefault' has a wrong offset!");

// ScriptStruct OakGame.OakUIVirtualBackpackConfig
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FOakUIVirtualBackpackConfig final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakUIVirtualBackpackConfig) == 0x000008, "Wrong alignment on FOakUIVirtualBackpackConfig");
static_assert(sizeof(FOakUIVirtualBackpackConfig) == 0x000070, "Wrong size on FOakUIVirtualBackpackConfig");

// ScriptStruct OakGame.VehicleOverrideData
// 0x0030 (0x0030 - 0x0000)
struct FVehicleOverrideData final
{
public:
	TArray<class FString>                         PartSelections;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Property;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                Data;                                              // 0x0020(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 DataType;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleOverrideData) == 0x000008, "Wrong alignment on FVehicleOverrideData");
static_assert(sizeof(FVehicleOverrideData) == 0x000030, "Wrong size on FVehicleOverrideData");
static_assert(offsetof(FVehicleOverrideData, PartSelections) == 0x000000, "Member 'FVehicleOverrideData::PartSelections' has a wrong offset!");
static_assert(offsetof(FVehicleOverrideData, Property) == 0x000010, "Member 'FVehicleOverrideData::Property' has a wrong offset!");
static_assert(offsetof(FVehicleOverrideData, Data) == 0x000020, "Member 'FVehicleOverrideData::Data' has a wrong offset!");
static_assert(offsetof(FVehicleOverrideData, DataType) == 0x000028, "Member 'FVehicleOverrideData::DataType' has a wrong offset!");

// ScriptStruct OakGame.PickupEvaluationResult
// 0x0010 (0x0010 - 0x0000)
struct FPickupEvaluationResult final
{
public:
	class AOakInventoryItemPickup*                Pickup;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPickupEvaluationResult) == 0x000008, "Wrong alignment on FPickupEvaluationResult");
static_assert(sizeof(FPickupEvaluationResult) == 0x000010, "Wrong size on FPickupEvaluationResult");
static_assert(offsetof(FPickupEvaluationResult, Pickup) == 0x000000, "Member 'FPickupEvaluationResult::Pickup' has a wrong offset!");

// ScriptStruct OakGame.VaultCardGearRewardData
// 0x0010 (0x0058 - 0x0048)
struct FVaultCardGearRewardData final : public FVaultCardRewardDataBase
{
public:
	class UInventoryBalanceData*                  GearReward;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemPoolData*                          GearRewardItemPool;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultCardGearRewardData) == 0x000008, "Wrong alignment on FVaultCardGearRewardData");
static_assert(sizeof(FVaultCardGearRewardData) == 0x000058, "Wrong size on FVaultCardGearRewardData");
static_assert(offsetof(FVaultCardGearRewardData, GearReward) == 0x000048, "Member 'FVaultCardGearRewardData::GearReward' has a wrong offset!");
static_assert(offsetof(FVaultCardGearRewardData, GearRewardItemPool) == 0x000050, "Member 'FVaultCardGearRewardData::GearRewardItemPool' has a wrong offset!");

// ScriptStruct OakGame.FakeGear
// 0x0098 (0x0098 - 0x0000)
struct FFakeGear final
{
public:
	struct FFloatCurve                            RPMCurve;                                          // 0x0000(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FVector2D                              SpeedMinMax;                                       // 0x0090(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFakeGear) == 0x000008, "Wrong alignment on FFakeGear");
static_assert(sizeof(FFakeGear) == 0x000098, "Wrong size on FFakeGear");
static_assert(offsetof(FFakeGear, RPMCurve) == 0x000000, "Member 'FFakeGear::RPMCurve' has a wrong offset!");
static_assert(offsetof(FFakeGear, SpeedMinMax) == 0x000090, "Member 'FFakeGear::SpeedMinMax' has a wrong offset!");

// ScriptStruct OakGame.NavPainterLayerEntry
// 0x0002 (0x0002 - 0x0000)
struct FNavPainterLayerEntry final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavPainterLayerEntry) == 0x000001, "Wrong alignment on FNavPainterLayerEntry");
static_assert(sizeof(FNavPainterLayerEntry) == 0x000002, "Wrong size on FNavPainterLayerEntry");

// ScriptStruct OakGame.SkinParameterData
// 0x0030 (0x0030 - 0x0000)
struct FSkinParameterData final
{
public:
	TArray<struct FMaterialParameterData>         Color1;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaterialParameterData>         Color2;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaterialParameterData>         Color3;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinParameterData) == 0x000008, "Wrong alignment on FSkinParameterData");
static_assert(sizeof(FSkinParameterData) == 0x000030, "Wrong size on FSkinParameterData");
static_assert(offsetof(FSkinParameterData, Color1) == 0x000000, "Member 'FSkinParameterData::Color1' has a wrong offset!");
static_assert(offsetof(FSkinParameterData, Color2) == 0x000010, "Member 'FSkinParameterData::Color2' has a wrong offset!");
static_assert(offsetof(FSkinParameterData, Color3) == 0x000020, "Member 'FSkinParameterData::Color3' has a wrong offset!");

// ScriptStruct OakGame.StuckTeleport
// 0x0020 (0x0020 - 0x0000)
struct FStuckTeleport final
{
public:
	bool                                          bEnableStuckTeleport;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardStuckValue;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CantMoveValuePerSec;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckTeleportTrigger;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckDecay;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0xB];                                       // 0x0015(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStuckTeleport) == 0x000004, "Wrong alignment on FStuckTeleport");
static_assert(sizeof(FStuckTeleport) == 0x000020, "Wrong size on FStuckTeleport");
static_assert(offsetof(FStuckTeleport, bEnableStuckTeleport) == 0x000000, "Member 'FStuckTeleport::bEnableStuckTeleport' has a wrong offset!");
static_assert(offsetof(FStuckTeleport, ForwardStuckValue) == 0x000004, "Member 'FStuckTeleport::ForwardStuckValue' has a wrong offset!");
static_assert(offsetof(FStuckTeleport, CantMoveValuePerSec) == 0x000008, "Member 'FStuckTeleport::CantMoveValuePerSec' has a wrong offset!");
static_assert(offsetof(FStuckTeleport, StuckTeleportTrigger) == 0x00000C, "Member 'FStuckTeleport::StuckTeleportTrigger' has a wrong offset!");
static_assert(offsetof(FStuckTeleport, StuckDecay) == 0x000010, "Member 'FStuckTeleport::StuckDecay' has a wrong offset!");
static_assert(offsetof(FStuckTeleport, bShowDebug) == 0x000014, "Member 'FStuckTeleport::bShowDebug' has a wrong offset!");

// ScriptStruct OakGame.OakVehicleNavCorrecter
// 0x00B8 (0x00B8 - 0x0000)
struct FOakVehicleNavCorrecter final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOakNavComponent*                       OakNavComp;                                        // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOakVehicle*                            OakVehicle;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNavAgentProperties                    NavAgentProps;                                     // 0x0020(0x0030)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x68];                                      // 0x0050(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakVehicleNavCorrecter) == 0x000008, "Wrong alignment on FOakVehicleNavCorrecter");
static_assert(sizeof(FOakVehicleNavCorrecter) == 0x0000B8, "Wrong size on FOakVehicleNavCorrecter");
static_assert(offsetof(FOakVehicleNavCorrecter, World) == 0x000000, "Member 'FOakVehicleNavCorrecter::World' has a wrong offset!");
static_assert(offsetof(FOakVehicleNavCorrecter, GbxNavWorld) == 0x000008, "Member 'FOakVehicleNavCorrecter::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FOakVehicleNavCorrecter, OakNavComp) == 0x000010, "Member 'FOakVehicleNavCorrecter::OakNavComp' has a wrong offset!");
static_assert(offsetof(FOakVehicleNavCorrecter, OakVehicle) == 0x000018, "Member 'FOakVehicleNavCorrecter::OakVehicle' has a wrong offset!");
static_assert(offsetof(FOakVehicleNavCorrecter, NavAgentProps) == 0x000020, "Member 'FOakVehicleNavCorrecter::NavAgentProps' has a wrong offset!");

// ScriptStruct OakGame.SDUCaseSpawner
// 0x0088 (0x0088 - 0x0000)
struct FSDUCaseSpawner final
{
public:
	class FName                                   AttachmentSocketName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOakSDUData*                            SDUData;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DisplayMesh;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSDULeft;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSDURight;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSDUUp;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSDUDown;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoldOut;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USocketComponent*                       AttachmentSocket;                                  // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USocketComponent*                       CameraSocket;                                      // 0x0048(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DisplayMeshComponent;                              // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   TextRenderComponent;                               // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          MouseCollisionComponent;                           // 0x0060(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSDUCaseSpawner) == 0x000008, "Wrong alignment on FSDUCaseSpawner");
static_assert(sizeof(FSDUCaseSpawner) == 0x000088, "Wrong size on FSDUCaseSpawner");
static_assert(offsetof(FSDUCaseSpawner, AttachmentSocketName) == 0x000000, "Member 'FSDUCaseSpawner::AttachmentSocketName' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, SDUData) == 0x000008, "Member 'FSDUCaseSpawner::SDUData' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, DisplayMesh) == 0x000010, "Member 'FSDUCaseSpawner::DisplayMesh' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, NextSDULeft) == 0x000018, "Member 'FSDUCaseSpawner::NextSDULeft' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, NextSDURight) == 0x000020, "Member 'FSDUCaseSpawner::NextSDURight' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, NextSDUUp) == 0x000028, "Member 'FSDUCaseSpawner::NextSDUUp' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, NextSDUDown) == 0x000030, "Member 'FSDUCaseSpawner::NextSDUDown' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, bSoldOut) == 0x000038, "Member 'FSDUCaseSpawner::bSoldOut' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, AttachmentSocket) == 0x000040, "Member 'FSDUCaseSpawner::AttachmentSocket' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, CameraSocket) == 0x000048, "Member 'FSDUCaseSpawner::CameraSocket' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, DisplayMeshComponent) == 0x000050, "Member 'FSDUCaseSpawner::DisplayMeshComponent' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, TextRenderComponent) == 0x000058, "Member 'FSDUCaseSpawner::TextRenderComponent' has a wrong offset!");
static_assert(offsetof(FSDUCaseSpawner, MouseCollisionComponent) == 0x000060, "Member 'FSDUCaseSpawner::MouseCollisionComponent' has a wrong offset!");

// ScriptStruct OakGame.VehicleUnlockedSaveGameData
// 0x0018 (0x0018 - 0x0000)
struct FVehicleUnlockedSaveGameData final
{
public:
	class FString                                 AssetPath;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustUnlocked;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleUnlockedSaveGameData) == 0x000008, "Wrong alignment on FVehicleUnlockedSaveGameData");
static_assert(sizeof(FVehicleUnlockedSaveGameData) == 0x000018, "Wrong size on FVehicleUnlockedSaveGameData");
static_assert(offsetof(FVehicleUnlockedSaveGameData, AssetPath) == 0x000000, "Member 'FVehicleUnlockedSaveGameData::AssetPath' has a wrong offset!");
static_assert(offsetof(FVehicleUnlockedSaveGameData, bJustUnlocked) == 0x000010, "Member 'FVehicleUnlockedSaveGameData::bJustUnlocked' has a wrong offset!");

// ScriptStruct OakGame.DummyProjectileInfo
// 0x0030 (0x0030 - 0x0000)
struct FDummyProjectileInfo final
{
public:
	TSubclassOf<class AActor>                     ProjectileClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 TransitInAction;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 TransitOutAction;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            TransitInSoundEvent;                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ProjectileActor;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDummyProjectileInfo) == 0x000008, "Wrong alignment on FDummyProjectileInfo");
static_assert(sizeof(FDummyProjectileInfo) == 0x000030, "Wrong size on FDummyProjectileInfo");
static_assert(offsetof(FDummyProjectileInfo, ProjectileClass) == 0x000000, "Member 'FDummyProjectileInfo::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FDummyProjectileInfo, Socket) == 0x000008, "Member 'FDummyProjectileInfo::Socket' has a wrong offset!");
static_assert(offsetof(FDummyProjectileInfo, TransitInAction) == 0x000010, "Member 'FDummyProjectileInfo::TransitInAction' has a wrong offset!");
static_assert(offsetof(FDummyProjectileInfo, TransitOutAction) == 0x000018, "Member 'FDummyProjectileInfo::TransitOutAction' has a wrong offset!");
static_assert(offsetof(FDummyProjectileInfo, TransitInSoundEvent) == 0x000020, "Member 'FDummyProjectileInfo::TransitInSoundEvent' has a wrong offset!");
static_assert(offsetof(FDummyProjectileInfo, ProjectileActor) == 0x000028, "Member 'FDummyProjectileInfo::ProjectileActor' has a wrong offset!");

// ScriptStruct OakGame.WeaponAudioBodyLoopPlaybackInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FWeaponAudioBodyLoopPlaybackInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponAudioBodyLoopPlaybackInfo) == 0x000008, "Wrong alignment on FWeaponAudioBodyLoopPlaybackInfo");
static_assert(sizeof(FWeaponAudioBodyLoopPlaybackInfo) == 0x000028, "Wrong size on FWeaponAudioBodyLoopPlaybackInfo");

// ScriptStruct OakGame.WeaponAudioBodyLoop
// 0x0028 (0x0028 - 0x0000)
struct FWeaponAudioBodyLoop final
{
public:
	class FName                                   PlaybackSocket;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StartLoopEvent;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            StopLoopEvent;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAudioBodyLoopType                      LoopType;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComponentSize;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentTag;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAudioBodyLoop) == 0x000008, "Wrong alignment on FWeaponAudioBodyLoop");
static_assert(sizeof(FWeaponAudioBodyLoop) == 0x000028, "Wrong size on FWeaponAudioBodyLoop");
static_assert(offsetof(FWeaponAudioBodyLoop, PlaybackSocket) == 0x000000, "Member 'FWeaponAudioBodyLoop::PlaybackSocket' has a wrong offset!");
static_assert(offsetof(FWeaponAudioBodyLoop, StartLoopEvent) == 0x000008, "Member 'FWeaponAudioBodyLoop::StartLoopEvent' has a wrong offset!");
static_assert(offsetof(FWeaponAudioBodyLoop, StopLoopEvent) == 0x000010, "Member 'FWeaponAudioBodyLoop::StopLoopEvent' has a wrong offset!");
static_assert(offsetof(FWeaponAudioBodyLoop, LoopType) == 0x000018, "Member 'FWeaponAudioBodyLoop::LoopType' has a wrong offset!");
static_assert(offsetof(FWeaponAudioBodyLoop, ComponentSize) == 0x00001C, "Member 'FWeaponAudioBodyLoop::ComponentSize' has a wrong offset!");
static_assert(offsetof(FWeaponAudioBodyLoop, ComponentTag) == 0x000020, "Member 'FWeaponAudioBodyLoop::ComponentTag' has a wrong offset!");

// ScriptStruct OakGame.WeaponShellCasingImpact
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FWeaponShellCasingImpact final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponShellCasingImpact) == 0x000008, "Wrong alignment on FWeaponShellCasingImpact");
static_assert(sizeof(FWeaponShellCasingImpact) == 0x000018, "Wrong size on FWeaponShellCasingImpact");

// ScriptStruct OakGame.WeaponShellCasingAudioParameters
// 0x0010 (0x0010 - 0x0000)
struct FWeaponShellCasingAudioParameters final
{
public:
	class UWwiseEvent*                            ShellCasingWwiseEvent;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EjectDistance;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactDelay;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponShellCasingAudioParameters) == 0x000008, "Wrong alignment on FWeaponShellCasingAudioParameters");
static_assert(sizeof(FWeaponShellCasingAudioParameters) == 0x000010, "Wrong size on FWeaponShellCasingAudioParameters");
static_assert(offsetof(FWeaponShellCasingAudioParameters, ShellCasingWwiseEvent) == 0x000000, "Member 'FWeaponShellCasingAudioParameters::ShellCasingWwiseEvent' has a wrong offset!");
static_assert(offsetof(FWeaponShellCasingAudioParameters, EjectDistance) == 0x000008, "Member 'FWeaponShellCasingAudioParameters::EjectDistance' has a wrong offset!");
static_assert(offsetof(FWeaponShellCasingAudioParameters, ImpactDelay) == 0x00000C, "Member 'FWeaponShellCasingAudioParameters::ImpactDelay' has a wrong offset!");

// ScriptStruct OakGame.WeaponAudioFailsafe
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FWeaponAudioFailsafe final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponAudioFailsafe) == 0x000008, "Wrong alignment on FWeaponAudioFailsafe");
static_assert(sizeof(FWeaponAudioFailsafe) == 0x000030, "Wrong size on FWeaponAudioFailsafe");

// ScriptStruct OakGame.WeaponConfigurationRtpc
// 0x0010 (0x0010 - 0x0000)
struct FWeaponConfigurationRtpc final
{
public:
	class UWwiseRtpc*                             RtpcParam;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAveragingSum;                              // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponConfigurationRtpc) == 0x000008, "Wrong alignment on FWeaponConfigurationRtpc");
static_assert(sizeof(FWeaponConfigurationRtpc) == 0x000010, "Wrong size on FWeaponConfigurationRtpc");
static_assert(offsetof(FWeaponConfigurationRtpc, RtpcParam) == 0x000000, "Member 'FWeaponConfigurationRtpc::RtpcParam' has a wrong offset!");
static_assert(offsetof(FWeaponConfigurationRtpc, Value) == 0x000008, "Member 'FWeaponConfigurationRtpc::Value' has a wrong offset!");
static_assert(offsetof(FWeaponConfigurationRtpc, PriorityAveragingSum) == 0x00000C, "Member 'FWeaponConfigurationRtpc::PriorityAveragingSum' has a wrong offset!");

// ScriptStruct OakGame.WeaponConfigurationEvent
// 0x0010 (0x0010 - 0x0000)
struct FWeaponConfigurationEvent final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponConfigurationEvent) == 0x000008, "Wrong alignment on FWeaponConfigurationEvent");
static_assert(sizeof(FWeaponConfigurationEvent) == 0x000010, "Wrong size on FWeaponConfigurationEvent");
static_assert(offsetof(FWeaponConfigurationEvent, Priority) == 0x000000, "Member 'FWeaponConfigurationEvent::Priority' has a wrong offset!");
static_assert(offsetof(FWeaponConfigurationEvent, WwiseEvent) == 0x000008, "Member 'FWeaponConfigurationEvent::WwiseEvent' has a wrong offset!");

// ScriptStruct OakGame.OakVehicleWeaponTriggerFeedbackDefinitionData
// 0x0040 (0x0040 - 0x0000)
struct FOakVehicleWeaponTriggerFeedbackDefinitionData final
{
public:
	class UWeaponTriggerFeedbackAsset*            Feedback;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponAssetPath;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakVehicleWeaponTriggerFeedbackDefinitionData) == 0x000008, "Wrong alignment on FOakVehicleWeaponTriggerFeedbackDefinitionData");
static_assert(sizeof(FOakVehicleWeaponTriggerFeedbackDefinitionData) == 0x000040, "Wrong size on FOakVehicleWeaponTriggerFeedbackDefinitionData");
static_assert(offsetof(FOakVehicleWeaponTriggerFeedbackDefinitionData, Feedback) == 0x000000, "Member 'FOakVehicleWeaponTriggerFeedbackDefinitionData::Feedback' has a wrong offset!");
static_assert(offsetof(FOakVehicleWeaponTriggerFeedbackDefinitionData, WeaponAssetPath) == 0x000008, "Member 'FOakVehicleWeaponTriggerFeedbackDefinitionData::WeaponAssetPath' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankEnabledIndexTracker
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGuardianRankEnabledIndexTracker final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardianRankEnabledIndexTracker) == 0x000008, "Wrong alignment on FGuardianRankEnabledIndexTracker");
static_assert(sizeof(FGuardianRankEnabledIndexTracker) == 0x000020, "Wrong size on FGuardianRankEnabledIndexTracker");

// ScriptStruct OakGame.OakWeaponTriggerFeedbackDefinitionData
// 0x0048 (0x0048 - 0x0000)
struct FOakWeaponTriggerFeedbackDefinitionData final
{
public:
	class UWeaponTriggerFeedbackAsset*            Feedback;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponClassPath;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOakWeaponPartType                            PartType;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PartTypeValue;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2E];                                      // 0x001A(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOakWeaponTriggerFeedbackDefinitionData) == 0x000008, "Wrong alignment on FOakWeaponTriggerFeedbackDefinitionData");
static_assert(sizeof(FOakWeaponTriggerFeedbackDefinitionData) == 0x000048, "Wrong size on FOakWeaponTriggerFeedbackDefinitionData");
static_assert(offsetof(FOakWeaponTriggerFeedbackDefinitionData, Feedback) == 0x000000, "Member 'FOakWeaponTriggerFeedbackDefinitionData::Feedback' has a wrong offset!");
static_assert(offsetof(FOakWeaponTriggerFeedbackDefinitionData, WeaponClassPath) == 0x000008, "Member 'FOakWeaponTriggerFeedbackDefinitionData::WeaponClassPath' has a wrong offset!");
static_assert(offsetof(FOakWeaponTriggerFeedbackDefinitionData, PartType) == 0x000018, "Member 'FOakWeaponTriggerFeedbackDefinitionData::PartType' has a wrong offset!");
static_assert(offsetof(FOakWeaponTriggerFeedbackDefinitionData, PartTypeValue) == 0x000019, "Member 'FOakWeaponTriggerFeedbackDefinitionData::PartTypeValue' has a wrong offset!");

// ScriptStruct OakGame.OakWeaponNamingAttributePair
// 0x0018 (0x0018 - 0x0000)
struct FOakWeaponNamingAttributePair final
{
public:
	class FName                                   FirstAttributeName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondAttributeName;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryNamePartData*                 NamePart;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOakWeaponNamingAttributePair) == 0x000008, "Wrong alignment on FOakWeaponNamingAttributePair");
static_assert(sizeof(FOakWeaponNamingAttributePair) == 0x000018, "Wrong size on FOakWeaponNamingAttributePair");
static_assert(offsetof(FOakWeaponNamingAttributePair, FirstAttributeName) == 0x000000, "Member 'FOakWeaponNamingAttributePair::FirstAttributeName' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamingAttributePair, SecondAttributeName) == 0x000008, "Member 'FOakWeaponNamingAttributePair::SecondAttributeName' has a wrong offset!");
static_assert(offsetof(FOakWeaponNamingAttributePair, NamePart) == 0x000010, "Member 'FOakWeaponNamingAttributePair::NamePart' has a wrong offset!");

// ScriptStruct OakGame.OakWeaponAttributeNamingData
// 0x0018 (0x0018 - 0x0000)
struct FOakWeaponAttributeNamingData final
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOakWeaponNameThresholdPairData> NamingTiers;                                       // 0x0008(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOakWeaponAttributeNamingData) == 0x000008, "Wrong alignment on FOakWeaponAttributeNamingData");
static_assert(sizeof(FOakWeaponAttributeNamingData) == 0x000018, "Wrong size on FOakWeaponAttributeNamingData");
static_assert(offsetof(FOakWeaponAttributeNamingData, Attribute) == 0x000000, "Member 'FOakWeaponAttributeNamingData::Attribute' has a wrong offset!");
static_assert(offsetof(FOakWeaponAttributeNamingData, NamingTiers) == 0x000008, "Member 'FOakWeaponAttributeNamingData::NamingTiers' has a wrong offset!");

// ScriptStruct OakGame.RepWindGust
// 0x0004 (0x0004 - 0x0000)
struct FRepWindGust final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepWindGust) == 0x000004, "Wrong alignment on FRepWindGust");
static_assert(sizeof(FRepWindGust) == 0x000004, "Wrong size on FRepWindGust");
static_assert(offsetof(FRepWindGust, Seed) == 0x000000, "Member 'FRepWindGust::Seed' has a wrong offset!");

// ScriptStruct OakGame.OperativeBarrierStatusEffectInfo
// 0x0018 (0x0018 - 0x0000)
struct FOperativeBarrierStatusEffectInfo final
{
public:
	class UStatusEffectData*                      OwnerStatusEffect;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatusEffectData*                      DefaultStatusEffect;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOperativeBarrierStatusEffectInfo) == 0x000008, "Wrong alignment on FOperativeBarrierStatusEffectInfo");
static_assert(sizeof(FOperativeBarrierStatusEffectInfo) == 0x000018, "Wrong size on FOperativeBarrierStatusEffectInfo");
static_assert(offsetof(FOperativeBarrierStatusEffectInfo, OwnerStatusEffect) == 0x000000, "Member 'FOperativeBarrierStatusEffectInfo::OwnerStatusEffect' has a wrong offset!");
static_assert(offsetof(FOperativeBarrierStatusEffectInfo, DefaultStatusEffect) == 0x000008, "Member 'FOperativeBarrierStatusEffectInfo::DefaultStatusEffect' has a wrong offset!");
static_assert(offsetof(FOperativeBarrierStatusEffectInfo, Duration) == 0x000010, "Member 'FOperativeBarrierStatusEffectInfo::Duration' has a wrong offset!");

// ScriptStruct OakGame.RebindContextAndDescription
// 0x0050 (0x0050 - 0x0000)
struct FRebindContextAndDescription final
{
public:
	class FText                                   SchemeName;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGbxInputRebindContext>  RebindContext;                                     // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOptionDescriptionItem*>         Description;                                       // 0x0040(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRebindContextAndDescription) == 0x000008, "Wrong alignment on FRebindContextAndDescription");
static_assert(sizeof(FRebindContextAndDescription) == 0x000050, "Wrong size on FRebindContextAndDescription");
static_assert(offsetof(FRebindContextAndDescription, SchemeName) == 0x000000, "Member 'FRebindContextAndDescription::SchemeName' has a wrong offset!");
static_assert(offsetof(FRebindContextAndDescription, RebindContext) == 0x000018, "Member 'FRebindContextAndDescription::RebindContext' has a wrong offset!");
static_assert(offsetof(FRebindContextAndDescription, Description) == 0x000040, "Member 'FRebindContextAndDescription::Description' has a wrong offset!");

// ScriptStruct OakGame.GamepadStickTypeToSchemes
// 0x0010 (0x0010 - 0x0000)
struct FGamepadStickTypeToSchemes final
{
public:
	TArray<struct FRebindContextAndDescription>   SchemesWithStickType;                              // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadStickTypeToSchemes) == 0x000008, "Wrong alignment on FGamepadStickTypeToSchemes");
static_assert(sizeof(FGamepadStickTypeToSchemes) == 0x000010, "Wrong size on FGamepadStickTypeToSchemes");
static_assert(offsetof(FGamepadStickTypeToSchemes, SchemesWithStickType) == 0x000000, "Member 'FGamepadStickTypeToSchemes::SchemesWithStickType' has a wrong offset!");

// ScriptStruct OakGame.OutrunnerVehicleAnimInstanceProxy
// 0x0040 (0x07C0 - 0x0780)
struct FOutrunnerVehicleAnimInstanceProxy final : public FOakVehicleAnimInstanceProxy
{
public:
	uint8                                         Pad_780[0x40];                                     // 0x0780(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOutrunnerVehicleAnimInstanceProxy) == 0x000010, "Wrong alignment on FOutrunnerVehicleAnimInstanceProxy");
static_assert(sizeof(FOutrunnerVehicleAnimInstanceProxy) == 0x0007C0, "Wrong size on FOutrunnerVehicleAnimInstanceProxy");

// ScriptStruct OakGame.PerPlayerCullable
// 0x0008 (0x0008 - 0x0000)
struct FPerPlayerCullable final
{
public:
	class AActor*                                 CullableActor;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerPlayerCullable) == 0x000008, "Wrong alignment on FPerPlayerCullable");
static_assert(sizeof(FPerPlayerCullable) == 0x000008, "Wrong size on FPerPlayerCullable");
static_assert(offsetof(FPerPlayerCullable, CullableActor) == 0x000000, "Member 'FPerPlayerCullable::CullableActor' has a wrong offset!");

// ScriptStruct OakGame.PhotoModeOption
// 0x0050 (0x0050 - 0x0000)
struct FPhotoModeOption final
{
public:
	class FText                                   OptionName;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	EPhotoModeOptionEffect                        OptionEffect;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSlider;                                         // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SliderDisplayMin;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderDisplayMax;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderOutputMin;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderOutputMax;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSliderDisplayAsInteger;                           // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SliderStepping;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SliderRepeatsToAccelerate;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SliderMaxIncreases;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SliderFastestSteps;                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           SpinnerOptions;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhotoModeOption) == 0x000008, "Wrong alignment on FPhotoModeOption");
static_assert(sizeof(FPhotoModeOption) == 0x000050, "Wrong size on FPhotoModeOption");
static_assert(offsetof(FPhotoModeOption, OptionName) == 0x000000, "Member 'FPhotoModeOption::OptionName' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, OptionEffect) == 0x000018, "Member 'FPhotoModeOption::OptionEffect' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, bIsSlider) == 0x000019, "Member 'FPhotoModeOption::bIsSlider' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderDisplayMin) == 0x00001C, "Member 'FPhotoModeOption::SliderDisplayMin' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderDisplayMax) == 0x000020, "Member 'FPhotoModeOption::SliderDisplayMax' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderOutputMin) == 0x000024, "Member 'FPhotoModeOption::SliderOutputMin' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderOutputMax) == 0x000028, "Member 'FPhotoModeOption::SliderOutputMax' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, bSliderDisplayAsInteger) == 0x00002C, "Member 'FPhotoModeOption::bSliderDisplayAsInteger' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderStepping) == 0x000030, "Member 'FPhotoModeOption::SliderStepping' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderRepeatsToAccelerate) == 0x000034, "Member 'FPhotoModeOption::SliderRepeatsToAccelerate' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderMaxIncreases) == 0x000038, "Member 'FPhotoModeOption::SliderMaxIncreases' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SliderFastestSteps) == 0x00003C, "Member 'FPhotoModeOption::SliderFastestSteps' has a wrong offset!");
static_assert(offsetof(FPhotoModeOption, SpinnerOptions) == 0x000040, "Member 'FPhotoModeOption::SpinnerOptions' has a wrong offset!");

// ScriptStruct OakGame.PhotoModeOptionSet
// 0x0020 (0x0020 - 0x0000)
struct FPhotoModeOptionSet final
{
public:
	class FString                                 OptionSetName;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPhotoModeOption>               Options;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhotoModeOptionSet) == 0x000008, "Wrong alignment on FPhotoModeOptionSet");
static_assert(sizeof(FPhotoModeOptionSet) == 0x000020, "Wrong size on FPhotoModeOptionSet");
static_assert(offsetof(FPhotoModeOptionSet, OptionSetName) == 0x000000, "Member 'FPhotoModeOptionSet::OptionSetName' has a wrong offset!");
static_assert(offsetof(FPhotoModeOptionSet, Options) == 0x000010, "Member 'FPhotoModeOptionSet::Options' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapPOIMeshListEntry
// 0x0010 (0x0010 - 0x0000)
struct FZoneMapPOIMeshListEntry final
{
public:
	class UStaticMesh*                            ZoneMapPOIMesh;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UZoneMapData*                           ZoneMapForPOIMesh;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapPOIMeshListEntry) == 0x000008, "Wrong alignment on FZoneMapPOIMeshListEntry");
static_assert(sizeof(FZoneMapPOIMeshListEntry) == 0x000010, "Wrong size on FZoneMapPOIMeshListEntry");
static_assert(offsetof(FZoneMapPOIMeshListEntry, ZoneMapPOIMesh) == 0x000000, "Member 'FZoneMapPOIMeshListEntry::ZoneMapPOIMesh' has a wrong offset!");
static_assert(offsetof(FZoneMapPOIMeshListEntry, ZoneMapForPOIMesh) == 0x000008, "Member 'FZoneMapPOIMeshListEntry::ZoneMapForPOIMesh' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankRewardCategoryEntry
// 0x0010 (0x0010 - 0x0000)
struct FGuardianRankRewardCategoryEntry final
{
public:
	class UGuardianRankRewardCategoryData*        RankRewardCategory;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCategoryTokens;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardianRankRewardCategoryEntry) == 0x000008, "Wrong alignment on FGuardianRankRewardCategoryEntry");
static_assert(sizeof(FGuardianRankRewardCategoryEntry) == 0x000010, "Wrong size on FGuardianRankRewardCategoryEntry");
static_assert(offsetof(FGuardianRankRewardCategoryEntry, RankRewardCategory) == 0x000000, "Member 'FGuardianRankRewardCategoryEntry::RankRewardCategory' has a wrong offset!");
static_assert(offsetof(FGuardianRankRewardCategoryEntry, NumCategoryTokens) == 0x000008, "Member 'FGuardianRankRewardCategoryEntry::NumCategoryTokens' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankPerkEntry
// 0x0018 (0x0018 - 0x0000)
struct FGuardianRankPerkEntry final
{
public:
	class UGuardianRankPerkData*                  RankPerk;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAbility*                            PerkAbilityInstance;                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlocked;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasJustUnlocked;                                  // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardianRankPerkEntry) == 0x000008, "Wrong alignment on FGuardianRankPerkEntry");
static_assert(sizeof(FGuardianRankPerkEntry) == 0x000018, "Wrong size on FGuardianRankPerkEntry");
static_assert(offsetof(FGuardianRankPerkEntry, RankPerk) == 0x000000, "Member 'FGuardianRankPerkEntry::RankPerk' has a wrong offset!");
static_assert(offsetof(FGuardianRankPerkEntry, PerkAbilityInstance) == 0x000008, "Member 'FGuardianRankPerkEntry::PerkAbilityInstance' has a wrong offset!");
static_assert(offsetof(FGuardianRankPerkEntry, bUnlocked) == 0x000010, "Member 'FGuardianRankPerkEntry::bUnlocked' has a wrong offset!");
static_assert(offsetof(FGuardianRankPerkEntry, bWasJustUnlocked) == 0x000011, "Member 'FGuardianRankPerkEntry::bWasJustUnlocked' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankRewardEntry
// 0x0020 (0x0020 - 0x0000)
struct FGuardianRankRewardEntry final
{
public:
	class UGuardianRankRewardData*                RankReward;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTokens;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x14];                                       // 0x000C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardianRankRewardEntry) == 0x000008, "Wrong alignment on FGuardianRankRewardEntry");
static_assert(sizeof(FGuardianRankRewardEntry) == 0x000020, "Wrong size on FGuardianRankRewardEntry");
static_assert(offsetof(FGuardianRankRewardEntry, RankReward) == 0x000000, "Member 'FGuardianRankRewardEntry::RankReward' has a wrong offset!");
static_assert(offsetof(FGuardianRankRewardEntry, NumTokens) == 0x000008, "Member 'FGuardianRankRewardEntry::NumTokens' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankPerkCharacterSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FGuardianRankPerkCharacterSaveGameData final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGuardianRankPerkData>   PerkDataPath;                                      // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGuardianRankPerkCharacterSaveGameData) == 0x000008, "Wrong alignment on FGuardianRankPerkCharacterSaveGameData");
static_assert(sizeof(FGuardianRankPerkCharacterSaveGameData) == 0x000030, "Wrong size on FGuardianRankPerkCharacterSaveGameData");
static_assert(offsetof(FGuardianRankPerkCharacterSaveGameData, bEnabled) == 0x000000, "Member 'FGuardianRankPerkCharacterSaveGameData::bEnabled' has a wrong offset!");
static_assert(offsetof(FGuardianRankPerkCharacterSaveGameData, PerkDataPath) == 0x000008, "Member 'FGuardianRankPerkCharacterSaveGameData::PerkDataPath' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankCharacterSaveGameData
// 0x0040 (0x0040 - 0x0000)
struct FGuardianRankCharacterSaveGameData final
{
public:
	int32                                         AvailableTokens;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardianRank;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         GuardianExperience;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGuardianRankSystemEnabled;                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuardianRankRewardCharacterSaveGameData> RankRewards;                                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuardianRankPerkCharacterSaveGameData> RankPerks;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RankRewardRandomSeed;                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardianRankCharacterSaveGameData) == 0x000008, "Wrong alignment on FGuardianRankCharacterSaveGameData");
static_assert(sizeof(FGuardianRankCharacterSaveGameData) == 0x000040, "Wrong size on FGuardianRankCharacterSaveGameData");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, AvailableTokens) == 0x000000, "Member 'FGuardianRankCharacterSaveGameData::AvailableTokens' has a wrong offset!");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, GuardianRank) == 0x000004, "Member 'FGuardianRankCharacterSaveGameData::GuardianRank' has a wrong offset!");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, GuardianExperience) == 0x000008, "Member 'FGuardianRankCharacterSaveGameData::GuardianExperience' has a wrong offset!");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, bGuardianRankSystemEnabled) == 0x000010, "Member 'FGuardianRankCharacterSaveGameData::bGuardianRankSystemEnabled' has a wrong offset!");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, RankRewards) == 0x000018, "Member 'FGuardianRankCharacterSaveGameData::RankRewards' has a wrong offset!");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, RankPerks) == 0x000028, "Member 'FGuardianRankCharacterSaveGameData::RankPerks' has a wrong offset!");
static_assert(offsetof(FGuardianRankCharacterSaveGameData, RankRewardRandomSeed) == 0x000038, "Member 'FGuardianRankCharacterSaveGameData::RankRewardRandomSeed' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankRewardSaveGameData
// 0x0030 (0x0030 - 0x0000)
struct FGuardianRankRewardSaveGameData final
{
public:
	int32                                         NumTokens;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGuardianRankRewardData> RewardDataPath;                                    // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGuardianRankRewardSaveGameData) == 0x000008, "Wrong alignment on FGuardianRankRewardSaveGameData");
static_assert(sizeof(FGuardianRankRewardSaveGameData) == 0x000030, "Wrong size on FGuardianRankRewardSaveGameData");
static_assert(offsetof(FGuardianRankRewardSaveGameData, NumTokens) == 0x000000, "Member 'FGuardianRankRewardSaveGameData::NumTokens' has a wrong offset!");
static_assert(offsetof(FGuardianRankRewardSaveGameData, RewardDataPath) == 0x000008, "Member 'FGuardianRankRewardSaveGameData::RewardDataPath' has a wrong offset!");

// ScriptStruct OakGame.GuardianRankProfileData
// 0x0030 (0x0030 - 0x0000)
struct FGuardianRankProfileData final
{
public:
	int32                                         AvailableTokens;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuardianRankRewardSaveGameData> RankRewards;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GuardianRank;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         GuardianExperience;                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankRewardRandomSeed;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGuardianRankProfileData) == 0x000008, "Wrong alignment on FGuardianRankProfileData");
static_assert(sizeof(FGuardianRankProfileData) == 0x000030, "Wrong size on FGuardianRankProfileData");
static_assert(offsetof(FGuardianRankProfileData, AvailableTokens) == 0x000000, "Member 'FGuardianRankProfileData::AvailableTokens' has a wrong offset!");
static_assert(offsetof(FGuardianRankProfileData, RankRewards) == 0x000008, "Member 'FGuardianRankProfileData::RankRewards' has a wrong offset!");
static_assert(offsetof(FGuardianRankProfileData, GuardianRank) == 0x000018, "Member 'FGuardianRankProfileData::GuardianRank' has a wrong offset!");
static_assert(offsetof(FGuardianRankProfileData, GuardianExperience) == 0x000020, "Member 'FGuardianRankProfileData::GuardianExperience' has a wrong offset!");
static_assert(offsetof(FGuardianRankProfileData, RankRewardRandomSeed) == 0x000028, "Member 'FGuardianRankProfileData::RankRewardRandomSeed' has a wrong offset!");

// ScriptStruct OakGame.PlayerIdentityWidgetInfo
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FPlayerIdentityWidgetInfo final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerIdentityWidgetInfo) == 0x000008, "Wrong alignment on FPlayerIdentityWidgetInfo");
static_assert(sizeof(FPlayerIdentityWidgetInfo) == 0x000058, "Wrong size on FPlayerIdentityWidgetInfo");

// ScriptStruct OakGame.PlayerStandInInitData
// 0x0030 (0x0030 - 0x0000)
struct FPlayerStandInInitData final
{
public:
	class UPlayerClassIdentifier*                 PlayerClass;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOakPlayerController*                   OwnerPlayerController;                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStandInInitData) == 0x000008, "Wrong alignment on FPlayerStandInInitData");
static_assert(sizeof(FPlayerStandInInitData) == 0x000030, "Wrong size on FPlayerStandInInitData");
static_assert(offsetof(FPlayerStandInInitData, PlayerClass) == 0x000000, "Member 'FPlayerStandInInitData::PlayerClass' has a wrong offset!");
static_assert(offsetof(FPlayerStandInInitData, OwnerPlayerController) == 0x000010, "Member 'FPlayerStandInInitData::OwnerPlayerController' has a wrong offset!");

// ScriptStruct OakGame.ExtraStandInAnimationMeshData
// 0x0018 (0x0018 - 0x0000)
struct FExtraStandInAnimationMeshData final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimBlueprint;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAnimSet*                            AnimSet;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtraStandInAnimationMeshData) == 0x000008, "Wrong alignment on FExtraStandInAnimationMeshData");
static_assert(sizeof(FExtraStandInAnimationMeshData) == 0x000018, "Wrong size on FExtraStandInAnimationMeshData");
static_assert(offsetof(FExtraStandInAnimationMeshData, ComponentName) == 0x000000, "Member 'FExtraStandInAnimationMeshData::ComponentName' has a wrong offset!");
static_assert(offsetof(FExtraStandInAnimationMeshData, AnimBlueprint) == 0x000008, "Member 'FExtraStandInAnimationMeshData::AnimBlueprint' has a wrong offset!");
static_assert(offsetof(FExtraStandInAnimationMeshData, AnimSet) == 0x000010, "Member 'FExtraStandInAnimationMeshData::AnimSet' has a wrong offset!");

// ScriptStruct OakGame.FrontendStandInSpecialAnimationData
// 0x0018 (0x0018 - 0x0000)
struct FFrontendStandInSpecialAnimationData final
{
public:
	TSubclassOf<class UGbxAction>                 Animation;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 AuxiliaryAnimation;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDelay;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFrontendStandInSpecialAnimationData) == 0x000008, "Wrong alignment on FFrontendStandInSpecialAnimationData");
static_assert(sizeof(FFrontendStandInSpecialAnimationData) == 0x000018, "Wrong size on FFrontendStandInSpecialAnimationData");
static_assert(offsetof(FFrontendStandInSpecialAnimationData, Animation) == 0x000000, "Member 'FFrontendStandInSpecialAnimationData::Animation' has a wrong offset!");
static_assert(offsetof(FFrontendStandInSpecialAnimationData, AuxiliaryAnimation) == 0x000008, "Member 'FFrontendStandInSpecialAnimationData::AuxiliaryAnimation' has a wrong offset!");
static_assert(offsetof(FFrontendStandInSpecialAnimationData, InitialDelay) == 0x000010, "Member 'FFrontendStandInSpecialAnimationData::InitialDelay' has a wrong offset!");

// ScriptStruct OakGame.PlayerStandIn_ActionAbility
// 0x0088 (0x0088 - 0x0000)
struct FPlayerStandIn_ActionAbility final
{
public:
	TSoftClassPtr<class UClass>                   ActionAbilityClass;                                // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrontendStandInAuxiliaryActorData     ActorData;                                         // 0x0028(0x0058)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideDefault;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStandIn_ActionAbility) == 0x000008, "Wrong alignment on FPlayerStandIn_ActionAbility");
static_assert(sizeof(FPlayerStandIn_ActionAbility) == 0x000088, "Wrong size on FPlayerStandIn_ActionAbility");
static_assert(offsetof(FPlayerStandIn_ActionAbility, ActionAbilityClass) == 0x000000, "Member 'FPlayerStandIn_ActionAbility::ActionAbilityClass' has a wrong offset!");
static_assert(offsetof(FPlayerStandIn_ActionAbility, ActorData) == 0x000028, "Member 'FPlayerStandIn_ActionAbility::ActorData' has a wrong offset!");
static_assert(offsetof(FPlayerStandIn_ActionAbility, bOverrideDefault) == 0x000080, "Member 'FPlayerStandIn_ActionAbility::bOverrideDefault' has a wrong offset!");

// ScriptStruct OakGame.ProjectedMeshResults
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FProjectedMeshResults final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectedMeshResults) == 0x000008, "Wrong alignment on FProjectedMeshResults");
static_assert(sizeof(FProjectedMeshResults) == 0x000040, "Wrong size on FProjectedMeshResults");

// ScriptStruct OakGame.ProjectedMeshOptions
// 0x0048 (0x0048 - 0x0000)
struct FProjectedMeshOptions final
{
public:
	EProjectedMeshShape                           Shape;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Size;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale2D;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Complexity;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRings;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipNormals;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateUVs;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTraceDistance;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTraceDistance;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushAwayDistance;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreActor;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AdditionalIgnoredActors;                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectedMeshOptions) == 0x000008, "Wrong alignment on FProjectedMeshOptions");
static_assert(sizeof(FProjectedMeshOptions) == 0x000048, "Wrong size on FProjectedMeshOptions");
static_assert(offsetof(FProjectedMeshOptions, Shape) == 0x000000, "Member 'FProjectedMeshOptions::Shape' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, Size) == 0x000004, "Member 'FProjectedMeshOptions::Size' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, Scale2D) == 0x000008, "Member 'FProjectedMeshOptions::Scale2D' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, Complexity) == 0x000010, "Member 'FProjectedMeshOptions::Complexity' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, NumRings) == 0x000014, "Member 'FProjectedMeshOptions::NumRings' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, bFlipNormals) == 0x000018, "Member 'FProjectedMeshOptions::bFlipNormals' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, bGenerateUVs) == 0x000019, "Member 'FProjectedMeshOptions::bGenerateUVs' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, CollisionChannel) == 0x00001A, "Member 'FProjectedMeshOptions::CollisionChannel' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, StartTraceDistance) == 0x00001C, "Member 'FProjectedMeshOptions::StartTraceDistance' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, EndTraceDistance) == 0x000020, "Member 'FProjectedMeshOptions::EndTraceDistance' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, PushAwayDistance) == 0x000024, "Member 'FProjectedMeshOptions::PushAwayDistance' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, bIgnoreActor) == 0x000028, "Member 'FProjectedMeshOptions::bIgnoreActor' has a wrong offset!");
static_assert(offsetof(FProjectedMeshOptions, AdditionalIgnoredActors) == 0x000030, "Member 'FProjectedMeshOptions::AdditionalIgnoredActors' has a wrong offset!");

// ScriptStruct OakGame.RegionBalancePreviewData
// 0x000C (0x000C - 0x0000)
struct FRegionBalancePreviewData final
{
public:
	int32                                         GameStageMinimum;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameStageMaximum;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameStageIncreaseOverPlayerLevel;                  // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegionBalancePreviewData) == 0x000004, "Wrong alignment on FRegionBalancePreviewData");
static_assert(sizeof(FRegionBalancePreviewData) == 0x00000C, "Wrong size on FRegionBalancePreviewData");
static_assert(offsetof(FRegionBalancePreviewData, GameStageMinimum) == 0x000000, "Member 'FRegionBalancePreviewData::GameStageMinimum' has a wrong offset!");
static_assert(offsetof(FRegionBalancePreviewData, GameStageMaximum) == 0x000004, "Member 'FRegionBalancePreviewData::GameStageMaximum' has a wrong offset!");
static_assert(offsetof(FRegionBalancePreviewData, GameStageIncreaseOverPlayerLevel) == 0x000008, "Member 'FRegionBalancePreviewData::GameStageIncreaseOverPlayerLevel' has a wrong offset!");

// ScriptStruct OakGame.PlayThroughData
// 0x0058 (0x0058 - 0x0000)
struct FPlayThroughData final
{
public:
	int32                                         PlayThrough;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnforceMinimumGameStageForPlaythrough;            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           MinimumGameStageForPlaythrough;                    // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FRegionBalanceData>             Regions;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bGameStageTracksPlayerLevelAboveMinimum;           // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayThroughData) == 0x000008, "Wrong alignment on FPlayThroughData");
static_assert(sizeof(FPlayThroughData) == 0x000058, "Wrong size on FPlayThroughData");
static_assert(offsetof(FPlayThroughData, PlayThrough) == 0x000000, "Member 'FPlayThroughData::PlayThrough' has a wrong offset!");
static_assert(offsetof(FPlayThroughData, bEnforceMinimumGameStageForPlaythrough) == 0x000004, "Member 'FPlayThroughData::bEnforceMinimumGameStageForPlaythrough' has a wrong offset!");
static_assert(offsetof(FPlayThroughData, MinimumGameStageForPlaythrough) == 0x000008, "Member 'FPlayThroughData::MinimumGameStageForPlaythrough' has a wrong offset!");
static_assert(offsetof(FPlayThroughData, Regions) == 0x000040, "Member 'FPlayThroughData::Regions' has a wrong offset!");
static_assert(offsetof(FPlayThroughData, bGameStageTracksPlayerLevelAboveMinimum) == 0x000050, "Member 'FPlayThroughData::bGameStageTracksPlayerLevelAboveMinimum' has a wrong offset!");

// ScriptStruct OakGame.RegionSaveData
// 0x0010 (0x0010 - 0x0000)
struct FRegionSaveData final
{
public:
	class URegionData*                            REGION;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameStage;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayThroughIdx;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegionSaveData) == 0x000008, "Wrong alignment on FRegionSaveData");
static_assert(sizeof(FRegionSaveData) == 0x000010, "Wrong size on FRegionSaveData");
static_assert(offsetof(FRegionSaveData, REGION) == 0x000000, "Member 'FRegionSaveData::REGION' has a wrong offset!");
static_assert(offsetof(FRegionSaveData, GameStage) == 0x000008, "Member 'FRegionSaveData::GameStage' has a wrong offset!");
static_assert(offsetof(FRegionSaveData, PlayThroughIdx) == 0x00000C, "Member 'FRegionSaveData::PlayThroughIdx' has a wrong offset!");

// ScriptStruct OakGame.RevolverVehicleAnimInstanceProxy
// 0x0020 (0x07A0 - 0x0780)
struct FRevolverVehicleAnimInstanceProxy final : public FOakVehicleAnimInstanceProxy
{
public:
	uint8                                         Pad_780[0x20];                                     // 0x0780(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRevolverVehicleAnimInstanceProxy) == 0x000010, "Wrong alignment on FRevolverVehicleAnimInstanceProxy");
static_assert(sizeof(FRevolverVehicleAnimInstanceProxy) == 0x0007A0, "Wrong size on FRevolverVehicleAnimInstanceProxy");

// ScriptStruct OakGame.ShieldDamageModifierData
// 0x0020 (0x0020 - 0x0000)
struct FShieldDamageModifierData final
{
public:
	class UShieldAugment_DamageModifier*          Augment;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConditionalDamageModifier*             ModifierInstance;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AOakCharacter*>                  RegisteredCharacters;                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldDamageModifierData) == 0x000008, "Wrong alignment on FShieldDamageModifierData");
static_assert(sizeof(FShieldDamageModifierData) == 0x000020, "Wrong size on FShieldDamageModifierData");
static_assert(offsetof(FShieldDamageModifierData, Augment) == 0x000000, "Member 'FShieldDamageModifierData::Augment' has a wrong offset!");
static_assert(offsetof(FShieldDamageModifierData, ModifierInstance) == 0x000008, "Member 'FShieldDamageModifierData::ModifierInstance' has a wrong offset!");
static_assert(offsetof(FShieldDamageModifierData, RegisteredCharacters) == 0x000010, "Member 'FShieldDamageModifierData::RegisteredCharacters' has a wrong offset!");

// ScriptStruct OakGame.AugmentData
// 0x0030 (0x0030 - 0x0000)
struct FAugmentData final
{
public:
	class AShield*                                Shield;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeTriggered;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstanceBool;                                     // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InstanceFloat;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceInt;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InstanceVector;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InstanceActor;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAugmentData) == 0x000008, "Wrong alignment on FAugmentData");
static_assert(sizeof(FAugmentData) == 0x000030, "Wrong size on FAugmentData");
static_assert(offsetof(FAugmentData, Shield) == 0x000000, "Member 'FAugmentData::Shield' has a wrong offset!");
static_assert(offsetof(FAugmentData, StackCount) == 0x000008, "Member 'FAugmentData::StackCount' has a wrong offset!");
static_assert(offsetof(FAugmentData, bCanBeTriggered) == 0x00000C, "Member 'FAugmentData::bCanBeTriggered' has a wrong offset!");
static_assert(offsetof(FAugmentData, bInstanceBool) == 0x00000D, "Member 'FAugmentData::bInstanceBool' has a wrong offset!");
static_assert(offsetof(FAugmentData, InstanceFloat) == 0x000010, "Member 'FAugmentData::InstanceFloat' has a wrong offset!");
static_assert(offsetof(FAugmentData, InstanceInt) == 0x000014, "Member 'FAugmentData::InstanceInt' has a wrong offset!");
static_assert(offsetof(FAugmentData, InstanceVector) == 0x000018, "Member 'FAugmentData::InstanceVector' has a wrong offset!");
static_assert(offsetof(FAugmentData, InstanceActor) == 0x000028, "Member 'FAugmentData::InstanceActor' has a wrong offset!");

// ScriptStruct OakGame.TrackedShieldAttributeData
// 0x0028 (0x0028 - 0x0000)
struct FTrackedShieldAttributeData final
{
public:
	class UGbxAttributeData*                      Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeModifierHandle            ModifierHandle;                                    // 0x0008(0x0010)(Transient, NativeAccessSpecifierPublic)
	class UClass*                                 ShieldAugmentClass;                                // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackedShieldAttributeData) == 0x000008, "Wrong alignment on FTrackedShieldAttributeData");
static_assert(sizeof(FTrackedShieldAttributeData) == 0x000028, "Wrong size on FTrackedShieldAttributeData");
static_assert(offsetof(FTrackedShieldAttributeData, Data) == 0x000000, "Member 'FTrackedShieldAttributeData::Data' has a wrong offset!");
static_assert(offsetof(FTrackedShieldAttributeData, ModifierHandle) == 0x000008, "Member 'FTrackedShieldAttributeData::ModifierHandle' has a wrong offset!");
static_assert(offsetof(FTrackedShieldAttributeData, ShieldAugmentClass) == 0x000018, "Member 'FTrackedShieldAttributeData::ShieldAugmentClass' has a wrong offset!");

// ScriptStruct OakGame.ShieldAugmentDamageEventData
// 0x0048 (0x0048 - 0x0000)
struct FShieldAugmentDamageEventData final
{
public:
	uint8                                         bShieldMustNotBeDepleted : 1;                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstanceBoolMustBeTrue : 1;                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstanceBoolMustBeTrueForBarrier : 1;             // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMustBeTriggerable : 1;                            // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetNotTriggerableAfterTriggering : 1;             // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           TriggerCooldown;                                   // 0x0008(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UDamageFilter*                          DamageEventFilter;                                 // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldAugmentDamageEventData) == 0x000008, "Wrong alignment on FShieldAugmentDamageEventData");
static_assert(sizeof(FShieldAugmentDamageEventData) == 0x000048, "Wrong size on FShieldAugmentDamageEventData");
static_assert(offsetof(FShieldAugmentDamageEventData, TriggerCooldown) == 0x000008, "Member 'FShieldAugmentDamageEventData::TriggerCooldown' has a wrong offset!");
static_assert(offsetof(FShieldAugmentDamageEventData, DamageEventFilter) == 0x000040, "Member 'FShieldAugmentDamageEventData::DamageEventFilter' has a wrong offset!");

// ScriptStruct OakGame.ShieldAugmentAbsorbRestoreData
// 0x0050 (0x0050 - 0x0000)
struct FShieldAugmentAbsorbRestoreData final
{
public:
	bool                                          bOnlyTriggerOnBarrier;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGbxDamageType>>     TriggeringDamageTypes;                             // 0x0008(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           RestoreAmount;                                     // 0x0018(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldAugmentAbsorbRestoreData) == 0x000008, "Wrong alignment on FShieldAugmentAbsorbRestoreData");
static_assert(sizeof(FShieldAugmentAbsorbRestoreData) == 0x000050, "Wrong size on FShieldAugmentAbsorbRestoreData");
static_assert(offsetof(FShieldAugmentAbsorbRestoreData, bOnlyTriggerOnBarrier) == 0x000000, "Member 'FShieldAugmentAbsorbRestoreData::bOnlyTriggerOnBarrier' has a wrong offset!");
static_assert(offsetof(FShieldAugmentAbsorbRestoreData, TriggeringDamageTypes) == 0x000008, "Member 'FShieldAugmentAbsorbRestoreData::TriggeringDamageTypes' has a wrong offset!");
static_assert(offsetof(FShieldAugmentAbsorbRestoreData, RestoreAmount) == 0x000018, "Member 'FShieldAugmentAbsorbRestoreData::RestoreAmount' has a wrong offset!");

// ScriptStruct OakGame.AdaptiveTypeAssociations
// 0x0020 (0x0020 - 0x0000)
struct FAdaptiveTypeAssociations final
{
public:
	EOakElementalType                             DamageType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAttributeData*                      ResistanceAttribute;                               // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            TriggerAudioEvent;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            HitByTypeAudioEvent;                               // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdaptiveTypeAssociations) == 0x000008, "Wrong alignment on FAdaptiveTypeAssociations");
static_assert(sizeof(FAdaptiveTypeAssociations) == 0x000020, "Wrong size on FAdaptiveTypeAssociations");
static_assert(offsetof(FAdaptiveTypeAssociations, DamageType) == 0x000000, "Member 'FAdaptiveTypeAssociations::DamageType' has a wrong offset!");
static_assert(offsetof(FAdaptiveTypeAssociations, ResistanceAttribute) == 0x000008, "Member 'FAdaptiveTypeAssociations::ResistanceAttribute' has a wrong offset!");
static_assert(offsetof(FAdaptiveTypeAssociations, TriggerAudioEvent) == 0x000010, "Member 'FAdaptiveTypeAssociations::TriggerAudioEvent' has a wrong offset!");
static_assert(offsetof(FAdaptiveTypeAssociations, HitByTypeAudioEvent) == 0x000018, "Member 'FAdaptiveTypeAssociations::HitByTypeAudioEvent' has a wrong offset!");

// ScriptStruct OakGame.AttributeModifiers
// 0x0020 (0x0020 - 0x0000)
struct FAttributeModifiers final
{
public:
	class UGbxAttributeData*                      AttributeToModify;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeInitializationData>   StackValues;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeModifiers) == 0x000008, "Wrong alignment on FAttributeModifiers");
static_assert(sizeof(FAttributeModifiers) == 0x000020, "Wrong size on FAttributeModifiers");
static_assert(offsetof(FAttributeModifiers, AttributeToModify) == 0x000000, "Member 'FAttributeModifiers::AttributeToModify' has a wrong offset!");
static_assert(offsetof(FAttributeModifiers, ModifierType) == 0x000008, "Member 'FAttributeModifiers::ModifierType' has a wrong offset!");
static_assert(offsetof(FAttributeModifiers, StackValues) == 0x000010, "Member 'FAttributeModifiers::StackValues' has a wrong offset!");

// ScriptStruct OakGame.DamageTypeAttribute
// 0x0010 (0x0010 - 0x0000)
struct FDamageTypeAttribute final
{
public:
	class UGbxAttributeData*                      AttributeToModify;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeAttribute) == 0x000008, "Wrong alignment on FDamageTypeAttribute");
static_assert(sizeof(FDamageTypeAttribute) == 0x000010, "Wrong size on FDamageTypeAttribute");
static_assert(offsetof(FDamageTypeAttribute, AttributeToModify) == 0x000000, "Member 'FDamageTypeAttribute::AttributeToModify' has a wrong offset!");
static_assert(offsetof(FDamageTypeAttribute, DamageType) == 0x000008, "Member 'FDamageTypeAttribute::DamageType' has a wrong offset!");

// ScriptStruct OakGame.ShieldTriggeredProjectileReflectEffect
// 0x0048 (0x0048 - 0x0000)
struct FShieldTriggeredProjectileReflectEffect final
{
public:
	bool                                          bShieldMustBeActiveToTrigger;                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightProjectileData>       LightProjectile;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           Damage;                                            // 0x0010(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShieldTriggeredProjectileReflectEffect) == 0x000008, "Wrong alignment on FShieldTriggeredProjectileReflectEffect");
static_assert(sizeof(FShieldTriggeredProjectileReflectEffect) == 0x000048, "Wrong size on FShieldTriggeredProjectileReflectEffect");
static_assert(offsetof(FShieldTriggeredProjectileReflectEffect, bShieldMustBeActiveToTrigger) == 0x000000, "Member 'FShieldTriggeredProjectileReflectEffect::bShieldMustBeActiveToTrigger' has a wrong offset!");
static_assert(offsetof(FShieldTriggeredProjectileReflectEffect, LightProjectile) == 0x000008, "Member 'FShieldTriggeredProjectileReflectEffect::LightProjectile' has a wrong offset!");
static_assert(offsetof(FShieldTriggeredProjectileReflectEffect, Damage) == 0x000010, "Member 'FShieldTriggeredProjectileReflectEffect::Damage' has a wrong offset!");

// ScriptStruct OakGame.SpawnFactorKeyedAction
// 0x0038 (0x0038 - 0x0000)
struct FSpawnFactorKeyedAction final
{
public:
	bool                                          bOverrideKeyedActionList;                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDataActionPair_Spawn>          SpawnKeyedActionList;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataActionPair_SpawnMesh>      SpawnMeshKeyedActionList;                          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataActionPair_SmartObject>    SmartObjectKeyedActionList;                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnFactorKeyedAction) == 0x000008, "Wrong alignment on FSpawnFactorKeyedAction");
static_assert(sizeof(FSpawnFactorKeyedAction) == 0x000038, "Wrong size on FSpawnFactorKeyedAction");
static_assert(offsetof(FSpawnFactorKeyedAction, bOverrideKeyedActionList) == 0x000000, "Member 'FSpawnFactorKeyedAction::bOverrideKeyedActionList' has a wrong offset!");
static_assert(offsetof(FSpawnFactorKeyedAction, SpawnKeyedActionList) == 0x000008, "Member 'FSpawnFactorKeyedAction::SpawnKeyedActionList' has a wrong offset!");
static_assert(offsetof(FSpawnFactorKeyedAction, SpawnMeshKeyedActionList) == 0x000018, "Member 'FSpawnFactorKeyedAction::SpawnMeshKeyedActionList' has a wrong offset!");
static_assert(offsetof(FSpawnFactorKeyedAction, SmartObjectKeyedActionList) == 0x000028, "Member 'FSpawnFactorKeyedAction::SmartObjectKeyedActionList' has a wrong offset!");

// ScriptStruct OakGame.WeightedPassengersNum
// 0x0008 (0x0008 - 0x0000)
struct FWeightedPassengersNum final
{
public:
	int32                                         PassengerCount;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedPassengersNum) == 0x000004, "Wrong alignment on FWeightedPassengersNum");
static_assert(sizeof(FWeightedPassengersNum) == 0x000008, "Wrong size on FWeightedPassengersNum");
static_assert(offsetof(FWeightedPassengersNum, PassengerCount) == 0x000000, "Member 'FWeightedPassengersNum::PassengerCount' has a wrong offset!");
static_assert(offsetof(FWeightedPassengersNum, Weight) == 0x000004, "Member 'FWeightedPassengersNum::Weight' has a wrong offset!");

// ScriptStruct OakGame.SeatOccupant
// 0x0010 (0x0010 - 0x0000)
struct FSeatOccupant final
{
public:
	int32                                         SeatSlot;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeatOccupant) == 0x000008, "Wrong alignment on FSeatOccupant");
static_assert(sizeof(FSeatOccupant) == 0x000010, "Wrong size on FSeatOccupant");
static_assert(offsetof(FSeatOccupant, SeatSlot) == 0x000000, "Member 'FSeatOccupant::SeatSlot' has a wrong offset!");
static_assert(offsetof(FSeatOccupant, SpawnOptions) == 0x000008, "Member 'FSeatOccupant::SpawnOptions' has a wrong offset!");

// ScriptStruct OakGame.SpawnDroppedPickupLootRequestEntry
// 0x0058 (0x0110 - 0x00B8)
struct alignas(0x10) FSpawnDroppedPickupLootRequestEntry final : public FSpawnDroppedPickupLootRequest
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSelectedInventorySpawningState> SpawningStates;                                    // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnDroppedPickupLootRequestEntry) == 0x000010, "Wrong alignment on FSpawnDroppedPickupLootRequestEntry");
static_assert(sizeof(FSpawnDroppedPickupLootRequestEntry) == 0x000110, "Wrong size on FSpawnDroppedPickupLootRequestEntry");
static_assert(offsetof(FSpawnDroppedPickupLootRequestEntry, SpawningStates) == 0x0000C8, "Member 'FSpawnDroppedPickupLootRequestEntry::SpawningStates' has a wrong offset!");

// ScriptStruct OakGame.SplineFollowerDistanceCheckpoint
// 0x0018 (0x0018 - 0x0000)
struct FSplineFollowerDistanceCheckpoint final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplineFollowerDistanceCheckpoint) == 0x000008, "Wrong alignment on FSplineFollowerDistanceCheckpoint");
static_assert(sizeof(FSplineFollowerDistanceCheckpoint) == 0x000018, "Wrong size on FSplineFollowerDistanceCheckpoint");
static_assert(offsetof(FSplineFollowerDistanceCheckpoint, Name) == 0x000000, "Member 'FSplineFollowerDistanceCheckpoint::Name' has a wrong offset!");
static_assert(offsetof(FSplineFollowerDistanceCheckpoint, Distance) == 0x000010, "Member 'FSplineFollowerDistanceCheckpoint::Distance' has a wrong offset!");

// ScriptStruct OakGame.HardPointSlotSettings
// 0x0028 (0x0028 - 0x0000)
struct FHardPointSlotSettings final
{
public:
	class FName                                   AnimationSlotName;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CESlotName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction_CoordinatedEffect> HardPointSelectedCE;                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction_CoordinatedEffect> HardpointPreviewCE;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction_CoordinatedEffect> HardPointEquippedCE;                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHardPointSlotSettings) == 0x000008, "Wrong alignment on FHardPointSlotSettings");
static_assert(sizeof(FHardPointSlotSettings) == 0x000028, "Wrong size on FHardPointSlotSettings");
static_assert(offsetof(FHardPointSlotSettings, AnimationSlotName) == 0x000000, "Member 'FHardPointSlotSettings::AnimationSlotName' has a wrong offset!");
static_assert(offsetof(FHardPointSlotSettings, CESlotName) == 0x000008, "Member 'FHardPointSlotSettings::CESlotName' has a wrong offset!");
static_assert(offsetof(FHardPointSlotSettings, HardPointSelectedCE) == 0x000010, "Member 'FHardPointSlotSettings::HardPointSelectedCE' has a wrong offset!");
static_assert(offsetof(FHardPointSlotSettings, HardpointPreviewCE) == 0x000018, "Member 'FHardPointSlotSettings::HardpointPreviewCE' has a wrong offset!");
static_assert(offsetof(FHardPointSlotSettings, HardPointEquippedCE) == 0x000020, "Member 'FHardPointSlotSettings::HardPointEquippedCE' has a wrong offset!");

// ScriptStruct OakGame.FrontendStandInSlotSettings
// 0x0050 (0x0050 - 0x0000)
struct FFrontendStandInSlotSettings final
{
public:
	TArray<int32>                                 SlotsToRemainHidden;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFrontendStandInSlotTransitionSettings Transitions[0x4];                                  // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrontendStandInSlotSettings) == 0x000008, "Wrong alignment on FFrontendStandInSlotSettings");
static_assert(sizeof(FFrontendStandInSlotSettings) == 0x000050, "Wrong size on FFrontendStandInSlotSettings");
static_assert(offsetof(FFrontendStandInSlotSettings, SlotsToRemainHidden) == 0x000000, "Member 'FFrontendStandInSlotSettings::SlotsToRemainHidden' has a wrong offset!");
static_assert(offsetof(FFrontendStandInSlotSettings, Transitions) == 0x000010, "Member 'FFrontendStandInSlotSettings::Transitions' has a wrong offset!");

// ScriptStruct OakGame.StandInUIController
// 0x0390 (0x0390 - 0x0000)
struct alignas(0x10) FStandInUIController final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ContainerClass;                                    // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VerticalSplitInVehicleAdjustment;                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                OuterObject;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOakPlayerController*                   PlayerController;                                  // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOakUIActorContainer*                   StandInContainer;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FStandInLightComponentInstance> LightComponents;                                   // 0x0050(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class USceneComponent*                        StandInTransformRoot;                              // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CurrentStandInActor;                               // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         SecondaryActors;                                   // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 TempInventoryActor;                                // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryBalanceStateComponent*        StandInTemplateInventoryBalanceState;              // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesiredStandInActorData               LastDesiredActorData;                              // 0x00A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x138];                                     // 0x00F8(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesiredStandInActorData               DesiredActorData;                                  // 0x0230(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        StreamedObjects;                                   // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        WantedStreamRequest;                               // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4[0xEC];                                     // 0x02A4(0x00EC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandInUIController) == 0x000010, "Wrong alignment on FStandInUIController");
static_assert(sizeof(FStandInUIController) == 0x000390, "Wrong size on FStandInUIController");
static_assert(offsetof(FStandInUIController, ContainerClass) == 0x000008, "Member 'FStandInUIController::ContainerClass' has a wrong offset!");
static_assert(offsetof(FStandInUIController, VerticalSplitInVehicleAdjustment) == 0x000030, "Member 'FStandInUIController::VerticalSplitInVehicleAdjustment' has a wrong offset!");
static_assert(offsetof(FStandInUIController, OuterObject) == 0x000038, "Member 'FStandInUIController::OuterObject' has a wrong offset!");
static_assert(offsetof(FStandInUIController, PlayerController) == 0x000040, "Member 'FStandInUIController::PlayerController' has a wrong offset!");
static_assert(offsetof(FStandInUIController, StandInContainer) == 0x000048, "Member 'FStandInUIController::StandInContainer' has a wrong offset!");
static_assert(offsetof(FStandInUIController, LightComponents) == 0x000050, "Member 'FStandInUIController::LightComponents' has a wrong offset!");
static_assert(offsetof(FStandInUIController, StandInTransformRoot) == 0x000060, "Member 'FStandInUIController::StandInTransformRoot' has a wrong offset!");
static_assert(offsetof(FStandInUIController, CurrentStandInActor) == 0x000068, "Member 'FStandInUIController::CurrentStandInActor' has a wrong offset!");
static_assert(offsetof(FStandInUIController, SecondaryActors) == 0x000070, "Member 'FStandInUIController::SecondaryActors' has a wrong offset!");
static_assert(offsetof(FStandInUIController, TempInventoryActor) == 0x000080, "Member 'FStandInUIController::TempInventoryActor' has a wrong offset!");
static_assert(offsetof(FStandInUIController, StandInTemplateInventoryBalanceState) == 0x000088, "Member 'FStandInUIController::StandInTemplateInventoryBalanceState' has a wrong offset!");
static_assert(offsetof(FStandInUIController, LastDesiredActorData) == 0x0000A8, "Member 'FStandInUIController::LastDesiredActorData' has a wrong offset!");
static_assert(offsetof(FStandInUIController, DesiredActorData) == 0x000230, "Member 'FStandInUIController::DesiredActorData' has a wrong offset!");
static_assert(offsetof(FStandInUIController, StreamedObjects) == 0x000280, "Member 'FStandInUIController::StreamedObjects' has a wrong offset!");
static_assert(offsetof(FStandInUIController, WantedStreamRequest) == 0x0002A0, "Member 'FStandInUIController::WantedStreamRequest' has a wrong offset!");

// ScriptStruct OakGame.StandInUIControllerTickFunction
// 0x0008 (0x0058 - 0x0050)
struct FStandInUIControllerTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStandInUIControllerTickFunction) == 0x000008, "Wrong alignment on FStandInUIControllerTickFunction");
static_assert(sizeof(FStandInUIControllerTickFunction) == 0x000058, "Wrong size on FStandInUIControllerTickFunction");

// ScriptStruct OakGame.StreamerBoosterInfo
// 0x0030 (0x0030 - 0x0000)
struct FStreamerBoosterInfo final
{
public:
	class FName                                   NameId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Icon;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStreamerBoosterInfo) == 0x000008, "Wrong alignment on FStreamerBoosterInfo");
static_assert(sizeof(FStreamerBoosterInfo) == 0x000030, "Wrong size on FStreamerBoosterInfo");
static_assert(offsetof(FStreamerBoosterInfo, NameId) == 0x000000, "Member 'FStreamerBoosterInfo::NameId' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterInfo, DisplayName) == 0x000008, "Member 'FStreamerBoosterInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterInfo, StatusEffectData) == 0x000020, "Member 'FStreamerBoosterInfo::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStreamerBoosterInfo, Icon) == 0x000028, "Member 'FStreamerBoosterInfo::Icon' has a wrong offset!");

// ScriptStruct OakGame.TechnicalVehicleAnimInstanceProxy
// 0x0010 (0x0790 - 0x0780)
struct FTechnicalVehicleAnimInstanceProxy final : public FOakVehicleAnimInstanceProxy
{
public:
	uint8                                         Pad_780[0x10];                                     // 0x0780(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTechnicalVehicleAnimInstanceProxy) == 0x000010, "Wrong alignment on FTechnicalVehicleAnimInstanceProxy");
static_assert(sizeof(FTechnicalVehicleAnimInstanceProxy) == 0x000790, "Wrong size on FTechnicalVehicleAnimInstanceProxy");

// ScriptStruct OakGame.TestMapMenuEntry
// 0x0028 (0x0028 - 0x0000)
struct FTestMapMenuEntry final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTestMapMenuEntry) == 0x000008, "Wrong alignment on FTestMapMenuEntry");
static_assert(sizeof(FTestMapMenuEntry) == 0x000028, "Wrong size on FTestMapMenuEntry");
static_assert(offsetof(FTestMapMenuEntry, DisplayName) == 0x000000, "Member 'FTestMapMenuEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(FTestMapMenuEntry, MapName) == 0x000018, "Member 'FTestMapMenuEntry::MapName' has a wrong offset!");

// ScriptStruct OakGame.VendingMachineItemRarityData
// 0x0020 (0x0020 - 0x0000)
struct FVendingMachineItemRarityData final
{
public:
	class UInventoryRarityData*                   Rarity;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShelfMaterial;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ItemOfTheDayShelfMaterial;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionParticleRarityParameter;                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendingMachineItemRarityData) == 0x000008, "Wrong alignment on FVendingMachineItemRarityData");
static_assert(sizeof(FVendingMachineItemRarityData) == 0x000020, "Wrong size on FVendingMachineItemRarityData");
static_assert(offsetof(FVendingMachineItemRarityData, Rarity) == 0x000000, "Member 'FVendingMachineItemRarityData::Rarity' has a wrong offset!");
static_assert(offsetof(FVendingMachineItemRarityData, ShelfMaterial) == 0x000008, "Member 'FVendingMachineItemRarityData::ShelfMaterial' has a wrong offset!");
static_assert(offsetof(FVendingMachineItemRarityData, ItemOfTheDayShelfMaterial) == 0x000010, "Member 'FVendingMachineItemRarityData::ItemOfTheDayShelfMaterial' has a wrong offset!");
static_assert(offsetof(FVendingMachineItemRarityData, SelectionParticleRarityParameter) == 0x000018, "Member 'FVendingMachineItemRarityData::SelectionParticleRarityParameter' has a wrong offset!");

// ScriptStruct OakGame.TransporterCraneRecord
// 0x0010 (0x0010 - 0x0000)
struct FTransporterCraneRecord final
{
public:
	ETransporterCraneState                        CraneState;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeed;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStartPosition;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStartTime;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransporterCraneRecord) == 0x000004, "Wrong alignment on FTransporterCraneRecord");
static_assert(sizeof(FTransporterCraneRecord) == 0x000010, "Wrong size on FTransporterCraneRecord");
static_assert(offsetof(FTransporterCraneRecord, CraneState) == 0x000000, "Member 'FTransporterCraneRecord::CraneState' has a wrong offset!");
static_assert(offsetof(FTransporterCraneRecord, MoveSpeed) == 0x000004, "Member 'FTransporterCraneRecord::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FTransporterCraneRecord, MoveStartPosition) == 0x000008, "Member 'FTransporterCraneRecord::MoveStartPosition' has a wrong offset!");
static_assert(offsetof(FTransporterCraneRecord, MoveStartTime) == 0x00000C, "Member 'FTransporterCraneRecord::MoveStartTime' has a wrong offset!");

// ScriptStruct OakGame.WeightedTransporterCrane
// 0x0010 (0x0010 - 0x0000)
struct FWeightedTransporterCrane final
{
public:
	TSubclassOf<class ATransporterCrane>          Crane;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeightedTransporterCrane) == 0x000008, "Wrong alignment on FWeightedTransporterCrane");
static_assert(sizeof(FWeightedTransporterCrane) == 0x000010, "Wrong size on FWeightedTransporterCrane");
static_assert(offsetof(FWeightedTransporterCrane, Crane) == 0x000000, "Member 'FWeightedTransporterCrane::Crane' has a wrong offset!");
static_assert(offsetof(FWeightedTransporterCrane, Weight) == 0x000008, "Member 'FWeightedTransporterCrane::Weight' has a wrong offset!");

// ScriptStruct OakGame.TrophyCaseReplicatedBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FTrophyCaseReplicatedBase final
{
public:
	class FName                                   BaseTag;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CompletedProgressLevel;                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxProgressLevel;                                  // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrophyCaseReplicatedBase) == 0x000008, "Wrong alignment on FTrophyCaseReplicatedBase");
static_assert(sizeof(FTrophyCaseReplicatedBase) == 0x000010, "Wrong size on FTrophyCaseReplicatedBase");
static_assert(offsetof(FTrophyCaseReplicatedBase, BaseTag) == 0x000000, "Member 'FTrophyCaseReplicatedBase::BaseTag' has a wrong offset!");
static_assert(offsetof(FTrophyCaseReplicatedBase, CompletedProgressLevel) == 0x000008, "Member 'FTrophyCaseReplicatedBase::CompletedProgressLevel' has a wrong offset!");
static_assert(offsetof(FTrophyCaseReplicatedBase, MaxProgressLevel) == 0x000009, "Member 'FTrophyCaseReplicatedBase::MaxProgressLevel' has a wrong offset!");

// ScriptStruct OakGame.TrophyCaseReplicatedSet
// 0x0010 (0x0010 - 0x0000)
struct FTrophyCaseReplicatedSet final
{
public:
	TArray<struct FTrophyCaseReplicatedBase>      BaseData;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrophyCaseReplicatedSet) == 0x000008, "Wrong alignment on FTrophyCaseReplicatedSet");
static_assert(sizeof(FTrophyCaseReplicatedSet) == 0x000010, "Wrong size on FTrophyCaseReplicatedSet");
static_assert(offsetof(FTrophyCaseReplicatedSet, BaseData) == 0x000000, "Member 'FTrophyCaseReplicatedSet::BaseData' has a wrong offset!");

// ScriptStruct OakGame.ChallengeTrophy
// 0x0050 (0x0050 - 0x0000)
struct FChallengeTrophy final
{
public:
	class FText                                   TrophyName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TrophyDescription;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TrophyMesh;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UChallenge>                 AssociatedChallenge;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssociatedTrophyBaseTag;                           // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChallengeTrophyBaseComponent*          AssociatedTrophyBase;                              // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeTrophy) == 0x000008, "Wrong alignment on FChallengeTrophy");
static_assert(sizeof(FChallengeTrophy) == 0x000050, "Wrong size on FChallengeTrophy");
static_assert(offsetof(FChallengeTrophy, TrophyName) == 0x000000, "Member 'FChallengeTrophy::TrophyName' has a wrong offset!");
static_assert(offsetof(FChallengeTrophy, TrophyDescription) == 0x000018, "Member 'FChallengeTrophy::TrophyDescription' has a wrong offset!");
static_assert(offsetof(FChallengeTrophy, TrophyMesh) == 0x000030, "Member 'FChallengeTrophy::TrophyMesh' has a wrong offset!");
static_assert(offsetof(FChallengeTrophy, AssociatedChallenge) == 0x000038, "Member 'FChallengeTrophy::AssociatedChallenge' has a wrong offset!");
static_assert(offsetof(FChallengeTrophy, AssociatedTrophyBaseTag) == 0x000040, "Member 'FChallengeTrophy::AssociatedTrophyBaseTag' has a wrong offset!");
static_assert(offsetof(FChallengeTrophy, AssociatedTrophyBase) == 0x000048, "Member 'FChallengeTrophy::AssociatedTrophyBase' has a wrong offset!");

// ScriptStruct OakGame.ChallengeTrophyGroup
// 0x0048 (0x0048 - 0x0000)
struct FChallengeTrophyGroup final
{
public:
	class FText                                   TrophyGroupName;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TrophyGroupDescription;                            // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTrophyCaseBaseComponent*               AssociatedGroupBase;                               // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChallengeTrophy>               TrophyList;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeTrophyGroup) == 0x000008, "Wrong alignment on FChallengeTrophyGroup");
static_assert(sizeof(FChallengeTrophyGroup) == 0x000048, "Wrong size on FChallengeTrophyGroup");
static_assert(offsetof(FChallengeTrophyGroup, TrophyGroupName) == 0x000000, "Member 'FChallengeTrophyGroup::TrophyGroupName' has a wrong offset!");
static_assert(offsetof(FChallengeTrophyGroup, TrophyGroupDescription) == 0x000018, "Member 'FChallengeTrophyGroup::TrophyGroupDescription' has a wrong offset!");
static_assert(offsetof(FChallengeTrophyGroup, AssociatedGroupBase) == 0x000030, "Member 'FChallengeTrophyGroup::AssociatedGroupBase' has a wrong offset!");
static_assert(offsetof(FChallengeTrophyGroup, TrophyList) == 0x000038, "Member 'FChallengeTrophyGroup::TrophyList' has a wrong offset!");

// ScriptStruct OakGame.ChallengeTrophySet
// 0x0040 (0x0040 - 0x0000)
struct FChallengeTrophySet final
{
public:
	class FText                                   TrophySetName;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TrophySetDescription;                              // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FChallengeTrophyGroup>          TrophyGroupList;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeTrophySet) == 0x000008, "Wrong alignment on FChallengeTrophySet");
static_assert(sizeof(FChallengeTrophySet) == 0x000040, "Wrong size on FChallengeTrophySet");
static_assert(offsetof(FChallengeTrophySet, TrophySetName) == 0x000000, "Member 'FChallengeTrophySet::TrophySetName' has a wrong offset!");
static_assert(offsetof(FChallengeTrophySet, TrophySetDescription) == 0x000018, "Member 'FChallengeTrophySet::TrophySetDescription' has a wrong offset!");
static_assert(offsetof(FChallengeTrophySet, TrophyGroupList) == 0x000030, "Member 'FChallengeTrophySet::TrophyGroupList' has a wrong offset!");

// ScriptStruct OakGame.PlaythroughUnlockedData
// 0x0028 (0x0028 - 0x0000)
struct FPlaythroughUnlockedData final
{
public:
	TArray<class UTutorialMessageDataAsset*>      PlaythroughUnlockedMessages;                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGFxModalTutorialDataAsset*>     PlaythroughUnlockedMessages_Modal;                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseModalTutorial;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModalTutorialDelay;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlaythroughUnlockedData) == 0x000008, "Wrong alignment on FPlaythroughUnlockedData");
static_assert(sizeof(FPlaythroughUnlockedData) == 0x000028, "Wrong size on FPlaythroughUnlockedData");
static_assert(offsetof(FPlaythroughUnlockedData, PlaythroughUnlockedMessages) == 0x000000, "Member 'FPlaythroughUnlockedData::PlaythroughUnlockedMessages' has a wrong offset!");
static_assert(offsetof(FPlaythroughUnlockedData, PlaythroughUnlockedMessages_Modal) == 0x000010, "Member 'FPlaythroughUnlockedData::PlaythroughUnlockedMessages_Modal' has a wrong offset!");
static_assert(offsetof(FPlaythroughUnlockedData, bUseModalTutorial) == 0x000020, "Member 'FPlaythroughUnlockedData::bUseModalTutorial' has a wrong offset!");
static_assert(offsetof(FPlaythroughUnlockedData, ModalTutorialDelay) == 0x000024, "Member 'FPlaythroughUnlockedData::ModalTutorialDelay' has a wrong offset!");

// ScriptStruct OakGame.TutorialLevelUpData
// 0x0020 (0x0020 - 0x0000)
struct FTutorialLevelUpData final
{
public:
	class UTutorialMessageDataAsset*              LevelUpMessage;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxModalTutorialDataAsset*             LevelUpMessage_Modal;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelForMessage;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseModalTutorial;                                 // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModalTutorialDelay;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTutorialLevelUpData) == 0x000008, "Wrong alignment on FTutorialLevelUpData");
static_assert(sizeof(FTutorialLevelUpData) == 0x000020, "Wrong size on FTutorialLevelUpData");
static_assert(offsetof(FTutorialLevelUpData, LevelUpMessage) == 0x000000, "Member 'FTutorialLevelUpData::LevelUpMessage' has a wrong offset!");
static_assert(offsetof(FTutorialLevelUpData, LevelUpMessage_Modal) == 0x000008, "Member 'FTutorialLevelUpData::LevelUpMessage_Modal' has a wrong offset!");
static_assert(offsetof(FTutorialLevelUpData, LevelForMessage) == 0x000010, "Member 'FTutorialLevelUpData::LevelForMessage' has a wrong offset!");
static_assert(offsetof(FTutorialLevelUpData, bUseModalTutorial) == 0x000014, "Member 'FTutorialLevelUpData::bUseModalTutorial' has a wrong offset!");
static_assert(offsetof(FTutorialLevelUpData, ModalTutorialDelay) == 0x000018, "Member 'FTutorialLevelUpData::ModalTutorialDelay' has a wrong offset!");

// ScriptStruct OakGame.CurrencyInfo
// 0x0030 (0x0030 - 0x0000)
struct FCurrencyInfo final
{
public:
	class UInventoryCategoryData*                 ItemCategory;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IncStartAudioEvent;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IncStopAudioEvent;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecStartAudioEvent;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecStopAudioEvent;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrencyFrameName;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyInfo) == 0x000008, "Wrong alignment on FCurrencyInfo");
static_assert(sizeof(FCurrencyInfo) == 0x000030, "Wrong size on FCurrencyInfo");
static_assert(offsetof(FCurrencyInfo, ItemCategory) == 0x000000, "Member 'FCurrencyInfo::ItemCategory' has a wrong offset!");
static_assert(offsetof(FCurrencyInfo, IncStartAudioEvent) == 0x000008, "Member 'FCurrencyInfo::IncStartAudioEvent' has a wrong offset!");
static_assert(offsetof(FCurrencyInfo, IncStopAudioEvent) == 0x000010, "Member 'FCurrencyInfo::IncStopAudioEvent' has a wrong offset!");
static_assert(offsetof(FCurrencyInfo, DecStartAudioEvent) == 0x000018, "Member 'FCurrencyInfo::DecStartAudioEvent' has a wrong offset!");
static_assert(offsetof(FCurrencyInfo, DecStopAudioEvent) == 0x000020, "Member 'FCurrencyInfo::DecStopAudioEvent' has a wrong offset!");
static_assert(offsetof(FCurrencyInfo, CurrencyFrameName) == 0x000028, "Member 'FCurrencyInfo::CurrencyFrameName' has a wrong offset!");

// ScriptStruct OakGame.VehicleConfigurationEvent
// 0x0010 (0x0010 - 0x0000)
struct FVehicleConfigurationEvent final
{
public:
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioComponentTag;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleConfigurationEvent) == 0x000008, "Wrong alignment on FVehicleConfigurationEvent");
static_assert(sizeof(FVehicleConfigurationEvent) == 0x000010, "Wrong size on FVehicleConfigurationEvent");
static_assert(offsetof(FVehicleConfigurationEvent, WwiseEvent) == 0x000000, "Member 'FVehicleConfigurationEvent::WwiseEvent' has a wrong offset!");
static_assert(offsetof(FVehicleConfigurationEvent, AudioComponentTag) == 0x000008, "Member 'FVehicleConfigurationEvent::AudioComponentTag' has a wrong offset!");

// ScriptStruct OakGame.VehicleAudioLoopData
// 0x0010 (0x0010 - 0x0000)
struct FVehicleAudioLoopData final
{
public:
	class UWwiseEvent*                            LoopStart;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            LoopEnd;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleAudioLoopData) == 0x000008, "Wrong alignment on FVehicleAudioLoopData");
static_assert(sizeof(FVehicleAudioLoopData) == 0x000010, "Wrong size on FVehicleAudioLoopData");
static_assert(offsetof(FVehicleAudioLoopData, LoopStart) == 0x000000, "Member 'FVehicleAudioLoopData::LoopStart' has a wrong offset!");
static_assert(offsetof(FVehicleAudioLoopData, LoopEnd) == 0x000008, "Member 'FVehicleAudioLoopData::LoopEnd' has a wrong offset!");

// ScriptStruct OakGame.VehicleAudioLoopOnNamedCompData
// 0x0028 (0x0028 - 0x0000)
struct FVehicleAudioLoopOnNamedCompData final
{
public:
	struct FVehicleAudioLoopData                  AudioLoopData;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   AudioComponentTag;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FWwisePlaybackInstance>         PlaybackInstances;                                 // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FVehicleAudioLoopOnNamedCompData) == 0x000008, "Wrong alignment on FVehicleAudioLoopOnNamedCompData");
static_assert(sizeof(FVehicleAudioLoopOnNamedCompData) == 0x000028, "Wrong size on FVehicleAudioLoopOnNamedCompData");
static_assert(offsetof(FVehicleAudioLoopOnNamedCompData, AudioLoopData) == 0x000000, "Member 'FVehicleAudioLoopOnNamedCompData::AudioLoopData' has a wrong offset!");
static_assert(offsetof(FVehicleAudioLoopOnNamedCompData, AudioComponentTag) == 0x000010, "Member 'FVehicleAudioLoopOnNamedCompData::AudioComponentTag' has a wrong offset!");
static_assert(offsetof(FVehicleAudioLoopOnNamedCompData, PlaybackInstances) == 0x000018, "Member 'FVehicleAudioLoopOnNamedCompData::PlaybackInstances' has a wrong offset!");

// ScriptStruct OakGame.VehicleLandingEventData
// 0x0010 (0x0010 - 0x0000)
struct FVehicleLandingEventData final
{
public:
	class UWwiseEvent*                            LandingEvent;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeInAir;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleLandingEventData) == 0x000008, "Wrong alignment on FVehicleLandingEventData");
static_assert(sizeof(FVehicleLandingEventData) == 0x000010, "Wrong size on FVehicleLandingEventData");
static_assert(offsetof(FVehicleLandingEventData, LandingEvent) == 0x000000, "Member 'FVehicleLandingEventData::LandingEvent' has a wrong offset!");
static_assert(offsetof(FVehicleLandingEventData, MaxTimeInAir) == 0x000008, "Member 'FVehicleLandingEventData::MaxTimeInAir' has a wrong offset!");

// ScriptStruct OakGame.VehicleEffect
// 0x0010 (0x0010 - 0x0000)
struct FVehicleEffect final
{
public:
	class UBaseVehicleEffectData*                 EffectData;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleEffect) == 0x000008, "Wrong alignment on FVehicleEffect");
static_assert(sizeof(FVehicleEffect) == 0x000010, "Wrong size on FVehicleEffect");
static_assert(offsetof(FVehicleEffect, EffectData) == 0x000000, "Member 'FVehicleEffect::EffectData' has a wrong offset!");

// ScriptStruct OakGame.VehicleImpactEffectData
// 0x0028 (0x0028 - 0x0000)
struct FVehicleImpactEffectData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFilteredImpactData>            FilteredImpactData;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleImpactEffectData) == 0x000008, "Wrong alignment on FVehicleImpactEffectData");
static_assert(sizeof(FVehicleImpactEffectData) == 0x000028, "Wrong size on FVehicleImpactEffectData");
static_assert(offsetof(FVehicleImpactEffectData, FilteredImpactData) == 0x000018, "Member 'FVehicleImpactEffectData::FilteredImpactData' has a wrong offset!");

// ScriptStruct OakGame.EmitterEnableData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEmitterEnableData final
{
public:
	class FName                                   EmitterName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterEnableMode                            EnableMode;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterEnableData) == 0x000008, "Wrong alignment on FEmitterEnableData");
static_assert(sizeof(FEmitterEnableData) == 0x000010, "Wrong size on FEmitterEnableData");
static_assert(offsetof(FEmitterEnableData, EmitterName) == 0x000000, "Member 'FEmitterEnableData::EmitterName' has a wrong offset!");
static_assert(offsetof(FEmitterEnableData, EnableMode) == 0x000008, "Member 'FEmitterEnableData::EnableMode' has a wrong offset!");

// ScriptStruct OakGame.VehicleEffectQueryData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FVehicleEffectQueryData final
{
public:
	class FName                                   Event;                                             // 0x0000(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVehicleEffectEvent                           EffectEvent;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ComponentTag;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleEffectQueryData) == 0x000008, "Wrong alignment on FVehicleEffectQueryData");
static_assert(sizeof(FVehicleEffectQueryData) == 0x000018, "Wrong size on FVehicleEffectQueryData");
static_assert(offsetof(FVehicleEffectQueryData, Event) == 0x000000, "Member 'FVehicleEffectQueryData::Event' has a wrong offset!");
static_assert(offsetof(FVehicleEffectQueryData, EffectEvent) == 0x000008, "Member 'FVehicleEffectQueryData::EffectEvent' has a wrong offset!");
static_assert(offsetof(FVehicleEffectQueryData, ComponentTag) == 0x000010, "Member 'FVehicleEffectQueryData::ComponentTag' has a wrong offset!");

// ScriptStruct OakGame.UseCharacterWeaponSettings
// 0x0004 (0x0004 - 0x0000)
struct FUseCharacterWeaponSettings final
{
public:
	float                                         ShootMaxAngle;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUseCharacterWeaponSettings) == 0x000004, "Wrong alignment on FUseCharacterWeaponSettings");
static_assert(sizeof(FUseCharacterWeaponSettings) == 0x000004, "Wrong size on FUseCharacterWeaponSettings");
static_assert(offsetof(FUseCharacterWeaponSettings, ShootMaxAngle) == 0x000000, "Member 'FUseCharacterWeaponSettings::ShootMaxAngle' has a wrong offset!");

// ScriptStruct OakGame.VendingMachinePhysicalShelf
// 0x0030 (0x0030 - 0x0000)
struct FVendingMachinePhysicalShelf final
{
public:
	class UStaticMeshComponent*                   ShelfMeshComponent;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ClickCollisionComponent;                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ItemScoreParticleComponent;                        // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               SoldOutParticleComponent;                          // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVendingMachinePhysicalShelf) == 0x000008, "Wrong alignment on FVendingMachinePhysicalShelf");
static_assert(sizeof(FVendingMachinePhysicalShelf) == 0x000030, "Wrong size on FVendingMachinePhysicalShelf");
static_assert(offsetof(FVendingMachinePhysicalShelf, ShelfMeshComponent) == 0x000000, "Member 'FVendingMachinePhysicalShelf::ShelfMeshComponent' has a wrong offset!");
static_assert(offsetof(FVendingMachinePhysicalShelf, ClickCollisionComponent) == 0x000008, "Member 'FVendingMachinePhysicalShelf::ClickCollisionComponent' has a wrong offset!");
static_assert(offsetof(FVendingMachinePhysicalShelf, ItemScoreParticleComponent) == 0x000010, "Member 'FVendingMachinePhysicalShelf::ItemScoreParticleComponent' has a wrong offset!");
static_assert(offsetof(FVendingMachinePhysicalShelf, SoldOutParticleComponent) == 0x000018, "Member 'FVendingMachinePhysicalShelf::SoldOutParticleComponent' has a wrong offset!");
static_assert(offsetof(FVendingMachinePhysicalShelf, MaterialInstance) == 0x000020, "Member 'FVendingMachinePhysicalShelf::MaterialInstance' has a wrong offset!");

// ScriptStruct OakGame.WeaponUseModeAspectSetData
// 0x0038 (0x0038 - 0x0000)
struct FWeaponUseModeAspectSetData final
{
public:
	class UWeaponUseModeAspectData*               Aspect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWeaponUseModeSecondaryAspectData*> SecondaryAspectList;                               // 0x0008(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	class UWeaponDamageTypeAspectData*            DamageTypeAspect[0x2];                             // 0x0018(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponUseModeNameAspectData*           NameAspect;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponUseModeCrosshairAspectData*      CrosshairAspect;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponUseModeAspectSetData) == 0x000008, "Wrong alignment on FWeaponUseModeAspectSetData");
static_assert(sizeof(FWeaponUseModeAspectSetData) == 0x000038, "Wrong size on FWeaponUseModeAspectSetData");
static_assert(offsetof(FWeaponUseModeAspectSetData, Aspect) == 0x000000, "Member 'FWeaponUseModeAspectSetData::Aspect' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeAspectSetData, SecondaryAspectList) == 0x000008, "Member 'FWeaponUseModeAspectSetData::SecondaryAspectList' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeAspectSetData, DamageTypeAspect) == 0x000018, "Member 'FWeaponUseModeAspectSetData::DamageTypeAspect' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeAspectSetData, NameAspect) == 0x000028, "Member 'FWeaponUseModeAspectSetData::NameAspect' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeAspectSetData, CrosshairAspect) == 0x000030, "Member 'FWeaponUseModeAspectSetData::CrosshairAspect' has a wrong offset!");

// ScriptStruct OakGame.WeaponBonusDataTableColumnCollectionData
// 0x0028 (0x0028 - 0x0000)
struct FWeaponBonusDataTableColumnCollectionData final
{
public:
	class FName                                   CollectionName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         ColumnNames;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponBonusDataTableColumnCollectionData) == 0x000008, "Wrong alignment on FWeaponBonusDataTableColumnCollectionData");
static_assert(sizeof(FWeaponBonusDataTableColumnCollectionData) == 0x000028, "Wrong size on FWeaponBonusDataTableColumnCollectionData");
static_assert(offsetof(FWeaponBonusDataTableColumnCollectionData, CollectionName) == 0x000000, "Member 'FWeaponBonusDataTableColumnCollectionData::CollectionName' has a wrong offset!");
static_assert(offsetof(FWeaponBonusDataTableColumnCollectionData, ColumnNames) == 0x000008, "Member 'FWeaponBonusDataTableColumnCollectionData::ColumnNames' has a wrong offset!");

// ScriptStruct OakGame.COVBrokenEffectData
// 0x0020 (0x0020 - 0x0000)
struct FCOVBrokenEffectData final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HiddenBone;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEffectType                             BreakEffectType;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BreakEffectID;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEffectType                             BrokenEffectType;                                  // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BrokenEffectID;                                    // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAmpEffect;                                    // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCOVBrokenEffectData) == 0x000008, "Wrong alignment on FCOVBrokenEffectData");
static_assert(sizeof(FCOVBrokenEffectData) == 0x000020, "Wrong size on FCOVBrokenEffectData");
static_assert(offsetof(FCOVBrokenEffectData, Mesh) == 0x000000, "Member 'FCOVBrokenEffectData::Mesh' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, AttachSocket) == 0x000008, "Member 'FCOVBrokenEffectData::AttachSocket' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, HiddenBone) == 0x000010, "Member 'FCOVBrokenEffectData::HiddenBone' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, BreakEffectType) == 0x000018, "Member 'FCOVBrokenEffectData::BreakEffectType' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, BreakEffectID) == 0x000019, "Member 'FCOVBrokenEffectData::BreakEffectID' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, BrokenEffectType) == 0x00001A, "Member 'FCOVBrokenEffectData::BrokenEffectType' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, BrokenEffectID) == 0x00001B, "Member 'FCOVBrokenEffectData::BrokenEffectID' has a wrong offset!");
static_assert(offsetof(FCOVBrokenEffectData, bHideAmpEffect) == 0x00001C, "Member 'FCOVBrokenEffectData::bHideAmpEffect' has a wrong offset!");

// ScriptStruct OakGame.WeightedFloatRange
// 0x0040 (0x0040 - 0x0000)
struct FWeightedFloatRange final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Weight;                                            // 0x0008(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWeightedFloatRange) == 0x000008, "Wrong alignment on FWeightedFloatRange");
static_assert(sizeof(FWeightedFloatRange) == 0x000040, "Wrong size on FWeightedFloatRange");
static_assert(offsetof(FWeightedFloatRange, MinValue) == 0x000000, "Member 'FWeightedFloatRange::MinValue' has a wrong offset!");
static_assert(offsetof(FWeightedFloatRange, MaxValue) == 0x000004, "Member 'FWeightedFloatRange::MaxValue' has a wrong offset!");
static_assert(offsetof(FWeightedFloatRange, Weight) == 0x000008, "Member 'FWeightedFloatRange::Weight' has a wrong offset!");

// ScriptStruct OakGame.WeaponVehicleAnimInstanceProxy
// 0x00C0 (0x0780 - 0x06C0)
struct FWeaponVehicleAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_6C0[0xC0];                                     // 0x06C0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponVehicleAnimInstanceProxy) == 0x000010, "Wrong alignment on FWeaponVehicleAnimInstanceProxy");
static_assert(sizeof(FWeaponVehicleAnimInstanceProxy) == 0x000780, "Wrong size on FWeaponVehicleAnimInstanceProxy");

// ScriptStruct OakGame.ZoneMapMissionPOIBlacklistEntry
// 0x0058 (0x0058 - 0x0000)
struct FZoneMapMissionPOIBlacklistEntry final
{
public:
	TSoftClassPtr<class UClass>                   BlacklistedCharacter;                              // 0x0000(0x0028)(Deprecated, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BlacklistedCharacterPath;                          // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          MissionBlacklistCondition;                         // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlacklistMissionGiving;                           // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          ObjectiveBlacklistCondition;                       // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlacklistObjectiveWaypoint;                       // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneMapMissionPOIBlacklistEntry) == 0x000008, "Wrong alignment on FZoneMapMissionPOIBlacklistEntry");
static_assert(sizeof(FZoneMapMissionPOIBlacklistEntry) == 0x000058, "Wrong size on FZoneMapMissionPOIBlacklistEntry");
static_assert(offsetof(FZoneMapMissionPOIBlacklistEntry, BlacklistedCharacter) == 0x000000, "Member 'FZoneMapMissionPOIBlacklistEntry::BlacklistedCharacter' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionPOIBlacklistEntry, BlacklistedCharacterPath) == 0x000028, "Member 'FZoneMapMissionPOIBlacklistEntry::BlacklistedCharacterPath' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionPOIBlacklistEntry, MissionBlacklistCondition) == 0x000038, "Member 'FZoneMapMissionPOIBlacklistEntry::MissionBlacklistCondition' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionPOIBlacklistEntry, bBlacklistMissionGiving) == 0x000040, "Member 'FZoneMapMissionPOIBlacklistEntry::bBlacklistMissionGiving' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionPOIBlacklistEntry, ObjectiveBlacklistCondition) == 0x000048, "Member 'FZoneMapMissionPOIBlacklistEntry::ObjectiveBlacklistCondition' has a wrong offset!");
static_assert(offsetof(FZoneMapMissionPOIBlacklistEntry, bBlacklistObjectiveWaypoint) == 0x000050, "Member 'FZoneMapMissionPOIBlacklistEntry::bBlacklistObjectiveWaypoint' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapChallengeGroupEntry
// 0x0020 (0x0020 - 0x0000)
struct FZoneMapChallengeGroupEntry final
{
public:
	class UChallengeCategoryData*                 ChallengeGroup;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UChallenge>>         ChallengesInGroup;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         NumChallengesInCategory;                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChallengesVisibleInUI;                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapChallengeGroupEntry) == 0x000008, "Wrong alignment on FZoneMapChallengeGroupEntry");
static_assert(sizeof(FZoneMapChallengeGroupEntry) == 0x000020, "Wrong size on FZoneMapChallengeGroupEntry");
static_assert(offsetof(FZoneMapChallengeGroupEntry, ChallengeGroup) == 0x000000, "Member 'FZoneMapChallengeGroupEntry::ChallengeGroup' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeGroupEntry, ChallengesInGroup) == 0x000008, "Member 'FZoneMapChallengeGroupEntry::ChallengesInGroup' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeGroupEntry, NumChallengesInCategory) == 0x000018, "Member 'FZoneMapChallengeGroupEntry::NumChallengesInCategory' has a wrong offset!");
static_assert(offsetof(FZoneMapChallengeGroupEntry, NumChallengesVisibleInUI) == 0x00001C, "Member 'FZoneMapChallengeGroupEntry::NumChallengesVisibleInUI' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapDataSection
// 0x0040 (0x0040 - 0x0000)
struct FZoneMapDataSection final
{
public:
	class FString                                 ZoneMapSectionObjectName;                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SectionName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extents;                                           // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapDataSection) == 0x000008, "Wrong alignment on FZoneMapDataSection");
static_assert(sizeof(FZoneMapDataSection) == 0x000040, "Wrong size on FZoneMapDataSection");
static_assert(offsetof(FZoneMapDataSection, ZoneMapSectionObjectName) == 0x000000, "Member 'FZoneMapDataSection::ZoneMapSectionObjectName' has a wrong offset!");
static_assert(offsetof(FZoneMapDataSection, SectionName) == 0x000010, "Member 'FZoneMapDataSection::SectionName' has a wrong offset!");
static_assert(offsetof(FZoneMapDataSection, Origin) == 0x000028, "Member 'FZoneMapDataSection::Origin' has a wrong offset!");
static_assert(offsetof(FZoneMapDataSection, Extents) == 0x000034, "Member 'FZoneMapDataSection::Extents' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapGPUPointCloudData
// 0x0010 (0x0010 - 0x0000)
struct FZoneMapGPUPointCloudData final
{
public:
	class UTexture*                               PositionData;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               NormalsData;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZoneMapGPUPointCloudData) == 0x000008, "Wrong alignment on FZoneMapGPUPointCloudData");
static_assert(sizeof(FZoneMapGPUPointCloudData) == 0x000010, "Wrong size on FZoneMapGPUPointCloudData");
static_assert(offsetof(FZoneMapGPUPointCloudData, PositionData) == 0x000000, "Member 'FZoneMapGPUPointCloudData::PositionData' has a wrong offset!");
static_assert(offsetof(FZoneMapGPUPointCloudData, NormalsData) == 0x000008, "Member 'FZoneMapGPUPointCloudData::NormalsData' has a wrong offset!");

// ScriptStruct OakGame.ZoneMapMeshListEntry
// 0x0038 (0x0038 - 0x0000)
struct FZoneMapMeshListEntry final
{
public:
	class UStaticMesh*                            ZoneMapMesh;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ZoneMapVisibilityExtents;                          // 0x0008(0x001C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          MeshDisplayCondition;                              // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConditionalMeshDisplay;                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneMapMeshListEntry) == 0x000008, "Wrong alignment on FZoneMapMeshListEntry");
static_assert(sizeof(FZoneMapMeshListEntry) == 0x000038, "Wrong size on FZoneMapMeshListEntry");
static_assert(offsetof(FZoneMapMeshListEntry, ZoneMapMesh) == 0x000000, "Member 'FZoneMapMeshListEntry::ZoneMapMesh' has a wrong offset!");
static_assert(offsetof(FZoneMapMeshListEntry, ZoneMapVisibilityExtents) == 0x000008, "Member 'FZoneMapMeshListEntry::ZoneMapVisibilityExtents' has a wrong offset!");
static_assert(offsetof(FZoneMapMeshListEntry, MeshDisplayCondition) == 0x000028, "Member 'FZoneMapMeshListEntry::MeshDisplayCondition' has a wrong offset!");
static_assert(offsetof(FZoneMapMeshListEntry, bConditionalMeshDisplay) == 0x000030, "Member 'FZoneMapMeshListEntry::bConditionalMeshDisplay' has a wrong offset!");

// ScriptStruct OakGame.PlanetZonePOI
// 0x0010 (0x0010 - 0x0000)
struct FPlanetZonePOI final
{
public:
	class UZoneMapData*                           ZoneReference;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ZoneMeshOnPlanet;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlanetZonePOI) == 0x000008, "Wrong alignment on FPlanetZonePOI");
static_assert(sizeof(FPlanetZonePOI) == 0x000010, "Wrong size on FPlanetZonePOI");
static_assert(offsetof(FPlanetZonePOI, ZoneReference) == 0x000000, "Member 'FPlanetZonePOI::ZoneReference' has a wrong offset!");
static_assert(offsetof(FPlanetZonePOI, ZoneMeshOnPlanet) == 0x000008, "Member 'FPlanetZonePOI::ZoneMeshOnPlanet' has a wrong offset!");

}

