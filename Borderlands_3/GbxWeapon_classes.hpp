#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxWeapon

#include "Basic.hpp"

#include "GbxWeapon_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "GbxRuntime_structs.hpp"
#include "GbxRuntime_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class GbxWeapon.BodyWeaponHoldData
// 0x0030 (0x0060 - 0x0030)
class UBodyWeaponHoldData final : public UGbxDataAsset
{
public:
	class FName                                   HoldName;                                          // 0x0030(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           HoldNames;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBodyWeaponActionInfo>          WeaponActions;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         DepthOfFieldForegroundFocusDistance;               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DepthOfFieldForegroundFocusNearRegionPct;          // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodyWeaponHoldData">();
	}
	static class UBodyWeaponHoldData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodyWeaponHoldData>();
	}
};
static_assert(alignof(UBodyWeaponHoldData) == 0x000008, "Wrong alignment on UBodyWeaponHoldData");
static_assert(sizeof(UBodyWeaponHoldData) == 0x000060, "Wrong size on UBodyWeaponHoldData");
static_assert(offsetof(UBodyWeaponHoldData, HoldName) == 0x000030, "Member 'UBodyWeaponHoldData::HoldName' has a wrong offset!");
static_assert(offsetof(UBodyWeaponHoldData, HoldNames) == 0x000038, "Member 'UBodyWeaponHoldData::HoldNames' has a wrong offset!");
static_assert(offsetof(UBodyWeaponHoldData, WeaponActions) == 0x000048, "Member 'UBodyWeaponHoldData::WeaponActions' has a wrong offset!");
static_assert(offsetof(UBodyWeaponHoldData, DepthOfFieldForegroundFocusDistance) == 0x000058, "Member 'UBodyWeaponHoldData::DepthOfFieldForegroundFocusDistance' has a wrong offset!");
static_assert(offsetof(UBodyWeaponHoldData, DepthOfFieldForegroundFocusNearRegionPct) == 0x00005C, "Member 'UBodyWeaponHoldData::DepthOfFieldForegroundFocusNearRegionPct' has a wrong offset!");

// Class GbxWeapon.Weapon
// 0x0480 (0x08D8 - 0x0458)
class AWeapon : public AActor
{
public:
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponFireComponent*                   CurrentFireComponent;                              // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTypeAsset*                       WeaponDisplayData;                                 // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponTypeData*                        WeaponType;                                        // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     SwitchModeTimeScale;                               // 0x0488(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchModeTime;                                    // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchModeCompletePercent;                         // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IGbxWeaponUserInterface> WeaponUser;                                        // 0x04A0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   BegunPlay;                                         // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyGivenTo;                                     // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyAttached;                                    // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyDetached;                                    // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyEquipped;                                    // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyPutDown;                                     // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifySwitchedMode;                                // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyFirstPersonCreated;                          // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyUseInput;                                    // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyReloadStarted;                               // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyReloadEnded;                                 // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyTargetLockChanged;                           // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyHidden;                                      // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         PostSprintDelayUseTime;                            // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewModelFOV;                                      // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldZoomedForegroundNearRegion;            // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageScaleConditionalData>    DamageScaleConditionals;                           // 0x0590(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxObjectReplicatorProxy              ReplicationProxy;                                  // 0x05A0(0x0068)(Net, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponAttachState                     PendingAttachState;                                // 0x0610(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponAttachState                     AttachState;                                       // 0x0628(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     EquipTime;                                         // 0x0640(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64C[0x18];                                     // 0x064C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     PutDownTime;                                       // 0x0664(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_670[0xA];                                      // 0x0670(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         PendingUseModeIndex;                               // 0x067A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67B[0x15];                                     // 0x067B(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         CurrentUseModeIndex;                               // 0x0690(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CurrentSlotIndex;                                  // 0x0691(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NextSlotIndex;                                     // 0x0692(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_693[0x5];                                      // 0x0693(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponUseModeState>            UseModeState;                                      // 0x0698(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A8[0x28];                                     // 0x06A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimAssistParameters*                   AimAssetParameters;                                // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargetLocked;                                   // 0x06D8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D9[0x3];                                      // 0x06D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        AttributeResolverUseModeBitmask;                   // 0x06DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceUnzoomWhenSwitchingModes;                    // 0x06F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F1[0xF];                                      // 0x06F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWeaponAttachmentSlot*>          AttachmentSlots3P;                                 // 0x0700(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UWeaponAttachmentSlot*>          AttachmentSlots1P;                                 // 0x0710(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bWeaponAttached;                                   // 0x0720(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_721[0x7];                                      // 0x0721(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponRegisterMaterialEffectData> RegisteredMaterialEffects;                         // 0x0728(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_738[0x58];                                     // 0x0738(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponRegisterSkeletalControlData> RegisteredSkeletalControls;                        // 0x0790(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x8];                                      // 0x07A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponTriggerFeedbackAsset*            CachedFireTriggerFeedback;                         // 0x07A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponTriggerFeedbackAsset*            CachedZoomTriggerFeedback;                         // 0x07B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowCrosshair;                                    // 0x07B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysTickAttachedMeshes;                         // 0x07B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BA[0x6];                                      // 0x07BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BodyWeaponHoldName;                                // 0x07C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AnimSetGenericNames;                               // 0x07C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageModifierComponent>   DamageModifierCompClass;                           // 0x07E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E8[0x10];                                     // 0x07E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentState;                                      // 0x07F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_800[0x98];                                     // 0x0800(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponRegisterAttachmentEffectData> UnregisteredFirstPersonOnlyAttachmentEffects;      // 0x0898(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     UseModeIcons;                                      // 0x08A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         UseModeIconFrameNames;                             // 0x08B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   MainHandGripSocketName;                            // 0x08C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OffHandGripSocketName;                             // 0x08D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Activate(class APawn* WeaponOwner, uint8 InSlot, EWeaponEquipType InEquipType);
	uint8 AddUseMode(class UWeaponUseComponent* UseComponent, const TArray<class UActorComponent*>& OtherComponents, int32 InputChannels);
	void ClientLock(float Duration);
	void ClientStopReloading();
	void ClientUnlock();
	void CycleZoomLevel();
	void Dropped();
	void EquipInterruptible();
	void GivenTo(class APawn* NewOwner);
	class UGbxAction* K2_PlayWeaponAction(EWeaponActionType WeaponAction, float PlayRate, float Duration, bool bCheckForRelevancy);
	class UGbxAction* K2_PlayWeaponActionEx(EWeaponActionType WeaponAction, const struct FActionState_Base& ActionParams, bool bCheckForRelevancy);
	void K2_StopWeaponActionObj(class UGbxAction* WeaponAction);
	void Lock(float Duration, bool bReplicate);
	void NextZoomLevel();
	void NotifySkeletalControl(EWeaponEffectType ControlType, class FName ControlName, EWeaponSkeletalControlEvent Event, float EventValue);
	void OnAmmoGivenToEmptyWeapon();
	void OnReloadEnded(bool bCompleted);
	void OnRep_CurrentUseModeIndex(uint8 PreviousUseModeIndex);
	void OnRep_PendingAttachState();
	void OnRep_PendingUseModeIndex();
	void OnRep_TargetLockedChanged();
	void OnUpdateSkeletalControlsWhenAmmoChanges();
	void OnUpdateSkeletalControlsWhenUsed();
	void OnUpdateSkeletalControlsWhenUseFinishes();
	void OnUseFinished();
	void OnUseStarted();
	void OnZoomedOut();
	float PlayAnimation(class UAnimMontage* Anim, bool bFirstPerson, float PlayRate, float Duration);
	int32 PlayDynamicMaterialEffect(const struct FWeaponMaterialEffectData& Data);
	void PlayEffects(EWeaponEffectType EffectType, uint8 UseModeIndex, int32 EffectID);
	void PrevZoomLevel();
	void ReevaluateConditionalEffects();
	void RegisterEffect(const struct FWeaponRegisterAttachmentEffectData& Data);
	void RegisterMaterialEffect(const struct FWeaponRegisterMaterialEffectData& Data);
	void RegisterSimpleEffect(EWeaponEffectType EffectType, class UParticleSystem* Effect, class FName EffectSocket);
	void RegisterSkeletalControl(const struct FWeaponRegisterSkeletalControlData& Data);
	void RegisterTrinketAttachment(const struct FWeaponRegisterTrinketAttachmentData& Data);
	void ServerEquipInterruptible();
	void ServerInterruptReloadToUse(int32 ClientLoadedAmmo);
	void ServerLock(float Duration);
	void ServerRestartAutoUse();
	void ServerSetPatternSeed(uint8 ClientPatternSeed);
	void ServerSetZoomState(uint8 UseModeIndex, const struct FWeaponZoomState& NewState, float ZoomStartOffset);
	void ServerStartReloading(uint8 UseModeIndex, bool bAuto);
	void ServerStartUsing(uint8 InputChannel, uint8 ClientPatternSeed);
	void ServerStopModeSwitch(uint8 InputChannel, uint8 ClientUseModeIndex);
	void ServerStopUsing(uint8 InputChannel, bool bForced);
	void ServerSwitchMode(uint8 InputChannel, uint8 NextUseModeIndex, bool bForced);
	void ServerUnlock();
	void SetBoneVisibility(class FName BoneName, bool bVisible, EWeaponAttachmentVisibilityType AttachmentType);
	void SetEffectColorParameter(class FName ParamName, const struct FLinearColor& ParamValue, const struct FWeaponEffectQueryData& QueryData);
	void SetEffectEmitterState(class FName EmitterName, bool bEnabled, const struct FWeaponEffectQueryData& QueryData);
	void SetEffectFloatParameter(class FName ParamName, float ParamValue, const struct FWeaponEffectQueryData& QueryData);
	void SetEffectMaterialParameter(class FName ParamName, class UMaterialInterface* ParamValue, const struct FWeaponEffectQueryData& QueryData);
	void SetEffectVectorParameter(class FName ParamName, const struct FVector& ParamValue, const struct FWeaponEffectQueryData& QueryData);
	void SetMaterialScalarParameterValue(class FName ParamName, float ParamValue);
	void SetMaterialVectorParameterValue(class FName ParamName, const struct FLinearColor& ParamValue);
	void SetPreUseState(uint8 UseModeIndex, bool bEnabled);
	void SetTargetLocked(bool bIsLocked);
	void StartReloading(bool bAuto);
	void StartUsing(uint8 InputChannel);
	void StartZooming();
	void StopAnimation(class UAnimMontage* Anim, bool bFirstPerson);
	void StopDynamicMaterialEffect(int32 EffectID);
	void StopEffects(EWeaponEffectType EffectType, uint8 UseModeIndex);
	void StopModeSwitch();
	void StopReloading();
	void StopUsing(uint8 InputChannel, bool bForced);
	void StopWeaponAction(EWeaponActionType WeaponAction);
	void StopZooming(bool bSkipTransitions, bool bClearInput);
	void SwitchMode(uint8 InputChannel, uint8 NextUseModeIndex, bool bForced);
	void SwitchPendingUseMode();
	void ToggleMode(uint8 InputChannel);
	void TryAutoReload();
	void Unlock(bool bReplicate);

	class UAimAssistParameters* GetAimAssistParameters() const;
	class UActorComponent* GetAssociatedUseModeComponentByClass(TSubclassOf<class UActorComponent> ComponentClass, class UActorComponent* ReferenceComponent) const;
	class UMeshComponent* GetAttachmentMesh(bool bFirstPerson, uint8 SlotIndex) const;
	uint8 GetCurrentReloadPartType() const;
	uint8 GetLastInputChannel() const;
	float GetMaxZoomFOVScale() const;
	float GetMuteADSAlpha() const;
	class UActorComponent* GetUseModeComponentByClass(TSubclassOf<class UActorComponent> ComponentClass, uint8 UseModeIndex) const;
	float GetZoomDuration() const;
	float GetZoomEffect() const;
	float GetZoomFOVScale() const;
	bool IsActive() const;
	bool IsAuthorityEquipping() const;
	bool IsAuthorityPuttingDown() const;
	bool IsAuthorityReloading() const;
	bool IsAuthoritySwitchingModes() const;
	bool IsAuthorityUsing() const;
	bool IsEquipping() const;
	bool IsInactive() const;
	bool IsLocalAuthority() const;
	bool IsLocked() const;
	bool IsPendingUse(uint8 InputChannel) const;
	bool IsPuttingDown() const;
	bool IsReloading() const;
	bool IsSwitchingModes() const;
	bool IsTargetLocked() const;
	bool IsUsing() const;
	bool IsZoomed() const;
	bool IsZoomedIn(bool bIncludeTransitions) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Weapon">();
	}
	static class AWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeapon>();
	}
};
static_assert(alignof(AWeapon) == 0x000008, "Wrong alignment on AWeapon");
static_assert(sizeof(AWeapon) == 0x0008D8, "Wrong size on AWeapon");
static_assert(offsetof(AWeapon, CurrentFireComponent) == 0x000470, "Member 'AWeapon::CurrentFireComponent' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponDisplayData) == 0x000478, "Member 'AWeapon::WeaponDisplayData' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponType) == 0x000480, "Member 'AWeapon::WeaponType' has a wrong offset!");
static_assert(offsetof(AWeapon, SwitchModeTimeScale) == 0x000488, "Member 'AWeapon::SwitchModeTimeScale' has a wrong offset!");
static_assert(offsetof(AWeapon, SwitchModeTime) == 0x000494, "Member 'AWeapon::SwitchModeTime' has a wrong offset!");
static_assert(offsetof(AWeapon, SwitchModeCompletePercent) == 0x000498, "Member 'AWeapon::SwitchModeCompletePercent' has a wrong offset!");
static_assert(offsetof(AWeapon, WeaponUser) == 0x0004A0, "Member 'AWeapon::WeaponUser' has a wrong offset!");
static_assert(offsetof(AWeapon, BegunPlay) == 0x0004B0, "Member 'AWeapon::BegunPlay' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyGivenTo) == 0x0004C0, "Member 'AWeapon::NotifyGivenTo' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyAttached) == 0x0004D0, "Member 'AWeapon::NotifyAttached' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyDetached) == 0x0004E0, "Member 'AWeapon::NotifyDetached' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyEquipped) == 0x0004F0, "Member 'AWeapon::NotifyEquipped' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyPutDown) == 0x000500, "Member 'AWeapon::NotifyPutDown' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifySwitchedMode) == 0x000510, "Member 'AWeapon::NotifySwitchedMode' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyFirstPersonCreated) == 0x000520, "Member 'AWeapon::NotifyFirstPersonCreated' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyUseInput) == 0x000530, "Member 'AWeapon::NotifyUseInput' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyReloadStarted) == 0x000540, "Member 'AWeapon::NotifyReloadStarted' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyReloadEnded) == 0x000550, "Member 'AWeapon::NotifyReloadEnded' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyTargetLockChanged) == 0x000560, "Member 'AWeapon::NotifyTargetLockChanged' has a wrong offset!");
static_assert(offsetof(AWeapon, NotifyHidden) == 0x000570, "Member 'AWeapon::NotifyHidden' has a wrong offset!");
static_assert(offsetof(AWeapon, PostSprintDelayUseTime) == 0x000580, "Member 'AWeapon::PostSprintDelayUseTime' has a wrong offset!");
static_assert(offsetof(AWeapon, ViewModelFOV) == 0x000584, "Member 'AWeapon::ViewModelFOV' has a wrong offset!");
static_assert(offsetof(AWeapon, DepthOfFieldZoomedForegroundNearRegion) == 0x000588, "Member 'AWeapon::DepthOfFieldZoomedForegroundNearRegion' has a wrong offset!");
static_assert(offsetof(AWeapon, DamageScaleConditionals) == 0x000590, "Member 'AWeapon::DamageScaleConditionals' has a wrong offset!");
static_assert(offsetof(AWeapon, ReplicationProxy) == 0x0005A0, "Member 'AWeapon::ReplicationProxy' has a wrong offset!");
static_assert(offsetof(AWeapon, PendingAttachState) == 0x000610, "Member 'AWeapon::PendingAttachState' has a wrong offset!");
static_assert(offsetof(AWeapon, AttachState) == 0x000628, "Member 'AWeapon::AttachState' has a wrong offset!");
static_assert(offsetof(AWeapon, EquipTime) == 0x000640, "Member 'AWeapon::EquipTime' has a wrong offset!");
static_assert(offsetof(AWeapon, PutDownTime) == 0x000664, "Member 'AWeapon::PutDownTime' has a wrong offset!");
static_assert(offsetof(AWeapon, PendingUseModeIndex) == 0x00067A, "Member 'AWeapon::PendingUseModeIndex' has a wrong offset!");
static_assert(offsetof(AWeapon, CurrentUseModeIndex) == 0x000690, "Member 'AWeapon::CurrentUseModeIndex' has a wrong offset!");
static_assert(offsetof(AWeapon, CurrentSlotIndex) == 0x000691, "Member 'AWeapon::CurrentSlotIndex' has a wrong offset!");
static_assert(offsetof(AWeapon, NextSlotIndex) == 0x000692, "Member 'AWeapon::NextSlotIndex' has a wrong offset!");
static_assert(offsetof(AWeapon, UseModeState) == 0x000698, "Member 'AWeapon::UseModeState' has a wrong offset!");
static_assert(offsetof(AWeapon, AimAssetParameters) == 0x0006D0, "Member 'AWeapon::AimAssetParameters' has a wrong offset!");
static_assert(offsetof(AWeapon, bIsTargetLocked) == 0x0006D8, "Member 'AWeapon::bIsTargetLocked' has a wrong offset!");
static_assert(offsetof(AWeapon, AttributeResolverUseModeBitmask) == 0x0006DC, "Member 'AWeapon::AttributeResolverUseModeBitmask' has a wrong offset!");
static_assert(offsetof(AWeapon, bForceUnzoomWhenSwitchingModes) == 0x0006F0, "Member 'AWeapon::bForceUnzoomWhenSwitchingModes' has a wrong offset!");
static_assert(offsetof(AWeapon, AttachmentSlots3P) == 0x000700, "Member 'AWeapon::AttachmentSlots3P' has a wrong offset!");
static_assert(offsetof(AWeapon, AttachmentSlots1P) == 0x000710, "Member 'AWeapon::AttachmentSlots1P' has a wrong offset!");
static_assert(offsetof(AWeapon, bWeaponAttached) == 0x000720, "Member 'AWeapon::bWeaponAttached' has a wrong offset!");
static_assert(offsetof(AWeapon, RegisteredMaterialEffects) == 0x000728, "Member 'AWeapon::RegisteredMaterialEffects' has a wrong offset!");
static_assert(offsetof(AWeapon, RegisteredSkeletalControls) == 0x000790, "Member 'AWeapon::RegisteredSkeletalControls' has a wrong offset!");
static_assert(offsetof(AWeapon, CachedFireTriggerFeedback) == 0x0007A8, "Member 'AWeapon::CachedFireTriggerFeedback' has a wrong offset!");
static_assert(offsetof(AWeapon, CachedZoomTriggerFeedback) == 0x0007B0, "Member 'AWeapon::CachedZoomTriggerFeedback' has a wrong offset!");
static_assert(offsetof(AWeapon, bShowCrosshair) == 0x0007B8, "Member 'AWeapon::bShowCrosshair' has a wrong offset!");
static_assert(offsetof(AWeapon, bAlwaysTickAttachedMeshes) == 0x0007B9, "Member 'AWeapon::bAlwaysTickAttachedMeshes' has a wrong offset!");
static_assert(offsetof(AWeapon, BodyWeaponHoldName) == 0x0007C0, "Member 'AWeapon::BodyWeaponHoldName' has a wrong offset!");
static_assert(offsetof(AWeapon, AnimSetGenericNames) == 0x0007C8, "Member 'AWeapon::AnimSetGenericNames' has a wrong offset!");
static_assert(offsetof(AWeapon, DamageModifierCompClass) == 0x0007E0, "Member 'AWeapon::DamageModifierCompClass' has a wrong offset!");
static_assert(offsetof(AWeapon, CurrentState) == 0x0007F8, "Member 'AWeapon::CurrentState' has a wrong offset!");
static_assert(offsetof(AWeapon, UnregisteredFirstPersonOnlyAttachmentEffects) == 0x000898, "Member 'AWeapon::UnregisteredFirstPersonOnlyAttachmentEffects' has a wrong offset!");
static_assert(offsetof(AWeapon, UseModeIcons) == 0x0008A8, "Member 'AWeapon::UseModeIcons' has a wrong offset!");
static_assert(offsetof(AWeapon, UseModeIconFrameNames) == 0x0008B8, "Member 'AWeapon::UseModeIconFrameNames' has a wrong offset!");
static_assert(offsetof(AWeapon, MainHandGripSocketName) == 0x0008C8, "Member 'AWeapon::MainHandGripSocketName' has a wrong offset!");
static_assert(offsetof(AWeapon, OffHandGripSocketName) == 0x0008D0, "Member 'AWeapon::OffHandGripSocketName' has a wrong offset!");

// Class GbxWeapon.LightProjectileMoveModifier
// 0x0008 (0x0030 - 0x0028)
class ULightProjectileMoveModifier : public UObject
{
public:
	uint8                                         FiringPatternID;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictFiringPattern;                            // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileMoveModifier">();
	}
	static class ULightProjectileMoveModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileMoveModifier>();
	}
};
static_assert(alignof(ULightProjectileMoveModifier) == 0x000008, "Wrong alignment on ULightProjectileMoveModifier");
static_assert(sizeof(ULightProjectileMoveModifier) == 0x000030, "Wrong size on ULightProjectileMoveModifier");
static_assert(offsetof(ULightProjectileMoveModifier, FiringPatternID) == 0x000028, "Member 'ULightProjectileMoveModifier::FiringPatternID' has a wrong offset!");
static_assert(offsetof(ULightProjectileMoveModifier, bRestrictFiringPattern) == 0x000029, "Member 'ULightProjectileMoveModifier::bRestrictFiringPattern' has a wrong offset!");

// Class GbxWeapon.LightProjectileAimViewPointHomingModifier
// 0x0008 (0x0038 - 0x0030)
class ULightProjectileAimViewPointHomingModifier final : public ULightProjectileMoveModifier
{
public:
	float                                         LookAheadDistance;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileAimViewPointHomingModifier">();
	}
	static class ULightProjectileAimViewPointHomingModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileAimViewPointHomingModifier>();
	}
};
static_assert(alignof(ULightProjectileAimViewPointHomingModifier) == 0x000008, "Wrong alignment on ULightProjectileAimViewPointHomingModifier");
static_assert(sizeof(ULightProjectileAimViewPointHomingModifier) == 0x000038, "Wrong size on ULightProjectileAimViewPointHomingModifier");
static_assert(offsetof(ULightProjectileAimViewPointHomingModifier, LookAheadDistance) == 0x000030, "Member 'ULightProjectileAimViewPointHomingModifier::LookAheadDistance' has a wrong offset!");

// Class GbxWeapon.WeaponPreUseComponent
// 0x0020 (0x0198 - 0x0178)
class UWeaponPreUseComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   NotifyPreUseFinished;                              // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void K2_OnActivated();
	void K2_OnDeactivated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponPreUseComponent">();
	}
	static class UWeaponPreUseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponPreUseComponent>();
	}
};
static_assert(alignof(UWeaponPreUseComponent) == 0x000008, "Wrong alignment on UWeaponPreUseComponent");
static_assert(sizeof(UWeaponPreUseComponent) == 0x000198, "Wrong size on UWeaponPreUseComponent");
static_assert(offsetof(UWeaponPreUseComponent, NotifyPreUseFinished) == 0x000178, "Member 'UWeaponPreUseComponent::NotifyPreUseFinished' has a wrong offset!");
static_assert(offsetof(UWeaponPreUseComponent, bEnabled) == 0x000188, "Member 'UWeaponPreUseComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UWeaponPreUseComponent, WeaponPrivate) == 0x000190, "Member 'UWeaponPreUseComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.WeaponUseComponent
// 0x00A0 (0x0218 - 0x0178)
class UWeaponUseComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         UseMode;                                           // 0x0180(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoSwitchModeWhenOutOfAmmo : 1;                  // 0x0181(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClearUseInputWhenSwitchingModes : 1;              // 0x0181(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActivateModeWhenZoomed : 1;                       // 0x0181(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseAnimationSwitchModeTime : 1;                   // 0x0181(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_182[0x6];                                      // 0x0182(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCrosshairDataAsset*                 CrosshairData;                                     // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCrosshairDataAsset*                 ZoomedCrosshairData;                               // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModeName;                                          // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeEffectData>           InstigatorAttributeEffects;                        // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyUseStarted;                                  // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyUseFinished;                                 // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyUsed;                                        // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FGbxAttributeModifierHandle>    InstigatorAttributeModifiers;                      // 0x01F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UWeaponPreUseComponent*                 PreUseComponent;                                   // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void K2_OnActivated();
	void K2_OnDeactivated();
	void OnPreUseFinished(bool bInterrupted);
	void SwitchFromZoomedMode(uint8 ZoomLevel);
	void SwitchToZoomedMode(uint8 ZoomLevel);
	bool ToggleMode();

	bool CanActivateMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponUseComponent">();
	}
	static class UWeaponUseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponUseComponent>();
	}
};
static_assert(alignof(UWeaponUseComponent) == 0x000008, "Wrong alignment on UWeaponUseComponent");
static_assert(sizeof(UWeaponUseComponent) == 0x000218, "Wrong size on UWeaponUseComponent");
static_assert(offsetof(UWeaponUseComponent, UseMode) == 0x000180, "Member 'UWeaponUseComponent::UseMode' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, CrosshairData) == 0x000188, "Member 'UWeaponUseComponent::CrosshairData' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, ZoomedCrosshairData) == 0x000190, "Member 'UWeaponUseComponent::ZoomedCrosshairData' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, Icon) == 0x000198, "Member 'UWeaponUseComponent::Icon' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, ModeName) == 0x0001A0, "Member 'UWeaponUseComponent::ModeName' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, InstigatorAttributeEffects) == 0x0001B0, "Member 'UWeaponUseComponent::InstigatorAttributeEffects' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, NotifyUseStarted) == 0x0001C0, "Member 'UWeaponUseComponent::NotifyUseStarted' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, NotifyUseFinished) == 0x0001D0, "Member 'UWeaponUseComponent::NotifyUseFinished' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, NotifyUsed) == 0x0001E0, "Member 'UWeaponUseComponent::NotifyUsed' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, InstigatorAttributeModifiers) == 0x0001F0, "Member 'UWeaponUseComponent::InstigatorAttributeModifiers' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, PreUseComponent) == 0x000200, "Member 'UWeaponUseComponent::PreUseComponent' has a wrong offset!");
static_assert(offsetof(UWeaponUseComponent, WeaponPrivate) == 0x000210, "Member 'UWeaponUseComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.WeaponFireComponent
// 0x06E8 (0x0900 - 0x0218)
class UWeaponFireComponent : public UWeaponUseComponent
{
public:
	struct FGbxAttributeFloat                     FireRate;                                          // 0x0218(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeInteger                   AutomaticBurstCount;                               // 0x0224(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     BurstFireDelay;                                    // 0x0230(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBurst;                                        // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FireSocket;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FireSockets;                                       // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          FullFireSocketCycle;                               // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0259(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A[0x2];                                      // 0x025A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFireRateScale;                                  // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     FireRateAccelDuration;                             // 0x0260(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     FireRateDecelDuration;                             // 0x026C(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFireRatePercentToFire;                          // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FireRateCurve;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShotStrengthFormula;                           // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ShotStrengthFormula;                               // 0x0290(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FireSequenceLength;                                // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ResetFireSequenceTime;                             // 0x02CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetFireSequenceCompletePercent;                  // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdvanceFireSequenceAtEndOfBurst;                  // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTotalShotCostRequiredToFire;                      // 0x02DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeInteger                   ShotAmmoCost;                                      // 0x02E0(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinShotAmmoCost;                                   // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     Spread;                                            // 0x02F0(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     AccuracyImpulse;                                   // 0x02FC(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     BurstAccuracyImpulseScale;                         // 0x0308(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewModelShotOffsetScale;                          // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     Damage;                                            // 0x0318(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageFormula;                                     // 0x0328(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShotStrengthDamageCurve;                           // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     DamageRadius;                                      // 0x0368(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageRadiusFormula;                               // 0x0378(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShotStrengthDamageRadiusCurve;                     // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ImpactForce;                                       // 0x03B8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceSelection                        ImpactForceSelection;                              // 0x03C8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShotStrengthImpactForceCurve;                      // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x0400(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MuzzleFXSequenceLength;                            // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundPerceptionProperties             FireSoundPerception;                               // 0x040C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFeedbackData*                          FireFeedback;                                      // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayFeedbackAtLocation : 1;                       // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleFeedbackWithFireRate : 1;                    // 0x0420(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          ScaledFeedback;                                    // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     FeedbackFireRateScalar;                            // 0x0430(0x0078)(Edit, NativeAccessSpecifierPublic)
	class FName                                   FeedbackSocket;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncAnimationToFireRate;                          // 0x04B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireAnimationBlendSpace;                           // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEffectType                             SkeletalControlType;                               // 0x04B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkeletalControlName;                               // 0x04C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkeletalControlFireInput;                          // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOntoBestTarget;                               // 0x04CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayInitializeAttribute;                          // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0xD];                                      // 0x04D4(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_4E1_0 : 1;                                  // 0x04E1(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bFireRateAccelActive : 1;                          // 0x04E1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4E2[0x2];                                      // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EWeaponFireRateState                          FireRateState;                                     // 0x04E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentBurstShotCount;                             // 0x04E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CurrentFireSequenceIndex;                          // 0x04EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4ED[0x10];                                     // 0x04ED(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ClientFireSequenceState;                           // 0x04FD(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FE[0x22];                                     // 0x04FE(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireRatePercent;                                   // 0x0520(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_524[0x14];                                     // 0x0524(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         FlashSlot;                                         // 0x0538(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         FlashCount;                                        // 0x0539(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53A[0x6];                                      // 0x053A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ImpactLocation;                                    // 0x0540(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageAmount;                                      // 0x054C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxParam                              AIBurstCount;                                      // 0x0550(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              AIBurstFireDelay;                                  // 0x05D0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              AIFireInterval;                                    // 0x0650(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              AIAccuracy;                                        // 0x06D0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              AIProjectileSpeedScale;                            // 0x0750(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FNumericRange                          AIDesiredRange;                                    // 0x07D0(0x0008)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              AIMinDesiredRange;                                 // 0x07D8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              AIMaxDesiredRange;                                 // 0x0858(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxForceFeedbackEffect                ScaledEffect;                                      // 0x08D8(0x0018)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F0[0x10];                                     // 0x08F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientStopResetFireSequence();
	class AActor* GetLockedTarget();
	void OnGivenTo();
	void OnLoopingFireActionEnd(EGbxActionEndState EndState);
	void OnReloadAmmoGiven();
	void OnRep_ClientFireSequenceState();
	void OnRep_FireRateAccelChanged();
	void OnRep_FlashCount();
	void OnRep_ImpactLocation();
	void OnStartFireRateAcceleration();
	void OnStartFireRateDeceleration();
	void OnStopFireRateAcceleration();
	void OnStopFireRateDeceleration();
	void ServerResetFireSequence();

	float GetFireRatePercent() const;
	bool IsFireRateAccelEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponFireComponent">();
	}
	static class UWeaponFireComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponFireComponent>();
	}
};
static_assert(alignof(UWeaponFireComponent) == 0x000008, "Wrong alignment on UWeaponFireComponent");
static_assert(sizeof(UWeaponFireComponent) == 0x000900, "Wrong size on UWeaponFireComponent");
static_assert(offsetof(UWeaponFireComponent, FireRate) == 0x000218, "Member 'UWeaponFireComponent::FireRate' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AutomaticBurstCount) == 0x000224, "Member 'UWeaponFireComponent::AutomaticBurstCount' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, BurstFireDelay) == 0x000230, "Member 'UWeaponFireComponent::BurstFireDelay' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, bAutoBurst) == 0x00023C, "Member 'UWeaponFireComponent::bAutoBurst' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireSocket) == 0x000240, "Member 'UWeaponFireComponent::FireSocket' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireSockets) == 0x000248, "Member 'UWeaponFireComponent::FireSockets' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FullFireSocketCycle) == 0x000258, "Member 'UWeaponFireComponent::FullFireSocketCycle' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, TraceChannel) == 0x000259, "Member 'UWeaponFireComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, MinFireRateScale) == 0x00025C, "Member 'UWeaponFireComponent::MinFireRateScale' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireRateAccelDuration) == 0x000260, "Member 'UWeaponFireComponent::FireRateAccelDuration' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireRateDecelDuration) == 0x00026C, "Member 'UWeaponFireComponent::FireRateDecelDuration' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, MinFireRatePercentToFire) == 0x000278, "Member 'UWeaponFireComponent::MinFireRatePercentToFire' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireRateCurve) == 0x000280, "Member 'UWeaponFireComponent::FireRateCurve' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, bUseShotStrengthFormula) == 0x000288, "Member 'UWeaponFireComponent::bUseShotStrengthFormula' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ShotStrengthFormula) == 0x000290, "Member 'UWeaponFireComponent::ShotStrengthFormula' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireSequenceLength) == 0x0002C8, "Member 'UWeaponFireComponent::FireSequenceLength' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ResetFireSequenceTime) == 0x0002CC, "Member 'UWeaponFireComponent::ResetFireSequenceTime' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ResetFireSequenceCompletePercent) == 0x0002D8, "Member 'UWeaponFireComponent::ResetFireSequenceCompletePercent' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, bAdvanceFireSequenceAtEndOfBurst) == 0x0002DC, "Member 'UWeaponFireComponent::bAdvanceFireSequenceAtEndOfBurst' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, bTotalShotCostRequiredToFire) == 0x0002DD, "Member 'UWeaponFireComponent::bTotalShotCostRequiredToFire' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ShotAmmoCost) == 0x0002E0, "Member 'UWeaponFireComponent::ShotAmmoCost' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, MinShotAmmoCost) == 0x0002EC, "Member 'UWeaponFireComponent::MinShotAmmoCost' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, Spread) == 0x0002F0, "Member 'UWeaponFireComponent::Spread' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AccuracyImpulse) == 0x0002FC, "Member 'UWeaponFireComponent::AccuracyImpulse' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, BurstAccuracyImpulseScale) == 0x000308, "Member 'UWeaponFireComponent::BurstAccuracyImpulseScale' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ViewModelShotOffsetScale) == 0x000314, "Member 'UWeaponFireComponent::ViewModelShotOffsetScale' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, Damage) == 0x000318, "Member 'UWeaponFireComponent::Damage' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DamageFormula) == 0x000328, "Member 'UWeaponFireComponent::DamageFormula' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ShotStrengthDamageCurve) == 0x000360, "Member 'UWeaponFireComponent::ShotStrengthDamageCurve' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DamageRadius) == 0x000368, "Member 'UWeaponFireComponent::DamageRadius' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DamageRadiusFormula) == 0x000378, "Member 'UWeaponFireComponent::DamageRadiusFormula' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ShotStrengthDamageRadiusCurve) == 0x0003B0, "Member 'UWeaponFireComponent::ShotStrengthDamageRadiusCurve' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ImpactForce) == 0x0003B8, "Member 'UWeaponFireComponent::ImpactForce' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ImpactForceSelection) == 0x0003C8, "Member 'UWeaponFireComponent::ImpactForceSelection' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ShotStrengthImpactForceCurve) == 0x0003E8, "Member 'UWeaponFireComponent::ShotStrengthImpactForceCurve' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DamageType) == 0x0003F0, "Member 'UWeaponFireComponent::DamageType' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DamageSource) == 0x0003F8, "Member 'UWeaponFireComponent::DamageSource' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ImpactData) == 0x000400, "Member 'UWeaponFireComponent::ImpactData' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, MuzzleFXSequenceLength) == 0x000408, "Member 'UWeaponFireComponent::MuzzleFXSequenceLength' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireSoundPerception) == 0x00040C, "Member 'UWeaponFireComponent::FireSoundPerception' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireFeedback) == 0x000418, "Member 'UWeaponFireComponent::FireFeedback' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ScaledFeedback) == 0x000428, "Member 'UWeaponFireComponent::ScaledFeedback' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FeedbackFireRateScalar) == 0x000430, "Member 'UWeaponFireComponent::FeedbackFireRateScalar' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FeedbackSocket) == 0x0004A8, "Member 'UWeaponFireComponent::FeedbackSocket' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, bSyncAnimationToFireRate) == 0x0004B0, "Member 'UWeaponFireComponent::bSyncAnimationToFireRate' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireAnimationBlendSpace) == 0x0004B4, "Member 'UWeaponFireComponent::FireAnimationBlendSpace' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, SkeletalControlType) == 0x0004B8, "Member 'UWeaponFireComponent::SkeletalControlType' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, SkeletalControlName) == 0x0004C0, "Member 'UWeaponFireComponent::SkeletalControlName' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, SkeletalControlFireInput) == 0x0004C8, "Member 'UWeaponFireComponent::SkeletalControlFireInput' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, bLockOntoBestTarget) == 0x0004CC, "Member 'UWeaponFireComponent::bLockOntoBestTarget' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DelayInitializeAttribute) == 0x0004D0, "Member 'UWeaponFireComponent::DelayInitializeAttribute' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireRateState) == 0x0004E4, "Member 'UWeaponFireComponent::FireRateState' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, CurrentBurstShotCount) == 0x0004E8, "Member 'UWeaponFireComponent::CurrentBurstShotCount' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, CurrentFireSequenceIndex) == 0x0004EC, "Member 'UWeaponFireComponent::CurrentFireSequenceIndex' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ClientFireSequenceState) == 0x0004FD, "Member 'UWeaponFireComponent::ClientFireSequenceState' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FireRatePercent) == 0x000520, "Member 'UWeaponFireComponent::FireRatePercent' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FlashSlot) == 0x000538, "Member 'UWeaponFireComponent::FlashSlot' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, FlashCount) == 0x000539, "Member 'UWeaponFireComponent::FlashCount' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ImpactLocation) == 0x000540, "Member 'UWeaponFireComponent::ImpactLocation' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, DamageAmount) == 0x00054C, "Member 'UWeaponFireComponent::DamageAmount' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIBurstCount) == 0x000550, "Member 'UWeaponFireComponent::AIBurstCount' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIBurstFireDelay) == 0x0005D0, "Member 'UWeaponFireComponent::AIBurstFireDelay' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIFireInterval) == 0x000650, "Member 'UWeaponFireComponent::AIFireInterval' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIAccuracy) == 0x0006D0, "Member 'UWeaponFireComponent::AIAccuracy' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIProjectileSpeedScale) == 0x000750, "Member 'UWeaponFireComponent::AIProjectileSpeedScale' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIDesiredRange) == 0x0007D0, "Member 'UWeaponFireComponent::AIDesiredRange' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIMinDesiredRange) == 0x0007D8, "Member 'UWeaponFireComponent::AIMinDesiredRange' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, AIMaxDesiredRange) == 0x000858, "Member 'UWeaponFireComponent::AIMaxDesiredRange' has a wrong offset!");
static_assert(offsetof(UWeaponFireComponent, ScaledEffect) == 0x0008D8, "Member 'UWeaponFireComponent::ScaledEffect' has a wrong offset!");

// Class GbxWeapon.WeaponAudioProviderComponent
// 0x0000 (0x0178 - 0x0178)
class UWeaponAudioProviderComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAudioProviderComponent">();
	}
	static class UWeaponAudioProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAudioProviderComponent>();
	}
};
static_assert(alignof(UWeaponAudioProviderComponent) == 0x000008, "Wrong alignment on UWeaponAudioProviderComponent");
static_assert(sizeof(UWeaponAudioProviderComponent) == 0x000178, "Wrong size on UWeaponAudioProviderComponent");

// Class GbxWeapon.WeaponFireProjectileComponent
// 0x0058 (0x0958 - 0x0900)
class UWeaponFireProjectileComponent : public UWeaponFireComponent
{
public:
	struct FGbxAttributeInteger                   ProjectilesPerShot;                                // 0x0900(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ProjectileSpeedScale;                              // 0x090C(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShotStrengthProjectileSpeedCurve;                  // 0x0918(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ProjectileTemplate;                                // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeBaseValueData>        ProjectileBaseValues;                              // 0x0928(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightProjectileData>       LightProjectileData;                               // 0x0938(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFiringPattern*                         FiringPatternData;                                 // 0x0940(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94C[0xC];                                      // 0x094C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class ULightProjectileData> GetShotLightProjectileData() const;
	TSubclassOf<class AActor> GetShotProjectileData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponFireProjectileComponent">();
	}
	static class UWeaponFireProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponFireProjectileComponent>();
	}
};
static_assert(alignof(UWeaponFireProjectileComponent) == 0x000008, "Wrong alignment on UWeaponFireProjectileComponent");
static_assert(sizeof(UWeaponFireProjectileComponent) == 0x000958, "Wrong size on UWeaponFireProjectileComponent");
static_assert(offsetof(UWeaponFireProjectileComponent, ProjectilesPerShot) == 0x000900, "Member 'UWeaponFireProjectileComponent::ProjectilesPerShot' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, ProjectileSpeedScale) == 0x00090C, "Member 'UWeaponFireProjectileComponent::ProjectileSpeedScale' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, ShotStrengthProjectileSpeedCurve) == 0x000918, "Member 'UWeaponFireProjectileComponent::ShotStrengthProjectileSpeedCurve' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, ProjectileTemplate) == 0x000920, "Member 'UWeaponFireProjectileComponent::ProjectileTemplate' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, ProjectileBaseValues) == 0x000928, "Member 'UWeaponFireProjectileComponent::ProjectileBaseValues' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, LightProjectileData) == 0x000938, "Member 'UWeaponFireProjectileComponent::LightProjectileData' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, FiringPatternData) == 0x000940, "Member 'UWeaponFireProjectileComponent::FiringPatternData' has a wrong offset!");
static_assert(offsetof(UWeaponFireProjectileComponent, Range) == 0x000948, "Member 'UWeaponFireProjectileComponent::Range' has a wrong offset!");

// Class GbxWeapon.GbxProjectileMovementComponent
// 0x0070 (0x02C8 - 0x0258)
class UGbxProjectileMovementComponent : public UProjectileMovementComponent
{
public:
	UMulticastDelegateProperty_                   PostLastBounceDelegate;                            // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ProjectileAcceleration;                            // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedWhenDecelerating;                          // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AProjectile*                            OwningProjectile;                                  // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSmoothedRotationFollowsVelocity;                  // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothedRotationSpeed;                             // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDontStopSimulatingAfterHittingAnotherProjectile;  // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumBounces;                                     // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounceParallelToHitNormal;                        // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentNumBounces;                                 // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreezeMovementAfterLastBounce;                    // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletPerceptionProperties            BulletSensePerception;                             // 0x029C(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerceptionProperties             ImpactSoundPerception;                             // 0x02A4(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanTriggerGrenadeDodges;                          // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisablePhysicsWhenAttached;                       // 0x02B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0xE];                                      // 0x02B2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialProjectileGravity;                          // 0x02C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnProjectilePostLastBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult);
	void OnRep_InitialProjectileGravity();
	void ScaleVelocity(float InScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxProjectileMovementComponent">();
	}
	static class UGbxProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxProjectileMovementComponent>();
	}
};
static_assert(alignof(UGbxProjectileMovementComponent) == 0x000008, "Wrong alignment on UGbxProjectileMovementComponent");
static_assert(sizeof(UGbxProjectileMovementComponent) == 0x0002C8, "Wrong size on UGbxProjectileMovementComponent");
static_assert(offsetof(UGbxProjectileMovementComponent, PostLastBounceDelegate) == 0x000258, "Member 'UGbxProjectileMovementComponent::PostLastBounceDelegate' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, ProjectileAcceleration) == 0x000268, "Member 'UGbxProjectileMovementComponent::ProjectileAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, MinSpeedWhenDecelerating) == 0x00026C, "Member 'UGbxProjectileMovementComponent::MinSpeedWhenDecelerating' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, OwningProjectile) == 0x000278, "Member 'UGbxProjectileMovementComponent::OwningProjectile' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, bSmoothedRotationFollowsVelocity) == 0x000280, "Member 'UGbxProjectileMovementComponent::bSmoothedRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, SmoothedRotationSpeed) == 0x000284, "Member 'UGbxProjectileMovementComponent::SmoothedRotationSpeed' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, bDontStopSimulatingAfterHittingAnotherProjectile) == 0x000288, "Member 'UGbxProjectileMovementComponent::bDontStopSimulatingAfterHittingAnotherProjectile' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, MaxNumBounces) == 0x00028C, "Member 'UGbxProjectileMovementComponent::MaxNumBounces' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, bBounceParallelToHitNormal) == 0x000290, "Member 'UGbxProjectileMovementComponent::bBounceParallelToHitNormal' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, CurrentNumBounces) == 0x000294, "Member 'UGbxProjectileMovementComponent::CurrentNumBounces' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, bFreezeMovementAfterLastBounce) == 0x000298, "Member 'UGbxProjectileMovementComponent::bFreezeMovementAfterLastBounce' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, BulletSensePerception) == 0x00029C, "Member 'UGbxProjectileMovementComponent::BulletSensePerception' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, ImpactSoundPerception) == 0x0002A4, "Member 'UGbxProjectileMovementComponent::ImpactSoundPerception' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, bCanTriggerGrenadeDodges) == 0x0002B0, "Member 'UGbxProjectileMovementComponent::bCanTriggerGrenadeDodges' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, bDisablePhysicsWhenAttached) == 0x0002B1, "Member 'UGbxProjectileMovementComponent::bDisablePhysicsWhenAttached' has a wrong offset!");
static_assert(offsetof(UGbxProjectileMovementComponent, InitialProjectileGravity) == 0x0002C0, "Member 'UGbxProjectileMovementComponent::InitialProjectileGravity' has a wrong offset!");

// Class GbxWeapon.GbxAmmoTypeData
// 0x0040 (0x0070 - 0x0030)
class UGbxAmmoTypeData final : public UGbxDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             DisplayIcon;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScaleformDisplayFrameID;                           // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourceData*                      ResourceData;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegenerationRate;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAmmoTypeData">();
	}
	static class UGbxAmmoTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAmmoTypeData>();
	}
};
static_assert(alignof(UGbxAmmoTypeData) == 0x000008, "Wrong alignment on UGbxAmmoTypeData");
static_assert(sizeof(UGbxAmmoTypeData) == 0x000070, "Wrong size on UGbxAmmoTypeData");
static_assert(offsetof(UGbxAmmoTypeData, DisplayName) == 0x000030, "Member 'UGbxAmmoTypeData::DisplayName' has a wrong offset!");
static_assert(offsetof(UGbxAmmoTypeData, DisplayIcon) == 0x000048, "Member 'UGbxAmmoTypeData::DisplayIcon' has a wrong offset!");
static_assert(offsetof(UGbxAmmoTypeData, ScaleformDisplayFrameID) == 0x000050, "Member 'UGbxAmmoTypeData::ScaleformDisplayFrameID' has a wrong offset!");
static_assert(offsetof(UGbxAmmoTypeData, ResourceData) == 0x000060, "Member 'UGbxAmmoTypeData::ResourceData' has a wrong offset!");
static_assert(offsetof(UGbxAmmoTypeData, RegenerationRate) == 0x000068, "Member 'UGbxAmmoTypeData::RegenerationRate' has a wrong offset!");

// Class GbxWeapon.Projectile
// 0x0228 (0x0680 - 0x0458)
class AProjectile : public AActor
{
public:
	uint8                                         Pad_458[0x10];                                     // 0x0458(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIgnoreCollisionWithInstigator : 1;                // 0x0468(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCollisionWithInstigatorTeam : 1;            // 0x0468(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopBlockingPawnsAfterCollidingWithOne : 1;       // 0x0468(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bServerControlsProjectileLifetime : 1;             // 0x0468(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageInfo                            DamageInfo;                                        // 0x0470(0x0058)(Edit, BlueprintVisible, Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UImpactData*                            DefaultImpact;                                     // 0x04C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultImpactEffectDelay;                          // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponShotModifierType                       SpawnModifierType;                                 // 0x04D4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D5[0x13];                                     // 0x04D5(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnModifierValue;                                // 0x04E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxProjectileMovementComponent*        MovementComponent;                                 // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExplosionComponent*                    ExplosionComponent;                                // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x1];                                      // 0x0500(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClientExplodeAtLeastOnce;                         // 0x0501(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_502[0xA6];                                     // 0x0502(0x00A6)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExplodeOnHit;                                     // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeOnHitWorld;                                // 0x05A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeOnHitDamagable;                            // 0x05AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeOnHitEnemy;                                // 0x05AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExplodeAfterLifetime;                             // 0x05AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyAfterExplode;                              // 0x05AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamageOnExplode;                                  // 0x05AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AF[0x1];                                      // 0x05AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeam*                                  ProjectileTeam;                                    // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageSource>              DamageSourceOverride;                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageTypeOverride;                                // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExplosionData*                         ExplosionData;                                     // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseQuickPopExplosion;                             // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UExplosionData*                         QuickPopExplosion;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamageOverride;                                    // 0x05F0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DamageAreaRadius;                                  // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageAreaBoxExtent;                               // 0x062C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        ImpactForceOverride;                               // 0x0638(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCriticalHitDamageOverrides            CriticalHitOverrides;                              // 0x0658(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OverrideIgnoreActors;                              // 0x0660(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class AWeapon*                                WeaponFiredFrom;                                   // 0x0670(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnSpeedScale;                                   // 0x0678(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BounceDelegate(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void CheckProjectileAttachment();
	void Explode();
	class UExplosionComponent* GetExplosionComponent();
	float GetProjectileDamage();
	float GetProjectileDamageRadius();
	TSubclassOf<class UDamageSource> GetProjectileDamageSource();
	TSubclassOf<class UGbxDamageType> GetProjectileDamageType();
	class UGbxProjectileMovementComponent* GetProjectileMovementComponent();
	void HandleDetachRequest();
	void IgnoreCollisionWith(class AActor* ActorToIgnore);
	void OnBeginExplode();
	void OnBounce(const struct FHitResult& Hit, const struct FVector& ImpactVelocity);
	void OnComponentDetachedFromParent(class USceneComponent* SceneComponent);
	void OnExplode();
	void OnHitDamagableObject(const struct FHitResult& Hit);
	void OnHitEnemy(const struct FHitResult& Hit);
	void OnHitFriendly(const struct FHitResult& Hit);
	void OnHitNeutral(const struct FHitResult& Hit);
	void OnHitWorld(const struct FHitResult& Hit);
	void OnLastBounce(const struct FHitResult& ImpactResult);
	void OnRep_SpawnModifierType();
	void ResetCollisionWith(class AActor* ActorToCollide);
	void SetProjectileDamage(float Damage);
	void SetProjectileDamageRadius(float DamageRadius);
	void SetProjectileDamageSource(TSubclassOf<class UDamageSource> DamageSource);
	void SetProjectileDamageType(TSubclassOf<class UGbxDamageType> DamageType);
	void StopBlockingPawns();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile">();
	}
	static class AProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile>();
	}
};
static_assert(alignof(AProjectile) == 0x000008, "Wrong alignment on AProjectile");
static_assert(sizeof(AProjectile) == 0x000680, "Wrong size on AProjectile");
static_assert(offsetof(AProjectile, DamageInfo) == 0x000470, "Member 'AProjectile::DamageInfo' has a wrong offset!");
static_assert(offsetof(AProjectile, DefaultImpact) == 0x0004C8, "Member 'AProjectile::DefaultImpact' has a wrong offset!");
static_assert(offsetof(AProjectile, DefaultImpactEffectDelay) == 0x0004D0, "Member 'AProjectile::DefaultImpactEffectDelay' has a wrong offset!");
static_assert(offsetof(AProjectile, SpawnModifierType) == 0x0004D4, "Member 'AProjectile::SpawnModifierType' has a wrong offset!");
static_assert(offsetof(AProjectile, SpawnModifierValue) == 0x0004E8, "Member 'AProjectile::SpawnModifierValue' has a wrong offset!");
static_assert(offsetof(AProjectile, MovementComponent) == 0x0004F0, "Member 'AProjectile::MovementComponent' has a wrong offset!");
static_assert(offsetof(AProjectile, ExplosionComponent) == 0x0004F8, "Member 'AProjectile::ExplosionComponent' has a wrong offset!");
static_assert(offsetof(AProjectile, bClientExplodeAtLeastOnce) == 0x000501, "Member 'AProjectile::bClientExplodeAtLeastOnce' has a wrong offset!");
static_assert(offsetof(AProjectile, bExplodeOnHit) == 0x0005A8, "Member 'AProjectile::bExplodeOnHit' has a wrong offset!");
static_assert(offsetof(AProjectile, bExplodeOnHitWorld) == 0x0005A9, "Member 'AProjectile::bExplodeOnHitWorld' has a wrong offset!");
static_assert(offsetof(AProjectile, bExplodeOnHitDamagable) == 0x0005AA, "Member 'AProjectile::bExplodeOnHitDamagable' has a wrong offset!");
static_assert(offsetof(AProjectile, bExplodeOnHitEnemy) == 0x0005AB, "Member 'AProjectile::bExplodeOnHitEnemy' has a wrong offset!");
static_assert(offsetof(AProjectile, bExplodeAfterLifetime) == 0x0005AC, "Member 'AProjectile::bExplodeAfterLifetime' has a wrong offset!");
static_assert(offsetof(AProjectile, bDestroyAfterExplode) == 0x0005AD, "Member 'AProjectile::bDestroyAfterExplode' has a wrong offset!");
static_assert(offsetof(AProjectile, bDamageOnExplode) == 0x0005AE, "Member 'AProjectile::bDamageOnExplode' has a wrong offset!");
static_assert(offsetof(AProjectile, DamageData) == 0x0005B0, "Member 'AProjectile::DamageData' has a wrong offset!");
static_assert(offsetof(AProjectile, ProjectileTeam) == 0x0005B8, "Member 'AProjectile::ProjectileTeam' has a wrong offset!");
static_assert(offsetof(AProjectile, DamageSourceOverride) == 0x0005C0, "Member 'AProjectile::DamageSourceOverride' has a wrong offset!");
static_assert(offsetof(AProjectile, DamageTypeOverride) == 0x0005C8, "Member 'AProjectile::DamageTypeOverride' has a wrong offset!");
static_assert(offsetof(AProjectile, ExplosionData) == 0x0005D0, "Member 'AProjectile::ExplosionData' has a wrong offset!");
static_assert(offsetof(AProjectile, bUseQuickPopExplosion) == 0x0005D8, "Member 'AProjectile::bUseQuickPopExplosion' has a wrong offset!");
static_assert(offsetof(AProjectile, QuickPopExplosion) == 0x0005E0, "Member 'AProjectile::QuickPopExplosion' has a wrong offset!");
static_assert(offsetof(AProjectile, ImpactData) == 0x0005E8, "Member 'AProjectile::ImpactData' has a wrong offset!");
static_assert(offsetof(AProjectile, DamageOverride) == 0x0005F0, "Member 'AProjectile::DamageOverride' has a wrong offset!");
static_assert(offsetof(AProjectile, DamageAreaRadius) == 0x000628, "Member 'AProjectile::DamageAreaRadius' has a wrong offset!");
static_assert(offsetof(AProjectile, DamageAreaBoxExtent) == 0x00062C, "Member 'AProjectile::DamageAreaBoxExtent' has a wrong offset!");
static_assert(offsetof(AProjectile, ImpactForceOverride) == 0x000638, "Member 'AProjectile::ImpactForceOverride' has a wrong offset!");
static_assert(offsetof(AProjectile, CriticalHitOverrides) == 0x000658, "Member 'AProjectile::CriticalHitOverrides' has a wrong offset!");
static_assert(offsetof(AProjectile, OverrideIgnoreActors) == 0x000660, "Member 'AProjectile::OverrideIgnoreActors' has a wrong offset!");
static_assert(offsetof(AProjectile, WeaponFiredFrom) == 0x000670, "Member 'AProjectile::WeaponFiredFrom' has a wrong offset!");
static_assert(offsetof(AProjectile, SpawnSpeedScale) == 0x000678, "Member 'AProjectile::SpawnSpeedScale' has a wrong offset!");

// Class GbxWeapon.LightProjectileManager
// 0x0168 (0x05C0 - 0x0458)
class ALightProjectileManager final : public AActor
{
public:
	TArray<class ULightProjectile*>               ActiveProjectiles;                                 // 0x0458(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x18];                                     // 0x0468(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULightProjectile*>               ProjectilesWaitingBatch;                           // 0x0480(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULightProjectile*>               ProjectilePool;                                    // 0x0490(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UParticleSystemComponent*>       ActiveParticles;                                   // 0x04A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FLightProjectileParticlePoolData> ParticlesPool;                                     // 0x04B0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0xD4];                                     // 0x04C0(0x00D4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAsyncSpawnTime;                                 // 0x0594(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x28];                                     // 0x0598(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void ServerSendDebugProjectileImpact(int32 ProjSyncID, class AActor* HitActor, class FName BoneName, uint16 ProjFlags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileManager">();
	}
	static class ALightProjectileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightProjectileManager>();
	}
};
static_assert(alignof(ALightProjectileManager) == 0x000008, "Wrong alignment on ALightProjectileManager");
static_assert(sizeof(ALightProjectileManager) == 0x0005C0, "Wrong size on ALightProjectileManager");
static_assert(offsetof(ALightProjectileManager, ActiveProjectiles) == 0x000458, "Member 'ALightProjectileManager::ActiveProjectiles' has a wrong offset!");
static_assert(offsetof(ALightProjectileManager, ProjectilesWaitingBatch) == 0x000480, "Member 'ALightProjectileManager::ProjectilesWaitingBatch' has a wrong offset!");
static_assert(offsetof(ALightProjectileManager, ProjectilePool) == 0x000490, "Member 'ALightProjectileManager::ProjectilePool' has a wrong offset!");
static_assert(offsetof(ALightProjectileManager, ActiveParticles) == 0x0004A0, "Member 'ALightProjectileManager::ActiveParticles' has a wrong offset!");
static_assert(offsetof(ALightProjectileManager, ParticlesPool) == 0x0004B0, "Member 'ALightProjectileManager::ParticlesPool' has a wrong offset!");
static_assert(offsetof(ALightProjectileManager, MaxAsyncSpawnTime) == 0x000594, "Member 'ALightProjectileManager::MaxAsyncSpawnTime' has a wrong offset!");

// Class GbxWeapon.EnvQueryItemType_ProjectileProxy
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryItemType_ProjectileProxy final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryItemType_ProjectileProxy">();
	}
	static class UEnvQueryItemType_ProjectileProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryItemType_ProjectileProxy>();
	}
};
static_assert(alignof(UEnvQueryItemType_ProjectileProxy) == 0x000008, "Wrong alignment on UEnvQueryItemType_ProjectileProxy");
static_assert(sizeof(UEnvQueryItemType_ProjectileProxy) == 0x000030, "Wrong size on UEnvQueryItemType_ProjectileProxy");

// Class GbxWeapon.WeaponHeatComponent
// 0x00C0 (0x0238 - 0x0178)
class UWeaponHeatComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     HeatCoolDownRate;                                  // 0x0188(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     HeatCoolDownDelay;                                 // 0x0194(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     UseHeatImpulse;                                    // 0x01A0(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ActiveHeatRate;                                    // 0x01AC(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateOnClients;                                // 0x01B8(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSimulateOnAI : 1;                                 // 0x01B9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisibleInHUD : 1;                                 // 0x01B9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartCoolDownEffectOnEndUse : 1;                  // 0x01B9(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanOverheat : 1;                                  // 0x01B9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanUseWhenOverheated;                             // 0x01BA(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BB[0x1];                                      // 0x01BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     OverheatTime;                                      // 0x01BC(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     OverheatCoolDownDelay;                             // 0x01C8(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponHeatEventNotify>         HeatEvents;                                        // 0x01D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   HeatMaterialParamName;                             // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HeatMaterialParamCurve;                            // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEffectType                             CoolDownEffectType;                                // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolDownEffectOnThreshold;                         // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolDownEffectOffThreshold;                        // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   NotifyHeatChanged;                                 // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Heat;                                              // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0xC];                                      // 0x021C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReplicatedHeat;                                    // 0x0228(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverheated : 1;                                   // 0x0229(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_22A[0x6];                                      // 0x022A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAttached();
	void OnDetached();
	void OnEquipped();
	void OnPutDown();
	void OnRep_Overheated(bool bWasOverheated);
	void OnRep_ReplicatedHeat();
	void OnStartOverheat();
	void OnStopOverheat();
	void OnUsed();
	void OnUseFinished();
	void SetCanUseWhenOverheated(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponHeatComponent">();
	}
	static class UWeaponHeatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponHeatComponent>();
	}
};
static_assert(alignof(UWeaponHeatComponent) == 0x000008, "Wrong alignment on UWeaponHeatComponent");
static_assert(sizeof(UWeaponHeatComponent) == 0x000238, "Wrong size on UWeaponHeatComponent");
static_assert(offsetof(UWeaponHeatComponent, HeatCoolDownRate) == 0x000188, "Member 'UWeaponHeatComponent::HeatCoolDownRate' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, HeatCoolDownDelay) == 0x000194, "Member 'UWeaponHeatComponent::HeatCoolDownDelay' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, UseHeatImpulse) == 0x0001A0, "Member 'UWeaponHeatComponent::UseHeatImpulse' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, ActiveHeatRate) == 0x0001AC, "Member 'UWeaponHeatComponent::ActiveHeatRate' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, bSimulateOnClients) == 0x0001B8, "Member 'UWeaponHeatComponent::bSimulateOnClients' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, bCanUseWhenOverheated) == 0x0001BA, "Member 'UWeaponHeatComponent::bCanUseWhenOverheated' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, OverheatTime) == 0x0001BC, "Member 'UWeaponHeatComponent::OverheatTime' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, OverheatCoolDownDelay) == 0x0001C8, "Member 'UWeaponHeatComponent::OverheatCoolDownDelay' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, HeatEvents) == 0x0001D8, "Member 'UWeaponHeatComponent::HeatEvents' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, HeatMaterialParamName) == 0x0001E8, "Member 'UWeaponHeatComponent::HeatMaterialParamName' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, HeatMaterialParamCurve) == 0x0001F0, "Member 'UWeaponHeatComponent::HeatMaterialParamCurve' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, CoolDownEffectType) == 0x0001F8, "Member 'UWeaponHeatComponent::CoolDownEffectType' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, CoolDownEffectOnThreshold) == 0x0001FC, "Member 'UWeaponHeatComponent::CoolDownEffectOnThreshold' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, CoolDownEffectOffThreshold) == 0x000200, "Member 'UWeaponHeatComponent::CoolDownEffectOffThreshold' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, NotifyHeatChanged) == 0x000208, "Member 'UWeaponHeatComponent::NotifyHeatChanged' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, Heat) == 0x000218, "Member 'UWeaponHeatComponent::Heat' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, ReplicatedHeat) == 0x000228, "Member 'UWeaponHeatComponent::ReplicatedHeat' has a wrong offset!");
static_assert(offsetof(UWeaponHeatComponent, WeaponPrivate) == 0x000230, "Member 'UWeaponHeatComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.LightProjectile
// 0x0448 (0x0470 - 0x0028)
class ULightProjectile : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SyncID;                                            // 0x0030(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x74];                                      // 0x0034(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightProjectileData*                   Data;                                              // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageRadius;                                      // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactForce;                                       // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x18];                                      // 0x00CC(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bActive : 1;                                       // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_E5[0x23];                                      // 0x00E5(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedLightProjectileInitializationData InitialClientState;                                // 0x0108(0x00B8)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLightProjectileAttachment             AttachmentData;                                    // 0x01C0(0x0040)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLightProjectileExplodeData            ExplodeData;                                       // 0x0200(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLightProjectileImpactData             ImpactInfo;                                        // 0x0210(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         ShutdownID;                                        // 0x0220(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0224(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingStartTime;                                   // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x2C];                                     // 0x0234(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LastHitActor;                                      // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x40];                                     // 0x0268(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x02A8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ComponentLocation;                                 // 0x02B4(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ComponentRotation;                                 // 0x02C0(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0xC];                                      // 0x02CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalStartLocation;                                // 0x02D8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocalStartDirection;                               // 0x02E4(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Velocity;                                          // 0x02F0(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScale;                                      // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BodyComponent;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               TracerComponent;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            Components;                                        // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x38];                                     // 0x0320(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumBounces;                                        // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x1C];                                     // 0x035C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageModifierComponent*               DamageModifierComp;                                // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0xF0];                                     // 0x0380(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAreaDamage(const struct FVector& Origin, class AActor* HitActor, const struct FHitResult& Hit);
	void Destroy();
	void DisableHoming();
	void EnableHoming();
	void Explode(float Delay);
	void K2_ApplyImpactDamage(const struct FHitResult& Hit, float ImpactDamage, bool bPenetrated, bool bCanReflect);
	void OnAttachedActorDestroyed(class AActor* DestroyedActor);
	void OnAttachedActorFractured(const struct FVector& HitPoint, const struct FVector& HitDirection);
	void OnAttachedComponentCollisionChanged(class UPrimitiveComponent* ChangedComponent);
	void OnAttachedComponentUnregistered(class UActorComponent* UnregisteredComponent);
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void OnRep_Attached();
	void OnRep_Exploded();
	void OnRep_Impact();
	void OnRep_InitialClientState();
	void OnRep_Shutdown();
	void SetHomingTarget(class AActor* HomingTarget, const struct FVector& TargetOffset);
	void SetHomingTargetLocation(const struct FVector& HomingLocation);
	void SetLifetime(float NewLifetime);

	class AActor* GetAssociatedActor(ELightProjectileQueryActorType ActorType) const;
	class AActor* GetAttachedActor() const;
	class AActor* GetAttachedDamageReceiverActor() const;
	struct FVector GetAttachedImpactNormal() const;
	ETeamAttitude GetAttitudeTowards(class AActor* TargetActor) const;
	class AActor* GetDamageCauser() const;
	const class UGbxDamageType* GetDamageType() const;
	uint8 GetFiringPatternID() const;
	float GetHomingStartTime() const;
	class UImpactData* GetImpactData() const;
	class UImpactData* GetImpactDataOverride() const;
	class APawn* GetInstigator() const;
	EWeaponShotModifierType GetModifierType() const;
	float GetModifierValue() const;
	class AActor* GetSource() const;
	class AActor* GetTarget() const;
	void InitChildData(struct FLightProjectileInitializationData* InitData) const;
	bool IsHoming() const;
	bool IsHomingMovingDirectlyTowardsTarget() const;
	void PlayFeedbackSoundEvent(class UWwiseEvent* Event) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectile">();
	}
	static class ULightProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectile>();
	}
};
static_assert(alignof(ULightProjectile) == 0x000008, "Wrong alignment on ULightProjectile");
static_assert(sizeof(ULightProjectile) == 0x000470, "Wrong size on ULightProjectile");
static_assert(offsetof(ULightProjectile, SyncID) == 0x000030, "Member 'ULightProjectile::SyncID' has a wrong offset!");
static_assert(offsetof(ULightProjectile, Data) == 0x0000A8, "Member 'ULightProjectile::Data' has a wrong offset!");
static_assert(offsetof(ULightProjectile, Damage) == 0x0000B0, "Member 'ULightProjectile::Damage' has a wrong offset!");
static_assert(offsetof(ULightProjectile, DamageRadius) == 0x0000B4, "Member 'ULightProjectile::DamageRadius' has a wrong offset!");
static_assert(offsetof(ULightProjectile, DamageType) == 0x0000B8, "Member 'ULightProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(ULightProjectile, DamageSource) == 0x0000C0, "Member 'ULightProjectile::DamageSource' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ImpactForce) == 0x0000C8, "Member 'ULightProjectile::ImpactForce' has a wrong offset!");
static_assert(offsetof(ULightProjectile, InitialClientState) == 0x000108, "Member 'ULightProjectile::InitialClientState' has a wrong offset!");
static_assert(offsetof(ULightProjectile, AttachmentData) == 0x0001C0, "Member 'ULightProjectile::AttachmentData' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ExplodeData) == 0x000200, "Member 'ULightProjectile::ExplodeData' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ImpactInfo) == 0x000210, "Member 'ULightProjectile::ImpactInfo' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ShutdownID) == 0x000220, "Member 'ULightProjectile::ShutdownID' has a wrong offset!");
static_assert(offsetof(ULightProjectile, StartTime) == 0x000224, "Member 'ULightProjectile::StartTime' has a wrong offset!");
static_assert(offsetof(ULightProjectile, LifeTime) == 0x000228, "Member 'ULightProjectile::LifeTime' has a wrong offset!");
static_assert(offsetof(ULightProjectile, HomingStartTime) == 0x00022C, "Member 'ULightProjectile::HomingStartTime' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ElapsedTime) == 0x000230, "Member 'ULightProjectile::ElapsedTime' has a wrong offset!");
static_assert(offsetof(ULightProjectile, LastHitActor) == 0x000260, "Member 'ULightProjectile::LastHitActor' has a wrong offset!");
static_assert(offsetof(ULightProjectile, Location) == 0x0002A8, "Member 'ULightProjectile::Location' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ComponentLocation) == 0x0002B4, "Member 'ULightProjectile::ComponentLocation' has a wrong offset!");
static_assert(offsetof(ULightProjectile, ComponentRotation) == 0x0002C0, "Member 'ULightProjectile::ComponentRotation' has a wrong offset!");
static_assert(offsetof(ULightProjectile, LocalStartLocation) == 0x0002D8, "Member 'ULightProjectile::LocalStartLocation' has a wrong offset!");
static_assert(offsetof(ULightProjectile, LocalStartDirection) == 0x0002E4, "Member 'ULightProjectile::LocalStartDirection' has a wrong offset!");
static_assert(offsetof(ULightProjectile, Velocity) == 0x0002F0, "Member 'ULightProjectile::Velocity' has a wrong offset!");
static_assert(offsetof(ULightProjectile, GravityScale) == 0x0002FC, "Member 'ULightProjectile::GravityScale' has a wrong offset!");
static_assert(offsetof(ULightProjectile, BodyComponent) == 0x000300, "Member 'ULightProjectile::BodyComponent' has a wrong offset!");
static_assert(offsetof(ULightProjectile, TracerComponent) == 0x000308, "Member 'ULightProjectile::TracerComponent' has a wrong offset!");
static_assert(offsetof(ULightProjectile, Components) == 0x000310, "Member 'ULightProjectile::Components' has a wrong offset!");
static_assert(offsetof(ULightProjectile, NumBounces) == 0x000358, "Member 'ULightProjectile::NumBounces' has a wrong offset!");
static_assert(offsetof(ULightProjectile, DamageModifierComp) == 0x000378, "Member 'ULightProjectile::DamageModifierComp' has a wrong offset!");

// Class GbxWeapon.LightProjectileRandomDrunkenModifier
// 0x0038 (0x0068 - 0x0030)
class ULightProjectileRandomDrunkenModifier final : public ULightProjectileMoveModifier
{
public:
	float                                         PathCorrectionInterval;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpreadAngle;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepartureAngle;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravityAffectsDrunkenness;                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrunkenGravityScalar;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartApproachDistance;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelayTime;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EaseInTime;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizedEaseTime;                               // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxEasingFunc                         EaseInFunc;                                        // 0x0058(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileRandomDrunkenModifier">();
	}
	static class ULightProjectileRandomDrunkenModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileRandomDrunkenModifier>();
	}
};
static_assert(alignof(ULightProjectileRandomDrunkenModifier) == 0x000008, "Wrong alignment on ULightProjectileRandomDrunkenModifier");
static_assert(sizeof(ULightProjectileRandomDrunkenModifier) == 0x000068, "Wrong size on ULightProjectileRandomDrunkenModifier");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, PathCorrectionInterval) == 0x000030, "Member 'ULightProjectileRandomDrunkenModifier::PathCorrectionInterval' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, TurnSpeed) == 0x000034, "Member 'ULightProjectileRandomDrunkenModifier::TurnSpeed' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, MaxSpreadAngle) == 0x000038, "Member 'ULightProjectileRandomDrunkenModifier::MaxSpreadAngle' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, MaxDepartureAngle) == 0x00003C, "Member 'ULightProjectileRandomDrunkenModifier::MaxDepartureAngle' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, bGravityAffectsDrunkenness) == 0x000040, "Member 'ULightProjectileRandomDrunkenModifier::bGravityAffectsDrunkenness' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, DrunkenGravityScalar) == 0x000044, "Member 'ULightProjectileRandomDrunkenModifier::DrunkenGravityScalar' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, StartApproachDistance) == 0x000048, "Member 'ULightProjectileRandomDrunkenModifier::StartApproachDistance' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, StartDelayTime) == 0x00004C, "Member 'ULightProjectileRandomDrunkenModifier::StartDelayTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, EaseInTime) == 0x000050, "Member 'ULightProjectileRandomDrunkenModifier::EaseInTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, bNormalizedEaseTime) == 0x000054, "Member 'ULightProjectileRandomDrunkenModifier::bNormalizedEaseTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileRandomDrunkenModifier, EaseInFunc) == 0x000058, "Member 'ULightProjectileRandomDrunkenModifier::EaseInFunc' has a wrong offset!");

// Class GbxWeapon.LightProjectileData
// 0x0308 (0x0330 - 0x0028)
class ULightProjectileData : public UObject
{
public:
	TSubclassOf<class ULightProjectile>           ProjectileClass;                                   // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BodyMesh;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BodyTransform;                                     // 0x0040(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxSignificanceEvent                  TracerSignificanceEvent;                           // 0x0070(0x0008)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ELightProjectileTracerThrottleLevel           MaxTracerThrottleLevel;                            // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TracerFX;                                          // 0x0080(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      TracerFXCollection;                                // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TracerFXBodySocket;                                // 0x0090(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TracerFXTransform;                                 // 0x00A0(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x00D0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayImpactEffectOnExplode : 1;                    // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UExplosionData*                         ExplosionData;                                     // 0x00E0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          DamageInstigatorFeedback;                          // 0x00E8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        AttachedFX;                                        // 0x00F0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      AttachedFXCollection;                              // 0x00F8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachedFXBodySocket;                              // 0x0100(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachedFXTransform;                               // 0x0110(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BounceEffectDelay;                                 // 0x0140(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0144(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0148(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InitialRelativeRotation;                           // 0x014C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0158(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x015C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0160(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetFriction;                                  // 0x0164(0x0004)(BlueprintReadOnly, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceFriction;                                    // 0x0168(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bounciness;                                        // 0x016C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULightProjectileMoveModifier*>   MoveModifiers;                                     // 0x0170(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0180(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAttachedLifetimeEnabled : 1;                      // 0x0184(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttachedLifetime;                                  // 0x0188(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x018C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceInterval;                                     // 0x0190(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0194(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRicochet;                                       // 0x0198(0x0004)(BlueprintReadOnly, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBounces;                                        // 0x019C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxReflections;                                    // 0x01A0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProxyRadius;                                       // 0x01A4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ProxyTraceChannel;                                 // 0x01A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreCollisionWithInstigator : 1;                // 0x01A9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetTeamCollision : 1;                             // 0x01A9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCollisionWithInstigatorTeam : 1;            // 0x01A9(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPenetratesTargetables : 1;                        // 0x01A9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPenetratesWorld : 1;                              // 0x01A9(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBounceOffTargetables : 1;                         // 0x01A9(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCollideWithSource : 1;                            // 0x01A9(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableProxyCollisionEvents : 1;                   // 0x01A9(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1AA[0x2];                                      // 0x01AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollideWithSourceDelay;                            // 0x01AC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLightProjectileTimedEvent>     TimedEvents;                                       // 0x01B0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBulletPerceptionProperties            BulletSensePerception;                             // 0x01C0(0x0008)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSoundPerceptionProperties             ImpactSoundPerception;                             // 0x01C8(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bCanTriggerBulletDodges : 1;                       // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTargetedImpactRadiusDamage : 1;                   // 0x01D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageRadius;                                      // 0x01D8(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0210(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageAreaData;                                    // 0x0218(0x0008)(BlueprintReadOnly, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0220(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAreaHitOffset;                               // 0x0228(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDamageFalloff : 1;                                // 0x022C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequiresInstigatorToDoDamage : 1;                 // 0x022C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttachDamageScale;                                 // 0x0230(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ImpactedActorDamageScale;                          // 0x0238(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UConditionalDamageModifier*>     ConditionalDamageModifiers;                        // 0x0270(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLightProjectileAudioProperties        AudioProperties;                                   // 0x0280(0x0040)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            AttachedSound;                                     // 0x02C0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanAttachToTargetables : 1;                       // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanAttachToFriendlies : 1;                        // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanAttachToWorld : 1;                             // 0x02C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideBodyOnAttach : 1;                             // 0x02C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDeactivateTracerFXOnAttach : 1;                   // 0x02C8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DeactivateTracerFXEmitterOnAttach;                 // 0x02D0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableHomingOnSpawn : 1;                          // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideAimAssistSettings : 1;                    // 0x02D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MagnetismRate;                                     // 0x02DC(0x0008)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMagnetismDeflection;                            // 0x02E4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightProjectileRingSettings           RingSettings;                                      // 0x02E8(0x0030)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bMakeProjectileRing : 1;                           // 0x0318(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_319[0xF];                                      // 0x0319(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCallOnDamageEventOncePerHit;                      // 0x0328(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetTimedEventNameList(TArray<class FName>* FuncList) const;
	void OnAttached(class ULightProjectile* Projectile, class AActor* AttachedActor) const;
	void OnBegin(class ULightProjectile* Projectile) const;
	void OnDamage(class ULightProjectile* Projectile, const struct FHitResult& Hit, bool bCritical) const;
	void OnExplode(class ULightProjectile* Projectile) const;
	void OnImpact(class ULightProjectile* Projectile, const struct FHitResult& Hit) const;
	void OnLifetimeExpired(class ULightProjectile* Projectile) const;
	void OnProxyImpact(class ULightProjectile* Projectile, const struct FHitResult& Hit) const;
	void OnRicochet(class ULightProjectile* Projectile, const struct FHitResult& Hit, const struct FVector& ImpactVelocity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileData">();
	}
	static class ULightProjectileData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileData>();
	}
};
static_assert(alignof(ULightProjectileData) == 0x000010, "Wrong alignment on ULightProjectileData");
static_assert(sizeof(ULightProjectileData) == 0x000330, "Wrong size on ULightProjectileData");
static_assert(offsetof(ULightProjectileData, ProjectileClass) == 0x000028, "Member 'ULightProjectileData::ProjectileClass' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, BodyMesh) == 0x000030, "Member 'ULightProjectileData::BodyMesh' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, BodyTransform) == 0x000040, "Member 'ULightProjectileData::BodyTransform' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TracerSignificanceEvent) == 0x000070, "Member 'ULightProjectileData::TracerSignificanceEvent' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MaxTracerThrottleLevel) == 0x000078, "Member 'ULightProjectileData::MaxTracerThrottleLevel' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TracerFX) == 0x000080, "Member 'ULightProjectileData::TracerFX' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TracerFXCollection) == 0x000088, "Member 'ULightProjectileData::TracerFXCollection' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TracerFXBodySocket) == 0x000090, "Member 'ULightProjectileData::TracerFXBodySocket' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TracerFXTransform) == 0x0000A0, "Member 'ULightProjectileData::TracerFXTransform' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ImpactData) == 0x0000D0, "Member 'ULightProjectileData::ImpactData' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ExplosionData) == 0x0000E0, "Member 'ULightProjectileData::ExplosionData' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DamageInstigatorFeedback) == 0x0000E8, "Member 'ULightProjectileData::DamageInstigatorFeedback' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachedFX) == 0x0000F0, "Member 'ULightProjectileData::AttachedFX' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachedFXCollection) == 0x0000F8, "Member 'ULightProjectileData::AttachedFXCollection' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachedFXBodySocket) == 0x000100, "Member 'ULightProjectileData::AttachedFXBodySocket' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachedFXTransform) == 0x000110, "Member 'ULightProjectileData::AttachedFXTransform' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, BounceEffectDelay) == 0x000140, "Member 'ULightProjectileData::BounceEffectDelay' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, Speed) == 0x000144, "Member 'ULightProjectileData::Speed' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MaxSpeed) == 0x000148, "Member 'ULightProjectileData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, InitialRelativeRotation) == 0x00014C, "Member 'ULightProjectileData::InitialRelativeRotation' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, Acceleration) == 0x000158, "Member 'ULightProjectileData::Acceleration' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, GravityScale) == 0x00015C, "Member 'ULightProjectileData::GravityScale' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, Friction) == 0x000160, "Member 'ULightProjectileData::Friction' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, RicochetFriction) == 0x000164, "Member 'ULightProjectileData::RicochetFriction' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, BounceFriction) == 0x000168, "Member 'ULightProjectileData::BounceFriction' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, Bounciness) == 0x00016C, "Member 'ULightProjectileData::Bounciness' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MoveModifiers) == 0x000170, "Member 'ULightProjectileData::MoveModifiers' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, LifeTime) == 0x000180, "Member 'ULightProjectileData::LifeTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachedLifetime) == 0x000188, "Member 'ULightProjectileData::AttachedLifetime' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TraceChannel) == 0x00018C, "Member 'ULightProjectileData::TraceChannel' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TraceInterval) == 0x000190, "Member 'ULightProjectileData::TraceInterval' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, CollisionRadius) == 0x000194, "Member 'ULightProjectileData::CollisionRadius' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MaxRicochet) == 0x000198, "Member 'ULightProjectileData::MaxRicochet' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MaxBounces) == 0x00019C, "Member 'ULightProjectileData::MaxBounces' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MaxReflections) == 0x0001A0, "Member 'ULightProjectileData::MaxReflections' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ProxyRadius) == 0x0001A4, "Member 'ULightProjectileData::ProxyRadius' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ProxyTraceChannel) == 0x0001A8, "Member 'ULightProjectileData::ProxyTraceChannel' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, CollideWithSourceDelay) == 0x0001AC, "Member 'ULightProjectileData::CollideWithSourceDelay' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, TimedEvents) == 0x0001B0, "Member 'ULightProjectileData::TimedEvents' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, BulletSensePerception) == 0x0001C0, "Member 'ULightProjectileData::BulletSensePerception' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ImpactSoundPerception) == 0x0001C8, "Member 'ULightProjectileData::ImpactSoundPerception' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DamageRadius) == 0x0001D8, "Member 'ULightProjectileData::DamageRadius' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DamageSource) == 0x000210, "Member 'ULightProjectileData::DamageSource' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DamageAreaData) == 0x000218, "Member 'ULightProjectileData::DamageAreaData' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DamageData) == 0x000220, "Member 'ULightProjectileData::DamageData' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DamageAreaHitOffset) == 0x000228, "Member 'ULightProjectileData::DamageAreaHitOffset' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachDamageScale) == 0x000230, "Member 'ULightProjectileData::AttachDamageScale' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ImpactedActorDamageScale) == 0x000238, "Member 'ULightProjectileData::ImpactedActorDamageScale' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, ConditionalDamageModifiers) == 0x000270, "Member 'ULightProjectileData::ConditionalDamageModifiers' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AudioProperties) == 0x000280, "Member 'ULightProjectileData::AudioProperties' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, AttachedSound) == 0x0002C0, "Member 'ULightProjectileData::AttachedSound' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, DeactivateTracerFXEmitterOnAttach) == 0x0002D0, "Member 'ULightProjectileData::DeactivateTracerFXEmitterOnAttach' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MagnetismRate) == 0x0002DC, "Member 'ULightProjectileData::MagnetismRate' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, MaxMagnetismDeflection) == 0x0002E4, "Member 'ULightProjectileData::MaxMagnetismDeflection' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, RingSettings) == 0x0002E8, "Member 'ULightProjectileData::RingSettings' has a wrong offset!");
static_assert(offsetof(ULightProjectileData, bCallOnDamageEventOncePerHit) == 0x000328, "Member 'ULightProjectileData::bCallOnDamageEventOncePerHit' has a wrong offset!");

// Class GbxWeapon.LightBeamManager
// 0x00B0 (0x0508 - 0x0458)
class ALightBeamManager final : public AActor
{
public:
	TArray<class ULightBeam*>                     ActiveBeams;                                       // 0x0458(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULightBeam*>                     BeamPool;                                          // 0x0468(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UParticleSystemComponent*>       ActiveParticles;                                   // 0x0478(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FLightBeamParticlePoolData>     ParticlesPool;                                     // 0x0488(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x70];                                     // 0x0498(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBeamManager">();
	}
	static class ALightBeamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightBeamManager>();
	}
};
static_assert(alignof(ALightBeamManager) == 0x000008, "Wrong alignment on ALightBeamManager");
static_assert(sizeof(ALightBeamManager) == 0x000508, "Wrong size on ALightBeamManager");
static_assert(offsetof(ALightBeamManager, ActiveBeams) == 0x000458, "Member 'ALightBeamManager::ActiveBeams' has a wrong offset!");
static_assert(offsetof(ALightBeamManager, BeamPool) == 0x000468, "Member 'ALightBeamManager::BeamPool' has a wrong offset!");
static_assert(offsetof(ALightBeamManager, ActiveParticles) == 0x000478, "Member 'ALightBeamManager::ActiveParticles' has a wrong offset!");
static_assert(offsetof(ALightBeamManager, ParticlesPool) == 0x000488, "Member 'ALightBeamManager::ParticlesPool' has a wrong offset!");

// Class GbxWeapon.LightBeam
// 0x05E8 (0x0610 - 0x0028)
class ULightBeam : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightBeamData*                         Data;                                              // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               Component;                                         // 0x00B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               AltViewComponent;                                  // 0x00C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageInterval;                                    // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockOnContactTime;                                 // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockOnBreakRadius;                                 // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockOnBreakAngle;                                  // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientLightBeamState                  ClientState;                                       // 0x00E0(0x00C8)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EWeaponShotModifierType                       ModifierType;                                      // 0x01A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x17];                                     // 0x01A9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifierValue;                                     // 0x01C0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize10                  ServerSourcePoint;                                 // 0x01C4(0x000C)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize10                  ServerTargetPoint;                                 // 0x01D0(0x000C)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x20];                                     // 0x01DC(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x30];                                     // 0x0200(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LastDamagedActor;                                  // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          DamagedActors;                                     // 0x0238(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         LastDamagedActorContinuousContact;                 // 0x0248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0xDC];                                     // 0x024C(0x00DC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastImpact;                                        // 0x0328(0x0090)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x18];                                     // 0x03B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightBeam*                             ParentBeam;                                        // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULightBeam*                             RootParentBeam;                                    // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULightBeam*>                     ChildBeams;                                        // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLightBeamImpactFXTrackingData> TrackingImpactEffects;                             // 0x0400(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x200];                                    // 0x0410(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LockOntoTarget(const struct FLightBeamAttachment& Target);
	void OnRep_ClientState();
	void OnRep_ModifierType();
	void OnRep_ModifierValue();
	void OnTrackedImpactParticleSystemFinished(class UParticleSystemComponent* PSC);
	void SetTargetSocket(class FName Socket);

	class AActor* GetAssociatedActor(ELightBeamQueryActorType ActorType) const;
	float GetDamage() const;
	class AActor* GetDamageCauser() const;
	const class UGbxDamageType* GetDamageType() const;
	float GetImpactForce() const;
	class APawn* GetInstigator() const;
	const struct FLightBeamAttachment GetSource() const;
	class AActor* GetSourceActor() const;
	const struct FLightBeamAttachment GetTarget() const;
	class AActor* GetTargetActor() const;
	void InitChildData(struct FLightBeamInitializationData* InitData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBeam">();
	}
	static class ULightBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightBeam>();
	}
};
static_assert(alignof(ULightBeam) == 0x000008, "Wrong alignment on ULightBeam");
static_assert(sizeof(ULightBeam) == 0x000610, "Wrong size on ULightBeam");
static_assert(offsetof(ULightBeam, Data) == 0x0000B0, "Member 'ULightBeam::Data' has a wrong offset!");
static_assert(offsetof(ULightBeam, Component) == 0x0000B8, "Member 'ULightBeam::Component' has a wrong offset!");
static_assert(offsetof(ULightBeam, AltViewComponent) == 0x0000C0, "Member 'ULightBeam::AltViewComponent' has a wrong offset!");
static_assert(offsetof(ULightBeam, DamageInterval) == 0x0000C8, "Member 'ULightBeam::DamageInterval' has a wrong offset!");
static_assert(offsetof(ULightBeam, LockOnContactTime) == 0x0000CC, "Member 'ULightBeam::LockOnContactTime' has a wrong offset!");
static_assert(offsetof(ULightBeam, LockOnBreakRadius) == 0x0000D0, "Member 'ULightBeam::LockOnBreakRadius' has a wrong offset!");
static_assert(offsetof(ULightBeam, LockOnBreakAngle) == 0x0000D4, "Member 'ULightBeam::LockOnBreakAngle' has a wrong offset!");
static_assert(offsetof(ULightBeam, ClientState) == 0x0000E0, "Member 'ULightBeam::ClientState' has a wrong offset!");
static_assert(offsetof(ULightBeam, ModifierType) == 0x0001A8, "Member 'ULightBeam::ModifierType' has a wrong offset!");
static_assert(offsetof(ULightBeam, ModifierValue) == 0x0001C0, "Member 'ULightBeam::ModifierValue' has a wrong offset!");
static_assert(offsetof(ULightBeam, ServerSourcePoint) == 0x0001C4, "Member 'ULightBeam::ServerSourcePoint' has a wrong offset!");
static_assert(offsetof(ULightBeam, ServerTargetPoint) == 0x0001D0, "Member 'ULightBeam::ServerTargetPoint' has a wrong offset!");
static_assert(offsetof(ULightBeam, StartTime) == 0x0001FC, "Member 'ULightBeam::StartTime' has a wrong offset!");
static_assert(offsetof(ULightBeam, LastDamagedActor) == 0x000230, "Member 'ULightBeam::LastDamagedActor' has a wrong offset!");
static_assert(offsetof(ULightBeam, DamagedActors) == 0x000238, "Member 'ULightBeam::DamagedActors' has a wrong offset!");
static_assert(offsetof(ULightBeam, LastDamagedActorContinuousContact) == 0x000248, "Member 'ULightBeam::LastDamagedActorContinuousContact' has a wrong offset!");
static_assert(offsetof(ULightBeam, LastImpact) == 0x000328, "Member 'ULightBeam::LastImpact' has a wrong offset!");
static_assert(offsetof(ULightBeam, ParentBeam) == 0x0003D0, "Member 'ULightBeam::ParentBeam' has a wrong offset!");
static_assert(offsetof(ULightBeam, RootParentBeam) == 0x0003D8, "Member 'ULightBeam::RootParentBeam' has a wrong offset!");
static_assert(offsetof(ULightBeam, ChildBeams) == 0x0003E0, "Member 'ULightBeam::ChildBeams' has a wrong offset!");
static_assert(offsetof(ULightBeam, TrackingImpactEffects) == 0x000400, "Member 'ULightBeam::TrackingImpactEffects' has a wrong offset!");

// Class GbxWeapon.EnvQueryGenerator_FindProjectileTargets
// 0x0040 (0x00A0 - 0x0060)
class UEnvQueryGenerator_FindProjectileTargets final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              Range;                                             // 0x0060(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          TargetSkipRangeCheckCondition;                     // 0x0090(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHostiles;                                    // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFriendlies;                                  // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNeutrals;                                    // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoFindTargetableComponents;                     // 0x009B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreNonHostileAttachedParent;                   // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_FindProjectileTargets">();
	}
	static class UEnvQueryGenerator_FindProjectileTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_FindProjectileTargets>();
	}
};
static_assert(alignof(UEnvQueryGenerator_FindProjectileTargets) == 0x000008, "Wrong alignment on UEnvQueryGenerator_FindProjectileTargets");
static_assert(sizeof(UEnvQueryGenerator_FindProjectileTargets) == 0x0000A0, "Wrong size on UEnvQueryGenerator_FindProjectileTargets");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, Range) == 0x000060, "Member 'UEnvQueryGenerator_FindProjectileTargets::Range' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, TargetSkipRangeCheckCondition) == 0x000090, "Member 'UEnvQueryGenerator_FindProjectileTargets::TargetSkipRangeCheckCondition' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, bAllowHostiles) == 0x000098, "Member 'UEnvQueryGenerator_FindProjectileTargets::bAllowHostiles' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, bAllowFriendlies) == 0x000099, "Member 'UEnvQueryGenerator_FindProjectileTargets::bAllowFriendlies' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, bAllowNeutrals) == 0x00009A, "Member 'UEnvQueryGenerator_FindProjectileTargets::bAllowNeutrals' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, bAlsoFindTargetableComponents) == 0x00009B, "Member 'UEnvQueryGenerator_FindProjectileTargets::bAlsoFindTargetableComponents' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindProjectileTargets, bIgnoreNonHostileAttachedParent) == 0x00009C, "Member 'UEnvQueryGenerator_FindProjectileTargets::bIgnoreNonHostileAttachedParent' has a wrong offset!");

// Class GbxWeapon.LightBeamData
// 0x01A0 (0x01C8 - 0x0028)
class ULightBeamData : public UObject
{
public:
	TSubclassOf<class ULightBeam>                 BeamClass;                                         // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BeamFX;                                            // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      BeamFXCollection;                                  // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ViewerBeamFX;                                      // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      ViewerBeamFXCollection;                            // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            LoopingImpactAudio;                                // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      AudioFXCollection;                                 // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceTangentStrengthOverDistance;                 // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTangentStrengthOverDistance;                 // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeamEmitterName;                                   // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExplosionData*                         ExplosionData;                                     // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x0080(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactFXFrequency;                                 // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowPenetrationImpacts : 1;                       // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoImpactDecals : 1;                               // 0x008C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ECollisionChannel                             TraceChannel;                                      // 0x008D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionRadius;                                   // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceInterval;                                     // 0x0094(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTraceSteps;                                     // 0x0098(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLength;                                         // 0x009C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLength;                                       // 0x00A0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowSpeed;                                         // 0x00A4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGrowOverTime : 1;                                 // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetTeamCollision : 1;                             // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCollisionWithInstigatorTeam : 1;            // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPenetratesTargetables : 1;                        // 0x00A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPenetratesWorld : 1;                              // 0x00A8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanTriggerBulletDodges : 1;                       // 0x00A8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELightBeamLock                                LockType;                                          // 0x00A9(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanAcquireLock : 1;                               // 0x00AA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlignToLockedTarget : 1;                          // 0x00AA(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanLockOntoFriendlies : 1;                        // 0x00AA(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWorldCollisionBreaksLock : 1;                     // 0x00AA(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageInterval;                                    // 0x00AC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDamageDirectTargetOnce : 1;                       // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x00B8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UConditionalDamageModifier*>     ConditionalDamageModifiers;                        // 0x00C0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEnableDamageProxy : 1;                            // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageProxyRadius;                                 // 0x00D4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamageProxyTraceChannel;                           // 0x00D8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DamageProxyRadiusCurve;                            // 0x00E0(0x0078)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bScaleDamageProxyRadiusByCurve : 1;                // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableDragWhenLocked : 1;                        // 0x0158(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DragSpeed;                                         // 0x015C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDragRadius;                                     // 0x0160(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2DWaveform>              SpreadWaveforms;                                   // 0x0168(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSpreadWaveformIsAngle : 1;                        // 0x0178(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadWaveformTimeScale;                           // 0x017C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnSpreadScale;                                 // 0x0180(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyAccuracyToSpread : 1;                        // 0x0184(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxChains;                                         // 0x0188(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxChainDepth;                                     // 0x018C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightBeamData>             ChainBeamData;                                     // 0x0190(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              ChainTargetsQuery;                                 // 0x0198(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChainTargetsQueryMaxRangeParam;                    // 0x01A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChainDelay;                                        // 0x01A8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChainInterval;                                     // 0x01AC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChainDistance;                                  // 0x01B0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChainBreakDistance;                                // 0x01B4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetUpdateTime;                                     // 0x01B8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0xC];                                      // 0x01BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanLockOn(class ULightBeam* Beam, class AActor* TargetActor) const;
	float UpdateTarget(class ULightBeam* Beam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBeamData">();
	}
	static class ULightBeamData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightBeamData>();
	}
};
static_assert(alignof(ULightBeamData) == 0x000008, "Wrong alignment on ULightBeamData");
static_assert(sizeof(ULightBeamData) == 0x0001C8, "Wrong size on ULightBeamData");
static_assert(offsetof(ULightBeamData, BeamClass) == 0x000028, "Member 'ULightBeamData::BeamClass' has a wrong offset!");
static_assert(offsetof(ULightBeamData, LifeTime) == 0x000030, "Member 'ULightBeamData::LifeTime' has a wrong offset!");
static_assert(offsetof(ULightBeamData, BeamFX) == 0x000038, "Member 'ULightBeamData::BeamFX' has a wrong offset!");
static_assert(offsetof(ULightBeamData, BeamFXCollection) == 0x000040, "Member 'ULightBeamData::BeamFXCollection' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ViewerBeamFX) == 0x000048, "Member 'ULightBeamData::ViewerBeamFX' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ViewerBeamFXCollection) == 0x000050, "Member 'ULightBeamData::ViewerBeamFXCollection' has a wrong offset!");
static_assert(offsetof(ULightBeamData, LoopingImpactAudio) == 0x000058, "Member 'ULightBeamData::LoopingImpactAudio' has a wrong offset!");
static_assert(offsetof(ULightBeamData, AudioFXCollection) == 0x000060, "Member 'ULightBeamData::AudioFXCollection' has a wrong offset!");
static_assert(offsetof(ULightBeamData, SourceTangentStrengthOverDistance) == 0x000068, "Member 'ULightBeamData::SourceTangentStrengthOverDistance' has a wrong offset!");
static_assert(offsetof(ULightBeamData, TargetTangentStrengthOverDistance) == 0x00006C, "Member 'ULightBeamData::TargetTangentStrengthOverDistance' has a wrong offset!");
static_assert(offsetof(ULightBeamData, BeamEmitterName) == 0x000070, "Member 'ULightBeamData::BeamEmitterName' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ExplosionData) == 0x000078, "Member 'ULightBeamData::ExplosionData' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ImpactData) == 0x000080, "Member 'ULightBeamData::ImpactData' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ImpactFXFrequency) == 0x000088, "Member 'ULightBeamData::ImpactFXFrequency' has a wrong offset!");
static_assert(offsetof(ULightBeamData, TraceChannel) == 0x00008D, "Member 'ULightBeamData::TraceChannel' has a wrong offset!");
static_assert(offsetof(ULightBeamData, CollisionRadius) == 0x000090, "Member 'ULightBeamData::CollisionRadius' has a wrong offset!");
static_assert(offsetof(ULightBeamData, TraceInterval) == 0x000094, "Member 'ULightBeamData::TraceInterval' has a wrong offset!");
static_assert(offsetof(ULightBeamData, NumTraceSteps) == 0x000098, "Member 'ULightBeamData::NumTraceSteps' has a wrong offset!");
static_assert(offsetof(ULightBeamData, MaxLength) == 0x00009C, "Member 'ULightBeamData::MaxLength' has a wrong offset!");
static_assert(offsetof(ULightBeamData, StartLength) == 0x0000A0, "Member 'ULightBeamData::StartLength' has a wrong offset!");
static_assert(offsetof(ULightBeamData, GrowSpeed) == 0x0000A4, "Member 'ULightBeamData::GrowSpeed' has a wrong offset!");
static_assert(offsetof(ULightBeamData, LockType) == 0x0000A9, "Member 'ULightBeamData::LockType' has a wrong offset!");
static_assert(offsetof(ULightBeamData, DamageInterval) == 0x0000AC, "Member 'ULightBeamData::DamageInterval' has a wrong offset!");
static_assert(offsetof(ULightBeamData, DamageData) == 0x0000B8, "Member 'ULightBeamData::DamageData' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ConditionalDamageModifiers) == 0x0000C0, "Member 'ULightBeamData::ConditionalDamageModifiers' has a wrong offset!");
static_assert(offsetof(ULightBeamData, DamageProxyRadius) == 0x0000D4, "Member 'ULightBeamData::DamageProxyRadius' has a wrong offset!");
static_assert(offsetof(ULightBeamData, DamageProxyTraceChannel) == 0x0000D8, "Member 'ULightBeamData::DamageProxyTraceChannel' has a wrong offset!");
static_assert(offsetof(ULightBeamData, DamageProxyRadiusCurve) == 0x0000E0, "Member 'ULightBeamData::DamageProxyRadiusCurve' has a wrong offset!");
static_assert(offsetof(ULightBeamData, DragSpeed) == 0x00015C, "Member 'ULightBeamData::DragSpeed' has a wrong offset!");
static_assert(offsetof(ULightBeamData, MaxDragRadius) == 0x000160, "Member 'ULightBeamData::MaxDragRadius' has a wrong offset!");
static_assert(offsetof(ULightBeamData, SpreadWaveforms) == 0x000168, "Member 'ULightBeamData::SpreadWaveforms' has a wrong offset!");
static_assert(offsetof(ULightBeamData, SpreadWaveformTimeScale) == 0x00017C, "Member 'ULightBeamData::SpreadWaveformTimeScale' has a wrong offset!");
static_assert(offsetof(ULightBeamData, LockOnSpreadScale) == 0x000180, "Member 'ULightBeamData::LockOnSpreadScale' has a wrong offset!");
static_assert(offsetof(ULightBeamData, MaxChains) == 0x000188, "Member 'ULightBeamData::MaxChains' has a wrong offset!");
static_assert(offsetof(ULightBeamData, MaxChainDepth) == 0x00018C, "Member 'ULightBeamData::MaxChainDepth' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ChainBeamData) == 0x000190, "Member 'ULightBeamData::ChainBeamData' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ChainTargetsQuery) == 0x000198, "Member 'ULightBeamData::ChainTargetsQuery' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ChainTargetsQueryMaxRangeParam) == 0x0001A0, "Member 'ULightBeamData::ChainTargetsQueryMaxRangeParam' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ChainDelay) == 0x0001A8, "Member 'ULightBeamData::ChainDelay' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ChainInterval) == 0x0001AC, "Member 'ULightBeamData::ChainInterval' has a wrong offset!");
static_assert(offsetof(ULightBeamData, MaxChainDistance) == 0x0001B0, "Member 'ULightBeamData::MaxChainDistance' has a wrong offset!");
static_assert(offsetof(ULightBeamData, ChainBreakDistance) == 0x0001B4, "Member 'ULightBeamData::ChainBreakDistance' has a wrong offset!");
static_assert(offsetof(ULightBeamData, NetUpdateTime) == 0x0001B8, "Member 'ULightBeamData::NetUpdateTime' has a wrong offset!");

// Class GbxWeapon.WeaponAttachmentSlot
// 0x00A8 (0x00D0 - 0x0028)
class UWeaponAttachmentSlot final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocket;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         Mesh;                                              // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x4];                                       // 0x0040(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EWeaponTextureMipsSetting                     TextureMipsSetting;                                // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture*>                       CachedForceMipTextures;                            // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponEffectAttachment>        AttachmentEffects;                                 // 0x0060(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponMaterialEffectInstance>  ActiveMaterialEffects;                             // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponSkeletalControlInstance> ActiveSkeletalControls;                            // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponTrinketAttachment>       TrinketAttachments;                                // 0x00A0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 SecondaryMeshes;                                   // 0x00B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMesh(class UMeshComponent* InMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAttachmentSlot">();
	}
	static class UWeaponAttachmentSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAttachmentSlot>();
	}
};
static_assert(alignof(UWeaponAttachmentSlot) == 0x000008, "Wrong alignment on UWeaponAttachmentSlot");
static_assert(sizeof(UWeaponAttachmentSlot) == 0x0000D0, "Wrong size on UWeaponAttachmentSlot");
static_assert(offsetof(UWeaponAttachmentSlot, AttachSocket) == 0x000030, "Member 'UWeaponAttachmentSlot::AttachSocket' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, Mesh) == 0x000038, "Member 'UWeaponAttachmentSlot::Mesh' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, TextureMipsSetting) == 0x000044, "Member 'UWeaponAttachmentSlot::TextureMipsSetting' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, CachedForceMipTextures) == 0x000048, "Member 'UWeaponAttachmentSlot::CachedForceMipTextures' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, AttachmentEffects) == 0x000060, "Member 'UWeaponAttachmentSlot::AttachmentEffects' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, ActiveMaterialEffects) == 0x000080, "Member 'UWeaponAttachmentSlot::ActiveMaterialEffects' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, ActiveSkeletalControls) == 0x000090, "Member 'UWeaponAttachmentSlot::ActiveSkeletalControls' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, TrinketAttachments) == 0x0000A0, "Member 'UWeaponAttachmentSlot::TrinketAttachments' has a wrong offset!");
static_assert(offsetof(UWeaponAttachmentSlot, SecondaryMeshes) == 0x0000B0, "Member 'UWeaponAttachmentSlot::SecondaryMeshes' has a wrong offset!");

// Class GbxWeapon.WeaponAnimInstance
// 0x0020 (0x0460 - 0x0440)
class UWeaponAnimInstance : public UAnimInstance
{
public:
	class AWeapon*                                Weapon;                                            // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachmentSlot*                  Slot;                                              // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDuration;                                      // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomEffect;                                        // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsZoomedIn;                                       // 0x0458(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintSwitchedMode(int32 NewMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimInstance">();
	}
	static class UWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimInstance>();
	}
};
static_assert(alignof(UWeaponAnimInstance) == 0x000008, "Wrong alignment on UWeaponAnimInstance");
static_assert(sizeof(UWeaponAnimInstance) == 0x000460, "Wrong size on UWeaponAnimInstance");
static_assert(offsetof(UWeaponAnimInstance, Weapon) == 0x000440, "Member 'UWeaponAnimInstance::Weapon' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, Slot) == 0x000448, "Member 'UWeaponAnimInstance::Slot' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, ZoomDuration) == 0x000450, "Member 'UWeaponAnimInstance::ZoomDuration' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, ZoomEffect) == 0x000454, "Member 'UWeaponAnimInstance::ZoomEffect' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, bIsZoomedIn) == 0x000458, "Member 'UWeaponAnimInstance::bIsZoomedIn' has a wrong offset!");

// Class GbxWeapon.WeaponRecoilGoodnessValueResolver
// 0x0000 (0x0028 - 0x0028)
class UWeaponRecoilGoodnessValueResolver final : public UAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponRecoilGoodnessValueResolver">();
	}
	static class UWeaponRecoilGoodnessValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponRecoilGoodnessValueResolver>();
	}
};
static_assert(alignof(UWeaponRecoilGoodnessValueResolver) == 0x000008, "Wrong alignment on UWeaponRecoilGoodnessValueResolver");
static_assert(sizeof(UWeaponRecoilGoodnessValueResolver) == 0x000028, "Wrong size on UWeaponRecoilGoodnessValueResolver");

// Class GbxWeapon.WalkingProjectileMovementComponent
// 0x0090 (0x0358 - 0x02C8)
class UWalkingProjectileMovementComponent : public UGbxProjectileMovementComponent
{
public:
	bool                                          bGravityAffectsSlopeWalking;                       // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWalkAngle;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallOffLedges;                                    // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStepUpHeight;                                   // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementFrozenMaxTime;                             // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounceOffWalls;                                   // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxWallBounces;                                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallBounciness;                                    // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideWalkingSpeed;                             // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingSpeedOverride;                              // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x38];                                     // 0x02F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHitUnwalkableSurface;                            // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnBecomeAirborne;                                  // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnLanded;                                          // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalkingProjectileMovementComponent">();
	}
	static class UWalkingProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalkingProjectileMovementComponent>();
	}
};
static_assert(alignof(UWalkingProjectileMovementComponent) == 0x000008, "Wrong alignment on UWalkingProjectileMovementComponent");
static_assert(sizeof(UWalkingProjectileMovementComponent) == 0x000358, "Wrong size on UWalkingProjectileMovementComponent");
static_assert(offsetof(UWalkingProjectileMovementComponent, bGravityAffectsSlopeWalking) == 0x0002C8, "Member 'UWalkingProjectileMovementComponent::bGravityAffectsSlopeWalking' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, MaxWalkAngle) == 0x0002CC, "Member 'UWalkingProjectileMovementComponent::MaxWalkAngle' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, bFallOffLedges) == 0x0002D0, "Member 'UWalkingProjectileMovementComponent::bFallOffLedges' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, MaxStepUpHeight) == 0x0002D4, "Member 'UWalkingProjectileMovementComponent::MaxStepUpHeight' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, MovementFrozenMaxTime) == 0x0002D8, "Member 'UWalkingProjectileMovementComponent::MovementFrozenMaxTime' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, bBounceOffWalls) == 0x0002DC, "Member 'UWalkingProjectileMovementComponent::bBounceOffWalls' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, MaxWallBounces) == 0x0002E0, "Member 'UWalkingProjectileMovementComponent::MaxWallBounces' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, WallBounciness) == 0x0002E4, "Member 'UWalkingProjectileMovementComponent::WallBounciness' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, bOverrideWalkingSpeed) == 0x0002E8, "Member 'UWalkingProjectileMovementComponent::bOverrideWalkingSpeed' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, WalkingSpeedOverride) == 0x0002EC, "Member 'UWalkingProjectileMovementComponent::WalkingSpeedOverride' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, OnHitUnwalkableSurface) == 0x000328, "Member 'UWalkingProjectileMovementComponent::OnHitUnwalkableSurface' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, OnBecomeAirborne) == 0x000338, "Member 'UWalkingProjectileMovementComponent::OnBecomeAirborne' has a wrong offset!");
static_assert(offsetof(UWalkingProjectileMovementComponent, OnLanded) == 0x000348, "Member 'UWalkingProjectileMovementComponent::OnLanded' has a wrong offset!");

// Class GbxWeapon.WeaponAmmoComponent
// 0x0038 (0x01B0 - 0x0178)
class UWeaponAmmoComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAmmoTypeData*                       AmmoTypeData;                                      // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayAmmoInHUD;                                 // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   NotifyAmmoChanged;                                 // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClientRefillAmmo(int32 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAmmoComponent">();
	}
	static class UWeaponAmmoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAmmoComponent>();
	}
};
static_assert(alignof(UWeaponAmmoComponent) == 0x000008, "Wrong alignment on UWeaponAmmoComponent");
static_assert(sizeof(UWeaponAmmoComponent) == 0x0001B0, "Wrong size on UWeaponAmmoComponent");
static_assert(offsetof(UWeaponAmmoComponent, AmmoTypeData) == 0x000180, "Member 'UWeaponAmmoComponent::AmmoTypeData' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoComponent, bDisplayAmmoInHUD) == 0x000188, "Member 'UWeaponAmmoComponent::bDisplayAmmoInHUD' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoComponent, NotifyAmmoChanged) == 0x000190, "Member 'UWeaponAmmoComponent::NotifyAmmoChanged' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoComponent, WeaponPrivate) == 0x0001A8, "Member 'UWeaponAmmoComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.WeaponAmmoRegenAttributeValueResolver
// 0x0000 (0x0028 - 0x0028)
class UWeaponAmmoRegenAttributeValueResolver final : public UAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAmmoRegenAttributeValueResolver">();
	}
	static class UWeaponAmmoRegenAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAmmoRegenAttributeValueResolver>();
	}
};
static_assert(alignof(UWeaponAmmoRegenAttributeValueResolver) == 0x000008, "Wrong alignment on UWeaponAmmoRegenAttributeValueResolver");
static_assert(sizeof(UWeaponAmmoRegenAttributeValueResolver) == 0x000028, "Wrong size on UWeaponAmmoRegenAttributeValueResolver");

// Class GbxWeapon.WeaponReloadComponent
// 0x0060 (0x01D8 - 0x0178)
class UWeaponReloadComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReloadPartType;                                    // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   NotifyReloadStarted;                               // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyReloadEnded;                                 // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyAmmoGiven;                                   // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ReloadTime;                                        // 0x01C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponReloadComponent">();
	}
	static class UWeaponReloadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponReloadComponent>();
	}
};
static_assert(alignof(UWeaponReloadComponent) == 0x000008, "Wrong alignment on UWeaponReloadComponent");
static_assert(sizeof(UWeaponReloadComponent) == 0x0001D8, "Wrong size on UWeaponReloadComponent");
static_assert(offsetof(UWeaponReloadComponent, ReloadPartType) == 0x000188, "Member 'UWeaponReloadComponent::ReloadPartType' has a wrong offset!");
static_assert(offsetof(UWeaponReloadComponent, NotifyReloadStarted) == 0x000190, "Member 'UWeaponReloadComponent::NotifyReloadStarted' has a wrong offset!");
static_assert(offsetof(UWeaponReloadComponent, NotifyReloadEnded) == 0x0001A0, "Member 'UWeaponReloadComponent::NotifyReloadEnded' has a wrong offset!");
static_assert(offsetof(UWeaponReloadComponent, NotifyAmmoGiven) == 0x0001B0, "Member 'UWeaponReloadComponent::NotifyAmmoGiven' has a wrong offset!");
static_assert(offsetof(UWeaponReloadComponent, ReloadTime) == 0x0001C0, "Member 'UWeaponReloadComponent::ReloadTime' has a wrong offset!");
static_assert(offsetof(UWeaponReloadComponent, WeaponPrivate) == 0x0001D0, "Member 'UWeaponReloadComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.WeaponSkeletalControlBase
// 0x0068 (0x0090 - 0x0028)
class UWeaponSkeletalControlBase : public UObject
{
public:
	class FName                                   ControlName;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysUpdate : 1;                                 // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateWhenAmmoChanges : 1;                        // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartPaused : 1;                                  // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSyncToFireRate : 1;                               // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAddInputOnUse : 1;                                // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           UseInputValue;                                     // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinFireRate;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFireRate;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UseModeContextBitmask;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            ReceivedInputSound;                                // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAttachToBone : 1;                                 // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDefaultAudioComponent : 1;                     // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSkeletalControlBase">();
	}
	static class UWeaponSkeletalControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSkeletalControlBase>();
	}
};
static_assert(alignof(UWeaponSkeletalControlBase) == 0x000008, "Wrong alignment on UWeaponSkeletalControlBase");
static_assert(sizeof(UWeaponSkeletalControlBase) == 0x000090, "Wrong size on UWeaponSkeletalControlBase");
static_assert(offsetof(UWeaponSkeletalControlBase, ControlName) == 0x000028, "Member 'UWeaponSkeletalControlBase::ControlName' has a wrong offset!");
static_assert(offsetof(UWeaponSkeletalControlBase, UseInputValue) == 0x000038, "Member 'UWeaponSkeletalControlBase::UseInputValue' has a wrong offset!");
static_assert(offsetof(UWeaponSkeletalControlBase, MinFireRate) == 0x000070, "Member 'UWeaponSkeletalControlBase::MinFireRate' has a wrong offset!");
static_assert(offsetof(UWeaponSkeletalControlBase, MaxFireRate) == 0x000074, "Member 'UWeaponSkeletalControlBase::MaxFireRate' has a wrong offset!");
static_assert(offsetof(UWeaponSkeletalControlBase, UseModeContextBitmask) == 0x000078, "Member 'UWeaponSkeletalControlBase::UseModeContextBitmask' has a wrong offset!");
static_assert(offsetof(UWeaponSkeletalControlBase, ReceivedInputSound) == 0x000080, "Member 'UWeaponSkeletalControlBase::ReceivedInputSound' has a wrong offset!");

// Class GbxWeapon.WeaponZoomComponent
// 0x0170 (0x02E8 - 0x0178)
class UWeaponZoomComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponZoomLevel>               ZoomLevels;                                        // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InstigatorAccuracyScale;                           // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewModelShotOffsetScale;                          // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewModelLeadingScale;                             // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAnimationAlpha;                            // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchAnimationMagnitudeScale;                     // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUnzoomWhenSwitchingModes;                    // 0x01AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModeFOVScale;                                      // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModeTransitionDuration;                            // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EyeSocket;                                         // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScopeSocket;                                   // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FrontScopeSocket;                                  // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontSightSocket;                                  // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RearSightSocket;                                   // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVScale;                                          // 0x01E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationScale;                                     // 0x01E4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCrosshairWhenZoomed;                          // 0x01E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAttributesWhenFullyZoomed;                   // 0x01E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA[0x6];                                      // 0x01EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeEffectData>           AttributeEffects;                                  // 0x01F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAttributeEffectData>           InstigatorAttributeEffects;                        // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   DepthOfFieldFocusSocket;                           // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableBlurVignetteSize : 1;                       // 0x0218(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideStartBlurVignetteSize : 1;                // 0x0218(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideBlurVignetteSharpness : 1;                // 0x0218(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableColorVignetteSize : 1;                      // 0x0218(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideStartColorVignetteSize : 1;               // 0x0218(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideColorVignetteSharpness : 1;               // 0x0218(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLongitudinalMotionScale : 1;              // 0x0218(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLateralMotionScale : 1;                   // 0x0218(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlurVignetteSize;                                  // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartBlurVignetteSize;                             // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurVignetteSharpness;                             // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorVignetteSize;                                 // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartColorVignetteSize;                            // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorVignetteSharpness;                            // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongitudinalMotionScale;                           // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateralMotionScale;                                // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          UseFeedback;                                       // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseFeedbackScale;                                  // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   NotifyZoomingIn;                                   // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyZoomedIn;                                    // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyZoomingOut;                                  // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyZoomedOut;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bApplyWeaponModeZoom;                              // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeaponZoomState                       ZoomState;                                         // 0x0291(0x0002)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponZoomState                       ReplicatedZoomState;                               // 0x0293(0x0002)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         DesiredZoomLevel;                                  // 0x0295(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_296[0x2];                                      // 0x0296(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomStartTime;                                     // 0x0298(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomTransitionStartTime;                           // 0x029C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGbxAttributeModifierHandle>    AttributeModifiers;                                // 0x02A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGbxAttributeModifierHandle>    InstigatorAttributeModifiers;                      // 0x02B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         CachedWeaponModeIndex;                             // 0x02C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x1F];                                     // 0x02C1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAttached();
	void OnDetached();
	void OnRep_ReplicatedZoomState();
	void OnSwitchedWeaponMode();

	float GetMaxZoomFOVScale() const;
	float GetMaxZoomFOVScaleWithMode(uint8 ModeIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponZoomComponent">();
	}
	static class UWeaponZoomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponZoomComponent>();
	}
};
static_assert(alignof(UWeaponZoomComponent) == 0x000008, "Wrong alignment on UWeaponZoomComponent");
static_assert(sizeof(UWeaponZoomComponent) == 0x0002E8, "Wrong size on UWeaponZoomComponent");
static_assert(offsetof(UWeaponZoomComponent, ZoomLevels) == 0x000188, "Member 'UWeaponZoomComponent::ZoomLevels' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, InstigatorAccuracyScale) == 0x000198, "Member 'UWeaponZoomComponent::InstigatorAccuracyScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ViewModelShotOffsetScale) == 0x00019C, "Member 'UWeaponZoomComponent::ViewModelShotOffsetScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ViewModelLeadingScale) == 0x0001A0, "Member 'UWeaponZoomComponent::ViewModelLeadingScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, MovementAnimationAlpha) == 0x0001A4, "Member 'UWeaponZoomComponent::MovementAnimationAlpha' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, FlinchAnimationMagnitudeScale) == 0x0001A8, "Member 'UWeaponZoomComponent::FlinchAnimationMagnitudeScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, bForceUnzoomWhenSwitchingModes) == 0x0001AC, "Member 'UWeaponZoomComponent::bForceUnzoomWhenSwitchingModes' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ModeFOVScale) == 0x0001B0, "Member 'UWeaponZoomComponent::ModeFOVScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ModeTransitionDuration) == 0x0001B4, "Member 'UWeaponZoomComponent::ModeTransitionDuration' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, EyeSocket) == 0x0001B8, "Member 'UWeaponZoomComponent::EyeSocket' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, bUseScopeSocket) == 0x0001C0, "Member 'UWeaponZoomComponent::bUseScopeSocket' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, FrontScopeSocket) == 0x0001C8, "Member 'UWeaponZoomComponent::FrontScopeSocket' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, FrontSightSocket) == 0x0001D0, "Member 'UWeaponZoomComponent::FrontSightSocket' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, RearSightSocket) == 0x0001D8, "Member 'UWeaponZoomComponent::RearSightSocket' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, FOVScale) == 0x0001E0, "Member 'UWeaponZoomComponent::FOVScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, DurationScale) == 0x0001E4, "Member 'UWeaponZoomComponent::DurationScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, bShowCrosshairWhenZoomed) == 0x0001E8, "Member 'UWeaponZoomComponent::bShowCrosshairWhenZoomed' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, bApplyAttributesWhenFullyZoomed) == 0x0001E9, "Member 'UWeaponZoomComponent::bApplyAttributesWhenFullyZoomed' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, AttributeEffects) == 0x0001F0, "Member 'UWeaponZoomComponent::AttributeEffects' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, InstigatorAttributeEffects) == 0x000200, "Member 'UWeaponZoomComponent::InstigatorAttributeEffects' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, DepthOfFieldFocusSocket) == 0x000210, "Member 'UWeaponZoomComponent::DepthOfFieldFocusSocket' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, BlurVignetteSize) == 0x00021C, "Member 'UWeaponZoomComponent::BlurVignetteSize' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, StartBlurVignetteSize) == 0x000220, "Member 'UWeaponZoomComponent::StartBlurVignetteSize' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, BlurVignetteSharpness) == 0x000224, "Member 'UWeaponZoomComponent::BlurVignetteSharpness' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ColorVignetteSize) == 0x000228, "Member 'UWeaponZoomComponent::ColorVignetteSize' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, StartColorVignetteSize) == 0x00022C, "Member 'UWeaponZoomComponent::StartColorVignetteSize' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ColorVignetteSharpness) == 0x000230, "Member 'UWeaponZoomComponent::ColorVignetteSharpness' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, LongitudinalMotionScale) == 0x000234, "Member 'UWeaponZoomComponent::LongitudinalMotionScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, LateralMotionScale) == 0x000238, "Member 'UWeaponZoomComponent::LateralMotionScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, UseFeedback) == 0x000240, "Member 'UWeaponZoomComponent::UseFeedback' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, UseFeedbackScale) == 0x000248, "Member 'UWeaponZoomComponent::UseFeedbackScale' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, NotifyZoomingIn) == 0x000250, "Member 'UWeaponZoomComponent::NotifyZoomingIn' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, NotifyZoomedIn) == 0x000260, "Member 'UWeaponZoomComponent::NotifyZoomedIn' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, NotifyZoomingOut) == 0x000270, "Member 'UWeaponZoomComponent::NotifyZoomingOut' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, NotifyZoomedOut) == 0x000280, "Member 'UWeaponZoomComponent::NotifyZoomedOut' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, bApplyWeaponModeZoom) == 0x000290, "Member 'UWeaponZoomComponent::bApplyWeaponModeZoom' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ZoomState) == 0x000291, "Member 'UWeaponZoomComponent::ZoomState' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ReplicatedZoomState) == 0x000293, "Member 'UWeaponZoomComponent::ReplicatedZoomState' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, DesiredZoomLevel) == 0x000295, "Member 'UWeaponZoomComponent::DesiredZoomLevel' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ZoomStartTime) == 0x000298, "Member 'UWeaponZoomComponent::ZoomStartTime' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, ZoomTransitionStartTime) == 0x00029C, "Member 'UWeaponZoomComponent::ZoomTransitionStartTime' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, AttributeModifiers) == 0x0002A0, "Member 'UWeaponZoomComponent::AttributeModifiers' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, InstigatorAttributeModifiers) == 0x0002B0, "Member 'UWeaponZoomComponent::InstigatorAttributeModifiers' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, CachedWeaponModeIndex) == 0x0002C0, "Member 'UWeaponZoomComponent::CachedWeaponModeIndex' has a wrong offset!");
static_assert(offsetof(UWeaponZoomComponent, WeaponPrivate) == 0x0002E0, "Member 'UWeaponZoomComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.AmmoProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IAmmoProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoProviderInterface">();
	}
	static class IAmmoProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAmmoProviderInterface>();
	}
};
static_assert(alignof(IAmmoProviderInterface) == 0x000008, "Wrong alignment on IAmmoProviderInterface");
static_assert(sizeof(IAmmoProviderInterface) == 0x000028, "Wrong size on IAmmoProviderInterface");

// Class GbxWeapon.WeaponAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UWeaponAnimNotify : public UAnimNotify
{
public:
	bool                                          bTriggerOnFirstPerson;                             // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimNotify">();
	}
	static class UWeaponAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimNotify>();
	}
};
static_assert(alignof(UWeaponAnimNotify) == 0x000008, "Wrong alignment on UWeaponAnimNotify");
static_assert(sizeof(UWeaponAnimNotify) == 0x000040, "Wrong size on UWeaponAnimNotify");
static_assert(offsetof(UWeaponAnimNotify, bTriggerOnFirstPerson) == 0x000038, "Member 'UWeaponAnimNotify::bTriggerOnFirstPerson' has a wrong offset!");

// Class GbxWeapon.AnimNotify_AmmoReloaded
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_AmmoReloaded final : public UWeaponAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AmmoReloaded">();
	}
	static class UAnimNotify_AmmoReloaded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AmmoReloaded>();
	}
};
static_assert(alignof(UAnimNotify_AmmoReloaded) == 0x000008, "Wrong alignment on UAnimNotify_AmmoReloaded");
static_assert(sizeof(UAnimNotify_AmmoReloaded) == 0x000040, "Wrong size on UAnimNotify_AmmoReloaded");

// Class GbxWeapon.AnimNotify_EquipInterruptible
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_EquipInterruptible final : public UWeaponAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipInterruptible">();
	}
	static class UAnimNotify_EquipInterruptible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipInterruptible>();
	}
};
static_assert(alignof(UAnimNotify_EquipInterruptible) == 0x000008, "Wrong alignment on UAnimNotify_EquipInterruptible");
static_assert(sizeof(UAnimNotify_EquipInterruptible) == 0x000040, "Wrong size on UAnimNotify_EquipInterruptible");

// Class GbxWeapon.AnimNotify_WeaponSkeletalControlEvent
// 0x0018 (0x0058 - 0x0040)
class UAnimNotify_WeaponSkeletalControlEvent final : public UWeaponAnimNotify
{
public:
	EWeaponEffectType                             ControlType;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ControlName;                                       // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponSkeletalControlEvent                   ControlEvent;                                      // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ControlInput;                                      // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WeaponSkeletalControlEvent">();
	}
	static class UAnimNotify_WeaponSkeletalControlEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WeaponSkeletalControlEvent>();
	}
};
static_assert(alignof(UAnimNotify_WeaponSkeletalControlEvent) == 0x000008, "Wrong alignment on UAnimNotify_WeaponSkeletalControlEvent");
static_assert(sizeof(UAnimNotify_WeaponSkeletalControlEvent) == 0x000058, "Wrong size on UAnimNotify_WeaponSkeletalControlEvent");
static_assert(offsetof(UAnimNotify_WeaponSkeletalControlEvent, ControlType) == 0x000040, "Member 'UAnimNotify_WeaponSkeletalControlEvent::ControlType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponSkeletalControlEvent, ControlName) == 0x000048, "Member 'UAnimNotify_WeaponSkeletalControlEvent::ControlName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponSkeletalControlEvent, ControlEvent) == 0x000050, "Member 'UAnimNotify_WeaponSkeletalControlEvent::ControlEvent' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WeaponSkeletalControlEvent, ControlInput) == 0x000054, "Member 'UAnimNotify_WeaponSkeletalControlEvent::ControlInput' has a wrong offset!");

// Class GbxWeapon.BodyWeaponHoldManagerComponent
// 0x0020 (0x0198 - 0x0178)
class UBodyWeaponHoldManagerComponent final : public UActorComponent
{
public:
	class UBodyWeaponHoldData*                    DefaultWeaponHold;                                 // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBodyWeaponHoldData*>            WeaponHolds;                                       // 0x0180(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   UnarmedHoldName;                                   // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodyWeaponHoldManagerComponent">();
	}
	static class UBodyWeaponHoldManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodyWeaponHoldManagerComponent>();
	}
};
static_assert(alignof(UBodyWeaponHoldManagerComponent) == 0x000008, "Wrong alignment on UBodyWeaponHoldManagerComponent");
static_assert(sizeof(UBodyWeaponHoldManagerComponent) == 0x000198, "Wrong size on UBodyWeaponHoldManagerComponent");
static_assert(offsetof(UBodyWeaponHoldManagerComponent, DefaultWeaponHold) == 0x000178, "Member 'UBodyWeaponHoldManagerComponent::DefaultWeaponHold' has a wrong offset!");
static_assert(offsetof(UBodyWeaponHoldManagerComponent, WeaponHolds) == 0x000180, "Member 'UBodyWeaponHoldManagerComponent::WeaponHolds' has a wrong offset!");
static_assert(offsetof(UBodyWeaponHoldManagerComponent, UnarmedHoldName) == 0x000190, "Member 'UBodyWeaponHoldManagerComponent::UnarmedHoldName' has a wrong offset!");

// Class GbxWeapon.EnvQueryContext_ProjectileProxy
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_ProjectileProxy final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_ProjectileProxy">();
	}
	static class UEnvQueryContext_ProjectileProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_ProjectileProxy>();
	}
};
static_assert(alignof(UEnvQueryContext_ProjectileProxy) == 0x000008, "Wrong alignment on UEnvQueryContext_ProjectileProxy");
static_assert(sizeof(UEnvQueryContext_ProjectileProxy) == 0x000028, "Wrong size on UEnvQueryContext_ProjectileProxy");

// Class GbxWeapon.FiringPattern
// 0x0020 (0x0050 - 0x0030)
class UFiringPattern final : public UGbxDataAsset
{
public:
	TArray<struct FFiringPatternSample>           Samples;                                           // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NoClear, Protected, NativeAccessSpecifierProtected)
	uint8                                         bFireRandomlyFromPattern : 1;                      // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bResetPatternAfterEachShot : 1;                    // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScalePattern : 1;                                 // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLerpAcrossFiringLineBasedOnProjectileCountWithinEachShot : 1; // 0x0040(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSuppressWeaponSpread : 1;                         // 0x0040(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSingleWeaponSpread : 1;                           // 0x0040(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableTracerThrottling : 1;                      // 0x0040(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BasePatternScale;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinPatternScale;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RequiredProjectilesPerShot;                        // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FiringPattern">();
	}
	static class UFiringPattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFiringPattern>();
	}
};
static_assert(alignof(UFiringPattern) == 0x000008, "Wrong alignment on UFiringPattern");
static_assert(sizeof(UFiringPattern) == 0x000050, "Wrong size on UFiringPattern");
static_assert(offsetof(UFiringPattern, Samples) == 0x000030, "Member 'UFiringPattern::Samples' has a wrong offset!");
static_assert(offsetof(UFiringPattern, BasePatternScale) == 0x000044, "Member 'UFiringPattern::BasePatternScale' has a wrong offset!");
static_assert(offsetof(UFiringPattern, MinPatternScale) == 0x000048, "Member 'UFiringPattern::MinPatternScale' has a wrong offset!");
static_assert(offsetof(UFiringPattern, RequiredProjectilesPerShot) == 0x00004C, "Member 'UFiringPattern::RequiredProjectilesPerShot' has a wrong offset!");

// Class GbxWeapon.FiringPatternData
// 0x0020 (0x0048 - 0x0028)
class UFiringPatternData final : public UObject
{
public:
	TArray<struct FFiringPatternSample>           Samples;                                           // 0x0028(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bFireRandomlyFromPattern : 1;                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetPatternAfterEachShot : 1;                    // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScalePattern : 1;                                 // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLerpAcrossFiringLineBasedOnProjectileCountWithinEachShot : 1; // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuppressWeaponSpread : 1;                         // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSingleWeaponSpread : 1;                           // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BasePatternScale;                                  // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPatternScale;                                   // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredProjectilesPerShot;                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FiringPatternData">();
	}
	static class UFiringPatternData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFiringPatternData>();
	}
};
static_assert(alignof(UFiringPatternData) == 0x000008, "Wrong alignment on UFiringPatternData");
static_assert(sizeof(UFiringPatternData) == 0x000048, "Wrong size on UFiringPatternData");
static_assert(offsetof(UFiringPatternData, Samples) == 0x000028, "Member 'UFiringPatternData::Samples' has a wrong offset!");
static_assert(offsetof(UFiringPatternData, BasePatternScale) == 0x00003C, "Member 'UFiringPatternData::BasePatternScale' has a wrong offset!");
static_assert(offsetof(UFiringPatternData, MinPatternScale) == 0x000040, "Member 'UFiringPatternData::MinPatternScale' has a wrong offset!");
static_assert(offsetof(UFiringPatternData, RequiredProjectilesPerShot) == 0x000044, "Member 'UFiringPatternData::RequiredProjectilesPerShot' has a wrong offset!");

// Class GbxWeapon.GbxProjectileManager
// 0x0010 (0x0038 - 0x0028)
class UGbxProjectileManager final : public UIGbxProjectileManager
{
public:
	TArray<class UProjectileHomingComponent*>     HomingComponents;                                  // 0x0028(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxProjectileManager">();
	}
	static class UGbxProjectileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxProjectileManager>();
	}
};
static_assert(alignof(UGbxProjectileManager) == 0x000008, "Wrong alignment on UGbxProjectileManager");
static_assert(sizeof(UGbxProjectileManager) == 0x000038, "Wrong size on UGbxProjectileManager");
static_assert(offsetof(UGbxProjectileManager, HomingComponents) == 0x000028, "Member 'UGbxProjectileManager::HomingComponents' has a wrong offset!");

// Class GbxWeapon.GbxTrajectometerComponent
// 0x01C8 (0x0340 - 0x0178)
class UGbxTrajectometerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxTrajectometerProjectile*            SimulatorProjectile;                               // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               TrailParticle;                                     // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x10];                                     // 0x0190(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ProjectileUpdatedComp;                             // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x40];                                     // 0x01A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableOnStart;                                    // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulationStepTime;                                // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulationMaxTime;                                 // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGbxTrajectometerProjectile> SimulatorTemplate;                                 // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ProjectileSpeed;                                   // 0x0200(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ProjectileMaxSpeed;                                // 0x0238(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ProjectileAcceleration;                            // 0x0270(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ProjectileGravityScale;                            // 0x02A8(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ProjectileInitialDirection;                        // 0x02E0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxTrajectometerTraceData             TraceSettings;                                     // 0x02EC(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AProjectile>                ProjectileToSimulate;                              // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TrailEmitterTemplate;                              // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideSocket;                                    // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bStartFromWeapon : 1;                              // 0x0328(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartFromViewLocation : 1;                        // 0x0328(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSocketAsStartRotation : 1;                     // 0x0328(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSimulateWeaponProjectile : 1;                     // 0x0328(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseProjectileForCollision : 1;                    // 0x0328(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConvergeTowardsAimLocation : 1;                   // 0x0328(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPostSimulation;                                  // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetTrajectometerEnabled(bool bEnabled);
	void SimulationResultEvent__DelegateSignature(const struct FHitResult& HitResult);
	void UpdateCollisionShape();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTrajectometerComponent">();
	}
	static class UGbxTrajectometerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTrajectometerComponent>();
	}
};
static_assert(alignof(UGbxTrajectometerComponent) == 0x000008, "Wrong alignment on UGbxTrajectometerComponent");
static_assert(sizeof(UGbxTrajectometerComponent) == 0x000340, "Wrong size on UGbxTrajectometerComponent");
static_assert(offsetof(UGbxTrajectometerComponent, SimulatorProjectile) == 0x000180, "Member 'UGbxTrajectometerComponent::SimulatorProjectile' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, TrailParticle) == 0x000188, "Member 'UGbxTrajectometerComponent::TrailParticle' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileUpdatedComp) == 0x0001A0, "Member 'UGbxTrajectometerComponent::ProjectileUpdatedComp' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, bEnableOnStart) == 0x0001E8, "Member 'UGbxTrajectometerComponent::bEnableOnStart' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, SimulationStepTime) == 0x0001EC, "Member 'UGbxTrajectometerComponent::SimulationStepTime' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, SimulationMaxTime) == 0x0001F0, "Member 'UGbxTrajectometerComponent::SimulationMaxTime' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, SimulatorTemplate) == 0x0001F8, "Member 'UGbxTrajectometerComponent::SimulatorTemplate' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileSpeed) == 0x000200, "Member 'UGbxTrajectometerComponent::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileMaxSpeed) == 0x000238, "Member 'UGbxTrajectometerComponent::ProjectileMaxSpeed' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileAcceleration) == 0x000270, "Member 'UGbxTrajectometerComponent::ProjectileAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileGravityScale) == 0x0002A8, "Member 'UGbxTrajectometerComponent::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileInitialDirection) == 0x0002E0, "Member 'UGbxTrajectometerComponent::ProjectileInitialDirection' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, TraceSettings) == 0x0002EC, "Member 'UGbxTrajectometerComponent::TraceSettings' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, ProjectileToSimulate) == 0x000310, "Member 'UGbxTrajectometerComponent::ProjectileToSimulate' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, TrailEmitterTemplate) == 0x000318, "Member 'UGbxTrajectometerComponent::TrailEmitterTemplate' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, OverrideSocket) == 0x000320, "Member 'UGbxTrajectometerComponent::OverrideSocket' has a wrong offset!");
static_assert(offsetof(UGbxTrajectometerComponent, OnPostSimulation) == 0x000330, "Member 'UGbxTrajectometerComponent::OnPostSimulation' has a wrong offset!");

// Class GbxWeapon.GbxTrajectometerProjectile
// 0x0098 (0x0718 - 0x0680)
class AGbxTrajectometerProjectile final : public AProjectile
{
public:
	class UParticleSystemComponent*               TrailParticle;                                     // 0x0680(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x90];                                     // 0x0688(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTrajectometerProjectile">();
	}
	static class AGbxTrajectometerProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxTrajectometerProjectile>();
	}
};
static_assert(alignof(AGbxTrajectometerProjectile) == 0x000008, "Wrong alignment on AGbxTrajectometerProjectile");
static_assert(sizeof(AGbxTrajectometerProjectile) == 0x000718, "Wrong size on AGbxTrajectometerProjectile");
static_assert(offsetof(AGbxTrajectometerProjectile, TrailParticle) == 0x000680, "Member 'AGbxTrajectometerProjectile::TrailParticle' has a wrong offset!");

// Class GbxWeapon.GbxWeaponUserInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxWeaponUserInterface final : public IWeaponUserInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxWeaponUserInterface">();
	}
	static class IGbxWeaponUserInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxWeaponUserInterface>();
	}
};
static_assert(alignof(IGbxWeaponUserInterface) == 0x000008, "Wrong alignment on IGbxWeaponUserInterface");
static_assert(sizeof(IGbxWeaponUserInterface) == 0x000028, "Wrong size on IGbxWeaponUserInterface");

// Class GbxWeapon.LightBeamStatics
// 0x0000 (0x0028 - 0x0028)
class ULightBeamStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ClearBeamFlag(struct FLightBeamInitializationData& InitData, ELightBeamFlag Flag);
	static void CreateLightBeam(TSubclassOf<class ULightBeamData> Data, class APawn* Instigator, const struct FLightBeamAttachment& Source, const struct FLightBeamAttachment& Target, bool bTargetLocked, class FName NameId, float Damage, TSubclassOf<class UGbxDamageType> DamageType, TSubclassOf<class UDamageSource> DamageSource, float DamageRadius, class AActor* DamageCauser, class UImpactData* ImpactDataOverride, const struct FForceSelection& ImpactForce, float LifetimeOverride, bool bViewDependent);
	static void CreateLightBeamFromData(const struct FLightBeamInitializationData& InitData);
	static bool DoesLightBeamExist(const struct FLightBeamQueryData& Query);
	static void ForEachLightBeam(const struct FLightBeamQueryData& Query, const TDelegate<void(class ULightBeam* Beam)>& Callback);
	static bool IsBeamFlagSet(const struct FLightBeamInitializationData& InitData, ELightBeamFlag Flag);
	static void RemoveLightBeamsByActor(const struct FLightBeamQueryData& Query);
	static void RemoveLightBeamsBySource(class AActor* Source, class FName NameId);
	static void SetBeamFlag(struct FLightBeamInitializationData& InitData, ELightBeamFlag Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBeamStatics">();
	}
	static class ULightBeamStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightBeamStatics>();
	}
};
static_assert(alignof(ULightBeamStatics) == 0x000008, "Wrong alignment on ULightBeamStatics");
static_assert(sizeof(ULightBeamStatics) == 0x000028, "Wrong size on ULightBeamStatics");

// Class GbxWeapon.LightProjectileCurveModifier
// 0x0008 (0x0038 - 0x0030)
class ULightProjectileCurveModifier final : public ULightProjectileMoveModifier
{
public:
	float                                         StartTangentMultiplier;                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileCurveModifier">();
	}
	static class ULightProjectileCurveModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileCurveModifier>();
	}
};
static_assert(alignof(ULightProjectileCurveModifier) == 0x000008, "Wrong alignment on ULightProjectileCurveModifier");
static_assert(sizeof(ULightProjectileCurveModifier) == 0x000038, "Wrong size on ULightProjectileCurveModifier");
static_assert(offsetof(ULightProjectileCurveModifier, StartTangentMultiplier) == 0x000030, "Member 'ULightProjectileCurveModifier::StartTangentMultiplier' has a wrong offset!");

// Class GbxWeapon.LightProjectileHomingModifier
// 0x0040 (0x0070 - 0x0030)
class ULightProjectileHomingModifier final : public ULightProjectileMoveModifier
{
public:
	struct FRotator                               MaxTurnRate;                                       // 0x0030(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartApproachDistance;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalApproachDistance;                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApproachTurnRateScale;                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         ApproachEaseInFunc;                                // 0x0048(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBreakHomingWhenPassingTargetDuringFinalApproach;  // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseInTime;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         EaseInFunc;                                        // 0x005C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StopHomingDistance;                                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileHomingModifier">();
	}
	static class ULightProjectileHomingModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileHomingModifier>();
	}
};
static_assert(alignof(ULightProjectileHomingModifier) == 0x000008, "Wrong alignment on ULightProjectileHomingModifier");
static_assert(sizeof(ULightProjectileHomingModifier) == 0x000070, "Wrong size on ULightProjectileHomingModifier");
static_assert(offsetof(ULightProjectileHomingModifier, MaxTurnRate) == 0x000030, "Member 'ULightProjectileHomingModifier::MaxTurnRate' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, StartApproachDistance) == 0x00003C, "Member 'ULightProjectileHomingModifier::StartApproachDistance' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, FinalApproachDistance) == 0x000040, "Member 'ULightProjectileHomingModifier::FinalApproachDistance' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, ApproachTurnRateScale) == 0x000044, "Member 'ULightProjectileHomingModifier::ApproachTurnRateScale' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, ApproachEaseInFunc) == 0x000048, "Member 'ULightProjectileHomingModifier::ApproachEaseInFunc' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, bBreakHomingWhenPassingTargetDuringFinalApproach) == 0x000054, "Member 'ULightProjectileHomingModifier::bBreakHomingWhenPassingTargetDuringFinalApproach' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, EaseInTime) == 0x000058, "Member 'ULightProjectileHomingModifier::EaseInTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, EaseInFunc) == 0x00005C, "Member 'ULightProjectileHomingModifier::EaseInFunc' has a wrong offset!");
static_assert(offsetof(ULightProjectileHomingModifier, StopHomingDistance) == 0x000068, "Member 'ULightProjectileHomingModifier::StopHomingDistance' has a wrong offset!");

// Class GbxWeapon.LightProjectileStatics
// 0x0000 (0x0028 - 0x0028)
class ULightProjectileStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ClearProjectileFlag(struct FLightProjectileInitializationData& InitData, ELightProjectileFlag Flag);
	static void CreateLightProjectile(TSubclassOf<class ULightProjectileData> Data, const struct FVector& Location, const struct FVector& Direction, class APawn* Instigator, class AActor* Source, class AActor* DamageCauser, float Damage, TSubclassOf<class UGbxDamageType> DamageType, TSubclassOf<class UDamageSource> DamageSource, class UImpactData* ImpactDataOverride);
	static void CreateLightProjectileFromData(const struct FLightProjectileInitializationData& InitData);
	static void CreateLightProjectileFromDataAsync(const struct FLightProjectileInitializationData& InitData, float ForceSpawnTimer);
	static void CreateLightProjectileFromSource(class ULightProjectile* SourceProjectile, TSubclassOf<class ULightProjectileData> Data, const struct FVector& Location, const struct FVector& Direction, float Damage);
	static void DetonateLightProjectiles(const struct FLightProjectileQueryData& Query, float StackingEnemyBonusDamage, float MinDetonationDelay, float MaxDetonationDelay);
	static void ForEachLightProjectile(const struct FLightProjectileQueryData& Query, const TDelegate<void(class ULightProjectile* Projectile)>& Callback);
	static bool IsProjectileFlagSet(const struct FLightProjectileInitializationData& InitData, ELightProjectileFlag Flag);
	static void RemoveLightProjectilesByActor(const struct FLightProjectileQueryData& Query);
	static void SetHomingState(const struct FLightProjectileQueryData& Query, bool bIsHoming);
	static void SetProjectileFlag(struct FLightProjectileInitializationData& InitData, ELightProjectileFlag Flag);
	static void SplitLightProjectile(class ULightProjectile* Projectile, TSubclassOf<class ULightProjectileData> Data, ELightProjectileSplitPattern Pattern, int32 Count, float SpreadAngle, float RotateAngle, float OffsetDistance, bool bDestroySource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileStatics">();
	}
	static class ULightProjectileStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileStatics>();
	}
};
static_assert(alignof(ULightProjectileStatics) == 0x000008, "Wrong alignment on ULightProjectileStatics");
static_assert(sizeof(ULightProjectileStatics) == 0x000028, "Wrong size on ULightProjectileStatics");

// Class GbxWeapon.LightProjectileWaveModifier
// 0x0050 (0x0080 - 0x0030)
class ULightProjectileWaveModifier final : public ULightProjectileMoveModifier
{
public:
	TArray<struct FVector2DWaveform>              Waveforms;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GlobalWaveformScale;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorWaveform                        Waveform;                                          // 0x0044(0x0024)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EaseInTime;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizedEaseTime;                               // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxEasingFunc                         EaseInFunc;                                        // 0x0070(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRandomize;                                        // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightProjectileWaveModifier">();
	}
	static class ULightProjectileWaveModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightProjectileWaveModifier>();
	}
};
static_assert(alignof(ULightProjectileWaveModifier) == 0x000008, "Wrong alignment on ULightProjectileWaveModifier");
static_assert(sizeof(ULightProjectileWaveModifier) == 0x000080, "Wrong size on ULightProjectileWaveModifier");
static_assert(offsetof(ULightProjectileWaveModifier, Waveforms) == 0x000030, "Member 'ULightProjectileWaveModifier::Waveforms' has a wrong offset!");
static_assert(offsetof(ULightProjectileWaveModifier, GlobalWaveformScale) == 0x000040, "Member 'ULightProjectileWaveModifier::GlobalWaveformScale' has a wrong offset!");
static_assert(offsetof(ULightProjectileWaveModifier, Waveform) == 0x000044, "Member 'ULightProjectileWaveModifier::Waveform' has a wrong offset!");
static_assert(offsetof(ULightProjectileWaveModifier, EaseInTime) == 0x000068, "Member 'ULightProjectileWaveModifier::EaseInTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileWaveModifier, bNormalizedEaseTime) == 0x00006C, "Member 'ULightProjectileWaveModifier::bNormalizedEaseTime' has a wrong offset!");
static_assert(offsetof(ULightProjectileWaveModifier, EaseInFunc) == 0x000070, "Member 'ULightProjectileWaveModifier::EaseInFunc' has a wrong offset!");
static_assert(offsetof(ULightProjectileWaveModifier, bRandomize) == 0x00007C, "Member 'ULightProjectileWaveModifier::bRandomize' has a wrong offset!");

// Class GbxWeapon.ProjectileBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectileBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CalcThrowVelocity(const class UObject* WorldContextObject, struct FVector* ResultVelocity, float* ResultGravityScale, const struct FVector& StartLocation, const struct FVector& TargetLocation, const struct FVector& TargetVelocity, float MaxPrediction, float Speed, float AnglePercent, const struct FRotator& DirectionOffset, const struct FVector& LocalTargetOffset);
	static void CalcThrowVelocityAtActor(struct FVector* ResultVelocity, float* ResultGravityScale, const struct FVector& StartLocation, class AActor* Target, float MaxPrediction, float Speed, float AnglePercent, const struct FRotator& DirectionOffset, const struct FVector& LocalTargetOffset);
	static struct FVector CalculateConeVector(float Fraction, const struct FVector& Origin, const struct FVector& Direction, float AngleWidth, float AngleHeight);
	static void DetachProjectilesFromActor(class AActor* BaseActor);
	static TArray<struct FTransform> GeneratePointsOnCone(const struct FVector& Origin, const struct FVector& Direction, int32 SampleCount, float SpreadAngle, float RotateAngle, float OriginOffset);
	static TArray<struct FTransform> GeneratePointsOnFan(const struct FVector& Origin, const struct FVector& Direction, int32 SampleCount, float SpreadAngle, float RotateAngle, float OriginOffset);
	static struct FTransform GetSafeProjectileThrowTransform(class AActor* SourceActor, class FName SocketName, const TArray<class AActor*>& IgnoreActors, bool bThrowFromFirstPersonSocket, ECollisionChannel TraceChannel);
	static struct FTransform GetSafeProjectileThrowTransform_Component(class AActor* SourceActor, class USceneComponent* SourceComponent, class FName SocketName, const TArray<class AActor*>& IgnoreActors, ECollisionChannel TraceChannel);
	static void PredictProjectilePathAsync(const class UObject* WorldContext, const struct FPredictProjectilePathAsyncRequest& Request);
	static void ThrowActorAt(class AActor* Actor, const struct FVector& TargetLocation, const struct FVector& TargetVelocity, float MaxPrediction, float Speed, float AnglePercent, const struct FRotator& DirectionOffset, const struct FVector& LocalTargetOffset);
	static int32 ThrowProjectileAsync(class UObject* WorldContext, const struct FThrowProjectileAsyncRequest& Request);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileBlueprintLibrary">();
	}
	static class UProjectileBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileBlueprintLibrary>();
	}
};
static_assert(alignof(UProjectileBlueprintLibrary) == 0x000008, "Wrong alignment on UProjectileBlueprintLibrary");
static_assert(sizeof(UProjectileBlueprintLibrary) == 0x000028, "Wrong size on UProjectileBlueprintLibrary");

// Class GbxWeapon.ProjectileEQSProxy
// 0x0028 (0x0050 - 0x0028)
class UProjectileEQSProxy final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0030(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x003C(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReferenceActor;                                    // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileEQSProxy">();
	}
	static class UProjectileEQSProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileEQSProxy>();
	}
};
static_assert(alignof(UProjectileEQSProxy) == 0x000008, "Wrong alignment on UProjectileEQSProxy");
static_assert(sizeof(UProjectileEQSProxy) == 0x000050, "Wrong size on UProjectileEQSProxy");
static_assert(offsetof(UProjectileEQSProxy, Location) == 0x000030, "Member 'UProjectileEQSProxy::Location' has a wrong offset!");
static_assert(offsetof(UProjectileEQSProxy, Rotation) == 0x00003C, "Member 'UProjectileEQSProxy::Rotation' has a wrong offset!");
static_assert(offsetof(UProjectileEQSProxy, ReferenceActor) == 0x000048, "Member 'UProjectileEQSProxy::ReferenceActor' has a wrong offset!");

// Class GbxWeapon.ProjectileSourceInterface
// 0x0000 (0x0028 - 0x0028)
class IProjectileSourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileSourceInterface">();
	}
	static class IProjectileSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileSourceInterface>();
	}
};
static_assert(alignof(IProjectileSourceInterface) == 0x000008, "Wrong alignment on IProjectileSourceInterface");
static_assert(sizeof(IProjectileSourceInterface) == 0x000028, "Wrong size on IProjectileSourceInterface");

// Class GbxWeapon.RecoilControlComponent
// 0x0060 (0x01D8 - 0x0178)
class URecoilControlComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   NotifyRecoveryFinished;                            // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyResetRecoil;                                 // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bServerSimulatesRecoil;                            // 0x0198(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CurrentRotation;                                   // 0x019C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x01A8(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               InputPassthroughThreshold;                         // 0x01B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x18];                                     // 0x01C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerApplyInput(uint32 CompressedInputRot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecoilControlComponent">();
	}
	static class URecoilControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecoilControlComponent>();
	}
};
static_assert(alignof(URecoilControlComponent) == 0x000008, "Wrong alignment on URecoilControlComponent");
static_assert(sizeof(URecoilControlComponent) == 0x0001D8, "Wrong size on URecoilControlComponent");
static_assert(offsetof(URecoilControlComponent, NotifyRecoveryFinished) == 0x000178, "Member 'URecoilControlComponent::NotifyRecoveryFinished' has a wrong offset!");
static_assert(offsetof(URecoilControlComponent, NotifyResetRecoil) == 0x000188, "Member 'URecoilControlComponent::NotifyResetRecoil' has a wrong offset!");
static_assert(offsetof(URecoilControlComponent, bServerSimulatesRecoil) == 0x000198, "Member 'URecoilControlComponent::bServerSimulatesRecoil' has a wrong offset!");
static_assert(offsetof(URecoilControlComponent, CurrentRotation) == 0x00019C, "Member 'URecoilControlComponent::CurrentRotation' has a wrong offset!");
static_assert(offsetof(URecoilControlComponent, TargetRotation) == 0x0001A8, "Member 'URecoilControlComponent::TargetRotation' has a wrong offset!");
static_assert(offsetof(URecoilControlComponent, InputPassthroughThreshold) == 0x0001B4, "Member 'URecoilControlComponent::InputPassthroughThreshold' has a wrong offset!");

// Class GbxWeapon.RecoilPatternData
// 0x00A8 (0x00D8 - 0x0030)
class URecoilPatternData final : public UGbxDataAsset
{
public:
	TArray<struct FVector2D>                      Samples;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRandom;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecoilEndOfPatternAction                     EndOfPatternAction;                                // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RepeatPatternStartIndex;                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndOfPatternRise;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ShotSequenceScaleCurve;                            // 0x0050(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAutoGenerateGoodness;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PatternHeightGoodness;                             // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatternWidthGoodness;                              // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecoilPatternData">();
	}
	static class URecoilPatternData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecoilPatternData>();
	}
};
static_assert(alignof(URecoilPatternData) == 0x000008, "Wrong alignment on URecoilPatternData");
static_assert(sizeof(URecoilPatternData) == 0x0000D8, "Wrong size on URecoilPatternData");
static_assert(offsetof(URecoilPatternData, Samples) == 0x000030, "Member 'URecoilPatternData::Samples' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, bRandom) == 0x000040, "Member 'URecoilPatternData::bRandom' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, EndOfPatternAction) == 0x000041, "Member 'URecoilPatternData::EndOfPatternAction' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, RepeatPatternStartIndex) == 0x000044, "Member 'URecoilPatternData::RepeatPatternStartIndex' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, EndOfPatternRise) == 0x000048, "Member 'URecoilPatternData::EndOfPatternRise' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, ShotSequenceScaleCurve) == 0x000050, "Member 'URecoilPatternData::ShotSequenceScaleCurve' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, bAutoGenerateGoodness) == 0x0000C8, "Member 'URecoilPatternData::bAutoGenerateGoodness' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, PatternHeightGoodness) == 0x0000CC, "Member 'URecoilPatternData::PatternHeightGoodness' has a wrong offset!");
static_assert(offsetof(URecoilPatternData, PatternWidthGoodness) == 0x0000D0, "Member 'URecoilPatternData::PatternWidthGoodness' has a wrong offset!");

// Class GbxWeapon.WeaponAccuracyPoolAttributePropertyValueResolver
// 0x0008 (0x00B8 - 0x00B0)
class UWeaponAccuracyPoolAttributePropertyValueResolver final : public UAttributePropertyValueResolver
{
public:
	class UGameResourceData*                      DefaultResource;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAccuracyPoolAttributePropertyValueResolver">();
	}
	static class UWeaponAccuracyPoolAttributePropertyValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAccuracyPoolAttributePropertyValueResolver>();
	}
};
static_assert(alignof(UWeaponAccuracyPoolAttributePropertyValueResolver) == 0x000008, "Wrong alignment on UWeaponAccuracyPoolAttributePropertyValueResolver");
static_assert(sizeof(UWeaponAccuracyPoolAttributePropertyValueResolver) == 0x0000B8, "Wrong size on UWeaponAccuracyPoolAttributePropertyValueResolver");
static_assert(offsetof(UWeaponAccuracyPoolAttributePropertyValueResolver, DefaultResource) == 0x0000B0, "Member 'UWeaponAccuracyPoolAttributePropertyValueResolver::DefaultResource' has a wrong offset!");

// Class GbxWeapon.WeaponAmmoChamberBoneControl
// 0x0010 (0x00A0 - 0x0090)
class UWeaponAmmoChamberBoneControl final : public UWeaponSkeletalControlBase
{
public:
	TArray<class FName>                           AmmoBoneNames;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAmmoChamberBoneControl">();
	}
	static class UWeaponAmmoChamberBoneControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAmmoChamberBoneControl>();
	}
};
static_assert(alignof(UWeaponAmmoChamberBoneControl) == 0x000008, "Wrong alignment on UWeaponAmmoChamberBoneControl");
static_assert(sizeof(UWeaponAmmoChamberBoneControl) == 0x0000A0, "Wrong size on UWeaponAmmoChamberBoneControl");
static_assert(offsetof(UWeaponAmmoChamberBoneControl, AmmoBoneNames) == 0x000090, "Member 'UWeaponAmmoChamberBoneControl::AmmoBoneNames' has a wrong offset!");

// Class GbxWeapon.WeaponConsumedLoadedAmmoValueResolver
// 0x0000 (0x0028 - 0x0028)
class UWeaponConsumedLoadedAmmoValueResolver final : public UAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponConsumedLoadedAmmoValueResolver">();
	}
	static class UWeaponConsumedLoadedAmmoValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponConsumedLoadedAmmoValueResolver>();
	}
};
static_assert(alignof(UWeaponConsumedLoadedAmmoValueResolver) == 0x000008, "Wrong alignment on UWeaponConsumedLoadedAmmoValueResolver");
static_assert(sizeof(UWeaponConsumedLoadedAmmoValueResolver) == 0x000028, "Wrong size on UWeaponConsumedLoadedAmmoValueResolver");

// Class GbxWeapon.WeaponAmmoPoolComponent
// 0x00B0 (0x0260 - 0x01B0)
class UWeaponAmmoPoolComponent final : public UWeaponAmmoComponent
{
public:
	struct FGbxAttributeInteger                   MaxLoadedAmmo;                                     // 0x01B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxStoredAmmo;                                     // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LoadedAmmo;                                        // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StoredAmmo;                                        // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpareAmmo;                                         // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInfiniteAmmo : 1;                                 // 0x01CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInfiniteAmmoForAI : 1;                            // 0x01CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCreateAmmoResourceForAI : 1;                      // 0x01CC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGiveAmmoOnPickup : 1;                             // 0x01CC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameResourceData*                      ResourceData;                                      // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           PickupAmmoFormula;                                 // 0x01D8(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EAmmoRegenType                                AmmoRegenType;                                     // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AmmoRegenRate;                                     // 0x0214(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConsumeAmmoRegenDelay;                             // 0x0218(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameResourcePoolReference             ResourcePool;                                      // 0x0220(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         ServerSyncedLoadedAmmo;                            // 0x0238(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x24];                                     // 0x023C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientConsumeAmmo(int32 Amount);
	void ClientSetLoadedAmmo(int32 NewLoadedAmmo);
	void OnGivenTo();
	void OnMaxLoadedAmmoChanged(float OldValue, float NewValue);
	void OnRep_ServerSyncedLoadedAmmo();
	void OnRep_SpareAmmo();
	void ServerSendAmmoState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAmmoPoolComponent">();
	}
	static class UWeaponAmmoPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAmmoPoolComponent>();
	}
};
static_assert(alignof(UWeaponAmmoPoolComponent) == 0x000008, "Wrong alignment on UWeaponAmmoPoolComponent");
static_assert(sizeof(UWeaponAmmoPoolComponent) == 0x000260, "Wrong size on UWeaponAmmoPoolComponent");
static_assert(offsetof(UWeaponAmmoPoolComponent, MaxLoadedAmmo) == 0x0001B0, "Member 'UWeaponAmmoPoolComponent::MaxLoadedAmmo' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, MaxStoredAmmo) == 0x0001BC, "Member 'UWeaponAmmoPoolComponent::MaxStoredAmmo' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, LoadedAmmo) == 0x0001C0, "Member 'UWeaponAmmoPoolComponent::LoadedAmmo' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, StoredAmmo) == 0x0001C4, "Member 'UWeaponAmmoPoolComponent::StoredAmmo' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, SpareAmmo) == 0x0001C8, "Member 'UWeaponAmmoPoolComponent::SpareAmmo' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, ResourceData) == 0x0001D0, "Member 'UWeaponAmmoPoolComponent::ResourceData' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, PickupAmmoFormula) == 0x0001D8, "Member 'UWeaponAmmoPoolComponent::PickupAmmoFormula' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, AmmoRegenType) == 0x000210, "Member 'UWeaponAmmoPoolComponent::AmmoRegenType' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, AmmoRegenRate) == 0x000214, "Member 'UWeaponAmmoPoolComponent::AmmoRegenRate' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, ConsumeAmmoRegenDelay) == 0x000218, "Member 'UWeaponAmmoPoolComponent::ConsumeAmmoRegenDelay' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, ResourcePool) == 0x000220, "Member 'UWeaponAmmoPoolComponent::ResourcePool' has a wrong offset!");
static_assert(offsetof(UWeaponAmmoPoolComponent, ServerSyncedLoadedAmmo) == 0x000238, "Member 'UWeaponAmmoPoolComponent::ServerSyncedLoadedAmmo' has a wrong offset!");

// Class GbxWeapon.WeaponAttributeContextResolver
// 0x0008 (0x0058 - 0x0050)
class UWeaponAttributeContextResolver final : public UAttributeContextResolver
{
public:
	uint32                                        UseModeContextBitmask;                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAttributeContextResolver">();
	}
	static class UWeaponAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAttributeContextResolver>();
	}
};
static_assert(alignof(UWeaponAttributeContextResolver) == 0x000008, "Wrong alignment on UWeaponAttributeContextResolver");
static_assert(sizeof(UWeaponAttributeContextResolver) == 0x000058, "Wrong size on UWeaponAttributeContextResolver");
static_assert(offsetof(UWeaponAttributeContextResolver, UseModeContextBitmask) == 0x000050, "Member 'UWeaponAttributeContextResolver::UseModeContextBitmask' has a wrong offset!");

// Class GbxWeapon.WeaponChargePercentValueResolver
// 0x0000 (0x0028 - 0x0028)
class UWeaponChargePercentValueResolver final : public UAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponChargePercentValueResolver">();
	}
	static class UWeaponChargePercentValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponChargePercentValueResolver>();
	}
};
static_assert(alignof(UWeaponChargePercentValueResolver) == 0x000008, "Wrong alignment on UWeaponChargePercentValueResolver");
static_assert(sizeof(UWeaponChargePercentValueResolver) == 0x000028, "Wrong size on UWeaponChargePercentValueResolver");

// Class GbxWeapon.WeaponChargeComponent
// 0x0168 (0x0300 - 0x0198)
class UWeaponChargeComponent : public UWeaponPreUseComponent
{
public:
	struct FGbxAttributeFloat                     ChargeTime;                                        // 0x0198(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     DischargeTime;                                     // 0x01A4(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     CancelChargeDelay;                                 // 0x01B0(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredUseChargePct;                              // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommitUseChargePct;                                // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     OverchargeHoldTime;                                // 0x01C4(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseWhenCharged : 1;                               // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bChargeBeforeEachUse : 1;                          // 0x01D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopChargingEffectsOnCharged : 1;                 // 0x01D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopChargedEffectsOnOvercharged : 1;              // 0x01D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateChargeActionBlendSpace : 1;                 // 0x01D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bZoomModifiesBlendSpaceY : 1;                      // 0x01D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ChargePercentParamName;                            // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomChargeActionBlendSpaceScale;                   // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponChargeAttributeEffect>   AttributeEffects;                                  // 0x01E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFeedbackData*                          ChargeFeedback;                                    // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          OverchargeFeedback;                                // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayFeedbackAtLocation : 1;                       // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FeedbackSocket;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeaponChargeEventNotify>       ChargeEvents;                                      // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponChargeEventNotify>       DischargeEvents;                                   // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyChargeStarted;                               // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyChargeStopped;                               // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyFullyCharged;                                // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyChargeCanceled;                              // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyOvercharged;                                 // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyDischargeStarted;                            // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyDischargeStopped;                            // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotifyFullyDischarged;                             // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EWeaponChargeState                            ChargeState;                                       // 0x02B8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x47];                                     // 0x02B9(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayChargeFinished();
	void FullyCharged();
	void FullyDischarged();
	void OnChargeActionEnd(EGbxActionEndState EndState);
	void OnRep_ChargeState(EWeaponChargeState PrevChargeState);
	void Overcharged();
	void StopEffects();

	float GetChargeDuration() const;
	float GetChargePercent() const;
	float GetDischargeDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponChargeComponent">();
	}
	static class UWeaponChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponChargeComponent>();
	}
};
static_assert(alignof(UWeaponChargeComponent) == 0x000008, "Wrong alignment on UWeaponChargeComponent");
static_assert(sizeof(UWeaponChargeComponent) == 0x000300, "Wrong size on UWeaponChargeComponent");
static_assert(offsetof(UWeaponChargeComponent, ChargeTime) == 0x000198, "Member 'UWeaponChargeComponent::ChargeTime' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, DischargeTime) == 0x0001A4, "Member 'UWeaponChargeComponent::DischargeTime' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, CancelChargeDelay) == 0x0001B0, "Member 'UWeaponChargeComponent::CancelChargeDelay' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, RequiredUseChargePct) == 0x0001BC, "Member 'UWeaponChargeComponent::RequiredUseChargePct' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, CommitUseChargePct) == 0x0001C0, "Member 'UWeaponChargeComponent::CommitUseChargePct' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, OverchargeHoldTime) == 0x0001C4, "Member 'UWeaponChargeComponent::OverchargeHoldTime' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, ChargePercentParamName) == 0x0001D8, "Member 'UWeaponChargeComponent::ChargePercentParamName' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, ZoomChargeActionBlendSpaceScale) == 0x0001E0, "Member 'UWeaponChargeComponent::ZoomChargeActionBlendSpaceScale' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, AttributeEffects) == 0x0001E8, "Member 'UWeaponChargeComponent::AttributeEffects' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, ChargeFeedback) == 0x0001F8, "Member 'UWeaponChargeComponent::ChargeFeedback' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, OverchargeFeedback) == 0x000200, "Member 'UWeaponChargeComponent::OverchargeFeedback' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, FeedbackSocket) == 0x000210, "Member 'UWeaponChargeComponent::FeedbackSocket' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, ChargeEvents) == 0x000218, "Member 'UWeaponChargeComponent::ChargeEvents' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, DischargeEvents) == 0x000228, "Member 'UWeaponChargeComponent::DischargeEvents' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyChargeStarted) == 0x000238, "Member 'UWeaponChargeComponent::NotifyChargeStarted' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyChargeStopped) == 0x000248, "Member 'UWeaponChargeComponent::NotifyChargeStopped' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyFullyCharged) == 0x000258, "Member 'UWeaponChargeComponent::NotifyFullyCharged' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyChargeCanceled) == 0x000268, "Member 'UWeaponChargeComponent::NotifyChargeCanceled' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyOvercharged) == 0x000278, "Member 'UWeaponChargeComponent::NotifyOvercharged' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyDischargeStarted) == 0x000288, "Member 'UWeaponChargeComponent::NotifyDischargeStarted' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyDischargeStopped) == 0x000298, "Member 'UWeaponChargeComponent::NotifyDischargeStopped' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, NotifyFullyDischarged) == 0x0002A8, "Member 'UWeaponChargeComponent::NotifyFullyDischarged' has a wrong offset!");
static_assert(offsetof(UWeaponChargeComponent, ChargeState) == 0x0002B8, "Member 'UWeaponChargeComponent::ChargeState' has a wrong offset!");

// Class GbxWeapon.WeaponClipReloadComponent
// 0x0030 (0x0208 - 0x01D8)
class UWeaponClipReloadComponent final : public UWeaponReloadComponent
{
public:
	float                                         ReloadCompletePercent;                             // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     TapedReloadTime;                                   // 0x01DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TapedReloadCompletePercent;                        // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TapedClipCount;                                    // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0x11];                                     // 0x01F0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ClientReloadState;                                 // 0x0201(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         CurrentClip;                                       // 0x0202(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_203[0x5];                                      // 0x0203(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ClientReloadState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponClipReloadComponent">();
	}
	static class UWeaponClipReloadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponClipReloadComponent>();
	}
};
static_assert(alignof(UWeaponClipReloadComponent) == 0x000008, "Wrong alignment on UWeaponClipReloadComponent");
static_assert(sizeof(UWeaponClipReloadComponent) == 0x000208, "Wrong size on UWeaponClipReloadComponent");
static_assert(offsetof(UWeaponClipReloadComponent, ReloadCompletePercent) == 0x0001D8, "Member 'UWeaponClipReloadComponent::ReloadCompletePercent' has a wrong offset!");
static_assert(offsetof(UWeaponClipReloadComponent, TapedReloadTime) == 0x0001DC, "Member 'UWeaponClipReloadComponent::TapedReloadTime' has a wrong offset!");
static_assert(offsetof(UWeaponClipReloadComponent, TapedReloadCompletePercent) == 0x0001E8, "Member 'UWeaponClipReloadComponent::TapedReloadCompletePercent' has a wrong offset!");
static_assert(offsetof(UWeaponClipReloadComponent, TapedClipCount) == 0x0001EC, "Member 'UWeaponClipReloadComponent::TapedClipCount' has a wrong offset!");
static_assert(offsetof(UWeaponClipReloadComponent, ClientReloadState) == 0x000201, "Member 'UWeaponClipReloadComponent::ClientReloadState' has a wrong offset!");
static_assert(offsetof(UWeaponClipReloadComponent, CurrentClip) == 0x000202, "Member 'UWeaponClipReloadComponent::CurrentClip' has a wrong offset!");

// Class GbxWeapon.GbxCondition_ZoomState
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_ZoomState final : public UGbxCondition
{
public:
	uint8                                         bIsZoomedIn : 1;                                   // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeTransitions : 1;                           // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_ZoomState">();
	}
	static class UGbxCondition_ZoomState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_ZoomState>();
	}
};
static_assert(alignof(UGbxCondition_ZoomState) == 0x000008, "Wrong alignment on UGbxCondition_ZoomState");
static_assert(sizeof(UGbxCondition_ZoomState) == 0x000090, "Wrong size on UGbxCondition_ZoomState");

// Class GbxWeapon.WeaponDebugInterface
// 0x0000 (0x0028 - 0x0028)
class IWeaponDebugInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponDebugInterface">();
	}
	static class IWeaponDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponDebugInterface>();
	}
};
static_assert(alignof(IWeaponDebugInterface) == 0x000008, "Wrong alignment on IWeaponDebugInterface");
static_assert(sizeof(IWeaponDebugInterface) == 0x000028, "Wrong size on IWeaponDebugInterface");

// Class GbxWeapon.WeaponFireBeamComponent
// 0x0038 (0x0938 - 0x0900)
class UWeaponFireBeamComponent : public UWeaponFireComponent
{
public:
	float                                         DamageRateScale;                                   // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_904[0x4];                                      // 0x0904(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightBeamData>             LightBeamData;                                     // 0x0908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFollowPlayerCrosshair;                            // 0x0910(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_911[0x3];                                      // 0x0911(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnContactTime;                                 // 0x0914(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnBreakRadius;                                 // 0x0918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnBreakAngle;                                  // 0x091C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageRampCurve;                                   // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     DamageRampScale;                                   // 0x0928(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_934[0x4];                                      // 0x0934(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class ULightBeamData> GetShotLightBeamData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponFireBeamComponent">();
	}
	static class UWeaponFireBeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponFireBeamComponent>();
	}
};
static_assert(alignof(UWeaponFireBeamComponent) == 0x000008, "Wrong alignment on UWeaponFireBeamComponent");
static_assert(sizeof(UWeaponFireBeamComponent) == 0x000938, "Wrong size on UWeaponFireBeamComponent");
static_assert(offsetof(UWeaponFireBeamComponent, DamageRateScale) == 0x000900, "Member 'UWeaponFireBeamComponent::DamageRateScale' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, LightBeamData) == 0x000908, "Member 'UWeaponFireBeamComponent::LightBeamData' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, bFollowPlayerCrosshair) == 0x000910, "Member 'UWeaponFireBeamComponent::bFollowPlayerCrosshair' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, LockOnContactTime) == 0x000914, "Member 'UWeaponFireBeamComponent::LockOnContactTime' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, LockOnBreakRadius) == 0x000918, "Member 'UWeaponFireBeamComponent::LockOnBreakRadius' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, LockOnBreakAngle) == 0x00091C, "Member 'UWeaponFireBeamComponent::LockOnBreakAngle' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, DamageRampCurve) == 0x000920, "Member 'UWeaponFireBeamComponent::DamageRampCurve' has a wrong offset!");
static_assert(offsetof(UWeaponFireBeamComponent, DamageRampScale) == 0x000928, "Member 'UWeaponFireBeamComponent::DamageRampScale' has a wrong offset!");

// Class GbxWeapon.WeaponFireRateAccelPercentValueResolver
// 0x0000 (0x0028 - 0x0028)
class UWeaponFireRateAccelPercentValueResolver final : public UAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponFireRateAccelPercentValueResolver">();
	}
	static class UWeaponFireRateAccelPercentValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponFireRateAccelPercentValueResolver>();
	}
};
static_assert(alignof(UWeaponFireRateAccelPercentValueResolver) == 0x000008, "Wrong alignment on UWeaponFireRateAccelPercentValueResolver");
static_assert(sizeof(UWeaponFireRateAccelPercentValueResolver) == 0x000028, "Wrong size on UWeaponFireRateAccelPercentValueResolver");

// Class GbxWeapon.WeaponRecoilComponent
// 0x0020 (0x0198 - 0x0178)
class UWeaponRecoilComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URecoilControlComponent*                CachedControlComponent;                            // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWeapon*                                WeaponPrivate;                                     // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAttached();
	void OnDetached();
	void OnUsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponRecoilComponent">();
	}
	static class UWeaponRecoilComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponRecoilComponent>();
	}
};
static_assert(alignof(UWeaponRecoilComponent) == 0x000008, "Wrong alignment on UWeaponRecoilComponent");
static_assert(sizeof(UWeaponRecoilComponent) == 0x000198, "Wrong size on UWeaponRecoilComponent");
static_assert(offsetof(UWeaponRecoilComponent, CachedControlComponent) == 0x000188, "Member 'UWeaponRecoilComponent::CachedControlComponent' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilComponent, WeaponPrivate) == 0x000190, "Member 'UWeaponRecoilComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.WeaponRecoilPatternComponent
// 0x0068 (0x0200 - 0x0198)
class UWeaponRecoilPatternComponent final : public UWeaponRecoilComponent
{
public:
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URecoilPatternData*                     Pattern;                                           // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     PatternWidthScale;                                 // 0x01A8(0x000C)(Edit, BlueprintVisible, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     PatternHeightScale;                                // 0x01B4(0x000C)(Edit, BlueprintVisible, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     PatternZoomScale;                                  // 0x01C0(0x000C)(Edit, BlueprintVisible, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScalePatternByFOV;                                // 0x01CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetPatternWhenFiringEnds;                       // 0x01CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CE[0x2];                                      // 0x01CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilSpeed;                                       // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilRecoveryTime;                                // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilRecoveryDelayTime;                           // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartRecoilRecoveryWhenFiringEnds;                // 0x01DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DD[0x23];                                     // 0x01DD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUseFinished();
	void ResetPattern();

	float GetRecoilPatternGoodness() const;
	float GetRecoilPatternHeightGoodness() const;
	float GetRecoilPatternWidthGoodness() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponRecoilPatternComponent">();
	}
	static class UWeaponRecoilPatternComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponRecoilPatternComponent>();
	}
};
static_assert(alignof(UWeaponRecoilPatternComponent) == 0x000008, "Wrong alignment on UWeaponRecoilPatternComponent");
static_assert(sizeof(UWeaponRecoilPatternComponent) == 0x000200, "Wrong size on UWeaponRecoilPatternComponent");
static_assert(offsetof(UWeaponRecoilPatternComponent, Pattern) == 0x0001A0, "Member 'UWeaponRecoilPatternComponent::Pattern' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, PatternWidthScale) == 0x0001A8, "Member 'UWeaponRecoilPatternComponent::PatternWidthScale' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, PatternHeightScale) == 0x0001B4, "Member 'UWeaponRecoilPatternComponent::PatternHeightScale' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, PatternZoomScale) == 0x0001C0, "Member 'UWeaponRecoilPatternComponent::PatternZoomScale' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, bScalePatternByFOV) == 0x0001CC, "Member 'UWeaponRecoilPatternComponent::bScalePatternByFOV' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, bResetPatternWhenFiringEnds) == 0x0001CD, "Member 'UWeaponRecoilPatternComponent::bResetPatternWhenFiringEnds' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, RecoilSpeed) == 0x0001D0, "Member 'UWeaponRecoilPatternComponent::RecoilSpeed' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, RecoilRecoveryTime) == 0x0001D4, "Member 'UWeaponRecoilPatternComponent::RecoilRecoveryTime' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, RecoilRecoveryDelayTime) == 0x0001D8, "Member 'UWeaponRecoilPatternComponent::RecoilRecoveryDelayTime' has a wrong offset!");
static_assert(offsetof(UWeaponRecoilPatternComponent, bStartRecoilRecoveryWhenFiringEnds) == 0x0001DC, "Member 'UWeaponRecoilPatternComponent::bStartRecoilRecoveryWhenFiringEnds' has a wrong offset!");

// Class GbxWeapon.WeaponSettings
// 0x0050 (0x0088 - 0x0038)
class UWeaponSettings final : public UDeveloperSettings
{
public:
	TArray<struct FWeaponEffectTypeName>          WeaponEffectTypes;                                 // 0x0038(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponActionTypeName>          WeaponActionTypes;                                 // 0x0048(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLightProjectileFlagName>       LightProjectileFlags;                              // 0x0058(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLightBeamFlagName>             LightBeamFlags;                                    // 0x0068(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponShotModifierTypeName>    WeaponShotModifierTypes;                           // 0x0078(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSettings">();
	}
	static class UWeaponSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSettings>();
	}
};
static_assert(alignof(UWeaponSettings) == 0x000008, "Wrong alignment on UWeaponSettings");
static_assert(sizeof(UWeaponSettings) == 0x000088, "Wrong size on UWeaponSettings");
static_assert(offsetof(UWeaponSettings, WeaponEffectTypes) == 0x000038, "Member 'UWeaponSettings::WeaponEffectTypes' has a wrong offset!");
static_assert(offsetof(UWeaponSettings, WeaponActionTypes) == 0x000048, "Member 'UWeaponSettings::WeaponActionTypes' has a wrong offset!");
static_assert(offsetof(UWeaponSettings, LightProjectileFlags) == 0x000058, "Member 'UWeaponSettings::LightProjectileFlags' has a wrong offset!");
static_assert(offsetof(UWeaponSettings, LightBeamFlags) == 0x000068, "Member 'UWeaponSettings::LightBeamFlags' has a wrong offset!");
static_assert(offsetof(UWeaponSettings, WeaponShotModifierTypes) == 0x000078, "Member 'UWeaponSettings::WeaponShotModifierTypes' has a wrong offset!");

// Class GbxWeapon.WeaponShotModifier
// 0x0158 (0x0188 - 0x0030)
class UWeaponShotModifier final : public UGbxDataAsset
{
public:
	bool                                          bTriggerEveryXShots;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           TriggerEveryXShots;                                // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EWeaponShotModifierType                       ModifierType;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyDamage;                                     // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageModifier;                                    // 0x0078(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EWeaponShotDamageModifierType                 DamageModifierType;                                // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistributeBetweenProjectiles;                     // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECriticalHitDamageOverride                    CriticalHitModifier;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultCriticalHitMultiplier;                  // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           AdditionalCriticalMultiplier;                      // 0x00D0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           GoreModifier;                                      // 0x0108(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           GibModifier;                                       // 0x0140(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UConditionalDamageModifier*             ConditionalDamageModifier;                         // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassConditionalDamageModifierToChildProjectiles;  // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefundShotCostWhenTriggered;                      // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressRefundThatWouldPreventReload;             // 0x0182(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183[0x5];                                      // 0x0183(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponShotModifier">();
	}
	static class UWeaponShotModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponShotModifier>();
	}
};
static_assert(alignof(UWeaponShotModifier) == 0x000008, "Wrong alignment on UWeaponShotModifier");
static_assert(sizeof(UWeaponShotModifier) == 0x000188, "Wrong size on UWeaponShotModifier");
static_assert(offsetof(UWeaponShotModifier, bTriggerEveryXShots) == 0x000030, "Member 'UWeaponShotModifier::bTriggerEveryXShots' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, TriggerEveryXShots) == 0x000038, "Member 'UWeaponShotModifier::TriggerEveryXShots' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, ModifierType) == 0x000070, "Member 'UWeaponShotModifier::ModifierType' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, bModifyDamage) == 0x000071, "Member 'UWeaponShotModifier::bModifyDamage' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, DamageModifier) == 0x000078, "Member 'UWeaponShotModifier::DamageModifier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, DamageModifierType) == 0x0000B0, "Member 'UWeaponShotModifier::DamageModifierType' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, bDistributeBetweenProjectiles) == 0x0000B4, "Member 'UWeaponShotModifier::bDistributeBetweenProjectiles' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, DamageType) == 0x0000B8, "Member 'UWeaponShotModifier::DamageType' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, ImpactData) == 0x0000C0, "Member 'UWeaponShotModifier::ImpactData' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, CriticalHitModifier) == 0x0000C8, "Member 'UWeaponShotModifier::CriticalHitModifier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, bUseDefaultCriticalHitMultiplier) == 0x0000C9, "Member 'UWeaponShotModifier::bUseDefaultCriticalHitMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, AdditionalCriticalMultiplier) == 0x0000D0, "Member 'UWeaponShotModifier::AdditionalCriticalMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, GoreModifier) == 0x000108, "Member 'UWeaponShotModifier::GoreModifier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, GibModifier) == 0x000140, "Member 'UWeaponShotModifier::GibModifier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, ConditionalDamageModifier) == 0x000178, "Member 'UWeaponShotModifier::ConditionalDamageModifier' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, bPassConditionalDamageModifierToChildProjectiles) == 0x000180, "Member 'UWeaponShotModifier::bPassConditionalDamageModifierToChildProjectiles' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, bRefundShotCostWhenTriggered) == 0x000181, "Member 'UWeaponShotModifier::bRefundShotCostWhenTriggered' has a wrong offset!");
static_assert(offsetof(UWeaponShotModifier, bSuppressRefundThatWouldPreventReload) == 0x000182, "Member 'UWeaponShotModifier::bSuppressRefundThatWouldPreventReload' has a wrong offset!");

// Class GbxWeapon.WeaponSimpleMotionControlBase
// 0x0060 (0x00F0 - 0x0090)
class UWeaponSimpleMotionControlBase : public UWeaponSkeletalControlBase
{
public:
	uint8                                         bStartActive : 1;                                  // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoActivate : 1;                                 // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESimpleMotionInputHandler                     InputHandler;                                      // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ControlValue;                                      // 0x0098(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bLimitMinControlValue : 1;                         // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLimitMaxControlValue : 1;                         // 0x00D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinControlValue;                                   // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxControlValue;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseSpeed;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseMaxValue;                            // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseDecayDelay;                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseDecaySpeed;                          // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSimpleMotionControlBase">();
	}
	static class UWeaponSimpleMotionControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSimpleMotionControlBase>();
	}
};
static_assert(alignof(UWeaponSimpleMotionControlBase) == 0x000008, "Wrong alignment on UWeaponSimpleMotionControlBase");
static_assert(sizeof(UWeaponSimpleMotionControlBase) == 0x0000F0, "Wrong size on UWeaponSimpleMotionControlBase");
static_assert(offsetof(UWeaponSimpleMotionControlBase, InputHandler) == 0x000091, "Member 'UWeaponSimpleMotionControlBase::InputHandler' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, ControlValue) == 0x000098, "Member 'UWeaponSimpleMotionControlBase::ControlValue' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, MinControlValue) == 0x0000D4, "Member 'UWeaponSimpleMotionControlBase::MinControlValue' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, MaxControlValue) == 0x0000D8, "Member 'UWeaponSimpleMotionControlBase::MaxControlValue' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, ControlImpulseSpeed) == 0x0000DC, "Member 'UWeaponSimpleMotionControlBase::ControlImpulseSpeed' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, ControlImpulseMaxValue) == 0x0000E0, "Member 'UWeaponSimpleMotionControlBase::ControlImpulseMaxValue' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, ControlImpulseDecayDelay) == 0x0000E4, "Member 'UWeaponSimpleMotionControlBase::ControlImpulseDecayDelay' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionControlBase, ControlImpulseDecaySpeed) == 0x0000E8, "Member 'UWeaponSimpleMotionControlBase::ControlImpulseDecaySpeed' has a wrong offset!");

// Class GbxWeapon.WeaponSimpleMotionBlendControl
// 0x0068 (0x0158 - 0x00F0)
class UWeaponSimpleMotionBlendControl final : public UWeaponSimpleMotionControlBase
{
public:
	uint8                                         bUseExistingNode : 1;                              // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMeshSpaceBlend : 1;                               // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        Animation;                                         // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputBlendPose                        BlendLayerSetup;                                   // 0x0100(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveState;                                       // 0x0110(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ActiveBlendTarget;                                 // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     RecoveryState;                                     // 0x0138(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSimpleMotionBlendControl">();
	}
	static class UWeaponSimpleMotionBlendControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSimpleMotionBlendControl>();
	}
};
static_assert(alignof(UWeaponSimpleMotionBlendControl) == 0x000008, "Wrong alignment on UWeaponSimpleMotionBlendControl");
static_assert(sizeof(UWeaponSimpleMotionBlendControl) == 0x000158, "Wrong size on UWeaponSimpleMotionBlendControl");
static_assert(offsetof(UWeaponSimpleMotionBlendControl, Animation) == 0x0000F8, "Member 'UWeaponSimpleMotionBlendControl::Animation' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBlendControl, BlendLayerSetup) == 0x000100, "Member 'UWeaponSimpleMotionBlendControl::BlendLayerSetup' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBlendControl, ActiveState) == 0x000110, "Member 'UWeaponSimpleMotionBlendControl::ActiveState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBlendControl, ActiveBlendTarget) == 0x000130, "Member 'UWeaponSimpleMotionBlendControl::ActiveBlendTarget' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBlendControl, RecoveryState) == 0x000138, "Member 'UWeaponSimpleMotionBlendControl::RecoveryState' has a wrong offset!");

// Class GbxWeapon.WeaponSimpleMotionBoneControl
// 0x0188 (0x0278 - 0x00F0)
class UWeaponSimpleMotionBoneControl final : public UWeaponSimpleMotionControlBase
{
public:
	class FName                                   BoneName;                                          // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneModificationMode                         TranslationMode;                                   // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             TranslationSpace;                                  // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IdleTranslation;                                   // 0x00FC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActiveTranslation;                                 // 0x0108(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     IdleTranslationState;                              // 0x0118(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveTranslationState;                            // 0x0138(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     RecoveryTranslationState;                          // 0x0158(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneModificationMode                         RotationMode;                                      // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             RotationSpace;                                     // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               IdleRotation;                                      // 0x017C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ActiveRotation;                                    // 0x0188(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     IdleRotationState;                                 // 0x0198(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveRotationState;                               // 0x01B8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     RecoveryRotationState;                             // 0x01D8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneModificationMode                         ScaleMode;                                         // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             ScaleSpace;                                        // 0x01F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA[0x2];                                      // 0x01FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IdleScale;                                         // 0x01FC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActiveScale;                                       // 0x0208(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     IdleScaleState;                                    // 0x0218(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveScaleState;                                  // 0x0238(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     RecoveryScaleState;                                // 0x0258(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSimpleMotionBoneControl">();
	}
	static class UWeaponSimpleMotionBoneControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSimpleMotionBoneControl>();
	}
};
static_assert(alignof(UWeaponSimpleMotionBoneControl) == 0x000008, "Wrong alignment on UWeaponSimpleMotionBoneControl");
static_assert(sizeof(UWeaponSimpleMotionBoneControl) == 0x000278, "Wrong size on UWeaponSimpleMotionBoneControl");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, BoneName) == 0x0000F0, "Member 'UWeaponSimpleMotionBoneControl::BoneName' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, TranslationMode) == 0x0000F8, "Member 'UWeaponSimpleMotionBoneControl::TranslationMode' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, TranslationSpace) == 0x0000F9, "Member 'UWeaponSimpleMotionBoneControl::TranslationSpace' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, IdleTranslation) == 0x0000FC, "Member 'UWeaponSimpleMotionBoneControl::IdleTranslation' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ActiveTranslation) == 0x000108, "Member 'UWeaponSimpleMotionBoneControl::ActiveTranslation' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, IdleTranslationState) == 0x000118, "Member 'UWeaponSimpleMotionBoneControl::IdleTranslationState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ActiveTranslationState) == 0x000138, "Member 'UWeaponSimpleMotionBoneControl::ActiveTranslationState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, RecoveryTranslationState) == 0x000158, "Member 'UWeaponSimpleMotionBoneControl::RecoveryTranslationState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, RotationMode) == 0x000178, "Member 'UWeaponSimpleMotionBoneControl::RotationMode' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, RotationSpace) == 0x000179, "Member 'UWeaponSimpleMotionBoneControl::RotationSpace' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, IdleRotation) == 0x00017C, "Member 'UWeaponSimpleMotionBoneControl::IdleRotation' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ActiveRotation) == 0x000188, "Member 'UWeaponSimpleMotionBoneControl::ActiveRotation' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, IdleRotationState) == 0x000198, "Member 'UWeaponSimpleMotionBoneControl::IdleRotationState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ActiveRotationState) == 0x0001B8, "Member 'UWeaponSimpleMotionBoneControl::ActiveRotationState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, RecoveryRotationState) == 0x0001D8, "Member 'UWeaponSimpleMotionBoneControl::RecoveryRotationState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ScaleMode) == 0x0001F8, "Member 'UWeaponSimpleMotionBoneControl::ScaleMode' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ScaleSpace) == 0x0001F9, "Member 'UWeaponSimpleMotionBoneControl::ScaleSpace' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, IdleScale) == 0x0001FC, "Member 'UWeaponSimpleMotionBoneControl::IdleScale' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ActiveScale) == 0x000208, "Member 'UWeaponSimpleMotionBoneControl::ActiveScale' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, IdleScaleState) == 0x000218, "Member 'UWeaponSimpleMotionBoneControl::IdleScaleState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, ActiveScaleState) == 0x000238, "Member 'UWeaponSimpleMotionBoneControl::ActiveScaleState' has a wrong offset!");
static_assert(offsetof(UWeaponSimpleMotionBoneControl, RecoveryScaleState) == 0x000258, "Member 'UWeaponSimpleMotionBoneControl::RecoveryScaleState' has a wrong offset!");

// Class GbxWeapon.WeaponSingleFeedReloadComponent
// 0x0038 (0x0210 - 0x01D8)
class UWeaponSingleFeedReloadComponent final : public UWeaponReloadComponent
{
public:
	bool                                          bDisableInterruptedToUse;                          // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SingleFeedIncrement;                               // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SingleFeedCompletePercent;                         // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x25];                                     // 0x01E4(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ClientReloadState;                                 // 0x0209(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ClientReloadState();
	void OnUserInput(uint8 InputChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSingleFeedReloadComponent">();
	}
	static class UWeaponSingleFeedReloadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSingleFeedReloadComponent>();
	}
};
static_assert(alignof(UWeaponSingleFeedReloadComponent) == 0x000008, "Wrong alignment on UWeaponSingleFeedReloadComponent");
static_assert(sizeof(UWeaponSingleFeedReloadComponent) == 0x000210, "Wrong size on UWeaponSingleFeedReloadComponent");
static_assert(offsetof(UWeaponSingleFeedReloadComponent, bDisableInterruptedToUse) == 0x0001D8, "Member 'UWeaponSingleFeedReloadComponent::bDisableInterruptedToUse' has a wrong offset!");
static_assert(offsetof(UWeaponSingleFeedReloadComponent, SingleFeedIncrement) == 0x0001DC, "Member 'UWeaponSingleFeedReloadComponent::SingleFeedIncrement' has a wrong offset!");
static_assert(offsetof(UWeaponSingleFeedReloadComponent, SingleFeedCompletePercent) == 0x0001E0, "Member 'UWeaponSingleFeedReloadComponent::SingleFeedCompletePercent' has a wrong offset!");
static_assert(offsetof(UWeaponSingleFeedReloadComponent, ClientReloadState) == 0x000209, "Member 'UWeaponSingleFeedReloadComponent::ClientReloadState' has a wrong offset!");

// Class GbxWeapon.WeaponEffectShotStrengthValueResolver
// 0x0000 (0x0028 - 0x0028)
class UWeaponEffectShotStrengthValueResolver final : public UAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponEffectShotStrengthValueResolver">();
	}
	static class UWeaponEffectShotStrengthValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponEffectShotStrengthValueResolver>();
	}
};
static_assert(alignof(UWeaponEffectShotStrengthValueResolver) == 0x000008, "Wrong alignment on UWeaponEffectShotStrengthValueResolver");
static_assert(sizeof(UWeaponEffectShotStrengthValueResolver) == 0x000028, "Wrong size on UWeaponEffectShotStrengthValueResolver");

// Class GbxWeapon.WeaponStatics
// 0x0000 (0x0028 - 0x0028)
class UWeaponStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UProjectileEQSProxy* CreateProjectileEQSProxy(const struct FVector& Location, const struct FRotator& Rotation, class AActor* ReferenceActor);
	static const class UGbxDamageType* GetDamageType(class AWeapon* Weapon, uint8 UseMode);
	static float GetFireRate(class AWeapon* Weapon, uint8 UseMode);
	static float GetFireRateAccelPercent(class AWeapon* Weapon, uint8 UseMode);
	static int32 GetLoadedAmmo(class AWeapon* Weapon, uint8 UseMode);
	static float GetMaxZoomFOVScale(class AWeapon* Weapon, uint8 UseMode);
	static class AWeapon* GetWeapon(class UObject* Context);
	static void GiveAmmo(class AWeapon* Weapon, int32 Amount, bool bLoaded, bool bAsPercent);
	static void HideWeapon(class AActor* WeaponUser, uint8 Slot, class FName Reason);
	static void HideWeapons(class AActor* WeaponUser, class FName Reason);
	static class UGbxAction* K2_PlayWeaponHoldAction(class AActor* Actor, EWeaponActionType WeaponAction, class AWeapon* Weapon, float PlayRate, float Duration);
	static class UGbxAction* K2_PlayWeaponHoldActionEx(class AActor* Actor, EWeaponActionType WeaponAction, class AWeapon* Weapon, const struct FActionState_Base& ActionParams);
	static void RefillAmmo(class AWeapon* Weapon, int32 Amount, bool bAsPercent);
	static void ResetVisibleAmmoState(class AWeapon* Weapon);
	static void SetVisibleAmmoState(class AWeapon* Weapon, EWeaponVisibleAmmoState NewState);
	static void SetVisibleAmmoUpdateMethod(class AWeapon* Weapon, EWeaponVisibleAmmoUpdateMethod NewUpdateMethod);
	static void UnhideWeapon(class AActor* WeaponUser, uint8 Slot, class FName Reason);
	static void UnhideWeapons(class AActor* WeaponUser, class FName Reason);
	static void UpdateVisibleAmmo(class AWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponStatics">();
	}
	static class UWeaponStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponStatics>();
	}
};
static_assert(alignof(UWeaponStatics) == 0x000008, "Wrong alignment on UWeaponStatics");
static_assert(sizeof(UWeaponStatics) == 0x000028, "Wrong size on UWeaponStatics");

// Class GbxWeapon.WeaponTriggerFeedbackAsset
// 0x0028 (0x0058 - 0x0030)
class UWeaponTriggerFeedbackAsset final : public UGbxDataAsset
{
public:
	EWeaponTriggerFeedbackMode                    Mode;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponTriggerFeedbackData             Feedback;                                          // 0x0034(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponTriggerWeaponData               Weapon;                                            // 0x003C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponTriggerVibrationData            Vibration;                                         // 0x0048(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponTriggerFireThreasholdData       FireThreshold;                                     // 0x0054(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTriggerFeedbackAsset">();
	}
	static class UWeaponTriggerFeedbackAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTriggerFeedbackAsset>();
	}
};
static_assert(alignof(UWeaponTriggerFeedbackAsset) == 0x000008, "Wrong alignment on UWeaponTriggerFeedbackAsset");
static_assert(sizeof(UWeaponTriggerFeedbackAsset) == 0x000058, "Wrong size on UWeaponTriggerFeedbackAsset");
static_assert(offsetof(UWeaponTriggerFeedbackAsset, Mode) == 0x000030, "Member 'UWeaponTriggerFeedbackAsset::Mode' has a wrong offset!");
static_assert(offsetof(UWeaponTriggerFeedbackAsset, Feedback) == 0x000034, "Member 'UWeaponTriggerFeedbackAsset::Feedback' has a wrong offset!");
static_assert(offsetof(UWeaponTriggerFeedbackAsset, Weapon) == 0x00003C, "Member 'UWeaponTriggerFeedbackAsset::Weapon' has a wrong offset!");
static_assert(offsetof(UWeaponTriggerFeedbackAsset, Vibration) == 0x000048, "Member 'UWeaponTriggerFeedbackAsset::Vibration' has a wrong offset!");
static_assert(offsetof(UWeaponTriggerFeedbackAsset, FireThreshold) == 0x000054, "Member 'UWeaponTriggerFeedbackAsset::FireThreshold' has a wrong offset!");

// Class GbxWeapon.WeaponTypeAsset
// 0x0030 (0x0060 - 0x0030)
class UWeaponTypeAsset final : public UGbxDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 ScaleformDisplayFrameID;                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EquipAudioEventName;                               // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTypeAsset">();
	}
	static class UWeaponTypeAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTypeAsset>();
	}
};
static_assert(alignof(UWeaponTypeAsset) == 0x000008, "Wrong alignment on UWeaponTypeAsset");
static_assert(sizeof(UWeaponTypeAsset) == 0x000060, "Wrong size on UWeaponTypeAsset");
static_assert(offsetof(UWeaponTypeAsset, DisplayName) == 0x000030, "Member 'UWeaponTypeAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UWeaponTypeAsset, ScaleformDisplayFrameID) == 0x000048, "Member 'UWeaponTypeAsset::ScaleformDisplayFrameID' has a wrong offset!");
static_assert(offsetof(UWeaponTypeAsset, EquipAudioEventName) == 0x000058, "Member 'UWeaponTypeAsset::EquipAudioEventName' has a wrong offset!");

// Class GbxWeapon.WeaponTypeData
// 0x0020 (0x0050 - 0x0030)
class UWeaponTypeData final : public UGbxDataAsset
{
public:
	struct FDataTableRowHandle                    BaseWeaponBalanceTableRow;                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ManufacturerDamageScaleRow;                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTypeData">();
	}
	static class UWeaponTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTypeData>();
	}
};
static_assert(alignof(UWeaponTypeData) == 0x000008, "Wrong alignment on UWeaponTypeData");
static_assert(sizeof(UWeaponTypeData) == 0x000050, "Wrong size on UWeaponTypeData");
static_assert(offsetof(UWeaponTypeData, BaseWeaponBalanceTableRow) == 0x000030, "Member 'UWeaponTypeData::BaseWeaponBalanceTableRow' has a wrong offset!");
static_assert(offsetof(UWeaponTypeData, ManufacturerDamageScaleRow) == 0x000040, "Member 'UWeaponTypeData::ManufacturerDamageScaleRow' has a wrong offset!");

// Class GbxWeapon.WeaponTypeDataTableAttributeValueResolver
// 0x0008 (0x00E0 - 0x00D8)
class UWeaponTypeDataTableAttributeValueResolver final : public UDataTableFunctionAttributeValueResolver
{
public:
	EWeaponTypeDataTableType                      DataTableFromWeaponType;                           // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTypeDataTableAttributeValueResolver">();
	}
	static class UWeaponTypeDataTableAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTypeDataTableAttributeValueResolver>();
	}
};
static_assert(alignof(UWeaponTypeDataTableAttributeValueResolver) == 0x000008, "Wrong alignment on UWeaponTypeDataTableAttributeValueResolver");
static_assert(sizeof(UWeaponTypeDataTableAttributeValueResolver) == 0x0000E0, "Wrong size on UWeaponTypeDataTableAttributeValueResolver");
static_assert(offsetof(UWeaponTypeDataTableAttributeValueResolver, DataTableFromWeaponType) == 0x0000D8, "Member 'UWeaponTypeDataTableAttributeValueResolver::DataTableFromWeaponType' has a wrong offset!");

// Class GbxWeapon.WeaponVisibleAmmoComponent
// 0x00D8 (0x0250 - 0x0178)
class UWeaponVisibleAmmoComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AmmoBoneNames;                                     // 0x0180(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EWeaponAttachmentVisibilityType               MeshType;                                          // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponVisibleAmmoState                       InitialState;                                      // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponVisibleAmmoUpdateMethod                UpdateMethod;                                      // 0x0192(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_193[0xD];                                      // 0x0193(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponVisibleAmmoEffectData           HideAmmoEffect;                                    // 0x01A0(0x0040)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponVisibleAmmoEffectData           ShowAmmoEffect;                                    // 0x01E0(0x0040)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EWeaponVisibleAmmoState                       VisibleAmmoState;                                  // 0x0220(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerAmmoCount;                                   // 0x0224(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponAmmoComponent*                   CachedAmmoComponent;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                WeaponPrivate;                                     // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAmmoChanged();
	void OnAttached();
	void OnDetached();
	void OnRep_ServerAmmoCount();
	void ResetVisibleAmmoState();
	void SetVisibleAmmoState(EWeaponVisibleAmmoState NewState);
	void SetVisibleAmmoUpdateMethod(EWeaponVisibleAmmoUpdateMethod NewUpdateMethod);
	void UpdateBoneVisibility(bool bForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponVisibleAmmoComponent">();
	}
	static class UWeaponVisibleAmmoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponVisibleAmmoComponent>();
	}
};
static_assert(alignof(UWeaponVisibleAmmoComponent) == 0x000010, "Wrong alignment on UWeaponVisibleAmmoComponent");
static_assert(sizeof(UWeaponVisibleAmmoComponent) == 0x000250, "Wrong size on UWeaponVisibleAmmoComponent");
static_assert(offsetof(UWeaponVisibleAmmoComponent, AmmoBoneNames) == 0x000180, "Member 'UWeaponVisibleAmmoComponent::AmmoBoneNames' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, MeshType) == 0x000190, "Member 'UWeaponVisibleAmmoComponent::MeshType' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, InitialState) == 0x000191, "Member 'UWeaponVisibleAmmoComponent::InitialState' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, UpdateMethod) == 0x000192, "Member 'UWeaponVisibleAmmoComponent::UpdateMethod' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, HideAmmoEffect) == 0x0001A0, "Member 'UWeaponVisibleAmmoComponent::HideAmmoEffect' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, ShowAmmoEffect) == 0x0001E0, "Member 'UWeaponVisibleAmmoComponent::ShowAmmoEffect' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, VisibleAmmoState) == 0x000220, "Member 'UWeaponVisibleAmmoComponent::VisibleAmmoState' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, ServerAmmoCount) == 0x000224, "Member 'UWeaponVisibleAmmoComponent::ServerAmmoCount' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, CachedAmmoComponent) == 0x000228, "Member 'UWeaponVisibleAmmoComponent::CachedAmmoComponent' has a wrong offset!");
static_assert(offsetof(UWeaponVisibleAmmoComponent, WeaponPrivate) == 0x000248, "Member 'UWeaponVisibleAmmoComponent::WeaponPrivate' has a wrong offset!");

// Class GbxWeapon.WeaponMaxZoomFOVScaleValueResolver
// 0x0008 (0x0030 - 0x0028)
class UWeaponMaxZoomFOVScaleValueResolver final : public UAttributeValueResolver
{
public:
	uint8                                         bInvertValue : 1;                                  // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyWeaponModeZoom : 1;                          // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponMaxZoomFOVScaleValueResolver">();
	}
	static class UWeaponMaxZoomFOVScaleValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponMaxZoomFOVScaleValueResolver>();
	}
};
static_assert(alignof(UWeaponMaxZoomFOVScaleValueResolver) == 0x000008, "Wrong alignment on UWeaponMaxZoomFOVScaleValueResolver");
static_assert(sizeof(UWeaponMaxZoomFOVScaleValueResolver) == 0x000030, "Wrong size on UWeaponMaxZoomFOVScaleValueResolver");

}

