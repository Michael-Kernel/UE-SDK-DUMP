#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxGameSystemCore

#include "Basic.hpp"

#include "GbxRuntime_structs.hpp"
#include "GbxRuntime_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SignificanceManager_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayTasks_classes.hpp"
#include "GbxAnimRuntimeBase_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"


namespace SDK
{

// Class GbxGameSystemCore.GbxAction
// 0x0038 (0x0060 - 0x0028)
class UGbxAction : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanUseCDO;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionSlotName;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxActionPriority                            ActionPriority;                                    // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptStruct*                          InstanceDataType;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBegin(class AActor* Actor);
	void OnEnd(EGbxActionEndState ActionEndState, class AActor* Actor);
	void OnServerBegin(class AActor* Actor);
	void OnServerEnd(EGbxActionEndState ActionEndState, class AActor* Actor);

	class AActor* K2_GetActor() const;
	float K2_GetCurrentNormalizedTime() const;
	float K2_GetCurrentTime() const;
	bool K2_GetFloatRegisterValue(const class FName InName, float* OutFloat) const;
	bool K2_GetIntRegisterValue(const class FName InName, int32* OutInt) const;
	float K2_GetMaxCurrentTime() const;
	bool K2_GetNameRegisterValue(const class FName InName, class FName* OutName) const;
	bool K2_GetObjectRegisterValue(const class FName InName, class UObject** OutObject) const;
	float K2_GetTimeRemaining() const;
	bool K2_GetVectorRegisterValue(const class FName InName, struct FVector* OutVector) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction">();
	}
	static class UGbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction>();
	}
};
static_assert(alignof(UGbxAction) == 0x000008, "Wrong alignment on UGbxAction");
static_assert(sizeof(UGbxAction) == 0x000060, "Wrong size on UGbxAction");
static_assert(offsetof(UGbxAction, bCanUseCDO) == 0x000030, "Member 'UGbxAction::bCanUseCDO' has a wrong offset!");
static_assert(offsetof(UGbxAction, ActionSlotName) == 0x000048, "Member 'UGbxAction::ActionSlotName' has a wrong offset!");
static_assert(offsetof(UGbxAction, ActionPriority) == 0x000050, "Member 'UGbxAction::ActionPriority' has a wrong offset!");
static_assert(offsetof(UGbxAction, InstanceDataType) == 0x000058, "Member 'UGbxAction::InstanceDataType' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_RandomContainer
// 0x0010 (0x0070 - 0x0060)
class UGbxAction_RandomContainer : public UGbxAction
{
public:
	TArray<struct FRandomActionPair>              ActionList;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_RandomContainer">();
	}
	static class UGbxAction_RandomContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_RandomContainer>();
	}
};
static_assert(alignof(UGbxAction_RandomContainer) == 0x000008, "Wrong alignment on UGbxAction_RandomContainer");
static_assert(sizeof(UGbxAction_RandomContainer) == 0x000070, "Wrong size on UGbxAction_RandomContainer");
static_assert(offsetof(UGbxAction_RandomContainer, ActionList) == 0x000060, "Member 'UGbxAction_RandomContainer::ActionList' has a wrong offset!");

// Class GbxGameSystemCore.GbxGameState
// 0x0058 (0x0598 - 0x0540)
class AGbxGameState : public AGameState
{
public:
	class AChallengeManager*                      ChallengeManager;                                  // 0x0540(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameStatsManager*                      StatsManager;                                      // 0x0548(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxCustomizationManager*               CustomizationManager;                              // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           HostPlayerState;                                   // 0x0558(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AImpactDecalManager*                    ImpactDecalManager;                                // 0x0560(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  GameInstanceId;                                    // 0x0568(0x0010)(Net, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GameInstanceTime;                                  // 0x0578(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GameInstanceTimeUpdateRate;                        // 0x057C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGbxCustomizationManager>   CustomizationManagerClass;                         // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRepPlayersOnly;                                   // 0x0590(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_591[0x7];                                      // 0x0591(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SpawnEmitterAtActorSocketMulticast(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, class AActor* Actor, class FName Socket, bool bAutoDestroy, class UObject* ParameterEvaluationContext);
	static void SpawnEmitterAtComponentSocketMulticast(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, class USceneComponent* Component, class FName Socket, bool bAutoDestroy, class UObject* ParameterEvaluationContext);
	static void SpawnEmitterAtLocationMulticast(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, class UObject* ParameterEvaluationContext);

	void OnRep_bPlayersOnly();
	void OnRep_GameInstanceId();
	void OnRep_GameInstanceTime();
	void OnRep_HostPlayerState();
	void OnRep_StatsManager();
	void PlayHitRegionImpactMulticast(const class UHitRegionData* HitRegion, class AActor* ImpactInstigator, const struct FReplicatedImpactHitResult& HitResult);
	void PlayImpactMulticast(const class UImpactData* ImpactData, class AActor* ImpactInstigator, const struct FReplicatedImpactHitResult& HitResult, const struct FImpactResponseParams& ResponseParams);

	void SpawnEmitterAtLocationMulticastImpl(class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, class UObject* ParameterEvaluationContext) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameState">();
	}
	static class AGbxGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxGameState>();
	}
};
static_assert(alignof(AGbxGameState) == 0x000008, "Wrong alignment on AGbxGameState");
static_assert(sizeof(AGbxGameState) == 0x000598, "Wrong size on AGbxGameState");
static_assert(offsetof(AGbxGameState, ChallengeManager) == 0x000540, "Member 'AGbxGameState::ChallengeManager' has a wrong offset!");
static_assert(offsetof(AGbxGameState, StatsManager) == 0x000548, "Member 'AGbxGameState::StatsManager' has a wrong offset!");
static_assert(offsetof(AGbxGameState, CustomizationManager) == 0x000550, "Member 'AGbxGameState::CustomizationManager' has a wrong offset!");
static_assert(offsetof(AGbxGameState, HostPlayerState) == 0x000558, "Member 'AGbxGameState::HostPlayerState' has a wrong offset!");
static_assert(offsetof(AGbxGameState, ImpactDecalManager) == 0x000560, "Member 'AGbxGameState::ImpactDecalManager' has a wrong offset!");
static_assert(offsetof(AGbxGameState, GameInstanceId) == 0x000568, "Member 'AGbxGameState::GameInstanceId' has a wrong offset!");
static_assert(offsetof(AGbxGameState, GameInstanceTime) == 0x000578, "Member 'AGbxGameState::GameInstanceTime' has a wrong offset!");
static_assert(offsetof(AGbxGameState, GameInstanceTimeUpdateRate) == 0x00057C, "Member 'AGbxGameState::GameInstanceTimeUpdateRate' has a wrong offset!");
static_assert(offsetof(AGbxGameState, CustomizationManagerClass) == 0x000580, "Member 'AGbxGameState::CustomizationManagerClass' has a wrong offset!");
static_assert(offsetof(AGbxGameState, bRepPlayersOnly) == 0x000590, "Member 'AGbxGameState::bRepPlayersOnly' has a wrong offset!");

// Class GbxGameSystemCore.StanceDataProvider
// 0x0000 (0x0030 - 0x0030)
class UStanceDataProvider : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceDataProvider">();
	}
	static class UStanceDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceDataProvider>();
	}
};
static_assert(alignof(UStanceDataProvider) == 0x000008, "Wrong alignment on UStanceDataProvider");
static_assert(sizeof(UStanceDataProvider) == 0x000030, "Wrong size on UStanceDataProvider");

// Class GbxGameSystemCore.HitReactionLayer
// 0x0008 (0x0030 - 0x0028)
class UHitReactionLayer : public UObject
{
public:
	bool                                          bStackable;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer">();
	}
	static class UHitReactionLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer>();
	}
};
static_assert(alignof(UHitReactionLayer) == 0x000008, "Wrong alignment on UHitReactionLayer");
static_assert(sizeof(UHitReactionLayer) == 0x000030, "Wrong size on UHitReactionLayer");
static_assert(offsetof(UHitReactionLayer, bStackable) == 0x000028, "Member 'UHitReactionLayer::bStackable' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionLayer_Map
// 0x0010 (0x0040 - 0x0030)
class UHitReactionLayer_Map : public UHitReactionLayer
{
public:
	TArray<struct FHitReactionMapItem>            TagMap;                                            // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer_Map">();
	}
	static class UHitReactionLayer_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer_Map>();
	}
};
static_assert(alignof(UHitReactionLayer_Map) == 0x000008, "Wrong alignment on UHitReactionLayer_Map");
static_assert(sizeof(UHitReactionLayer_Map) == 0x000040, "Wrong size on UHitReactionLayer_Map");
static_assert(offsetof(UHitReactionLayer_Map, TagMap) == 0x000030, "Member 'UHitReactionLayer_Map::TagMap' has a wrong offset!");

// Class GbxGameSystemCore.GbxGameMode
// 0x0000 (0x0548 - 0x0548)
class AGbxGameMode : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameMode">();
	}
	static class AGbxGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxGameMode>();
	}
};
static_assert(alignof(AGbxGameMode) == 0x000008, "Wrong alignment on AGbxGameMode");
static_assert(sizeof(AGbxGameMode) == 0x000548, "Wrong size on AGbxGameMode");

// Class GbxGameSystemCore.GbxCondition_IsPlayerController
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_IsPlayerController final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsPlayerController">();
	}
	static class UGbxCondition_IsPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsPlayerController>();
	}
};
static_assert(alignof(UGbxCondition_IsPlayerController) == 0x000008, "Wrong alignment on UGbxCondition_IsPlayerController");
static_assert(sizeof(UGbxCondition_IsPlayerController) == 0x000088, "Wrong size on UGbxCondition_IsPlayerController");

// Class GbxGameSystemCore.UsableComponent
// 0x0238 (0x03B0 - 0x0178)
class UUsableComponent : public UActorComponent
{
public:
	struct FHoldToUseSettings                     HoldToUseSettings;                                 // 0x0178(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUsabilityDataSelection*                UsabilityData;                                     // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEnabledCondition;                              // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          EnabledCondition;                                  // 0x01A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       PrimaryUseDefSelection;                            // 0x01A8(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       PrimaryHoldUseDefSelection;                        // 0x01C8(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       SecondaryUseDefSelection;                          // 0x01E8(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       SecondaryHoldUseDefSelection;                      // 0x0208(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCanBeUsedFromVehicle : 1;                         // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeUsedFromMech : 1;                            // 0x0228(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanOnlyBeUsedByOwner : 1;                         // 0x0228(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultIsBackupPrimaryData : 1;                   // 0x0228(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UsablePriority;                                    // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsMaxUseCount;                                 // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxUseCount;                                       // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentUseCount;                                   // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RequiredComponentNames;                            // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseAngleRestriction;                              // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUsableAngleRestriction                AngleRestriction;                                  // 0x0254(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRequiresNetAuthority;                             // 0x025C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeaderName;                                        // 0x0260(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0xA0];                                     // 0x0278(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnUsed;                                            // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUsedPrimary;                                     // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUsedPrimaryHold;                                 // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUsedSecondary;                                   // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUsedSecondaryHold;                               // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLookedAt;                                        // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLookedAwayFrom;                                  // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x28];                                     // 0x0388(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetUseCount();
	void SetInteractionHeader(const class FText& NewHeaderName);
	void SetUsableLocked(bool bLocked, class FName Reason);

	const class FText GetInteractionHeader() const;
	void GetValidPrimitiveComponentNames(TArray<class FName>* ComponentNames) const;
	bool K2_CanBeUsed(const struct FUsabilityQuery& Query) const;
	class FText K2_GetOptionalErrorText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsableComponent">();
	}
	static class UUsableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsableComponent>();
	}
};
static_assert(alignof(UUsableComponent) == 0x000008, "Wrong alignment on UUsableComponent");
static_assert(sizeof(UUsableComponent) == 0x0003B0, "Wrong size on UUsableComponent");
static_assert(offsetof(UUsableComponent, HoldToUseSettings) == 0x000178, "Member 'UUsableComponent::HoldToUseSettings' has a wrong offset!");
static_assert(offsetof(UUsableComponent, UsabilityData) == 0x000190, "Member 'UUsableComponent::UsabilityData' has a wrong offset!");
static_assert(offsetof(UUsableComponent, bUseEnabledCondition) == 0x000198, "Member 'UUsableComponent::bUseEnabledCondition' has a wrong offset!");
static_assert(offsetof(UUsableComponent, EnabledCondition) == 0x0001A0, "Member 'UUsableComponent::EnabledCondition' has a wrong offset!");
static_assert(offsetof(UUsableComponent, PrimaryUseDefSelection) == 0x0001A8, "Member 'UUsableComponent::PrimaryUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsableComponent, PrimaryHoldUseDefSelection) == 0x0001C8, "Member 'UUsableComponent::PrimaryHoldUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsableComponent, SecondaryUseDefSelection) == 0x0001E8, "Member 'UUsableComponent::SecondaryUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsableComponent, SecondaryHoldUseDefSelection) == 0x000208, "Member 'UUsableComponent::SecondaryHoldUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsableComponent, UsablePriority) == 0x00022C, "Member 'UUsableComponent::UsablePriority' has a wrong offset!");
static_assert(offsetof(UUsableComponent, bWantsMaxUseCount) == 0x000230, "Member 'UUsableComponent::bWantsMaxUseCount' has a wrong offset!");
static_assert(offsetof(UUsableComponent, MaxUseCount) == 0x000234, "Member 'UUsableComponent::MaxUseCount' has a wrong offset!");
static_assert(offsetof(UUsableComponent, CurrentUseCount) == 0x000238, "Member 'UUsableComponent::CurrentUseCount' has a wrong offset!");
static_assert(offsetof(UUsableComponent, RequiredComponentNames) == 0x000240, "Member 'UUsableComponent::RequiredComponentNames' has a wrong offset!");
static_assert(offsetof(UUsableComponent, bUseAngleRestriction) == 0x000250, "Member 'UUsableComponent::bUseAngleRestriction' has a wrong offset!");
static_assert(offsetof(UUsableComponent, AngleRestriction) == 0x000254, "Member 'UUsableComponent::AngleRestriction' has a wrong offset!");
static_assert(offsetof(UUsableComponent, bRequiresNetAuthority) == 0x00025C, "Member 'UUsableComponent::bRequiresNetAuthority' has a wrong offset!");
static_assert(offsetof(UUsableComponent, HeaderName) == 0x000260, "Member 'UUsableComponent::HeaderName' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnUsed) == 0x000318, "Member 'UUsableComponent::OnUsed' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnUsedPrimary) == 0x000328, "Member 'UUsableComponent::OnUsedPrimary' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnUsedPrimaryHold) == 0x000338, "Member 'UUsableComponent::OnUsedPrimaryHold' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnUsedSecondary) == 0x000348, "Member 'UUsableComponent::OnUsedSecondary' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnUsedSecondaryHold) == 0x000358, "Member 'UUsableComponent::OnUsedSecondaryHold' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnLookedAt) == 0x000368, "Member 'UUsableComponent::OnLookedAt' has a wrong offset!");
static_assert(offsetof(UUsableComponent, OnLookedAwayFrom) == 0x000378, "Member 'UUsableComponent::OnLookedAwayFrom' has a wrong offset!");

// Class GbxGameSystemCore.FirstPersonConfigurationData
// 0x0010 (0x0468 - 0x0458)
class AFirstPersonConfigurationData : public AActor
{
public:
	bool                                          bAutoFillComponentVariables;                       // 0x0458(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxSkeletalMeshComponent*              Arms;                                              // 0x0460(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstPersonConfigurationData">();
	}
	static class AFirstPersonConfigurationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirstPersonConfigurationData>();
	}
};
static_assert(alignof(AFirstPersonConfigurationData) == 0x000008, "Wrong alignment on AFirstPersonConfigurationData");
static_assert(sizeof(AFirstPersonConfigurationData) == 0x000468, "Wrong size on AFirstPersonConfigurationData");
static_assert(offsetof(AFirstPersonConfigurationData, bAutoFillComponentVariables) == 0x000458, "Member 'AFirstPersonConfigurationData::bAutoFillComponentVariables' has a wrong offset!");
static_assert(offsetof(AFirstPersonConfigurationData, Arms) == 0x000460, "Member 'AFirstPersonConfigurationData::Arms' has a wrong offset!");

// Class GbxGameSystemCore.StanceData
// 0x0078 (0x00A8 - 0x0030)
class UStanceData : public UStanceDataProvider
{
public:
	struct FStanceFloatValue                      MaxSpeed;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStanceFloatValue                      MaxRotation;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStanceFloatValue                      MaxAllowedAimOffset;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseMaxAllowedAimOffset;                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStanceFloatValue                      AimRotationRate;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAimRotationRate;                               // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStanceFloatValue                      MaxIdleRotation;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseMaxIdleRotation;                               // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceData*                            StanceDataToShowAnimSystem;                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSlowdownSpeed;                            // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStanceFloatValue                      SlowdownSpeed;                                     // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideMaxAcceleration;                          // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAcceleration;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockDodging;                                      // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockTurns;                                        // 0x0085(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockFootIK;                                       // 0x0086(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockHandIK;                                       // 0x0087(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bThisStanceAllowsFidgetAnims;                      // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTimeBeforeFirstFidgetAnim;                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicalAnimationProfileAsset*         PhysicalAnimation;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UHitReactionLayer>          HitReactionLayer;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitReactionData*                       HitReactionData;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceData">();
	}
	static class UStanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceData>();
	}
};
static_assert(alignof(UStanceData) == 0x000008, "Wrong alignment on UStanceData");
static_assert(sizeof(UStanceData) == 0x0000A8, "Wrong size on UStanceData");
static_assert(offsetof(UStanceData, MaxSpeed) == 0x000030, "Member 'UStanceData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UStanceData, MaxRotation) == 0x000038, "Member 'UStanceData::MaxRotation' has a wrong offset!");
static_assert(offsetof(UStanceData, MaxAllowedAimOffset) == 0x000040, "Member 'UStanceData::MaxAllowedAimOffset' has a wrong offset!");
static_assert(offsetof(UStanceData, bUseMaxAllowedAimOffset) == 0x000048, "Member 'UStanceData::bUseMaxAllowedAimOffset' has a wrong offset!");
static_assert(offsetof(UStanceData, AimRotationRate) == 0x00004C, "Member 'UStanceData::AimRotationRate' has a wrong offset!");
static_assert(offsetof(UStanceData, bUseAimRotationRate) == 0x000054, "Member 'UStanceData::bUseAimRotationRate' has a wrong offset!");
static_assert(offsetof(UStanceData, MaxIdleRotation) == 0x000058, "Member 'UStanceData::MaxIdleRotation' has a wrong offset!");
static_assert(offsetof(UStanceData, bUseMaxIdleRotation) == 0x000060, "Member 'UStanceData::bUseMaxIdleRotation' has a wrong offset!");
static_assert(offsetof(UStanceData, StanceDataToShowAnimSystem) == 0x000068, "Member 'UStanceData::StanceDataToShowAnimSystem' has a wrong offset!");
static_assert(offsetof(UStanceData, bOverrideSlowdownSpeed) == 0x000070, "Member 'UStanceData::bOverrideSlowdownSpeed' has a wrong offset!");
static_assert(offsetof(UStanceData, SlowdownSpeed) == 0x000074, "Member 'UStanceData::SlowdownSpeed' has a wrong offset!");
static_assert(offsetof(UStanceData, bOverrideMaxAcceleration) == 0x00007C, "Member 'UStanceData::bOverrideMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UStanceData, MaxAcceleration) == 0x000080, "Member 'UStanceData::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UStanceData, bLockDodging) == 0x000084, "Member 'UStanceData::bLockDodging' has a wrong offset!");
static_assert(offsetof(UStanceData, bLockTurns) == 0x000085, "Member 'UStanceData::bLockTurns' has a wrong offset!");
static_assert(offsetof(UStanceData, bLockFootIK) == 0x000086, "Member 'UStanceData::bLockFootIK' has a wrong offset!");
static_assert(offsetof(UStanceData, bLockHandIK) == 0x000087, "Member 'UStanceData::bLockHandIK' has a wrong offset!");
static_assert(offsetof(UStanceData, bThisStanceAllowsFidgetAnims) == 0x000088, "Member 'UStanceData::bThisStanceAllowsFidgetAnims' has a wrong offset!");
static_assert(offsetof(UStanceData, WaitTimeBeforeFirstFidgetAnim) == 0x00008C, "Member 'UStanceData::WaitTimeBeforeFirstFidgetAnim' has a wrong offset!");
static_assert(offsetof(UStanceData, PhysicalAnimation) == 0x000090, "Member 'UStanceData::PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(UStanceData, HitReactionLayer) == 0x000098, "Member 'UStanceData::HitReactionLayer' has a wrong offset!");
static_assert(offsetof(UStanceData, HitReactionData) == 0x0000A0, "Member 'UStanceData::HitReactionData' has a wrong offset!");

// Class GbxGameSystemCore.AttributeValueResolver
// 0x0000 (0x0028 - 0x0028)
class UAttributeValueResolver : public UObject
{
public:
	float GetValueForAttribute(const class UGbxAttributeData* Attribute, const class UObject* Context);
	bool SetValueForAttribute(const class UGbxAttributeData* Attribute, const class UObject* Context, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeValueResolver">();
	}
	static class UAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeValueResolver>();
	}
};
static_assert(alignof(UAttributeValueResolver) == 0x000008, "Wrong alignment on UAttributeValueResolver");
static_assert(sizeof(UAttributeValueResolver) == 0x000028, "Wrong size on UAttributeValueResolver");

// Class GbxGameSystemCore.SimpleMathValueResolver
// 0x0078 (0x00A0 - 0x0028)
class USimpleMathValueResolver final : public UAttributeValueResolver
{
public:
	struct FAttributeInitializationData           ValueA;                                            // 0x0028(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESimpleMathValueResolverOperatorType          Operator;                                          // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ValueB;                                            // 0x0068(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleMathValueResolver">();
	}
	static class USimpleMathValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleMathValueResolver>();
	}
};
static_assert(alignof(USimpleMathValueResolver) == 0x000008, "Wrong alignment on USimpleMathValueResolver");
static_assert(sizeof(USimpleMathValueResolver) == 0x0000A0, "Wrong size on USimpleMathValueResolver");
static_assert(offsetof(USimpleMathValueResolver, ValueA) == 0x000028, "Member 'USimpleMathValueResolver::ValueA' has a wrong offset!");
static_assert(offsetof(USimpleMathValueResolver, Operator) == 0x000060, "Member 'USimpleMathValueResolver::Operator' has a wrong offset!");
static_assert(offsetof(USimpleMathValueResolver, ValueB) == 0x000068, "Member 'USimpleMathValueResolver::ValueB' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_SimpleAnim
// 0x0058 (0x00B8 - 0x0060)
class UGbxAction_SimpleAnim : public UGbxAction
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStopAI;                                           // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbortAI;                                          // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMovement;                                     // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableHitReactions;                              // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePhysNoneWithRootMotion;                        // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopLook;                                         // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAimRotation;                                  // 0x006E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopHeadLook;                                     // 0x006F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockHeadLook;                                     // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAvoidance;                                 // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickAndRefreshBones;                              // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCollision;                                 // 0x0073(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     DisableCollisionChannels;                          // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableLoopHelper;                                 // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInterruptSameSlotAnims;                        // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetDynamicsOnBegin;                             // 0x008A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePhysicalAnimationProfile;                      // 0x008B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalAnimationProfileAsset*         PhysicalAnimationProfile;                          // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestorePreviousPhysicalAnimationProfileOnEnd;     // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseNewBoneSetFilter;                              // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxBoneSet*                            NewBoneSetFilter;                                  // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestorePreviousBoneSetFilterProfileOnEnd;         // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetBoneSetFilter;                               // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultInterruptBlendOutTime;                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReleaseResourceFlagsOnAnimEnd;                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndActionOnBlendOut;                              // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimEnd(class AActor* Actor);

	void K2_SetAimRotation(bool bDisable) const;
	void K2_SetAIThinking(bool bDisable) const;
	void K2_SetAvoidance(bool bDisable) const;
	void K2_SetCollision(bool bEnable) const;
	void K2_SetHeadLook(bool bDisable) const;
	void K2_SetHeadLookLocked(bool bLock) const;
	void K2_SetHitReactions(bool bDisable) const;
	void K2_SetLook(bool bDisable) const;
	void K2_SetMovement(bool bDisable) const;
	void K2_SetPhysNoneWithRootMotion(bool bEnable) const;
	void K2_SetTickAndRefreshBones(bool bLockResource) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_SimpleAnim">();
	}
	static class UGbxAction_SimpleAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_SimpleAnim>();
	}
};
static_assert(alignof(UGbxAction_SimpleAnim) == 0x000008, "Wrong alignment on UGbxAction_SimpleAnim");
static_assert(sizeof(UGbxAction_SimpleAnim) == 0x0000B8, "Wrong size on UGbxAction_SimpleAnim");
static_assert(offsetof(UGbxAction_SimpleAnim, bStopAI) == 0x000068, "Member 'UGbxAction_SimpleAnim::bStopAI' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bAbortAI) == 0x000069, "Member 'UGbxAction_SimpleAnim::bAbortAI' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bStopMovement) == 0x00006A, "Member 'UGbxAction_SimpleAnim::bStopMovement' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bDisableHitReactions) == 0x00006B, "Member 'UGbxAction_SimpleAnim::bDisableHitReactions' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bUsePhysNoneWithRootMotion) == 0x00006C, "Member 'UGbxAction_SimpleAnim::bUsePhysNoneWithRootMotion' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bStopLook) == 0x00006D, "Member 'UGbxAction_SimpleAnim::bStopLook' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bStopAimRotation) == 0x00006E, "Member 'UGbxAction_SimpleAnim::bStopAimRotation' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bStopHeadLook) == 0x00006F, "Member 'UGbxAction_SimpleAnim::bStopHeadLook' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bLockHeadLook) == 0x000070, "Member 'UGbxAction_SimpleAnim::bLockHeadLook' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bDisableAvoidance) == 0x000071, "Member 'UGbxAction_SimpleAnim::bDisableAvoidance' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bTickAndRefreshBones) == 0x000072, "Member 'UGbxAction_SimpleAnim::bTickAndRefreshBones' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bDisableCollision) == 0x000073, "Member 'UGbxAction_SimpleAnim::bDisableCollision' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, DisableCollisionChannels) == 0x000078, "Member 'UGbxAction_SimpleAnim::DisableCollisionChannels' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bEnableLoopHelper) == 0x000088, "Member 'UGbxAction_SimpleAnim::bEnableLoopHelper' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bCanInterruptSameSlotAnims) == 0x000089, "Member 'UGbxAction_SimpleAnim::bCanInterruptSameSlotAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bResetDynamicsOnBegin) == 0x00008A, "Member 'UGbxAction_SimpleAnim::bResetDynamicsOnBegin' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bUsePhysicalAnimationProfile) == 0x00008B, "Member 'UGbxAction_SimpleAnim::bUsePhysicalAnimationProfile' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, PhysicalAnimationProfile) == 0x000090, "Member 'UGbxAction_SimpleAnim::PhysicalAnimationProfile' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bRestorePreviousPhysicalAnimationProfileOnEnd) == 0x000098, "Member 'UGbxAction_SimpleAnim::bRestorePreviousPhysicalAnimationProfileOnEnd' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bUseNewBoneSetFilter) == 0x000099, "Member 'UGbxAction_SimpleAnim::bUseNewBoneSetFilter' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, NewBoneSetFilter) == 0x0000A0, "Member 'UGbxAction_SimpleAnim::NewBoneSetFilter' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bRestorePreviousBoneSetFilterProfileOnEnd) == 0x0000A8, "Member 'UGbxAction_SimpleAnim::bRestorePreviousBoneSetFilterProfileOnEnd' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bResetBoneSetFilter) == 0x0000A9, "Member 'UGbxAction_SimpleAnim::bResetBoneSetFilter' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, DefaultInterruptBlendOutTime) == 0x0000AC, "Member 'UGbxAction_SimpleAnim::DefaultInterruptBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bReleaseResourceFlagsOnAnimEnd) == 0x0000B0, "Member 'UGbxAction_SimpleAnim::bReleaseResourceFlagsOnAnimEnd' has a wrong offset!");
static_assert(offsetof(UGbxAction_SimpleAnim, bEndActionOnBlendOut) == 0x0000B1, "Member 'UGbxAction_SimpleAnim::bEndActionOnBlendOut' has a wrong offset!");

// Class GbxGameSystemCore.CauseDamageContextSourceInterface
// 0x0000 (0x0028 - 0x0028)
class ICauseDamageContextSourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CauseDamageContextSourceInterface">();
	}
	static class ICauseDamageContextSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICauseDamageContextSourceInterface>();
	}
};
static_assert(alignof(ICauseDamageContextSourceInterface) == 0x000008, "Wrong alignment on ICauseDamageContextSourceInterface");
static_assert(sizeof(ICauseDamageContextSourceInterface) == 0x000028, "Wrong size on ICauseDamageContextSourceInterface");

// Class GbxGameSystemCore.ControlledMove
// 0x0878 (0x08A0 - 0x0028)
class UControlledMove : public UObject
{
public:
	uint8                                         bIsSpeedScaleNormalized : 1;                       // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEaseInSpeedConstraints : 1;                       // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRestoreCharacterMovementMode : 1;                 // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bZeroVelocityAtEnd : 1;                            // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateCharacterRotationYaw : 1;                   // 0x0028(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateCharacterRotationPitch : 1;                 // 0x0028(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyLaunchVelocityOnStart : 1;                   // 0x0028(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpeedAffectedByMaxGroundSpeedScale : 1;           // 0x0028(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockMomentumAdd : 1;                             // 0x0029(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMotionNormalized : 1;                           // 0x0029(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsInheritVelocityScaleNormalized : 1;             // 0x0029(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyMoveWhenFalling : 1;                         // 0x0029(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopOnLanding : 1;                                // 0x0029(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideAirControl : 1;                           // 0x0029(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSlopeCurve : 1;                                // 0x0029(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopWhenTargetReached : 1;                        // 0x0029(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMoveControls : 1;                           // 0x002A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLimitedLookControl : 1;                           // 0x002A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInputVectorRelativeToMoveDirection : 1;           // 0x002A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMovingLaunchDirection : 1;                     // 0x002A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDirectionRelativeToTarget : 1;                    // 0x002A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOffsetLocationByCollisionRadius : 1;              // 0x002A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOffsetLocationByTargetCollisionRadius : 1;        // 0x002A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLeap : 1;                                         // 0x002A(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysCollideWithTarget : 1;                      // 0x002B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopOnHitWall : 1;                                // 0x002B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopOnHitTargetable : 1;                          // 0x002B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTeleport : 1;                                     // 0x002B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRestrictTeleportToGround : 1;                     // 0x002B(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableLookInput : 1;                             // 0x002B(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMoveInput : 1;                             // 0x002B(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableTargetControls : 1;                         // 0x002B(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTargetControlGrounded : 1;                        // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrackTarget : 1;                                  // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopAI : 1;                                       // 0x002C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortAI : 1;                                      // 0x002C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGodMode : 1;                                      // 0x002C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDemigodMode : 1;                                  // 0x002C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEndCrouch : 1;                                    // 0x002C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceCrouch : 1;                                  // 0x002C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateCameraRotationYaw : 1;                      // 0x002D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateCameraRotationPitch : 1;                    // 0x002D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCancelActionSkillsIfPlayerNotInstigator : 1;      // 0x002D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsNetworkAutonomous : 1;                          // 0x002D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayStartStopActionsLocally : 1;                  // 0x002D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowClientCollisionNotifications : 1;            // 0x002D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           Duration;                                          // 0x0030(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECMMovementType                               MovementType;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           Speed;                                             // 0x0070(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     SpeedScaleCurve;                                   // 0x00A8(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         CharacterRotationYawOffset;                        // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterRotationPitchOffset;                      // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCMMotionData                          MotionCurves;                                      // 0x0128(0x0168)(Edit, NativeAccessSpecifierPublic)
	int32                                         InheritVelocityType;                               // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     InheritVelocityScaleCurve;                         // 0x0298(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         AdjustDurationBySlopeModifier;                     // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     SpeedSlopeScaleCurve;                              // 0x0318(0x0078)(Edit, NativeAccessSpecifierPublic)
	ECMLedgeBehavior                              LedgeBehavior;                                     // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LedgeHeight;                                       // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           AirControl;                                        // 0x0398(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           GravityModifier;                                   // 0x03D0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECMGravityModificationType                    GravityModificationType;                           // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     GravityModifierEffectOverTime;                     // 0x0410(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           TerminalVelocityModifier;                          // 0x0488(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ECMTerminalVelocityModificationType           TerminalVelocityModificationType;                  // 0x04C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetReached2DThreshold;                          // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetReachedUpThreshold;                          // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetReachedDownThreshold;                        // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECMMoveFBControlType                          MoveFBControlType;                                 // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECMMoveLRControlType                          MoveLRControlType;                                 // 0x04D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D2[0x6];                                      // 0x04D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           MoveForwardRate;                                   // 0x04D8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MoveBackwardRate;                                  // 0x0510(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MoveLRRate;                                        // 0x0548(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           LookTurnScale;                                     // 0x0580(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           LookUpScale;                                       // 0x05B8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           LookDownScale;                                     // 0x05F0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DropRate;                                          // 0x0628(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MaxDiveAngle;                                      // 0x0660(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MaxClimbAngle;                                     // 0x0698(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRelativeDirectionData                 LaunchDirection;                                   // 0x06D0(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRelativeDirectionData                 MovingLaunchDirection;                             // 0x0720(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           LaunchAngle;                                       // 0x0770(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocationOffset;                                    // 0x07A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeapApexAngle;                                     // 0x07AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeapStartLandingOffsetTime;                        // 0x07B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B4[0x4];                                      // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 StartAction;                                       // 0x07B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 StopAction;                                        // 0x07C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 LeapApexAction;                                    // 0x07C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 LeapLandingAction;                                 // 0x07D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitWallAngle;                                      // 0x07D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportOffset;                                    // 0x07DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECMTeleportPreferenceType                     TeleportLocationPreference;                        // 0x07E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           LimitedTargetControlDistance;                      // 0x07E8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           TargetControlVelocity;                             // 0x0820(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           TargetControlDelay;                                // 0x0858(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxTrackingCorrectionAngle;                        // 0x0890(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackingVelocity;                                  // 0x0894(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxCharacter*                          ControlledCharacter;                               // 0x0898(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnHitTargetable(class AActor* HitActor, const struct FVector& HitNormal);
	void OnHitWorld(class AActor* HitActor, const struct FVector& HitNormal);
	void OnServerStart(float MoveDuration, class AActor* TargetActor, class AActor* Instigator);
	void OnServerStop(bool bInterrupted);
	void OnStart(float MoveDuration, class AActor* TargetActor);
	void OnStop(bool bInterrupted);
	void OnTargetLocationChanged(const struct FVector& NewTargetLocation);
	void OnTeleported(float MoveDuration, const struct FVector& PreTeleportLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlledMove">();
	}
	static class UControlledMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlledMove>();
	}
};
static_assert(alignof(UControlledMove) == 0x000008, "Wrong alignment on UControlledMove");
static_assert(sizeof(UControlledMove) == 0x0008A0, "Wrong size on UControlledMove");
static_assert(offsetof(UControlledMove, Duration) == 0x000030, "Member 'UControlledMove::Duration' has a wrong offset!");
static_assert(offsetof(UControlledMove, MovementType) == 0x000068, "Member 'UControlledMove::MovementType' has a wrong offset!");
static_assert(offsetof(UControlledMove, Speed) == 0x000070, "Member 'UControlledMove::Speed' has a wrong offset!");
static_assert(offsetof(UControlledMove, SpeedScaleCurve) == 0x0000A8, "Member 'UControlledMove::SpeedScaleCurve' has a wrong offset!");
static_assert(offsetof(UControlledMove, CharacterRotationYawOffset) == 0x000120, "Member 'UControlledMove::CharacterRotationYawOffset' has a wrong offset!");
static_assert(offsetof(UControlledMove, CharacterRotationPitchOffset) == 0x000124, "Member 'UControlledMove::CharacterRotationPitchOffset' has a wrong offset!");
static_assert(offsetof(UControlledMove, MotionCurves) == 0x000128, "Member 'UControlledMove::MotionCurves' has a wrong offset!");
static_assert(offsetof(UControlledMove, InheritVelocityType) == 0x000290, "Member 'UControlledMove::InheritVelocityType' has a wrong offset!");
static_assert(offsetof(UControlledMove, InheritVelocityScaleCurve) == 0x000298, "Member 'UControlledMove::InheritVelocityScaleCurve' has a wrong offset!");
static_assert(offsetof(UControlledMove, AdjustDurationBySlopeModifier) == 0x000310, "Member 'UControlledMove::AdjustDurationBySlopeModifier' has a wrong offset!");
static_assert(offsetof(UControlledMove, MaxStepHeight) == 0x000314, "Member 'UControlledMove::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UControlledMove, SpeedSlopeScaleCurve) == 0x000318, "Member 'UControlledMove::SpeedSlopeScaleCurve' has a wrong offset!");
static_assert(offsetof(UControlledMove, LedgeBehavior) == 0x000390, "Member 'UControlledMove::LedgeBehavior' has a wrong offset!");
static_assert(offsetof(UControlledMove, LedgeHeight) == 0x000394, "Member 'UControlledMove::LedgeHeight' has a wrong offset!");
static_assert(offsetof(UControlledMove, AirControl) == 0x000398, "Member 'UControlledMove::AirControl' has a wrong offset!");
static_assert(offsetof(UControlledMove, GravityModifier) == 0x0003D0, "Member 'UControlledMove::GravityModifier' has a wrong offset!");
static_assert(offsetof(UControlledMove, GravityModificationType) == 0x000408, "Member 'UControlledMove::GravityModificationType' has a wrong offset!");
static_assert(offsetof(UControlledMove, GravityModifierEffectOverTime) == 0x000410, "Member 'UControlledMove::GravityModifierEffectOverTime' has a wrong offset!");
static_assert(offsetof(UControlledMove, TerminalVelocityModifier) == 0x000488, "Member 'UControlledMove::TerminalVelocityModifier' has a wrong offset!");
static_assert(offsetof(UControlledMove, TerminalVelocityModificationType) == 0x0004C0, "Member 'UControlledMove::TerminalVelocityModificationType' has a wrong offset!");
static_assert(offsetof(UControlledMove, TargetReached2DThreshold) == 0x0004C4, "Member 'UControlledMove::TargetReached2DThreshold' has a wrong offset!");
static_assert(offsetof(UControlledMove, TargetReachedUpThreshold) == 0x0004C8, "Member 'UControlledMove::TargetReachedUpThreshold' has a wrong offset!");
static_assert(offsetof(UControlledMove, TargetReachedDownThreshold) == 0x0004CC, "Member 'UControlledMove::TargetReachedDownThreshold' has a wrong offset!");
static_assert(offsetof(UControlledMove, MoveFBControlType) == 0x0004D0, "Member 'UControlledMove::MoveFBControlType' has a wrong offset!");
static_assert(offsetof(UControlledMove, MoveLRControlType) == 0x0004D1, "Member 'UControlledMove::MoveLRControlType' has a wrong offset!");
static_assert(offsetof(UControlledMove, MoveForwardRate) == 0x0004D8, "Member 'UControlledMove::MoveForwardRate' has a wrong offset!");
static_assert(offsetof(UControlledMove, MoveBackwardRate) == 0x000510, "Member 'UControlledMove::MoveBackwardRate' has a wrong offset!");
static_assert(offsetof(UControlledMove, MoveLRRate) == 0x000548, "Member 'UControlledMove::MoveLRRate' has a wrong offset!");
static_assert(offsetof(UControlledMove, LookTurnScale) == 0x000580, "Member 'UControlledMove::LookTurnScale' has a wrong offset!");
static_assert(offsetof(UControlledMove, LookUpScale) == 0x0005B8, "Member 'UControlledMove::LookUpScale' has a wrong offset!");
static_assert(offsetof(UControlledMove, LookDownScale) == 0x0005F0, "Member 'UControlledMove::LookDownScale' has a wrong offset!");
static_assert(offsetof(UControlledMove, DropRate) == 0x000628, "Member 'UControlledMove::DropRate' has a wrong offset!");
static_assert(offsetof(UControlledMove, MaxDiveAngle) == 0x000660, "Member 'UControlledMove::MaxDiveAngle' has a wrong offset!");
static_assert(offsetof(UControlledMove, MaxClimbAngle) == 0x000698, "Member 'UControlledMove::MaxClimbAngle' has a wrong offset!");
static_assert(offsetof(UControlledMove, LaunchDirection) == 0x0006D0, "Member 'UControlledMove::LaunchDirection' has a wrong offset!");
static_assert(offsetof(UControlledMove, MovingLaunchDirection) == 0x000720, "Member 'UControlledMove::MovingLaunchDirection' has a wrong offset!");
static_assert(offsetof(UControlledMove, LaunchAngle) == 0x000770, "Member 'UControlledMove::LaunchAngle' has a wrong offset!");
static_assert(offsetof(UControlledMove, LocationOffset) == 0x0007A8, "Member 'UControlledMove::LocationOffset' has a wrong offset!");
static_assert(offsetof(UControlledMove, LeapApexAngle) == 0x0007AC, "Member 'UControlledMove::LeapApexAngle' has a wrong offset!");
static_assert(offsetof(UControlledMove, LeapStartLandingOffsetTime) == 0x0007B0, "Member 'UControlledMove::LeapStartLandingOffsetTime' has a wrong offset!");
static_assert(offsetof(UControlledMove, StartAction) == 0x0007B8, "Member 'UControlledMove::StartAction' has a wrong offset!");
static_assert(offsetof(UControlledMove, StopAction) == 0x0007C0, "Member 'UControlledMove::StopAction' has a wrong offset!");
static_assert(offsetof(UControlledMove, LeapApexAction) == 0x0007C8, "Member 'UControlledMove::LeapApexAction' has a wrong offset!");
static_assert(offsetof(UControlledMove, LeapLandingAction) == 0x0007D0, "Member 'UControlledMove::LeapLandingAction' has a wrong offset!");
static_assert(offsetof(UControlledMove, HitWallAngle) == 0x0007D8, "Member 'UControlledMove::HitWallAngle' has a wrong offset!");
static_assert(offsetof(UControlledMove, TeleportOffset) == 0x0007DC, "Member 'UControlledMove::TeleportOffset' has a wrong offset!");
static_assert(offsetof(UControlledMove, TeleportLocationPreference) == 0x0007E0, "Member 'UControlledMove::TeleportLocationPreference' has a wrong offset!");
static_assert(offsetof(UControlledMove, LimitedTargetControlDistance) == 0x0007E8, "Member 'UControlledMove::LimitedTargetControlDistance' has a wrong offset!");
static_assert(offsetof(UControlledMove, TargetControlVelocity) == 0x000820, "Member 'UControlledMove::TargetControlVelocity' has a wrong offset!");
static_assert(offsetof(UControlledMove, TargetControlDelay) == 0x000858, "Member 'UControlledMove::TargetControlDelay' has a wrong offset!");
static_assert(offsetof(UControlledMove, MaxTrackingCorrectionAngle) == 0x000890, "Member 'UControlledMove::MaxTrackingCorrectionAngle' has a wrong offset!");
static_assert(offsetof(UControlledMove, TrackingVelocity) == 0x000894, "Member 'UControlledMove::TrackingVelocity' has a wrong offset!");
static_assert(offsetof(UControlledMove, ControlledCharacter) == 0x000898, "Member 'UControlledMove::ControlledCharacter' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionData
// 0x0030 (0x0060 - 0x0030)
class UHitReactionData final : public UGbxDataAsset
{
public:
	TArray<TSubclassOf<class UHitReactionLayer>>  LiveLayers;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UHitReactionLayer>>  DeathLayers;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FHitReactionPair>               HitReactions;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionData">();
	}
	static class UHitReactionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionData>();
	}
};
static_assert(alignof(UHitReactionData) == 0x000008, "Wrong alignment on UHitReactionData");
static_assert(sizeof(UHitReactionData) == 0x000060, "Wrong size on UHitReactionData");
static_assert(offsetof(UHitReactionData, LiveLayers) == 0x000030, "Member 'UHitReactionData::LiveLayers' has a wrong offset!");
static_assert(offsetof(UHitReactionData, DeathLayers) == 0x000040, "Member 'UHitReactionData::DeathLayers' has a wrong offset!");
static_assert(offsetof(UHitReactionData, HitReactions) == 0x000050, "Member 'UHitReactionData::HitReactions' has a wrong offset!");

// Class GbxGameSystemCore.GbxAnimTable
// 0x0018 (0x0048 - 0x0030)
class UGbxAnimTable : public UGbxDataAsset
{
public:
	struct FGbxTriggerProperty                    TriggerAutofill;                                   // 0x0030(0x0001)(Edit, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTable;                                         // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bScaleRateByMeshScale;                             // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Autofill();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimTable">();
	}
	static class UGbxAnimTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimTable>();
	}
};
static_assert(alignof(UGbxAnimTable) == 0x000008, "Wrong alignment on UGbxAnimTable");
static_assert(sizeof(UGbxAnimTable) == 0x000048, "Wrong size on UGbxAnimTable");
static_assert(offsetof(UGbxAnimTable, TriggerAutofill) == 0x000030, "Member 'UGbxAnimTable::TriggerAutofill' has a wrong offset!");
static_assert(offsetof(UGbxAnimTable, DataTable) == 0x000038, "Member 'UGbxAnimTable::DataTable' has a wrong offset!");
static_assert(offsetof(UGbxAnimTable, bScaleRateByMeshScale) == 0x000040, "Member 'UGbxAnimTable::bScaleRateByMeshScale' has a wrong offset!");

// Class GbxGameSystemCore.ConditionalDamageModifier
// 0x0108 (0x0138 - 0x0030)
class UConditionalDamageModifier : public UGbxDataAsset
{
public:
	class UGbxCondition*                          AttackerCondition;                                 // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackerConditionFirstContextIsOverrideContextObject; // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackerConditionSecondContextIsDamageCauser;     // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          DefenderCondition;                                 // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefenderConditionFirstContextIsOverrideContextObject; // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefenderConditionSecondContextIsDamageCauser;     // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EDamageFilterExprMode                         DamageTypeFilterMode;                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGbxDamageType>>     DamageTypeFilter;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EDamageFilterExprMode                         DamageSourceFilterMode;                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeDamageSourceSubclasses;                    // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UDamageSource>>      DamageSourceFilter;                                // 0x0068(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bUseHitDirectionAngle;                             // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           HitDirectionAngle;                                 // 0x0080(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           HitDirectionAngleOffset;                           // 0x00B8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCriticalFilter;                                // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConditionalDamageCriticalFilter              CriticalFilter;                                    // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAreaDamageFilter;                              // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConditionalAreaDamageFilter                  AreaDamageFilter;                                  // 0x00F3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomChance;                                  // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           RandomChance;                                      // 0x00F8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanTriggerOnBonusDamage;                          // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppliesToInstigatorChildren;                      // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalDamageModifier">();
	}
	static class UConditionalDamageModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalDamageModifier>();
	}
};
static_assert(alignof(UConditionalDamageModifier) == 0x000008, "Wrong alignment on UConditionalDamageModifier");
static_assert(sizeof(UConditionalDamageModifier) == 0x000138, "Wrong size on UConditionalDamageModifier");
static_assert(offsetof(UConditionalDamageModifier, AttackerCondition) == 0x000030, "Member 'UConditionalDamageModifier::AttackerCondition' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bAttackerConditionFirstContextIsOverrideContextObject) == 0x000038, "Member 'UConditionalDamageModifier::bAttackerConditionFirstContextIsOverrideContextObject' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bAttackerConditionSecondContextIsDamageCauser) == 0x000039, "Member 'UConditionalDamageModifier::bAttackerConditionSecondContextIsDamageCauser' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, DefenderCondition) == 0x000040, "Member 'UConditionalDamageModifier::DefenderCondition' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bDefenderConditionFirstContextIsOverrideContextObject) == 0x000048, "Member 'UConditionalDamageModifier::bDefenderConditionFirstContextIsOverrideContextObject' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bDefenderConditionSecondContextIsDamageCauser) == 0x000049, "Member 'UConditionalDamageModifier::bDefenderConditionSecondContextIsDamageCauser' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, DamageTypeFilterMode) == 0x00004C, "Member 'UConditionalDamageModifier::DamageTypeFilterMode' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, DamageTypeFilter) == 0x000050, "Member 'UConditionalDamageModifier::DamageTypeFilter' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, DamageSourceFilterMode) == 0x000060, "Member 'UConditionalDamageModifier::DamageSourceFilterMode' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bIncludeDamageSourceSubclasses) == 0x000064, "Member 'UConditionalDamageModifier::bIncludeDamageSourceSubclasses' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, DamageSourceFilter) == 0x000068, "Member 'UConditionalDamageModifier::DamageSourceFilter' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bUseHitDirectionAngle) == 0x000078, "Member 'UConditionalDamageModifier::bUseHitDirectionAngle' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, HitDirectionAngle) == 0x000080, "Member 'UConditionalDamageModifier::HitDirectionAngle' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, HitDirectionAngleOffset) == 0x0000B8, "Member 'UConditionalDamageModifier::HitDirectionAngleOffset' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bUseCriticalFilter) == 0x0000F0, "Member 'UConditionalDamageModifier::bUseCriticalFilter' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, CriticalFilter) == 0x0000F1, "Member 'UConditionalDamageModifier::CriticalFilter' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bUseAreaDamageFilter) == 0x0000F2, "Member 'UConditionalDamageModifier::bUseAreaDamageFilter' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, AreaDamageFilter) == 0x0000F3, "Member 'UConditionalDamageModifier::AreaDamageFilter' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bUseRandomChance) == 0x0000F4, "Member 'UConditionalDamageModifier::bUseRandomChance' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, RandomChance) == 0x0000F8, "Member 'UConditionalDamageModifier::RandomChance' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bCanTriggerOnBonusDamage) == 0x000130, "Member 'UConditionalDamageModifier::bCanTriggerOnBonusDamage' has a wrong offset!");
static_assert(offsetof(UConditionalDamageModifier, bAppliesToInstigatorChildren) == 0x000131, "Member 'UConditionalDamageModifier::bAppliesToInstigatorChildren' has a wrong offset!");

// Class GbxGameSystemCore.ConditionalDamageCriticalModifier
// 0x0040 (0x0178 - 0x0138)
class UConditionalDamageCriticalModifier final : public UConditionalDamageModifier
{
public:
	bool                                          bOnlyApplyIfHitRegionWasCritical;                  // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultCriticalHitMultiplier;                  // 0x0139(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x6];                                      // 0x013A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           AdditionalCriticalMultiplier;                      // 0x0140(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalDamageCriticalModifier">();
	}
	static class UConditionalDamageCriticalModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalDamageCriticalModifier>();
	}
};
static_assert(alignof(UConditionalDamageCriticalModifier) == 0x000008, "Wrong alignment on UConditionalDamageCriticalModifier");
static_assert(sizeof(UConditionalDamageCriticalModifier) == 0x000178, "Wrong size on UConditionalDamageCriticalModifier");
static_assert(offsetof(UConditionalDamageCriticalModifier, bOnlyApplyIfHitRegionWasCritical) == 0x000138, "Member 'UConditionalDamageCriticalModifier::bOnlyApplyIfHitRegionWasCritical' has a wrong offset!");
static_assert(offsetof(UConditionalDamageCriticalModifier, bUseDefaultCriticalHitMultiplier) == 0x000139, "Member 'UConditionalDamageCriticalModifier::bUseDefaultCriticalHitMultiplier' has a wrong offset!");
static_assert(offsetof(UConditionalDamageCriticalModifier, AdditionalCriticalMultiplier) == 0x000140, "Member 'UConditionalDamageCriticalModifier::AdditionalCriticalMultiplier' has a wrong offset!");

// Class GbxGameSystemCore.CinematicModeData
// 0x0010 (0x0040 - 0x0030)
class UCinematicModeData : public UGbxDataAsset
{
public:
	bool                                          bCinematicMode;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayer;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayerOwnedVehicles;                          // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideNPC;                                          // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHUD;                                       // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsMovement;                                  // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsPawnRotation;                              // 0x0036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsTurning;                                   // 0x0037(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCinematicSplitScreen;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGodMode;                                    // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNoTarget;                                   // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECinematicAudioMode                           AudioMode;                                         // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicModeData">();
	}
	static class UCinematicModeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicModeData>();
	}
};
static_assert(alignof(UCinematicModeData) == 0x000008, "Wrong alignment on UCinematicModeData");
static_assert(sizeof(UCinematicModeData) == 0x000040, "Wrong size on UCinematicModeData");
static_assert(offsetof(UCinematicModeData, bCinematicMode) == 0x000030, "Member 'UCinematicModeData::bCinematicMode' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bHidePlayer) == 0x000031, "Member 'UCinematicModeData::bHidePlayer' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bHidePlayerOwnedVehicles) == 0x000032, "Member 'UCinematicModeData::bHidePlayerOwnedVehicles' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bHideNPC) == 0x000033, "Member 'UCinematicModeData::bHideNPC' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bAffectsHUD) == 0x000034, "Member 'UCinematicModeData::bAffectsHUD' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bAffectsMovement) == 0x000035, "Member 'UCinematicModeData::bAffectsMovement' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bAffectsPawnRotation) == 0x000036, "Member 'UCinematicModeData::bAffectsPawnRotation' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bAffectsTurning) == 0x000037, "Member 'UCinematicModeData::bAffectsTurning' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bCinematicSplitScreen) == 0x000038, "Member 'UCinematicModeData::bCinematicSplitScreen' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bEnableGodMode) == 0x000039, "Member 'UCinematicModeData::bEnableGodMode' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, bEnableNoTarget) == 0x00003A, "Member 'UCinematicModeData::bEnableNoTarget' has a wrong offset!");
static_assert(offsetof(UCinematicModeData, AudioMode) == 0x00003B, "Member 'UCinematicModeData::AudioMode' has a wrong offset!");

// Class GbxGameSystemCore.GbxAssetManager
// 0x0030 (0x0410 - 0x03E0)
class UGbxAssetManager : public UAssetManager
{
public:
	TArray<struct FStartupAssetTypeData>          StartupAssetTypes;                                 // 0x03E0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           StartupAssetFiles;                                 // 0x03F0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAssetManager">();
	}
	static class UGbxAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAssetManager>();
	}
};
static_assert(alignof(UGbxAssetManager) == 0x000008, "Wrong alignment on UGbxAssetManager");
static_assert(sizeof(UGbxAssetManager) == 0x000410, "Wrong size on UGbxAssetManager");
static_assert(offsetof(UGbxAssetManager, StartupAssetTypes) == 0x0003E0, "Member 'UGbxAssetManager::StartupAssetTypes' has a wrong offset!");
static_assert(offsetof(UGbxAssetManager, StartupAssetFiles) == 0x0003F0, "Member 'UGbxAssetManager::StartupAssetFiles' has a wrong offset!");

// Class GbxGameSystemCore.GbxAISystemBase
// 0x0008 (0x0130 - 0x0128)
class UGbxAISystemBase : public UAISystem
{
public:
	class UGbxQueryManager*                       GbxQueryManager;                                   // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAISystemBase">();
	}
	static class UGbxAISystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAISystemBase>();
	}
};
static_assert(alignof(UGbxAISystemBase) == 0x000008, "Wrong alignment on UGbxAISystemBase");
static_assert(sizeof(UGbxAISystemBase) == 0x000130, "Wrong size on UGbxAISystemBase");
static_assert(offsetof(UGbxAISystemBase, GbxQueryManager) == 0x000128, "Member 'UGbxAISystemBase::GbxQueryManager' has a wrong offset!");

// Class GbxGameSystemCore.AimAssistStrategy
// 0x0000 (0x0028 - 0x0028)
class UAimAssistStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistStrategy">();
	}
	static class UAimAssistStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistStrategy>();
	}
};
static_assert(alignof(UAimAssistStrategy) == 0x000008, "Wrong alignment on UAimAssistStrategy");
static_assert(sizeof(UAimAssistStrategy) == 0x000028, "Wrong size on UAimAssistStrategy");

// Class GbxGameSystemCore.AIDataProvider_AttributeInitializationData
// 0x0048 (0x0070 - 0x0028)
class UAIDataProvider_AttributeInitializationData final : public UAIDataProvider
{
public:
	struct FAttributeInitializationData           AttributeInitializationData;                       // 0x0028(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_AttributeInitializationData">();
	}
	static class UAIDataProvider_AttributeInitializationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_AttributeInitializationData>();
	}
};
static_assert(alignof(UAIDataProvider_AttributeInitializationData) == 0x000008, "Wrong alignment on UAIDataProvider_AttributeInitializationData");
static_assert(sizeof(UAIDataProvider_AttributeInitializationData) == 0x000070, "Wrong size on UAIDataProvider_AttributeInitializationData");
static_assert(offsetof(UAIDataProvider_AttributeInitializationData, AttributeInitializationData) == 0x000028, "Member 'UAIDataProvider_AttributeInitializationData::AttributeInitializationData' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeInitializationData, FloatValue) == 0x000060, "Member 'UAIDataProvider_AttributeInitializationData::FloatValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeInitializationData, IntValue) == 0x000064, "Member 'UAIDataProvider_AttributeInitializationData::IntValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeInitializationData, BoolValue) == 0x000068, "Member 'UAIDataProvider_AttributeInitializationData::BoolValue' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_CoordinatedEffect
// 0x00D0 (0x0130 - 0x0060)
class UGbxAction_CoordinatedEffect : public UGbxAction
{
public:
	uint8                                         bInfiniteDuration : 1;                             // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoop : 1;                                         // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCensored : 1;                                     // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyActorOnEnd : 1;                            // 0x0060(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUnhideActorOnBegin : 1;                           // 0x0060(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHideActorOnEnd : 1;                               // 0x0060(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGbxAction_CoordinatedEffect> NextEffect;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PermanentGroupTag;                                 // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MaskMaterial;                                      // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GlowMaterial;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCoordinatedConditionalMaterialData> ConditionalOverrideMaterials;                      // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCoordinatedScalarParameter>    MaterialScalarParameters;                          // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCoordinatedVectorParameter>    MaterialVectorParameters;                          // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           InheritedMaterialParameters;                       // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EMaterialParameterCopyMethod                  InheritMaterialParametersMethod;                   // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInheritAllMaterialParameters : 1;                 // 0x00D1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverwriteInstancedMaterialParameters : 1;         // 0x00D1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bApplyToTranslucentMaterials : 1;                  // 0x00D1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPermanentMaterialOverride : 1;                    // 0x00D1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAlwaysRestoreMaterialParametersAtEnd : 1;         // 0x00D1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bApplyMaterialParametersToBothOverrideAndMaskGlow : 1; // 0x00D1(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedMaterialStaticParameters;                  // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCoordinatedParticleSystemData> ParticleEffects;                                   // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCoordinatedParticleSystemParameterData> ParticleParameters;                                // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ParticleSpeedMultiplier;                           // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoordinatedOwnedParticleAction               OwnedParticleAction;                               // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAlwaysRestoreParticleParametersAtEnd : 1;         // 0x010D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bHideOwnedParticles;                               // 0x010E(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F[0x1];                                      // 0x010F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCoordinatedAudioData>          AudioEffects;                                      // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCoordinatedLightParameterData> LightParameters;                                   // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void SetConstantMaterialVectorParamValue(class FName ParamName, const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_CoordinatedEffect">();
	}
	static class UGbxAction_CoordinatedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_CoordinatedEffect>();
	}
};
static_assert(alignof(UGbxAction_CoordinatedEffect) == 0x000008, "Wrong alignment on UGbxAction_CoordinatedEffect");
static_assert(sizeof(UGbxAction_CoordinatedEffect) == 0x000130, "Wrong size on UGbxAction_CoordinatedEffect");
static_assert(offsetof(UGbxAction_CoordinatedEffect, Duration) == 0x000064, "Member 'UGbxAction_CoordinatedEffect::Duration' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, NextEffect) == 0x000068, "Member 'UGbxAction_CoordinatedEffect::NextEffect' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, PermanentGroupTag) == 0x000070, "Member 'UGbxAction_CoordinatedEffect::PermanentGroupTag' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, OverrideMaterial) == 0x000078, "Member 'UGbxAction_CoordinatedEffect::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, MaskMaterial) == 0x000080, "Member 'UGbxAction_CoordinatedEffect::MaskMaterial' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, GlowMaterial) == 0x000088, "Member 'UGbxAction_CoordinatedEffect::GlowMaterial' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, ConditionalOverrideMaterials) == 0x000090, "Member 'UGbxAction_CoordinatedEffect::ConditionalOverrideMaterials' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, MaterialScalarParameters) == 0x0000A0, "Member 'UGbxAction_CoordinatedEffect::MaterialScalarParameters' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, MaterialVectorParameters) == 0x0000B0, "Member 'UGbxAction_CoordinatedEffect::MaterialVectorParameters' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, InheritedMaterialParameters) == 0x0000C0, "Member 'UGbxAction_CoordinatedEffect::InheritedMaterialParameters' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, InheritMaterialParametersMethod) == 0x0000D0, "Member 'UGbxAction_CoordinatedEffect::InheritMaterialParametersMethod' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, ExcludedMaterialStaticParameters) == 0x0000D8, "Member 'UGbxAction_CoordinatedEffect::ExcludedMaterialStaticParameters' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, ParticleEffects) == 0x0000E8, "Member 'UGbxAction_CoordinatedEffect::ParticleEffects' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, ParticleParameters) == 0x0000F8, "Member 'UGbxAction_CoordinatedEffect::ParticleParameters' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, ParticleSpeedMultiplier) == 0x000108, "Member 'UGbxAction_CoordinatedEffect::ParticleSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, OwnedParticleAction) == 0x00010C, "Member 'UGbxAction_CoordinatedEffect::OwnedParticleAction' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, bHideOwnedParticles) == 0x00010E, "Member 'UGbxAction_CoordinatedEffect::bHideOwnedParticles' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, AudioEffects) == 0x000110, "Member 'UGbxAction_CoordinatedEffect::AudioEffects' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoordinatedEffect, LightParameters) == 0x000120, "Member 'UGbxAction_CoordinatedEffect::LightParameters' has a wrong offset!");

// Class GbxGameSystemCore.UIStatData
// 0x0038 (0x0068 - 0x0030)
class UUIStatData : public UGbxDataAsset
{
public:
	class FText                                   Description;                                       // 0x0030(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCanDisplayMultipleTimes : 1;                      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBiggerIsBetter : 1;                               // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BasePriority;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SectionName;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 IconFrameName;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float ComputeAttributeModification(class UGbxAttributeData* Attribute, const bool bScale, const struct FUIStatCollector& Collector) const;
	void EnumerateSectionNames(TArray<class FName>* OutSectionNameList) const;
	float K2_GetComparisonValue(class UObject* Context, const struct FUIStatCollector& Collector) const;
	class FText K2_GetValueText(class UObject* Context, const struct FUIStatCollector& Collector) const;
	bool K2_ShouldDisplayStat(class UObject* Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatData">();
	}
	static class UUIStatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatData>();
	}
};
static_assert(alignof(UUIStatData) == 0x000008, "Wrong alignment on UUIStatData");
static_assert(sizeof(UUIStatData) == 0x000068, "Wrong size on UUIStatData");
static_assert(offsetof(UUIStatData, Description) == 0x000030, "Member 'UUIStatData::Description' has a wrong offset!");
static_assert(offsetof(UUIStatData, BasePriority) == 0x00004C, "Member 'UUIStatData::BasePriority' has a wrong offset!");
static_assert(offsetof(UUIStatData, SectionName) == 0x000050, "Member 'UUIStatData::SectionName' has a wrong offset!");
static_assert(offsetof(UUIStatData, IconFrameName) == 0x000058, "Member 'UUIStatData::IconFrameName' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_Anim
// 0x00F0 (0x01A8 - 0x00B8)
class UGbxAction_Anim : public UGbxAction_SimpleAnim
{
public:
	struct FAnimMeshList                          DefaultAnims;                                      // 0x00B8(0x0078)(Edit, NativeAccessSpecifierPublic)
	EGbxActionEndCondition                        DefaultEndCondition;                               // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationSlot;                                     // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPushBlendInTime;                                  // 0x0144(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBlendOutTime;                               // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPushBlendOutTime;                                 // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePlayrateWithCharacterScale;                  // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceCameraAlpha;                                 // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageCameraAlpha;                                // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableFootIk;                                    // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBody1stControlsDuration;                          // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlay1stPersonAnimationsOnRemotePlayers;           // 0x0162(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_163[0x5];                                      // 0x0163(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimSlot3rd;                                       // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimSlot1st;                                       // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAnimSlot3rdValue;                              // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAnimSlot1stValue;                              // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodMode;                                          // 0x017A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDemigodMode;                                      // 0x017B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockCrouching;                                   // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockMantling;                                    // 0x017D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableScaledRootMotion;                           // 0x017E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainRootVelocity;                             // 0x017F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDuration;                                 // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideDuration;                                  // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCount;                                    // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideCount;                                     // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePlayRate;                                 // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverridePlayRate;                                  // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlendSpaceXRegisterName;                           // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlendSpaceYRegisterName;                           // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void K2_JumpToNextSection() const;
	void K2_Pause() const;
	void K2_ProceedToNextSection() const;
	void K2_RepJumpToNextSection() const;
	void K2_RepProceedToNextSection() const;
	void K2_Resume() const;
	void K2_SetCrouchBlocked(bool bBlocked) const;
	void K2_SetDemigodMode(bool bEnable) const;
	void K2_SetFootIK(bool bDisable) const;
	void K2_SetGodMode(bool bEnable) const;
	void K2_SetMantlingBlocked(bool bBlocked) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_Anim">();
	}
	static class UGbxAction_Anim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_Anim>();
	}
};
static_assert(alignof(UGbxAction_Anim) == 0x000008, "Wrong alignment on UGbxAction_Anim");
static_assert(sizeof(UGbxAction_Anim) == 0x0001A8, "Wrong size on UGbxAction_Anim");
static_assert(offsetof(UGbxAction_Anim, DefaultAnims) == 0x0000B8, "Member 'UGbxAction_Anim::DefaultAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, DefaultEndCondition) == 0x000130, "Member 'UGbxAction_Anim::DefaultEndCondition' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, AnimationSlot) == 0x000138, "Member 'UGbxAction_Anim::AnimationSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, BlendInTime) == 0x000140, "Member 'UGbxAction_Anim::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bPushBlendInTime) == 0x000144, "Member 'UGbxAction_Anim::bPushBlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, DefaultBlendOutTime) == 0x000148, "Member 'UGbxAction_Anim::DefaultBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bPushBlendOutTime) == 0x00014C, "Member 'UGbxAction_Anim::bPushBlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, PlayRate) == 0x000150, "Member 'UGbxAction_Anim::PlayRate' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bScalePlayrateWithCharacterScale) == 0x000154, "Member 'UGbxAction_Anim::bScalePlayrateWithCharacterScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, SourceCameraAlpha) == 0x000158, "Member 'UGbxAction_Anim::SourceCameraAlpha' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, MontageCameraAlpha) == 0x00015C, "Member 'UGbxAction_Anim::MontageCameraAlpha' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bDisableFootIk) == 0x000160, "Member 'UGbxAction_Anim::bDisableFootIk' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bBody1stControlsDuration) == 0x000161, "Member 'UGbxAction_Anim::bBody1stControlsDuration' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bPlay1stPersonAnimationsOnRemotePlayers) == 0x000162, "Member 'UGbxAction_Anim::bPlay1stPersonAnimationsOnRemotePlayers' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, AnimSlot3rd) == 0x000168, "Member 'UGbxAction_Anim::AnimSlot3rd' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, AnimSlot1st) == 0x000170, "Member 'UGbxAction_Anim::AnimSlot1st' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bHasAnimSlot3rdValue) == 0x000178, "Member 'UGbxAction_Anim::bHasAnimSlot3rdValue' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bHasAnimSlot1stValue) == 0x000179, "Member 'UGbxAction_Anim::bHasAnimSlot1stValue' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bGodMode) == 0x00017A, "Member 'UGbxAction_Anim::bGodMode' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bDemigodMode) == 0x00017B, "Member 'UGbxAction_Anim::bDemigodMode' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bBlockCrouching) == 0x00017C, "Member 'UGbxAction_Anim::bBlockCrouching' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bBlockMantling) == 0x00017D, "Member 'UGbxAction_Anim::bBlockMantling' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bEnableScaledRootMotion) == 0x00017E, "Member 'UGbxAction_Anim::bEnableScaledRootMotion' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bMaintainRootVelocity) == 0x00017F, "Member 'UGbxAction_Anim::bMaintainRootVelocity' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bOverrideDuration) == 0x000180, "Member 'UGbxAction_Anim::bOverrideDuration' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, OverrideDuration) == 0x000184, "Member 'UGbxAction_Anim::OverrideDuration' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bOverrideCount) == 0x000188, "Member 'UGbxAction_Anim::bOverrideCount' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, OverrideCount) == 0x00018C, "Member 'UGbxAction_Anim::OverrideCount' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, bOverridePlayRate) == 0x000190, "Member 'UGbxAction_Anim::bOverridePlayRate' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, OverridePlayRate) == 0x000194, "Member 'UGbxAction_Anim::OverridePlayRate' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, BlendSpaceXRegisterName) == 0x000198, "Member 'UGbxAction_Anim::BlendSpaceXRegisterName' has a wrong offset!");
static_assert(offsetof(UGbxAction_Anim, BlendSpaceYRegisterName) == 0x0001A0, "Member 'UGbxAction_Anim::BlendSpaceYRegisterName' has a wrong offset!");

// Class GbxGameSystemCore.PreviewComponent
// 0x00F8 (0x07E8 - 0x06F0)
#pragma pack(push, 0x1)
class alignas(0x08) UPreviewComponent : public UPrimitiveComponent
{
public:
	bool                                          bSpawnInPIE;                                       // 0x06F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewEnabled;                                   // 0x06F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F2[0x6];                                      // 0x06F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     PreviewActor;                                      // 0x06F8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPreviewState                          PreviewState;                                      // 0x0700(0x00D8)(Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x07D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D9[0x3];                                      // 0x07D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USkinnedMeshComponent>   SkinnedMeshComponent;                              // 0x07DC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E4[0x4];                                      // 0x07E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlueprintCompiled(class UBlueprint* BP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewComponent">();
	}
	static class UPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreviewComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPreviewComponent) == 0x000008, "Wrong alignment on UPreviewComponent");
static_assert(sizeof(UPreviewComponent) == 0x0007E8, "Wrong size on UPreviewComponent");
static_assert(offsetof(UPreviewComponent, bSpawnInPIE) == 0x0006F0, "Member 'UPreviewComponent::bSpawnInPIE' has a wrong offset!");
static_assert(offsetof(UPreviewComponent, bPreviewEnabled) == 0x0006F1, "Member 'UPreviewComponent::bPreviewEnabled' has a wrong offset!");
static_assert(offsetof(UPreviewComponent, PreviewActor) == 0x0006F8, "Member 'UPreviewComponent::PreviewActor' has a wrong offset!");
static_assert(offsetof(UPreviewComponent, PreviewState) == 0x000700, "Member 'UPreviewComponent::PreviewState' has a wrong offset!");
static_assert(offsetof(UPreviewComponent, bEnabled) == 0x0007D8, "Member 'UPreviewComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UPreviewComponent, SkinnedMeshComponent) == 0x0007DC, "Member 'UPreviewComponent::SkinnedMeshComponent' has a wrong offset!");

// Class GbxGameSystemCore.PropertyUtilsTestContext
// 0x0268 (0x0290 - 0x0028)
class UPropertyUtilsTestContext final : public UObject
{
public:
	float                                         FloatProp;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatPropStaticArray[0x3];                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatPropDynamicArray;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UPropertyUtilsTestContext*              ObjectProp;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPropertyUtilsTestContext*              ObjectPropStaticArray[0x3];                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPropertyUtilsTestContext*>      ObjectPropDynamicArray;                            // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPropertyUtilsTestStruct               StructProp;                                        // 0x0078(0x0078)(NativeAccessSpecifierPublic)
	struct FPropertyUtilsTestStruct               StructPropStaticArray[0x3];                        // 0x00F0(0x0078)(NativeAccessSpecifierPublic)
	TArray<struct FPropertyUtilsTestStruct>       StructPropDynamicArray;                            // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        DoubleProp;                                        // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Int8Prop;                                          // 0x0270(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UInt8Prop;                                         // 0x0271(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Int16Prop;                                         // 0x0272(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        UInt16Prop;                                        // 0x0274(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276[0x2];                                      // 0x0276(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Int32Prop;                                         // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UInt32Prop;                                        // 0x027C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Int64Prop;                                         // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        UInt64Prop;                                        // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyUtilsTestContext">();
	}
	static class UPropertyUtilsTestContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertyUtilsTestContext>();
	}
};
static_assert(alignof(UPropertyUtilsTestContext) == 0x000008, "Wrong alignment on UPropertyUtilsTestContext");
static_assert(sizeof(UPropertyUtilsTestContext) == 0x000290, "Wrong size on UPropertyUtilsTestContext");
static_assert(offsetof(UPropertyUtilsTestContext, FloatProp) == 0x000028, "Member 'UPropertyUtilsTestContext::FloatProp' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, FloatPropStaticArray) == 0x00002C, "Member 'UPropertyUtilsTestContext::FloatPropStaticArray' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, FloatPropDynamicArray) == 0x000038, "Member 'UPropertyUtilsTestContext::FloatPropDynamicArray' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, ObjectProp) == 0x000048, "Member 'UPropertyUtilsTestContext::ObjectProp' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, ObjectPropStaticArray) == 0x000050, "Member 'UPropertyUtilsTestContext::ObjectPropStaticArray' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, ObjectPropDynamicArray) == 0x000068, "Member 'UPropertyUtilsTestContext::ObjectPropDynamicArray' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, StructProp) == 0x000078, "Member 'UPropertyUtilsTestContext::StructProp' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, StructPropStaticArray) == 0x0000F0, "Member 'UPropertyUtilsTestContext::StructPropStaticArray' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, StructPropDynamicArray) == 0x000258, "Member 'UPropertyUtilsTestContext::StructPropDynamicArray' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, DoubleProp) == 0x000268, "Member 'UPropertyUtilsTestContext::DoubleProp' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, Int8Prop) == 0x000270, "Member 'UPropertyUtilsTestContext::Int8Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, UInt8Prop) == 0x000271, "Member 'UPropertyUtilsTestContext::UInt8Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, Int16Prop) == 0x000272, "Member 'UPropertyUtilsTestContext::Int16Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, UInt16Prop) == 0x000274, "Member 'UPropertyUtilsTestContext::UInt16Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, Int32Prop) == 0x000278, "Member 'UPropertyUtilsTestContext::Int32Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, UInt32Prop) == 0x00027C, "Member 'UPropertyUtilsTestContext::UInt32Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, Int64Prop) == 0x000280, "Member 'UPropertyUtilsTestContext::Int64Prop' has a wrong offset!");
static_assert(offsetof(UPropertyUtilsTestContext, UInt64Prop) == 0x000288, "Member 'UPropertyUtilsTestContext::UInt64Prop' has a wrong offset!");

// Class GbxGameSystemCore.StatusEffectData
// 0x0058 (0x0088 - 0x0030)
class UStatusEffectData : public UDataAsset
{
public:
	class UStatusEffectStackingStrategyData*      StackingStrategy;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAttributeEffect>               AttributeEffects;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bDoesDamageOverTime;                               // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageSource>              DamageSourceClass;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0060(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectData">();
	}
	static class UStatusEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectData>();
	}
};
static_assert(alignof(UStatusEffectData) == 0x000008, "Wrong alignment on UStatusEffectData");
static_assert(sizeof(UStatusEffectData) == 0x000088, "Wrong size on UStatusEffectData");
static_assert(offsetof(UStatusEffectData, StackingStrategy) == 0x000030, "Member 'UStatusEffectData::StackingStrategy' has a wrong offset!");
static_assert(offsetof(UStatusEffectData, AttributeEffects) == 0x000038, "Member 'UStatusEffectData::AttributeEffects' has a wrong offset!");
static_assert(offsetof(UStatusEffectData, bDoesDamageOverTime) == 0x000048, "Member 'UStatusEffectData::bDoesDamageOverTime' has a wrong offset!");
static_assert(offsetof(UStatusEffectData, DamageType) == 0x000050, "Member 'UStatusEffectData::DamageType' has a wrong offset!");
static_assert(offsetof(UStatusEffectData, DamageSourceClass) == 0x000058, "Member 'UStatusEffectData::DamageSourceClass' has a wrong offset!");
static_assert(offsetof(UStatusEffectData, GameplayTags) == 0x000060, "Member 'UStatusEffectData::GameplayTags' has a wrong offset!");

// Class GbxGameSystemCore.RadiusDamageReplicationManager
// 0x0018 (0x0470 - 0x0458)
class ARadiusDamageReplicationManager : public AActor
{
public:
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ProcessRadiusRequest(class AActor* ContextActor, TSubclassOf<class UDamageData> DamageData, TSubclassOf<class UGbxDamageType> DamageType, float Radius, const struct FVector_NetQuantize& Location, float Damage, class UExplosionData* ExplosionData, class UParticleSystem* DefaultParticles, class UWwiseEvent* DefaultAudioEvent, class UImpactData* DefaultImpactData, const struct FGbxSignificanceEvent& SignificanceEvent, float Force);
	void Multicast_StopRadiusEffect(class AActor* ContextActor, TSubclassOf<class UDamageData> DamageData, bool bStopAllForContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadiusDamageReplicationManager">();
	}
	static class ARadiusDamageReplicationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadiusDamageReplicationManager>();
	}
};
static_assert(alignof(ARadiusDamageReplicationManager) == 0x000008, "Wrong alignment on ARadiusDamageReplicationManager");
static_assert(sizeof(ARadiusDamageReplicationManager) == 0x000470, "Wrong size on ARadiusDamageReplicationManager");

// Class GbxGameSystemCore.TeamComponent
// 0x0040 (0x01B8 - 0x0178)
class UTeamComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeam*                                  Team;                                              // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeam*                                  TeamDefault;                                       // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x18];                                     // 0x0190(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSetTeamCollision;                                 // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreCollisionWithTeam;                          // 0x01A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInheritSourceTeamFromInstigator;                  // 0x01AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AB[0x5];                                      // 0x01AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTeamComponent*                         SourceTeamComponent;                               // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeTeam(class UTeam* NewTeam);
	void OnRep_bIgnoreCollisionWithTeam();
	void OnRep_Team(class UTeam* OldTeam);
	void SetCollidesWithTeam(bool bCollidesWithTeam);
	void SetSourceTeamComponent(class UTeamComponent* NewSourceTeamComponent);
	void SetTeam(class UTeam* NewTeam);
	void SetTeamCollision(bool bOn);
	void SetTeamToDefault();

	ETeamAttitude GetTeamAttitudeTowardsActor(const class AActor* Actor) const;
	ETeamAttitude GetTeamAttitudeTowardsTeam(const class UTeam* OtherTeam) const;
	ETeamCollisionChannel GetTeamCollisionChannel() const;
	bool IsFriendly(const class AActor* Actor) const;
	bool IsHostile(const class AActor* Actor) const;
	bool IsNeutral(const class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamComponent">();
	}
	static class UTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamComponent>();
	}
};
static_assert(alignof(UTeamComponent) == 0x000008, "Wrong alignment on UTeamComponent");
static_assert(sizeof(UTeamComponent) == 0x0001B8, "Wrong size on UTeamComponent");
static_assert(offsetof(UTeamComponent, Team) == 0x000180, "Member 'UTeamComponent::Team' has a wrong offset!");
static_assert(offsetof(UTeamComponent, TeamDefault) == 0x000188, "Member 'UTeamComponent::TeamDefault' has a wrong offset!");
static_assert(offsetof(UTeamComponent, bSetTeamCollision) == 0x0001A8, "Member 'UTeamComponent::bSetTeamCollision' has a wrong offset!");
static_assert(offsetof(UTeamComponent, bIgnoreCollisionWithTeam) == 0x0001A9, "Member 'UTeamComponent::bIgnoreCollisionWithTeam' has a wrong offset!");
static_assert(offsetof(UTeamComponent, bInheritSourceTeamFromInstigator) == 0x0001AA, "Member 'UTeamComponent::bInheritSourceTeamFromInstigator' has a wrong offset!");
static_assert(offsetof(UTeamComponent, SourceTeamComponent) == 0x0001B0, "Member 'UTeamComponent::SourceTeamComponent' has a wrong offset!");

// Class GbxGameSystemCore.GbxCharacter
// 0x04D0 (0x0D80 - 0x08B0)
class AGbxCharacter : public ACharacter
{
public:
	uint8                                         Pad_8B0[0x50];                                     // 0x08B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCharacterMovementComponent*         GbxCharacterMovement;                              // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetableComponent*                   TargetableComponent;                               // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageComponent*                       DamageComponent;                                   // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageCauserComponent*                 DamageCauserComponent;                             // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxActionComponent*                    GbxAction;                                         // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTagContainerComponent*         GameplayTagContainerComponent;                     // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicPhysicalAnimationComponent*     DynamicPhysicalAnimationComponent;                 // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetingComponent*                    TargetingComponent;                                // 0x0938(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxPerceptionComponent*                PerceptionComponent;                               // 0x0940(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFirstPersonComponent*                  FirstPersonComponent;                              // 0x0948(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_950[0x10];                                     // 0x0950(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandingData*                           LandingData;                                       // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImpactData*                            JumpedImpact;                                      // 0x0968(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayJumpAndLandImpactsOnAllFeet;                  // 0x0970(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_971[0x7];                                      // 0x0971(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            FootstepImpact;                                    // 0x0978(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImpactData*                            GenericHandImpact;                                 // 0x0980(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImpactData*                            LadderHandImpact;                                  // 0x0988(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           FootstepSockets;                                   // 0x0990(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           HandAccessoryTags;                                 // 0x09A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   LandingDataTriggeredDelegate;                      // 0x09B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class AGbxPlayerController*                   OwnerPlayerController;                             // 0x09C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAIController*                          OwnerAIController;                                 // 0x09C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGbxCharacter*                          PlayerMaster;                                      // 0x09D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGbxCharacter*>                  Pets;                                              // 0x09D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FMassSelection                         CharacterMass;                                     // 0x09E8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSpawnCostSelection                    SpawnCostSelection;                                // 0x0A00(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGbxSkeletalMeshComponent*              GbxMesh;                                           // 0x0A18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOrientEyeHeight;                                  // 0x0A20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A21[0x7];                                      // 0x0A21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ViewSocket;                                        // 0x0A28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ViewSocketComponent;                               // 0x0A30(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A38[0xB0];                                     // 0x0A38(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedPawnAttachState             ReplicatedPawnAttachState;                         // 0x0AE8(0x0010)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FReplicatedPawnAttachState             PawnAttachState;                                   // 0x0AF8(0x0010)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B08[0xA8];                                     // 0x0B08(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseAimHeight;                                     // 0x0BB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomBaseAimHeight;                           // 0x0BB4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB5[0x3];                                      // 0x0BB5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimHeightFromGround;                               // 0x0BB8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchedAimHeight;                                 // 0x0BBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCrouchedAimHeight;                       // 0x0BC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC1[0x3];                                      // 0x0BC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimEyeHeightPct;                                   // 0x0BC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimSocket;                                         // 0x0BC8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AimSocketComponent;                                // 0x0BD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD8[0x8];                                      // 0x0BD8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFacingController                      FacingController;                                  // 0x0BE0(0x0110)(Net, Transient, NativeAccessSpecifierPublic)
	uint8                                         ClientTurnDelta;                                   // 0x0CF0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF1[0x7];                                      // 0x0CF1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInputComponent>            InputComponentClass;                               // 0x0CF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFoleyAccessoryComponent*               GestaltFoleyAccessory;                             // 0x0D00(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFoleyMainComponent*                    CachedFoleyMainComponent;                          // 0x0D08(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x0D10(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   LevelSequencePlayerController;                     // 0x0D18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSavedCollision                        LevelSequenceCollisionState;                       // 0x0D20(0x0020)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGbxBoneSet*                            AnimGraphBoneSetFilter;                            // 0x0D40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimGraphBoneSet>              ActiveAnimGraphBoneSetFilterList;                  // 0x0D48(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UGbxBoneSet*                            SmartObjectBoneSetFilter;                          // 0x0D58(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxBoneSet*                            DefaultBoneSetFilter;                              // 0x0D60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxBoneSet*                            ActionBoneSetFilter;                               // 0x0D68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseAIWhileFalling;                              // 0x0D70(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D71[0xF];                                      // 0x0D71(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachCharacterToActor(class AActor* ParentActor, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	void AttachCharacterToComponent(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	void CauseEveryoneToForgetMe();
	void ClientRotateCharacterTo(const struct FRotator& TargetRotation, float Duration, EEasingFunc Easing);
	void DetachCharacter(EDetachmentRule LocationRule);
	void NetMulticast_PlayJumped();
	void NetMulticast_PlayLanded(const struct FHitResult& Hit, float ImpactSpeed, bool bLandFromJump, class ULandingData* LandingDataOverride);
	void NetMulticast_TriggerHitReactionSound(const class UCharacterSoundTag* Tag);
	void OnLandingDataTriggered(const struct FLandingInfo& LandingInfo, int32 Index_0);
	void OnRep_ReplicatedPawnAttachState();
	void ReceiveOwnerPlayerControllerChanged(class AGbxPlayerController* NewPlayerControllerOwner);
	void RotateCharacterTo(const struct FRotator& TargetRotation, float Duration, EEasingFunc Easing);
	void SetCharacterName(const class FText& NewCharacterName);
	void SetCharacterNameFromString(const class FString& NewCharacterName);
	void SetCharacterUIName(const class UGbxUIName* NewCharacterUIName);
	void SetPlayerMaster(class AGbxCharacter* NewPlayerMaster);

	class UFirstPersonComponent* FindFirstPersonComponent() const;
	struct FRotator GetAimOffset() const;
	struct FVector GetAimVectorStartLocation() const;
	void GetAvailableSocketNames(TArray<class FName>* Array) const;
	class UBlackboardData* GetBlackboardAsset() const;
	class UBlackboardComponent* GetBlackboardComponent() const;
	class UFirstPersonComponent* GetFirstPersonComponent() const;
	class USkeletalMeshComponent* GetFirstPersonMesh() const;
	float GetLookAt(struct FVector* HeadLocation, struct FVector* EyeLocation, float* HeadWeight) const;
	struct FVector GetLookAtLocation(float* OutWeight) const;
	class AActor* GetPawnAttachActor() const;
	class UPawnAttachSlotComponent* GetPawnAttachComponent() const;
	EPawnAttachStatus GetPawnAttachStatus() const;
	class UGbxPerceptionComponent* GetPerceptionComponent() const;
	class UTargetableComponent* GetTargetableComponent() const;
	class UTargetingComponent* GetTargetingComponent() const;
	class UTeam* GetTeam() const;
	class UTeamComponent* GetTeamComponent() const;
	bool IsZoomed() const;
	void SetTeam(class UTeam* Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCharacter">();
	}
	static class AGbxCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxCharacter>();
	}
};
static_assert(alignof(AGbxCharacter) == 0x000010, "Wrong alignment on AGbxCharacter");
static_assert(sizeof(AGbxCharacter) == 0x000D80, "Wrong size on AGbxCharacter");
static_assert(offsetof(AGbxCharacter, GbxCharacterMovement) == 0x000900, "Member 'AGbxCharacter::GbxCharacterMovement' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, TargetableComponent) == 0x000908, "Member 'AGbxCharacter::TargetableComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, DamageComponent) == 0x000910, "Member 'AGbxCharacter::DamageComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, DamageCauserComponent) == 0x000918, "Member 'AGbxCharacter::DamageCauserComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, GbxAction) == 0x000920, "Member 'AGbxCharacter::GbxAction' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, GameplayTagContainerComponent) == 0x000928, "Member 'AGbxCharacter::GameplayTagContainerComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, DynamicPhysicalAnimationComponent) == 0x000930, "Member 'AGbxCharacter::DynamicPhysicalAnimationComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, TargetingComponent) == 0x000938, "Member 'AGbxCharacter::TargetingComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, PerceptionComponent) == 0x000940, "Member 'AGbxCharacter::PerceptionComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, FirstPersonComponent) == 0x000948, "Member 'AGbxCharacter::FirstPersonComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, LandingData) == 0x000960, "Member 'AGbxCharacter::LandingData' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, JumpedImpact) == 0x000968, "Member 'AGbxCharacter::JumpedImpact' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, bPlayJumpAndLandImpactsOnAllFeet) == 0x000970, "Member 'AGbxCharacter::bPlayJumpAndLandImpactsOnAllFeet' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, FootstepImpact) == 0x000978, "Member 'AGbxCharacter::FootstepImpact' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, GenericHandImpact) == 0x000980, "Member 'AGbxCharacter::GenericHandImpact' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, LadderHandImpact) == 0x000988, "Member 'AGbxCharacter::LadderHandImpact' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, FootstepSockets) == 0x000990, "Member 'AGbxCharacter::FootstepSockets' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, HandAccessoryTags) == 0x0009A0, "Member 'AGbxCharacter::HandAccessoryTags' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, LandingDataTriggeredDelegate) == 0x0009B0, "Member 'AGbxCharacter::LandingDataTriggeredDelegate' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, OwnerPlayerController) == 0x0009C0, "Member 'AGbxCharacter::OwnerPlayerController' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, OwnerAIController) == 0x0009C8, "Member 'AGbxCharacter::OwnerAIController' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, PlayerMaster) == 0x0009D0, "Member 'AGbxCharacter::PlayerMaster' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, Pets) == 0x0009D8, "Member 'AGbxCharacter::Pets' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, CharacterMass) == 0x0009E8, "Member 'AGbxCharacter::CharacterMass' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, SpawnCostSelection) == 0x000A00, "Member 'AGbxCharacter::SpawnCostSelection' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, GbxMesh) == 0x000A18, "Member 'AGbxCharacter::GbxMesh' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, bOrientEyeHeight) == 0x000A20, "Member 'AGbxCharacter::bOrientEyeHeight' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, ViewSocket) == 0x000A28, "Member 'AGbxCharacter::ViewSocket' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, ViewSocketComponent) == 0x000A30, "Member 'AGbxCharacter::ViewSocketComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, ReplicatedPawnAttachState) == 0x000AE8, "Member 'AGbxCharacter::ReplicatedPawnAttachState' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, PawnAttachState) == 0x000AF8, "Member 'AGbxCharacter::PawnAttachState' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, BaseAimHeight) == 0x000BB0, "Member 'AGbxCharacter::BaseAimHeight' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, bUseCustomBaseAimHeight) == 0x000BB4, "Member 'AGbxCharacter::bUseCustomBaseAimHeight' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, AimHeightFromGround) == 0x000BB8, "Member 'AGbxCharacter::AimHeightFromGround' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, CrouchedAimHeight) == 0x000BBC, "Member 'AGbxCharacter::CrouchedAimHeight' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, bUseCustomCrouchedAimHeight) == 0x000BC0, "Member 'AGbxCharacter::bUseCustomCrouchedAimHeight' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, AimEyeHeightPct) == 0x000BC4, "Member 'AGbxCharacter::AimEyeHeightPct' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, AimSocket) == 0x000BC8, "Member 'AGbxCharacter::AimSocket' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, AimSocketComponent) == 0x000BD0, "Member 'AGbxCharacter::AimSocketComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, FacingController) == 0x000BE0, "Member 'AGbxCharacter::FacingController' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, ClientTurnDelta) == 0x000CF0, "Member 'AGbxCharacter::ClientTurnDelta' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, InputComponentClass) == 0x000CF8, "Member 'AGbxCharacter::InputComponentClass' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, GestaltFoleyAccessory) == 0x000D00, "Member 'AGbxCharacter::GestaltFoleyAccessory' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, CachedFoleyMainComponent) == 0x000D08, "Member 'AGbxCharacter::CachedFoleyMainComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, GameplayTasksComponent) == 0x000D10, "Member 'AGbxCharacter::GameplayTasksComponent' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, LevelSequencePlayerController) == 0x000D18, "Member 'AGbxCharacter::LevelSequencePlayerController' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, LevelSequenceCollisionState) == 0x000D20, "Member 'AGbxCharacter::LevelSequenceCollisionState' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, AnimGraphBoneSetFilter) == 0x000D40, "Member 'AGbxCharacter::AnimGraphBoneSetFilter' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, ActiveAnimGraphBoneSetFilterList) == 0x000D48, "Member 'AGbxCharacter::ActiveAnimGraphBoneSetFilterList' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, SmartObjectBoneSetFilter) == 0x000D58, "Member 'AGbxCharacter::SmartObjectBoneSetFilter' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, DefaultBoneSetFilter) == 0x000D60, "Member 'AGbxCharacter::DefaultBoneSetFilter' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, ActionBoneSetFilter) == 0x000D68, "Member 'AGbxCharacter::ActionBoneSetFilter' has a wrong offset!");
static_assert(offsetof(AGbxCharacter, bPauseAIWhileFalling) == 0x000D70, "Member 'AGbxCharacter::bPauseAIWhileFalling' has a wrong offset!");

// Class GbxGameSystemCore.BalanceStateComponent
// 0x0060 (0x01D8 - 0x0178)
class UBalanceStateComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    BalanceTableRowHandle;                             // 0x0180(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    InheritedBalanceTableRowHandle;                    // 0x0190(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x4];                                      // 0x01A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GameStage;                                         // 0x01A4(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ExperienceLevel;                                   // 0x01A8(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnLevelChanged;                                    // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoRefreshInheritedBalanceWhenSourceChangesLevel; // 0x01D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInheritedBalanceSourceLevelChanged(class UBalanceStateComponent* InheritedBalanceStateSource, const int32 OldExperienceLevel, const int32 NewExperienceLevel);
	void OnRep_ExperienceLevel(int32 OldExperienceLevel);
	void SetExperienceLevel(int32 NewExperienceLevel);
	void SetGameStage(int32 NewGameStage);

	struct FDataTableRowHandle GetBalanceTableRow() const;
	int32 GetExperienceLevel() const;
	int32 GetGameStage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BalanceStateComponent">();
	}
	static class UBalanceStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBalanceStateComponent>();
	}
};
static_assert(alignof(UBalanceStateComponent) == 0x000008, "Wrong alignment on UBalanceStateComponent");
static_assert(sizeof(UBalanceStateComponent) == 0x0001D8, "Wrong size on UBalanceStateComponent");
static_assert(offsetof(UBalanceStateComponent, BalanceTableRowHandle) == 0x000180, "Member 'UBalanceStateComponent::BalanceTableRowHandle' has a wrong offset!");
static_assert(offsetof(UBalanceStateComponent, InheritedBalanceTableRowHandle) == 0x000190, "Member 'UBalanceStateComponent::InheritedBalanceTableRowHandle' has a wrong offset!");
static_assert(offsetof(UBalanceStateComponent, GameStage) == 0x0001A4, "Member 'UBalanceStateComponent::GameStage' has a wrong offset!");
static_assert(offsetof(UBalanceStateComponent, ExperienceLevel) == 0x0001A8, "Member 'UBalanceStateComponent::ExperienceLevel' has a wrong offset!");
static_assert(offsetof(UBalanceStateComponent, OnLevelChanged) == 0x0001B0, "Member 'UBalanceStateComponent::OnLevelChanged' has a wrong offset!");
static_assert(offsetof(UBalanceStateComponent, bAutoRefreshInheritedBalanceWhenSourceChangesLevel) == 0x0001D0, "Member 'UBalanceStateComponent::bAutoRefreshInheritedBalanceWhenSourceChangesLevel' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolData
// 0x0080 (0x00B0 - 0x0030)
class UGameResourcePoolData final : public UGbxDataAsset
{
public:
	class UGameResourceData*                      Resource;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMinValue;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           BaseMaxValue;                                      // 0x0040(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartingValue;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartWithMinValue;                                 // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartWithMaxValue;                                 // 0x007D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateCurrentValueOnExtremaChange;                // 0x007E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F[0x1];                                       // 0x007F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumReservedValue;                              // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckFilledAgainstOldValues;                      // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseConsumptionRate;                               // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseActiveRegenerationRate;                        // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasePassiveRegenerationRate;                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasePassivePercentRegenerationRate;                // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasePassiveMissingPercentRegenerationRate;         // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseOnIdleRegenerationRate;                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseOnIdleRegenerationDelay;                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseOnDepletedRegenerationDelay;                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecentImpulseTimer;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyReplicateToOwner;                             // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameResourcePoolReplicationType              ReplicationType;                                   // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolData">();
	}
	static class UGameResourcePoolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolData>();
	}
};
static_assert(alignof(UGameResourcePoolData) == 0x000008, "Wrong alignment on UGameResourcePoolData");
static_assert(sizeof(UGameResourcePoolData) == 0x0000B0, "Wrong size on UGameResourcePoolData");
static_assert(offsetof(UGameResourcePoolData, Resource) == 0x000030, "Member 'UGameResourcePoolData::Resource' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseMinValue) == 0x000038, "Member 'UGameResourcePoolData::BaseMinValue' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseMaxValue) == 0x000040, "Member 'UGameResourcePoolData::BaseMaxValue' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, StartingValue) == 0x000078, "Member 'UGameResourcePoolData::StartingValue' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, StartWithMinValue) == 0x00007C, "Member 'UGameResourcePoolData::StartWithMinValue' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, StartWithMaxValue) == 0x00007D, "Member 'UGameResourcePoolData::StartWithMaxValue' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, bUpdateCurrentValueOnExtremaChange) == 0x00007E, "Member 'UGameResourcePoolData::bUpdateCurrentValueOnExtremaChange' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, MinimumReservedValue) == 0x000080, "Member 'UGameResourcePoolData::MinimumReservedValue' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, bCheckFilledAgainstOldValues) == 0x000084, "Member 'UGameResourcePoolData::bCheckFilledAgainstOldValues' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseConsumptionRate) == 0x000088, "Member 'UGameResourcePoolData::BaseConsumptionRate' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseActiveRegenerationRate) == 0x00008C, "Member 'UGameResourcePoolData::BaseActiveRegenerationRate' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BasePassiveRegenerationRate) == 0x000090, "Member 'UGameResourcePoolData::BasePassiveRegenerationRate' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BasePassivePercentRegenerationRate) == 0x000094, "Member 'UGameResourcePoolData::BasePassivePercentRegenerationRate' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BasePassiveMissingPercentRegenerationRate) == 0x000098, "Member 'UGameResourcePoolData::BasePassiveMissingPercentRegenerationRate' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseOnIdleRegenerationRate) == 0x00009C, "Member 'UGameResourcePoolData::BaseOnIdleRegenerationRate' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseOnIdleRegenerationDelay) == 0x0000A0, "Member 'UGameResourcePoolData::BaseOnIdleRegenerationDelay' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, BaseOnDepletedRegenerationDelay) == 0x0000A4, "Member 'UGameResourcePoolData::BaseOnDepletedRegenerationDelay' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, RecentImpulseTimer) == 0x0000A8, "Member 'UGameResourcePoolData::RecentImpulseTimer' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, bOnlyReplicateToOwner) == 0x0000AC, "Member 'UGameResourcePoolData::bOnlyReplicateToOwner' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolData, ReplicationType) == 0x0000AD, "Member 'UGameResourcePoolData::ReplicationType' has a wrong offset!");

// Class GbxGameSystemCore.GbxChildActorComponent
// 0x0020 (0x0320 - 0x0300)
class UGbxChildActorComponent : public UChildActorComponent
{
public:
	uint8                                         bAutoSpawnActor : 1;                               // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoDestroyActor : 1;                             // 0x0300(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyExistingChildActorOnSpawn : 1;             // 0x0300(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDeferChildActorClassUpdate : 1;                   // 0x0300(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClearChildActorReferenceToMeWhenChildActorIsDetached : 1; // 0x0300(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnChildActorSpawned;                               // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DespawnChildActor();
	void SpawnChildActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxChildActorComponent">();
	}
	static class UGbxChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxChildActorComponent>();
	}
};
static_assert(alignof(UGbxChildActorComponent) == 0x000008, "Wrong alignment on UGbxChildActorComponent");
static_assert(sizeof(UGbxChildActorComponent) == 0x000320, "Wrong size on UGbxChildActorComponent");
static_assert(offsetof(UGbxChildActorComponent, OnChildActorSpawned) == 0x000308, "Member 'UGbxChildActorComponent::OnChildActorSpawned' has a wrong offset!");

// Class GbxGameSystemCore.GbxCustomizationComponent
// 0x0228 (0x03A0 - 0x0178)
class UGbxCustomizationComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomizationColorEntry>       ColorCustomizationParameters;                      // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationLinkedParameterEntry> SharedLinkedParameters;                            // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationLinkedParameterEntry> LinkedParameters;                                  // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EGbxCustomizationComponentInitSourceType      CustomizationSourceInitType;                       // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomizationTextureInheritanceSettings TextureInheritanceSettings;                        // 0x01B8(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FGbxCustomizationContainer             CustomizationList;                                 // 0x01F0(0x00D8)(Net, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationColorApplication> CustomColorSelections;                             // 0x02C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x48];                                     // 0x02D8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCustomizationApplied;                            // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCustomizationRemoved;                            // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGbxCustomizationComponent*             LinkedCustomizationSource;                         // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UMeshComponent*, struct FMaterialArray> CustomMaterials;                                   // 0x0348(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseCustomMaterials;                               // 0x0398(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyFromCustomization(class UGbxCustomizationComponent* SourceComponent);
	bool GetDefaultCustomColor(int32 SelectionIndex, struct FLinearColor* DefaultColor);
	bool GetDefaultCustomSplitColor(int32 SelectionIndex, struct FLinearColor* DefaultSplitColor);
	void LinkedCustomizationApplied(class UGbxCustomizationData* Customization);
	void LinkedCustomizationRemoved(class UGbxCustomizationData* Customization);
	void LinkToCustomization(class UGbxCustomizationComponent* SourceComponent);
	void OnRep_CustomColorSelections();
	bool RemoveCustomization(class UGbxCustomizationData* Customization);
	void ServerApplyCustomColor(int32 CustomColorIndex, const struct FVector& InAppliedColor, const struct FVector& InSplitColor, bool InUseDefaultColor, bool InUseDefaultSplitColor);
	void ServerApplyCustomizationData(class UGbxCustomizationData* CustomizationToApply, int32 OptionalCustomizationId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCustomizationComponent">();
	}
	static class UGbxCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCustomizationComponent>();
	}
};
static_assert(alignof(UGbxCustomizationComponent) == 0x000008, "Wrong alignment on UGbxCustomizationComponent");
static_assert(sizeof(UGbxCustomizationComponent) == 0x0003A0, "Wrong size on UGbxCustomizationComponent");
static_assert(offsetof(UGbxCustomizationComponent, ColorCustomizationParameters) == 0x000180, "Member 'UGbxCustomizationComponent::ColorCustomizationParameters' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, SharedLinkedParameters) == 0x000190, "Member 'UGbxCustomizationComponent::SharedLinkedParameters' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, LinkedParameters) == 0x0001A0, "Member 'UGbxCustomizationComponent::LinkedParameters' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, CustomizationSourceInitType) == 0x0001B0, "Member 'UGbxCustomizationComponent::CustomizationSourceInitType' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, TextureInheritanceSettings) == 0x0001B8, "Member 'UGbxCustomizationComponent::TextureInheritanceSettings' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, CustomizationList) == 0x0001F0, "Member 'UGbxCustomizationComponent::CustomizationList' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, CustomColorSelections) == 0x0002C8, "Member 'UGbxCustomizationComponent::CustomColorSelections' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, OnCustomizationApplied) == 0x000320, "Member 'UGbxCustomizationComponent::OnCustomizationApplied' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, OnCustomizationRemoved) == 0x000330, "Member 'UGbxCustomizationComponent::OnCustomizationRemoved' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, LinkedCustomizationSource) == 0x000340, "Member 'UGbxCustomizationComponent::LinkedCustomizationSource' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, CustomMaterials) == 0x000348, "Member 'UGbxCustomizationComponent::CustomMaterials' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationComponent, bUseCustomMaterials) == 0x000398, "Member 'UGbxCustomizationComponent::bUseCustomMaterials' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_PhysicalAnim
// 0x0028 (0x01D0 - 0x01A8)
class UGbxAction_PhysicalAnim : public UGbxAction_Anim
{
public:
	EPhysicalAnimationRootMotionControl           RootMotionControl;                                 // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxPhysicalActionMovementLockMode            MovementLockMode;                                  // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxPhysicalActionDynamicBoneActivationMode   DynamicBoneActivationMode;                         // 0x01AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AB[0x1];                                      // 0x01AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneFatigueParams                     FatigueParams;                                     // 0x01AC(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EGbxPhysicalActionBeginCondition              BeginCondition;                                    // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PhysicalBeginConditionFlags;                       // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PhysicalEndConditionFlags;                         // 0x01C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxPhysicalActionEndCondition                PhysicalEndCondition;                              // 0x01C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomForceMultiplier;                             // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardForceMultiplier;                             // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceAppliedAtLocation;                           // 0x01CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidHitForce;                                 // 0x01CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE[0x2];                                      // 0x01CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_FixupDynamicToKinematicIssues(float AngularThreshold) const;
	EGbxPhysicalActionDynamicBodyState K2_GetDynamicBodyState(float AngularThreshold) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_PhysicalAnim">();
	}
	static class UGbxAction_PhysicalAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_PhysicalAnim>();
	}
};
static_assert(alignof(UGbxAction_PhysicalAnim) == 0x000008, "Wrong alignment on UGbxAction_PhysicalAnim");
static_assert(sizeof(UGbxAction_PhysicalAnim) == 0x0001D0, "Wrong size on UGbxAction_PhysicalAnim");
static_assert(offsetof(UGbxAction_PhysicalAnim, RootMotionControl) == 0x0001A8, "Member 'UGbxAction_PhysicalAnim::RootMotionControl' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, MovementLockMode) == 0x0001A9, "Member 'UGbxAction_PhysicalAnim::MovementLockMode' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, DynamicBoneActivationMode) == 0x0001AA, "Member 'UGbxAction_PhysicalAnim::DynamicBoneActivationMode' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, FatigueParams) == 0x0001AC, "Member 'UGbxAction_PhysicalAnim::FatigueParams' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, BeginCondition) == 0x0001C0, "Member 'UGbxAction_PhysicalAnim::BeginCondition' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, PhysicalBeginConditionFlags) == 0x0001C1, "Member 'UGbxAction_PhysicalAnim::PhysicalBeginConditionFlags' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, PhysicalEndConditionFlags) == 0x0001C2, "Member 'UGbxAction_PhysicalAnim::PhysicalEndConditionFlags' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, PhysicalEndCondition) == 0x0001C3, "Member 'UGbxAction_PhysicalAnim::PhysicalEndCondition' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, CustomForceMultiplier) == 0x0001C4, "Member 'UGbxAction_PhysicalAnim::CustomForceMultiplier' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, UpwardForceMultiplier) == 0x0001C8, "Member 'UGbxAction_PhysicalAnim::UpwardForceMultiplier' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, bForceAppliedAtLocation) == 0x0001CC, "Member 'UGbxAction_PhysicalAnim::bForceAppliedAtLocation' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalAnim, bHasValidHitForce) == 0x0001CD, "Member 'UGbxAction_PhysicalAnim::bHasValidHitForce' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_PhysicalDeath
// 0x0020 (0x01F0 - 0x01D0)
class UGbxAction_PhysicalDeath : public UGbxAction_PhysicalAnim
{
public:
	float                                         PhysicalAnimationDelayTime;                        // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapPhysicalAnimationDelayToAnimationDuration;     // 0x01D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PrematurePhysicalAnimationIgnoreBodyNames;         // 0x01D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowPrematurePhysicalAnimation;                  // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTearOffOnDeath;                                   // 0x01E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA[0x2];                                      // 0x01EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRagdollTime;                                    // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_PhysicalDeath">();
	}
	static class UGbxAction_PhysicalDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_PhysicalDeath>();
	}
};
static_assert(alignof(UGbxAction_PhysicalDeath) == 0x000008, "Wrong alignment on UGbxAction_PhysicalDeath");
static_assert(sizeof(UGbxAction_PhysicalDeath) == 0x0001F0, "Wrong size on UGbxAction_PhysicalDeath");
static_assert(offsetof(UGbxAction_PhysicalDeath, PhysicalAnimationDelayTime) == 0x0001D0, "Member 'UGbxAction_PhysicalDeath::PhysicalAnimationDelayTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalDeath, bCapPhysicalAnimationDelayToAnimationDuration) == 0x0001D4, "Member 'UGbxAction_PhysicalDeath::bCapPhysicalAnimationDelayToAnimationDuration' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalDeath, PrematurePhysicalAnimationIgnoreBodyNames) == 0x0001D8, "Member 'UGbxAction_PhysicalDeath::PrematurePhysicalAnimationIgnoreBodyNames' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalDeath, bAllowPrematurePhysicalAnimation) == 0x0001E8, "Member 'UGbxAction_PhysicalDeath::bAllowPrematurePhysicalAnimation' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalDeath, bTearOffOnDeath) == 0x0001E9, "Member 'UGbxAction_PhysicalDeath::bTearOffOnDeath' has a wrong offset!");
static_assert(offsetof(UGbxAction_PhysicalDeath, MaxRagdollTime) == 0x0001EC, "Member 'UGbxAction_PhysicalDeath::MaxRagdollTime' has a wrong offset!");

// Class GbxGameSystemCore.AttributeContextResolver
// 0x0028 (0x0050 - 0x0028)
class UAttributeContextResolver : public UObject
{
public:
	TSoftClassPtr<class UClass>                   ComponentTypeToFurtherResolveTo;                   // 0x0028(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class UObject*> GetContextForAttribute(const class UGbxAttributeData* Attribute, class UObject* ContextSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeContextResolver">();
	}
	static class UAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeContextResolver>();
	}
};
static_assert(alignof(UAttributeContextResolver) == 0x000008, "Wrong alignment on UAttributeContextResolver");
static_assert(sizeof(UAttributeContextResolver) == 0x000050, "Wrong size on UAttributeContextResolver");
static_assert(offsetof(UAttributeContextResolver, ComponentTypeToFurtherResolveTo) == 0x000028, "Member 'UAttributeContextResolver::ComponentTypeToFurtherResolveTo' has a wrong offset!");

// Class GbxGameSystemCore.CharacterAttributeContextResolver
// 0x0000 (0x0050 - 0x0050)
class UCharacterAttributeContextResolver : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAttributeContextResolver">();
	}
	static class UCharacterAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAttributeContextResolver>();
	}
};
static_assert(alignof(UCharacterAttributeContextResolver) == 0x000008, "Wrong alignment on UCharacterAttributeContextResolver");
static_assert(sizeof(UCharacterAttributeContextResolver) == 0x000050, "Wrong size on UCharacterAttributeContextResolver");

// Class GbxGameSystemCore.ChallengeObserverInterface
// 0x0000 (0x0028 - 0x0028)
class IChallengeObserverInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeObserverInterface">();
	}
	static class IChallengeObserverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengeObserverInterface>();
	}
};
static_assert(alignof(IChallengeObserverInterface) == 0x000008, "Wrong alignment on IChallengeObserverInterface");
static_assert(sizeof(IChallengeObserverInterface) == 0x000028, "Wrong size on IChallengeObserverInterface");

// Class GbxGameSystemCore.AIDataProvider_AttributeInitializer
// 0x0018 (0x0040 - 0x0028)
class UAIDataProvider_AttributeInitializer final : public UAIDataProvider
{
public:
	TSubclassOf<class UAttributeInitializer>      AttributeInitializer;                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_AttributeInitializer">();
	}
	static class UAIDataProvider_AttributeInitializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_AttributeInitializer>();
	}
};
static_assert(alignof(UAIDataProvider_AttributeInitializer) == 0x000008, "Wrong alignment on UAIDataProvider_AttributeInitializer");
static_assert(sizeof(UAIDataProvider_AttributeInitializer) == 0x000040, "Wrong size on UAIDataProvider_AttributeInitializer");
static_assert(offsetof(UAIDataProvider_AttributeInitializer, AttributeInitializer) == 0x000028, "Member 'UAIDataProvider_AttributeInitializer::AttributeInitializer' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeInitializer, FloatValue) == 0x000030, "Member 'UAIDataProvider_AttributeInitializer::FloatValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeInitializer, IntValue) == 0x000034, "Member 'UAIDataProvider_AttributeInitializer::IntValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeInitializer, BoolValue) == 0x000038, "Member 'UAIDataProvider_AttributeInitializer::BoolValue' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_PawnAttachSlotTransition
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PawnAttachSlotTransition : public UAnimNotify
{
public:
	uint8                                         bTriggerOnFirstPersonMesh : 1;                     // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDetach : 1;                                       // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttach : 1;                                       // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PawnAttachSlotTransition">();
	}
	static class UAnimNotify_PawnAttachSlotTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PawnAttachSlotTransition>();
	}
};
static_assert(alignof(UAnimNotify_PawnAttachSlotTransition) == 0x000008, "Wrong alignment on UAnimNotify_PawnAttachSlotTransition");
static_assert(sizeof(UAnimNotify_PawnAttachSlotTransition) == 0x000040, "Wrong size on UAnimNotify_PawnAttachSlotTransition");

// Class GbxGameSystemCore.SenseConfigProviderInterface
// 0x0000 (0x0028 - 0x0028)
class ISenseConfigProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SenseConfigProviderInterface">();
	}
	static class ISenseConfigProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISenseConfigProviderInterface>();
	}
};
static_assert(alignof(ISenseConfigProviderInterface) == 0x000008, "Wrong alignment on ISenseConfigProviderInterface");
static_assert(sizeof(ISenseConfigProviderInterface) == 0x000028, "Wrong size on ISenseConfigProviderInterface");

// Class GbxGameSystemCore.SaveGameChannel
// 0x0030 (0x0098 - 0x0068)
class USaveGameChannel : public UChannel
{
public:
	TScriptInterface<class ISaveGameActorInterface> SaveGameActor;                                     // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameChannel">();
	}
	static class USaveGameChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameChannel>();
	}
};
static_assert(alignof(USaveGameChannel) == 0x000008, "Wrong alignment on USaveGameChannel");
static_assert(sizeof(USaveGameChannel) == 0x000098, "Wrong size on USaveGameChannel");
static_assert(offsetof(USaveGameChannel, SaveGameActor) == 0x000068, "Member 'USaveGameChannel::SaveGameActor' has a wrong offset!");

// Class GbxGameSystemCore.AttributeEffectMutatorData
// 0x0000 (0x0030 - 0x0030)
class UAttributeEffectMutatorData : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeEffectMutatorData">();
	}
	static class UAttributeEffectMutatorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeEffectMutatorData>();
	}
};
static_assert(alignof(UAttributeEffectMutatorData) == 0x000008, "Wrong alignment on UAttributeEffectMutatorData");
static_assert(sizeof(UAttributeEffectMutatorData) == 0x000030, "Wrong size on UAttributeEffectMutatorData");

// Class GbxGameSystemCore.Challenge
// 0x00F0 (0x0118 - 0x0028)
class UChallenge : public UObject
{
public:
	class UChallengesComponent*                   RegisteredOwner;                                   // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UChallenge>>         ParentChallenges;                                  // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   ChallengeName;                                     // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CompletedDescription;                              // 0x0070(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShared;                                           // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatable;                                       // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideInUI;                                         // 0x008A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowActivationUI;                                 // 0x008B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowProgressUI;                                   // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCompletionUI;                                 // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAsUndiscoveredUntilProgressed;                // 0x008E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F[0x1];                                       // 0x008F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AssociatedMapName;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChallengeType                                ChallengeType;                                     // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatChallengeTest>             StatChallengeTests;                                // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCompleteIfGoalValueReached;                       // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetProgressWhenGoalValueReached;                // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChallengeGoalValue>            ProgressGoalInfo;                                  // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ProgressGoalValues;                                // 0x00C8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	class UChallengeCategoryData*                 ChallengeCategoryData;                             // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitiallyActive;                                  // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideFromCounts;                                   // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UChallenge>                 PrerequisiteChallenge;                             // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssociatedCompletionAchievementId;                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssociatedProgressAchievementId;                   // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProfileChallenge;                                 // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UChallenge>>         SubChallenges;                                     // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          CompletedBySubChallenges;                          // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivateIfSubChallengesComplete;                   // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncrementProgressViaSubChallenges;                // 0x0112(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_113[0x5];                                      // 0x0113(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateChallenge();
	void CompletedChallenge(const class AGbxPlayerController* CompletedPlayer);
	bool CompletedConditional();
	void IncrementChallengeProgressByValue(int32 Value);
	void OnChallengeActivated();
	void OnInitChallengeInstance(class UChallengesComponent* OwningChallenges, class AGbxCharacter* AssociatedCharacter);
	void OnLevelActorRegistered(class UChallengeLevelActorComponent* RegisteredLevelActor);
	void PlayerEnterChallengeArea(class UChallengeLevelActorComponent* LevelActorComponent);
	void PlayerExitChallengeArea(class UChallengeLevelActorComponent* LevelActorComponent);
	bool TestForCompleted(const class AGbxPlayerController* PlayerToTest, const class UObject* OtherObject, const TArray<class FString>& EnumTag);

	void CompleteChallenge() const;
	void GetChallengeCompleteInfo(int32* NumCompleted, int32* NumChallenges) const;
	int32 GetChallengeProgress() const;
	int32 GetChallengeProgressGoalValue() const;
	void GetLevelActorComponents(TArray<class UChallengeLevelActorComponent*>* LevelActorList) const;
	void IncrementChallengeProgress() const;
	bool IsChallengeActive() const;
	bool IsChallengeComplete() const;
	void SetChallengeProgress(int32 NewProgress) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge">();
	}
	static class UChallenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallenge>();
	}
};
static_assert(alignof(UChallenge) == 0x000008, "Wrong alignment on UChallenge");
static_assert(sizeof(UChallenge) == 0x000118, "Wrong size on UChallenge");
static_assert(offsetof(UChallenge, RegisteredOwner) == 0x000028, "Member 'UChallenge::RegisteredOwner' has a wrong offset!");
static_assert(offsetof(UChallenge, ParentChallenges) == 0x000030, "Member 'UChallenge::ParentChallenges' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeName) == 0x000040, "Member 'UChallenge::ChallengeName' has a wrong offset!");
static_assert(offsetof(UChallenge, Description) == 0x000058, "Member 'UChallenge::Description' has a wrong offset!");
static_assert(offsetof(UChallenge, CompletedDescription) == 0x000070, "Member 'UChallenge::CompletedDescription' has a wrong offset!");
static_assert(offsetof(UChallenge, bShared) == 0x000088, "Member 'UChallenge::bShared' has a wrong offset!");
static_assert(offsetof(UChallenge, bRepeatable) == 0x000089, "Member 'UChallenge::bRepeatable' has a wrong offset!");
static_assert(offsetof(UChallenge, bHideInUI) == 0x00008A, "Member 'UChallenge::bHideInUI' has a wrong offset!");
static_assert(offsetof(UChallenge, bShowActivationUI) == 0x00008B, "Member 'UChallenge::bShowActivationUI' has a wrong offset!");
static_assert(offsetof(UChallenge, bShowProgressUI) == 0x00008C, "Member 'UChallenge::bShowProgressUI' has a wrong offset!");
static_assert(offsetof(UChallenge, bShowCompletionUI) == 0x00008D, "Member 'UChallenge::bShowCompletionUI' has a wrong offset!");
static_assert(offsetof(UChallenge, bShowAsUndiscoveredUntilProgressed) == 0x00008E, "Member 'UChallenge::bShowAsUndiscoveredUntilProgressed' has a wrong offset!");
static_assert(offsetof(UChallenge, AssociatedMapName) == 0x000090, "Member 'UChallenge::AssociatedMapName' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeType) == 0x000098, "Member 'UChallenge::ChallengeType' has a wrong offset!");
static_assert(offsetof(UChallenge, StatChallengeTests) == 0x0000A0, "Member 'UChallenge::StatChallengeTests' has a wrong offset!");
static_assert(offsetof(UChallenge, bCompleteIfGoalValueReached) == 0x0000B0, "Member 'UChallenge::bCompleteIfGoalValueReached' has a wrong offset!");
static_assert(offsetof(UChallenge, bResetProgressWhenGoalValueReached) == 0x0000B1, "Member 'UChallenge::bResetProgressWhenGoalValueReached' has a wrong offset!");
static_assert(offsetof(UChallenge, ProgressGoalInfo) == 0x0000B8, "Member 'UChallenge::ProgressGoalInfo' has a wrong offset!");
static_assert(offsetof(UChallenge, ProgressGoalValues) == 0x0000C8, "Member 'UChallenge::ProgressGoalValues' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeCategoryData) == 0x0000D8, "Member 'UChallenge::ChallengeCategoryData' has a wrong offset!");
static_assert(offsetof(UChallenge, bInitiallyActive) == 0x0000E0, "Member 'UChallenge::bInitiallyActive' has a wrong offset!");
static_assert(offsetof(UChallenge, bHideFromCounts) == 0x0000E1, "Member 'UChallenge::bHideFromCounts' has a wrong offset!");
static_assert(offsetof(UChallenge, PrerequisiteChallenge) == 0x0000E8, "Member 'UChallenge::PrerequisiteChallenge' has a wrong offset!");
static_assert(offsetof(UChallenge, AssociatedCompletionAchievementId) == 0x0000F0, "Member 'UChallenge::AssociatedCompletionAchievementId' has a wrong offset!");
static_assert(offsetof(UChallenge, AssociatedProgressAchievementId) == 0x0000F4, "Member 'UChallenge::AssociatedProgressAchievementId' has a wrong offset!");
static_assert(offsetof(UChallenge, bProfileChallenge) == 0x0000F8, "Member 'UChallenge::bProfileChallenge' has a wrong offset!");
static_assert(offsetof(UChallenge, SubChallenges) == 0x000100, "Member 'UChallenge::SubChallenges' has a wrong offset!");
static_assert(offsetof(UChallenge, CompletedBySubChallenges) == 0x000110, "Member 'UChallenge::CompletedBySubChallenges' has a wrong offset!");
static_assert(offsetof(UChallenge, ActivateIfSubChallengesComplete) == 0x000111, "Member 'UChallenge::ActivateIfSubChallengesComplete' has a wrong offset!");
static_assert(offsetof(UChallenge, bIncrementProgressViaSubChallenges) == 0x000112, "Member 'UChallenge::bIncrementProgressViaSubChallenges' has a wrong offset!");

// Class GbxGameSystemCore.SpawnPatternData
// 0x0000 (0x0030 - 0x0030)
class USpawnPatternData : public UGbxDataAsset
{
public:
	void CalculateSpawnPoint(const struct FSpawnPatternInputs& Inputs, struct FSpawnPatternResult* Result) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPatternData">();
	}
	static class USpawnPatternData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPatternData>();
	}
};
static_assert(alignof(USpawnPatternData) == 0x000008, "Wrong alignment on USpawnPatternData");
static_assert(sizeof(USpawnPatternData) == 0x000030, "Wrong size on USpawnPatternData");

// Class GbxGameSystemCore.PhysicsSpawnPatternData
// 0x00C8 (0x00F8 - 0x0030)
class UPhysicsSpawnPatternData : public USpawnPatternData
{
public:
	uint8                                         bEnableSpeedRange : 1;                             // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableAngularSpeedRange : 1;                      // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplySpeedAsImpulse : 1;                          // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyAngularSpeedAsImpulse : 1;                   // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickRandomPointInActorBounds : 1;                 // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleSpeedByIncomingImpulse : 1;                  // 0x0030(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRelativeDirectionData                 Direction;                                         // 0x0040(0x0050)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AngularSpeed;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngularSpeed;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRelativeDirectionData                 RotationAxis;                                      // 0x0098(0x0050)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ActorBoundsScale;                                  // 0x00E8(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsSpawnPatternData">();
	}
	static class UPhysicsSpawnPatternData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsSpawnPatternData>();
	}
};
static_assert(alignof(UPhysicsSpawnPatternData) == 0x000008, "Wrong alignment on UPhysicsSpawnPatternData");
static_assert(sizeof(UPhysicsSpawnPatternData) == 0x0000F8, "Wrong size on UPhysicsSpawnPatternData");
static_assert(offsetof(UPhysicsSpawnPatternData, Speed) == 0x000034, "Member 'UPhysicsSpawnPatternData::Speed' has a wrong offset!");
static_assert(offsetof(UPhysicsSpawnPatternData, MaxSpeed) == 0x000038, "Member 'UPhysicsSpawnPatternData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UPhysicsSpawnPatternData, Direction) == 0x000040, "Member 'UPhysicsSpawnPatternData::Direction' has a wrong offset!");
static_assert(offsetof(UPhysicsSpawnPatternData, AngularSpeed) == 0x000090, "Member 'UPhysicsSpawnPatternData::AngularSpeed' has a wrong offset!");
static_assert(offsetof(UPhysicsSpawnPatternData, MaxAngularSpeed) == 0x000094, "Member 'UPhysicsSpawnPatternData::MaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(UPhysicsSpawnPatternData, RotationAxis) == 0x000098, "Member 'UPhysicsSpawnPatternData::RotationAxis' has a wrong offset!");
static_assert(offsetof(UPhysicsSpawnPatternData, ActorBoundsScale) == 0x0000E8, "Member 'UPhysicsSpawnPatternData::ActorBoundsScale' has a wrong offset!");

// Class GbxGameSystemCore.DamageAreaType
// 0x0038 (0x0060 - 0x0028)
class UDamageAreaType : public UObject
{
public:
	int32                                         MaxTargets;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseMaxTargets : 1;                                // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoDirectDamageToImpactedActor : 1;                // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreWorldGeometry : 1;                          // 0x002C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTryDirectTraceFirst : 1;                          // 0x002C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipBackupImpactTrace : 1;                        // 0x002C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceZeroPitch : 1;                               // 0x002C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bZeroPitchBeforeApplyingHitStartOffset : 1;        // 0x002C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceZeroRoll : 1;                                // 0x002C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             TraceChannel;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceToGround;                                    // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceToGroundDownwardDistance;                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceToGroundStartHeightOffset;                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceToGroundHitOffset;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageAreaOverlapFilterType                  OverlapFilter;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverlapProfileName;                                // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      OverlapObjectTypes;                                // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType">();
	}
	static class UDamageAreaType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType>();
	}
};
static_assert(alignof(UDamageAreaType) == 0x000008, "Wrong alignment on UDamageAreaType");
static_assert(sizeof(UDamageAreaType) == 0x000060, "Wrong size on UDamageAreaType");
static_assert(offsetof(UDamageAreaType, MaxTargets) == 0x000028, "Member 'UDamageAreaType::MaxTargets' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, TraceChannel) == 0x000030, "Member 'UDamageAreaType::TraceChannel' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, bTraceToGround) == 0x000031, "Member 'UDamageAreaType::bTraceToGround' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, TraceToGroundDownwardDistance) == 0x000034, "Member 'UDamageAreaType::TraceToGroundDownwardDistance' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, TraceToGroundStartHeightOffset) == 0x000038, "Member 'UDamageAreaType::TraceToGroundStartHeightOffset' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, TraceToGroundHitOffset) == 0x00003C, "Member 'UDamageAreaType::TraceToGroundHitOffset' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, OverlapFilter) == 0x000040, "Member 'UDamageAreaType::OverlapFilter' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, OverlapProfileName) == 0x000048, "Member 'UDamageAreaType::OverlapProfileName' has a wrong offset!");
static_assert(offsetof(UDamageAreaType, OverlapObjectTypes) == 0x000050, "Member 'UDamageAreaType::OverlapObjectTypes' has a wrong offset!");

// Class GbxGameSystemCore.DamageAreaType_Box
// 0x00B0 (0x0110 - 0x0060)
class UDamageAreaType_Box final : public UDamageAreaType
{
public:
	struct FAttributeInitializationData           HalfHeight;                                        // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           HalfWidth;                                         // 0x0098(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           HalfDepth;                                         // 0x00D0(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EDamageAreaBoxOriginType                      OriginType;                                        // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamageFallsOff;                                   // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType_Box">();
	}
	static class UDamageAreaType_Box* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType_Box>();
	}
};
static_assert(alignof(UDamageAreaType_Box) == 0x000008, "Wrong alignment on UDamageAreaType_Box");
static_assert(sizeof(UDamageAreaType_Box) == 0x000110, "Wrong size on UDamageAreaType_Box");
static_assert(offsetof(UDamageAreaType_Box, HalfHeight) == 0x000060, "Member 'UDamageAreaType_Box::HalfHeight' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Box, HalfWidth) == 0x000098, "Member 'UDamageAreaType_Box::HalfWidth' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Box, HalfDepth) == 0x0000D0, "Member 'UDamageAreaType_Box::HalfDepth' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Box, OriginType) == 0x000108, "Member 'UDamageAreaType_Box::OriginType' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Box, bDamageFallsOff) == 0x000109, "Member 'UDamageAreaType_Box::bDamageFallsOff' has a wrong offset!");

// Class GbxGameSystemCore.GbxAnimInstance
// 0x00F8 (0x0538 - 0x0440)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxAnimInstance : public UAnimInstance
{
public:
	class UGbxSkeletalMeshComponent*              GbxSkeletalMeshComponent;                          // 0x0440(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGbxAnimStateMachineDefinition*> AnimStateMachineDefinitions;                       // 0x0448(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRuntimeStateMachineData>       RuntimeStateMachines;                              // 0x0458(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UGbxAnimTable*, struct FGbxAnimTableMapItem> AnimTableMap;                                      // 0x0468(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x28];                                     // 0x04B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxStateManagerRuntime                ManagerRuntime;                                    // 0x04E0(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          bEarlyBindBoneSetDelegates;                        // 0x0530(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanUseAnimTable(class UGbxAnimTable* AnimTable) const;
	class UAnimSequence* GetAnimTableSequence(class UGbxAnimTable* AnimTable) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimInstance">();
	}
	static class UGbxAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxAnimInstance) == 0x000008, "Wrong alignment on UGbxAnimInstance");
static_assert(sizeof(UGbxAnimInstance) == 0x000538, "Wrong size on UGbxAnimInstance");
static_assert(offsetof(UGbxAnimInstance, GbxSkeletalMeshComponent) == 0x000440, "Member 'UGbxAnimInstance::GbxSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UGbxAnimInstance, AnimStateMachineDefinitions) == 0x000448, "Member 'UGbxAnimInstance::AnimStateMachineDefinitions' has a wrong offset!");
static_assert(offsetof(UGbxAnimInstance, RuntimeStateMachines) == 0x000458, "Member 'UGbxAnimInstance::RuntimeStateMachines' has a wrong offset!");
static_assert(offsetof(UGbxAnimInstance, AnimTableMap) == 0x000468, "Member 'UGbxAnimInstance::AnimTableMap' has a wrong offset!");
static_assert(offsetof(UGbxAnimInstance, ManagerRuntime) == 0x0004E0, "Member 'UGbxAnimInstance::ManagerRuntime' has a wrong offset!");
static_assert(offsetof(UGbxAnimInstance, bEarlyBindBoneSetDelegates) == 0x000530, "Member 'UGbxAnimInstance::bEarlyBindBoneSetDelegates' has a wrong offset!");

// Class GbxGameSystemCore.GbxAreaComponent
// 0x0060 (0x0750 - 0x06F0)
class UGbxAreaComponent : public UPrimitiveComponent
{
public:
	TArray<class AVolume*>                        DetectionVolumes;                                  // 0x06F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          bWorldAreaVolume;                                  // 0x0700(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetectionRadius;                                   // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectionHalfHeight;                               // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldAreaRadius;                                  // 0x070C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualTest;                                       // 0x070D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70E[0x2];                                      // 0x070E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlayerEnteredArea;                               // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerExitedArea;                                // 0x0720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGbxAreaDrawStyle                             DrawStyle;                                         // 0x0730(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0x7];                                      // 0x0731(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class APlayerController>> PlayersDetected;                                   // 0x0738(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AreaTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAreaComponent">();
	}
	static class UGbxAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAreaComponent>();
	}
};
static_assert(alignof(UGbxAreaComponent) == 0x000008, "Wrong alignment on UGbxAreaComponent");
static_assert(sizeof(UGbxAreaComponent) == 0x000750, "Wrong size on UGbxAreaComponent");
static_assert(offsetof(UGbxAreaComponent, DetectionVolumes) == 0x0006F0, "Member 'UGbxAreaComponent::DetectionVolumes' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, bWorldAreaVolume) == 0x000700, "Member 'UGbxAreaComponent::bWorldAreaVolume' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, DetectionRadius) == 0x000704, "Member 'UGbxAreaComponent::DetectionRadius' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, DetectionHalfHeight) == 0x000708, "Member 'UGbxAreaComponent::DetectionHalfHeight' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, bWorldAreaRadius) == 0x00070C, "Member 'UGbxAreaComponent::bWorldAreaRadius' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, bManualTest) == 0x00070D, "Member 'UGbxAreaComponent::bManualTest' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, OnPlayerEnteredArea) == 0x000710, "Member 'UGbxAreaComponent::OnPlayerEnteredArea' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, OnPlayerExitedArea) == 0x000720, "Member 'UGbxAreaComponent::OnPlayerExitedArea' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, DrawStyle) == 0x000730, "Member 'UGbxAreaComponent::DrawStyle' has a wrong offset!");
static_assert(offsetof(UGbxAreaComponent, PlayersDetected) == 0x000738, "Member 'UGbxAreaComponent::PlayersDetected' has a wrong offset!");

// Class GbxGameSystemCore.RigidBodyComponent
// 0x0028 (0x07D0 - 0x07A8)
class URigidBodyComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_7A8[0x8];                                      // 0x07A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            RigidBodyImpactData;                               // 0x07B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnImpulseAdded;                                    // 0x07B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableHardSleeping;                               // 0x07C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C9[0x7];                                      // 0x07C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetKinematic(class UPrimitiveComponent* SleepingComponent, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RigidBodyComponent">();
	}
	static class URigidBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URigidBodyComponent>();
	}
};
static_assert(alignof(URigidBodyComponent) == 0x000008, "Wrong alignment on URigidBodyComponent");
static_assert(sizeof(URigidBodyComponent) == 0x0007D0, "Wrong size on URigidBodyComponent");
static_assert(offsetof(URigidBodyComponent, RigidBodyImpactData) == 0x0007B0, "Member 'URigidBodyComponent::RigidBodyImpactData' has a wrong offset!");
static_assert(offsetof(URigidBodyComponent, OnImpulseAdded) == 0x0007B8, "Member 'URigidBodyComponent::OnImpulseAdded' has a wrong offset!");
static_assert(offsetof(URigidBodyComponent, bEnableHardSleeping) == 0x0007C8, "Member 'URigidBodyComponent::bEnableHardSleeping' has a wrong offset!");

// Class GbxGameSystemCore.GbxCustomizationData
// 0x0100 (0x0130 - 0x0030)
class UGbxCustomizationData : public UGbxDataAsset
{
public:
	class FText                                   CustomizationName;                                 // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CustomizationDescription;                          // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 IconFrameName;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUIStatPriorityData>            UIStats;                                           // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 ItemCardTypeFrameName;                             // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                PreviewImage;                                      // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           PurchasePrice;                                     // 0x00B8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxCustomizationTypeData*              CustomizationType;                                 // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationAssetEntry>       CustomizationTargetAssets;                         // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUnlockedByDefault;                                // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquippedByDefault;                                // 0x0109(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A[0x6];                                      // 0x010A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCustomizationData*                  DefaultSkin;                                       // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCustomizationData*                  DependentBody;                                     // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AsyncLoadCustomizationAssets(const TDelegate<void(class UGbxCustomizationData* LoadedCustomization)>& LoadedDelegate);
	bool IsLoading();
	class UGbxAction* K2_PlayAction(class AActor* TargetActor, const struct FActionState_Base& ActionData);
	void OnCustomizationAssetLoaded();

	bool ApplyCustomizationToActor(class AActor* TargetActor, int32 OptionalCustomizationId) const;
	bool IsLoaded(int32 OptionalCustomizationId) const;
	bool RemoveCustomizationFromActor(class AActor* TargetActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCustomizationData">();
	}
	static class UGbxCustomizationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCustomizationData>();
	}
};
static_assert(alignof(UGbxCustomizationData) == 0x000008, "Wrong alignment on UGbxCustomizationData");
static_assert(sizeof(UGbxCustomizationData) == 0x000130, "Wrong size on UGbxCustomizationData");
static_assert(offsetof(UGbxCustomizationData, CustomizationName) == 0x000030, "Member 'UGbxCustomizationData::CustomizationName' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, CustomizationDescription) == 0x000048, "Member 'UGbxCustomizationData::CustomizationDescription' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, IconFrameName) == 0x000060, "Member 'UGbxCustomizationData::IconFrameName' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, UIStats) == 0x000070, "Member 'UGbxCustomizationData::UIStats' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, ItemCardTypeFrameName) == 0x000080, "Member 'UGbxCustomizationData::ItemCardTypeFrameName' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, PreviewImage) == 0x000090, "Member 'UGbxCustomizationData::PreviewImage' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, PurchasePrice) == 0x0000B8, "Member 'UGbxCustomizationData::PurchasePrice' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, CustomizationType) == 0x0000F0, "Member 'UGbxCustomizationData::CustomizationType' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, CustomizationTargetAssets) == 0x0000F8, "Member 'UGbxCustomizationData::CustomizationTargetAssets' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, bUnlockedByDefault) == 0x000108, "Member 'UGbxCustomizationData::bUnlockedByDefault' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, bEquippedByDefault) == 0x000109, "Member 'UGbxCustomizationData::bEquippedByDefault' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, DefaultSkin) == 0x000110, "Member 'UGbxCustomizationData::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationData, DependentBody) == 0x000118, "Member 'UGbxCustomizationData::DependentBody' has a wrong offset!");

// Class GbxGameSystemCore.GbxFlagValueResolver
// 0x0000 (0x0028 - 0x0028)
class UGbxFlagValueResolver : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFlagValueResolver">();
	}
	static class UGbxFlagValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFlagValueResolver>();
	}
};
static_assert(alignof(UGbxFlagValueResolver) == 0x000008, "Wrong alignment on UGbxFlagValueResolver");
static_assert(sizeof(UGbxFlagValueResolver) == 0x000028, "Wrong size on UGbxFlagValueResolver");

// Class GbxGameSystemCore.ActorPartSelectionData
// 0x0068 (0x0098 - 0x0030)
class UActorPartSelectionData : public UGbxDataAsset
{
public:
	class UActorPartSelectionData*                BaseSelectionData;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorPartSetData*                      PartSetData;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  PartSetDataGuid;                                   // 0x0040(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRuntimeActorPartListData              RuntimePartList;                                   // 0x0050(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  RuntimePartListGuid;                               // 0x0078(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  InheritedRuntimePartListGuid;                      // 0x0088(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPartSelectionData">();
	}
	static class UActorPartSelectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPartSelectionData>();
	}
};
static_assert(alignof(UActorPartSelectionData) == 0x000008, "Wrong alignment on UActorPartSelectionData");
static_assert(sizeof(UActorPartSelectionData) == 0x000098, "Wrong size on UActorPartSelectionData");
static_assert(offsetof(UActorPartSelectionData, BaseSelectionData) == 0x000030, "Member 'UActorPartSelectionData::BaseSelectionData' has a wrong offset!");
static_assert(offsetof(UActorPartSelectionData, PartSetData) == 0x000038, "Member 'UActorPartSelectionData::PartSetData' has a wrong offset!");
static_assert(offsetof(UActorPartSelectionData, PartSetDataGuid) == 0x000040, "Member 'UActorPartSelectionData::PartSetDataGuid' has a wrong offset!");
static_assert(offsetof(UActorPartSelectionData, RuntimePartList) == 0x000050, "Member 'UActorPartSelectionData::RuntimePartList' has a wrong offset!");
static_assert(offsetof(UActorPartSelectionData, RuntimePartListGuid) == 0x000078, "Member 'UActorPartSelectionData::RuntimePartListGuid' has a wrong offset!");
static_assert(offsetof(UActorPartSelectionData, InheritedRuntimePartListGuid) == 0x000088, "Member 'UActorPartSelectionData::InheritedRuntimePartListGuid' has a wrong offset!");

// Class GbxGameSystemCore.ImpactDecalManager
// 0x0470 (0x08C8 - 0x0458)
class AImpactDecalManager final : public AActor
{
public:
	uint8                                         Pad_458[0x470];                                    // 0x0458(0x0470)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactDecalManager">();
	}
	static class AImpactDecalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AImpactDecalManager>();
	}
};
static_assert(alignof(AImpactDecalManager) == 0x000008, "Wrong alignment on AImpactDecalManager");
static_assert(sizeof(AImpactDecalManager) == 0x0008C8, "Wrong size on AImpactDecalManager");

// Class GbxGameSystemCore.UserStatesFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserStatesFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool HasEnableConditionsSetForSpecificUserState(class UObject* Context, class FName UserStateProperty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserStatesFunctionLibrary">();
	}
	static class UUserStatesFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserStatesFunctionLibrary>();
	}
};
static_assert(alignof(UUserStatesFunctionLibrary) == 0x000008, "Wrong alignment on UUserStatesFunctionLibrary");
static_assert(sizeof(UUserStatesFunctionLibrary) == 0x000028, "Wrong size on UUserStatesFunctionLibrary");

// Class GbxGameSystemCore.ChallengesComponent
// 0x0090 (0x0208 - 0x0178)
class UChallengesComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnChallengeRegistrationComplete;                   // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChallengeActivated;                              // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChallengeUpdated;                                // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChallengeCompleted;                              // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChallengeChildCompleted;                         // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FChallengeInstanceData>         LocalChallengeDataCache;                           // 0x01C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ChallengeRewardsEarned;                            // 0x01D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ChallengeRewardsToOfferNext;                       // 0x01E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UGameStatsComponent*                    GameStatsComponent;                                // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateChallenge(class UClass* ChalClass);
	bool AreGlobalChallengesRegistered();
	void ClientActivateChallenge(class UClass* ChalClass);
	void ClientChallengeCompleted(class UClass* ChalClass, int32 NumTiersComplete, bool bForceActive);
	void ClientChallengeUpdateProgress(class UClass* ChalClass, int32 NewProgress);
	void CompleteChallenge(class UClass* ChalClass, bool bForceActive);
	void CompleteChallengeIfConditionsMet(class UClass* ChalClass);
	void GetChallengeCompleteInfo(class UClass* ChalClass, int32* NumCompleted, int32* NumChallenges);
	void GetChallengeCompleteInfoForLevels(const TArray<class FName>& LevelsForChallenges, class UChallengeCategoryData* Category, int32* NumCompleted, int32* NumActive, bool bIgnoreHidden);
	int32 GetChallengeProgress(class UClass* ChalClass);
	int32 GetChallengeProgressGoalValue(class UClass* ChalClass);
	int32 GetChallengeStatGoalValue(class UClass* ChalClass, class UGameStatData* StatId);
	int32 GetChallengeStatValue(class UClass* ChalClass, class UGameStatData* StatId);
	int32 GetCompletedChallengeTiers(class UClass* ChalClass);
	TArray<struct FChallengeInstanceData> GetLocalChallenges();
	int32 GetMaxChallengeTiers(class UClass* ChalClass);
	void IncrementChallengeProgress(class UClass* ChalClass);
	bool IsChallengeActive(class UClass* ChalClass);
	bool IsChallengeComplete(class UClass* ChalClass);
	void SetChallengeActive(class UClass* ChalClass, bool bInIsActive);
	void SetChallengeProgress(class UClass* ChalClass, int32 NewProgress);
	void UnregisterInActivePlayerChallenges();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesComponent">();
	}
	static class UChallengesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengesComponent>();
	}
};
static_assert(alignof(UChallengesComponent) == 0x000008, "Wrong alignment on UChallengesComponent");
static_assert(sizeof(UChallengesComponent) == 0x000208, "Wrong size on UChallengesComponent");
static_assert(offsetof(UChallengesComponent, OnChallengeRegistrationComplete) == 0x000178, "Member 'UChallengesComponent::OnChallengeRegistrationComplete' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, OnChallengeActivated) == 0x000188, "Member 'UChallengesComponent::OnChallengeActivated' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, OnChallengeUpdated) == 0x000198, "Member 'UChallengesComponent::OnChallengeUpdated' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, OnChallengeCompleted) == 0x0001A8, "Member 'UChallengesComponent::OnChallengeCompleted' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, OnChallengeChildCompleted) == 0x0001B8, "Member 'UChallengesComponent::OnChallengeChildCompleted' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, LocalChallengeDataCache) == 0x0001C8, "Member 'UChallengesComponent::LocalChallengeDataCache' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, ChallengeRewardsEarned) == 0x0001D8, "Member 'UChallengesComponent::ChallengeRewardsEarned' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, ChallengeRewardsToOfferNext) == 0x0001E8, "Member 'UChallengesComponent::ChallengeRewardsToOfferNext' has a wrong offset!");
static_assert(offsetof(UChallengesComponent, GameStatsComponent) == 0x0001F8, "Member 'UChallengesComponent::GameStatsComponent' has a wrong offset!");

// Class GbxGameSystemCore.GbxCharacterAnimInstance
// 0x0418 (0x0950 - 0x0538)
class UGbxCharacterAnimInstance : public UGbxAnimInstance
{
public:
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HeadLookAtLocation;                                // 0x0540(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyeLookAtLocation;                                 // 0x054C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadLookAtPercentage;                              // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtWeight;                                      // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtBlinkStarted;                               // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveStanceData;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveStanceType;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    CombatStance;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    PassiveStance;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceData*                            StanceData;                                        // 0x0588(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceType*                            StanceType;                                        // 0x0590(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceComponent*                       StanceComponent;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCombatStance;                                   // 0x05A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInPassiveStance;                                  // 0x05A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInAir;                                           // 0x05A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCrouching;                                       // 0x05A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x05A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x05A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenLaunched;                                  // 0x05A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumped;                                           // 0x05A7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFallingState;                                // 0x05A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWalkSpeed;                                      // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintSpeed;                                    // 0x05B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedCrouched;                              // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2D;                                           // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2DRaw;                                        // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityZ;                                         // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardDirection;                                  // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightDirection;                                    // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDirection;                                       // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x05D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyYaw;                                           // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverseDirection;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationalVelocity;                                // 0x05E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                GroundLocation;                                    // 0x05F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WantsToTurn;                                       // 0x0604(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_605[0x3];                                      // 0x0605(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAmount;                                        // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnIsActive;                                      // 0x060C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60D[0x3];                                      // 0x060D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPredictedTurnDegrees;                           // 0x0610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPredictedTurnTime;                              // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x061C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimBlendWeight;                                    // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimFacingLocation;                                 // 0x0624(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAimInPassiveStance;                            // 0x0630(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateFootIK;                                     // 0x0631(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateHandIK;                                     // 0x0632(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_633[0x1];                                      // 0x0633(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftHandIKWeight;                                  // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightHandIKWeight;                                 // 0x0638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandGripWeight;                                // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightHandGripWeight;                               // 0x0640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLegIkBaseClass;                                // 0x0644(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_645[0xB];                                      // 0x0645(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandWeaponIKOffset;                            // 0x0650(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             RightHandWeaponIKOffset;                           // 0x0680(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LeftHandWorldIKTarget;                             // 0x06B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasLeftHandWorldIKTarget;                         // 0x06E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlueprintForceLeftHandWorldIKTarget;              // 0x06E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E2[0x6];                                      // 0x06E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftHandIKTargetSocketName;                        // 0x06E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RightHandWorldIKTarget;                            // 0x06F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasRightHandWorldIKTarget;                        // 0x0720(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlueprintForceRightHandWorldIKTarget;             // 0x0721(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_722[0x6];                                      // 0x0722(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RightHandIKTargetSocketName;                       // 0x0728(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootWorldIKTargetLocation;                     // 0x0730(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftFootWorldIKTargetRotation;                     // 0x073C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightFootWorldIKTargetLocation;                    // 0x0748(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightFootWorldIKTargetRotation;                    // 0x0754(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasFootWorldIKTargets;                            // 0x0760(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AINavYaw;                                          // 0x0764(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AINavTurnBlendDegrees;                             // 0x0768(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AINavTransitionBlendDegrees;                       // 0x076C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AINavHopDirection;                                 // 0x0770(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AINavHopDistance;                                  // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavAnimServerData                     AINavServerData;                                   // 0x0780(0x00A0)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FNavAnimClientData                     AINavClientData;                                   // 0x0820(0x001C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AINavState_IdleAlphaTime;                          // 0x083C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AINavState_IdleAlpha;                              // 0x0840(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavState_Idle;                                  // 0x0844(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavState_Move;                                  // 0x0845(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavState_Start;                                 // 0x0846(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavState_Stop;                                  // 0x0847(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavState_Turn;                                  // 0x0848(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxCharacterBlendPoints                      BlendPoints;                                       // 0x0849(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavWantsForward;                                // 0x084A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavWantsBackward;                               // 0x084B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavWantsLeft;                                   // 0x084C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavWantsRight;                                  // 0x084D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavIsMoving2D;                                  // 0x084E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINavIsStill2D;                                   // 0x084F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AINavPreviewTableIndex;                            // 0x0850(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavAnimState                                 AINavPreviewDesiredState;                          // 0x0854(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINav_UseDesired;                                 // 0x0855(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAINav_CanStretch;                                 // 0x0856(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_857[0x1];                                      // 0x0857(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshScale;                                         // 0x0858(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavAnimState                                 AINavPreviewCurrentState;                          // 0x085C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85D[0x53];                                     // 0x085D(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTransitionTimeToEvaluate;                     // 0x08B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTransitionTimeToEvaluate;                      // 0x08B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningRotationTimeToEvaluate;                     // 0x08B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxBoneSet*                            ActiveAnimBoneSetFilter;                           // 0x08C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxBoneSet*                            PrevAnimBoneSetFilter;                             // 0x08C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D0[0x18];                                     // 0x08D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGaitScalingSettings                   GaitScalingSettings;                               // 0x08E8(0x0038)(Edit, NativeAccessSpecifierPublic)
	float                                         FacialEmoteWeight;                                 // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredFacialEmoteWeight;                          // 0x0924(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FacialEmoteWeightAlphaSpeed;                       // 0x0928(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredActionWeight;                               // 0x092C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneSetTransitionActionWeight;                     // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneSetBlendWeight;                                // 0x0934(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSetTransitionBlendType                   BoneSetTransitionBlendType;                        // 0x0938(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_939[0x3];                                      // 0x0939(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoneSetTransitionBlendSpeed;                       // 0x093C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BoneSetBlendSpeed;                                 // 0x0940(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultBoneSetBlendSpeed;                          // 0x0944(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultBoneSetTransitionBlendSpeed;                // 0x0948(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94C[0x4];                                      // 0x094C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStanceChanged();
	void SetDesiredFacialEmoteWeight(float Weight, float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCharacterAnimInstance">();
	}
	static class UGbxCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCharacterAnimInstance>();
	}
};
static_assert(alignof(UGbxCharacterAnimInstance) == 0x000010, "Wrong alignment on UGbxCharacterAnimInstance");
static_assert(sizeof(UGbxCharacterAnimInstance) == 0x000950, "Wrong size on UGbxCharacterAnimInstance");
static_assert(offsetof(UGbxCharacterAnimInstance, HeadLookAtLocation) == 0x000540, "Member 'UGbxCharacterAnimInstance::HeadLookAtLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, EyeLookAtLocation) == 0x00054C, "Member 'UGbxCharacterAnimInstance::EyeLookAtLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, HeadLookAtPercentage) == 0x000558, "Member 'UGbxCharacterAnimInstance::HeadLookAtPercentage' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LookAtWeight) == 0x00055C, "Member 'UGbxCharacterAnimInstance::LookAtWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bLookAtBlinkStarted) == 0x000560, "Member 'UGbxCharacterAnimInstance::bLookAtBlinkStarted' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, ActiveStanceData) == 0x000568, "Member 'UGbxCharacterAnimInstance::ActiveStanceData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, ActiveStanceType) == 0x000570, "Member 'UGbxCharacterAnimInstance::ActiveStanceType' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, CombatStance) == 0x000578, "Member 'UGbxCharacterAnimInstance::CombatStance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, PassiveStance) == 0x000580, "Member 'UGbxCharacterAnimInstance::PassiveStance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, StanceData) == 0x000588, "Member 'UGbxCharacterAnimInstance::StanceData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, StanceType) == 0x000590, "Member 'UGbxCharacterAnimInstance::StanceType' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, StanceComponent) == 0x000598, "Member 'UGbxCharacterAnimInstance::StanceComponent' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bInCombatStance) == 0x0005A0, "Member 'UGbxCharacterAnimInstance::bInCombatStance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bInPassiveStance) == 0x0005A1, "Member 'UGbxCharacterAnimInstance::bInPassiveStance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, IsInAir) == 0x0005A2, "Member 'UGbxCharacterAnimInstance::IsInAir' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, IsCrouching) == 0x0005A3, "Member 'UGbxCharacterAnimInstance::IsCrouching' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bIsFlying) == 0x0005A4, "Member 'UGbxCharacterAnimInstance::bIsFlying' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bIsFalling) == 0x0005A5, "Member 'UGbxCharacterAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bHasBeenLaunched) == 0x0005A6, "Member 'UGbxCharacterAnimInstance::bHasBeenLaunched' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bJumped) == 0x0005A7, "Member 'UGbxCharacterAnimInstance::bJumped' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bForceFallingState) == 0x0005A8, "Member 'UGbxCharacterAnimInstance::bForceFallingState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, MaxWalkSpeed) == 0x0005AC, "Member 'UGbxCharacterAnimInstance::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, MaxSprintSpeed) == 0x0005B0, "Member 'UGbxCharacterAnimInstance::MaxSprintSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, MaxWalkSpeedCrouched) == 0x0005B4, "Member 'UGbxCharacterAnimInstance::MaxWalkSpeedCrouched' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Speed2D) == 0x0005B8, "Member 'UGbxCharacterAnimInstance::Speed2D' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Speed2DRaw) == 0x0005BC, "Member 'UGbxCharacterAnimInstance::Speed2DRaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, VelocityZ) == 0x0005C0, "Member 'UGbxCharacterAnimInstance::VelocityZ' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, ForwardDirection) == 0x0005C4, "Member 'UGbxCharacterAnimInstance::ForwardDirection' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightDirection) == 0x0005C8, "Member 'UGbxCharacterAnimInstance::RightDirection' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, UpDirection) == 0x0005CC, "Member 'UGbxCharacterAnimInstance::UpDirection' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Acceleration) == 0x0005D0, "Member 'UGbxCharacterAnimInstance::Acceleration' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Direction) == 0x0005DC, "Member 'UGbxCharacterAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BodyYaw) == 0x0005E0, "Member 'UGbxCharacterAnimInstance::BodyYaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, ReverseDirection) == 0x0005E4, "Member 'UGbxCharacterAnimInstance::ReverseDirection' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RotationalVelocity) == 0x0005E8, "Member 'UGbxCharacterAnimInstance::RotationalVelocity' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, GroundLocation) == 0x0005F4, "Member 'UGbxCharacterAnimInstance::GroundLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Radius) == 0x000600, "Member 'UGbxCharacterAnimInstance::Radius' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, WantsToTurn) == 0x000604, "Member 'UGbxCharacterAnimInstance::WantsToTurn' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, TurnAmount) == 0x000608, "Member 'UGbxCharacterAnimInstance::TurnAmount' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, TurnIsActive) == 0x00060C, "Member 'UGbxCharacterAnimInstance::TurnIsActive' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, MaxPredictedTurnDegrees) == 0x000610, "Member 'UGbxCharacterAnimInstance::MaxPredictedTurnDegrees' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, MaxPredictedTurnTime) == 0x000614, "Member 'UGbxCharacterAnimInstance::MaxPredictedTurnTime' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Pitch) == 0x000618, "Member 'UGbxCharacterAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, Yaw) == 0x00061C, "Member 'UGbxCharacterAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AimBlendWeight) == 0x000620, "Member 'UGbxCharacterAnimInstance::AimBlendWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AimFacingLocation) == 0x000624, "Member 'UGbxCharacterAnimInstance::AimFacingLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bCanAimInPassiveStance) == 0x000630, "Member 'UGbxCharacterAnimInstance::bCanAimInPassiveStance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bUpdateFootIK) == 0x000631, "Member 'UGbxCharacterAnimInstance::bUpdateFootIK' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bUpdateHandIK) == 0x000632, "Member 'UGbxCharacterAnimInstance::bUpdateHandIK' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftHandIKWeight) == 0x000634, "Member 'UGbxCharacterAnimInstance::LeftHandIKWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightHandIKWeight) == 0x000638, "Member 'UGbxCharacterAnimInstance::RightHandIKWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftHandGripWeight) == 0x00063C, "Member 'UGbxCharacterAnimInstance::LeftHandGripWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightHandGripWeight) == 0x000640, "Member 'UGbxCharacterAnimInstance::RightHandGripWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bUseLegIkBaseClass) == 0x000644, "Member 'UGbxCharacterAnimInstance::bUseLegIkBaseClass' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftHandWeaponIKOffset) == 0x000650, "Member 'UGbxCharacterAnimInstance::LeftHandWeaponIKOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightHandWeaponIKOffset) == 0x000680, "Member 'UGbxCharacterAnimInstance::RightHandWeaponIKOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftHandWorldIKTarget) == 0x0006B0, "Member 'UGbxCharacterAnimInstance::LeftHandWorldIKTarget' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bHasLeftHandWorldIKTarget) == 0x0006E0, "Member 'UGbxCharacterAnimInstance::bHasLeftHandWorldIKTarget' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bBlueprintForceLeftHandWorldIKTarget) == 0x0006E1, "Member 'UGbxCharacterAnimInstance::bBlueprintForceLeftHandWorldIKTarget' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftHandIKTargetSocketName) == 0x0006E8, "Member 'UGbxCharacterAnimInstance::LeftHandIKTargetSocketName' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightHandWorldIKTarget) == 0x0006F0, "Member 'UGbxCharacterAnimInstance::RightHandWorldIKTarget' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bHasRightHandWorldIKTarget) == 0x000720, "Member 'UGbxCharacterAnimInstance::bHasRightHandWorldIKTarget' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bBlueprintForceRightHandWorldIKTarget) == 0x000721, "Member 'UGbxCharacterAnimInstance::bBlueprintForceRightHandWorldIKTarget' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightHandIKTargetSocketName) == 0x000728, "Member 'UGbxCharacterAnimInstance::RightHandIKTargetSocketName' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftFootWorldIKTargetLocation) == 0x000730, "Member 'UGbxCharacterAnimInstance::LeftFootWorldIKTargetLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, LeftFootWorldIKTargetRotation) == 0x00073C, "Member 'UGbxCharacterAnimInstance::LeftFootWorldIKTargetRotation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightFootWorldIKTargetLocation) == 0x000748, "Member 'UGbxCharacterAnimInstance::RightFootWorldIKTargetLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, RightFootWorldIKTargetRotation) == 0x000754, "Member 'UGbxCharacterAnimInstance::RightFootWorldIKTargetRotation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bHasFootWorldIKTargets) == 0x000760, "Member 'UGbxCharacterAnimInstance::bHasFootWorldIKTargets' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavYaw) == 0x000764, "Member 'UGbxCharacterAnimInstance::AINavYaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavTurnBlendDegrees) == 0x000768, "Member 'UGbxCharacterAnimInstance::AINavTurnBlendDegrees' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavTransitionBlendDegrees) == 0x00076C, "Member 'UGbxCharacterAnimInstance::AINavTransitionBlendDegrees' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavHopDirection) == 0x000770, "Member 'UGbxCharacterAnimInstance::AINavHopDirection' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavHopDistance) == 0x000778, "Member 'UGbxCharacterAnimInstance::AINavHopDistance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavServerData) == 0x000780, "Member 'UGbxCharacterAnimInstance::AINavServerData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavClientData) == 0x000820, "Member 'UGbxCharacterAnimInstance::AINavClientData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavState_IdleAlphaTime) == 0x00083C, "Member 'UGbxCharacterAnimInstance::AINavState_IdleAlphaTime' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavState_IdleAlpha) == 0x000840, "Member 'UGbxCharacterAnimInstance::AINavState_IdleAlpha' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavState_Idle) == 0x000844, "Member 'UGbxCharacterAnimInstance::bAINavState_Idle' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavState_Move) == 0x000845, "Member 'UGbxCharacterAnimInstance::bAINavState_Move' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavState_Start) == 0x000846, "Member 'UGbxCharacterAnimInstance::bAINavState_Start' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavState_Stop) == 0x000847, "Member 'UGbxCharacterAnimInstance::bAINavState_Stop' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavState_Turn) == 0x000848, "Member 'UGbxCharacterAnimInstance::bAINavState_Turn' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BlendPoints) == 0x000849, "Member 'UGbxCharacterAnimInstance::BlendPoints' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavWantsForward) == 0x00084A, "Member 'UGbxCharacterAnimInstance::bAINavWantsForward' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavWantsBackward) == 0x00084B, "Member 'UGbxCharacterAnimInstance::bAINavWantsBackward' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavWantsLeft) == 0x00084C, "Member 'UGbxCharacterAnimInstance::bAINavWantsLeft' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavWantsRight) == 0x00084D, "Member 'UGbxCharacterAnimInstance::bAINavWantsRight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavIsMoving2D) == 0x00084E, "Member 'UGbxCharacterAnimInstance::bAINavIsMoving2D' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINavIsStill2D) == 0x00084F, "Member 'UGbxCharacterAnimInstance::bAINavIsStill2D' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavPreviewTableIndex) == 0x000850, "Member 'UGbxCharacterAnimInstance::AINavPreviewTableIndex' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavPreviewDesiredState) == 0x000854, "Member 'UGbxCharacterAnimInstance::AINavPreviewDesiredState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINav_UseDesired) == 0x000855, "Member 'UGbxCharacterAnimInstance::bAINav_UseDesired' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, bAINav_CanStretch) == 0x000856, "Member 'UGbxCharacterAnimInstance::bAINav_CanStretch' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, MeshScale) == 0x000858, "Member 'UGbxCharacterAnimInstance::MeshScale' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, AINavPreviewCurrentState) == 0x00085C, "Member 'UGbxCharacterAnimInstance::AINavPreviewCurrentState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, StartTransitionTimeToEvaluate) == 0x0008B0, "Member 'UGbxCharacterAnimInstance::StartTransitionTimeToEvaluate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, StopTransitionTimeToEvaluate) == 0x0008B4, "Member 'UGbxCharacterAnimInstance::StopTransitionTimeToEvaluate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, TurningRotationTimeToEvaluate) == 0x0008B8, "Member 'UGbxCharacterAnimInstance::TurningRotationTimeToEvaluate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, ActiveAnimBoneSetFilter) == 0x0008C0, "Member 'UGbxCharacterAnimInstance::ActiveAnimBoneSetFilter' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, PrevAnimBoneSetFilter) == 0x0008C8, "Member 'UGbxCharacterAnimInstance::PrevAnimBoneSetFilter' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, GaitScalingSettings) == 0x0008E8, "Member 'UGbxCharacterAnimInstance::GaitScalingSettings' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, FacialEmoteWeight) == 0x000920, "Member 'UGbxCharacterAnimInstance::FacialEmoteWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, DesiredFacialEmoteWeight) == 0x000924, "Member 'UGbxCharacterAnimInstance::DesiredFacialEmoteWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, FacialEmoteWeightAlphaSpeed) == 0x000928, "Member 'UGbxCharacterAnimInstance::FacialEmoteWeightAlphaSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, DesiredActionWeight) == 0x00092C, "Member 'UGbxCharacterAnimInstance::DesiredActionWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BoneSetTransitionActionWeight) == 0x000930, "Member 'UGbxCharacterAnimInstance::BoneSetTransitionActionWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BoneSetBlendWeight) == 0x000934, "Member 'UGbxCharacterAnimInstance::BoneSetBlendWeight' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BoneSetTransitionBlendType) == 0x000938, "Member 'UGbxCharacterAnimInstance::BoneSetTransitionBlendType' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BoneSetTransitionBlendSpeed) == 0x00093C, "Member 'UGbxCharacterAnimInstance::BoneSetTransitionBlendSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, BoneSetBlendSpeed) == 0x000940, "Member 'UGbxCharacterAnimInstance::BoneSetBlendSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, DefaultBoneSetBlendSpeed) == 0x000944, "Member 'UGbxCharacterAnimInstance::DefaultBoneSetBlendSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterAnimInstance, DefaultBoneSetTransitionBlendSpeed) == 0x000948, "Member 'UGbxCharacterAnimInstance::DefaultBoneSetTransitionBlendSpeed' has a wrong offset!");

// Class GbxGameSystemCore.ParentChallenge
// 0x0000 (0x0118 - 0x0118)
class UParentChallenge final : public UChallenge
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParentChallenge">();
	}
	static class UParentChallenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParentChallenge>();
	}
};
static_assert(alignof(UParentChallenge) == 0x000008, "Wrong alignment on UParentChallenge");
static_assert(sizeof(UParentChallenge) == 0x000118, "Wrong size on UParentChallenge");

// Class GbxGameSystemCore.EffectCollectionData
// 0x0000 (0x0028 - 0x0028)
class UEffectCollectionData : public UObject
{
public:
	static class UParticleSystem* StaticGetParticleEffect(TSubclassOf<class UEffectCollectionData> Collection, class UObject* ContextObject);
	static void StaticGetParticleEffectAndWwiseEvent(TSubclassOf<class UEffectCollectionData> Collection, class UObject* ContextObject, class UParticleSystem** ParticleEffect, class UWwiseEvent** WwiseEvent);
	static class UWwiseEvent* StaticGetWwiseEvent(TSubclassOf<class UEffectCollectionData> Collection, class UObject* ContextObject);

	class UParticleSystem* GetParticleEffect(class UObject* ContextObject) const;
	void GetParticleEffectAndWwiseEvent(class UObject* ContextObject, class UParticleSystem** ParticleEffect, class UWwiseEvent** WwiseEvent) const;
	class UWwiseEvent* GetWwiseEvent(class UObject* ContextObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectCollectionData">();
	}
	static class UEffectCollectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectCollectionData>();
	}
};
static_assert(alignof(UEffectCollectionData) == 0x000008, "Wrong alignment on UEffectCollectionData");
static_assert(sizeof(UEffectCollectionData) == 0x000028, "Wrong size on UEffectCollectionData");

// Class GbxGameSystemCore.AttributePropertyValueResolver
// 0x0088 (0x00B0 - 0x0028)
class UAttributePropertyValueResolver : public UAttributeValueResolver
{
public:
	bool                                          PropertySupportsModifierRemoval;                   // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FParsedProperty                        Property;                                          // 0x0030(0x0080)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributePropertyValueResolver">();
	}
	static class UAttributePropertyValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributePropertyValueResolver>();
	}
};
static_assert(alignof(UAttributePropertyValueResolver) == 0x000008, "Wrong alignment on UAttributePropertyValueResolver");
static_assert(sizeof(UAttributePropertyValueResolver) == 0x0000B0, "Wrong size on UAttributePropertyValueResolver");
static_assert(offsetof(UAttributePropertyValueResolver, PropertySupportsModifierRemoval) == 0x000028, "Member 'UAttributePropertyValueResolver::PropertySupportsModifierRemoval' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolver, Property) == 0x000030, "Member 'UAttributePropertyValueResolver::Property' has a wrong offset!");

// Class GbxGameSystemCore.DataTableAttributeValueResolver
// 0x0020 (0x00D0 - 0x00B0)
class UDataTableAttributeValueResolver : public UAttributePropertyValueResolver
{
public:
	struct FDataTableRowHandle                    DataTableRow;                                      // 0x00B0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 DataTableColumn;                                   // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GetDataTableColumnNames(TArray<class FString>* ValueNames) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableAttributeValueResolver">();
	}
	static class UDataTableAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableAttributeValueResolver>();
	}
};
static_assert(alignof(UDataTableAttributeValueResolver) == 0x000008, "Wrong alignment on UDataTableAttributeValueResolver");
static_assert(sizeof(UDataTableAttributeValueResolver) == 0x0000D0, "Wrong size on UDataTableAttributeValueResolver");
static_assert(offsetof(UDataTableAttributeValueResolver, DataTableRow) == 0x0000B0, "Member 'UDataTableAttributeValueResolver::DataTableRow' has a wrong offset!");
static_assert(offsetof(UDataTableAttributeValueResolver, DataTableColumn) == 0x0000C0, "Member 'UDataTableAttributeValueResolver::DataTableColumn' has a wrong offset!");

// Class GbxGameSystemCore.DataTableFunctionAttributeValueResolver
// 0x0008 (0x00D8 - 0x00D0)
class UDataTableFunctionAttributeValueResolver : public UDataTableAttributeValueResolver
{
public:
	class UScriptStruct*                          DataTableStruct;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FDataTableRowHandle GetDataTableRow(const class UObject* Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableFunctionAttributeValueResolver">();
	}
	static class UDataTableFunctionAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableFunctionAttributeValueResolver>();
	}
};
static_assert(alignof(UDataTableFunctionAttributeValueResolver) == 0x000008, "Wrong alignment on UDataTableFunctionAttributeValueResolver");
static_assert(sizeof(UDataTableFunctionAttributeValueResolver) == 0x0000D8, "Wrong size on UDataTableFunctionAttributeValueResolver");
static_assert(offsetof(UDataTableFunctionAttributeValueResolver, DataTableStruct) == 0x0000D0, "Member 'UDataTableFunctionAttributeValueResolver::DataTableStruct' has a wrong offset!");

// Class GbxGameSystemCore.EnvQueryGenerator_TargetableActors
// 0x00B0 (0x0110 - 0x0060)
class UEnvQueryGenerator_TargetableActors : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              DistanceMax;                                       // 0x0060(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          TargetSkipDistanceCheckCondition;                  // 0x0090(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNonTargetableActors;                         // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDeadActors;                                  // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowQuerier;                                     // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHostiles;                                    // 0x009B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFriendlies;                                  // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNeutrals;                                    // 0x009D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          TargetCondition;                                   // 0x00A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorTagCompositeQuery                TagQuery;                                          // 0x00A8(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           AllowedTypes;                                      // 0x00B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bUseAllowedTypes : 1;                              // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           DisallowedTypes;                                   // 0x00D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bUseDisallowedTypes : 1;                           // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         AllowedTypesCache;                                 // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         DisallowedTypesCache;                              // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_TargetableActors">();
	}
	static class UEnvQueryGenerator_TargetableActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_TargetableActors>();
	}
};
static_assert(alignof(UEnvQueryGenerator_TargetableActors) == 0x000008, "Wrong alignment on UEnvQueryGenerator_TargetableActors");
static_assert(sizeof(UEnvQueryGenerator_TargetableActors) == 0x000110, "Wrong size on UEnvQueryGenerator_TargetableActors");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, DistanceMax) == 0x000060, "Member 'UEnvQueryGenerator_TargetableActors::DistanceMax' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, TargetSkipDistanceCheckCondition) == 0x000090, "Member 'UEnvQueryGenerator_TargetableActors::TargetSkipDistanceCheckCondition' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, bAllowNonTargetableActors) == 0x000098, "Member 'UEnvQueryGenerator_TargetableActors::bAllowNonTargetableActors' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, bAllowDeadActors) == 0x000099, "Member 'UEnvQueryGenerator_TargetableActors::bAllowDeadActors' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, bAllowQuerier) == 0x00009A, "Member 'UEnvQueryGenerator_TargetableActors::bAllowQuerier' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, bAllowHostiles) == 0x00009B, "Member 'UEnvQueryGenerator_TargetableActors::bAllowHostiles' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, bAllowFriendlies) == 0x00009C, "Member 'UEnvQueryGenerator_TargetableActors::bAllowFriendlies' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, bAllowNeutrals) == 0x00009D, "Member 'UEnvQueryGenerator_TargetableActors::bAllowNeutrals' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, TargetCondition) == 0x0000A0, "Member 'UEnvQueryGenerator_TargetableActors::TargetCondition' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, TagQuery) == 0x0000A8, "Member 'UEnvQueryGenerator_TargetableActors::TagQuery' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, AllowedTypes) == 0x0000B8, "Member 'UEnvQueryGenerator_TargetableActors::AllowedTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, DisallowedTypes) == 0x0000D0, "Member 'UEnvQueryGenerator_TargetableActors::DisallowedTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, AllowedTypesCache) == 0x0000E8, "Member 'UEnvQueryGenerator_TargetableActors::AllowedTypesCache' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetableActors, DisallowedTypesCache) == 0x0000F8, "Member 'UEnvQueryGenerator_TargetableActors::DisallowedTypesCache' has a wrong offset!");

// Class GbxGameSystemCore.ConditionalAttributeValueResolver
// 0x0080 (0x00A8 - 0x0028)
class UConditionalAttributeValueResolver final : public UAttributeValueResolver
{
public:
	struct FAttributeInitializationData           DefaultValue;                                      // 0x0028(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Scaler;                                            // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAttributeConditionalValue>     ConditionalValues;                                 // 0x0098(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalAttributeValueResolver">();
	}
	static class UConditionalAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalAttributeValueResolver>();
	}
};
static_assert(alignof(UConditionalAttributeValueResolver) == 0x000008, "Wrong alignment on UConditionalAttributeValueResolver");
static_assert(sizeof(UConditionalAttributeValueResolver) == 0x0000A8, "Wrong size on UConditionalAttributeValueResolver");
static_assert(offsetof(UConditionalAttributeValueResolver, DefaultValue) == 0x000028, "Member 'UConditionalAttributeValueResolver::DefaultValue' has a wrong offset!");
static_assert(offsetof(UConditionalAttributeValueResolver, Scaler) == 0x000060, "Member 'UConditionalAttributeValueResolver::Scaler' has a wrong offset!");
static_assert(offsetof(UConditionalAttributeValueResolver, ConditionalValues) == 0x000098, "Member 'UConditionalAttributeValueResolver::ConditionalValues' has a wrong offset!");

// Class GbxGameSystemCore.GbxGameplayGlobals
// 0x01E8 (0x0218 - 0x0030)
class UGbxGameplayGlobals : public UGbxDataAsset
{
public:
	class UHealthTypeData*                        ShieldHealthType;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              ProjectileReflectionQuery;                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileReflectionSpeedScale;                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileHitRegionRicochetSpeedScale;             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ProjectileReflectionInaccuracy;                    // 0x0048(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UImpactData*                            ProjectileReflectionImpact;                        // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ProjectileSelfReflectionImpact;                    // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUsableTypeDefinition*                  DefaultUseDefinition;                              // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           InventoryScoreValueInitializer;                    // 0x0098(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UGlobalAIData*                          GlobalAIData;                                      // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionWindRadiusModifier;                       // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinExplosionRadiusToTriggerRadialBlur;             // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDefaultExplosionSettings>      DefaultExplosionSettings;                          // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            ShortDurationTinnitusEvent;                        // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            MediumDurationTinnitusEvent;                       // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            LongDurationTinnitusEvent;                         // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionSoundStackingMaxDistanceSquared;          // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionSoundStackingPreventionDelay;             // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DefaultFeedbackTable;                              // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UGameStatData*> KillStatMap;                                       // 0x0118(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UGameStatList*>                  GameStatLists;                                     // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UChallengeList*>                 GameChallengeLists;                                // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMantleGlobalData                      MantleGlobals;                                     // 0x0188(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameplayGlobals">();
	}
	static class UGbxGameplayGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGameplayGlobals>();
	}
};
static_assert(alignof(UGbxGameplayGlobals) == 0x000008, "Wrong alignment on UGbxGameplayGlobals");
static_assert(sizeof(UGbxGameplayGlobals) == 0x000218, "Wrong size on UGbxGameplayGlobals");
static_assert(offsetof(UGbxGameplayGlobals, ShieldHealthType) == 0x000030, "Member 'UGbxGameplayGlobals::ShieldHealthType' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ProjectileReflectionQuery) == 0x000038, "Member 'UGbxGameplayGlobals::ProjectileReflectionQuery' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ProjectileReflectionSpeedScale) == 0x000040, "Member 'UGbxGameplayGlobals::ProjectileReflectionSpeedScale' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ProjectileHitRegionRicochetSpeedScale) == 0x000044, "Member 'UGbxGameplayGlobals::ProjectileHitRegionRicochetSpeedScale' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ProjectileReflectionInaccuracy) == 0x000048, "Member 'UGbxGameplayGlobals::ProjectileReflectionInaccuracy' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ProjectileReflectionImpact) == 0x000080, "Member 'UGbxGameplayGlobals::ProjectileReflectionImpact' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ProjectileSelfReflectionImpact) == 0x000088, "Member 'UGbxGameplayGlobals::ProjectileSelfReflectionImpact' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, DefaultUseDefinition) == 0x000090, "Member 'UGbxGameplayGlobals::DefaultUseDefinition' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, InventoryScoreValueInitializer) == 0x000098, "Member 'UGbxGameplayGlobals::InventoryScoreValueInitializer' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, GlobalAIData) == 0x0000D0, "Member 'UGbxGameplayGlobals::GlobalAIData' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ExplosionWindRadiusModifier) == 0x0000D8, "Member 'UGbxGameplayGlobals::ExplosionWindRadiusModifier' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, MinExplosionRadiusToTriggerRadialBlur) == 0x0000DC, "Member 'UGbxGameplayGlobals::MinExplosionRadiusToTriggerRadialBlur' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, DefaultExplosionSettings) == 0x0000E0, "Member 'UGbxGameplayGlobals::DefaultExplosionSettings' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ShortDurationTinnitusEvent) == 0x0000F0, "Member 'UGbxGameplayGlobals::ShortDurationTinnitusEvent' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, MediumDurationTinnitusEvent) == 0x0000F8, "Member 'UGbxGameplayGlobals::MediumDurationTinnitusEvent' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, LongDurationTinnitusEvent) == 0x000100, "Member 'UGbxGameplayGlobals::LongDurationTinnitusEvent' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ExplosionSoundStackingMaxDistanceSquared) == 0x000108, "Member 'UGbxGameplayGlobals::ExplosionSoundStackingMaxDistanceSquared' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, ExplosionSoundStackingPreventionDelay) == 0x00010C, "Member 'UGbxGameplayGlobals::ExplosionSoundStackingPreventionDelay' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, DefaultFeedbackTable) == 0x000110, "Member 'UGbxGameplayGlobals::DefaultFeedbackTable' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, KillStatMap) == 0x000118, "Member 'UGbxGameplayGlobals::KillStatMap' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, GameStatLists) == 0x000168, "Member 'UGbxGameplayGlobals::GameStatLists' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, GameChallengeLists) == 0x000178, "Member 'UGbxGameplayGlobals::GameChallengeLists' has a wrong offset!");
static_assert(offsetof(UGbxGameplayGlobals, MantleGlobals) == 0x000188, "Member 'UGbxGameplayGlobals::MantleGlobals' has a wrong offset!");

// Class GbxGameSystemCore.DamageInfoFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDamageInfoFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetApplyCriticalHitModsToAoEDamage(const struct FDamageInfo& DamageInfo);
	static struct FCriticalHitDamageOverrides GetCriticalHitDamageOverrides(const struct FDamageInfo& DamageInfo);
	static float GetDamage(const struct FDamageInfo& DamageInfo);
	static class AActor* GetDamageCauser(const struct FDamageInfo& DamageInfo);
	static class UDamageModifierComponent* GetDamageModifierComponent(const struct FDamageInfo& DamageInfo);
	static float GetDamageRadius(const struct FDamageInfo& DamageInfo);
	static TSubclassOf<class UDamageSource> GetDamageSource(const struct FDamageInfo& DamageInfo);
	static TSubclassOf<class UGbxDamageType> GetDamageType(const struct FDamageInfo& DamageInfo);
	static float GetImpactForce(const struct FDamageInfo& DamageInfo);
	static void SetApplyCriticalHitModsToAoEDamage(struct FDamageInfo& DamageInfo, bool bApplyCriticalHitModsToAoEDamage);
	static void SetCriticalHitDamageOverrides(struct FDamageInfo& DamageInfo, const struct FCriticalHitDamageOverrides& Overrides);
	static void SetDamage(struct FDamageInfo& DamageInfo, float InDamage);
	static void SetDamageCauser(struct FDamageInfo& DamageInfo, class AActor* InDamageCauser);
	static void SetDamageModifierComponent(struct FDamageInfo& DamageInfo, class UDamageModifierComponent* InModifierComponent);
	static void SetDamageRadius(struct FDamageInfo& DamageInfo, float InDamageRadius);
	static void SetDamageSource(struct FDamageInfo& DamageInfo, TSubclassOf<class UDamageSource> InDamageSource);
	static void SetDamageType(struct FDamageInfo& DamageInfo, TSubclassOf<class UGbxDamageType> InDamageType);
	static void SetImpactForce(struct FDamageInfo& DamageInfo, float InImpactForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageInfoFunctionLibrary">();
	}
	static class UDamageInfoFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageInfoFunctionLibrary>();
	}
};
static_assert(alignof(UDamageInfoFunctionLibrary) == 0x000008, "Wrong alignment on UDamageInfoFunctionLibrary");
static_assert(sizeof(UDamageInfoFunctionLibrary) == 0x000028, "Wrong size on UDamageInfoFunctionLibrary");

// Class GbxGameSystemCore.DamageData
// 0x01D0 (0x01F8 - 0x0028)
class UDamageData : public UObject
{
public:
	struct FAttributeInitializationData           Damage;                                            // 0x0028(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamageMultiplier;                                  // 0x0060(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UDamageAreaType*                        DamageAreaType;                                    // 0x0098(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x00A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x00A8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UConditionalDamageModifier*>     ConditionalDamageModifiers;                        // 0x00B0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bApplyUpwardForce;                                 // 0x00C0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpwardForceScalar;                                 // 0x00C4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        ImpactForceSelection;                              // 0x00C8(0x0020)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GoreModifier;                                      // 0x00E8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GibModifier;                                       // 0x00EC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImpactForceFallsOff;                              // 0x00F0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HitRotationOffset;                                 // 0x00F4(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSimulatedOnClients;                               // 0x0100(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceNoCrit;                                      // 0x0101(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeExecutedAsync;                               // 0x0102(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_103[0x1];                                      // 0x0103(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAsyncExecutionDeferTime;                        // 0x0104(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitStartSocketOrBone;                              // 0x0108(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseTransformComesFromActorTransform;             // 0x0110(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitStartOffset;                                    // 0x0114(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HitStartRotationOffset;                            // 0x0120(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttitudeDamageRules                   AttitudeDamageRules;                               // 0x012C(0x0004)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnforceAttitudeRulesForHealing;                   // 0x0130(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanHurtSelf;                                      // 0x0131(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanHurtInstigator;                                // 0x0132(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x1];                                      // 0x0133(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCausesDamageOverTime : 1;                         // 0x0134(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowMultipleInstances : 1;                       // 0x0134(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHitEachTargetOnlyOnce : 1;                        // 0x0134(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCacheSourceLocationAndRotation : 1;               // 0x0134(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDamageDuration;                                 // 0x0138(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInterval;                                    // 0x013C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelDamageOverTimeWhenOwnerDies;                // 0x0140(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        DamageOverTimeParticleSystem;                      // 0x0148(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            DamageOverTimeAudioEventStart;                     // 0x0150(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            DamageOverTimeAudioEventStop;                      // 0x0158(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          InstigatorFeedback;                                // 0x0160(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFeedbackData*>                  TargetFeedbacks;                                   // 0x0168(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x0178(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExplosionData*                         ExplosionData;                                     // 0x0180(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DefaultExplosionParticles;                         // 0x0188(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxSignificanceEvent                  SignificanceEvent;                                 // 0x0190(0x0008)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            DefaultAudioEvent;                                 // 0x0198(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            DefaultExplosionImpactData;                        // 0x01A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DefaultExplosionDecalOverride;                     // 0x01A8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExplosionSizeForDecal;                         // 0x01B0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyDrawParticleIfFacingDamage;                   // 0x01B1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B2[0x6];                                      // 0x01B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenParticleInitParams              ScreenParticleParams;                              // 0x01B8(0x0030)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            PlayerAudioEvent;                                  // 0x01E8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x8];                                      // 0x01F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitAnyAttitude(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details) const;
	void OnHitEnemy(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details) const;
	void OnHitFriendly(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details) const;
	void OnKilledEnemy(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageData">();
	}
	static class UDamageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageData>();
	}
};
static_assert(alignof(UDamageData) == 0x000008, "Wrong alignment on UDamageData");
static_assert(sizeof(UDamageData) == 0x0001F8, "Wrong size on UDamageData");
static_assert(offsetof(UDamageData, Damage) == 0x000028, "Member 'UDamageData::Damage' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageMultiplier) == 0x000060, "Member 'UDamageData::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageAreaType) == 0x000098, "Member 'UDamageData::DamageAreaType' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageSource) == 0x0000A0, "Member 'UDamageData::DamageSource' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageType) == 0x0000A8, "Member 'UDamageData::DamageType' has a wrong offset!");
static_assert(offsetof(UDamageData, ConditionalDamageModifiers) == 0x0000B0, "Member 'UDamageData::ConditionalDamageModifiers' has a wrong offset!");
static_assert(offsetof(UDamageData, bApplyUpwardForce) == 0x0000C0, "Member 'UDamageData::bApplyUpwardForce' has a wrong offset!");
static_assert(offsetof(UDamageData, UpwardForceScalar) == 0x0000C4, "Member 'UDamageData::UpwardForceScalar' has a wrong offset!");
static_assert(offsetof(UDamageData, ImpactForceSelection) == 0x0000C8, "Member 'UDamageData::ImpactForceSelection' has a wrong offset!");
static_assert(offsetof(UDamageData, GoreModifier) == 0x0000E8, "Member 'UDamageData::GoreModifier' has a wrong offset!");
static_assert(offsetof(UDamageData, GibModifier) == 0x0000EC, "Member 'UDamageData::GibModifier' has a wrong offset!");
static_assert(offsetof(UDamageData, bImpactForceFallsOff) == 0x0000F0, "Member 'UDamageData::bImpactForceFallsOff' has a wrong offset!");
static_assert(offsetof(UDamageData, HitRotationOffset) == 0x0000F4, "Member 'UDamageData::HitRotationOffset' has a wrong offset!");
static_assert(offsetof(UDamageData, bSimulatedOnClients) == 0x000100, "Member 'UDamageData::bSimulatedOnClients' has a wrong offset!");
static_assert(offsetof(UDamageData, bForceNoCrit) == 0x000101, "Member 'UDamageData::bForceNoCrit' has a wrong offset!");
static_assert(offsetof(UDamageData, bCanBeExecutedAsync) == 0x000102, "Member 'UDamageData::bCanBeExecutedAsync' has a wrong offset!");
static_assert(offsetof(UDamageData, MaxAsyncExecutionDeferTime) == 0x000104, "Member 'UDamageData::MaxAsyncExecutionDeferTime' has a wrong offset!");
static_assert(offsetof(UDamageData, HitStartSocketOrBone) == 0x000108, "Member 'UDamageData::HitStartSocketOrBone' has a wrong offset!");
static_assert(offsetof(UDamageData, bBaseTransformComesFromActorTransform) == 0x000110, "Member 'UDamageData::bBaseTransformComesFromActorTransform' has a wrong offset!");
static_assert(offsetof(UDamageData, HitStartOffset) == 0x000114, "Member 'UDamageData::HitStartOffset' has a wrong offset!");
static_assert(offsetof(UDamageData, HitStartRotationOffset) == 0x000120, "Member 'UDamageData::HitStartRotationOffset' has a wrong offset!");
static_assert(offsetof(UDamageData, AttitudeDamageRules) == 0x00012C, "Member 'UDamageData::AttitudeDamageRules' has a wrong offset!");
static_assert(offsetof(UDamageData, bEnforceAttitudeRulesForHealing) == 0x000130, "Member 'UDamageData::bEnforceAttitudeRulesForHealing' has a wrong offset!");
static_assert(offsetof(UDamageData, bCanHurtSelf) == 0x000131, "Member 'UDamageData::bCanHurtSelf' has a wrong offset!");
static_assert(offsetof(UDamageData, bCanHurtInstigator) == 0x000132, "Member 'UDamageData::bCanHurtInstigator' has a wrong offset!");
static_assert(offsetof(UDamageData, MaxDamageDuration) == 0x000138, "Member 'UDamageData::MaxDamageDuration' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageInterval) == 0x00013C, "Member 'UDamageData::DamageInterval' has a wrong offset!");
static_assert(offsetof(UDamageData, bCancelDamageOverTimeWhenOwnerDies) == 0x000140, "Member 'UDamageData::bCancelDamageOverTimeWhenOwnerDies' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageOverTimeParticleSystem) == 0x000148, "Member 'UDamageData::DamageOverTimeParticleSystem' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageOverTimeAudioEventStart) == 0x000150, "Member 'UDamageData::DamageOverTimeAudioEventStart' has a wrong offset!");
static_assert(offsetof(UDamageData, DamageOverTimeAudioEventStop) == 0x000158, "Member 'UDamageData::DamageOverTimeAudioEventStop' has a wrong offset!");
static_assert(offsetof(UDamageData, InstigatorFeedback) == 0x000160, "Member 'UDamageData::InstigatorFeedback' has a wrong offset!");
static_assert(offsetof(UDamageData, TargetFeedbacks) == 0x000168, "Member 'UDamageData::TargetFeedbacks' has a wrong offset!");
static_assert(offsetof(UDamageData, ImpactData) == 0x000178, "Member 'UDamageData::ImpactData' has a wrong offset!");
static_assert(offsetof(UDamageData, ExplosionData) == 0x000180, "Member 'UDamageData::ExplosionData' has a wrong offset!");
static_assert(offsetof(UDamageData, DefaultExplosionParticles) == 0x000188, "Member 'UDamageData::DefaultExplosionParticles' has a wrong offset!");
static_assert(offsetof(UDamageData, SignificanceEvent) == 0x000190, "Member 'UDamageData::SignificanceEvent' has a wrong offset!");
static_assert(offsetof(UDamageData, DefaultAudioEvent) == 0x000198, "Member 'UDamageData::DefaultAudioEvent' has a wrong offset!");
static_assert(offsetof(UDamageData, DefaultExplosionImpactData) == 0x0001A0, "Member 'UDamageData::DefaultExplosionImpactData' has a wrong offset!");
static_assert(offsetof(UDamageData, DefaultExplosionDecalOverride) == 0x0001A8, "Member 'UDamageData::DefaultExplosionDecalOverride' has a wrong offset!");
static_assert(offsetof(UDamageData, bUseExplosionSizeForDecal) == 0x0001B0, "Member 'UDamageData::bUseExplosionSizeForDecal' has a wrong offset!");
static_assert(offsetof(UDamageData, bOnlyDrawParticleIfFacingDamage) == 0x0001B1, "Member 'UDamageData::bOnlyDrawParticleIfFacingDamage' has a wrong offset!");
static_assert(offsetof(UDamageData, ScreenParticleParams) == 0x0001B8, "Member 'UDamageData::ScreenParticleParams' has a wrong offset!");
static_assert(offsetof(UDamageData, PlayerAudioEvent) == 0x0001E8, "Member 'UDamageData::PlayerAudioEvent' has a wrong offset!");

// Class GbxGameSystemCore.SceneBodySwitchManagerComponent
// 0x0000 (0x0178 - 0x0178)
class USceneBodySwitchManagerComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneBodySwitchManagerComponent">();
	}
	static class USceneBodySwitchManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneBodySwitchManagerComponent>();
	}
};
static_assert(alignof(USceneBodySwitchManagerComponent) == 0x000008, "Wrong alignment on USceneBodySwitchManagerComponent");
static_assert(sizeof(USceneBodySwitchManagerComponent) == 0x000178, "Wrong size on USceneBodySwitchManagerComponent");

// Class GbxGameSystemCore.ChallengeManager
// 0x00C0 (0x0518 - 0x0458)
class AChallengeManager : public AActor
{
public:
	uint8                                         Pad_458[0xC0];                                     // 0x0458(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatIncrement(class AActor* StatContext, class UGameStatData* StatId, int32 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeManager">();
	}
	static class AChallengeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallengeManager>();
	}
};
static_assert(alignof(AChallengeManager) == 0x000008, "Wrong alignment on AChallengeManager");
static_assert(sizeof(AChallengeManager) == 0x000518, "Wrong size on AChallengeManager");

// Class GbxGameSystemCore.ProjectileHomingComponent
// 0x00B0 (0x0228 - 0x0178)
class UProjectileHomingComponent : public UActorComponent
{
public:
	bool                                          bMoveDirectlyToTarget;                             // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnSpeed;                                         // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeTurnSpeed;                                  // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalTurnSpeed;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAcceleration;                                  // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrueTargetDistance;                                // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrueTargetTime;                                    // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideHomingSpeed;                               // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationScale;                                 // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HomingTarget;                                      // 0x01A0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        HomingTargetComponent;                             // 0x01A8(0x0008)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HomingSocketOverride;                              // 0x01B0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HomingTargetLocation;                              // 0x01B8(0x000C)(Edit, BlueprintVisible, Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachDistance;                                     // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachDistanceSquared;                              // 0x01C8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HomingTargetLocalOffset;                           // 0x01CC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopHomingDistance;                                // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStopHomingDistanceReached;                       // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReachedTargetLocation;                           // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHomeIn;                                           // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Projectile;                                        // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModifyDefault;                                    // 0x0218(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0xF];                                      // 0x0219(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetHomingLocation();
	void SetAssociatedProjectileMovement(class UProjectileMovementComponent* ProjectileMovementComponent);
	void SetHomeIn(bool bEnabled);
	void ToggleHoming();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileHomingComponent">();
	}
	static class UProjectileHomingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileHomingComponent>();
	}
};
static_assert(alignof(UProjectileHomingComponent) == 0x000008, "Wrong alignment on UProjectileHomingComponent");
static_assert(sizeof(UProjectileHomingComponent) == 0x000228, "Wrong size on UProjectileHomingComponent");
static_assert(offsetof(UProjectileHomingComponent, bMoveDirectlyToTarget) == 0x000178, "Member 'UProjectileHomingComponent::bMoveDirectlyToTarget' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, TurnSpeed) == 0x00017C, "Member 'UProjectileHomingComponent::TurnSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, bChangeTurnSpeed) == 0x000180, "Member 'UProjectileHomingComponent::bChangeTurnSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, FinalTurnSpeed) == 0x000184, "Member 'UProjectileHomingComponent::FinalTurnSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, TurnAcceleration) == 0x000188, "Member 'UProjectileHomingComponent::TurnAcceleration' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, TrueTargetDistance) == 0x00018C, "Member 'UProjectileHomingComponent::TrueTargetDistance' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, TrueTargetTime) == 0x000190, "Member 'UProjectileHomingComponent::TrueTargetTime' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, OverrideHomingSpeed) == 0x000194, "Member 'UProjectileHomingComponent::OverrideHomingSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, AccelerationScale) == 0x000198, "Member 'UProjectileHomingComponent::AccelerationScale' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, HomingTarget) == 0x0001A0, "Member 'UProjectileHomingComponent::HomingTarget' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, HomingTargetComponent) == 0x0001A8, "Member 'UProjectileHomingComponent::HomingTargetComponent' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, HomingSocketOverride) == 0x0001B0, "Member 'UProjectileHomingComponent::HomingSocketOverride' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, HomingTargetLocation) == 0x0001B8, "Member 'UProjectileHomingComponent::HomingTargetLocation' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, ReachDistance) == 0x0001C4, "Member 'UProjectileHomingComponent::ReachDistance' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, ReachDistanceSquared) == 0x0001C8, "Member 'UProjectileHomingComponent::ReachDistanceSquared' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, HomingTargetLocalOffset) == 0x0001CC, "Member 'UProjectileHomingComponent::HomingTargetLocalOffset' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, StopHomingDistance) == 0x0001D8, "Member 'UProjectileHomingComponent::StopHomingDistance' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, OnStopHomingDistanceReached) == 0x0001E0, "Member 'UProjectileHomingComponent::OnStopHomingDistanceReached' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, OnReachedTargetLocation) == 0x0001F0, "Member 'UProjectileHomingComponent::OnReachedTargetLocation' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, bHomeIn) == 0x000200, "Member 'UProjectileHomingComponent::bHomeIn' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, ProjectileMovement) == 0x000208, "Member 'UProjectileHomingComponent::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, Projectile) == 0x000210, "Member 'UProjectileHomingComponent::Projectile' has a wrong offset!");
static_assert(offsetof(UProjectileHomingComponent, bModifyDefault) == 0x000218, "Member 'UProjectileHomingComponent::bModifyDefault' has a wrong offset!");

// Class GbxGameSystemCore.DamageBaseComponent
// 0x0050 (0x01C8 - 0x0178)
class UDamageBaseComponent : public UActorComponent
{
public:
	class UTeamComponent*                         CachedTeamComponent;                               // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetableComponent*                   CachedTargetableComponent;                         // 0x0180(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRegisteredConditionalDamageValueModifier> ConditionalValueModifiers;                         // 0x0188(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FRegisteredConditionalDamageCriticalModifier> ConditionalCritModifiers;                          // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UConditionalDamageTypeModifier*> ConditionalTypeModifiers;                          // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UConditionalDamageHitRegionModifier*> ConditionalHitRegionModifiers;                     // 0x01B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageBaseComponent">();
	}
	static class UDamageBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageBaseComponent>();
	}
};
static_assert(alignof(UDamageBaseComponent) == 0x000008, "Wrong alignment on UDamageBaseComponent");
static_assert(sizeof(UDamageBaseComponent) == 0x0001C8, "Wrong size on UDamageBaseComponent");
static_assert(offsetof(UDamageBaseComponent, CachedTeamComponent) == 0x000178, "Member 'UDamageBaseComponent::CachedTeamComponent' has a wrong offset!");
static_assert(offsetof(UDamageBaseComponent, CachedTargetableComponent) == 0x000180, "Member 'UDamageBaseComponent::CachedTargetableComponent' has a wrong offset!");
static_assert(offsetof(UDamageBaseComponent, ConditionalValueModifiers) == 0x000188, "Member 'UDamageBaseComponent::ConditionalValueModifiers' has a wrong offset!");
static_assert(offsetof(UDamageBaseComponent, ConditionalCritModifiers) == 0x000198, "Member 'UDamageBaseComponent::ConditionalCritModifiers' has a wrong offset!");
static_assert(offsetof(UDamageBaseComponent, ConditionalTypeModifiers) == 0x0001A8, "Member 'UDamageBaseComponent::ConditionalTypeModifiers' has a wrong offset!");
static_assert(offsetof(UDamageBaseComponent, ConditionalHitRegionModifiers) == 0x0001B8, "Member 'UDamageBaseComponent::ConditionalHitRegionModifiers' has a wrong offset!");

// Class GbxGameSystemCore.DamageCauserComponent
// 0x0128 (0x02F0 - 0x01C8)
class UDamageCauserComponent : public UDamageBaseComponent
{
public:
	uint8                                         Pad_1C8[0x20];                                     // 0x01C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCausedAnyDamage;                                 // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCausedDeath;                                     // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCausedHealing;                                   // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHitFriendly;                                     // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EDamageCausedModificationStrategy             DefaultModificationContextStrategy;                // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttitudeDamageRules                   AttitudeDamageRules;                               // 0x0244(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanHurtSelf;                                      // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     StatusEffectChanceModifierScalar;                  // 0x024C(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     StatusEffectDamageModifierScalar;                  // 0x0258(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     StatusEffectDurationModifierScalar;                // 0x0264(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStatusEffectModifiers>         StatusEffectModifiers;                             // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     DamageDealtMultiplier;                             // 0x0280(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     RadiusDamage_RadiusMultiplier;                     // 0x028C(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     RadiusDamage_DamageMultiplier;                     // 0x0298(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeInteger                   ShouldIgnoreEnemyElementalResistance;              // 0x02A4(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyInstigatorSkillDamageModifier;               // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     DefaultCriticalHitMultiplier;                      // 0x02B4(0x000C)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UConditionalDamageModifier*>     DefaultConditionalDamageModifiers;                 // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         EnemyReflectionChance;                             // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReflectedDamageParams                 EnemyReflectionParams;                             // 0x02D8(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void RegisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier);
	void UnregisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCauserComponent">();
	}
	static class UDamageCauserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageCauserComponent>();
	}
};
static_assert(alignof(UDamageCauserComponent) == 0x000008, "Wrong alignment on UDamageCauserComponent");
static_assert(sizeof(UDamageCauserComponent) == 0x0002F0, "Wrong size on UDamageCauserComponent");
static_assert(offsetof(UDamageCauserComponent, OnCausedAnyDamage) == 0x0001E8, "Member 'UDamageCauserComponent::OnCausedAnyDamage' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, OnCausedDeath) == 0x0001F8, "Member 'UDamageCauserComponent::OnCausedDeath' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, OnCausedHealing) == 0x000220, "Member 'UDamageCauserComponent::OnCausedHealing' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, OnHitFriendly) == 0x000230, "Member 'UDamageCauserComponent::OnHitFriendly' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, DefaultModificationContextStrategy) == 0x000240, "Member 'UDamageCauserComponent::DefaultModificationContextStrategy' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, AttitudeDamageRules) == 0x000244, "Member 'UDamageCauserComponent::AttitudeDamageRules' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, bCanHurtSelf) == 0x000248, "Member 'UDamageCauserComponent::bCanHurtSelf' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, StatusEffectChanceModifierScalar) == 0x00024C, "Member 'UDamageCauserComponent::StatusEffectChanceModifierScalar' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, StatusEffectDamageModifierScalar) == 0x000258, "Member 'UDamageCauserComponent::StatusEffectDamageModifierScalar' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, StatusEffectDurationModifierScalar) == 0x000264, "Member 'UDamageCauserComponent::StatusEffectDurationModifierScalar' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, StatusEffectModifiers) == 0x000270, "Member 'UDamageCauserComponent::StatusEffectModifiers' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, DamageDealtMultiplier) == 0x000280, "Member 'UDamageCauserComponent::DamageDealtMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, RadiusDamage_RadiusMultiplier) == 0x00028C, "Member 'UDamageCauserComponent::RadiusDamage_RadiusMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, RadiusDamage_DamageMultiplier) == 0x000298, "Member 'UDamageCauserComponent::RadiusDamage_DamageMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, ShouldIgnoreEnemyElementalResistance) == 0x0002A4, "Member 'UDamageCauserComponent::ShouldIgnoreEnemyElementalResistance' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, bApplyInstigatorSkillDamageModifier) == 0x0002B0, "Member 'UDamageCauserComponent::bApplyInstigatorSkillDamageModifier' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, DefaultCriticalHitMultiplier) == 0x0002B4, "Member 'UDamageCauserComponent::DefaultCriticalHitMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, DefaultConditionalDamageModifiers) == 0x0002C0, "Member 'UDamageCauserComponent::DefaultConditionalDamageModifiers' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, EnemyReflectionChance) == 0x0002D0, "Member 'UDamageCauserComponent::EnemyReflectionChance' has a wrong offset!");
static_assert(offsetof(UDamageCauserComponent, EnemyReflectionParams) == 0x0002D8, "Member 'UDamageCauserComponent::EnemyReflectionParams' has a wrong offset!");

// Class GbxGameSystemCore.BlackboardKeyType_GbxFlag
// 0x0000 (0x0030 - 0x0030)
class UBlackboardKeyType_GbxFlag final : public UBlackboardKeyType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackboardKeyType_GbxFlag">();
	}
	static class UBlackboardKeyType_GbxFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackboardKeyType_GbxFlag>();
	}
};
static_assert(alignof(UBlackboardKeyType_GbxFlag) == 0x000008, "Wrong alignment on UBlackboardKeyType_GbxFlag");
static_assert(sizeof(UBlackboardKeyType_GbxFlag) == 0x000030, "Wrong size on UBlackboardKeyType_GbxFlag");

// Class GbxGameSystemCore.ChallengeList
// 0x0018 (0x0048 - 0x0030)
class UChallengeList : public UGbxDataAsset
{
public:
	class UDownloadableContentData*               AssociatedDLC;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           Challenges;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeList">();
	}
	static class UChallengeList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeList>();
	}
};
static_assert(alignof(UChallengeList) == 0x000008, "Wrong alignment on UChallengeList");
static_assert(sizeof(UChallengeList) == 0x000048, "Wrong size on UChallengeList");
static_assert(offsetof(UChallengeList, AssociatedDLC) == 0x000030, "Member 'UChallengeList::AssociatedDLC' has a wrong offset!");
static_assert(offsetof(UChallengeList, Challenges) == 0x000038, "Member 'UChallengeList::Challenges' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_IsBlackboardTarget
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_IsBlackboardTarget final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsBlackboardTarget">();
	}
	static class UGbxCondition_IsBlackboardTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsBlackboardTarget>();
	}
};
static_assert(alignof(UGbxCondition_IsBlackboardTarget) == 0x000008, "Wrong alignment on UGbxCondition_IsBlackboardTarget");
static_assert(sizeof(UGbxCondition_IsBlackboardTarget) == 0x000088, "Wrong size on UGbxCondition_IsBlackboardTarget");

// Class GbxGameSystemCore.AchievementUtility
// 0x0000 (0x0028 - 0x0028)
class UAchievementUtility : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementUtility">();
	}
	static class UAchievementUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementUtility>();
	}
};
static_assert(alignof(UAchievementUtility) == 0x000008, "Wrong alignment on UAchievementUtility");
static_assert(sizeof(UAchievementUtility) == 0x000028, "Wrong size on UAchievementUtility");

// Class GbxGameSystemCore.LadderInterface
// 0x0000 (0x0028 - 0x0028)
class ILadderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderInterface">();
	}
	static class ILadderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILadderInterface>();
	}
};
static_assert(alignof(ILadderInterface) == 0x000008, "Wrong alignment on ILadderInterface");
static_assert(sizeof(ILadderInterface) == 0x000028, "Wrong size on ILadderInterface");

// Class GbxGameSystemCore.GbxPlayerCameraManager
// 0x0010 (0x2C80 - 0x2C70)
class AGbxPlayerCameraManager : public APlayerCameraManager
{
public:
	class AGbxPlayerController*                   GbxPCOwner;                                        // 0x2C68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C70[0x10];                                    // 0x2C70(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPlayerCameraManager">();
	}
	static class AGbxPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxPlayerCameraManager>();
	}
};
static_assert(alignof(AGbxPlayerCameraManager) == 0x000010, "Wrong alignment on AGbxPlayerCameraManager");
static_assert(sizeof(AGbxPlayerCameraManager) == 0x002C80, "Wrong size on AGbxPlayerCameraManager");
static_assert(offsetof(AGbxPlayerCameraManager, GbxPCOwner) == 0x002C68, "Member 'AGbxPlayerCameraManager::GbxPCOwner' has a wrong offset!");

// Class GbxGameSystemCore.StanceType
// 0x0000 (0x0030 - 0x0030)
class UStanceType final : public UStanceDataProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceType">();
	}
	static class UStanceType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceType>();
	}
};
static_assert(alignof(UStanceType) == 0x000008, "Wrong alignment on UStanceType");
static_assert(sizeof(UStanceType) == 0x000030, "Wrong size on UStanceType");

// Class GbxGameSystemCore.CustomChallengePersistentState
// 0x0000 (0x0028 - 0x0028)
class UCustomChallengePersistentState : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomChallengePersistentState">();
	}
	static class UCustomChallengePersistentState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomChallengePersistentState>();
	}
};
static_assert(alignof(UCustomChallengePersistentState) == 0x000008, "Wrong alignment on UCustomChallengePersistentState");
static_assert(sizeof(UCustomChallengePersistentState) == 0x000028, "Wrong size on UCustomChallengePersistentState");

// Class GbxGameSystemCore.UIStatData_Numeric
// 0x01B8 (0x0220 - 0x0068)
class UUIStatData_Numeric : public UUIStatData
{
public:
	EUIStatValueStyle                             ValueStyle;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIStatValueSignStyle                         SignStyle;                                         // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIStatValueRoundingMode                      RoundingMode;                                      // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x1];                                       // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDisplayAsPercentage : 1;                          // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayPercentAsFloat : 1;                        // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayAsInverse : 1;                             // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayPlusSign : 1;                              // 0x006C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayAsOneMinus : 1;                            // 0x006C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCalculateWithReductionMath : 1;                   // 0x006C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFormatText : 1;                                // 0x006C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableValueRemapping : 1;                         // 0x006C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSupplementalStatFormatText : 1;                // 0x006D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMinValueCondition : 1;                         // 0x006D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMaxValueCondition : 1;                         // 0x006D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMinOrMaxValueCondition : 1;                       // 0x006D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           MinValueCondition;                                 // 0x0070(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MaxValueCondition;                                 // 0x00A8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x00E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        FloatPrecision;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FormatText;                                        // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FUIStatValueRemappingData              ValueRemapping;                                    // 0x0108(0x00E8)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UUIStatData_Numeric*                    SupplementalStat;                                  // 0x01F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIStatCombinationMethod                      SupplementalStatCombinationMethod;                 // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          SupplementalStatCondition;                         // 0x0200(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SupplementalStatFormatText;                        // 0x0208(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatData_Numeric">();
	}
	static class UUIStatData_Numeric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatData_Numeric>();
	}
};
static_assert(alignof(UUIStatData_Numeric) == 0x000008, "Wrong alignment on UUIStatData_Numeric");
static_assert(sizeof(UUIStatData_Numeric) == 0x000220, "Wrong size on UUIStatData_Numeric");
static_assert(offsetof(UUIStatData_Numeric, ValueStyle) == 0x000068, "Member 'UUIStatData_Numeric::ValueStyle' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, SignStyle) == 0x000069, "Member 'UUIStatData_Numeric::SignStyle' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, RoundingMode) == 0x00006A, "Member 'UUIStatData_Numeric::RoundingMode' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, MinValueCondition) == 0x000070, "Member 'UUIStatData_Numeric::MinValueCondition' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, MaxValueCondition) == 0x0000A8, "Member 'UUIStatData_Numeric::MaxValueCondition' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, Condition) == 0x0000E0, "Member 'UUIStatData_Numeric::Condition' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, FloatPrecision) == 0x0000E8, "Member 'UUIStatData_Numeric::FloatPrecision' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, FormatText) == 0x0000F0, "Member 'UUIStatData_Numeric::FormatText' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, ValueRemapping) == 0x000108, "Member 'UUIStatData_Numeric::ValueRemapping' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, SupplementalStat) == 0x0001F0, "Member 'UUIStatData_Numeric::SupplementalStat' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, SupplementalStatCombinationMethod) == 0x0001F8, "Member 'UUIStatData_Numeric::SupplementalStatCombinationMethod' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, SupplementalStatCondition) == 0x000200, "Member 'UUIStatData_Numeric::SupplementalStatCondition' has a wrong offset!");
static_assert(offsetof(UUIStatData_Numeric, SupplementalStatFormatText) == 0x000208, "Member 'UUIStatData_Numeric::SupplementalStatFormatText' has a wrong offset!");

// Class GbxGameSystemCore.PhysicalAnimationProfileAsset
// 0x0018 (0x0048 - 0x0030)
class UPhysicalAnimationProfileAsset final : public UGbxDataAsset
{
public:
	TArray<struct FPhysicalAnimationBoneData>     BoneData;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EPhysicalAnimationBlendToKinematicMode        DynamicToKinematicBlendMode;                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalAnimationProfileAsset">();
	}
	static class UPhysicalAnimationProfileAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalAnimationProfileAsset>();
	}
};
static_assert(alignof(UPhysicalAnimationProfileAsset) == 0x000008, "Wrong alignment on UPhysicalAnimationProfileAsset");
static_assert(sizeof(UPhysicalAnimationProfileAsset) == 0x000048, "Wrong size on UPhysicalAnimationProfileAsset");
static_assert(offsetof(UPhysicalAnimationProfileAsset, BoneData) == 0x000030, "Member 'UPhysicalAnimationProfileAsset::BoneData' has a wrong offset!");
static_assert(offsetof(UPhysicalAnimationProfileAsset, DynamicToKinematicBlendMode) == 0x000040, "Member 'UPhysicalAnimationProfileAsset::DynamicToKinematicBlendMode' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_Gib
// 0x01A0 (0x0200 - 0x0060)
#pragma pack(push, 0x1)
class alignas(0x10) UGbxAction_Gib : public UGbxAction
{
public:
	int32                                         MaxGibCount;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGibData>                       Gibs;                                              // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         GibMinScale;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GibMaxScale;                                       // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpawnPatternData*                      GibSpawnPattern;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GibMassScale;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     GibActorClass;                                     // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpactResponseEffect                  GibEffect;                                         // 0x00A0(0x0140)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         GibEffectScale;                                    // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        GibParticle;                                       // 0x01E8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWwiseEvent*                            GibSound;                                          // 0x01F0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_Gib">();
	}
	static class UGbxAction_Gib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_Gib>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxAction_Gib) == 0x000010, "Wrong alignment on UGbxAction_Gib");
static_assert(sizeof(UGbxAction_Gib) == 0x000200, "Wrong size on UGbxAction_Gib");
static_assert(offsetof(UGbxAction_Gib, MaxGibCount) == 0x000060, "Member 'UGbxAction_Gib::MaxGibCount' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, Gibs) == 0x000068, "Member 'UGbxAction_Gib::Gibs' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibMinScale) == 0x000078, "Member 'UGbxAction_Gib::GibMinScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibMaxScale) == 0x00007C, "Member 'UGbxAction_Gib::GibMaxScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibSpawnPattern) == 0x000080, "Member 'UGbxAction_Gib::GibSpawnPattern' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibMassScale) == 0x000088, "Member 'UGbxAction_Gib::GibMassScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibActorClass) == 0x000090, "Member 'UGbxAction_Gib::GibActorClass' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibEffect) == 0x0000A0, "Member 'UGbxAction_Gib::GibEffect' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibEffectScale) == 0x0001E0, "Member 'UGbxAction_Gib::GibEffectScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibParticle) == 0x0001E8, "Member 'UGbxAction_Gib::GibParticle' has a wrong offset!");
static_assert(offsetof(UGbxAction_Gib, GibSound) == 0x0001F0, "Member 'UGbxAction_Gib::GibSound' has a wrong offset!");

// Class GbxGameSystemCore.HealthResourcePoolModifierAttributeValueResolver
// 0x0008 (0x0030 - 0x0028)
class UHealthResourcePoolModifierAttributeValueResolver final : public UAttributeValueResolver
{
public:
	class UGameResourcePoolData*                  HealthResourcePool;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthResourcePoolModifierAttributeValueResolver">();
	}
	static class UHealthResourcePoolModifierAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthResourcePoolModifierAttributeValueResolver>();
	}
};
static_assert(alignof(UHealthResourcePoolModifierAttributeValueResolver) == 0x000008, "Wrong alignment on UHealthResourcePoolModifierAttributeValueResolver");
static_assert(sizeof(UHealthResourcePoolModifierAttributeValueResolver) == 0x000030, "Wrong size on UHealthResourcePoolModifierAttributeValueResolver");
static_assert(offsetof(UHealthResourcePoolModifierAttributeValueResolver, HealthResourcePool) == 0x000028, "Member 'UHealthResourcePoolModifierAttributeValueResolver::HealthResourcePool' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_Loop
// 0x0300 (0x03B8 - 0x00B8)
class UGbxAction_Loop : public UGbxAction_SimpleAnim
{
public:
	struct FAnimMeshList                          AnimStart;                                         // 0x00B8(0x0078)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FWeightedAnim>                  AnimLoopList;                                      // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FAnimMeshList                          AnimStop;                                          // 0x0140(0x0078)(Edit, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartToLoopBlendTime;                              // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopToLoopBlendTime;                               // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopToStopBlendTime;                               // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimSlot;                                          // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLetLoopFinish;                                    // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              LoopCount;                                         // 0x01E0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseLoopCount;                                     // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              LoopTime;                                          // 0x0268(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseLoopTime;                                      // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          LoopCondition;                                     // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLoopCondition;                                 // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoopAnimData                          AnimData3rd;                                       // 0x0300(0x0018)(Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bPlay3rd;                                          // 0x0318(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoopAnimData                          AnimData1st;                                       // 0x0320(0x0018)(Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bPlay1st;                                          // 0x0338(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimMeshList                          AnimLoop;                                          // 0x0340(0x0078)(Deprecated, NativeAccessSpecifierPrivate)

public:
	void OnLoop(class AActor* Actor);
	void OnStop(class AActor* Actor);

	void K2_StopLooping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_Loop">();
	}
	static class UGbxAction_Loop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_Loop>();
	}
};
static_assert(alignof(UGbxAction_Loop) == 0x000008, "Wrong alignment on UGbxAction_Loop");
static_assert(sizeof(UGbxAction_Loop) == 0x0003B8, "Wrong size on UGbxAction_Loop");
static_assert(offsetof(UGbxAction_Loop, AnimStart) == 0x0000B8, "Member 'UGbxAction_Loop::AnimStart' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, AnimLoopList) == 0x000130, "Member 'UGbxAction_Loop::AnimLoopList' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, AnimStop) == 0x000140, "Member 'UGbxAction_Loop::AnimStop' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, BlendInTime) == 0x0001B8, "Member 'UGbxAction_Loop::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, BlendOutTime) == 0x0001BC, "Member 'UGbxAction_Loop::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, StartToLoopBlendTime) == 0x0001C0, "Member 'UGbxAction_Loop::StartToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, LoopToLoopBlendTime) == 0x0001C4, "Member 'UGbxAction_Loop::LoopToLoopBlendTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, LoopToStopBlendTime) == 0x0001C8, "Member 'UGbxAction_Loop::LoopToStopBlendTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, AnimSlot) == 0x0001D0, "Member 'UGbxAction_Loop::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, bLetLoopFinish) == 0x0001D8, "Member 'UGbxAction_Loop::bLetLoopFinish' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, LoopCount) == 0x0001E0, "Member 'UGbxAction_Loop::LoopCount' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, bUseLoopCount) == 0x000260, "Member 'UGbxAction_Loop::bUseLoopCount' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, LoopTime) == 0x000268, "Member 'UGbxAction_Loop::LoopTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, bUseLoopTime) == 0x0002E8, "Member 'UGbxAction_Loop::bUseLoopTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, LoopCondition) == 0x0002F0, "Member 'UGbxAction_Loop::LoopCondition' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, bUseLoopCondition) == 0x0002F8, "Member 'UGbxAction_Loop::bUseLoopCondition' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, AnimData3rd) == 0x000300, "Member 'UGbxAction_Loop::AnimData3rd' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, bPlay3rd) == 0x000318, "Member 'UGbxAction_Loop::bPlay3rd' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, AnimData1st) == 0x000320, "Member 'UGbxAction_Loop::AnimData1st' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, bPlay1st) == 0x000338, "Member 'UGbxAction_Loop::bPlay1st' has a wrong offset!");
static_assert(offsetof(UGbxAction_Loop, AnimLoop) == 0x000340, "Member 'UGbxAction_Loop::AnimLoop' has a wrong offset!");

// Class GbxGameSystemCore.AimAssistParameters
// 0x0000 (0x0030 - 0x0030)
class UAimAssistParameters : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistParameters">();
	}
	static class UAimAssistParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistParameters>();
	}
};
static_assert(alignof(UAimAssistParameters) == 0x000008, "Wrong alignment on UAimAssistParameters");
static_assert(sizeof(UAimAssistParameters) == 0x000030, "Wrong size on UAimAssistParameters");

// Class GbxGameSystemCore.GbxPlayerController
// 0x0150 (0x0980 - 0x0830)
class AGbxPlayerController : public APlayerController
{
public:
	uint8                                         Pad_830[0x10];                                     // 0x0830(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxCharacter*                          GbxCharacter;                                      // 0x0840(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGbxCharacter*                          PrimaryCharacter;                                  // 0x0848(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URecentDamageTrackingComponent*         RecentDamageTrackingComponent;                     // 0x0850(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxProfile*                            CurrentProfile;                                    // 0x0858(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInputComponent>            InputComponentClass;                               // 0x0860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlayerInput>               PlayerInputClass;                                  // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAimAssistStrategy>         AimAssistStrategyClass;                            // 0x0870(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         CheatClassGbx;                                     // 0x0878(0x0018)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_890[0x30];                                     // 0x0890(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPrimaryCharacterChanged;                         // 0x08C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPauseChanged;                                    // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E0[0x28];                                     // 0x08E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxGlyphSetOption                            CachedGlyphMode;                                   // 0x0908(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_909[0x7];                                      // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetingComponent*                    TargetingComponent;                                // 0x0910(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetableComponent*                   TargetableComponent;                               // 0x0918(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTeamComponent*                         TeamComponent;                                     // 0x0920(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxPerceptionComponent*                PerceptionComponent;                               // 0x0928(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFirstPersonComponent*                  FirstPersonComponent;                              // 0x0930(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimAssistStrategy*                     AimAssistStrategy;                                 // 0x0938(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWwiseListenerComponent*                WwiseListener;                                     // 0x0940(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FActiveTrackedFeedback>         ActiveTrackedFeedbacks;                            // 0x0948(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bUsingGamepad;                                     // 0x0958(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_959[0x7];                                      // 0x0959(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCinematicModeData*>             CinematicModeStack;                                // 0x0960(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCinematicModeData*                     CinematicMode;                                     // 0x0970(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScreenParticleManagerComponent*        ScreenParticleManagerComponent;                    // 0x0978(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearAndSetCinematicMode(class UCinematicModeData* InCinematicMode);
	void ClearCinematicMode();
	void Client_PlayGbxFeedback(const class UGbxFeedbackData* Data, bool bIs3D, bool bLoop, float Scale, class UObject* SourceContext, const struct FVector& SourceLocation, float EffectFalloffMinDistance, float EffectFalloffMaxDistance);
	void Client_StopGbxFeedback(const class UGbxFeedbackData* Data, class UObject* SourceContext);
	void ClientApplyDamageDataPresentation(const class UDamageData* DamageData, const struct FPlayerDamageDataPresentation& PlayerPresentation);
	void ClientCanSplitscreenJoin(int32 ControllerId, bool bCanJoin);
	void ClientNotifyActivateCheckpoint();
	void ClientPerformFeedback(class UFeedbackData* FeedbackData, class UObject* SourceContext);
	void ClientPerformFeedbackAtLocation(class UFeedbackData* FeedbackData, const struct FVector& SourceLocation, bool bLoop, class UObject* SourceContext, const struct FRangedDistanceOverrides& RangedOverrides);
	void ClientPlayFeedback(class UFeedbackData* Data, float Scale, bool bLoop, class UObject* SourceContext);
	void ClientPlayWwiseEvent(class UWwiseEvent* Event);
	void ClientStopFeedback(class UFeedbackData* Data);
	void DebugCategory(class FName CategoryName);
	void OnPausedChangedDelegate__DelegateSignature(bool bPaused);
	void OnPrimaryCharacterChanged__DelegateSignature(class AGbxCharacter* NewCharacter);
	void OnRep_CinematicMode();
	void OnRep_PrimaryCharacter();
	void PopCinematicMode(class UCinematicModeData* InCinematicMode);
	void PushCinematicMode(class UCinematicModeData* InCinematicMode);
	void ServerCanSplitscreenJoin(int32 ControllerId);
	void ServerRequestPawnSlotDetach(class APawn* Occupant);

	bool DeprojectViewportPositionToWorld(float ViewportX, float ViewportY, struct FVector* WorldLocation, struct FVector* WorldDirection, bool bUseForegroundProjection) const;
	class UGbxPerceptionComponent* GetGbxPerceptionComponent() const;
	class UGbxProfile* GetPlayerProfile() const;
	void GetPlayerViewportOffset(int32* OffsetX, int32* OffsetY) const;
	void GetPlayerViewportSize(int32* SizeX, int32* SizeY) const;
	class AGbxCharacter* GetPrimaryCharacter() const;
	class UTargetableComponent* GetTargetableComponent() const;
	class UTargetingComponent* GetTargetingComponent() const;
	class UTeam* GetTeam() const;
	class UTeamComponent* GetTeamComponent() const;
	bool IsUsingGamepad() const;
	void SetTeam(class UTeam* Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPlayerController">();
	}
	static class AGbxPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxPlayerController>();
	}
};
static_assert(alignof(AGbxPlayerController) == 0x000008, "Wrong alignment on AGbxPlayerController");
static_assert(sizeof(AGbxPlayerController) == 0x000980, "Wrong size on AGbxPlayerController");
static_assert(offsetof(AGbxPlayerController, GbxCharacter) == 0x000840, "Member 'AGbxPlayerController::GbxCharacter' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, PrimaryCharacter) == 0x000848, "Member 'AGbxPlayerController::PrimaryCharacter' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, RecentDamageTrackingComponent) == 0x000850, "Member 'AGbxPlayerController::RecentDamageTrackingComponent' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, CurrentProfile) == 0x000858, "Member 'AGbxPlayerController::CurrentProfile' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, InputComponentClass) == 0x000860, "Member 'AGbxPlayerController::InputComponentClass' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, PlayerInputClass) == 0x000868, "Member 'AGbxPlayerController::PlayerInputClass' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, AimAssistStrategyClass) == 0x000870, "Member 'AGbxPlayerController::AimAssistStrategyClass' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, CheatClassGbx) == 0x000878, "Member 'AGbxPlayerController::CheatClassGbx' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, OnPrimaryCharacterChanged) == 0x0008C0, "Member 'AGbxPlayerController::OnPrimaryCharacterChanged' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, OnPauseChanged) == 0x0008D0, "Member 'AGbxPlayerController::OnPauseChanged' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, CachedGlyphMode) == 0x000908, "Member 'AGbxPlayerController::CachedGlyphMode' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, TargetingComponent) == 0x000910, "Member 'AGbxPlayerController::TargetingComponent' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, TargetableComponent) == 0x000918, "Member 'AGbxPlayerController::TargetableComponent' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, TeamComponent) == 0x000920, "Member 'AGbxPlayerController::TeamComponent' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, PerceptionComponent) == 0x000928, "Member 'AGbxPlayerController::PerceptionComponent' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, FirstPersonComponent) == 0x000930, "Member 'AGbxPlayerController::FirstPersonComponent' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, AimAssistStrategy) == 0x000938, "Member 'AGbxPlayerController::AimAssistStrategy' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, WwiseListener) == 0x000940, "Member 'AGbxPlayerController::WwiseListener' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, ActiveTrackedFeedbacks) == 0x000948, "Member 'AGbxPlayerController::ActiveTrackedFeedbacks' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, bUsingGamepad) == 0x000958, "Member 'AGbxPlayerController::bUsingGamepad' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, CinematicModeStack) == 0x000960, "Member 'AGbxPlayerController::CinematicModeStack' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, CinematicMode) == 0x000970, "Member 'AGbxPlayerController::CinematicMode' has a wrong offset!");
static_assert(offsetof(AGbxPlayerController, ScreenParticleManagerComponent) == 0x000978, "Member 'AGbxPlayerController::ScreenParticleManagerComponent' has a wrong offset!");

// Class GbxGameSystemCore.AssetMappingData
// 0x0230 (0x0260 - 0x0030)
class UAssetMappingData : public UGbxDataAsset
{
public:
	TMap<uint32, class FString>                   ChallengesMap;                                     // 0x0030(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<uint32, class FString>                   GameStatDataMap;                                   // 0x0080(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<uint32, class FString>                   CustomizationDataMap;                              // 0x00D0(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<uint32, class FString>                   MissionsMap;                                       // 0x0120(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<uint32, class FString>                   ObjectiveSetsMap;                                  // 0x0170(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<uint32, class FString>                   InventoryCategoryMap;                              // 0x01C0(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<uint32, class FString>                   UINamesMap;                                        // 0x0210(0x0050)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetMappingData">();
	}
	static class UAssetMappingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetMappingData>();
	}
};
static_assert(alignof(UAssetMappingData) == 0x000008, "Wrong alignment on UAssetMappingData");
static_assert(sizeof(UAssetMappingData) == 0x000260, "Wrong size on UAssetMappingData");
static_assert(offsetof(UAssetMappingData, ChallengesMap) == 0x000030, "Member 'UAssetMappingData::ChallengesMap' has a wrong offset!");
static_assert(offsetof(UAssetMappingData, GameStatDataMap) == 0x000080, "Member 'UAssetMappingData::GameStatDataMap' has a wrong offset!");
static_assert(offsetof(UAssetMappingData, CustomizationDataMap) == 0x0000D0, "Member 'UAssetMappingData::CustomizationDataMap' has a wrong offset!");
static_assert(offsetof(UAssetMappingData, MissionsMap) == 0x000120, "Member 'UAssetMappingData::MissionsMap' has a wrong offset!");
static_assert(offsetof(UAssetMappingData, ObjectiveSetsMap) == 0x000170, "Member 'UAssetMappingData::ObjectiveSetsMap' has a wrong offset!");
static_assert(offsetof(UAssetMappingData, InventoryCategoryMap) == 0x0001C0, "Member 'UAssetMappingData::InventoryCategoryMap' has a wrong offset!");
static_assert(offsetof(UAssetMappingData, UINamesMap) == 0x000210, "Member 'UAssetMappingData::UINamesMap' has a wrong offset!");

// Class GbxGameSystemCore.BalanceFormulaAttributeValueResolver
// 0x0130 (0x0158 - 0x0028)
class UBalanceFormulaAttributeValueResolver final : public UAttributeValueResolver
{
public:
	struct FBalanceFormulaDefinedValueRow         Value;                                             // 0x0028(0x0120)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAttributeInitializationData>   AdditionalScalars;                                 // 0x0148(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BalanceFormulaAttributeValueResolver">();
	}
	static class UBalanceFormulaAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBalanceFormulaAttributeValueResolver>();
	}
};
static_assert(alignof(UBalanceFormulaAttributeValueResolver) == 0x000008, "Wrong alignment on UBalanceFormulaAttributeValueResolver");
static_assert(sizeof(UBalanceFormulaAttributeValueResolver) == 0x000158, "Wrong size on UBalanceFormulaAttributeValueResolver");
static_assert(offsetof(UBalanceFormulaAttributeValueResolver, Value) == 0x000028, "Member 'UBalanceFormulaAttributeValueResolver::Value' has a wrong offset!");
static_assert(offsetof(UBalanceFormulaAttributeValueResolver, AdditionalScalars) == 0x000148, "Member 'UBalanceFormulaAttributeValueResolver::AdditionalScalars' has a wrong offset!");

// Class GbxGameSystemCore.ChallengeCategoryData
// 0x0020 (0x0050 - 0x0030)
class UChallengeCategoryData : public UGbxDataAsset
{
public:
	class FText                                   CategoryName;                                      // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         ProgressWeight;                                    // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeCategoryData">();
	}
	static class UChallengeCategoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeCategoryData>();
	}
};
static_assert(alignof(UChallengeCategoryData) == 0x000008, "Wrong alignment on UChallengeCategoryData");
static_assert(sizeof(UChallengeCategoryData) == 0x000050, "Wrong size on UChallengeCategoryData");
static_assert(offsetof(UChallengeCategoryData, CategoryName) == 0x000030, "Member 'UChallengeCategoryData::CategoryName' has a wrong offset!");
static_assert(offsetof(UChallengeCategoryData, ProgressWeight) == 0x000048, "Member 'UChallengeCategoryData::ProgressWeight' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_DropshipSpawn
// 0x01A0 (0x0258 - 0x00B8)
class UGbxAction_DropshipSpawn final : public UGbxAction_SimpleAnim
{
public:
	struct FAnimMeshList                          StartAnims;                                        // 0x00B8(0x0078)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimMeshList                          InAirAnims;                                        // 0x0130(0x0078)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimMeshList                          RecoveryAnims;                                     // 0x01A8(0x0078)(Edit, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AnimSlot;                                          // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationLerpTime;                                  // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveWithSpawnPointTime;                            // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwitchToFallingTime;                               // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      AnimStart;                                         // 0x0240(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      AnimInAir;                                         // 0x0248(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      AnimRecovery;                                      // 0x0250(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_DropshipSpawn">();
	}
	static class UGbxAction_DropshipSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_DropshipSpawn>();
	}
};
static_assert(alignof(UGbxAction_DropshipSpawn) == 0x000008, "Wrong alignment on UGbxAction_DropshipSpawn");
static_assert(sizeof(UGbxAction_DropshipSpawn) == 0x000258, "Wrong size on UGbxAction_DropshipSpawn");
static_assert(offsetof(UGbxAction_DropshipSpawn, StartAnims) == 0x0000B8, "Member 'UGbxAction_DropshipSpawn::StartAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, InAirAnims) == 0x000130, "Member 'UGbxAction_DropshipSpawn::InAirAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, RecoveryAnims) == 0x0001A8, "Member 'UGbxAction_DropshipSpawn::RecoveryAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, BlendInTime) == 0x000220, "Member 'UGbxAction_DropshipSpawn::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, BlendOutTime) == 0x000224, "Member 'UGbxAction_DropshipSpawn::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, AnimSlot) == 0x000228, "Member 'UGbxAction_DropshipSpawn::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, RotationLerpTime) == 0x000230, "Member 'UGbxAction_DropshipSpawn::RotationLerpTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, MoveWithSpawnPointTime) == 0x000234, "Member 'UGbxAction_DropshipSpawn::MoveWithSpawnPointTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, SwitchToFallingTime) == 0x000238, "Member 'UGbxAction_DropshipSpawn::SwitchToFallingTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, AnimStart) == 0x000240, "Member 'UGbxAction_DropshipSpawn::AnimStart' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, AnimInAir) == 0x000248, "Member 'UGbxAction_DropshipSpawn::AnimInAir' has a wrong offset!");
static_assert(offsetof(UGbxAction_DropshipSpawn, AnimRecovery) == 0x000250, "Member 'UGbxAction_DropshipSpawn::AnimRecovery' has a wrong offset!");

// Class GbxGameSystemCore.GbxCharacterMovementComponent
// 0x1DF0 (0x2680 - 0x0890)
class UGbxCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_890[0x748];                                    // 0x0890(0x0748)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxCharacter*                          GbxCharacterOwner;                                 // 0x0FD8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxCharacterAnimInstance*              GbxAnimInstance;                                   // 0x0FE0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimInstance*                          AnimInstance;                                      // 0x0FE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallingFloorUpdateInterval;                        // 0x0FF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallingFloorTraceDistance;                         // 0x0FF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FF8[0x98];                                     // 0x0FF8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterMoveToState                  CurrentMoveToState;                                // 0x1090(0x0030)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCharacterRotateToState                CurrentRotateToState;                              // 0x10C0(0x0068)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         bCanCrouchInAir : 1;                               // 0x1128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanClimbLadders : 1;                              // 0x1128(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCenterOnLadder : 1;                               // 0x1128(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSlideAlongLadderCollision : 1;                    // 0x1128(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockMomentumAdd : 1;                             // 0x1128(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1129[0x3];                                     // 0x1129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     MaxGroundSpeedScale;                               // 0x112C(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderFriction;                                    // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     MaxLadderAscendSpeed;                              // 0x113C(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     MaxLadderDescendSpeed;                             // 0x1148(0x000C)(Edit, BlueprintVisible, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLadderForwardSpeed;                             // 0x1154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLadderReverseSpeed;                             // 0x1158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderBrakingDeceleration;                         // 0x115C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderInterpSpeed;                                 // 0x1160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderJumpVelocity;                                // 0x1164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 EnterBottomAnimation;                              // 0x1168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ExitBottomAnimation;                               // 0x1170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 EnterTopAnimation;                                 // 0x1178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ExitTopAnimation;                                  // 0x1180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULadderInteractData*                    LadderInteractData;                                // 0x1188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEnterLadder;                                     // 0x1190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnExitLadderTop;                                   // 0x11A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnExitLadderBottom;                                // 0x11B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnJumpFromLadder;                                  // 0x11C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMantleStarted;                                   // 0x11D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMantleFinished;                                  // 0x11E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStanceComponent*                       StanceComponent;                                   // 0x11F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxActionComponent*                    ActionComponent;                                   // 0x11F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterScriptedMeshOffsetState      ScriptedMeshOffsetState;                           // 0x1200(0x0140)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bClientWasOnLadder;                                // 0x1340(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1341[0x7];                                     // 0x1341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class ILadderInterface>> OverlappingLadderVolumes;                          // 0x1348(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TScriptInterface<class ILadderInterface>      CurrentLadderVolume;                               // 0x1358(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TScriptInterface<class ILadderInterface>      JumpLadderVolume;                                  // 0x1368(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         LadderJumpTime;                                    // 0x1378(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAlreadyCenteredOnLadder : 1;                      // 0x137C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToBeOnLadder : 1;                            // 0x137C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_137D[0x3];                                     // 0x137D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLadderAnimState                       LadderAnimState;                                   // 0x1380(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedLadderState                 ReplicatedLadderState;                             // 0x13A8(0x0002)(Net, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AA[0x2];                                     // 0x13AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     RotationRateYaw;                                   // 0x13AC(0x000C)(Net, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     IdleRotationRateYaw;                               // 0x13B8(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIdleRotationRateYaw;                           // 0x13C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C5[0x97];                                    // 0x13C5(0x0097)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     MaxAllowedAimOffset;                               // 0x145C(0x000C)(Edit, Net, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurnAimOffset;                                  // 0x1468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBodyFacingThreshold;                            // 0x146C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPredictedTurnDegrees;                           // 0x1470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxPredictedTurnDegrees;                       // 0x1474(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1475[0x3];                                     // 0x1475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPredictedTurnTime;                              // 0x1478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxPredictedTurnTime;                          // 0x147C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysFaceActorsCurrentLocation;                  // 0x147D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_147E[0x2];                                     // 0x147E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeFloat                     AimRotationRate;                                   // 0x1480(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAngleClamp;                                  // 0x148C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookRotationRate;                                  // 0x1490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastLookRotationRate;                              // 0x1494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFastLookRotationRate;                          // 0x1498(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1499[0x3];                                     // 0x1499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNumericRange                          FastLookRotationSpeed;                             // 0x149C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HeadLookPercent;                                   // 0x14A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          HeadLookPercentDistance;                           // 0x14A8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseHeadLookPercentDistance;                       // 0x14B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14B1[0x3];                                     // 0x14B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadLookPercentInterpSpeed;                        // 0x14B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtParentBoneForAngleClamp;                 // 0x14B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14B9[0x3];                                     // 0x14B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtBlinkAngle;                                  // 0x14BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtBlinkAngle;                              // 0x14C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C1[0x3];                                     // 0x14C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtHeadTargetOffset;                            // 0x14C4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtHeadTargetOffset;                        // 0x14D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D1[0x3];                                     // 0x14D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtEyeTargetOffset;                             // 0x14D4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtEyeTargetOffset;                         // 0x14E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtTargetClearDelay;                        // 0x14E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E2[0x2];                                     // 0x14E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtRate;                                        // 0x14E4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIkEnabledInterpolationSpeed;                   // 0x14E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAdaptationOverrideInterpSpeed;                // 0x14EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F0[0x280];                                   // 0x14F0(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlledMoveState                   ControlledMoveState;                               // 0x1770(0x0160)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FControlledMoveReplicationData         ControlledMoveReplicationData;                     // 0x18D0(0x0048)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1918[0x30];                                    // 0x1918(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UMantleData*                            MantleData;                                        // 0x1948(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMantleState                           MantleState;                                       // 0x1950(0x06E8)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedMantleState                 ReplicatedMantleState;                             // 0x2038(0x0008)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2040[0x8];                                     // 0x2040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxCharacterNavWalking                GbxNavWalking;                                     // 0x2048(0x00B0)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UNavComponent*                          NavComponent;                                      // 0x20F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavMeshProjectionDistance;                         // 0x2100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirFriction;                                       // 0x2104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavMeshProjectionTraceDistance;                    // 0x2108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210C[0x4];                                     // 0x210C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavAnimState                          NavAnimState;                                      // 0x2110(0x0050)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FNavAnimServerData                     NavServerData;                                     // 0x2160(0x00A0)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FNavAnimClientData                     NavClientData;                                     // 0x2200(0x001C)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPretendToBeWalking;                               // 0x221C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221D[0x143];                                   // 0x221D(0x0143)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotationDeltaMatchingInfo             RotationDeltaMatchingInfo;                         // 0x2360(0x00C0)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2420[0x8];                                     // 0x2420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxInterpData                         InterpData;                                        // 0x2428(0x0140)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FIdleVelocityData                      IdleVelocity;                                      // 0x2568(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FRootMotionStateData                   RootMotionState;                                   // 0x2580(0x0058)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D8[0xA8];                                    // 0x25D8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FFacingInfo MakeFacingInfoActor(class AActor* Actor);
	static struct FFacingInfo MakeFacingInfoActorEyes(class AActor* Actor);
	static struct FFacingInfo MakeFacingInfoComponent(class USceneComponent* Component);
	static struct FFacingInfo MakeFacingInfoDirection(const struct FVector& Direction);
	static struct FFacingInfo MakeFacingInfoLocation(const struct FVector& Location);
	static struct FFacingInfo MakeFacingInfoNone();
	static struct FFacingInfo MakeFacingInfoRotation(const struct FRotator& Rotation);

	void ClientAdjustControlledMovePosition(float Timestamp, const struct FControlledMoveNetCorrection& ServerCMData, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
	void ControlledServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, uint32 CMDir, uint16 ClientBodyYaw);
	void ControlledServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, uint32 CMDir0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, uint32 CMDir, uint16 ClientBodyYaw);
	void ControlledServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags, uint32 CMDir);
	void GbxCharacterMovementEvent__DelegateSignature();
	void GbxSetAnimInstanceClass(class USkeletalMeshComponent* SkelMeshComponent, class UClass* NewClass);
	void LeaveNoneWithRootMotionMode(bool bApplyDefault);
	void OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnNotifyTurnEnter();
	void OnNotifyTurnExit();
	void OnRep_ControlledMove();
	void OnStanceChanged(const struct FStanceChangedEventArgs& Args);
	void ServerAttemptMantle(const struct FMantleAttemptInfo& ClientData, float Timestamp);
	void ServerStartMoveTo(const struct FCharacterMoveToCommand& MoveToCommand);
	void ServerStopMoveTo();
	void SetAnimationBasedTurning(const bool bEnable);
	void SetFacingTarget(const struct FFacingInfo& FacingTarget, EFacingChannel Channel);
	void SetNoneWithRootMotionMode(bool bAnimationWalking, const class FName Reason);
	void SetPendingRawInputVector(const struct FVector& NewInputVector);
	bool StartControlledMove(TSubclassOf<class UControlledMove> ControlledMove, class AActor* Instigator, float SpeedOverride, float DurationOverride, float LaunchAngleOverride, class AActor* TargetActor, const struct FVector& TargetLocation);
	void StartMoveTo(const struct FCharacterMoveToCommand& MoveToCommand);
	void StartRotateTo(const struct FCharacterRotateToCommand& RotateToCommand);
	void StopControlledMove(TSubclassOf<class UControlledMove> ControlledMove, bool bZeroVelocity, bool bInterrupted);
	void StopMoveTo(bool bForce, bool bReplicateStop);
	void StopRotateTo();

	bool CanStartMantle() const;
	bool CanStartPassiveMantle() const;
	struct FVector GetCurrentFacingLocation(EFacingChannel Channel) const;
	struct FVector GetCurrentFacingOrigin(EFacingChannel Channel) const;
	struct FRotator GetCurrentFacingRotation(EFacingChannel Channel) const;
	struct FVector GetDesiredFacingLocation(EFacingChannel Channel) const;
	struct FRotator GetDesiredFacingRotation(EFacingChannel Channel) const;
	class UMantleData* GetMantleData() const;
	float GetMaxAllowedAimOffset() const;
	bool IsFacingTargetBP(float ThresholdDegrees, EFacingChannel Channel) const;
	bool IsFootIkEnabled() const;
	bool IsFootIkTracingEnabled() const;
	bool IsHandIkEnabled() const;
	bool IsInNoneWithRootMotionMode() const;
	bool IsMantling() const;
	bool IsMantlingAllowed() const;
	bool IsMovingOnLadder() const;
	bool IsPerformingControlledMove() const;
	bool IsPerformingSpecificControlledMove(TSubclassOf<class UControlledMove> ControlledMove) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCharacterMovementComponent">();
	}
	static class UGbxCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCharacterMovementComponent>();
	}
};
static_assert(alignof(UGbxCharacterMovementComponent) == 0x000010, "Wrong alignment on UGbxCharacterMovementComponent");
static_assert(sizeof(UGbxCharacterMovementComponent) == 0x002680, "Wrong size on UGbxCharacterMovementComponent");
static_assert(offsetof(UGbxCharacterMovementComponent, GbxCharacterOwner) == 0x000FD8, "Member 'UGbxCharacterMovementComponent::GbxCharacterOwner' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, GbxAnimInstance) == 0x000FE0, "Member 'UGbxCharacterMovementComponent::GbxAnimInstance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, AnimInstance) == 0x000FE8, "Member 'UGbxCharacterMovementComponent::AnimInstance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, FallingFloorUpdateInterval) == 0x000FF0, "Member 'UGbxCharacterMovementComponent::FallingFloorUpdateInterval' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, FallingFloorTraceDistance) == 0x000FF4, "Member 'UGbxCharacterMovementComponent::FallingFloorTraceDistance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, CurrentMoveToState) == 0x001090, "Member 'UGbxCharacterMovementComponent::CurrentMoveToState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, CurrentRotateToState) == 0x0010C0, "Member 'UGbxCharacterMovementComponent::CurrentRotateToState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxGroundSpeedScale) == 0x00112C, "Member 'UGbxCharacterMovementComponent::MaxGroundSpeedScale' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderFriction) == 0x001138, "Member 'UGbxCharacterMovementComponent::LadderFriction' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxLadderAscendSpeed) == 0x00113C, "Member 'UGbxCharacterMovementComponent::MaxLadderAscendSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxLadderDescendSpeed) == 0x001148, "Member 'UGbxCharacterMovementComponent::MaxLadderDescendSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxLadderForwardSpeed) == 0x001154, "Member 'UGbxCharacterMovementComponent::MaxLadderForwardSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxLadderReverseSpeed) == 0x001158, "Member 'UGbxCharacterMovementComponent::MaxLadderReverseSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderBrakingDeceleration) == 0x00115C, "Member 'UGbxCharacterMovementComponent::LadderBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderInterpSpeed) == 0x001160, "Member 'UGbxCharacterMovementComponent::LadderInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderJumpVelocity) == 0x001164, "Member 'UGbxCharacterMovementComponent::LadderJumpVelocity' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, EnterBottomAnimation) == 0x001168, "Member 'UGbxCharacterMovementComponent::EnterBottomAnimation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ExitBottomAnimation) == 0x001170, "Member 'UGbxCharacterMovementComponent::ExitBottomAnimation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, EnterTopAnimation) == 0x001178, "Member 'UGbxCharacterMovementComponent::EnterTopAnimation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ExitTopAnimation) == 0x001180, "Member 'UGbxCharacterMovementComponent::ExitTopAnimation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderInteractData) == 0x001188, "Member 'UGbxCharacterMovementComponent::LadderInteractData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OnEnterLadder) == 0x001190, "Member 'UGbxCharacterMovementComponent::OnEnterLadder' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OnExitLadderTop) == 0x0011A0, "Member 'UGbxCharacterMovementComponent::OnExitLadderTop' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OnExitLadderBottom) == 0x0011B0, "Member 'UGbxCharacterMovementComponent::OnExitLadderBottom' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OnJumpFromLadder) == 0x0011C0, "Member 'UGbxCharacterMovementComponent::OnJumpFromLadder' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OnMantleStarted) == 0x0011D0, "Member 'UGbxCharacterMovementComponent::OnMantleStarted' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OnMantleFinished) == 0x0011E0, "Member 'UGbxCharacterMovementComponent::OnMantleFinished' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, StanceComponent) == 0x0011F0, "Member 'UGbxCharacterMovementComponent::StanceComponent' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ActionComponent) == 0x0011F8, "Member 'UGbxCharacterMovementComponent::ActionComponent' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ScriptedMeshOffsetState) == 0x001200, "Member 'UGbxCharacterMovementComponent::ScriptedMeshOffsetState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bClientWasOnLadder) == 0x001340, "Member 'UGbxCharacterMovementComponent::bClientWasOnLadder' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, OverlappingLadderVolumes) == 0x001348, "Member 'UGbxCharacterMovementComponent::OverlappingLadderVolumes' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, CurrentLadderVolume) == 0x001358, "Member 'UGbxCharacterMovementComponent::CurrentLadderVolume' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, JumpLadderVolume) == 0x001368, "Member 'UGbxCharacterMovementComponent::JumpLadderVolume' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderJumpTime) == 0x001378, "Member 'UGbxCharacterMovementComponent::LadderJumpTime' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LadderAnimState) == 0x001380, "Member 'UGbxCharacterMovementComponent::LadderAnimState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ReplicatedLadderState) == 0x0013A8, "Member 'UGbxCharacterMovementComponent::ReplicatedLadderState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, RotationRateYaw) == 0x0013AC, "Member 'UGbxCharacterMovementComponent::RotationRateYaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, IdleRotationRateYaw) == 0x0013B8, "Member 'UGbxCharacterMovementComponent::IdleRotationRateYaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseIdleRotationRateYaw) == 0x0013C4, "Member 'UGbxCharacterMovementComponent::bUseIdleRotationRateYaw' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxAllowedAimOffset) == 0x00145C, "Member 'UGbxCharacterMovementComponent::MaxAllowedAimOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MinTurnAimOffset) == 0x001468, "Member 'UGbxCharacterMovementComponent::MinTurnAimOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MinBodyFacingThreshold) == 0x00146C, "Member 'UGbxCharacterMovementComponent::MinBodyFacingThreshold' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxPredictedTurnDegrees) == 0x001470, "Member 'UGbxCharacterMovementComponent::MaxPredictedTurnDegrees' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseMaxPredictedTurnDegrees) == 0x001474, "Member 'UGbxCharacterMovementComponent::bUseMaxPredictedTurnDegrees' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MaxPredictedTurnTime) == 0x001478, "Member 'UGbxCharacterMovementComponent::MaxPredictedTurnTime' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseMaxPredictedTurnTime) == 0x00147C, "Member 'UGbxCharacterMovementComponent::bUseMaxPredictedTurnTime' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bAlwaysFaceActorsCurrentLocation) == 0x00147D, "Member 'UGbxCharacterMovementComponent::bAlwaysFaceActorsCurrentLocation' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, AimRotationRate) == 0x001480, "Member 'UGbxCharacterMovementComponent::AimRotationRate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LookAtAngleClamp) == 0x00148C, "Member 'UGbxCharacterMovementComponent::LookAtAngleClamp' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LookRotationRate) == 0x001490, "Member 'UGbxCharacterMovementComponent::LookRotationRate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, FastLookRotationRate) == 0x001494, "Member 'UGbxCharacterMovementComponent::FastLookRotationRate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseFastLookRotationRate) == 0x001498, "Member 'UGbxCharacterMovementComponent::bUseFastLookRotationRate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, FastLookRotationSpeed) == 0x00149C, "Member 'UGbxCharacterMovementComponent::FastLookRotationSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, HeadLookPercent) == 0x0014A4, "Member 'UGbxCharacterMovementComponent::HeadLookPercent' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, HeadLookPercentDistance) == 0x0014A8, "Member 'UGbxCharacterMovementComponent::HeadLookPercentDistance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseHeadLookPercentDistance) == 0x0014B0, "Member 'UGbxCharacterMovementComponent::bUseHeadLookPercentDistance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, HeadLookPercentInterpSpeed) == 0x0014B4, "Member 'UGbxCharacterMovementComponent::HeadLookPercentInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseLookAtParentBoneForAngleClamp) == 0x0014B8, "Member 'UGbxCharacterMovementComponent::bUseLookAtParentBoneForAngleClamp' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LookAtBlinkAngle) == 0x0014BC, "Member 'UGbxCharacterMovementComponent::LookAtBlinkAngle' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseLookAtBlinkAngle) == 0x0014C0, "Member 'UGbxCharacterMovementComponent::bUseLookAtBlinkAngle' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LookAtHeadTargetOffset) == 0x0014C4, "Member 'UGbxCharacterMovementComponent::LookAtHeadTargetOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseLookAtHeadTargetOffset) == 0x0014D0, "Member 'UGbxCharacterMovementComponent::bUseLookAtHeadTargetOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LookAtEyeTargetOffset) == 0x0014D4, "Member 'UGbxCharacterMovementComponent::LookAtEyeTargetOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseLookAtEyeTargetOffset) == 0x0014E0, "Member 'UGbxCharacterMovementComponent::bUseLookAtEyeTargetOffset' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bUseLookAtTargetClearDelay) == 0x0014E1, "Member 'UGbxCharacterMovementComponent::bUseLookAtTargetClearDelay' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, LookAtRate) == 0x0014E4, "Member 'UGbxCharacterMovementComponent::LookAtRate' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, FootIkEnabledInterpolationSpeed) == 0x0014E8, "Member 'UGbxCharacterMovementComponent::FootIkEnabledInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, SlopeAdaptationOverrideInterpSpeed) == 0x0014EC, "Member 'UGbxCharacterMovementComponent::SlopeAdaptationOverrideInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ControlledMoveState) == 0x001770, "Member 'UGbxCharacterMovementComponent::ControlledMoveState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ControlledMoveReplicationData) == 0x0018D0, "Member 'UGbxCharacterMovementComponent::ControlledMoveReplicationData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MantleData) == 0x001948, "Member 'UGbxCharacterMovementComponent::MantleData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, MantleState) == 0x001950, "Member 'UGbxCharacterMovementComponent::MantleState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, ReplicatedMantleState) == 0x002038, "Member 'UGbxCharacterMovementComponent::ReplicatedMantleState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, GbxNavWalking) == 0x002048, "Member 'UGbxCharacterMovementComponent::GbxNavWalking' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, NavComponent) == 0x0020F8, "Member 'UGbxCharacterMovementComponent::NavComponent' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, NavMeshProjectionDistance) == 0x002100, "Member 'UGbxCharacterMovementComponent::NavMeshProjectionDistance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, AirFriction) == 0x002104, "Member 'UGbxCharacterMovementComponent::AirFriction' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, NavMeshProjectionTraceDistance) == 0x002108, "Member 'UGbxCharacterMovementComponent::NavMeshProjectionTraceDistance' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, NavAnimState) == 0x002110, "Member 'UGbxCharacterMovementComponent::NavAnimState' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, NavServerData) == 0x002160, "Member 'UGbxCharacterMovementComponent::NavServerData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, NavClientData) == 0x002200, "Member 'UGbxCharacterMovementComponent::NavClientData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, bPretendToBeWalking) == 0x00221C, "Member 'UGbxCharacterMovementComponent::bPretendToBeWalking' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, RotationDeltaMatchingInfo) == 0x002360, "Member 'UGbxCharacterMovementComponent::RotationDeltaMatchingInfo' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, InterpData) == 0x002428, "Member 'UGbxCharacterMovementComponent::InterpData' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, IdleVelocity) == 0x002568, "Member 'UGbxCharacterMovementComponent::IdleVelocity' has a wrong offset!");
static_assert(offsetof(UGbxCharacterMovementComponent, RootMotionState) == 0x002580, "Member 'UGbxCharacterMovementComponent::RootMotionState' has a wrong offset!");

// Class GbxGameSystemCore.ChallengeLevelActorComponent
// 0x0080 (0x07D0 - 0x0750)
class UChallengeLevelActorComponent : public UGbxAreaComponent
{
public:
	TSubclassOf<class UChallenge>                 BaseChallengeReference;                            // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UChallenge>                 ChallengeReference;                                // 0x0758(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInZoneMap;                                    // 0x0760(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMiniMap;                                    // 0x0761(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInWorld;                                      // 0x0762(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInWorldIconEnabled;                               // 0x0763(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnfogRadiusWhenChallengeActive;                    // 0x0764(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnfogHeightWhenChallengeActive;                    // 0x0768(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  IconGuid;                                          // 0x076C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStationary;                                     // 0x077C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77D[0x3];                                      // 0x077D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlayerChallengeActivated;                        // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerChallengeCompleted;                        // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerEnteredChallengeArea;                      // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerExitedChallengeArea;                       // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChallengeLevelActorComponent*          OwningLevelActorComponent;                         // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AActor* GetAssociatedActor();
	void HandleAttachmentChanged();
	void OnRep_ChallengeReference();
	void OnRep_InWorldIconEnabled(bool bOldEnabled);
	void OnRep_IsStationary(bool bOldIsStationary);
	void SetInWorldIconEnabled(bool bEnable);
	void SetIsStationary(bool bInIsStationary);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeLevelActorComponent">();
	}
	static class UChallengeLevelActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeLevelActorComponent>();
	}
};
static_assert(alignof(UChallengeLevelActorComponent) == 0x000008, "Wrong alignment on UChallengeLevelActorComponent");
static_assert(sizeof(UChallengeLevelActorComponent) == 0x0007D0, "Wrong size on UChallengeLevelActorComponent");
static_assert(offsetof(UChallengeLevelActorComponent, BaseChallengeReference) == 0x000750, "Member 'UChallengeLevelActorComponent::BaseChallengeReference' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, ChallengeReference) == 0x000758, "Member 'UChallengeLevelActorComponent::ChallengeReference' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, bShowInZoneMap) == 0x000760, "Member 'UChallengeLevelActorComponent::bShowInZoneMap' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, bShowInMiniMap) == 0x000761, "Member 'UChallengeLevelActorComponent::bShowInMiniMap' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, bShowInWorld) == 0x000762, "Member 'UChallengeLevelActorComponent::bShowInWorld' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, bInWorldIconEnabled) == 0x000763, "Member 'UChallengeLevelActorComponent::bInWorldIconEnabled' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, UnfogRadiusWhenChallengeActive) == 0x000764, "Member 'UChallengeLevelActorComponent::UnfogRadiusWhenChallengeActive' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, UnfogHeightWhenChallengeActive) == 0x000768, "Member 'UChallengeLevelActorComponent::UnfogHeightWhenChallengeActive' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, IconGuid) == 0x00076C, "Member 'UChallengeLevelActorComponent::IconGuid' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, bIsStationary) == 0x00077C, "Member 'UChallengeLevelActorComponent::bIsStationary' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, OnPlayerChallengeActivated) == 0x000780, "Member 'UChallengeLevelActorComponent::OnPlayerChallengeActivated' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, OnPlayerChallengeCompleted) == 0x000790, "Member 'UChallengeLevelActorComponent::OnPlayerChallengeCompleted' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, OnPlayerEnteredChallengeArea) == 0x0007A0, "Member 'UChallengeLevelActorComponent::OnPlayerEnteredChallengeArea' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, OnPlayerExitedChallengeArea) == 0x0007B0, "Member 'UChallengeLevelActorComponent::OnPlayerExitedChallengeArea' has a wrong offset!");
static_assert(offsetof(UChallengeLevelActorComponent, OwningLevelActorComponent) == 0x0007C8, "Member 'UChallengeLevelActorComponent::OwningLevelActorComponent' has a wrong offset!");

// Class GbxGameSystemCore.GbxCheatManager
// 0x0010 (0x0088 - 0x0078)
class UGbxCheatManager : public UCheatManager
{
public:
	uint8                                         BitPad_78_0 : 2;                                   // 0x0078(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bHLQNoClipActive : 1;                              // 0x0078(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_79[0xF];                                       // 0x0079(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetDebugActor(class AActor* Actor, int32 ControllerIndex);

	void ClearPlayerInit();
	void DebugNextAI();
	void PlayFeedback(const class FString& FeedbackData, float Scale);
	void PlayFeedbackDirectional(const class FString& FeedbackData, float DirectionAngle);
	void PlayFeedbackRangedFromThere(const class FString& FeedbackData);
	void Server_DamageTarget(float DamageAmount);
	void Server_TogglePlayersOnly();
	void SetDebugActorByName(const class FString& ActorName);
	void ShowProjectileImpacts(float Size, float LifeTime);
	void StartPlayerInit();
	void TestGameStage(int32 GameStageOverride);

	void DamageAreaDebug() const;
	void LogQatalystInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCheatManager">();
	}
	static class UGbxCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCheatManager>();
	}
};
static_assert(alignof(UGbxCheatManager) == 0x000008, "Wrong alignment on UGbxCheatManager");
static_assert(sizeof(UGbxCheatManager) == 0x000088, "Wrong size on UGbxCheatManager");

// Class GbxGameSystemCore.AnimNotifyState_StretchAction
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_StretchAction final : public UAnimNotifyState
{
public:
	bool                                          bRotate;                                           // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTranslate;                                        // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_StretchAction">();
	}
	static class UAnimNotifyState_StretchAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_StretchAction>();
	}
};
static_assert(alignof(UAnimNotifyState_StretchAction) == 0x000008, "Wrong alignment on UAnimNotifyState_StretchAction");
static_assert(sizeof(UAnimNotifyState_StretchAction) == 0x000038, "Wrong size on UAnimNotifyState_StretchAction");
static_assert(offsetof(UAnimNotifyState_StretchAction, bRotate) == 0x000030, "Member 'UAnimNotifyState_StretchAction::bRotate' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchAction, bTranslate) == 0x000031, "Member 'UAnimNotifyState_StretchAction::bTranslate' has a wrong offset!");

// Class GbxGameSystemCore.GbxCustomizationManager
// 0x0018 (0x0470 - 0x0458)
class AGbxCustomizationManager : public AActor
{
public:
	TArray<struct FCustomizationStreamingEntry>   CustomizationStreamingEntries;                     // 0x0458(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationAssetLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCustomizationManager">();
	}
	static class AGbxCustomizationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxCustomizationManager>();
	}
};
static_assert(alignof(AGbxCustomizationManager) == 0x000008, "Wrong alignment on AGbxCustomizationManager");
static_assert(sizeof(AGbxCustomizationManager) == 0x000470, "Wrong size on AGbxCustomizationManager");
static_assert(offsetof(AGbxCustomizationManager, CustomizationStreamingEntries) == 0x000458, "Member 'AGbxCustomizationManager::CustomizationStreamingEntries' has a wrong offset!");

// Class GbxGameSystemCore.DamageComponent
// 0x06B0 (0x0878 - 0x01C8)
class UDamageComponent : public UDamageBaseComponent
{
public:
	uint8                                         Pad_1C8[0x38];                                     // 0x01C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTakeAnyDamage;                                   // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerMeleeHit;                                  // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTakeAnyHealing;                                  // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHealthDepleted;                                  // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDeath;                                           // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHitByFriendly;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x130];                                    // 0x0290(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHitReaction;                                     // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHitReactionState                      HitReactions;                                      // 0x03D0(0x0290)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bShowDamageNumbers : 1;                            // 0x0660(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowImmuneFeedbackInGodMode : 1;                  // 0x0660(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysBlockWeapons : 1;                           // 0x0660(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreDamageAreaVisibilityChecks : 1;             // 0x0660(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDieWhenHealthDepleted : 1;                        // 0x0660(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDeathData*                             DeathData;                                         // 0x0668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageComponentHealthMode                    HealthMode;                                        // 0x0670(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_674[0x4];                                      // 0x0674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHealthType>                    HealthInformation;                                 // 0x0678(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSimpleHealthInfo                      SimpleHealthInformation;                           // 0x0688(0x0058)(Edit, Net, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     DamageTakenMultiplier;                             // 0x06E0(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     RadiusDamageTakenMultiplier;                       // 0x06EC(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     StatusEffectChanceModifierScalar;                  // 0x06F8(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     StatusEffectDamageModifierScalar;                  // 0x0704(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     StatusEffectDurationModifierScalar;                // 0x0710(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatusEffectModifiers>         StatusEffectModifiers;                             // 0x0720(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinimumDamageLaunchVelocity;                       // 0x0730(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseBoundForCylinderTest : 1;                      // 0x0734(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_735[0x3];                                      // 0x0735(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchVerticalDampening;                           // 0x0738(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSelfInflictedLaunchVelocity;                    // 0x073C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            SplatterEffect;                                    // 0x0740(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProtectionTimer;                               // 0x0748(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_749[0x7];                                      // 0x0749(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSyncedHitReactionData                 DeathHitReaction;                                  // 0x0750(0x0040)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_790[0x4];                                      // 0x0790(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamageGoreModifiers                   DeathGoreModifiers;                                // 0x0794(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      LastHitByPlayer;                                   // 0x07A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvertDeathChance;                                  // 0x07A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IntrinsicArmor;                                    // 0x07AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxAttributeFloat                     SelfReflectionChance;                              // 0x07B0(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxAttributeFloat                     SelfReflectionDamageTakenScale;                    // 0x07BC(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxAttributeFloat                     SelfReflectionDamageScale;                         // 0x07C8(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxAttributeInteger                   SelfReflectionTowardsAttacker;                     // 0x07D4(0x000C)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxDamageType>             SelfReflectionDamageType;                          // 0x07E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bPassDamageToParent : 1;                           // 0x07E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDamageOnlyAppliesToParent : 1;                    // 0x07E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanDamageCorpse : 1;                              // 0x07E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_7E9[0x7];                                      // 0x07E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UConditionalDamageModifier*>     DefaultConditionalDamageModifiers;                 // 0x07F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FDamageReactionEvent_DamageComponent> DamageEvents;                                      // 0x0800(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UHitRegionComponent*                    CachedHitRegionComponent;                          // 0x0810(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       ParentDamageComponent;                             // 0x0818(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AController*                            LastHitBy;                                         // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_828[0x18];                                     // 0x0828(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bGodMode : 1;                                      // 0x0840(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDemigodMode : 1;                                  // 0x0840(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_840_2 : 1;                                  // 0x0840(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bCurrentlyDead : 1;                                // 0x0840(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_841[0x27];                                     // 0x0841(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      ImpactPhysicalMaterialOverride;                    // 0x0868(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSuppressOnDeathCall;                              // 0x0870(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_871[0x7];                                      // 0x0871(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastPlayImpactSplatterEffect(class UImpactData* ImpactData, const struct FVector_NetQuantize100& HitLocation, const struct FVector_NetQuantizeNormal& HitDirection, float DamageSeverity);
	void OnHealthResourceNowDepleted(const struct FGameResourcePoolReference& ResourcePool);
	void OnHealthResourceNowNotDepleted(const struct FGameResourcePoolReference& ResourcePool);
	void OnOwnerExperienceLevelChanged(const int32 OldExperienceLevel, const int32 NewExperienceLevel);
	void OnRep_bCurrentlyDead();
	void OnRep_DeathHitReaction();
	void OnRep_HealthInformation();
	void ReceiveAnyDamage(float Damage, const class UGbxDamageType* DamageType, const class UDamageSource* DamageSource, class AController* InstigatedBy, class UDamageCauserComponent* DamageCauser, const struct FReceivedDamageDetails& Details);
	void ReceiveAnyHealing(float Healing, class AActor* HealInstigator);
	void ReceiveHealthDepleted(class UDamageCauserComponent* DamageCauser);
	void RegisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier);
	void SetCurrentHealth(float NewCurrentHealth);
	void SetCurrentShield(float NewCurrentShield);
	void SetDemiGodMode(bool bInDemiGodMode);
	void SetGodMode(bool bInGodMode);
	void SetSelfReflectedDamageType(const TSubclassOf<class UGbxDamageType>& DamageType);
	void UnregisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier);

	float GetCurrentHealth() const;
	float GetCurrentHealthPercent() const;
	float GetCurrentShield() const;
	float GetMaxHealth() const;
	float GetMaxShield() const;
	float GetTotalMaxHealth() const;
	void GetValidDamageEventFunctionNames(TArray<class FName>* Names) const;
	bool IsDamageOverkill(float DamageAmount, float OverkillThreshold) const;
	bool IsInDemiGodMode() const;
	bool IsInGodMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageComponent">();
	}
	static class UDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageComponent>();
	}
};
static_assert(alignof(UDamageComponent) == 0x000008, "Wrong alignment on UDamageComponent");
static_assert(sizeof(UDamageComponent) == 0x000878, "Wrong size on UDamageComponent");
static_assert(offsetof(UDamageComponent, OnTakeAnyDamage) == 0x000200, "Member 'UDamageComponent::OnTakeAnyDamage' has a wrong offset!");
static_assert(offsetof(UDamageComponent, OnPlayerMeleeHit) == 0x000210, "Member 'UDamageComponent::OnPlayerMeleeHit' has a wrong offset!");
static_assert(offsetof(UDamageComponent, OnTakeAnyHealing) == 0x000220, "Member 'UDamageComponent::OnTakeAnyHealing' has a wrong offset!");
static_assert(offsetof(UDamageComponent, OnHealthDepleted) == 0x000230, "Member 'UDamageComponent::OnHealthDepleted' has a wrong offset!");
static_assert(offsetof(UDamageComponent, OnDeath) == 0x000258, "Member 'UDamageComponent::OnDeath' has a wrong offset!");
static_assert(offsetof(UDamageComponent, OnHitByFriendly) == 0x000280, "Member 'UDamageComponent::OnHitByFriendly' has a wrong offset!");
static_assert(offsetof(UDamageComponent, OnHitReaction) == 0x0003C0, "Member 'UDamageComponent::OnHitReaction' has a wrong offset!");
static_assert(offsetof(UDamageComponent, HitReactions) == 0x0003D0, "Member 'UDamageComponent::HitReactions' has a wrong offset!");
static_assert(offsetof(UDamageComponent, DeathData) == 0x000668, "Member 'UDamageComponent::DeathData' has a wrong offset!");
static_assert(offsetof(UDamageComponent, HealthMode) == 0x000670, "Member 'UDamageComponent::HealthMode' has a wrong offset!");
static_assert(offsetof(UDamageComponent, HealthInformation) == 0x000678, "Member 'UDamageComponent::HealthInformation' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SimpleHealthInformation) == 0x000688, "Member 'UDamageComponent::SimpleHealthInformation' has a wrong offset!");
static_assert(offsetof(UDamageComponent, DamageTakenMultiplier) == 0x0006E0, "Member 'UDamageComponent::DamageTakenMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageComponent, RadiusDamageTakenMultiplier) == 0x0006EC, "Member 'UDamageComponent::RadiusDamageTakenMultiplier' has a wrong offset!");
static_assert(offsetof(UDamageComponent, StatusEffectChanceModifierScalar) == 0x0006F8, "Member 'UDamageComponent::StatusEffectChanceModifierScalar' has a wrong offset!");
static_assert(offsetof(UDamageComponent, StatusEffectDamageModifierScalar) == 0x000704, "Member 'UDamageComponent::StatusEffectDamageModifierScalar' has a wrong offset!");
static_assert(offsetof(UDamageComponent, StatusEffectDurationModifierScalar) == 0x000710, "Member 'UDamageComponent::StatusEffectDurationModifierScalar' has a wrong offset!");
static_assert(offsetof(UDamageComponent, StatusEffectModifiers) == 0x000720, "Member 'UDamageComponent::StatusEffectModifiers' has a wrong offset!");
static_assert(offsetof(UDamageComponent, MinimumDamageLaunchVelocity) == 0x000730, "Member 'UDamageComponent::MinimumDamageLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UDamageComponent, LaunchVerticalDampening) == 0x000738, "Member 'UDamageComponent::LaunchVerticalDampening' has a wrong offset!");
static_assert(offsetof(UDamageComponent, MaxSelfInflictedLaunchVelocity) == 0x00073C, "Member 'UDamageComponent::MaxSelfInflictedLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SplatterEffect) == 0x000740, "Member 'UDamageComponent::SplatterEffect' has a wrong offset!");
static_assert(offsetof(UDamageComponent, bUseProtectionTimer) == 0x000748, "Member 'UDamageComponent::bUseProtectionTimer' has a wrong offset!");
static_assert(offsetof(UDamageComponent, DeathHitReaction) == 0x000750, "Member 'UDamageComponent::DeathHitReaction' has a wrong offset!");
static_assert(offsetof(UDamageComponent, DeathGoreModifiers) == 0x000794, "Member 'UDamageComponent::DeathGoreModifiers' has a wrong offset!");
static_assert(offsetof(UDamageComponent, LastHitByPlayer) == 0x0007A0, "Member 'UDamageComponent::LastHitByPlayer' has a wrong offset!");
static_assert(offsetof(UDamageComponent, AvertDeathChance) == 0x0007A8, "Member 'UDamageComponent::AvertDeathChance' has a wrong offset!");
static_assert(offsetof(UDamageComponent, IntrinsicArmor) == 0x0007AC, "Member 'UDamageComponent::IntrinsicArmor' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SelfReflectionChance) == 0x0007B0, "Member 'UDamageComponent::SelfReflectionChance' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SelfReflectionDamageTakenScale) == 0x0007BC, "Member 'UDamageComponent::SelfReflectionDamageTakenScale' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SelfReflectionDamageScale) == 0x0007C8, "Member 'UDamageComponent::SelfReflectionDamageScale' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SelfReflectionTowardsAttacker) == 0x0007D4, "Member 'UDamageComponent::SelfReflectionTowardsAttacker' has a wrong offset!");
static_assert(offsetof(UDamageComponent, SelfReflectionDamageType) == 0x0007E0, "Member 'UDamageComponent::SelfReflectionDamageType' has a wrong offset!");
static_assert(offsetof(UDamageComponent, DefaultConditionalDamageModifiers) == 0x0007F0, "Member 'UDamageComponent::DefaultConditionalDamageModifiers' has a wrong offset!");
static_assert(offsetof(UDamageComponent, DamageEvents) == 0x000800, "Member 'UDamageComponent::DamageEvents' has a wrong offset!");
static_assert(offsetof(UDamageComponent, CachedHitRegionComponent) == 0x000810, "Member 'UDamageComponent::CachedHitRegionComponent' has a wrong offset!");
static_assert(offsetof(UDamageComponent, ParentDamageComponent) == 0x000818, "Member 'UDamageComponent::ParentDamageComponent' has a wrong offset!");
static_assert(offsetof(UDamageComponent, LastHitBy) == 0x000820, "Member 'UDamageComponent::LastHitBy' has a wrong offset!");
static_assert(offsetof(UDamageComponent, ImpactPhysicalMaterialOverride) == 0x000868, "Member 'UDamageComponent::ImpactPhysicalMaterialOverride' has a wrong offset!");
static_assert(offsetof(UDamageComponent, bSuppressOnDeathCall) == 0x000870, "Member 'UDamageComponent::bSuppressOnDeathCall' has a wrong offset!");

// Class GbxGameSystemCore.DamageFilter
// 0x0070 (0x0098 - 0x0028)
class UDamageFilter : public UObject
{
public:
	bool                                          bExactDamageSourceClass;                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExactDamageTypeClass;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxCondition*                          ConditionSelf;                                     // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxCondition*                          ConditionAttacker;                                 // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOnlyAoEDamage : 1;                                // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMustNotBeSelfDamage : 1;                          // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseRandomChance : 1;                              // 0x0058(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           RandomChance;                                      // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageFilter">();
	}
	static class UDamageFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageFilter>();
	}
};
static_assert(alignof(UDamageFilter) == 0x000008, "Wrong alignment on UDamageFilter");
static_assert(sizeof(UDamageFilter) == 0x000098, "Wrong size on UDamageFilter");
static_assert(offsetof(UDamageFilter, bExactDamageSourceClass) == 0x000028, "Member 'UDamageFilter::bExactDamageSourceClass' has a wrong offset!");
static_assert(offsetof(UDamageFilter, DamageSource) == 0x000030, "Member 'UDamageFilter::DamageSource' has a wrong offset!");
static_assert(offsetof(UDamageFilter, bExactDamageTypeClass) == 0x000038, "Member 'UDamageFilter::bExactDamageTypeClass' has a wrong offset!");
static_assert(offsetof(UDamageFilter, DamageType) == 0x000040, "Member 'UDamageFilter::DamageType' has a wrong offset!");
static_assert(offsetof(UDamageFilter, ConditionSelf) == 0x000048, "Member 'UDamageFilter::ConditionSelf' has a wrong offset!");
static_assert(offsetof(UDamageFilter, ConditionAttacker) == 0x000050, "Member 'UDamageFilter::ConditionAttacker' has a wrong offset!");
static_assert(offsetof(UDamageFilter, RandomChance) == 0x000060, "Member 'UDamageFilter::RandomChance' has a wrong offset!");

// Class GbxGameSystemCore.DamageGlobalsData
// 0x0218 (0x0248 - 0x0030)
class UDamageGlobalsData : public UGbxDataAsset
{
public:
	struct FProtectionTimerSettings               ProtectionTimerSettings;                           // 0x0030(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DefaultInstigatorSelfDamageScale;                  // 0x0040(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DefaultHealingDamageType;                          // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            DefaultHealingImpact;                              // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           GlobalAIDamageScale;                               // 0x0088(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLevelBasedDamageScale>         PlayerDamageScaleByLevelDifference;                // 0x00C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLevelBasedDamageScale>         AIDamageScaleByLevelDifference;                    // 0x00D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     SplatterProbabilityCurve;                          // 0x00E0(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeFloatCurve                     SplatterTraceDistanceCurve;                        // 0x0158(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SplatterDirectionSpread;                           // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GibLifeSpan;                                       // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GibCollisionProfileName;                           // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GibCollisionProfileNameAttached;                   // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           GibMaterialParameterResetList;                     // 0x01E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FDamageLocalizationSettings> LanguageToTextureMap;                              // 0x01F8(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageGlobalsData">();
	}
	static class UDamageGlobalsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageGlobalsData>();
	}
};
static_assert(alignof(UDamageGlobalsData) == 0x000008, "Wrong alignment on UDamageGlobalsData");
static_assert(sizeof(UDamageGlobalsData) == 0x000248, "Wrong size on UDamageGlobalsData");
static_assert(offsetof(UDamageGlobalsData, ProtectionTimerSettings) == 0x000030, "Member 'UDamageGlobalsData::ProtectionTimerSettings' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, DefaultInstigatorSelfDamageScale) == 0x000040, "Member 'UDamageGlobalsData::DefaultInstigatorSelfDamageScale' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, DefaultHealingDamageType) == 0x000078, "Member 'UDamageGlobalsData::DefaultHealingDamageType' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, DefaultHealingImpact) == 0x000080, "Member 'UDamageGlobalsData::DefaultHealingImpact' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, GlobalAIDamageScale) == 0x000088, "Member 'UDamageGlobalsData::GlobalAIDamageScale' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, PlayerDamageScaleByLevelDifference) == 0x0000C0, "Member 'UDamageGlobalsData::PlayerDamageScaleByLevelDifference' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, AIDamageScaleByLevelDifference) == 0x0000D0, "Member 'UDamageGlobalsData::AIDamageScaleByLevelDifference' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, SplatterProbabilityCurve) == 0x0000E0, "Member 'UDamageGlobalsData::SplatterProbabilityCurve' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, SplatterTraceDistanceCurve) == 0x000158, "Member 'UDamageGlobalsData::SplatterTraceDistanceCurve' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, SplatterDirectionSpread) == 0x0001D0, "Member 'UDamageGlobalsData::SplatterDirectionSpread' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, GibLifeSpan) == 0x0001D4, "Member 'UDamageGlobalsData::GibLifeSpan' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, GibCollisionProfileName) == 0x0001D8, "Member 'UDamageGlobalsData::GibCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, GibCollisionProfileNameAttached) == 0x0001E0, "Member 'UDamageGlobalsData::GibCollisionProfileNameAttached' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, GibMaterialParameterResetList) == 0x0001E8, "Member 'UDamageGlobalsData::GibMaterialParameterResetList' has a wrong offset!");
static_assert(offsetof(UDamageGlobalsData, LanguageToTextureMap) == 0x0001F8, "Member 'UDamageGlobalsData::LanguageToTextureMap' has a wrong offset!");

// Class GbxGameSystemCore.DamageModifierComponent
// 0x0040 (0x01B8 - 0x0178)
class UDamageModifierComponent : public UActorComponent
{
public:
	TArray<class UConditionalDamageValueModifier*> ConditionalValueModifiers;                         // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UConditionalDamageCriticalModifier*> ConditionalCritModifiers;                          // 0x0188(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UConditionalDamageTypeModifier*> ConditionalTypeModifiers;                          // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UConditionalDamageHitRegionModifier*> ConditionalHitRegionModifiers;                     // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void RegisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier);
	void UnregisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageModifierComponent">();
	}
	static class UDamageModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageModifierComponent>();
	}
};
static_assert(alignof(UDamageModifierComponent) == 0x000008, "Wrong alignment on UDamageModifierComponent");
static_assert(sizeof(UDamageModifierComponent) == 0x0001B8, "Wrong size on UDamageModifierComponent");
static_assert(offsetof(UDamageModifierComponent, ConditionalValueModifiers) == 0x000178, "Member 'UDamageModifierComponent::ConditionalValueModifiers' has a wrong offset!");
static_assert(offsetof(UDamageModifierComponent, ConditionalCritModifiers) == 0x000188, "Member 'UDamageModifierComponent::ConditionalCritModifiers' has a wrong offset!");
static_assert(offsetof(UDamageModifierComponent, ConditionalTypeModifiers) == 0x000198, "Member 'UDamageModifierComponent::ConditionalTypeModifiers' has a wrong offset!");
static_assert(offsetof(UDamageModifierComponent, ConditionalHitRegionModifiers) == 0x0001A8, "Member 'UDamageModifierComponent::ConditionalHitRegionModifiers' has a wrong offset!");

// Class GbxGameSystemCore.DamageOverTimeManager
// 0x0020 (0x0048 - 0x0028)
class UDamageOverTimeManager : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageOverTimeInstance>        DamageInstances;                                   // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleSystemStopped(class UParticleSystemComponent* ParticleSystem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageOverTimeManager">();
	}
	static class UDamageOverTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageOverTimeManager>();
	}
};
static_assert(alignof(UDamageOverTimeManager) == 0x000008, "Wrong alignment on UDamageOverTimeManager");
static_assert(sizeof(UDamageOverTimeManager) == 0x000048, "Wrong size on UDamageOverTimeManager");
static_assert(offsetof(UDamageOverTimeManager, DamageInstances) == 0x000030, "Member 'UDamageOverTimeManager::DamageInstances' has a wrong offset!");

// Class GbxGameSystemCore.DamageSource
// 0x0060 (0x0088 - 0x0028)
class UDamageSource : public UObject
{
public:
	struct FDamageModifierAttributeCollection     ModifierAttributes;                                // 0x0028(0x0010)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           AIInstigatedDamageScale;                           // 0x0038(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDamageSourceHealthTypeModifier> HealthTypeModifiers;                               // 0x0070(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanCauseCriticals;                                // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollectForHitReactions;                           // 0x0081(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCooldown;                                   // 0x0082(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageSource">();
	}
	static class UDamageSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageSource>();
	}
};
static_assert(alignof(UDamageSource) == 0x000008, "Wrong alignment on UDamageSource");
static_assert(sizeof(UDamageSource) == 0x000088, "Wrong size on UDamageSource");
static_assert(offsetof(UDamageSource, ModifierAttributes) == 0x000028, "Member 'UDamageSource::ModifierAttributes' has a wrong offset!");
static_assert(offsetof(UDamageSource, AIInstigatedDamageScale) == 0x000038, "Member 'UDamageSource::AIInstigatedDamageScale' has a wrong offset!");
static_assert(offsetof(UDamageSource, HealthTypeModifiers) == 0x000070, "Member 'UDamageSource::HealthTypeModifiers' has a wrong offset!");
static_assert(offsetof(UDamageSource, bCanCauseCriticals) == 0x000080, "Member 'UDamageSource::bCanCauseCriticals' has a wrong offset!");
static_assert(offsetof(UDamageSource, bCollectForHitReactions) == 0x000081, "Member 'UDamageSource::bCollectForHitReactions' has a wrong offset!");
static_assert(offsetof(UDamageSource, bIgnoreCooldown) == 0x000082, "Member 'UDamageSource::bIgnoreCooldown' has a wrong offset!");

// Class GbxGameSystemCore.DrunkenBaseMovementComponent
// 0x0040 (0x01B8 - 0x0178)
#pragma pack(push, 0x1)
class alignas(0x08) UDrunkenBaseMovementComponent : public UActorComponent
{
public:
	float                                         StartApproachDistance;                             // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelayTime;                                    // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EaseInTime;                                        // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x8];                                      // 0x0184(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomNumberSeed;                                  // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x28];                                     // 0x0190(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrunkenBaseMovementComponent">();
	}
	static class UDrunkenBaseMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrunkenBaseMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDrunkenBaseMovementComponent) == 0x000008, "Wrong alignment on UDrunkenBaseMovementComponent");
static_assert(sizeof(UDrunkenBaseMovementComponent) == 0x0001B8, "Wrong size on UDrunkenBaseMovementComponent");
static_assert(offsetof(UDrunkenBaseMovementComponent, StartApproachDistance) == 0x000178, "Member 'UDrunkenBaseMovementComponent::StartApproachDistance' has a wrong offset!");
static_assert(offsetof(UDrunkenBaseMovementComponent, StartDelayTime) == 0x00017C, "Member 'UDrunkenBaseMovementComponent::StartDelayTime' has a wrong offset!");
static_assert(offsetof(UDrunkenBaseMovementComponent, EaseInTime) == 0x000180, "Member 'UDrunkenBaseMovementComponent::EaseInTime' has a wrong offset!");
static_assert(offsetof(UDrunkenBaseMovementComponent, RandomNumberSeed) == 0x00018C, "Member 'UDrunkenBaseMovementComponent::RandomNumberSeed' has a wrong offset!");

// Class GbxGameSystemCore.DrunkenRandomMovementComponent
// 0x0058 (0x0210 - 0x01B8)
class UDrunkenRandomMovementComponent final : public UDrunkenBaseMovementComponent
{
public:
	float                                         PathCorrectionInterval;                            // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpreadAngle;                                    // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepartureAngle;                                 // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravityAffectsDrunkenness;                        // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrunkenGravityScalar;                              // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x28];                                     // 0x01D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFixDrunkenMovementAcceleration;                   // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F9[0x17];                                     // 0x01F9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrunkenRandomMovementComponent">();
	}
	static class UDrunkenRandomMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrunkenRandomMovementComponent>();
	}
};
static_assert(alignof(UDrunkenRandomMovementComponent) == 0x000008, "Wrong alignment on UDrunkenRandomMovementComponent");
static_assert(sizeof(UDrunkenRandomMovementComponent) == 0x000210, "Wrong size on UDrunkenRandomMovementComponent");
static_assert(offsetof(UDrunkenRandomMovementComponent, PathCorrectionInterval) == 0x0001B8, "Member 'UDrunkenRandomMovementComponent::PathCorrectionInterval' has a wrong offset!");
static_assert(offsetof(UDrunkenRandomMovementComponent, TurnSpeed) == 0x0001BC, "Member 'UDrunkenRandomMovementComponent::TurnSpeed' has a wrong offset!");
static_assert(offsetof(UDrunkenRandomMovementComponent, MaxSpreadAngle) == 0x0001C0, "Member 'UDrunkenRandomMovementComponent::MaxSpreadAngle' has a wrong offset!");
static_assert(offsetof(UDrunkenRandomMovementComponent, MaxDepartureAngle) == 0x0001C4, "Member 'UDrunkenRandomMovementComponent::MaxDepartureAngle' has a wrong offset!");
static_assert(offsetof(UDrunkenRandomMovementComponent, bGravityAffectsDrunkenness) == 0x0001C8, "Member 'UDrunkenRandomMovementComponent::bGravityAffectsDrunkenness' has a wrong offset!");
static_assert(offsetof(UDrunkenRandomMovementComponent, DrunkenGravityScalar) == 0x0001CC, "Member 'UDrunkenRandomMovementComponent::DrunkenGravityScalar' has a wrong offset!");
static_assert(offsetof(UDrunkenRandomMovementComponent, bFixDrunkenMovementAcceleration) == 0x0001F8, "Member 'UDrunkenRandomMovementComponent::bFixDrunkenMovementAcceleration' has a wrong offset!");

// Class GbxGameSystemCore.GbxDamageType
// 0x00E8 (0x0128 - 0x0040)
class UGbxDamageType : public UDamageType
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DamageTypeDisplayName;                             // 0x0048(0x0018)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DamageEffectVerb;                                  // 0x0060(0x0018)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DamageTypeBaseDescription;                         // 0x0078(0x0018)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           DamageColor;                                       // 0x0090(0x0010)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageIconFrameName;                               // 0x00A0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHealingType;                                    // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoT;                                            // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InnerDamageRadiusPercent;                          // 0x00B4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterDamageRadiusPercent;                          // 0x00B8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadiusDamageScalar;                             // 0x00BC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x00C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDamageModifierAttributeCollection     ModifierAttributes;                                // 0x00E0(0x0010)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    OnlyApplyToThisHealthType;                         // 0x00F0(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0100(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageSurfaceModifier>         SurfaceDamageModifiers;                            // 0x0108(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UUIStatData*>                    UIStats;                                           // 0x0118(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	bool IsElementalType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDamageType">();
	}
	static class UGbxDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDamageType>();
	}
};
static_assert(alignof(UGbxDamageType) == 0x000008, "Wrong alignment on UGbxDamageType");
static_assert(sizeof(UGbxDamageType) == 0x000128, "Wrong size on UGbxDamageType");
static_assert(offsetof(UGbxDamageType, DamageTypeDisplayName) == 0x000048, "Member 'UGbxDamageType::DamageTypeDisplayName' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, DamageEffectVerb) == 0x000060, "Member 'UGbxDamageType::DamageEffectVerb' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, DamageTypeBaseDescription) == 0x000078, "Member 'UGbxDamageType::DamageTypeBaseDescription' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, DamageColor) == 0x000090, "Member 'UGbxDamageType::DamageColor' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, DamageIconFrameName) == 0x0000A0, "Member 'UGbxDamageType::DamageIconFrameName' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, bIsHealingType) == 0x0000B0, "Member 'UGbxDamageType::bIsHealingType' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, bIsDoT) == 0x0000B1, "Member 'UGbxDamageType::bIsDoT' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, InnerDamageRadiusPercent) == 0x0000B4, "Member 'UGbxDamageType::InnerDamageRadiusPercent' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, OuterDamageRadiusPercent) == 0x0000B8, "Member 'UGbxDamageType::OuterDamageRadiusPercent' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, MinRadiusDamageScalar) == 0x0000BC, "Member 'UGbxDamageType::MinRadiusDamageScalar' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, GameplayTags) == 0x0000C0, "Member 'UGbxDamageType::GameplayTags' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, ModifierAttributes) == 0x0000E0, "Member 'UGbxDamageType::ModifierAttributes' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, OnlyApplyToThisHealthType) == 0x0000F0, "Member 'UGbxDamageType::OnlyApplyToThisHealthType' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, StatusEffectData) == 0x000100, "Member 'UGbxDamageType::StatusEffectData' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, SurfaceDamageModifiers) == 0x000108, "Member 'UGbxDamageType::SurfaceDamageModifiers' has a wrong offset!");
static_assert(offsetof(UGbxDamageType, UIStats) == 0x000118, "Member 'UGbxDamageType::UIStats' has a wrong offset!");

// Class GbxGameSystemCore.GbxBoneModifyProfile
// 0x0030 (0x0060 - 0x0030)
class UGbxBoneModifyProfile final : public UGbxDataAsset
{
public:
	class UAnimSequence*                          ReferenceAnimation;                                // 0x0030(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTranslation;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotation;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxBoneModifyProfile_PoseMode                PoseMode;                                          // 0x003B(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationTime;                                     // 0x003C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBoneModifyInfo>                Bones;                                             // 0x0040(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FBoneModifyState>               BoneModStates;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxBoneModifyProfile">();
	}
	static class UGbxBoneModifyProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxBoneModifyProfile>();
	}
};
static_assert(alignof(UGbxBoneModifyProfile) == 0x000008, "Wrong alignment on UGbxBoneModifyProfile");
static_assert(sizeof(UGbxBoneModifyProfile) == 0x000060, "Wrong size on UGbxBoneModifyProfile");
static_assert(offsetof(UGbxBoneModifyProfile, ReferenceAnimation) == 0x000030, "Member 'UGbxBoneModifyProfile::ReferenceAnimation' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, bUseTranslation) == 0x000038, "Member 'UGbxBoneModifyProfile::bUseTranslation' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, bUseRotation) == 0x000039, "Member 'UGbxBoneModifyProfile::bUseRotation' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, bUseScale) == 0x00003A, "Member 'UGbxBoneModifyProfile::bUseScale' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, PoseMode) == 0x00003B, "Member 'UGbxBoneModifyProfile::PoseMode' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, AnimationTime) == 0x00003C, "Member 'UGbxBoneModifyProfile::AnimationTime' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, Bones) == 0x000040, "Member 'UGbxBoneModifyProfile::Bones' has a wrong offset!");
static_assert(offsetof(UGbxBoneModifyProfile, BoneModStates) == 0x000050, "Member 'UGbxBoneModifyProfile::BoneModStates' has a wrong offset!");

// Class GbxGameSystemCore.EnvQueryContext_EnvQueryParam
// 0x0010 (0x0038 - 0x0028)
class UEnvQueryContext_EnvQueryParam : public UEnvQueryContext
{
public:
	class FName                                   DefaultBlackboardKeyName;                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowsUnboundContext;                              // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_EnvQueryParam">();
	}
	static class UEnvQueryContext_EnvQueryParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_EnvQueryParam>();
	}
};
static_assert(alignof(UEnvQueryContext_EnvQueryParam) == 0x000008, "Wrong alignment on UEnvQueryContext_EnvQueryParam");
static_assert(sizeof(UEnvQueryContext_EnvQueryParam) == 0x000038, "Wrong size on UEnvQueryContext_EnvQueryParam");
static_assert(offsetof(UEnvQueryContext_EnvQueryParam, DefaultBlackboardKeyName) == 0x000028, "Member 'UEnvQueryContext_EnvQueryParam::DefaultBlackboardKeyName' has a wrong offset!");
static_assert(offsetof(UEnvQueryContext_EnvQueryParam, AllowsUnboundContext) == 0x000030, "Member 'UEnvQueryContext_EnvQueryParam::AllowsUnboundContext' has a wrong offset!");

// Class GbxGameSystemCore.FirstPersonComponent
// 0x03E8 (0x0560 - 0x0178)
#pragma pack(push, 0x1)
class alignas(0x08) UFirstPersonComponent : public UActorComponent
{
public:
	TSubclassOf<class AFirstPersonConfigurationData> ConfigData;                                        // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxSkeletalMeshComponent*              Arms;                                              // 0x0180(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxSkeletalMeshComponent*              Legs;                                              // 0x0188(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstPersonRootBone;                               // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraSocket;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrimaryHandWeaponSocket;                           // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          BaseTransformsAnimation;                           // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x90];                                     // 0x01B0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchTransitionDuration;                          // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchTransitionEasing;                            // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x20];                                     // 0x0248(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FViewLeadingTranslationInfo>    TranslationLeadingList;                            // 0x0268(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FViewLeadingTranslationInfo            TranslationLeading;                                // 0x0278(0x002C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FViewLeadingRotationInfo>       RotationleadingList;                               // 0x02A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FViewLeadingRotationInfo               RotationLeading;                                   // 0x02B8(0x003C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FViewLeadingRotationInfo               ZoomRotationLeading;                               // 0x02F4(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ZoomRotationSocket;                                // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotOffsetSpeed;                                   // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotOffsetRecoverySpeed;                           // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxViewModelImpulseTranslationOffset;              // 0x0340(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MaxViewModelImpulseRotationOffset;                 // 0x034C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        FlinchBlendSpace;                                  // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FlinchAnimSlotName;                                // 0x0360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFlinchBlendInTime;                          // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFlinchBlendOutTime;                         // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptFlinchBlendInTime;                        // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchInterruptThreshold;                          // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomedFlinchWeight;                                // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnFirstPersonCreated;                              // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x30];                                     // 0x0390(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     ViewModelOffsetList;                               // 0x03C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CurrentShotRotationOffset;                         // 0x0400(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BaseViewModelLocationOffset;                       // 0x0410(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x2C];                                     // 0x041C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                CreatedFirstPersonComponents;                      // 0x0448(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTrackedFirstPersonComponent>   TopLevelComponents;                                // 0x0460(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x4];                                      // 0x0470(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetShotRotationOffset;                          // 0x0474(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentRelativeLocation;                           // 0x0490(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DefaultTranslationOffset;                          // 0x049C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0xB4];                                     // 0x04A8(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseEyeToWeaponTransform(const struct FTransform& NewWeaponTransform);

	class USceneComponent* GetFirstPersonComponentByName(class FName Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstPersonComponent">();
	}
	static class UFirstPersonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstPersonComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFirstPersonComponent) == 0x000008, "Wrong alignment on UFirstPersonComponent");
static_assert(sizeof(UFirstPersonComponent) == 0x000560, "Wrong size on UFirstPersonComponent");
static_assert(offsetof(UFirstPersonComponent, ConfigData) == 0x000178, "Member 'UFirstPersonComponent::ConfigData' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, Arms) == 0x000180, "Member 'UFirstPersonComponent::Arms' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, Legs) == 0x000188, "Member 'UFirstPersonComponent::Legs' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, FirstPersonRootBone) == 0x000190, "Member 'UFirstPersonComponent::FirstPersonRootBone' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, CameraSocket) == 0x000198, "Member 'UFirstPersonComponent::CameraSocket' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, PrimaryHandWeaponSocket) == 0x0001A0, "Member 'UFirstPersonComponent::PrimaryHandWeaponSocket' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, BaseTransformsAnimation) == 0x0001A8, "Member 'UFirstPersonComponent::BaseTransformsAnimation' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, CrouchTransitionDuration) == 0x000240, "Member 'UFirstPersonComponent::CrouchTransitionDuration' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, CrouchTransitionEasing) == 0x000244, "Member 'UFirstPersonComponent::CrouchTransitionEasing' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, TranslationLeadingList) == 0x000268, "Member 'UFirstPersonComponent::TranslationLeadingList' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, TranslationLeading) == 0x000278, "Member 'UFirstPersonComponent::TranslationLeading' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, RotationleadingList) == 0x0002A8, "Member 'UFirstPersonComponent::RotationleadingList' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, RotationLeading) == 0x0002B8, "Member 'UFirstPersonComponent::RotationLeading' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, ZoomRotationLeading) == 0x0002F4, "Member 'UFirstPersonComponent::ZoomRotationLeading' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, ZoomRotationSocket) == 0x000330, "Member 'UFirstPersonComponent::ZoomRotationSocket' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, ShotOffsetSpeed) == 0x000338, "Member 'UFirstPersonComponent::ShotOffsetSpeed' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, ShotOffsetRecoverySpeed) == 0x00033C, "Member 'UFirstPersonComponent::ShotOffsetRecoverySpeed' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, MaxViewModelImpulseTranslationOffset) == 0x000340, "Member 'UFirstPersonComponent::MaxViewModelImpulseTranslationOffset' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, MaxViewModelImpulseRotationOffset) == 0x00034C, "Member 'UFirstPersonComponent::MaxViewModelImpulseRotationOffset' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, FlinchBlendSpace) == 0x000358, "Member 'UFirstPersonComponent::FlinchBlendSpace' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, FlinchAnimSlotName) == 0x000360, "Member 'UFirstPersonComponent::FlinchAnimSlotName' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, DefaultFlinchBlendInTime) == 0x000368, "Member 'UFirstPersonComponent::DefaultFlinchBlendInTime' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, DefaultFlinchBlendOutTime) == 0x00036C, "Member 'UFirstPersonComponent::DefaultFlinchBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, InterruptFlinchBlendInTime) == 0x000370, "Member 'UFirstPersonComponent::InterruptFlinchBlendInTime' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, FlinchInterruptThreshold) == 0x000374, "Member 'UFirstPersonComponent::FlinchInterruptThreshold' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, ZoomedFlinchWeight) == 0x000378, "Member 'UFirstPersonComponent::ZoomedFlinchWeight' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, OnFirstPersonCreated) == 0x000380, "Member 'UFirstPersonComponent::OnFirstPersonCreated' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, ViewModelOffsetList) == 0x0003C0, "Member 'UFirstPersonComponent::ViewModelOffsetList' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, CurrentShotRotationOffset) == 0x000400, "Member 'UFirstPersonComponent::CurrentShotRotationOffset' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, BaseViewModelLocationOffset) == 0x000410, "Member 'UFirstPersonComponent::BaseViewModelLocationOffset' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, CreatedFirstPersonComponents) == 0x000448, "Member 'UFirstPersonComponent::CreatedFirstPersonComponents' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, TopLevelComponents) == 0x000460, "Member 'UFirstPersonComponent::TopLevelComponents' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, TargetShotRotationOffset) == 0x000474, "Member 'UFirstPersonComponent::TargetShotRotationOffset' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, CurrentRelativeLocation) == 0x000490, "Member 'UFirstPersonComponent::CurrentRelativeLocation' has a wrong offset!");
static_assert(offsetof(UFirstPersonComponent, DefaultTranslationOffset) == 0x00049C, "Member 'UFirstPersonComponent::DefaultTranslationOffset' has a wrong offset!");

// Class GbxGameSystemCore.ImpactExpansionData
// 0x0018 (0x0048 - 0x0030)
class UImpactExpansionData final : public UGbxDataAsset
{
public:
	class UImpactData*                            ImpactDataToExpand;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FImpactResponseInfo>            ImpactResponses;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactExpansionData">();
	}
	static class UImpactExpansionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpactExpansionData>();
	}
};
static_assert(alignof(UImpactExpansionData) == 0x000008, "Wrong alignment on UImpactExpansionData");
static_assert(sizeof(UImpactExpansionData) == 0x000048, "Wrong size on UImpactExpansionData");
static_assert(offsetof(UImpactExpansionData, ImpactDataToExpand) == 0x000030, "Member 'UImpactExpansionData::ImpactDataToExpand' has a wrong offset!");
static_assert(offsetof(UImpactExpansionData, ImpactResponses) == 0x000038, "Member 'UImpactExpansionData::ImpactResponses' has a wrong offset!");

// Class GbxGameSystemCore.GbxGameInstance
// 0x0128 (0x01F0 - 0x00C8)
class UGbxGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMenuStash                             MenuStashes[0x4];                                  // 0x00E8(0x0010)(Transient, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        CharacterMassPresets;                              // 0x0128(0x0018)(Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CachedCharacterMassPresets;                        // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        ForcePresets;                                      // 0x0148(0x0018)(Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CachedForcePresets;                                // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        SpawnCostPresets;                                  // 0x0168(0x0018)(Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CachedSpawnCostPresets;                            // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCinematicModeData*>             CinematicModeStack;                                // 0x0188(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCinematicModeData*                     CinematicMode;                                     // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIGbxProjectileManager*                 ProjectileManager;                                 // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSharedPickupInventoryActor>    SharedPickupInventoryActors;                       // 0x01A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x38];                                     // 0x01B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugLoadStartupAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameInstance">();
	}
	static class UGbxGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGameInstance>();
	}
};
static_assert(alignof(UGbxGameInstance) == 0x000008, "Wrong alignment on UGbxGameInstance");
static_assert(sizeof(UGbxGameInstance) == 0x0001F0, "Wrong size on UGbxGameInstance");
static_assert(offsetof(UGbxGameInstance, MenuStashes) == 0x0000E8, "Member 'UGbxGameInstance::MenuStashes' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, CharacterMassPresets) == 0x000128, "Member 'UGbxGameInstance::CharacterMassPresets' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, CachedCharacterMassPresets) == 0x000140, "Member 'UGbxGameInstance::CachedCharacterMassPresets' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, ForcePresets) == 0x000148, "Member 'UGbxGameInstance::ForcePresets' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, CachedForcePresets) == 0x000160, "Member 'UGbxGameInstance::CachedForcePresets' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, SpawnCostPresets) == 0x000168, "Member 'UGbxGameInstance::SpawnCostPresets' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, CachedSpawnCostPresets) == 0x000180, "Member 'UGbxGameInstance::CachedSpawnCostPresets' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, CinematicModeStack) == 0x000188, "Member 'UGbxGameInstance::CinematicModeStack' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, CinematicMode) == 0x000198, "Member 'UGbxGameInstance::CinematicMode' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, ProjectileManager) == 0x0001A0, "Member 'UGbxGameInstance::ProjectileManager' has a wrong offset!");
static_assert(offsetof(UGbxGameInstance, SharedPickupInventoryActors) == 0x0001A8, "Member 'UGbxGameInstance::SharedPickupInventoryActors' has a wrong offset!");

// Class GbxGameSystemCore.GlobalAIData
// 0x00F0 (0x0120 - 0x0030)
class UGlobalAIData : public UGbxDataAsset
{
public:
	struct FGameplayTag                           CombatTag;                                         // 0x0030(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PassiveTag;                                        // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AITimeToRememberDirectAttacks;                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AITimeToRememberNonAttackingEnemies;               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AITimeToRememberHiddenEnemies;                     // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitReactionTag*                        JumpHitReactionDeathOverride;                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHitReactionLayer>          JumpHitLiveReactionLayer;                          // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceOfPlayingFirstNoticerAggroAnimation;         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceOfPlayingSecondNoticerAggroAnimation;        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVariableAccuracy;                              // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           TimeToBestAccuracy;                                // 0x0070(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamagePctToWorstAccuracy;                          // 0x00A8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamagePctDecayRate;                                // 0x00E0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinAccuracy;                                       // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalAIData">();
	}
	static class UGlobalAIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalAIData>();
	}
};
static_assert(alignof(UGlobalAIData) == 0x000008, "Wrong alignment on UGlobalAIData");
static_assert(sizeof(UGlobalAIData) == 0x000120, "Wrong size on UGlobalAIData");
static_assert(offsetof(UGlobalAIData, CombatTag) == 0x000030, "Member 'UGlobalAIData::CombatTag' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, PassiveTag) == 0x000038, "Member 'UGlobalAIData::PassiveTag' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, AITimeToRememberDirectAttacks) == 0x000040, "Member 'UGlobalAIData::AITimeToRememberDirectAttacks' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, AITimeToRememberNonAttackingEnemies) == 0x000044, "Member 'UGlobalAIData::AITimeToRememberNonAttackingEnemies' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, AITimeToRememberHiddenEnemies) == 0x000048, "Member 'UGlobalAIData::AITimeToRememberHiddenEnemies' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, JumpHitReactionDeathOverride) == 0x000050, "Member 'UGlobalAIData::JumpHitReactionDeathOverride' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, JumpHitLiveReactionLayer) == 0x000058, "Member 'UGlobalAIData::JumpHitLiveReactionLayer' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, ChanceOfPlayingFirstNoticerAggroAnimation) == 0x000060, "Member 'UGlobalAIData::ChanceOfPlayingFirstNoticerAggroAnimation' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, ChanceOfPlayingSecondNoticerAggroAnimation) == 0x000064, "Member 'UGlobalAIData::ChanceOfPlayingSecondNoticerAggroAnimation' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, bUseVariableAccuracy) == 0x000068, "Member 'UGlobalAIData::bUseVariableAccuracy' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, TimeToBestAccuracy) == 0x000070, "Member 'UGlobalAIData::TimeToBestAccuracy' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, DamagePctToWorstAccuracy) == 0x0000A8, "Member 'UGlobalAIData::DamagePctToWorstAccuracy' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, DamagePctDecayRate) == 0x0000E0, "Member 'UGlobalAIData::DamagePctDecayRate' has a wrong offset!");
static_assert(offsetof(UGlobalAIData, MinAccuracy) == 0x000118, "Member 'UGlobalAIData::MinAccuracy' has a wrong offset!");

// Class GbxGameSystemCore.EQSProxyInterface
// 0x0000 (0x0028 - 0x0028)
class IEQSProxyInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQSProxyInterface">();
	}
	static class IEQSProxyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEQSProxyInterface>();
	}
};
static_assert(alignof(IEQSProxyInterface) == 0x000008, "Wrong alignment on IEQSProxyInterface");
static_assert(sizeof(IEQSProxyInterface) == 0x000028, "Wrong size on IEQSProxyInterface");

// Class GbxGameSystemCore.GbxGlobalsData
// 0x0060 (0x0090 - 0x0030)
class UGbxGlobalsData : public UGbxDataAsset
{
public:
	TSoftObjectPtr<class UDamageGlobalsData>      DamageGlobalsData;                                 // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGameplayGlobals*                    GameplayGlobals;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStatusEffectGlobalsData> StatusEffectGlobals;                               // 0x0060(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAssetMappingData*                      AssetMapping;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGlobalsData">();
	}
	static class UGbxGlobalsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGlobalsData>();
	}
};
static_assert(alignof(UGbxGlobalsData) == 0x000008, "Wrong alignment on UGbxGlobalsData");
static_assert(sizeof(UGbxGlobalsData) == 0x000090, "Wrong size on UGbxGlobalsData");
static_assert(offsetof(UGbxGlobalsData, DamageGlobalsData) == 0x000030, "Member 'UGbxGlobalsData::DamageGlobalsData' has a wrong offset!");
static_assert(offsetof(UGbxGlobalsData, GameplayGlobals) == 0x000058, "Member 'UGbxGlobalsData::GameplayGlobals' has a wrong offset!");
static_assert(offsetof(UGbxGlobalsData, StatusEffectGlobals) == 0x000060, "Member 'UGbxGlobalsData::StatusEffectGlobals' has a wrong offset!");
static_assert(offsetof(UGbxGlobalsData, AssetMapping) == 0x000088, "Member 'UGbxGlobalsData::AssetMapping' has a wrong offset!");

// Class GbxGameSystemCore.HitRegionComponent
// 0x0038 (0x01B0 - 0x0178)
class UHitRegionComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitRegionData*                         DefaultHitRegion;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHitRegionState>                HitRegions;                                        // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 CachedMesh;                                        // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       CachedDamageComponent;                             // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void TriggerClientEvent(const struct FDamageReactionEventSummary& EventSummary);

	float GetHitRegionCurrentHealth(class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent) const;
	float GetHitRegionMaxHealth(class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent) const;
	float GetHitRegionPercentHealth(class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent) const;
	void GetValidAssociatedComponentNames(TArray<class FName>* Array) const;
	void GetValidDamageEventFunctionNames(TArray<class FName>* Array) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitRegionComponent">();
	}
	static class UHitRegionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitRegionComponent>();
	}
};
static_assert(alignof(UHitRegionComponent) == 0x000008, "Wrong alignment on UHitRegionComponent");
static_assert(sizeof(UHitRegionComponent) == 0x0001B0, "Wrong size on UHitRegionComponent");
static_assert(offsetof(UHitRegionComponent, DefaultHitRegion) == 0x000180, "Member 'UHitRegionComponent::DefaultHitRegion' has a wrong offset!");
static_assert(offsetof(UHitRegionComponent, HitRegions) == 0x000188, "Member 'UHitRegionComponent::HitRegions' has a wrong offset!");
static_assert(offsetof(UHitRegionComponent, CachedMesh) == 0x0001A0, "Member 'UHitRegionComponent::CachedMesh' has a wrong offset!");
static_assert(offsetof(UHitRegionComponent, CachedDamageComponent) == 0x0001A8, "Member 'UHitRegionComponent::CachedDamageComponent' has a wrong offset!");

// Class GbxGameSystemCore.HitRegionData
// 0x0230 (0x0260 - 0x0030)
class UHitRegionData : public UGbxDataAsset
{
public:
	class FName                                   HitRegionName;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNames;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bCanEverTakeRadiusDamage : 1;                      // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCriticalHit : 1;                                  // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRadiusDamage : 1;                            // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBlockAreaDamage : 1;                        // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRadiusDamageToBeConvertedToImpactDamage : 1; // 0x0048(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrackDamage : 1;                                  // 0x0048(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitRegionHealthParams                 HealthParams;                                      // 0x0050(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseDamageScale;                                   // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageScale;                                       // 0x0070(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShowDamageNumbers;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReflect;                                       // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReflectionChance;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRicochet;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RicochetChance;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRicochetIfReflectionFails;                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyReflectToAttacker;                            // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReflectionAccuracyModifier;                        // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncomingReflectedDamageScale;                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutgoingReflectedDamageScale;                      // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableBulletMagnetism;                           // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BulletMagnetismOverrideBoneNames;                  // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideImpactEffect;                             // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0xF];                                       // 0x00E1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpactResponseEffect                  EffectOverride;                                    // 0x00F0(0x0140)(Edit, NativeAccessSpecifierPublic)
	bool                                          bPlayImactEffectWithNoDamage;                      // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoSplatterEffect;                                 // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            SplatterEffect;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CustomDamageNumberParticleSystem;                  // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableHitReactions;                              // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDamageSurfaceType                            DefaultDamageSurface;                              // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitRegionData">();
	}
	static class UHitRegionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitRegionData>();
	}
};
static_assert(alignof(UHitRegionData) == 0x000010, "Wrong alignment on UHitRegionData");
static_assert(sizeof(UHitRegionData) == 0x000260, "Wrong size on UHitRegionData");
static_assert(offsetof(UHitRegionData, HitRegionName) == 0x000030, "Member 'UHitRegionData::HitRegionName' has a wrong offset!");
static_assert(offsetof(UHitRegionData, BoneNames) == 0x000038, "Member 'UHitRegionData::BoneNames' has a wrong offset!");
static_assert(offsetof(UHitRegionData, HealthParams) == 0x000050, "Member 'UHitRegionData::HealthParams' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bUseDamageScale) == 0x000068, "Member 'UHitRegionData::bUseDamageScale' has a wrong offset!");
static_assert(offsetof(UHitRegionData, DamageScale) == 0x000070, "Member 'UHitRegionData::DamageScale' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bShowDamageNumbers) == 0x0000A8, "Member 'UHitRegionData::bShowDamageNumbers' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bCanReflect) == 0x0000A9, "Member 'UHitRegionData::bCanReflect' has a wrong offset!");
static_assert(offsetof(UHitRegionData, ReflectionChance) == 0x0000AC, "Member 'UHitRegionData::ReflectionChance' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bCanRicochet) == 0x0000B0, "Member 'UHitRegionData::bCanRicochet' has a wrong offset!");
static_assert(offsetof(UHitRegionData, RicochetChance) == 0x0000B4, "Member 'UHitRegionData::RicochetChance' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bRicochetIfReflectionFails) == 0x0000B8, "Member 'UHitRegionData::bRicochetIfReflectionFails' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bOnlyReflectToAttacker) == 0x0000B9, "Member 'UHitRegionData::bOnlyReflectToAttacker' has a wrong offset!");
static_assert(offsetof(UHitRegionData, ReflectionAccuracyModifier) == 0x0000BC, "Member 'UHitRegionData::ReflectionAccuracyModifier' has a wrong offset!");
static_assert(offsetof(UHitRegionData, IncomingReflectedDamageScale) == 0x0000C0, "Member 'UHitRegionData::IncomingReflectedDamageScale' has a wrong offset!");
static_assert(offsetof(UHitRegionData, OutgoingReflectedDamageScale) == 0x0000C4, "Member 'UHitRegionData::OutgoingReflectedDamageScale' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bDisableBulletMagnetism) == 0x0000C8, "Member 'UHitRegionData::bDisableBulletMagnetism' has a wrong offset!");
static_assert(offsetof(UHitRegionData, BulletMagnetismOverrideBoneNames) == 0x0000D0, "Member 'UHitRegionData::BulletMagnetismOverrideBoneNames' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bOverrideImpactEffect) == 0x0000E0, "Member 'UHitRegionData::bOverrideImpactEffect' has a wrong offset!");
static_assert(offsetof(UHitRegionData, EffectOverride) == 0x0000F0, "Member 'UHitRegionData::EffectOverride' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bPlayImactEffectWithNoDamage) == 0x000230, "Member 'UHitRegionData::bPlayImactEffectWithNoDamage' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bNoSplatterEffect) == 0x000231, "Member 'UHitRegionData::bNoSplatterEffect' has a wrong offset!");
static_assert(offsetof(UHitRegionData, SplatterEffect) == 0x000238, "Member 'UHitRegionData::SplatterEffect' has a wrong offset!");
static_assert(offsetof(UHitRegionData, CustomDamageNumberParticleSystem) == 0x000240, "Member 'UHitRegionData::CustomDamageNumberParticleSystem' has a wrong offset!");
static_assert(offsetof(UHitRegionData, bDisableHitReactions) == 0x000248, "Member 'UHitRegionData::bDisableHitReactions' has a wrong offset!");
static_assert(offsetof(UHitRegionData, PhysicalMaterial) == 0x000250, "Member 'UHitRegionData::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UHitRegionData, DefaultDamageSurface) == 0x000258, "Member 'UHitRegionData::DefaultDamageSurface' has a wrong offset!");

// Class GbxGameSystemCore.ActorPartData
// 0x00D0 (0x0100 - 0x0030)
class UActorPartData : public UGbxDataAsset
{
public:
	class UEnum*                                  PartTypeEnum;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PartType;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGestaltData*                           GestaltData;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GestaltMeshPartName;                               // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AdditionalGestaltMeshPartNames;                    // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMultiSelectionGestaltPartNameData> MultiSelectionGestaltPartNames;                    // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           MinGameStage;                                      // 0x0070(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           MaxGameStage;                                      // 0x00A8(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UActorPartData*>                 Dependencies;                                      // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UActorPartData*>                 Excluders;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	void EnumerateGestaltMeshPartNames(TArray<class FName>* OutPartNameList) const;
	void EnumerateOtherParts(TArray<class UActorPartData*>* OutPartList) const;
	void EnumeratePossibleDependencies(TArray<class UActorPartData*>* OutPartList) const;
	void EnumeratePossibleExcluders(TArray<class UActorPartData*>* OutPartList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPartData">();
	}
	static class UActorPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPartData>();
	}
};
static_assert(alignof(UActorPartData) == 0x000008, "Wrong alignment on UActorPartData");
static_assert(sizeof(UActorPartData) == 0x000100, "Wrong size on UActorPartData");
static_assert(offsetof(UActorPartData, PartTypeEnum) == 0x000030, "Member 'UActorPartData::PartTypeEnum' has a wrong offset!");
static_assert(offsetof(UActorPartData, PartType) == 0x000038, "Member 'UActorPartData::PartType' has a wrong offset!");
static_assert(offsetof(UActorPartData, GestaltData) == 0x000040, "Member 'UActorPartData::GestaltData' has a wrong offset!");
static_assert(offsetof(UActorPartData, GestaltMeshPartName) == 0x000048, "Member 'UActorPartData::GestaltMeshPartName' has a wrong offset!");
static_assert(offsetof(UActorPartData, AdditionalGestaltMeshPartNames) == 0x000050, "Member 'UActorPartData::AdditionalGestaltMeshPartNames' has a wrong offset!");
static_assert(offsetof(UActorPartData, MultiSelectionGestaltPartNames) == 0x000060, "Member 'UActorPartData::MultiSelectionGestaltPartNames' has a wrong offset!");
static_assert(offsetof(UActorPartData, MinGameStage) == 0x000070, "Member 'UActorPartData::MinGameStage' has a wrong offset!");
static_assert(offsetof(UActorPartData, MaxGameStage) == 0x0000A8, "Member 'UActorPartData::MaxGameStage' has a wrong offset!");
static_assert(offsetof(UActorPartData, Dependencies) == 0x0000E0, "Member 'UActorPartData::Dependencies' has a wrong offset!");
static_assert(offsetof(UActorPartData, Excluders) == 0x0000F0, "Member 'UActorPartData::Excluders' has a wrong offset!");

// Class GbxGameSystemCore.LadderInteractData
// 0x0210 (0x0240 - 0x0030)
class ULadderInteractData : public UGbxDataAsset
{
public:
	float                                         RequiredViewAlignment;                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredRearViewAlignment;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMountLadderFromTopWhileFacing;                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVerticalSpeedToGrabLadder;                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRegrabDelay;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopEnterAnimSyncTime;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopExitAnimSyncTime;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitLocationDepthOffset;                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitingTopThresholdHeightOffset;                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnteringTopTargetHeightOffset;                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnteringTopFeetToLadderThreshold;                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     LadderTopMountCurveHorz;                           // 0x0060(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LadderTopMountCurveVert;                           // 0x00D8(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LadderTopDismountCurveHorz;                        // 0x0150(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LadderTopDismountCurveVert;                        // 0x01C8(0x0078)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderInteractData">();
	}
	static class ULadderInteractData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULadderInteractData>();
	}
};
static_assert(alignof(ULadderInteractData) == 0x000008, "Wrong alignment on ULadderInteractData");
static_assert(sizeof(ULadderInteractData) == 0x000240, "Wrong size on ULadderInteractData");
static_assert(offsetof(ULadderInteractData, RequiredViewAlignment) == 0x000030, "Member 'ULadderInteractData::RequiredViewAlignment' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, RequiredRearViewAlignment) == 0x000034, "Member 'ULadderInteractData::RequiredRearViewAlignment' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, bCanMountLadderFromTopWhileFacing) == 0x000038, "Member 'ULadderInteractData::bCanMountLadderFromTopWhileFacing' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, MaxVerticalSpeedToGrabLadder) == 0x00003C, "Member 'ULadderInteractData::MaxVerticalSpeedToGrabLadder' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, JumpRegrabDelay) == 0x000040, "Member 'ULadderInteractData::JumpRegrabDelay' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, TopEnterAnimSyncTime) == 0x000044, "Member 'ULadderInteractData::TopEnterAnimSyncTime' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, TopExitAnimSyncTime) == 0x000048, "Member 'ULadderInteractData::TopExitAnimSyncTime' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, ExitLocationDepthOffset) == 0x00004C, "Member 'ULadderInteractData::ExitLocationDepthOffset' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, ExitingTopThresholdHeightOffset) == 0x000050, "Member 'ULadderInteractData::ExitingTopThresholdHeightOffset' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, EnteringTopTargetHeightOffset) == 0x000054, "Member 'ULadderInteractData::EnteringTopTargetHeightOffset' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, EnteringTopFeetToLadderThreshold) == 0x000058, "Member 'ULadderInteractData::EnteringTopFeetToLadderThreshold' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, LadderTopMountCurveHorz) == 0x000060, "Member 'ULadderInteractData::LadderTopMountCurveHorz' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, LadderTopMountCurveVert) == 0x0000D8, "Member 'ULadderInteractData::LadderTopMountCurveVert' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, LadderTopDismountCurveHorz) == 0x000150, "Member 'ULadderInteractData::LadderTopDismountCurveHorz' has a wrong offset!");
static_assert(offsetof(ULadderInteractData, LadderTopDismountCurveVert) == 0x0001C8, "Member 'ULadderInteractData::LadderTopDismountCurveVert' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_Footstep
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_Footstep final : public UAnimNotify
{
public:
	int32                                         FootIndex;                                         // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictToMatchingPlayerPerspective;              // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Footstep">();
	}
	static class UAnimNotify_Footstep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Footstep>();
	}
};
static_assert(alignof(UAnimNotify_Footstep) == 0x000008, "Wrong alignment on UAnimNotify_Footstep");
static_assert(sizeof(UAnimNotify_Footstep) == 0x000048, "Wrong size on UAnimNotify_Footstep");
static_assert(offsetof(UAnimNotify_Footstep, FootIndex) == 0x000038, "Member 'UAnimNotify_Footstep::FootIndex' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Footstep, Volume) == 0x00003C, "Member 'UAnimNotify_Footstep::Volume' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Footstep, Pitch) == 0x000040, "Member 'UAnimNotify_Footstep::Pitch' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Footstep, bRestrictToMatchingPlayerPerspective) == 0x000044, "Member 'UAnimNotify_Footstep::bRestrictToMatchingPlayerPerspective' has a wrong offset!");

// Class GbxGameSystemCore.NavComponent
// 0x0000 (0x0178 - 0x0178)
class UNavComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavComponent">();
	}
	static class UNavComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavComponent>();
	}
};
static_assert(alignof(UNavComponent) == 0x000008, "Wrong alignment on UNavComponent");
static_assert(sizeof(UNavComponent) == 0x000178, "Wrong size on UNavComponent");

// Class GbxGameSystemCore.GbxSkeletalMeshComponent
// 0x04F0 (0x1410 - 0x0F20)
class UGbxSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_F20[0x8];                                      // 0x0F20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USkeletalMeshComponent>  ParentAnimationComponent;                          // 0x0F28(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F30[0x8];                                      // 0x0F30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGestaltPartListData*                   GestaltPartList;                                   // 0x0F38(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGestaltPartData_Mesh*>          GestaltMeshParts;                                  // 0x0F40(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedGestaltPartsData            ReplicatedGestaltParts;                            // 0x0F50(0x0018)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         GestaultSeed;                                      // 0x0F68(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowDynamicallyAddedForwardDynamicsNodes;        // 0x0F6C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6D[0x3];                                      // 0x0F6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneModInstance>               BoneModInstances;                                  // 0x0F70(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F80[0x8];                                      // 0x0F80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStretchBonesInstance>          StretchBonesInstances;                             // 0x0F88(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_F98[0x8];                                      // 0x0F98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxBoneModifyProfile*                  BoneModifyProfile;                                 // 0x0FA0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateBoneMods;                                // 0x0FA8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA9[0x7];                                      // 0x0FA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneModifyProfileData                 BoneModifyProfileData;                             // 0x0FB0(0x0018)(Edit, Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC8[0x8];                                      // 0x0FC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LastUpdateTime;                                    // 0x0FD0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBMPOverride>                   CachedGlobalBMP;                                   // 0x0FD8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UGlobalBoneModifyProfileState*>  GlobalBMPRepArray;                                 // 0x0FE8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	float                                         NoBodyMass;                                        // 0x0FF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseMultiplier;                                 // 0x0FFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1000[0x60];                                    // 0x1000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            DefaultImpactData;                                 // 0x1060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UImpactData*>         BodyImpactDataOverrides;                           // 0x1068(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGbxCustomizationTargetData*>    CustomizationTargets;                              // 0x10B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FStretchAnimData                       StretchAnimData;                                   // 0x10C8(0x01E0)(Transient, NativeAccessSpecifierPublic)
	class UGbxAnimBlueprintProfile*               AnimBPProfile;                                     // 0x12A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGaitScalingOverride;                              // 0x12B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B1[0x7];                                     // 0x12B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGaitScalingSettings                   GaitScalingSettings;                               // 0x12B8(0x0038)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F0[0x18];                                    // 0x12F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAggregateSimulationSleepCheck;                 // 0x1308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1309[0x3];                                     // 0x1309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AggregateSimulationSleepCheckSeconds;              // 0x130C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AggregateSimulationSleepCheckDistance;             // 0x1310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1314[0x44];                                    // 0x1314(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimUpdateRateParameters              UpdateRateParametersOverride;                      // 0x1358(0x0088)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bOverrideUpdateRateParameters;                     // 0x13E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13E1[0xF];                                     // 0x13E1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAnimPoseMatch                      PoseMatch;                                         // 0x13F0(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	void CopyGestaltPartList(class AActor* GestaltPartListSource);
	void HideGestaltMeshPart(const class UGestaltPartData_Mesh* GestaltMeshPart, bool bLocalOnly);
	void HideGestaltMeshParts(const TArray<class UGestaltPartData_Mesh*>& Parts, bool bLocalOnly);
	void LinkSkelMeshAnimInstance(class USkeletalMeshComponent* InLinkedSkelMeshComponent);
	void LinkSkelMeshAnimInstances(const TArray<class USkeletalMeshComponent*>& InLinkedSkelMeshComponents);
	void OnRep_GestaltMeshParts();
	void OnRep_GlobalBoneMod();
	void RunPoseTest();
	void SetGestaltPartList(class UGestaltPartListData* NewGestaltPartList);
	void SetParentAnimationComponent(class USkeletalMeshComponent* ParentComponent);
	void SetUpdateOverrideValues(const TArray<float>& UpdateRateOverrides, bool bEnableOverrideProperties);
	void ShowGestaltMeshPart(const class UGestaltPartData_Mesh* GestaltMeshPart, bool bLocalOnly);
	void ShowGestaltMeshParts(const TArray<class UGestaltPartData_Mesh*>& Parts, bool bLocalOnly);

	void GetAvailableBoneNames(TArray<class FName>* Array) const;
	TArray<float> GetUpdateOverrideValues() const;
	bool IsCustomizationTargetFor(class UGbxCustomizationTargetData* TargetToTest) const;
	bool IsGestaltMeshPartVisible(const class UGestaltPartData_Mesh* GestaltMeshPart) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSkeletalMeshComponent">();
	}
	static class UGbxSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSkeletalMeshComponent>();
	}
};
static_assert(alignof(UGbxSkeletalMeshComponent) == 0x000008, "Wrong alignment on UGbxSkeletalMeshComponent");
static_assert(sizeof(UGbxSkeletalMeshComponent) == 0x001410, "Wrong size on UGbxSkeletalMeshComponent");
static_assert(offsetof(UGbxSkeletalMeshComponent, ParentAnimationComponent) == 0x000F28, "Member 'UGbxSkeletalMeshComponent::ParentAnimationComponent' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, GestaltPartList) == 0x000F38, "Member 'UGbxSkeletalMeshComponent::GestaltPartList' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, GestaltMeshParts) == 0x000F40, "Member 'UGbxSkeletalMeshComponent::GestaltMeshParts' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, ReplicatedGestaltParts) == 0x000F50, "Member 'UGbxSkeletalMeshComponent::ReplicatedGestaltParts' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, GestaultSeed) == 0x000F68, "Member 'UGbxSkeletalMeshComponent::GestaultSeed' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, bAllowDynamicallyAddedForwardDynamicsNodes) == 0x000F6C, "Member 'UGbxSkeletalMeshComponent::bAllowDynamicallyAddedForwardDynamicsNodes' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, BoneModInstances) == 0x000F70, "Member 'UGbxSkeletalMeshComponent::BoneModInstances' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, StretchBonesInstances) == 0x000F88, "Member 'UGbxSkeletalMeshComponent::StretchBonesInstances' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, BoneModifyProfile) == 0x000FA0, "Member 'UGbxSkeletalMeshComponent::BoneModifyProfile' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, bReplicateBoneMods) == 0x000FA8, "Member 'UGbxSkeletalMeshComponent::bReplicateBoneMods' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, BoneModifyProfileData) == 0x000FB0, "Member 'UGbxSkeletalMeshComponent::BoneModifyProfileData' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, LastUpdateTime) == 0x000FD0, "Member 'UGbxSkeletalMeshComponent::LastUpdateTime' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, CachedGlobalBMP) == 0x000FD8, "Member 'UGbxSkeletalMeshComponent::CachedGlobalBMP' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, GlobalBMPRepArray) == 0x000FE8, "Member 'UGbxSkeletalMeshComponent::GlobalBMPRepArray' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, NoBodyMass) == 0x000FF8, "Member 'UGbxSkeletalMeshComponent::NoBodyMass' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, ImpulseMultiplier) == 0x000FFC, "Member 'UGbxSkeletalMeshComponent::ImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, DefaultImpactData) == 0x001060, "Member 'UGbxSkeletalMeshComponent::DefaultImpactData' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, BodyImpactDataOverrides) == 0x001068, "Member 'UGbxSkeletalMeshComponent::BodyImpactDataOverrides' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, CustomizationTargets) == 0x0010B8, "Member 'UGbxSkeletalMeshComponent::CustomizationTargets' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, StretchAnimData) == 0x0010C8, "Member 'UGbxSkeletalMeshComponent::StretchAnimData' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, AnimBPProfile) == 0x0012A8, "Member 'UGbxSkeletalMeshComponent::AnimBPProfile' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, bGaitScalingOverride) == 0x0012B0, "Member 'UGbxSkeletalMeshComponent::bGaitScalingOverride' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, GaitScalingSettings) == 0x0012B8, "Member 'UGbxSkeletalMeshComponent::GaitScalingSettings' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, bUseAggregateSimulationSleepCheck) == 0x001308, "Member 'UGbxSkeletalMeshComponent::bUseAggregateSimulationSleepCheck' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, AggregateSimulationSleepCheckSeconds) == 0x00130C, "Member 'UGbxSkeletalMeshComponent::AggregateSimulationSleepCheckSeconds' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, AggregateSimulationSleepCheckDistance) == 0x001310, "Member 'UGbxSkeletalMeshComponent::AggregateSimulationSleepCheckDistance' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, UpdateRateParametersOverride) == 0x001358, "Member 'UGbxSkeletalMeshComponent::UpdateRateParametersOverride' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, bOverrideUpdateRateParameters) == 0x0013E0, "Member 'UGbxSkeletalMeshComponent::bOverrideUpdateRateParameters' has a wrong offset!");
static_assert(offsetof(UGbxSkeletalMeshComponent, PoseMatch) == 0x0013F0, "Member 'UGbxSkeletalMeshComponent::PoseMatch' has a wrong offset!");

// Class GbxGameSystemCore.PawnAttachSlotComponent
// 0x0270 (0x0620 - 0x03B0)
class UPawnAttachSlotComponent : public UUsableComponent
{
public:
	UMulticastDelegateProperty_                   OnAttachStarted;                                   // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAttachFinished;                                  // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDetachStarted;                                   // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDetachFinished;                                  // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAttachStateChanged;                              // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPawnAttachSlotState                   AttachState;                                       // 0x0400(0x0040)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPawnSceneAttachmentInfo               PersistentAttachInfo;                              // 0x0440(0x0028)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGbxAction>                 PersistentPawnAction;                              // 0x0468(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAttachSlotAnimSet>             AnimSets;                                          // 0x0470(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FPawnAttachmentTransition              AttachTransition;                                  // 0x0480(0x0048)(Deprecated, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPawnAttachmentTransition              DetachTransition;                                  // 0x04C8(0x0048)(Deprecated, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bManualAttachTransitionDuration;                   // 0x0510(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEvaluateAttachTransitionBeforeModifyingPawn;      // 0x0511(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_512[0x6];                                      // 0x0512(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPawnAttachTransition>          AttachTransitions;                                 // 0x0518(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bOffsetFallbackDetachLocationByActorHeight;        // 0x0528(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBaseOwnerLocationForSafeLocationTrace;         // 0x0529(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBaseOwnerLocationForFallbackDetachLocation;    // 0x052A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52B[0x5];                                      // 0x052B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPawnDetachTransition>          DetachTransitions;                                 // 0x0530(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EAttachmentPossessionRule                     PossessionRule;                                    // 0x0540(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPossessWhenAttachmentStarts;                      // 0x0541(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestorePossessionWhenDetachStarts;                // 0x0542(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_543[0x1];                                      // 0x0543(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsHijackable : 1;                                 // 0x0544(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanHijackPlayer : 1;                              // 0x0544(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanHijackFriendly : 1;                            // 0x0544(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanBeUsedByPlayers : 1;                           // 0x0544(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceUntargetable : 1;                            // 0x0544(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceGodMode : 1;                                 // 0x0544(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceHidden : 1;                                  // 0x0544(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceNoCollision : 1;                             // 0x0544(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableHitReaction : 1;                           // 0x0545(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCollideDuringTransitions : 1;                     // 0x0545(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMirrorTeam : 1;                                   // 0x0545(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceUnCrouch : 1;                                // 0x0545(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreCollisionWithBase : 1;                      // 0x0545(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBaseIgnoreCollisionWithPawn : 1;                  // 0x0545(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceSkeletalOptimizations : 1;                   // 0x0545(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableDelayRootMotionOneFrameDuringDetach : 1;   // 0x0545(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableOverlapOptimization : 1;                   // 0x0546(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_547[0x1];                                      // 0x0547(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGenerateOverlapEventOnDetach;                     // 0x0548(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0xD7];                                     // 0x0549(0x00D7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachPawn(class APawn* AttachingPawn, bool bInstant);
	void DetachPawn(bool bInstant, bool bSkipPlacement);
	void HandleActorDestroyed(class AActor* Actor);
	void ManuallyFinishAttach();
	void OnRep_AttachState();
	void RequestDetachPawn();
	void SetDetachabilityLocked(bool bLock, class FName Reason);
	void SetPersistentAttachSocketName(class FName SocketName);

	EPawnAttachStatus GetAttachStatus() const;
	class APawn* GetOccupant(bool bIncludeDetaching) const;
	struct FTransform GetPersistentAttachSocketTransform() const;
	bool IsOccupied(bool bIncludeDetaching) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnAttachSlotComponent">();
	}
	static class UPawnAttachSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnAttachSlotComponent>();
	}
};
static_assert(alignof(UPawnAttachSlotComponent) == 0x000008, "Wrong alignment on UPawnAttachSlotComponent");
static_assert(sizeof(UPawnAttachSlotComponent) == 0x000620, "Wrong size on UPawnAttachSlotComponent");
static_assert(offsetof(UPawnAttachSlotComponent, OnAttachStarted) == 0x0003B0, "Member 'UPawnAttachSlotComponent::OnAttachStarted' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, OnAttachFinished) == 0x0003C0, "Member 'UPawnAttachSlotComponent::OnAttachFinished' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, OnDetachStarted) == 0x0003D0, "Member 'UPawnAttachSlotComponent::OnDetachStarted' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, OnDetachFinished) == 0x0003E0, "Member 'UPawnAttachSlotComponent::OnDetachFinished' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, OnAttachStateChanged) == 0x0003F0, "Member 'UPawnAttachSlotComponent::OnAttachStateChanged' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, AttachState) == 0x000400, "Member 'UPawnAttachSlotComponent::AttachState' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, PersistentAttachInfo) == 0x000440, "Member 'UPawnAttachSlotComponent::PersistentAttachInfo' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, PersistentPawnAction) == 0x000468, "Member 'UPawnAttachSlotComponent::PersistentPawnAction' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, AnimSets) == 0x000470, "Member 'UPawnAttachSlotComponent::AnimSets' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, AttachTransition) == 0x000480, "Member 'UPawnAttachSlotComponent::AttachTransition' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, DetachTransition) == 0x0004C8, "Member 'UPawnAttachSlotComponent::DetachTransition' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bManualAttachTransitionDuration) == 0x000510, "Member 'UPawnAttachSlotComponent::bManualAttachTransitionDuration' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bEvaluateAttachTransitionBeforeModifyingPawn) == 0x000511, "Member 'UPawnAttachSlotComponent::bEvaluateAttachTransitionBeforeModifyingPawn' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, AttachTransitions) == 0x000518, "Member 'UPawnAttachSlotComponent::AttachTransitions' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bOffsetFallbackDetachLocationByActorHeight) == 0x000528, "Member 'UPawnAttachSlotComponent::bOffsetFallbackDetachLocationByActorHeight' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bUseBaseOwnerLocationForSafeLocationTrace) == 0x000529, "Member 'UPawnAttachSlotComponent::bUseBaseOwnerLocationForSafeLocationTrace' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bUseBaseOwnerLocationForFallbackDetachLocation) == 0x00052A, "Member 'UPawnAttachSlotComponent::bUseBaseOwnerLocationForFallbackDetachLocation' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, DetachTransitions) == 0x000530, "Member 'UPawnAttachSlotComponent::DetachTransitions' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, PossessionRule) == 0x000540, "Member 'UPawnAttachSlotComponent::PossessionRule' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bPossessWhenAttachmentStarts) == 0x000541, "Member 'UPawnAttachSlotComponent::bPossessWhenAttachmentStarts' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bRestorePossessionWhenDetachStarts) == 0x000542, "Member 'UPawnAttachSlotComponent::bRestorePossessionWhenDetachStarts' has a wrong offset!");
static_assert(offsetof(UPawnAttachSlotComponent, bGenerateOverlapEventOnDetach) == 0x000548, "Member 'UPawnAttachSlotComponent::bGenerateOverlapEventOnDetach' has a wrong offset!");

// Class GbxGameSystemCore.GbxProfile
// 0x0088 (0x00B0 - 0x0028)
class UGbxProfile : public USaveGame
{
public:
	uint8                                         Pad_28[0x1];                                       // 0x0028(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisplayVehicleSpeedAsMPH;                         // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAimAssist;                                  // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadInvertLook;                                // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadInvertTurn;                                // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadInvertMove;                                // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadInvertStrafe;                              // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMouseAcceleration;                          // 0x002F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGamepadInput;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseClassicGamepadInput;                           // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableVibration;                                  // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableTriggerFeedback;                            // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGbxGlyphSetOption                            GlyphMode;                                         // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertMousePitch;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMouseSmoothing;                             // 0x0036(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseScale;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDamageNumbers;                                // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowDamageNumberIcons;                            // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableTrainingMessages;                           // 0x003E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCenterCrosshair;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleSprint;                                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleCrouch;                                     // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCensorContent;                                    // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MasterVolume;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MusicVolume;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundEffectsVolume;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VOVolume;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoiceVolume;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableOptionalVO;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPushToTalk;                                       // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableControllerAudio;                            // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeakerAngleFront;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeakerAngleSide;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeakerAngleBack;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpeakerSetup                                 SpeakerSetup;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMuteAudioOnFocusLoss;                             // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableWindowsSpatialAudio;                        // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGraphicsMode                                 GraphicsMode;                                      // 0x006B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseFOV;                                           // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseVehicleFOV;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideStrictNATHelpDialog;                          // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HudScaleMultiplier;                                // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerInputBindings                   PlayerInputBindings;                               // 0x0080(0x0010)(Protected, NativeAccessSpecifierProtected)
	bool                                          bShowTextChat;                                     // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                NewsHashes;                                        // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint32                                        LastUsedSavegameId;                                // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxProfile">();
	}
	static class UGbxProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxProfile>();
	}
};
static_assert(alignof(UGbxProfile) == 0x000008, "Wrong alignment on UGbxProfile");
static_assert(sizeof(UGbxProfile) == 0x0000B0, "Wrong size on UGbxProfile");
static_assert(offsetof(UGbxProfile, bDisplayVehicleSpeedAsMPH) == 0x000029, "Member 'UGbxProfile::bDisplayVehicleSpeedAsMPH' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableAimAssist) == 0x00002A, "Member 'UGbxProfile::bEnableAimAssist' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bGamepadInvertLook) == 0x00002B, "Member 'UGbxProfile::bGamepadInvertLook' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bGamepadInvertTurn) == 0x00002C, "Member 'UGbxProfile::bGamepadInvertTurn' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bGamepadInvertMove) == 0x00002D, "Member 'UGbxProfile::bGamepadInvertMove' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bGamepadInvertStrafe) == 0x00002E, "Member 'UGbxProfile::bGamepadInvertStrafe' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableMouseAcceleration) == 0x00002F, "Member 'UGbxProfile::bEnableMouseAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableGamepadInput) == 0x000030, "Member 'UGbxProfile::bEnableGamepadInput' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bUseClassicGamepadInput) == 0x000031, "Member 'UGbxProfile::bUseClassicGamepadInput' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableVibration) == 0x000032, "Member 'UGbxProfile::bEnableVibration' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableTriggerFeedback) == 0x000033, "Member 'UGbxProfile::bEnableTriggerFeedback' has a wrong offset!");
static_assert(offsetof(UGbxProfile, GlyphMode) == 0x000034, "Member 'UGbxProfile::GlyphMode' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bInvertMousePitch) == 0x000035, "Member 'UGbxProfile::bInvertMousePitch' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableMouseSmoothing) == 0x000036, "Member 'UGbxProfile::bEnableMouseSmoothing' has a wrong offset!");
static_assert(offsetof(UGbxProfile, MouseScale) == 0x000038, "Member 'UGbxProfile::MouseScale' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bShowDamageNumbers) == 0x00003C, "Member 'UGbxProfile::bShowDamageNumbers' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bShowDamageNumberIcons) == 0x00003D, "Member 'UGbxProfile::bShowDamageNumberIcons' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableTrainingMessages) == 0x00003E, "Member 'UGbxProfile::bEnableTrainingMessages' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bCenterCrosshair) == 0x000040, "Member 'UGbxProfile::bCenterCrosshair' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bToggleSprint) == 0x000041, "Member 'UGbxProfile::bToggleSprint' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bToggleCrouch) == 0x000042, "Member 'UGbxProfile::bToggleCrouch' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bCensorContent) == 0x000043, "Member 'UGbxProfile::bCensorContent' has a wrong offset!");
static_assert(offsetof(UGbxProfile, MasterVolume) == 0x000044, "Member 'UGbxProfile::MasterVolume' has a wrong offset!");
static_assert(offsetof(UGbxProfile, MusicVolume) == 0x000048, "Member 'UGbxProfile::MusicVolume' has a wrong offset!");
static_assert(offsetof(UGbxProfile, SoundEffectsVolume) == 0x00004C, "Member 'UGbxProfile::SoundEffectsVolume' has a wrong offset!");
static_assert(offsetof(UGbxProfile, VOVolume) == 0x000050, "Member 'UGbxProfile::VOVolume' has a wrong offset!");
static_assert(offsetof(UGbxProfile, VoiceVolume) == 0x000054, "Member 'UGbxProfile::VoiceVolume' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableOptionalVO) == 0x000058, "Member 'UGbxProfile::bEnableOptionalVO' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bPushToTalk) == 0x000059, "Member 'UGbxProfile::bPushToTalk' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableControllerAudio) == 0x00005A, "Member 'UGbxProfile::bEnableControllerAudio' has a wrong offset!");
static_assert(offsetof(UGbxProfile, SpeakerAngleFront) == 0x00005C, "Member 'UGbxProfile::SpeakerAngleFront' has a wrong offset!");
static_assert(offsetof(UGbxProfile, SpeakerAngleSide) == 0x000060, "Member 'UGbxProfile::SpeakerAngleSide' has a wrong offset!");
static_assert(offsetof(UGbxProfile, SpeakerAngleBack) == 0x000064, "Member 'UGbxProfile::SpeakerAngleBack' has a wrong offset!");
static_assert(offsetof(UGbxProfile, SpeakerSetup) == 0x000068, "Member 'UGbxProfile::SpeakerSetup' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bMuteAudioOnFocusLoss) == 0x000069, "Member 'UGbxProfile::bMuteAudioOnFocusLoss' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bEnableWindowsSpatialAudio) == 0x00006A, "Member 'UGbxProfile::bEnableWindowsSpatialAudio' has a wrong offset!");
static_assert(offsetof(UGbxProfile, GraphicsMode) == 0x00006B, "Member 'UGbxProfile::GraphicsMode' has a wrong offset!");
static_assert(offsetof(UGbxProfile, BaseFOV) == 0x00006C, "Member 'UGbxProfile::BaseFOV' has a wrong offset!");
static_assert(offsetof(UGbxProfile, BaseVehicleFOV) == 0x000070, "Member 'UGbxProfile::BaseVehicleFOV' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bHideStrictNATHelpDialog) == 0x000074, "Member 'UGbxProfile::bHideStrictNATHelpDialog' has a wrong offset!");
static_assert(offsetof(UGbxProfile, HudScaleMultiplier) == 0x000078, "Member 'UGbxProfile::HudScaleMultiplier' has a wrong offset!");
static_assert(offsetof(UGbxProfile, PlayerInputBindings) == 0x000080, "Member 'UGbxProfile::PlayerInputBindings' has a wrong offset!");
static_assert(offsetof(UGbxProfile, bShowTextChat) == 0x000090, "Member 'UGbxProfile::bShowTextChat' has a wrong offset!");
static_assert(offsetof(UGbxProfile, NewsHashes) == 0x000098, "Member 'UGbxProfile::NewsHashes' has a wrong offset!");
static_assert(offsetof(UGbxProfile, LastUsedSavegameId) == 0x0000A8, "Member 'UGbxProfile::LastUsedSavegameId' has a wrong offset!");

// Class GbxGameSystemCore.BalanceTableAttributeValueResolver
// 0x0000 (0x00D8 - 0x00D8)
class UBalanceTableAttributeValueResolver final : public UDataTableFunctionAttributeValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BalanceTableAttributeValueResolver">();
	}
	static class UBalanceTableAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBalanceTableAttributeValueResolver>();
	}
};
static_assert(alignof(UBalanceTableAttributeValueResolver) == 0x000008, "Wrong alignment on UBalanceTableAttributeValueResolver");
static_assert(sizeof(UBalanceTableAttributeValueResolver) == 0x0000D8, "Wrong size on UBalanceTableAttributeValueResolver");

// Class GbxGameSystemCore.RecentDamageTrackingComponent
// 0x01E0 (0x0358 - 0x0178)
class URecentDamageTrackingComponent : public UActorComponent
{
public:
	class AGbxPlayerController*                   PlayerController;                                  // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRecentlyCausedDamageInstance          RecentlyCausedDamageInstances[0x6];                // 0x0180(0x0048)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFeedbackData*>                  InstigatedFeedbacks;                               // 0x0348(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecentDamageTrackingComponent">();
	}
	static class URecentDamageTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecentDamageTrackingComponent>();
	}
};
static_assert(alignof(URecentDamageTrackingComponent) == 0x000008, "Wrong alignment on URecentDamageTrackingComponent");
static_assert(sizeof(URecentDamageTrackingComponent) == 0x000358, "Wrong size on URecentDamageTrackingComponent");
static_assert(offsetof(URecentDamageTrackingComponent, PlayerController) == 0x000178, "Member 'URecentDamageTrackingComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(URecentDamageTrackingComponent, RecentlyCausedDamageInstances) == 0x000180, "Member 'URecentDamageTrackingComponent::RecentlyCausedDamageInstances' has a wrong offset!");
static_assert(offsetof(URecentDamageTrackingComponent, InstigatedFeedbacks) == 0x000348, "Member 'URecentDamageTrackingComponent::InstigatedFeedbacks' has a wrong offset!");

// Class GbxGameSystemCore.GbxFeedbackBase
// 0x0000 (0x0030 - 0x0030)
class UGbxFeedbackBase : public UGbxDataAsset
{
public:
	static void PlayGbxFeedbackData2D(const class UGbxFeedbackBase* FeedbackData, class UObject* WorldContextObject, class AGbxPlayerController* Controller, bool bLoop, bool bIgnoreController, float Scale, class UObject* SourceContext);
	static void PlayGbxFeedbackData3D(const class UGbxFeedbackBase* FeedbackData, class UObject* WorldContextObject, class AGbxPlayerController* Controller, const struct FVector& SourceLocation, bool bLoop, bool bIgnoreController, float Scale, class UObject* SourceContext, float EffectFalloffMinDistance, float EffectFalloffMaxDistance);
	static void StopGbxFeedback(const class UGbxFeedbackBase* FeedbackData, class UObject* WorldContextObject, class AGbxPlayerController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFeedbackBase">();
	}
	static class UGbxFeedbackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFeedbackBase>();
	}
};
static_assert(alignof(UGbxFeedbackBase) == 0x000008, "Wrong alignment on UGbxFeedbackBase");
static_assert(sizeof(UGbxFeedbackBase) == 0x000030, "Wrong size on UGbxFeedbackBase");

// Class GbxGameSystemCore.GbxFeedbackList
// 0x0010 (0x0040 - 0x0030)
class UGbxFeedbackList final : public UGbxFeedbackBase
{
public:
	TArray<class UGbxFeedbackData*>               FeedbackList;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFeedbackList">();
	}
	static class UGbxFeedbackList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFeedbackList>();
	}
};
static_assert(alignof(UGbxFeedbackList) == 0x000008, "Wrong alignment on UGbxFeedbackList");
static_assert(sizeof(UGbxFeedbackList) == 0x000040, "Wrong size on UGbxFeedbackList");
static_assert(offsetof(UGbxFeedbackList, FeedbackList) == 0x000030, "Member 'UGbxFeedbackList::FeedbackList' has a wrong offset!");

// Class GbxGameSystemCore.GbxSaveGame
// 0x0000 (0x0028 - 0x0028)
class UGbxSaveGame : public USaveGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSaveGame">();
	}
	static class UGbxSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSaveGame>();
	}
};
static_assert(alignof(UGbxSaveGame) == 0x000008, "Wrong alignment on UGbxSaveGame");
static_assert(sizeof(UGbxSaveGame) == 0x000028, "Wrong size on UGbxSaveGame");

// Class GbxGameSystemCore.Beacon
// 0x0020 (0x0478 - 0x0458)
class ABeacon final : public AActor
{
public:
	uint8                                         Pad_458[0x20];                                     // 0x0458(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeaconSourceEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Beacon">();
	}
	static class ABeacon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABeacon>();
	}
};
static_assert(alignof(ABeacon) == 0x000008, "Wrong alignment on ABeacon");
static_assert(sizeof(ABeacon) == 0x000478, "Wrong size on ABeacon");

// Class GbxGameSystemCore.GbxSignificanceManager
// 0x0098 (0x01C8 - 0x0130)
class UGbxSignificanceManager : public USignificanceManager
{
public:
	uint8                                         Pad_130[0x68];                                     // 0x0130(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedInterp>                  WeightInterps;                                     // 0x0198(0x0010)(ZeroConstructor, Transient, Config, NativeAccessSpecifierPrivate)
	TArray<struct FCachedInterp>                  BucketInterps;                                     // 0x01A8(0x0010)(ZeroConstructor, Transient, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSignificanceManager">();
	}
	static class UGbxSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSignificanceManager>();
	}
};
static_assert(alignof(UGbxSignificanceManager) == 0x000008, "Wrong alignment on UGbxSignificanceManager");
static_assert(sizeof(UGbxSignificanceManager) == 0x0001C8, "Wrong size on UGbxSignificanceManager");
static_assert(offsetof(UGbxSignificanceManager, WeightInterps) == 0x000198, "Member 'UGbxSignificanceManager::WeightInterps' has a wrong offset!");
static_assert(offsetof(UGbxSignificanceManager, BucketInterps) == 0x0001A8, "Member 'UGbxSignificanceManager::BucketInterps' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolAttributePropertyValueResolver
// 0x0008 (0x00B8 - 0x00B0)
class UGameResourcePoolAttributePropertyValueResolver : public UAttributePropertyValueResolver
{
public:
	class UGameResourceData*                      Resource;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolAttributePropertyValueResolver">();
	}
	static class UGameResourcePoolAttributePropertyValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolAttributePropertyValueResolver>();
	}
};
static_assert(alignof(UGameResourcePoolAttributePropertyValueResolver) == 0x000008, "Wrong alignment on UGameResourcePoolAttributePropertyValueResolver");
static_assert(sizeof(UGameResourcePoolAttributePropertyValueResolver) == 0x0000B8, "Wrong size on UGameResourcePoolAttributePropertyValueResolver");
static_assert(offsetof(UGameResourcePoolAttributePropertyValueResolver, Resource) == 0x0000B0, "Member 'UGameResourcePoolAttributePropertyValueResolver::Resource' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolClampedMaxValueResolver
// 0x0000 (0x00B8 - 0x00B8)
class UGameResourcePoolClampedMaxValueResolver final : public UGameResourcePoolAttributePropertyValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolClampedMaxValueResolver">();
	}
	static class UGameResourcePoolClampedMaxValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolClampedMaxValueResolver>();
	}
};
static_assert(alignof(UGameResourcePoolClampedMaxValueResolver) == 0x000008, "Wrong alignment on UGameResourcePoolClampedMaxValueResolver");
static_assert(sizeof(UGameResourcePoolClampedMaxValueResolver) == 0x0000B8, "Wrong size on UGameResourcePoolClampedMaxValueResolver");

// Class GbxGameSystemCore.GbxSingletons
// 0x0010 (0x0038 - 0x0028)
class UGbxSingletons : public UObject
{
public:
	class UAsyncExplosionImpactManager*           ExplosionImpactManager;                            // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxFeedbackManager*                    FeedbackManager;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSingletons">();
	}
	static class UGbxSingletons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSingletons>();
	}
};
static_assert(alignof(UGbxSingletons) == 0x000008, "Wrong alignment on UGbxSingletons");
static_assert(sizeof(UGbxSingletons) == 0x000038, "Wrong size on UGbxSingletons");
static_assert(offsetof(UGbxSingletons, ExplosionImpactManager) == 0x000028, "Member 'UGbxSingletons::ExplosionImpactManager' has a wrong offset!");
static_assert(offsetof(UGbxSingletons, FeedbackManager) == 0x000030, "Member 'UGbxSingletons::FeedbackManager' has a wrong offset!");

// Class GbxGameSystemCore.GbxFlagData
// 0x0018 (0x0048 - 0x0030)
class UGbxFlagData final : public UGbxDataAsset
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAttributeContextResolver*              ContextResolver;                                   // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxFlagValueResolver*                  ValueResolver;                                     // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFlagData">();
	}
	static class UGbxFlagData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFlagData>();
	}
};
static_assert(alignof(UGbxFlagData) == 0x000008, "Wrong alignment on UGbxFlagData");
static_assert(sizeof(UGbxFlagData) == 0x000048, "Wrong size on UGbxFlagData");
static_assert(offsetof(UGbxFlagData, Condition) == 0x000030, "Member 'UGbxFlagData::Condition' has a wrong offset!");
static_assert(offsetof(UGbxFlagData, ContextResolver) == 0x000038, "Member 'UGbxFlagData::ContextResolver' has a wrong offset!");
static_assert(offsetof(UGbxFlagData, ValueResolver) == 0x000040, "Member 'UGbxFlagData::ValueResolver' has a wrong offset!");

// Class GbxGameSystemCore.StanceDataSelector
// 0x0018 (0x0048 - 0x0030)
class UStanceDataSelector : public UStanceDataProvider
{
public:
	TArray<struct FConditionalStance>             StancePriorityList;                                // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UStanceDataProvider*                    DefaultStanceProvider;                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceDataSelector">();
	}
	static class UStanceDataSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceDataSelector>();
	}
};
static_assert(alignof(UStanceDataSelector) == 0x000008, "Wrong alignment on UStanceDataSelector");
static_assert(sizeof(UStanceDataSelector) == 0x000048, "Wrong size on UStanceDataSelector");
static_assert(offsetof(UStanceDataSelector, StancePriorityList) == 0x000030, "Member 'UStanceDataSelector::StancePriorityList' has a wrong offset!");
static_assert(offsetof(UStanceDataSelector, DefaultStanceProvider) == 0x000040, "Member 'UStanceDataSelector::DefaultStanceProvider' has a wrong offset!");

// Class GbxGameSystemCore.StatusEffectGlobalsData
// 0x0000 (0x0030 - 0x0030)
class UStatusEffectGlobalsData : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectGlobalsData">();
	}
	static class UStatusEffectGlobalsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectGlobalsData>();
	}
};
static_assert(alignof(UStatusEffectGlobalsData) == 0x000008, "Wrong alignment on UStatusEffectGlobalsData");
static_assert(sizeof(UStatusEffectGlobalsData) == 0x000030, "Wrong size on UStatusEffectGlobalsData");

// Class GbxGameSystemCore.StatusEffectManagerComponent
// 0x00B8 (0x0230 - 0x0178)
class UStatusEffectManagerComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStatusEffectInstanceStack>     InstanceStacks;                                    // 0x0180(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0xA0];                                     // 0x0190(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FStatusEffectInstanceReference AddStatusEffect(const struct FStatusEffectSpec& Spec);
	bool RemoveStatusEffect(const struct FStatusEffectRemoveSpec& Spec);
	bool RemoveStatusEffectInstance(struct FStatusEffectInstanceReference& Reference);

	struct FStatusEffectQueryResult QueryStatusEffect(const struct FStatusEffectQuery& Query) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectManagerComponent">();
	}
	static class UStatusEffectManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectManagerComponent>();
	}
};
static_assert(alignof(UStatusEffectManagerComponent) == 0x000008, "Wrong alignment on UStatusEffectManagerComponent");
static_assert(sizeof(UStatusEffectManagerComponent) == 0x000230, "Wrong size on UStatusEffectManagerComponent");
static_assert(offsetof(UStatusEffectManagerComponent, InstanceStacks) == 0x000180, "Member 'UStatusEffectManagerComponent::InstanceStacks' has a wrong offset!");

// Class GbxGameSystemCore.GbxSimpleMotionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxSimpleMotionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ResetMotionState(struct FSimpleMotionInstanceState* State);
	static void TeleportFloatMotion(float* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, float TargetValue, struct FSimpleMotionInstanceState* State);
	static void TeleportRotatorMotion(struct FRotator* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FRotator& TargetValue, struct FSimpleMotionInstanceState* State);
	static void TeleportVectorMotion(struct FVector* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FVector& TargetValue, struct FSimpleMotionInstanceState* State);
	static void UpdateFloatMotion(float DeltaTime, float* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, float TargetValue, struct FSimpleMotionInstanceState* State);
	static void UpdateRotatorMotion(float DeltaTime, struct FRotator* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FRotator& TargetValue, bool bShortestRotation, struct FSimpleMotionInstanceState* State);
	static void UpdateVectorMotion(float DeltaTime, struct FVector* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FVector& TargetValue, struct FSimpleMotionInstanceState* State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSimpleMotionLibrary">();
	}
	static class UGbxSimpleMotionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSimpleMotionLibrary>();
	}
};
static_assert(alignof(UGbxSimpleMotionLibrary) == 0x000008, "Wrong alignment on UGbxSimpleMotionLibrary");
static_assert(sizeof(UGbxSimpleMotionLibrary) == 0x000028, "Wrong size on UGbxSimpleMotionLibrary");

// Class GbxGameSystemCore.StatusEffectsStatics
// 0x0000 (0x0028 - 0x0028)
class UStatusEffectsStatics : public UBlueprintFunctionLibrary
{
public:
	static struct FStatusEffectInstanceReference AddStatusEffect(class AActor* Target, const struct FStatusEffectSpec& Spec);
	static struct FStatusEffectQueryResult QueryStatusEffect(class AActor* Target, const struct FStatusEffectQuery& Query);
	static bool RemoveStatusEffect(class AActor* Target, const struct FStatusEffectRemoveSpec& RemoveSpec);
	static bool RemoveStatusEffectInstance(class AActor* Target, struct FStatusEffectInstanceReference& Reference);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectsStatics">();
	}
	static class UStatusEffectsStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectsStatics>();
	}
};
static_assert(alignof(UStatusEffectsStatics) == 0x000008, "Wrong alignment on UStatusEffectsStatics");
static_assert(sizeof(UStatusEffectsStatics) == 0x000028, "Wrong size on UStatusEffectsStatics");

// Class GbxGameSystemCore.ImpactEffectFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UImpactEffectFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PlayHitResultImpact(class UImpactData* ImpactData, class AActor* Instigator, const struct FHitResult& HitInfo, bool bReplicated);
	static void PlayHitResultImpactGetParticleSystemComponents(class UImpactData* ImpactData, class AActor* Instigator, const struct FHitResult& HitInfo, TArray<class UParticleSystemComponent*>* SpawnedParticleSystemComponents);
	static void PlayTraceImpact(class UImpactData* ImpactData, class AActor* Instigator, const struct FVector& TraceStart, const struct FVector& TraceEnd, ECollisionChannel TraceChannel, bool bReplicated);
	static void PlayTraceImpactAndGetParticleSystemComponents(class UImpactData* ImpactData, class AActor* Instigator, const struct FVector& TraceStart, const struct FVector& TraceEnd, TArray<class UParticleSystemComponent*>* SpawnedParticleSystemComponents, ECollisionChannel TraceChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactEffectFunctionLibrary">();
	}
	static class UImpactEffectFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpactEffectFunctionLibrary>();
	}
};
static_assert(alignof(UImpactEffectFunctionLibrary) == 0x000008, "Wrong alignment on UImpactEffectFunctionLibrary");
static_assert(sizeof(UImpactEffectFunctionLibrary) == 0x000028, "Wrong size on UImpactEffectFunctionLibrary");

// Class GbxGameSystemCore.UseComponent
// 0x0428 (0x05A0 - 0x0178)
class UUseComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   UsableChanged;                                     // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ImpactDataChanged;                                 // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UsabilityChanged;                                  // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHoldUseStopped;                                  // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewDistance;                                      // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractDistance;                                  // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveInteractionDistance;                          // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleInteractDistance;                           // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleLeaveInteractionDistance;                   // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            CachedController;                                  // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUseTraceResult                        PreviousUsableState;                               // 0x01E8(0x0060)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FUseTraceResult                        ReplicatedUsableState;                             // 0x0248(0x0060)(Net, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FUseTraceResult                        LocalUsableState;                                  // 0x02A8(0x0060)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FUseTraceResult                        EmptyUsableState;                                  // 0x0308(0x0060)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLatentUseState                        LatentUseStates[0x2];                              // 0x0368(0x0010)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUsableCostCache                       ReplicatedCostCache;                               // 0x0398(0x0010)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x98];                                     // 0x03A8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FResourceLock                          CanUseObjectsLock_Replicated;                      // 0x0440(0x0098)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0xC8];                                     // 0x04D8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyAttemptedUseCouldNotAfford(class UUsableComponent* Usable, EUsabilityType UseType, bool bUseHeld);
	void ForceUsingObject(class UUsableComponent* UsableObject);
	void OnHoldUseStopped__DelegateSignature();
	void OnImpactDataChanged__DelegateSignature(class UUsableComponent* NewUsableComponent, const struct FVector& NewUsableComponentImpactPoint, float NewUsableComponentDistanceAway);
	void OnUnableToAffordUsableObject__DelegateSignature(class UUsableComponent* Usable, EUsabilityType UseType, bool bUseHeld);
	void OnUsabilityChanged__DelegateSignature(class UUsableComponent* NewUsableComponent, const struct FUsabilityInfo& InUsabilityInfo);
	void OnUsableChanged__DelegateSignature(class UUsableComponent* NewUsableComponent, const struct FUsabilityInfo& InUsabilityInfo, const struct FVector& NewUsableComponentImpactPoint, float NewUsableComponentDistanceAway);
	void ServerStartUsingObject(class UUsableComponent* UsableObject, EUsabilityType UseType);
	void ServerStopUsingObject(class UUsableComponent* UsableObject, EUsabilityType UseType);
	void ServerUseObject(class UUsableComponent* UsableObject, EUsabilityType UseType, bool bHeld);
	void StartUsingCurrentObject(EUsabilityType UseType);
	void StopUsingCurrentObject(EUsabilityType UseType);

	bool CanInteractWithCurrentUsable(EUsabilityType Type) const;
	bool CanUseCurrentUsable(EUsabilityType Type) const;
	class UUsableComponent* GetCurrentUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseComponent">();
	}
	static class UUseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseComponent>();
	}
};
static_assert(alignof(UUseComponent) == 0x000008, "Wrong alignment on UUseComponent");
static_assert(sizeof(UUseComponent) == 0x0005A0, "Wrong size on UUseComponent");
static_assert(offsetof(UUseComponent, UsableChanged) == 0x000178, "Member 'UUseComponent::UsableChanged' has a wrong offset!");
static_assert(offsetof(UUseComponent, ImpactDataChanged) == 0x000188, "Member 'UUseComponent::ImpactDataChanged' has a wrong offset!");
static_assert(offsetof(UUseComponent, UsabilityChanged) == 0x000198, "Member 'UUseComponent::UsabilityChanged' has a wrong offset!");
static_assert(offsetof(UUseComponent, OnHoldUseStopped) == 0x0001A8, "Member 'UUseComponent::OnHoldUseStopped' has a wrong offset!");
static_assert(offsetof(UUseComponent, ViewDistance) == 0x0001C8, "Member 'UUseComponent::ViewDistance' has a wrong offset!");
static_assert(offsetof(UUseComponent, InteractDistance) == 0x0001CC, "Member 'UUseComponent::InteractDistance' has a wrong offset!");
static_assert(offsetof(UUseComponent, LeaveInteractionDistance) == 0x0001D0, "Member 'UUseComponent::LeaveInteractionDistance' has a wrong offset!");
static_assert(offsetof(UUseComponent, VehicleInteractDistance) == 0x0001D4, "Member 'UUseComponent::VehicleInteractDistance' has a wrong offset!");
static_assert(offsetof(UUseComponent, VehicleLeaveInteractionDistance) == 0x0001D8, "Member 'UUseComponent::VehicleLeaveInteractionDistance' has a wrong offset!");
static_assert(offsetof(UUseComponent, CachedController) == 0x0001E0, "Member 'UUseComponent::CachedController' has a wrong offset!");
static_assert(offsetof(UUseComponent, PreviousUsableState) == 0x0001E8, "Member 'UUseComponent::PreviousUsableState' has a wrong offset!");
static_assert(offsetof(UUseComponent, ReplicatedUsableState) == 0x000248, "Member 'UUseComponent::ReplicatedUsableState' has a wrong offset!");
static_assert(offsetof(UUseComponent, LocalUsableState) == 0x0002A8, "Member 'UUseComponent::LocalUsableState' has a wrong offset!");
static_assert(offsetof(UUseComponent, EmptyUsableState) == 0x000308, "Member 'UUseComponent::EmptyUsableState' has a wrong offset!");
static_assert(offsetof(UUseComponent, LatentUseStates) == 0x000368, "Member 'UUseComponent::LatentUseStates' has a wrong offset!");
static_assert(offsetof(UUseComponent, ReplicatedCostCache) == 0x000398, "Member 'UUseComponent::ReplicatedCostCache' has a wrong offset!");
static_assert(offsetof(UUseComponent, CanUseObjectsLock_Replicated) == 0x000440, "Member 'UUseComponent::CanUseObjectsLock_Replicated' has a wrong offset!");

// Class GbxGameSystemCore.EnvQueryParamsExt
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryParamsExt final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetDescription(const struct FEnvQueryParams& QueryParams);
	static bool HasQuery(const struct FEnvQueryParams& QueryParams);
	static bool RunEnvQueryForAllActors(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, TArray<class AActor*>* ResultActors);
	static bool RunEnvQueryForAllLocations(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, TArray<struct FVector>* ResultLocations);
	static bool RunEnvQueryForBestActor(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, class AActor** ResultActor);
	static bool RunEnvQueryForBestLocation(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, struct FVector* ResultLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryParamsExt">();
	}
	static class UEnvQueryParamsExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryParamsExt>();
	}
};
static_assert(alignof(UEnvQueryParamsExt) == 0x000008, "Wrong alignment on UEnvQueryParamsExt");
static_assert(sizeof(UEnvQueryParamsExt) == 0x000028, "Wrong size on UEnvQueryParamsExt");

// Class GbxGameSystemCore.LevelGroupData
// 0x0058 (0x0088 - 0x0030)
class ULevelGroupData : public UGbxDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SubHeader;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelData>>      ContainedLevels;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelGroupData">();
	}
	static class ULevelGroupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelGroupData>();
	}
};
static_assert(alignof(ULevelGroupData) == 0x000008, "Wrong alignment on ULevelGroupData");
static_assert(sizeof(ULevelGroupData) == 0x000088, "Wrong size on ULevelGroupData");
static_assert(offsetof(ULevelGroupData, DisplayName) == 0x000030, "Member 'ULevelGroupData::DisplayName' has a wrong offset!");
static_assert(offsetof(ULevelGroupData, SubHeader) == 0x000048, "Member 'ULevelGroupData::SubHeader' has a wrong offset!");
static_assert(offsetof(ULevelGroupData, Description) == 0x000060, "Member 'ULevelGroupData::Description' has a wrong offset!");
static_assert(offsetof(ULevelGroupData, ContainedLevels) == 0x000078, "Member 'ULevelGroupData::ContainedLevels' has a wrong offset!");

// Class GbxGameSystemCore.CoordinatedEffectBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UCoordinatedEffectBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UMaterialInterface* GetOriginalOverrideMaterialAtIndex(class UMeshComponent* MeshComponent, int32 Index_0, int32* OutActualIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoordinatedEffectBlueprintLibrary">();
	}
	static class UCoordinatedEffectBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoordinatedEffectBlueprintLibrary>();
	}
};
static_assert(alignof(UCoordinatedEffectBlueprintLibrary) == 0x000008, "Wrong alignment on UCoordinatedEffectBlueprintLibrary");
static_assert(sizeof(UCoordinatedEffectBlueprintLibrary) == 0x000028, "Wrong size on UCoordinatedEffectBlueprintLibrary");

// Class GbxGameSystemCore.ActorPartSetData
// 0x0048 (0x0078 - 0x0030)
class UActorPartSetData : public UGbxDataAsset
{
public:
	TSubclassOf<class UActorPartData>             PartDataClass;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnum*                                  PartTypeEnum;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActorPartReplacementMode                     ActorPartReplacementMode;                          // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorPartListData>             ActorPartLists;                                    // 0x0048(0x0010)(Edit, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActorPartListData>             OldActorPartLists;                                 // 0x0058(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  Guid;                                              // 0x0068(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnumeratePartListForPartType(uint8 PartType, TArray<class UActorPartData*>* OutPartList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPartSetData">();
	}
	static class UActorPartSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPartSetData>();
	}
};
static_assert(alignof(UActorPartSetData) == 0x000008, "Wrong alignment on UActorPartSetData");
static_assert(sizeof(UActorPartSetData) == 0x000078, "Wrong size on UActorPartSetData");
static_assert(offsetof(UActorPartSetData, PartDataClass) == 0x000030, "Member 'UActorPartSetData::PartDataClass' has a wrong offset!");
static_assert(offsetof(UActorPartSetData, PartTypeEnum) == 0x000038, "Member 'UActorPartSetData::PartTypeEnum' has a wrong offset!");
static_assert(offsetof(UActorPartSetData, ActorPartReplacementMode) == 0x000040, "Member 'UActorPartSetData::ActorPartReplacementMode' has a wrong offset!");
static_assert(offsetof(UActorPartSetData, ActorPartLists) == 0x000048, "Member 'UActorPartSetData::ActorPartLists' has a wrong offset!");
static_assert(offsetof(UActorPartSetData, OldActorPartLists) == 0x000058, "Member 'UActorPartSetData::OldActorPartLists' has a wrong offset!");
static_assert(offsetof(UActorPartSetData, Guid) == 0x000068, "Member 'UActorPartSetData::Guid' has a wrong offset!");

// Class GbxGameSystemCore.PrototypeActor
// 0x0000 (0x0458 - 0x0458)
class APrototypeActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrototypeActor">();
	}
	static class APrototypeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrototypeActor>();
	}
};
static_assert(alignof(APrototypeActor) == 0x000008, "Wrong alignment on APrototypeActor");
static_assert(sizeof(APrototypeActor) == 0x000458, "Wrong size on APrototypeActor");

// Class GbxGameSystemCore.AttributeInitializer
// 0x0008 (0x0030 - 0x0028)
class UAttributeInitializer : public UObject
{
public:
	EAttributeInitializerUsageMode                UsageMode;                                         // 0x0028(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float EvaluateBalanceFormula(float Multiplier, float Level, float Power, float Offset);

	float CalculateAttributeInitialValue(const class UObject* Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeInitializer">();
	}
	static class UAttributeInitializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeInitializer>();
	}
};
static_assert(alignof(UAttributeInitializer) == 0x000008, "Wrong alignment on UAttributeInitializer");
static_assert(sizeof(UAttributeInitializer) == 0x000030, "Wrong size on UAttributeInitializer");
static_assert(offsetof(UAttributeInitializer, UsageMode) == 0x000028, "Member 'UAttributeInitializer::UsageMode' has a wrong offset!");

// Class GbxGameSystemCore.StatusEffectStackingStrategyData
// 0x0000 (0x0030 - 0x0030)
class UStatusEffectStackingStrategyData : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectStackingStrategyData">();
	}
	static class UStatusEffectStackingStrategyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectStackingStrategyData>();
	}
};
static_assert(alignof(UStatusEffectStackingStrategyData) == 0x000008, "Wrong alignment on UStatusEffectStackingStrategyData");
static_assert(sizeof(UStatusEffectStackingStrategyData) == 0x000030, "Wrong size on UStatusEffectStackingStrategyData");

// Class GbxGameSystemCore.CharacterMovementAttributeValueResolver
// 0x0008 (0x0030 - 0x0028)
class UCharacterMovementAttributeValueResolver final : public UAttributeValueResolver
{
public:
	ECharacterMovementAttributeValueType          ValueToResolve;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMovementAttributeValueResolver">();
	}
	static class UCharacterMovementAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMovementAttributeValueResolver>();
	}
};
static_assert(alignof(UCharacterMovementAttributeValueResolver) == 0x000008, "Wrong alignment on UCharacterMovementAttributeValueResolver");
static_assert(sizeof(UCharacterMovementAttributeValueResolver) == 0x000030, "Wrong size on UCharacterMovementAttributeValueResolver");
static_assert(offsetof(UCharacterMovementAttributeValueResolver, ValueToResolve) == 0x000028, "Member 'UCharacterMovementAttributeValueResolver::ValueToResolve' has a wrong offset!");

// Class GbxGameSystemCore.UIStatData_Attribute
// 0x0028 (0x0248 - 0x0220)
class UUIStatData_Attribute : public UUIStatData_Numeric
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUIStatData*>                    OtherComparableStats;                              // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UUIStatData*>                    StatsToReplace;                                    // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatData_Attribute">();
	}
	static class UUIStatData_Attribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatData_Attribute>();
	}
};
static_assert(alignof(UUIStatData_Attribute) == 0x000008, "Wrong alignment on UUIStatData_Attribute");
static_assert(sizeof(UUIStatData_Attribute) == 0x000248, "Wrong size on UUIStatData_Attribute");
static_assert(offsetof(UUIStatData_Attribute, Attribute) == 0x000220, "Member 'UUIStatData_Attribute::Attribute' has a wrong offset!");
static_assert(offsetof(UUIStatData_Attribute, OtherComparableStats) == 0x000228, "Member 'UUIStatData_Attribute::OtherComparableStats' has a wrong offset!");
static_assert(offsetof(UUIStatData_Attribute, StatsToReplace) == 0x000238, "Member 'UUIStatData_Attribute::StatsToReplace' has a wrong offset!");

// Class GbxGameSystemCore.GameStateAttributeContextResolver
// 0x0000 (0x0050 - 0x0050)
class UGameStateAttributeContextResolver final : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateAttributeContextResolver">();
	}
	static class UGameStateAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateAttributeContextResolver>();
	}
};
static_assert(alignof(UGameStateAttributeContextResolver) == 0x000008, "Wrong alignment on UGameStateAttributeContextResolver");
static_assert(sizeof(UGameStateAttributeContextResolver) == 0x000050, "Wrong size on UGameStateAttributeContextResolver");

// Class GbxGameSystemCore.AnimNotify_Feedback
// 0x0058 (0x0090 - 0x0038)
class UAnimNotify_Feedback final : public UAnimNotify
{
public:
	uint8                                         bApplyToAllPlayers : 1;                            // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreOwner : 1;                                  // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyFeedbackAtRanged;                            // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFeedbackData*                          FeedbackData;                                      // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFeedbackData*                          OwnerFeedbackData;                                 // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           FeedbackScale;                                     // 0x0058(0x0038)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Feedback">();
	}
	static class UAnimNotify_Feedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Feedback>();
	}
};
static_assert(alignof(UAnimNotify_Feedback) == 0x000008, "Wrong alignment on UAnimNotify_Feedback");
static_assert(sizeof(UAnimNotify_Feedback) == 0x000090, "Wrong size on UAnimNotify_Feedback");
static_assert(offsetof(UAnimNotify_Feedback, bApplyFeedbackAtRanged) == 0x00003C, "Member 'UAnimNotify_Feedback::bApplyFeedbackAtRanged' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Feedback, SocketName) == 0x000040, "Member 'UAnimNotify_Feedback::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Feedback, FeedbackData) == 0x000048, "Member 'UAnimNotify_Feedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Feedback, OwnerFeedbackData) == 0x000050, "Member 'UAnimNotify_Feedback::OwnerFeedbackData' has a wrong offset!");
static_assert(offsetof(UAnimNotify_Feedback, FeedbackScale) == 0x000058, "Member 'UAnimNotify_Feedback::FeedbackScale' has a wrong offset!");

// Class GbxGameSystemCore.UIStatFormulaEvaluator
// 0x0000 (0x0028 - 0x0028)
class UUIStatFormulaEvaluator : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatFormulaEvaluator">();
	}
	static class UUIStatFormulaEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatFormulaEvaluator>();
	}
};
static_assert(alignof(UUIStatFormulaEvaluator) == 0x000008, "Wrong alignment on UUIStatFormulaEvaluator");
static_assert(sizeof(UUIStatFormulaEvaluator) == 0x000028, "Wrong size on UUIStatFormulaEvaluator");

// Class GbxGameSystemCore.GbxWeaponSlotData
// 0x0010 (0x0040 - 0x0030)
class UGbxWeaponSlotData : public UDataAsset
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitiallyEnabled;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxWeaponSlotData">();
	}
	static class UGbxWeaponSlotData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxWeaponSlotData>();
	}
};
static_assert(alignof(UGbxWeaponSlotData) == 0x000008, "Wrong alignment on UGbxWeaponSlotData");
static_assert(sizeof(UGbxWeaponSlotData) == 0x000040, "Wrong size on UGbxWeaponSlotData");
static_assert(offsetof(UGbxWeaponSlotData, SocketName) == 0x000030, "Member 'UGbxWeaponSlotData::SocketName' has a wrong offset!");
static_assert(offsetof(UGbxWeaponSlotData, InitiallyEnabled) == 0x000038, "Member 'UGbxWeaponSlotData::InitiallyEnabled' has a wrong offset!");

// Class GbxGameSystemCore.ParticleConditionalEmitterEvaluator
// 0x0018 (0x0040 - 0x0028)
class UParticleConditionalEmitterEvaluator final : public UParticleParameterEvaluator
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EmitterName;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIfTrue;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEvaluateEveryFrame;                               // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleConditionalEmitterEvaluator">();
	}
	static class UParticleConditionalEmitterEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleConditionalEmitterEvaluator>();
	}
};
static_assert(alignof(UParticleConditionalEmitterEvaluator) == 0x000008, "Wrong alignment on UParticleConditionalEmitterEvaluator");
static_assert(sizeof(UParticleConditionalEmitterEvaluator) == 0x000040, "Wrong size on UParticleConditionalEmitterEvaluator");
static_assert(offsetof(UParticleConditionalEmitterEvaluator, Condition) == 0x000028, "Member 'UParticleConditionalEmitterEvaluator::Condition' has a wrong offset!");
static_assert(offsetof(UParticleConditionalEmitterEvaluator, EmitterName) == 0x000030, "Member 'UParticleConditionalEmitterEvaluator::EmitterName' has a wrong offset!");
static_assert(offsetof(UParticleConditionalEmitterEvaluator, bEnableIfTrue) == 0x000038, "Member 'UParticleConditionalEmitterEvaluator::bEnableIfTrue' has a wrong offset!");
static_assert(offsetof(UParticleConditionalEmitterEvaluator, bEvaluateEveryFrame) == 0x000039, "Member 'UParticleConditionalEmitterEvaluator::bEvaluateEveryFrame' has a wrong offset!");

// Class GbxGameSystemCore.LevelData
// 0x0090 (0x00C0 - 0x0030)
class ULevelData : public UGbxDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SubHeader;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   LevelMapName;                                      // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ULevelData>>      LinksToOtherLevel;                                 // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelGroupData>         OwningLevelGroup;                                  // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDownloadableContentData*               DLCExpansionData;                                  // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelData">();
	}
	static class ULevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelData>();
	}
};
static_assert(alignof(ULevelData) == 0x000008, "Wrong alignment on ULevelData");
static_assert(sizeof(ULevelData) == 0x0000C0, "Wrong size on ULevelData");
static_assert(offsetof(ULevelData, DisplayName) == 0x000030, "Member 'ULevelData::DisplayName' has a wrong offset!");
static_assert(offsetof(ULevelData, SubHeader) == 0x000048, "Member 'ULevelData::SubHeader' has a wrong offset!");
static_assert(offsetof(ULevelData, Description) == 0x000060, "Member 'ULevelData::Description' has a wrong offset!");
static_assert(offsetof(ULevelData, LevelMapName) == 0x000078, "Member 'ULevelData::LevelMapName' has a wrong offset!");
static_assert(offsetof(ULevelData, LinksToOtherLevel) == 0x000080, "Member 'ULevelData::LinksToOtherLevel' has a wrong offset!");
static_assert(offsetof(ULevelData, OwningLevelGroup) == 0x000090, "Member 'ULevelData::OwningLevelGroup' has a wrong offset!");
static_assert(offsetof(ULevelData, DLCExpansionData) == 0x0000B8, "Member 'ULevelData::DLCExpansionData' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolCurrentValueResolver
// 0x0008 (0x0030 - 0x0028)
class UGameResourcePoolCurrentValueResolver : public UAttributeValueResolver
{
public:
	class UGameResourceData*                      Resource;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolCurrentValueResolver">();
	}
	static class UGameResourcePoolCurrentValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolCurrentValueResolver>();
	}
};
static_assert(alignof(UGameResourcePoolCurrentValueResolver) == 0x000008, "Wrong alignment on UGameResourcePoolCurrentValueResolver");
static_assert(sizeof(UGameResourcePoolCurrentValueResolver) == 0x000030, "Wrong size on UGameResourcePoolCurrentValueResolver");
static_assert(offsetof(UGameResourcePoolCurrentValueResolver, Resource) == 0x000028, "Member 'UGameResourcePoolCurrentValueResolver::Resource' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolCurrentValueNoPauseOnHealResolver
// 0x0000 (0x0030 - 0x0030)
class UGameResourcePoolCurrentValueNoPauseOnHealResolver final : public UGameResourcePoolCurrentValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolCurrentValueNoPauseOnHealResolver">();
	}
	static class UGameResourcePoolCurrentValueNoPauseOnHealResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolCurrentValueNoPauseOnHealResolver>();
	}
};
static_assert(alignof(UGameResourcePoolCurrentValueNoPauseOnHealResolver) == 0x000008, "Wrong alignment on UGameResourcePoolCurrentValueNoPauseOnHealResolver");
static_assert(sizeof(UGameResourcePoolCurrentValueNoPauseOnHealResolver) == 0x000030, "Wrong size on UGameResourcePoolCurrentValueNoPauseOnHealResolver");

// Class GbxGameSystemCore.ActorAttributeContextResolver
// 0x0000 (0x0050 - 0x0050)
class UActorAttributeContextResolver final : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorAttributeContextResolver">();
	}
	static class UActorAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorAttributeContextResolver>();
	}
};
static_assert(alignof(UActorAttributeContextResolver) == 0x000008, "Wrong alignment on UActorAttributeContextResolver");
static_assert(sizeof(UActorAttributeContextResolver) == 0x000050, "Wrong size on UActorAttributeContextResolver");

// Class GbxGameSystemCore.AIChargeData
// 0x0230 (0x0260 - 0x0030)
class UAIChargeData final : public UGbxDataAsset
{
public:
	TSubclassOf<class UGbxAction>                 StartAction;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 MissAction;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 StrikeAction;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 HitWallAction;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ReachCliffAction;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 StopForFriendlyAction;                             // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnims;                                         // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction_AICharge>        ChargeAction;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikeAngle;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikeDistance;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTravelDistance;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissDistance;                                      // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitWallRadiusPct;                                  // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowStopTime;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowStopSpeedPercent;                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceSelection                        HitReactionForceSelection;                         // 0x0090(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        HitReactionFriendly;                               // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        HitReactionUnfriendly;                             // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCauseHitReaction;                                 // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelativeSizeCharge                           StopForFriendlyOfRelativeSize;                     // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopForFriendlyDistance;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    ChargeStance;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChargeCurveType                              SpeedOverrideType;                                 // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SpeedOverTime;                                     // 0x00D8(0x0078)(Edit, NativeAccessSpecifierPublic)
	EChargeCurveType                              RotationOverrideType;                              // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationOverTime;                                 // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     RotationOverTime;                                  // 0x0158(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RotationByDistance;                                // 0x01D0(0x0078)(Edit, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedCurve;                                        // 0x0248(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationCurve;                                     // 0x0250(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactionForce;                                  // 0x0258(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIChargeData">();
	}
	static class UAIChargeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIChargeData>();
	}
};
static_assert(alignof(UAIChargeData) == 0x000008, "Wrong alignment on UAIChargeData");
static_assert(sizeof(UAIChargeData) == 0x000260, "Wrong size on UAIChargeData");
static_assert(offsetof(UAIChargeData, StartAction) == 0x000030, "Member 'UAIChargeData::StartAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, MissAction) == 0x000038, "Member 'UAIChargeData::MissAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, StrikeAction) == 0x000040, "Member 'UAIChargeData::StrikeAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, HitWallAction) == 0x000048, "Member 'UAIChargeData::HitWallAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, ReachCliffAction) == 0x000050, "Member 'UAIChargeData::ReachCliffAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, StopForFriendlyAction) == 0x000058, "Member 'UAIChargeData::StopForFriendlyAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, bUseAnims) == 0x000060, "Member 'UAIChargeData::bUseAnims' has a wrong offset!");
static_assert(offsetof(UAIChargeData, ChargeAction) == 0x000068, "Member 'UAIChargeData::ChargeAction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, StrikeAngle) == 0x000070, "Member 'UAIChargeData::StrikeAngle' has a wrong offset!");
static_assert(offsetof(UAIChargeData, StrikeDistance) == 0x000074, "Member 'UAIChargeData::StrikeDistance' has a wrong offset!");
static_assert(offsetof(UAIChargeData, MaxTravelDistance) == 0x000078, "Member 'UAIChargeData::MaxTravelDistance' has a wrong offset!");
static_assert(offsetof(UAIChargeData, MissDistance) == 0x00007C, "Member 'UAIChargeData::MissDistance' has a wrong offset!");
static_assert(offsetof(UAIChargeData, HitWallRadiusPct) == 0x000080, "Member 'UAIChargeData::HitWallRadiusPct' has a wrong offset!");
static_assert(offsetof(UAIChargeData, SlowStopTime) == 0x000084, "Member 'UAIChargeData::SlowStopTime' has a wrong offset!");
static_assert(offsetof(UAIChargeData, SlowStopSpeedPercent) == 0x000088, "Member 'UAIChargeData::SlowStopSpeedPercent' has a wrong offset!");
static_assert(offsetof(UAIChargeData, HitReactionForceSelection) == 0x000090, "Member 'UAIChargeData::HitReactionForceSelection' has a wrong offset!");
static_assert(offsetof(UAIChargeData, HitReactionFriendly) == 0x0000B0, "Member 'UAIChargeData::HitReactionFriendly' has a wrong offset!");
static_assert(offsetof(UAIChargeData, HitReactionUnfriendly) == 0x0000B8, "Member 'UAIChargeData::HitReactionUnfriendly' has a wrong offset!");
static_assert(offsetof(UAIChargeData, bCauseHitReaction) == 0x0000C0, "Member 'UAIChargeData::bCauseHitReaction' has a wrong offset!");
static_assert(offsetof(UAIChargeData, StopForFriendlyOfRelativeSize) == 0x0000C1, "Member 'UAIChargeData::StopForFriendlyOfRelativeSize' has a wrong offset!");
static_assert(offsetof(UAIChargeData, StopForFriendlyDistance) == 0x0000C4, "Member 'UAIChargeData::StopForFriendlyDistance' has a wrong offset!");
static_assert(offsetof(UAIChargeData, ChargeStance) == 0x0000C8, "Member 'UAIChargeData::ChargeStance' has a wrong offset!");
static_assert(offsetof(UAIChargeData, SpeedOverrideType) == 0x0000D0, "Member 'UAIChargeData::SpeedOverrideType' has a wrong offset!");
static_assert(offsetof(UAIChargeData, SpeedOverTime) == 0x0000D8, "Member 'UAIChargeData::SpeedOverTime' has a wrong offset!");
static_assert(offsetof(UAIChargeData, RotationOverrideType) == 0x000150, "Member 'UAIChargeData::RotationOverrideType' has a wrong offset!");
static_assert(offsetof(UAIChargeData, bRotationOverTime) == 0x000151, "Member 'UAIChargeData::bRotationOverTime' has a wrong offset!");
static_assert(offsetof(UAIChargeData, RotationOverTime) == 0x000158, "Member 'UAIChargeData::RotationOverTime' has a wrong offset!");
static_assert(offsetof(UAIChargeData, RotationByDistance) == 0x0001D0, "Member 'UAIChargeData::RotationByDistance' has a wrong offset!");
static_assert(offsetof(UAIChargeData, SpeedCurve) == 0x000248, "Member 'UAIChargeData::SpeedCurve' has a wrong offset!");
static_assert(offsetof(UAIChargeData, RotationCurve) == 0x000250, "Member 'UAIChargeData::RotationCurve' has a wrong offset!");
static_assert(offsetof(UAIChargeData, HitReactionForce) == 0x000258, "Member 'UAIChargeData::HitReactionForce' has a wrong offset!");

// Class GbxGameSystemCore.ClothManagerInterface
// 0x0000 (0x0458 - 0x0458)
class AClothManagerInterface : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothManagerInterface">();
	}
	static class AClothManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothManagerInterface>();
	}
};
static_assert(alignof(AClothManagerInterface) == 0x000008, "Wrong alignment on AClothManagerInterface");
static_assert(sizeof(AClothManagerInterface) == 0x000458, "Wrong size on AClothManagerInterface");

// Class GbxGameSystemCore.AIDataProvider_AttributeData
// 0x0018 (0x0040 - 0x0028)
class UAIDataProvider_AttributeData final : public UAIDataProvider
{
public:
	class UGbxAttributeData*                      AttributeData;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDataProvider_AttributeData">();
	}
	static class UAIDataProvider_AttributeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDataProvider_AttributeData>();
	}
};
static_assert(alignof(UAIDataProvider_AttributeData) == 0x000008, "Wrong alignment on UAIDataProvider_AttributeData");
static_assert(sizeof(UAIDataProvider_AttributeData) == 0x000040, "Wrong size on UAIDataProvider_AttributeData");
static_assert(offsetof(UAIDataProvider_AttributeData, AttributeData) == 0x000028, "Member 'UAIDataProvider_AttributeData::AttributeData' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeData, FloatValue) == 0x000030, "Member 'UAIDataProvider_AttributeData::FloatValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeData, IntValue) == 0x000034, "Member 'UAIDataProvider_AttributeData::IntValue' has a wrong offset!");
static_assert(offsetof(UAIDataProvider_AttributeData, BoolValue) == 0x000038, "Member 'UAIDataProvider_AttributeData::BoolValue' has a wrong offset!");

// Class GbxGameSystemCore.AIDodgeComponent
// 0x0790 (0x0908 - 0x0178)
class UAIDodgeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x98];                                     // 0x0178(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDodging;                                         // 0x0210(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDodgeData                           DodgeBullet;                                       // 0x0218(0x01B8)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDodgeData                           DodgeGrenade;                                      // 0x03D0(0x01B8)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDodgeBasicData                      DodgeRandom;                                       // 0x0588(0x0098)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDodgeData                           DodgeZone;                                         // 0x0620(0x01B8)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              GlobalCooldown;                                    // 0x07D8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDodged;                                          // 0x0858(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UTeamComponent*                         TeamComponent;                                     // 0x0868(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    ActionComponent;                                   // 0x0870(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0878(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrainComponent*                        BrainComponent;                                    // 0x0880(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavComponent*                          NavComponent;                                      // 0x0888(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterMovementComponent*         MovementComponent;                                 // 0x0890(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDodgeInstance                       PendingDodge;                                      // 0x0898(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAIDodgeInstance                       ActiveDodge;                                       // 0x08B8(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x30];                                     // 0x08D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void TriggerBulletDodge(class UObject* WorldContextObject, const struct FVector& MuzzleLoc, const struct FVector& BulletVel, class AActor* Instigator);
	static void TriggerGrenadeDodge(class UObject* WorldContextObject, const struct FVector& GrenadeLoc, class AActor* Instigator, float ExtraDelay);
	static void TriggerZoneDodge(class UObject* WorldContextObject, class AActor* TargetActor, const struct FVector& ZoneLoc, const struct FVector& ZoneVel, class AActor* ActorRef);

	bool TriggerDodge(EAIDodgeType Type, const struct FVector& SourceLoc, class AActor* SourceActor, float ExtraDelay, bool bForced);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDodgeComponent">();
	}
	static class UAIDodgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDodgeComponent>();
	}
};
static_assert(alignof(UAIDodgeComponent) == 0x000008, "Wrong alignment on UAIDodgeComponent");
static_assert(sizeof(UAIDodgeComponent) == 0x000908, "Wrong size on UAIDodgeComponent");
static_assert(offsetof(UAIDodgeComponent, IsDodging) == 0x000210, "Member 'UAIDodgeComponent::IsDodging' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, DodgeBullet) == 0x000218, "Member 'UAIDodgeComponent::DodgeBullet' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, DodgeGrenade) == 0x0003D0, "Member 'UAIDodgeComponent::DodgeGrenade' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, DodgeRandom) == 0x000588, "Member 'UAIDodgeComponent::DodgeRandom' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, DodgeZone) == 0x000620, "Member 'UAIDodgeComponent::DodgeZone' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, GlobalCooldown) == 0x0007D8, "Member 'UAIDodgeComponent::GlobalCooldown' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, OnDodged) == 0x000858, "Member 'UAIDodgeComponent::OnDodged' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, TeamComponent) == 0x000868, "Member 'UAIDodgeComponent::TeamComponent' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, ActionComponent) == 0x000870, "Member 'UAIDodgeComponent::ActionComponent' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, BlackboardComponent) == 0x000878, "Member 'UAIDodgeComponent::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, BrainComponent) == 0x000880, "Member 'UAIDodgeComponent::BrainComponent' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, NavComponent) == 0x000888, "Member 'UAIDodgeComponent::NavComponent' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, MovementComponent) == 0x000890, "Member 'UAIDodgeComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, PendingDodge) == 0x000898, "Member 'UAIDodgeComponent::PendingDodge' has a wrong offset!");
static_assert(offsetof(UAIDodgeComponent, ActiveDodge) == 0x0008B8, "Member 'UAIDodgeComponent::ActiveDodge' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolClampedValueResolver
// 0x0008 (0x00C0 - 0x00B8)
class UGameResourcePoolClampedValueResolver final : public UGameResourcePoolAttributePropertyValueResolver
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolClampedValueResolver">();
	}
	static class UGameResourcePoolClampedValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolClampedValueResolver>();
	}
};
static_assert(alignof(UGameResourcePoolClampedValueResolver) == 0x000008, "Wrong alignment on UGameResourcePoolClampedValueResolver");
static_assert(sizeof(UGameResourcePoolClampedValueResolver) == 0x0000C0, "Wrong size on UGameResourcePoolClampedValueResolver");

// Class GbxGameSystemCore.AimControlData
// 0x0068 (0x0098 - 0x0030)
class UAimControlData final : public UGbxDataAsset
{
public:
	float                                         InputCurveExponent;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationCap;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelRate;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecelRate;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelRateRawBias;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAimSensitivityLevelParameters> HipSensitivityLevels;                              // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAimSensitivityLevelParameters> ZoomSensitivityLevels;                             // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAimSensitivityLevelParameters> VehicleSensitivityLevels;                          // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinFOVScaling;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAcceptedFOVScale;                               // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFOVScalingMouse;                                // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAcceptedFOVScaleMouse;                          // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighDeadZone;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxialDeadZoneBegin;                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxialDeadZoneRatio;                                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimControlData">();
	}
	static class UAimControlData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimControlData>();
	}
};
static_assert(alignof(UAimControlData) == 0x000008, "Wrong alignment on UAimControlData");
static_assert(sizeof(UAimControlData) == 0x000098, "Wrong size on UAimControlData");
static_assert(offsetof(UAimControlData, InputCurveExponent) == 0x000030, "Member 'UAimControlData::InputCurveExponent' has a wrong offset!");
static_assert(offsetof(UAimControlData, RotationCap) == 0x000034, "Member 'UAimControlData::RotationCap' has a wrong offset!");
static_assert(offsetof(UAimControlData, AccelRate) == 0x000038, "Member 'UAimControlData::AccelRate' has a wrong offset!");
static_assert(offsetof(UAimControlData, DecelRate) == 0x00003C, "Member 'UAimControlData::DecelRate' has a wrong offset!");
static_assert(offsetof(UAimControlData, AccelRateRawBias) == 0x000040, "Member 'UAimControlData::AccelRateRawBias' has a wrong offset!");
static_assert(offsetof(UAimControlData, HipSensitivityLevels) == 0x000048, "Member 'UAimControlData::HipSensitivityLevels' has a wrong offset!");
static_assert(offsetof(UAimControlData, ZoomSensitivityLevels) == 0x000058, "Member 'UAimControlData::ZoomSensitivityLevels' has a wrong offset!");
static_assert(offsetof(UAimControlData, VehicleSensitivityLevels) == 0x000068, "Member 'UAimControlData::VehicleSensitivityLevels' has a wrong offset!");
static_assert(offsetof(UAimControlData, MinFOVScaling) == 0x000078, "Member 'UAimControlData::MinFOVScaling' has a wrong offset!");
static_assert(offsetof(UAimControlData, MinAcceptedFOVScale) == 0x00007C, "Member 'UAimControlData::MinAcceptedFOVScale' has a wrong offset!");
static_assert(offsetof(UAimControlData, MinFOVScalingMouse) == 0x000080, "Member 'UAimControlData::MinFOVScalingMouse' has a wrong offset!");
static_assert(offsetof(UAimControlData, MinAcceptedFOVScaleMouse) == 0x000084, "Member 'UAimControlData::MinAcceptedFOVScaleMouse' has a wrong offset!");
static_assert(offsetof(UAimControlData, HighDeadZone) == 0x000088, "Member 'UAimControlData::HighDeadZone' has a wrong offset!");
static_assert(offsetof(UAimControlData, AxialDeadZoneBegin) == 0x00008C, "Member 'UAimControlData::AxialDeadZoneBegin' has a wrong offset!");
static_assert(offsetof(UAimControlData, AxialDeadZoneRatio) == 0x000090, "Member 'UAimControlData::AxialDeadZoneRatio' has a wrong offset!");

// Class GbxGameSystemCore.AISense_Bullet
// 0x0060 (0x00F8 - 0x0098)
class UAISense_Bullet final : public UAISense
{
public:
	TArray<struct FAIBulletEvent>                 BulletEvents;                                      // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportBulletEvent(class UObject* WorldContext, const struct FVector& StartLoc, const struct FVector& EndLoc, bool bFirstEvent, class AActor* Instigator, float Strength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Bullet">();
	}
	static class UAISense_Bullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Bullet>();
	}
};
static_assert(alignof(UAISense_Bullet) == 0x000008, "Wrong alignment on UAISense_Bullet");
static_assert(sizeof(UAISense_Bullet) == 0x0000F8, "Wrong size on UAISense_Bullet");
static_assert(offsetof(UAISense_Bullet, BulletEvents) == 0x000098, "Member 'UAISense_Bullet::BulletEvents' has a wrong offset!");

// Class GbxGameSystemCore.GameStatsComponent
// 0x0018 (0x0190 - 0x0178)
class UGameStatsComponent final : public UActorComponent
{
public:
	TArray<struct FGameStat>                      GameStats;                                         // 0x0178(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGameStatChannel>        GameStatChannel;                                   // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetStatValue(class UGameStatData* GameStat);
	void IncrementStat(class UGameStatData* GameStat, int32 Amount);
	void UpdateStat(class UGameStatData* GameStat, int32 NewValue);

	const TArray<struct FGameStat> GetGameStats() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStatsComponent">();
	}
	static class UGameStatsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStatsComponent>();
	}
};
static_assert(alignof(UGameStatsComponent) == 0x000008, "Wrong alignment on UGameStatsComponent");
static_assert(sizeof(UGameStatsComponent) == 0x000190, "Wrong size on UGameStatsComponent");
static_assert(offsetof(UGameStatsComponent, GameStats) == 0x000178, "Member 'UGameStatsComponent::GameStats' has a wrong offset!");
static_assert(offsetof(UGameStatsComponent, GameStatChannel) == 0x000188, "Member 'UGameStatsComponent::GameStatChannel' has a wrong offset!");

// Class GbxGameSystemCore.AISense_GbxPrediction
// 0x0060 (0x00F8 - 0x0098)
class UAISense_GbxPrediction final : public UAISense
{
public:
	uint8                                         Pad_98[0x60];                                      // 0x0098(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_GbxPrediction">();
	}
	static class UAISense_GbxPrediction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_GbxPrediction>();
	}
};
static_assert(alignof(UAISense_GbxPrediction) == 0x000008, "Wrong alignment on UAISense_GbxPrediction");
static_assert(sizeof(UAISense_GbxPrediction) == 0x0000F8, "Wrong size on UAISense_GbxPrediction");

// Class GbxGameSystemCore.AISense_GbxSight
// 0x0030 (0x01A0 - 0x0170)
class UAISense_GbxSight final : public UAISense_Sight
{
public:
	uint8                                         Pad_170[0x30];                                     // 0x0170(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ForceSightEvent(class UObject* WorldContext, class AActor* SeenActor, class AActor* LookingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_GbxSight">();
	}
	static class UAISense_GbxSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_GbxSight>();
	}
};
static_assert(alignof(UAISense_GbxSight) == 0x000008, "Wrong alignment on UAISense_GbxSight");
static_assert(sizeof(UAISense_GbxSight) == 0x0001A0, "Wrong size on UAISense_GbxSight");

// Class GbxGameSystemCore.GameResourcePoolManagerComponent
// 0x0128 (0x02A0 - 0x0178)
class UGameResourcePoolManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameResourcePool>              ResourcePools;                                     // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameResourcePool>              PendingResourcePools;                              // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGameResourcePoolNet                   ReplicatedPoolData;                                // 0x01A0(0x0010)(Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameResourcePoolData*>          InitialResourcePools;                              // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameResourceUserEvent>         ResourceEvents;                                    // 0x01C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0xC8];                                     // 0x01D8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddResourcePoolDelegate(class UGameResourceData* InResourceData, class FName DelegatePropertyName, TDelegate<void(const struct FGameResourcePoolReference& ResourcePool)> ScriptDelegate);
	void ClearResourcePoolDelegate(class UGameResourceData* InResourceData, class FName DelegatePropertyName);
	struct FGameResourcePoolReference CreatePool(class UGameResourcePoolData* PoolData, bool bReinitializeExistingPool);
	struct FGameResourcePoolReference GetResourcePoolByResource(class UGameResourceData* Resource);
	void OnOwnerExperienceLevelChanged(const int32 OldExperienceLevel);
	void RecalculateAttributeInitializedPoolProperties();
	void RemoveResourcePoolDelegate(class UGameResourceData* InResourceData, class FName DelegatePropertyName, TDelegate<void(const struct FGameResourcePoolReference& ResourcePool)> ScriptDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolManagerComponent">();
	}
	static class UGameResourcePoolManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolManagerComponent>();
	}
};
static_assert(alignof(UGameResourcePoolManagerComponent) == 0x000008, "Wrong alignment on UGameResourcePoolManagerComponent");
static_assert(sizeof(UGameResourcePoolManagerComponent) == 0x0002A0, "Wrong size on UGameResourcePoolManagerComponent");
static_assert(offsetof(UGameResourcePoolManagerComponent, ResourcePools) == 0x000180, "Member 'UGameResourcePoolManagerComponent::ResourcePools' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolManagerComponent, PendingResourcePools) == 0x000190, "Member 'UGameResourcePoolManagerComponent::PendingResourcePools' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolManagerComponent, ReplicatedPoolData) == 0x0001A0, "Member 'UGameResourcePoolManagerComponent::ReplicatedPoolData' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolManagerComponent, InitialResourcePools) == 0x0001B8, "Member 'UGameResourcePoolManagerComponent::InitialResourcePools' has a wrong offset!");
static_assert(offsetof(UGameResourcePoolManagerComponent, ResourceEvents) == 0x0001C8, "Member 'UGameResourcePoolManagerComponent::ResourceEvents' has a wrong offset!");

// Class GbxGameSystemCore.AISenseConfig_Bullet
// 0x0010 (0x0058 - 0x0048)
class UAISenseConfig_Bullet final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Bullet>            Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ListenRadius;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Bullet">();
	}
	static class UAISenseConfig_Bullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Bullet>();
	}
};
static_assert(alignof(UAISenseConfig_Bullet) == 0x000008, "Wrong alignment on UAISenseConfig_Bullet");
static_assert(sizeof(UAISenseConfig_Bullet) == 0x000058, "Wrong size on UAISenseConfig_Bullet");
static_assert(offsetof(UAISenseConfig_Bullet, Implementation) == 0x000048, "Member 'UAISenseConfig_Bullet::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Bullet, ListenRadius) == 0x000050, "Member 'UAISenseConfig_Bullet::ListenRadius' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Bullet, DetectionByAffiliation) == 0x000054, "Member 'UAISenseConfig_Bullet::DetectionByAffiliation' has a wrong offset!");

// Class GbxGameSystemCore.AISenseConfig_GbxPrediction
// 0x0008 (0x0050 - 0x0048)
class UAISenseConfig_GbxPrediction final : public UAISenseConfig
{
public:
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_GbxPrediction">();
	}
	static class UAISenseConfig_GbxPrediction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_GbxPrediction>();
	}
};
static_assert(alignof(UAISenseConfig_GbxPrediction) == 0x000008, "Wrong alignment on UAISenseConfig_GbxPrediction");
static_assert(sizeof(UAISenseConfig_GbxPrediction) == 0x000050, "Wrong size on UAISenseConfig_GbxPrediction");
static_assert(offsetof(UAISenseConfig_GbxPrediction, DetectionByAffiliation) == 0x000048, "Member 'UAISenseConfig_GbxPrediction::DetectionByAffiliation' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_CanInterruptAnim
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_CanInterruptAnim final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CanInterruptAnim">();
	}
	static class UAnimNotify_CanInterruptAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CanInterruptAnim>();
	}
};
static_assert(alignof(UAnimNotify_CanInterruptAnim) == 0x000008, "Wrong alignment on UAnimNotify_CanInterruptAnim");
static_assert(sizeof(UAnimNotify_CanInterruptAnim) == 0x000038, "Wrong size on UAnimNotify_CanInterruptAnim");

// Class GbxGameSystemCore.AnimNotify_CauseDamage
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_CauseDamage final : public UAnimNotify
{
public:
	TSubclassOf<class UDamageData>                DamageData;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CauseDamage">();
	}
	static class UAnimNotify_CauseDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CauseDamage>();
	}
};
static_assert(alignof(UAnimNotify_CauseDamage) == 0x000008, "Wrong alignment on UAnimNotify_CauseDamage");
static_assert(sizeof(UAnimNotify_CauseDamage) == 0x000040, "Wrong size on UAnimNotify_CauseDamage");
static_assert(offsetof(UAnimNotify_CauseDamage, DamageData) == 0x000038, "Member 'UAnimNotify_CauseDamage::DamageData' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_KeyedContainer
// 0x0008 (0x0068 - 0x0060)
class UGbxAction_KeyedContainer : public UGbxAction
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0060(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_KeyedContainer">();
	}
	static class UGbxAction_KeyedContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_KeyedContainer>();
	}
};
static_assert(alignof(UGbxAction_KeyedContainer) == 0x000008, "Wrong alignment on UGbxAction_KeyedContainer");
static_assert(sizeof(UGbxAction_KeyedContainer) == 0x000068, "Wrong size on UGbxAction_KeyedContainer");
static_assert(offsetof(UGbxAction_KeyedContainer, ActionKey) == 0x000060, "Member 'UGbxAction_KeyedContainer::ActionKey' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_GbxAction
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_GbxAction : public UAnimNotify
{
public:
	class FName                                   CustomEventName;                                   // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GbxAction">();
	}
	static class UAnimNotify_GbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GbxAction>();
	}
};
static_assert(alignof(UAnimNotify_GbxAction) == 0x000008, "Wrong alignment on UAnimNotify_GbxAction");
static_assert(sizeof(UAnimNotify_GbxAction) == 0x000040, "Wrong size on UAnimNotify_GbxAction");
static_assert(offsetof(UAnimNotify_GbxAction, CustomEventName) == 0x000038, "Member 'UAnimNotify_GbxAction::CustomEventName' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_HandPlant
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_HandPlant final : public UAnimNotify
{
public:
	int32                                         HandIndex;                                         // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictToMatchingPlayerPerspective;              // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_HandPlant">();
	}
	static class UAnimNotify_HandPlant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_HandPlant>();
	}
};
static_assert(alignof(UAnimNotify_HandPlant) == 0x000008, "Wrong alignment on UAnimNotify_HandPlant");
static_assert(sizeof(UAnimNotify_HandPlant) == 0x000048, "Wrong size on UAnimNotify_HandPlant");
static_assert(offsetof(UAnimNotify_HandPlant, HandIndex) == 0x000038, "Member 'UAnimNotify_HandPlant::HandIndex' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandPlant, Volume) == 0x00003C, "Member 'UAnimNotify_HandPlant::Volume' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandPlant, Pitch) == 0x000040, "Member 'UAnimNotify_HandPlant::Pitch' has a wrong offset!");
static_assert(offsetof(UAnimNotify_HandPlant, bRestrictToMatchingPlayerPerspective) == 0x000044, "Member 'UAnimNotify_HandPlant::bRestrictToMatchingPlayerPerspective' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_AICharge
// 0x0088 (0x0140 - 0x00B8)
class UGbxAction_AICharge : public UGbxAction_SimpleAnim
{
public:
	bool                                          bSetLoopSpeedManually;                             // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimLoopSpeed;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartBlendInTime;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoopBlendInTime;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StopBlendInTime;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  StartAnims;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  LoopAnims;                                         // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  MissAnims;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  StrikeAnims;                                       // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  HitWallAnims;                                      // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  ReachCliffAnims;                                   // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAnimMeshList>                  StopForFriendlyAnims;                              // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnHitWall(class AActor* Actor) const;
	void OnLoop(class AActor* Actor) const;
	void OnMiss(class AActor* Actor) const;
	void OnReachCliff(class AActor* Actor) const;
	void OnStopForFriendly(class AActor* Actor) const;
	void OnStrike(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_AICharge">();
	}
	static class UGbxAction_AICharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_AICharge>();
	}
};
static_assert(alignof(UGbxAction_AICharge) == 0x000008, "Wrong alignment on UGbxAction_AICharge");
static_assert(sizeof(UGbxAction_AICharge) == 0x000140, "Wrong size on UGbxAction_AICharge");
static_assert(offsetof(UGbxAction_AICharge, bSetLoopSpeedManually) == 0x0000B8, "Member 'UGbxAction_AICharge::bSetLoopSpeedManually' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, AnimLoopSpeed) == 0x0000BC, "Member 'UGbxAction_AICharge::AnimLoopSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, StartBlendInTime) == 0x0000C0, "Member 'UGbxAction_AICharge::StartBlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, LoopBlendInTime) == 0x0000C4, "Member 'UGbxAction_AICharge::LoopBlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, StopBlendInTime) == 0x0000C8, "Member 'UGbxAction_AICharge::StopBlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, BlendOutTime) == 0x0000CC, "Member 'UGbxAction_AICharge::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, StartAnims) == 0x0000D0, "Member 'UGbxAction_AICharge::StartAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, LoopAnims) == 0x0000E0, "Member 'UGbxAction_AICharge::LoopAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, MissAnims) == 0x0000F0, "Member 'UGbxAction_AICharge::MissAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, StrikeAnims) == 0x000100, "Member 'UGbxAction_AICharge::StrikeAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, HitWallAnims) == 0x000110, "Member 'UGbxAction_AICharge::HitWallAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, ReachCliffAnims) == 0x000120, "Member 'UGbxAction_AICharge::ReachCliffAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_AICharge, StopForFriendlyAnims) == 0x000130, "Member 'UGbxAction_AICharge::StopForFriendlyAnims' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_PlayJumpedImpact
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PlayJumpedImpact final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayJumpedImpact">();
	}
	static class UAnimNotify_PlayJumpedImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayJumpedImpact>();
	}
};
static_assert(alignof(UAnimNotify_PlayJumpedImpact) == 0x000008, "Wrong alignment on UAnimNotify_PlayJumpedImpact");
static_assert(sizeof(UAnimNotify_PlayJumpedImpact) == 0x000038, "Wrong size on UAnimNotify_PlayJumpedImpact");

// Class GbxGameSystemCore.AnimNotify_PlayLandedImpact
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PlayLandedImpact final : public UAnimNotify
{
public:
	float                                         ImpactSpeed;                                       // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAsIfFromJump;                                     // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayLandedImpact">();
	}
	static class UAnimNotify_PlayLandedImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayLandedImpact>();
	}
};
static_assert(alignof(UAnimNotify_PlayLandedImpact) == 0x000008, "Wrong alignment on UAnimNotify_PlayLandedImpact");
static_assert(sizeof(UAnimNotify_PlayLandedImpact) == 0x000040, "Wrong size on UAnimNotify_PlayLandedImpact");
static_assert(offsetof(UAnimNotify_PlayLandedImpact, ImpactSpeed) == 0x000038, "Member 'UAnimNotify_PlayLandedImpact::ImpactSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayLandedImpact, bAsIfFromJump) == 0x00003C, "Member 'UAnimNotify_PlayLandedImpact::bAsIfFromJump' has a wrong offset!");

// Class GbxGameSystemCore.GameStatChannel
// 0x0008 (0x0070 - 0x0068)
class UGameStatChannel final : public UChannel
{
public:
	TWeakObjectPtr<class UGameStatsComponent>     GameStatsComponent;                                // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStatChannel">();
	}
	static class UGameStatChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStatChannel>();
	}
};
static_assert(alignof(UGameStatChannel) == 0x000008, "Wrong alignment on UGameStatChannel");
static_assert(sizeof(UGameStatChannel) == 0x000070, "Wrong size on UGameStatChannel");
static_assert(offsetof(UGameStatChannel, GameStatsComponent) == 0x000068, "Member 'UGameStatChannel::GameStatsComponent' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_SetRagdollObjectHoldTransform
// 0x0038 (0x0070 - 0x0038)
class UAnimNotify_SetRagdollObjectHoldTransform final : public UAnimNotify
{
public:
	bool                                          bEnable;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetRagdollObjectHoldTransform">();
	}
	static class UAnimNotify_SetRagdollObjectHoldTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetRagdollObjectHoldTransform>();
	}
};
static_assert(alignof(UAnimNotify_SetRagdollObjectHoldTransform) == 0x000010, "Wrong alignment on UAnimNotify_SetRagdollObjectHoldTransform");
static_assert(sizeof(UAnimNotify_SetRagdollObjectHoldTransform) == 0x000070, "Wrong size on UAnimNotify_SetRagdollObjectHoldTransform");
static_assert(offsetof(UAnimNotify_SetRagdollObjectHoldTransform, bEnable) == 0x000038, "Member 'UAnimNotify_SetRagdollObjectHoldTransform::bEnable' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SetRagdollObjectHoldTransform, Transform) == 0x000040, "Member 'UAnimNotify_SetRagdollObjectHoldTransform::Transform' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotify_StretchBonesMarker
// 0x0028 (0x0068 - 0x0040)
class UAnimNotify_StretchBonesMarker final : public UAnimNotify_GbxAction
{
public:
	class FName                                   StartBoneName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBoneName;                                       // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimatedTargetDistance;                            // 0x0050(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtVector;                                      // 0x0054(0x000C)(BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XScale;                                            // 0x0060(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_StretchBonesMarker">();
	}
	static class UAnimNotify_StretchBonesMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_StretchBonesMarker>();
	}
};
static_assert(alignof(UAnimNotify_StretchBonesMarker) == 0x000008, "Wrong alignment on UAnimNotify_StretchBonesMarker");
static_assert(sizeof(UAnimNotify_StretchBonesMarker) == 0x000068, "Wrong size on UAnimNotify_StretchBonesMarker");
static_assert(offsetof(UAnimNotify_StretchBonesMarker, StartBoneName) == 0x000040, "Member 'UAnimNotify_StretchBonesMarker::StartBoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_StretchBonesMarker, EndBoneName) == 0x000048, "Member 'UAnimNotify_StretchBonesMarker::EndBoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_StretchBonesMarker, AnimatedTargetDistance) == 0x000050, "Member 'UAnimNotify_StretchBonesMarker::AnimatedTargetDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotify_StretchBonesMarker, LookAtVector) == 0x000054, "Member 'UAnimNotify_StretchBonesMarker::LookAtVector' has a wrong offset!");
static_assert(offsetof(UAnimNotify_StretchBonesMarker, XScale) == 0x000060, "Member 'UAnimNotify_StretchBonesMarker::XScale' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_DodgePicker
// 0x0040 (0x00A0 - 0x0060)
class UGbxAction_DodgePicker : public UGbxAction
{
public:
	TSubclassOf<class UGbxAction>                 IdleLeft;                                          // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 IdleRight;                                         // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 MovingLeft;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 MovingLeftBackward;                                // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 MovingLeftForward;                                 // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 MovingRight;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 MovingRightBackward;                               // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 MovingRightForward;                                // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_DodgePicker">();
	}
	static class UGbxAction_DodgePicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_DodgePicker>();
	}
};
static_assert(alignof(UGbxAction_DodgePicker) == 0x000008, "Wrong alignment on UGbxAction_DodgePicker");
static_assert(sizeof(UGbxAction_DodgePicker) == 0x0000A0, "Wrong size on UGbxAction_DodgePicker");
static_assert(offsetof(UGbxAction_DodgePicker, IdleLeft) == 0x000060, "Member 'UGbxAction_DodgePicker::IdleLeft' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, IdleRight) == 0x000068, "Member 'UGbxAction_DodgePicker::IdleRight' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, MovingLeft) == 0x000070, "Member 'UGbxAction_DodgePicker::MovingLeft' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, MovingLeftBackward) == 0x000078, "Member 'UGbxAction_DodgePicker::MovingLeftBackward' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, MovingLeftForward) == 0x000080, "Member 'UGbxAction_DodgePicker::MovingLeftForward' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, MovingRight) == 0x000088, "Member 'UGbxAction_DodgePicker::MovingRight' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, MovingRightBackward) == 0x000090, "Member 'UGbxAction_DodgePicker::MovingRightBackward' has a wrong offset!");
static_assert(offsetof(UGbxAction_DodgePicker, MovingRightForward) == 0x000098, "Member 'UGbxAction_DodgePicker::MovingRightForward' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_DeathOverride
// 0x0020 (0x0050 - 0x0030)
class UAnimNotifyState_DeathOverride final : public UAnimNotifyState
{
public:
	class UHitReactionTag*                        DeathReactionTag;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DefaultReactionTagName;                            // 0x0038(0x0018)(BlueprintReadOnly, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DeathOverride">();
	}
	static class UAnimNotifyState_DeathOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DeathOverride>();
	}
};
static_assert(alignof(UAnimNotifyState_DeathOverride) == 0x000008, "Wrong alignment on UAnimNotifyState_DeathOverride");
static_assert(sizeof(UAnimNotifyState_DeathOverride) == 0x000050, "Wrong size on UAnimNotifyState_DeathOverride");
static_assert(offsetof(UAnimNotifyState_DeathOverride, DeathReactionTag) == 0x000030, "Member 'UAnimNotifyState_DeathOverride::DeathReactionTag' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_DeathOverride, DefaultReactionTagName) == 0x000038, "Member 'UAnimNotifyState_DeathOverride::DefaultReactionTagName' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_DisableLegIK
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableLegIK final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableLegIK">();
	}
	static class UAnimNotifyState_DisableLegIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableLegIK>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableLegIK) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableLegIK");
static_assert(sizeof(UAnimNotifyState_DisableLegIK) == 0x000030, "Wrong size on UAnimNotifyState_DisableLegIK");

// Class GbxGameSystemCore.GbxActionComponent
// 0x0268 (0x03E0 - 0x0178)
class UGbxActionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxActionSlot>                 ActionSlots;                                       // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDataActionPair>                EditorKeyedActionList;                             // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataActionPair_Spawn>          SpawnKeyedActionList;                              // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataActionPair_SpawnMesh>      SpawnMeshKeyedActionList;                          // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDataActionPair_SmartObject>    SmartObjectKeyedActionList;                        // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x150];                                    // 0x01D0(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActionStarted;                                   // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnActionStopped;                                   // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0xA0];                                     // 0x0340(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGbxAction* K2_Play(TSubclassOf<class UGbxAction> ActionClass);
	void NotifyInterruptRequest();
	void OnComponentAttached(class USceneComponent* SceneComponent);
	void OnComponentDetached(class USceneComponent* SceneComponent);
	void OnComponentUnregistered(class UActorComponent* ActorComponent);
	void PlayOnRemoteServer(TSubclassOf<class UGbxAction> ActionClass, const struct FActionState_Base& ActionData);
	void StopActionClass(TSubclassOf<class UGbxAction> ActionClass);
	void StopActions();
	void StopActionSlot(const class FName ActionSlotName);
	void StopLoopingActionClass(TSubclassOf<class UGbxAction_Loop> ActionClass);
	void StopOnRemoteServer(int32 ManagerRepId, const EGbxActionEndState& EndState);
	void UpdateActionRemoteServer(const struct FActionState_Base& ActionData);

	bool IsPlayingClass(TSubclassOf<class UGbxAction> ActionClass) const;
	bool IsPlayingSlot(const class FName& ActionSlotName) const;
	class UGbxAction* K2_GetActionByClass(TSubclassOf<class UGbxAction> ActionClass) const;
	class UGbxAction* K2_GetActionBySlot(const class FName ActionSlotName) const;
	bool K2_IsPlayingObj(class UGbxAction* Action) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxActionComponent">();
	}
	static class UGbxActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxActionComponent>();
	}
};
static_assert(alignof(UGbxActionComponent) == 0x000008, "Wrong alignment on UGbxActionComponent");
static_assert(sizeof(UGbxActionComponent) == 0x0003E0, "Wrong size on UGbxActionComponent");
static_assert(offsetof(UGbxActionComponent, ActionSlots) == 0x000180, "Member 'UGbxActionComponent::ActionSlots' has a wrong offset!");
static_assert(offsetof(UGbxActionComponent, EditorKeyedActionList) == 0x000190, "Member 'UGbxActionComponent::EditorKeyedActionList' has a wrong offset!");
static_assert(offsetof(UGbxActionComponent, SpawnKeyedActionList) == 0x0001A0, "Member 'UGbxActionComponent::SpawnKeyedActionList' has a wrong offset!");
static_assert(offsetof(UGbxActionComponent, SpawnMeshKeyedActionList) == 0x0001B0, "Member 'UGbxActionComponent::SpawnMeshKeyedActionList' has a wrong offset!");
static_assert(offsetof(UGbxActionComponent, SmartObjectKeyedActionList) == 0x0001C0, "Member 'UGbxActionComponent::SmartObjectKeyedActionList' has a wrong offset!");
static_assert(offsetof(UGbxActionComponent, OnActionStarted) == 0x000320, "Member 'UGbxActionComponent::OnActionStarted' has a wrong offset!");
static_assert(offsetof(UGbxActionComponent, OnActionStopped) == 0x000330, "Member 'UGbxActionComponent::OnActionStopped' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_DisableLegIKTracing
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableLegIKTracing final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableLegIKTracing">();
	}
	static class UAnimNotifyState_DisableLegIKTracing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableLegIKTracing>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableLegIKTracing) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableLegIKTracing");
static_assert(sizeof(UAnimNotifyState_DisableLegIKTracing) == 0x000030, "Wrong size on UAnimNotifyState_DisableLegIKTracing");

// Class GbxGameSystemCore.AnimNotifyState_DisableLookAt
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableLookAt final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableLookAt">();
	}
	static class UAnimNotifyState_DisableLookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableLookAt>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableLookAt) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableLookAt");
static_assert(sizeof(UAnimNotifyState_DisableLookAt) == 0x000030, "Wrong size on UAnimNotifyState_DisableLookAt");

// Class GbxGameSystemCore.MotionMatchedAnimationTable
// 0x0058 (0x00A0 - 0x0048)
class UMotionMatchedAnimationTable final : public UGbxAnimTable
{
public:
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RootMotionBone;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         RootMotionBoneUpAxis;                              // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpAxisIsNegative;                                 // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         RootMotionBoneForwardAxis;                         // 0x0082(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForwardAxisIsNegative;                            // 0x0083(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         RootBoneForwardAxis;                               // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRootForwardAxisIsNegative;                        // 0x0085(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         RootBoneUpAxis;                                    // 0x0086(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRootUpAxisIsNegative;                             // 0x0087(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoMotionSpeed;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseIdlePoseDriving;                               // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinIdleTime;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicToKinematicTransition                 DynamicToKinematicTransition;                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendToRecoveryTime;                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAllowedDeviation;                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionMatchedAnimationTable">();
	}
	static class UMotionMatchedAnimationTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionMatchedAnimationTable>();
	}
};
static_assert(alignof(UMotionMatchedAnimationTable) == 0x000008, "Wrong alignment on UMotionMatchedAnimationTable");
static_assert(sizeof(UMotionMatchedAnimationTable) == 0x0000A0, "Wrong size on UMotionMatchedAnimationTable");
static_assert(offsetof(UMotionMatchedAnimationTable, RootMotionBone) == 0x000078, "Member 'UMotionMatchedAnimationTable::RootMotionBone' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, RootMotionBoneUpAxis) == 0x000080, "Member 'UMotionMatchedAnimationTable::RootMotionBoneUpAxis' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, bUpAxisIsNegative) == 0x000081, "Member 'UMotionMatchedAnimationTable::bUpAxisIsNegative' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, RootMotionBoneForwardAxis) == 0x000082, "Member 'UMotionMatchedAnimationTable::RootMotionBoneForwardAxis' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, bForwardAxisIsNegative) == 0x000083, "Member 'UMotionMatchedAnimationTable::bForwardAxisIsNegative' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, RootBoneForwardAxis) == 0x000084, "Member 'UMotionMatchedAnimationTable::RootBoneForwardAxis' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, bRootForwardAxisIsNegative) == 0x000085, "Member 'UMotionMatchedAnimationTable::bRootForwardAxisIsNegative' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, RootBoneUpAxis) == 0x000086, "Member 'UMotionMatchedAnimationTable::RootBoneUpAxis' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, bRootUpAxisIsNegative) == 0x000087, "Member 'UMotionMatchedAnimationTable::bRootUpAxisIsNegative' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, NoMotionSpeed) == 0x000088, "Member 'UMotionMatchedAnimationTable::NoMotionSpeed' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, bUseIdlePoseDriving) == 0x00008C, "Member 'UMotionMatchedAnimationTable::bUseIdlePoseDriving' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, MinIdleTime) == 0x000090, "Member 'UMotionMatchedAnimationTable::MinIdleTime' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, DynamicToKinematicTransition) == 0x000094, "Member 'UMotionMatchedAnimationTable::DynamicToKinematicTransition' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, BlendToRecoveryTime) == 0x000098, "Member 'UMotionMatchedAnimationTable::BlendToRecoveryTime' has a wrong offset!");
static_assert(offsetof(UMotionMatchedAnimationTable, MaxAllowedDeviation) == 0x00009C, "Member 'UMotionMatchedAnimationTable::MaxAllowedDeviation' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_Feedback
// 0x0048 (0x0078 - 0x0030)
class UAnimNotifyState_Feedback final : public UAnimNotifyState
{
public:
	uint8                                         bApplyToAllPlayers : 1;                            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          FeedbackData;                                      // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           FeedbackScale;                                     // 0x0040(0x0038)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_Feedback">();
	}
	static class UAnimNotifyState_Feedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_Feedback>();
	}
};
static_assert(alignof(UAnimNotifyState_Feedback) == 0x000008, "Wrong alignment on UAnimNotifyState_Feedback");
static_assert(sizeof(UAnimNotifyState_Feedback) == 0x000078, "Wrong size on UAnimNotifyState_Feedback");
static_assert(offsetof(UAnimNotifyState_Feedback, FeedbackData) == 0x000038, "Member 'UAnimNotifyState_Feedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Feedback, FeedbackScale) == 0x000040, "Member 'UAnimNotifyState_Feedback::FeedbackScale' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_GbxAction
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_GbxAction : public UAnimNotifyState
{
public:
	class FName                                   CustomEventName;                                   // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GbxAction">();
	}
	static class UAnimNotifyState_GbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GbxAction>();
	}
};
static_assert(alignof(UAnimNotifyState_GbxAction) == 0x000008, "Wrong alignment on UAnimNotifyState_GbxAction");
static_assert(sizeof(UAnimNotifyState_GbxAction) == 0x000038, "Wrong size on UAnimNotifyState_GbxAction");
static_assert(offsetof(UAnimNotifyState_GbxAction, CustomEventName) == 0x000030, "Member 'UAnimNotifyState_GbxAction::CustomEventName' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_ConditionContainer
// 0x0018 (0x0078 - 0x0060)
class UGbxAction_ConditionContainer : public UGbxAction
{
public:
	EActionSelectionMethod                        ActionSelectionMethod;                             // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConditionActionPair>           ConditionList;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_ConditionContainer">();
	}
	static class UGbxAction_ConditionContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_ConditionContainer>();
	}
};
static_assert(alignof(UGbxAction_ConditionContainer) == 0x000008, "Wrong alignment on UGbxAction_ConditionContainer");
static_assert(sizeof(UGbxAction_ConditionContainer) == 0x000078, "Wrong size on UGbxAction_ConditionContainer");
static_assert(offsetof(UGbxAction_ConditionContainer, ActionSelectionMethod) == 0x000060, "Member 'UGbxAction_ConditionContainer::ActionSelectionMethod' has a wrong offset!");
static_assert(offsetof(UGbxAction_ConditionContainer, ConditionList) == 0x000068, "Member 'UGbxAction_ConditionContainer::ConditionList' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_RootMotionRotation
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_RootMotionRotation final : public UAnimNotifyState
{
public:
	int32                                         LockFootIkIndex;                                   // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockFootIK;                                       // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RootMotionRotation">();
	}
	static class UAnimNotifyState_RootMotionRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RootMotionRotation>();
	}
};
static_assert(alignof(UAnimNotifyState_RootMotionRotation) == 0x000008, "Wrong alignment on UAnimNotifyState_RootMotionRotation");
static_assert(sizeof(UAnimNotifyState_RootMotionRotation) == 0x000038, "Wrong size on UAnimNotifyState_RootMotionRotation");
static_assert(offsetof(UAnimNotifyState_RootMotionRotation, LockFootIkIndex) == 0x000030, "Member 'UAnimNotifyState_RootMotionRotation::LockFootIkIndex' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RootMotionRotation, bLockFootIK) == 0x000034, "Member 'UAnimNotifyState_RootMotionRotation::bLockFootIK' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_SoftAlign
// 0x0020 (0x0050 - 0x0030)
class UAnimNotifyState_SoftAlign final : public UAnimNotifyState
{
public:
	EAnimNotifyAlignType                          Type;                                              // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAffectsLocation : 1;                              // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAffectsRotation : 1;                              // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PartnerName;                                       // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionSlotName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AlignSocketPartner;                                // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SoftAlign">();
	}
	static class UAnimNotifyState_SoftAlign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SoftAlign>();
	}
};
static_assert(alignof(UAnimNotifyState_SoftAlign) == 0x000008, "Wrong alignment on UAnimNotifyState_SoftAlign");
static_assert(sizeof(UAnimNotifyState_SoftAlign) == 0x000050, "Wrong size on UAnimNotifyState_SoftAlign");
static_assert(offsetof(UAnimNotifyState_SoftAlign, Type) == 0x000030, "Member 'UAnimNotifyState_SoftAlign::Type' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SoftAlign, PartnerName) == 0x000038, "Member 'UAnimNotifyState_SoftAlign::PartnerName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SoftAlign, ActionSlotName) == 0x000040, "Member 'UAnimNotifyState_SoftAlign::ActionSlotName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SoftAlign, AlignSocketPartner) == 0x000048, "Member 'UAnimNotifyState_SoftAlign::AlignSocketPartner' has a wrong offset!");

// Class GbxGameSystemCore.AnimNotifyState_StretchBonesMarker
// 0x0038 (0x0070 - 0x0038)
class UAnimNotifyState_StretchBonesMarker final : public UAnimNotifyState_GbxAction
{
public:
	class FName                                   StartBoneName;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBoneName;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimatedTargetDistance;                            // 0x0048(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtVector;                                      // 0x004C(0x000C)(BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAnimatedTargetDistance;                         // 0x0058(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLookAtVector;                                   // 0x005C(0x000C)(BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XScale;                                            // 0x0068(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_StretchBonesMarker">();
	}
	static class UAnimNotifyState_StretchBonesMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_StretchBonesMarker>();
	}
};
static_assert(alignof(UAnimNotifyState_StretchBonesMarker) == 0x000008, "Wrong alignment on UAnimNotifyState_StretchBonesMarker");
static_assert(sizeof(UAnimNotifyState_StretchBonesMarker) == 0x000070, "Wrong size on UAnimNotifyState_StretchBonesMarker");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, StartBoneName) == 0x000038, "Member 'UAnimNotifyState_StretchBonesMarker::StartBoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, EndBoneName) == 0x000040, "Member 'UAnimNotifyState_StretchBonesMarker::EndBoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, AnimatedTargetDistance) == 0x000048, "Member 'UAnimNotifyState_StretchBonesMarker::AnimatedTargetDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, LookAtVector) == 0x00004C, "Member 'UAnimNotifyState_StretchBonesMarker::LookAtVector' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, EndAnimatedTargetDistance) == 0x000058, "Member 'UAnimNotifyState_StretchBonesMarker::EndAnimatedTargetDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, EndLookAtVector) == 0x00005C, "Member 'UAnimNotifyState_StretchBonesMarker::EndLookAtVector' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_StretchBonesMarker, XScale) == 0x000068, "Member 'UAnimNotifyState_StretchBonesMarker::XScale' has a wrong offset!");

// Class GbxGameSystemCore.AsyncExplosionImpactManager
// 0x0028 (0x0050 - 0x0028)
class UAsyncExplosionImpactManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAsyncExplosionImpactRequest>   AsyncRequests;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncExplosionImpactManager">();
	}
	static class UAsyncExplosionImpactManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncExplosionImpactManager>();
	}
};
static_assert(alignof(UAsyncExplosionImpactManager) == 0x000008, "Wrong alignment on UAsyncExplosionImpactManager");
static_assert(sizeof(UAsyncExplosionImpactManager) == 0x000050, "Wrong size on UAsyncExplosionImpactManager");
static_assert(offsetof(UAsyncExplosionImpactManager, AsyncRequests) == 0x000030, "Member 'UAsyncExplosionImpactManager::AsyncRequests' has a wrong offset!");

// Class GbxGameSystemCore.AttributeEffectMultiMutatorData
// 0x0010 (0x0040 - 0x0030)
class UAttributeEffectMultiMutatorData final : public UAttributeEffectMutatorData
{
public:
	TArray<class UAttributeEffectMutatorData*>    Mutators;                                          // 0x0030(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeEffectMultiMutatorData">();
	}
	static class UAttributeEffectMultiMutatorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeEffectMultiMutatorData>();
	}
};
static_assert(alignof(UAttributeEffectMultiMutatorData) == 0x000008, "Wrong alignment on UAttributeEffectMultiMutatorData");
static_assert(sizeof(UAttributeEffectMultiMutatorData) == 0x000040, "Wrong size on UAttributeEffectMultiMutatorData");
static_assert(offsetof(UAttributeEffectMultiMutatorData, Mutators) == 0x000030, "Member 'UAttributeEffectMultiMutatorData::Mutators' has a wrong offset!");

// Class GbxGameSystemCore.AttributeModifierTestContext
// 0x0010 (0x0038 - 0x0028)
class UAttributeModifierTestContext final : public UObject
{
public:
	struct FGbxAttributeFloat                     AttributeProperty;                                 // 0x0028(0x000C)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatProperty;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeModifierTestContext">();
	}
	static class UAttributeModifierTestContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeModifierTestContext>();
	}
};
static_assert(alignof(UAttributeModifierTestContext) == 0x000008, "Wrong alignment on UAttributeModifierTestContext");
static_assert(sizeof(UAttributeModifierTestContext) == 0x000038, "Wrong size on UAttributeModifierTestContext");
static_assert(offsetof(UAttributeModifierTestContext, AttributeProperty) == 0x000028, "Member 'UAttributeModifierTestContext::AttributeProperty' has a wrong offset!");
static_assert(offsetof(UAttributeModifierTestContext, FloatProperty) == 0x000034, "Member 'UAttributeModifierTestContext::FloatProperty' has a wrong offset!");

// Class GbxGameSystemCore.TestAttributePropertyValueResolver
// 0x0000 (0x00B0 - 0x00B0)
class UTestAttributePropertyValueResolver final : public UAttributePropertyValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestAttributePropertyValueResolver">();
	}
	static class UTestAttributePropertyValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestAttributePropertyValueResolver>();
	}
};
static_assert(alignof(UTestAttributePropertyValueResolver) == 0x000008, "Wrong alignment on UTestAttributePropertyValueResolver");
static_assert(sizeof(UTestAttributePropertyValueResolver) == 0x0000B0, "Wrong size on UTestAttributePropertyValueResolver");

// Class GbxGameSystemCore.AttributePropertyValueResolverTestContext
// 0x01A0 (0x01C8 - 0x0028)
class UAttributePropertyValueResolverTestContext final : public UObject
{
public:
	float                                         FloatProp;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatPropStaticArray[0x3];                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatPropDynamicArray;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAttributePropertyValueResolverTestContext* ObjectProp;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAttributePropertyValueResolverTestContext* ObjectPropStaticArray[0x3];                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAttributePropertyValueResolverTestContext*> ObjectPropDynamicArray;                            // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAttributePropertyValueResolverTestStruct StructProp;                                        // 0x0078(0x0050)(NativeAccessSpecifierPublic)
	struct FAttributePropertyValueResolverTestStruct StructPropStaticArray[0x3];                        // 0x00C8(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FAttributePropertyValueResolverTestStruct> StructPropDynamicArray;                            // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributePropertyValueResolverTestContext">();
	}
	static class UAttributePropertyValueResolverTestContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributePropertyValueResolverTestContext>();
	}
};
static_assert(alignof(UAttributePropertyValueResolverTestContext) == 0x000008, "Wrong alignment on UAttributePropertyValueResolverTestContext");
static_assert(sizeof(UAttributePropertyValueResolverTestContext) == 0x0001C8, "Wrong size on UAttributePropertyValueResolverTestContext");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, FloatProp) == 0x000028, "Member 'UAttributePropertyValueResolverTestContext::FloatProp' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, FloatPropStaticArray) == 0x00002C, "Member 'UAttributePropertyValueResolverTestContext::FloatPropStaticArray' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, FloatPropDynamicArray) == 0x000038, "Member 'UAttributePropertyValueResolverTestContext::FloatPropDynamicArray' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, ObjectProp) == 0x000048, "Member 'UAttributePropertyValueResolverTestContext::ObjectProp' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, ObjectPropStaticArray) == 0x000050, "Member 'UAttributePropertyValueResolverTestContext::ObjectPropStaticArray' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, ObjectPropDynamicArray) == 0x000068, "Member 'UAttributePropertyValueResolverTestContext::ObjectPropDynamicArray' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, StructProp) == 0x000078, "Member 'UAttributePropertyValueResolverTestContext::StructProp' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, StructPropStaticArray) == 0x0000C8, "Member 'UAttributePropertyValueResolverTestContext::StructPropStaticArray' has a wrong offset!");
static_assert(offsetof(UAttributePropertyValueResolverTestContext, StructPropDynamicArray) == 0x0001B8, "Member 'UAttributePropertyValueResolverTestContext::StructPropDynamicArray' has a wrong offset!");

// Class GbxGameSystemCore.BalanceStateAttributeValueResolver
// 0x0008 (0x0030 - 0x0028)
class UBalanceStateAttributeValueResolver final : public UAttributeValueResolver
{
public:
	EBalanceValueType                             ValueToResolve;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BalanceStateAttributeValueResolver">();
	}
	static class UBalanceStateAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBalanceStateAttributeValueResolver>();
	}
};
static_assert(alignof(UBalanceStateAttributeValueResolver) == 0x000008, "Wrong alignment on UBalanceStateAttributeValueResolver");
static_assert(sizeof(UBalanceStateAttributeValueResolver) == 0x000030, "Wrong size on UBalanceStateAttributeValueResolver");
static_assert(offsetof(UBalanceStateAttributeValueResolver, ValueToResolve) == 0x000028, "Member 'UBalanceStateAttributeValueResolver::ValueToResolve' has a wrong offset!");

// Class GbxGameSystemCore.BlackboardKeyAttributeContextResolver
// 0x0010 (0x0060 - 0x0050)
class UBlackboardKeyAttributeContextResolver final : public UAttributeContextResolver
{
public:
	struct FGbxBlackboardKeySelector              BlackboardKey;                                     // 0x0050(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackboardKeyAttributeContextResolver">();
	}
	static class UBlackboardKeyAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackboardKeyAttributeContextResolver>();
	}
};
static_assert(alignof(UBlackboardKeyAttributeContextResolver) == 0x000008, "Wrong alignment on UBlackboardKeyAttributeContextResolver");
static_assert(sizeof(UBlackboardKeyAttributeContextResolver) == 0x000060, "Wrong size on UBlackboardKeyAttributeContextResolver");
static_assert(offsetof(UBlackboardKeyAttributeContextResolver, BlackboardKey) == 0x000050, "Member 'UBlackboardKeyAttributeContextResolver::BlackboardKey' has a wrong offset!");

// Class GbxGameSystemCore.BlackboardKeyType_Struct
// 0x0008 (0x0038 - 0x0030)
class UBlackboardKeyType_Struct final : public UBlackboardKeyType
{
public:
	class UScriptStruct*                          Type;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackboardKeyType_Struct">();
	}
	static class UBlackboardKeyType_Struct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackboardKeyType_Struct>();
	}
};
static_assert(alignof(UBlackboardKeyType_Struct) == 0x000008, "Wrong alignment on UBlackboardKeyType_Struct");
static_assert(sizeof(UBlackboardKeyType_Struct) == 0x000038, "Wrong size on UBlackboardKeyType_Struct");
static_assert(offsetof(UBlackboardKeyType_Struct, Type) == 0x000030, "Member 'UBlackboardKeyType_Struct::Type' has a wrong offset!");

// Class GbxGameSystemCore.BlackboardKeyType_TargetActorInfo
// 0x0000 (0x0030 - 0x0030)
class UBlackboardKeyType_TargetActorInfo final : public UBlackboardKeyType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackboardKeyType_TargetActorInfo">();
	}
	static class UBlackboardKeyType_TargetActorInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackboardKeyType_TargetActorInfo>();
	}
};
static_assert(alignof(UBlackboardKeyType_TargetActorInfo) == 0x000008, "Wrong alignment on UBlackboardKeyType_TargetActorInfo");
static_assert(sizeof(UBlackboardKeyType_TargetActorInfo) == 0x000030, "Wrong size on UBlackboardKeyType_TargetActorInfo");

// Class GbxGameSystemCore.BoneModBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UBoneModBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CreateBoneMod(const class FName InBoneModName, const class FName InBoneName, const struct FVector& InTranslation, const struct FRotator& InRotation, const struct FVector& InScale, const float InBlendTime, class UObject* Target, const EAlphaBlendOption InBlendOption, const class UCurveFloat* InCustomBlendCurve, const bool bInUseTranslation, const bool bInUseRotation, const bool bInUseScale, const bool bInReplaceTranslation, const bool bInReplaceRotation, const bool bInReplaceScale, const EBoneControlSpace InTranslationSpace, const EBoneControlSpace InRotationSpace, const bool bBlendIn);
	static bool GetBoneMod(const class FName BoneModName, struct FBoneModInstance* BoneMod, class UObject* Target);
	static void RemoveBoneMod(const class FName BoneModToRemove, class UObject* Target, bool bBlendOut);
	static void SetBoneMod(struct FBoneModInstance& InBoneMod, const class FName BoneModToSet, class UObject* Target, bool bBlendIn);
	static void SetBoneModActive(const class FName BoneModName, bool bActive, class UObject* Target);
	static void SetBoneModAlphaBlend(const class FName BoneModName, const struct FAlphaBlend& Blend, class UObject* Target);
	static void SetBoneModBlendTime(const class FName BoneModName, const float BlendTime, class UObject* Target);
	static void SetBoneModBoneName(const class FName BoneModName, const class FName BoneModBoneName, class UObject* Target);
	static void SetBoneModifyProfile(class UGbxBoneModifyProfile* BoneModifyProfile, class UObject* Target);
	static void SetBoneModifyProfileState(const class FName StateName, bool bActive, class UObject* Target, float BlendTime);
	static void SetBoneModName(const class FName BoneModName, const class FName NewBoneModName, class UObject* Target);
	static void SetBoneModReplaceRotation(const class FName BoneModName, const bool bReplaceRotation, class UObject* Target);
	static void SetBoneModReplaceScale(const class FName BoneModName, const bool bReplaceScale, class UObject* Target);
	static void SetBoneModReplaceTranslation(const class FName BoneModName, const bool bReplaceTranslation, class UObject* Target);
	static void SetBoneModRotation(const class FName BoneModName, const struct FRotator& Rotation, class UObject* Target);
	static void SetBoneModRotationSpace(const class FName BoneModName, const EBoneControlSpace RotationSpace, class UObject* Target);
	static void SetBoneModScale(const class FName BoneModName, const float Scale, class UObject* Target);
	static void SetBoneModScale3D(const class FName BoneModName, const struct FVector& Scale, class UObject* Target);
	static void SetBoneModTransform(const class FName BoneModName, const struct FTransform& Transform, class UObject* Target);
	static void SetBoneModTranslation(const class FName BoneModName, const struct FVector& Translation, class UObject* Target);
	static void SetBoneModTranslationSpace(const class FName BoneModName, const EBoneControlSpace TranslationSpace, class UObject* Target);
	static void SetBoneModUseRotation(const class FName BoneModName, const bool bUseRotation, class UObject* Target);
	static void SetBoneModUseScale(const class FName BoneModName, const bool bUseScale, class UObject* Target);
	static void SetBoneModUseTranslation(const class FName BoneModName, const bool bUseTranslation, class UObject* Target);
	static void SetBoneRotation(const class FName BoneName, const struct FRotator& Rotation, class UObject* Target, const float InBlendTime, const EAlphaBlendOption InBlendOption, const class UCurveFloat* InCustomBlendCurve);
	static void SetBoneScale(const class FName BoneName, const float Scale, class UObject* Target, const float InBlendTime, const EAlphaBlendOption InBlendOption, const class UCurveFloat* InCustomBlendCurve);
	static void SetBoneScale3D(const class FName BoneName, const struct FVector& Scale3D, class UObject* Target, const float InBlendTime, const EAlphaBlendOption InBlendOption, const class UCurveFloat* InCustomBlendCurve);
	static void SetBoneTranslation(const class FName BoneName, const struct FVector& Translation, class UObject* Target, const float InBlendTime, const EAlphaBlendOption InBlendOption, const class UCurveFloat* InCustomBlendCurve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneModBlueprintLibrary">();
	}
	static class UBoneModBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneModBlueprintLibrary>();
	}
};
static_assert(alignof(UBoneModBlueprintLibrary) == 0x000008, "Wrong alignment on UBoneModBlueprintLibrary");
static_assert(sizeof(UBoneModBlueprintLibrary) == 0x000028, "Wrong size on UBoneModBlueprintLibrary");

// Class GbxGameSystemCore.BoneModComponent
// 0x0050 (0x0320 - 0x02D0)
class UBoneModComponent final : public USceneComponent
{
public:
	bool                                          bUseTranslation;                                   // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             TranslationSpace;                                  // 0x02D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceTranslation;                               // 0x02D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotation;                                      // 0x02D3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             RotationSpace;                                     // 0x02D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceRotation;                                  // 0x02D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x02D6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceScale;                                     // 0x02D7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            Blend;                                             // 0x02D8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStartActive;                                      // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0xF];                                      // 0x0311(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneModComponent">();
	}
	static class UBoneModComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneModComponent>();
	}
};
static_assert(alignof(UBoneModComponent) == 0x000008, "Wrong alignment on UBoneModComponent");
static_assert(sizeof(UBoneModComponent) == 0x000320, "Wrong size on UBoneModComponent");
static_assert(offsetof(UBoneModComponent, bUseTranslation) == 0x0002D0, "Member 'UBoneModComponent::bUseTranslation' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, TranslationSpace) == 0x0002D1, "Member 'UBoneModComponent::TranslationSpace' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, bReplaceTranslation) == 0x0002D2, "Member 'UBoneModComponent::bReplaceTranslation' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, bUseRotation) == 0x0002D3, "Member 'UBoneModComponent::bUseRotation' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, RotationSpace) == 0x0002D4, "Member 'UBoneModComponent::RotationSpace' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, bReplaceRotation) == 0x0002D5, "Member 'UBoneModComponent::bReplaceRotation' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, bUseScale) == 0x0002D6, "Member 'UBoneModComponent::bUseScale' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, bReplaceScale) == 0x0002D7, "Member 'UBoneModComponent::bReplaceScale' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, Blend) == 0x0002D8, "Member 'UBoneModComponent::Blend' has a wrong offset!");
static_assert(offsetof(UBoneModComponent, bStartActive) == 0x000310, "Member 'UBoneModComponent::bStartActive' has a wrong offset!");

// Class GbxGameSystemCore.BTDecorator_GbxCondition
// 0x0008 (0x0070 - 0x0068)
class UBTDecorator_GbxCondition final : public UBTDecorator
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0068(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_GbxCondition">();
	}
	static class UBTDecorator_GbxCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_GbxCondition>();
	}
};
static_assert(alignof(UBTDecorator_GbxCondition) == 0x000008, "Wrong alignment on UBTDecorator_GbxCondition");
static_assert(sizeof(UBTDecorator_GbxCondition) == 0x000070, "Wrong size on UBTDecorator_GbxCondition");
static_assert(offsetof(UBTDecorator_GbxCondition, Condition) == 0x000068, "Member 'UBTDecorator_GbxCondition::Condition' has a wrong offset!");

// Class GbxGameSystemCore.BTTask_PlayGbxAction
// 0x0018 (0x0088 - 0x0070)
class UBTTask_PlayGbxAction final : public UBTTaskNode
{
public:
	TSubclassOf<class UGbxAction>                 ActionClassToPlay;                                 // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxActionComponent*                    CachedActionComponent;                             // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTreeComponent*                 CachedBTComponent;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PlayGbxAction">();
	}
	static class UBTTask_PlayGbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PlayGbxAction>();
	}
};
static_assert(alignof(UBTTask_PlayGbxAction) == 0x000008, "Wrong alignment on UBTTask_PlayGbxAction");
static_assert(sizeof(UBTTask_PlayGbxAction) == 0x000088, "Wrong size on UBTTask_PlayGbxAction");
static_assert(offsetof(UBTTask_PlayGbxAction, ActionClassToPlay) == 0x000070, "Member 'UBTTask_PlayGbxAction::ActionClassToPlay' has a wrong offset!");
static_assert(offsetof(UBTTask_PlayGbxAction, CachedActionComponent) == 0x000078, "Member 'UBTTask_PlayGbxAction::CachedActionComponent' has a wrong offset!");
static_assert(offsetof(UBTTask_PlayGbxAction, CachedBTComponent) == 0x000080, "Member 'UBTTask_PlayGbxAction::CachedBTComponent' has a wrong offset!");

// Class GbxGameSystemCore.ChallengeConditionData
// 0x0020 (0x0050 - 0x0030)
class UChallengeConditionData final : public UGbxDataAsset
{
public:
	class FString                                 Description;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameStatData*                          StatId;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TargetValue;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeConditionData">();
	}
	static class UChallengeConditionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeConditionData>();
	}
};
static_assert(alignof(UChallengeConditionData) == 0x000008, "Wrong alignment on UChallengeConditionData");
static_assert(sizeof(UChallengeConditionData) == 0x000050, "Wrong size on UChallengeConditionData");
static_assert(offsetof(UChallengeConditionData, Description) == 0x000030, "Member 'UChallengeConditionData::Description' has a wrong offset!");
static_assert(offsetof(UChallengeConditionData, StatId) == 0x000040, "Member 'UChallengeConditionData::StatId' has a wrong offset!");
static_assert(offsetof(UChallengeConditionData, TargetValue) == 0x000048, "Member 'UChallengeConditionData::TargetValue' has a wrong offset!");

// Class GbxGameSystemCore.ChallengeLevelParentComponent
// 0x0030 (0x0800 - 0x07D0)
class UChallengeLevelParentComponent : public UChallengeLevelActorComponent
{
public:
	bool                                          bHideIfAssociatedActors;                           // 0x07D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAllAssociatedActorsDestroyed;                    // 0x07D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UChallengeLevelActorComponent*>  AssociatedActors;                                  // 0x07E8(0x0010)(BlueprintVisible, ExportObject, Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F8[0x8];                                      // 0x07F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAssociatedActor(class AActor* AssociatedActor, TSubclassOf<class UChallengeLevelActorComponent> ComponentClass, const struct FVector& RelativeOffset);
	void ClearAssociatedActors();
	void RemoveAssociatedActor(class AActor* AssociatedActor);
	void RemoveAssociatedActorComponent(class UChallengeLevelActorComponent* AssociatedComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeLevelParentComponent">();
	}
	static class UChallengeLevelParentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeLevelParentComponent>();
	}
};
static_assert(alignof(UChallengeLevelParentComponent) == 0x000008, "Wrong alignment on UChallengeLevelParentComponent");
static_assert(sizeof(UChallengeLevelParentComponent) == 0x000800, "Wrong size on UChallengeLevelParentComponent");
static_assert(offsetof(UChallengeLevelParentComponent, bHideIfAssociatedActors) == 0x0007D0, "Member 'UChallengeLevelParentComponent::bHideIfAssociatedActors' has a wrong offset!");
static_assert(offsetof(UChallengeLevelParentComponent, OnAllAssociatedActorsDestroyed) == 0x0007D8, "Member 'UChallengeLevelParentComponent::OnAllAssociatedActorsDestroyed' has a wrong offset!");
static_assert(offsetof(UChallengeLevelParentComponent, AssociatedActors) == 0x0007E8, "Member 'UChallengeLevelParentComponent::AssociatedActors' has a wrong offset!");

// Class GbxGameSystemCore.ChallengeRewardData
// 0x0088 (0x00B8 - 0x0030)
class UChallengeRewardData final : public UGbxDataAsset
{
public:
	class FText                                   RewardName;                                        // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RewardString;                                      // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           AttrInitDef;                                       // 0x0078(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CachedRewardIndex;                                 // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeRewardData">();
	}
	static class UChallengeRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeRewardData>();
	}
};
static_assert(alignof(UChallengeRewardData) == 0x000008, "Wrong alignment on UChallengeRewardData");
static_assert(sizeof(UChallengeRewardData) == 0x0000B8, "Wrong size on UChallengeRewardData");
static_assert(offsetof(UChallengeRewardData, RewardName) == 0x000030, "Member 'UChallengeRewardData::RewardName' has a wrong offset!");
static_assert(offsetof(UChallengeRewardData, Description) == 0x000048, "Member 'UChallengeRewardData::Description' has a wrong offset!");
static_assert(offsetof(UChallengeRewardData, RewardString) == 0x000060, "Member 'UChallengeRewardData::RewardString' has a wrong offset!");
static_assert(offsetof(UChallengeRewardData, AttrInitDef) == 0x000078, "Member 'UChallengeRewardData::AttrInitDef' has a wrong offset!");
static_assert(offsetof(UChallengeRewardData, CachedRewardIndex) == 0x0000B0, "Member 'UChallengeRewardData::CachedRewardIndex' has a wrong offset!");

// Class GbxGameSystemCore.ChallengeSystemSettings
// 0x0070 (0x0098 - 0x0028)
class UChallengeSystemSettings final : public UObject
{
public:
	float                                         MinimumGoalForChallengeNotification;               // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ChallengeCompletionThresholdNotification;          // 0x0030(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           ChallengeRanksForToken;                            // 0x0040(0x0038)(Edit, Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ChallengePointsPerRank;                            // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                ChallengeRewards;                                  // 0x0080(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UChallengesComponent>       DefaultChallengeComponent;                         // 0x0090(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeSystemSettings">();
	}
	static class UChallengeSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeSystemSettings>();
	}
};
static_assert(alignof(UChallengeSystemSettings) == 0x000008, "Wrong alignment on UChallengeSystemSettings");
static_assert(sizeof(UChallengeSystemSettings) == 0x000098, "Wrong size on UChallengeSystemSettings");
static_assert(offsetof(UChallengeSystemSettings, MinimumGoalForChallengeNotification) == 0x000028, "Member 'UChallengeSystemSettings::MinimumGoalForChallengeNotification' has a wrong offset!");
static_assert(offsetof(UChallengeSystemSettings, ChallengeCompletionThresholdNotification) == 0x000030, "Member 'UChallengeSystemSettings::ChallengeCompletionThresholdNotification' has a wrong offset!");
static_assert(offsetof(UChallengeSystemSettings, ChallengeRanksForToken) == 0x000040, "Member 'UChallengeSystemSettings::ChallengeRanksForToken' has a wrong offset!");
static_assert(offsetof(UChallengeSystemSettings, ChallengePointsPerRank) == 0x000078, "Member 'UChallengeSystemSettings::ChallengePointsPerRank' has a wrong offset!");
static_assert(offsetof(UChallengeSystemSettings, ChallengeRewards) == 0x000080, "Member 'UChallengeSystemSettings::ChallengeRewards' has a wrong offset!");
static_assert(offsetof(UChallengeSystemSettings, DefaultChallengeComponent) == 0x000090, "Member 'UChallengeSystemSettings::DefaultChallengeComponent' has a wrong offset!");

// Class GbxGameSystemCore.CharacterBestTargetAttributeContextResolver
// 0x0000 (0x0050 - 0x0050)
class UCharacterBestTargetAttributeContextResolver final : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBestTargetAttributeContextResolver">();
	}
	static class UCharacterBestTargetAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBestTargetAttributeContextResolver>();
	}
};
static_assert(alignof(UCharacterBestTargetAttributeContextResolver) == 0x000008, "Wrong alignment on UCharacterBestTargetAttributeContextResolver");
static_assert(sizeof(UCharacterBestTargetAttributeContextResolver) == 0x000050, "Wrong size on UCharacterBestTargetAttributeContextResolver");

// Class GbxGameSystemCore.CinematicModeBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UCinematicModeBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearAndSetCinematicMode(class UObject* WorldContextObject, class UCinematicModeData* InCinematicMode);
	static void ClearCinematicMode(class UObject* WorldContextObject);
	static void PopCinematicMode(class UObject* WorldContextObject, class UCinematicModeData* InCinematicMode);
	static void PushCinematicMode(class UObject* WorldContextObject, class UCinematicModeData* InCinematicMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicModeBlueprintLibrary">();
	}
	static class UCinematicModeBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicModeBlueprintLibrary>();
	}
};
static_assert(alignof(UCinematicModeBlueprintLibrary) == 0x000008, "Wrong alignment on UCinematicModeBlueprintLibrary");
static_assert(sizeof(UCinematicModeBlueprintLibrary) == 0x000028, "Wrong size on UCinematicModeBlueprintLibrary");

// Class GbxGameSystemCore.ConditionalDamageHitRegionModifier
// 0x0010 (0x0148 - 0x0138)
class UConditionalDamageHitRegionModifier final : public UConditionalDamageModifier
{
public:
	uint32                                        Priority;                                          // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitRegionData*                         OverrideHitRegion;                                 // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalDamageHitRegionModifier">();
	}
	static class UConditionalDamageHitRegionModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalDamageHitRegionModifier>();
	}
};
static_assert(alignof(UConditionalDamageHitRegionModifier) == 0x000008, "Wrong alignment on UConditionalDamageHitRegionModifier");
static_assert(sizeof(UConditionalDamageHitRegionModifier) == 0x000148, "Wrong size on UConditionalDamageHitRegionModifier");
static_assert(offsetof(UConditionalDamageHitRegionModifier, Priority) == 0x000138, "Member 'UConditionalDamageHitRegionModifier::Priority' has a wrong offset!");
static_assert(offsetof(UConditionalDamageHitRegionModifier, OverrideHitRegion) == 0x000140, "Member 'UConditionalDamageHitRegionModifier::OverrideHitRegion' has a wrong offset!");

// Class GbxGameSystemCore.ConditionalDamageTypeModifier
// 0x00A0 (0x01D8 - 0x0138)
class UConditionalDamageTypeModifier final : public UConditionalDamageModifier
{
public:
	TSubclassOf<class UGbxDamageType>             OverrideDamageType;                                // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConditionalDamageDamageTypeConditional> ConditionalDamageTypes;                            // 0x0140(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              OptionalOverrideDamageSource;                      // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConditionalDamageTypeBonusMode               BonusMode;                                         // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ExtraDamagePercent;                                // 0x0160(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           OverridePrimaryDamageTypeScale;                    // 0x0198(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalDamageTypeModifier">();
	}
	static class UConditionalDamageTypeModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalDamageTypeModifier>();
	}
};
static_assert(alignof(UConditionalDamageTypeModifier) == 0x000008, "Wrong alignment on UConditionalDamageTypeModifier");
static_assert(sizeof(UConditionalDamageTypeModifier) == 0x0001D8, "Wrong size on UConditionalDamageTypeModifier");
static_assert(offsetof(UConditionalDamageTypeModifier, OverrideDamageType) == 0x000138, "Member 'UConditionalDamageTypeModifier::OverrideDamageType' has a wrong offset!");
static_assert(offsetof(UConditionalDamageTypeModifier, ConditionalDamageTypes) == 0x000140, "Member 'UConditionalDamageTypeModifier::ConditionalDamageTypes' has a wrong offset!");
static_assert(offsetof(UConditionalDamageTypeModifier, OptionalOverrideDamageSource) == 0x000150, "Member 'UConditionalDamageTypeModifier::OptionalOverrideDamageSource' has a wrong offset!");
static_assert(offsetof(UConditionalDamageTypeModifier, BonusMode) == 0x000158, "Member 'UConditionalDamageTypeModifier::BonusMode' has a wrong offset!");
static_assert(offsetof(UConditionalDamageTypeModifier, ExtraDamagePercent) == 0x000160, "Member 'UConditionalDamageTypeModifier::ExtraDamagePercent' has a wrong offset!");
static_assert(offsetof(UConditionalDamageTypeModifier, OverridePrimaryDamageTypeScale) == 0x000198, "Member 'UConditionalDamageTypeModifier::OverridePrimaryDamageTypeScale' has a wrong offset!");
static_assert(offsetof(UConditionalDamageTypeModifier, Priority) == 0x0001D0, "Member 'UConditionalDamageTypeModifier::Priority' has a wrong offset!");

// Class GbxGameSystemCore.ConditionalDamageValueModifier
// 0x00D8 (0x0210 - 0x0138)
class UConditionalDamageValueModifier final : public UConditionalDamageModifier
{
public:
	EConditionalDamageModifierType                ModifierType;                                      // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageValue;                                       // 0x0140(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConditionalDamageDamageConditionalValue> ConditionalDamageValues;                           // 0x0178(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bModifyValueBasedOnDistance;                       // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ModifyValueBasedOnDistanceCurve;                   // 0x0190(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bDisallowFatalDamage;                              // 0x0208(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalDamageValueModifier">();
	}
	static class UConditionalDamageValueModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalDamageValueModifier>();
	}
};
static_assert(alignof(UConditionalDamageValueModifier) == 0x000008, "Wrong alignment on UConditionalDamageValueModifier");
static_assert(sizeof(UConditionalDamageValueModifier) == 0x000210, "Wrong size on UConditionalDamageValueModifier");
static_assert(offsetof(UConditionalDamageValueModifier, ModifierType) == 0x000138, "Member 'UConditionalDamageValueModifier::ModifierType' has a wrong offset!");
static_assert(offsetof(UConditionalDamageValueModifier, DamageValue) == 0x000140, "Member 'UConditionalDamageValueModifier::DamageValue' has a wrong offset!");
static_assert(offsetof(UConditionalDamageValueModifier, ConditionalDamageValues) == 0x000178, "Member 'UConditionalDamageValueModifier::ConditionalDamageValues' has a wrong offset!");
static_assert(offsetof(UConditionalDamageValueModifier, bModifyValueBasedOnDistance) == 0x000188, "Member 'UConditionalDamageValueModifier::bModifyValueBasedOnDistance' has a wrong offset!");
static_assert(offsetof(UConditionalDamageValueModifier, ModifyValueBasedOnDistanceCurve) == 0x000190, "Member 'UConditionalDamageValueModifier::ModifyValueBasedOnDistanceCurve' has a wrong offset!");
static_assert(offsetof(UConditionalDamageValueModifier, bDisallowFatalDamage) == 0x000208, "Member 'UConditionalDamageValueModifier::bDisallowFatalDamage' has a wrong offset!");

// Class GbxGameSystemCore.ConstantAttributeValueResolver
// 0x0038 (0x0060 - 0x0028)
class UConstantAttributeValueResolver final : public UAttributeValueResolver
{
public:
	struct FAttributeInitializationData           Value;                                             // 0x0028(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstantAttributeValueResolver">();
	}
	static class UConstantAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstantAttributeValueResolver>();
	}
};
static_assert(alignof(UConstantAttributeValueResolver) == 0x000008, "Wrong alignment on UConstantAttributeValueResolver");
static_assert(sizeof(UConstantAttributeValueResolver) == 0x000060, "Wrong size on UConstantAttributeValueResolver");
static_assert(offsetof(UConstantAttributeValueResolver, Value) == 0x000028, "Member 'UConstantAttributeValueResolver::Value' has a wrong offset!");

// Class GbxGameSystemCore.ControlledMoveFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UControlledMoveFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsPerformingControlledMove(class AActor* Actor);
	static bool IsPerformingSpecificControlledMove(class AActor* Actor, TSubclassOf<class UControlledMove> ControlledMove);
	static bool StartControlledMove(class AActor* Actor, TSubclassOf<class UControlledMove> ControlledMove, class AActor* Instigator, float SpeedOverride, float DurationOverride, float LaunchAngleOverride, class AActor* TargetActor, const struct FVector& TargetLocation);
	static void StopControlledMove(class AActor* Actor, TSubclassOf<class UControlledMove> ControlledMove, bool bZeroVelocity, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlledMoveFunctionLibrary">();
	}
	static class UControlledMoveFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlledMoveFunctionLibrary>();
	}
};
static_assert(alignof(UControlledMoveFunctionLibrary) == 0x000008, "Wrong alignment on UControlledMoveFunctionLibrary");
static_assert(sizeof(UControlledMoveFunctionLibrary) == 0x000028, "Wrong size on UControlledMoveFunctionLibrary");

// Class GbxGameSystemCore.ControllerAttributeContextResolver
// 0x0000 (0x0050 - 0x0050)
class UControllerAttributeContextResolver final : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerAttributeContextResolver">();
	}
	static class UControllerAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerAttributeContextResolver>();
	}
};
static_assert(alignof(UControllerAttributeContextResolver) == 0x000008, "Wrong alignment on UControllerAttributeContextResolver");
static_assert(sizeof(UControllerAttributeContextResolver) == 0x000050, "Wrong size on UControllerAttributeContextResolver");

// Class GbxGameSystemCore.DamageableInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageableInterface">();
	}
	static class IDamageableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageableInterface>();
	}
};
static_assert(alignof(IDamageableInterface) == 0x000008, "Wrong alignment on IDamageableInterface");
static_assert(sizeof(IDamageableInterface) == 0x000028, "Wrong size on IDamageableInterface");

// Class GbxGameSystemCore.DamageAreaType_BaseRound
// 0x0040 (0x00A0 - 0x0060)
class UDamageAreaType_BaseRound : public UDamageAreaType
{
public:
	struct FAttributeInitializationData           Radius;                                            // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bComputeHitDirectionFromTarget;                    // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpandRadiusOverTime;                             // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExpandingRadiusIsHollow;                          // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType_BaseRound">();
	}
	static class UDamageAreaType_BaseRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType_BaseRound>();
	}
};
static_assert(alignof(UDamageAreaType_BaseRound) == 0x000008, "Wrong alignment on UDamageAreaType_BaseRound");
static_assert(sizeof(UDamageAreaType_BaseRound) == 0x0000A0, "Wrong size on UDamageAreaType_BaseRound");
static_assert(offsetof(UDamageAreaType_BaseRound, Radius) == 0x000060, "Member 'UDamageAreaType_BaseRound::Radius' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_BaseRound, bComputeHitDirectionFromTarget) == 0x000098, "Member 'UDamageAreaType_BaseRound::bComputeHitDirectionFromTarget' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_BaseRound, bExpandRadiusOverTime) == 0x000099, "Member 'UDamageAreaType_BaseRound::bExpandRadiusOverTime' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_BaseRound, bExpandingRadiusIsHollow) == 0x00009A, "Member 'UDamageAreaType_BaseRound::bExpandingRadiusIsHollow' has a wrong offset!");

// Class GbxGameSystemCore.DamageAreaType_Sphere
// 0x0008 (0x00A8 - 0x00A0)
class UDamageAreaType_Sphere final : public UDamageAreaType_BaseRound
{
public:
	bool                                          bTreatAsRadiusDamage;                              // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamageFallsOff;                                   // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType_Sphere">();
	}
	static class UDamageAreaType_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType_Sphere>();
	}
};
static_assert(alignof(UDamageAreaType_Sphere) == 0x000008, "Wrong alignment on UDamageAreaType_Sphere");
static_assert(sizeof(UDamageAreaType_Sphere) == 0x0000A8, "Wrong size on UDamageAreaType_Sphere");
static_assert(offsetof(UDamageAreaType_Sphere, bTreatAsRadiusDamage) == 0x0000A0, "Member 'UDamageAreaType_Sphere::bTreatAsRadiusDamage' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Sphere, bDamageFallsOff) == 0x0000A1, "Member 'UDamageAreaType_Sphere::bDamageFallsOff' has a wrong offset!");

// Class GbxGameSystemCore.DamageAreaType_Cylinder
// 0x00A8 (0x0148 - 0x00A0)
class UDamageAreaType_Cylinder final : public UDamageAreaType_BaseRound
{
public:
	struct FAttributeInitializationData           HalfHeight;                                        // 0x00A0(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           HeightOffset;                                      // 0x00D8(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           WedgeAngle;                                        // 0x0110(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType_Cylinder">();
	}
	static class UDamageAreaType_Cylinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType_Cylinder>();
	}
};
static_assert(alignof(UDamageAreaType_Cylinder) == 0x000008, "Wrong alignment on UDamageAreaType_Cylinder");
static_assert(sizeof(UDamageAreaType_Cylinder) == 0x000148, "Wrong size on UDamageAreaType_Cylinder");
static_assert(offsetof(UDamageAreaType_Cylinder, HalfHeight) == 0x0000A0, "Member 'UDamageAreaType_Cylinder::HalfHeight' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Cylinder, HeightOffset) == 0x0000D8, "Member 'UDamageAreaType_Cylinder::HeightOffset' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Cylinder, WedgeAngle) == 0x000110, "Member 'UDamageAreaType_Cylinder::WedgeAngle' has a wrong offset!");

// Class GbxGameSystemCore.DamageAreaType_Cone
// 0x0070 (0x00D0 - 0x0060)
class UDamageAreaType_Cone final : public UDamageAreaType
{
public:
	struct FAttributeInitializationData           Length;                                            // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           ConeAngle;                                         // 0x0098(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType_Cone">();
	}
	static class UDamageAreaType_Cone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType_Cone>();
	}
};
static_assert(alignof(UDamageAreaType_Cone) == 0x000008, "Wrong alignment on UDamageAreaType_Cone");
static_assert(sizeof(UDamageAreaType_Cone) == 0x0000D0, "Wrong size on UDamageAreaType_Cone");
static_assert(offsetof(UDamageAreaType_Cone, Length) == 0x000060, "Member 'UDamageAreaType_Cone::Length' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Cone, ConeAngle) == 0x000098, "Member 'UDamageAreaType_Cone::ConeAngle' has a wrong offset!");

// Class GbxGameSystemCore.DamageAreaType_Capsule
// 0x0070 (0x00D0 - 0x0060)
class UDamageAreaType_Capsule final : public UDamageAreaType
{
public:
	struct FAttributeInitializationData           HalfHeight;                                        // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Radius;                                            // 0x0098(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAreaType_Capsule">();
	}
	static class UDamageAreaType_Capsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAreaType_Capsule>();
	}
};
static_assert(alignof(UDamageAreaType_Capsule) == 0x000008, "Wrong alignment on UDamageAreaType_Capsule");
static_assert(sizeof(UDamageAreaType_Capsule) == 0x0000D0, "Wrong size on UDamageAreaType_Capsule");
static_assert(offsetof(UDamageAreaType_Capsule, HalfHeight) == 0x000060, "Member 'UDamageAreaType_Capsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(UDamageAreaType_Capsule, Radius) == 0x000098, "Member 'UDamageAreaType_Capsule::Radius' has a wrong offset!");

// Class GbxGameSystemCore.DamageAsyncManager
// 0x0038 (0x0060 - 0x0028)
class UDamageAsyncManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCauseDamageAsyncRequestEntry>  CauseDamageRequests;                               // 0x0038(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FCauseDamageAsyncRequestEntry>  PendingCauseDamageRequests;                        // 0x0048(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         MaxNumCauseDamagePerFrame;                         // 0x0058(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAsyncManager">();
	}
	static class UDamageAsyncManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAsyncManager>();
	}
};
static_assert(alignof(UDamageAsyncManager) == 0x000008, "Wrong alignment on UDamageAsyncManager");
static_assert(sizeof(UDamageAsyncManager) == 0x000060, "Wrong size on UDamageAsyncManager");
static_assert(offsetof(UDamageAsyncManager, CauseDamageRequests) == 0x000038, "Member 'UDamageAsyncManager::CauseDamageRequests' has a wrong offset!");
static_assert(offsetof(UDamageAsyncManager, PendingCauseDamageRequests) == 0x000048, "Member 'UDamageAsyncManager::PendingCauseDamageRequests' has a wrong offset!");
static_assert(offsetof(UDamageAsyncManager, MaxNumCauseDamagePerFrame) == 0x000058, "Member 'UDamageAsyncManager::MaxNumCauseDamagePerFrame' has a wrong offset!");

// Class GbxGameSystemCore.DamageCauserInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageCauserInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCauserInterface">();
	}
	static class IDamageCauserInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageCauserInterface>();
	}
};
static_assert(alignof(IDamageCauserInterface) == 0x000008, "Wrong alignment on IDamageCauserInterface");
static_assert(sizeof(IDamageCauserInterface) == 0x000028, "Wrong size on IDamageCauserInterface");

// Class GbxGameSystemCore.DamageStatics
// 0x0000 (0x0028 - 0x0028)
class UDamageStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyDamage(class AActor* DamageReceiver, float BaseDamage, TSubclassOf<class UGbxDamageType> DamageType, TSubclassOf<class UDamageSource> DamageSource, class AController* EventInstigator, class AActor* DamageCauser);
	static void ApplyDamageEx(const struct FPipelineDamageInput& PipelineInput, float BaseDamage);
	static void ApplyDamageInRadius(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float Radius, TSubclassOf<class UGbxDamageType> DamageType, TSubclassOf<class UDamageSource> DamageSource, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* EventInstigator, const struct FForceSelection& BaseImpactForce, ECollisionChannel DamagePreventionChannel, bool bDamageFalloff, class UDamageModifierComponent* DamageModifierComponent, class UFeedbackData* InstigatorFeedback, bool bUseInstigatorRadiusDamageScale);
	static struct FForceSelection Conv_FloatToForceSelection(float ForceSelection);
	static float Conv_ForceSelectionToFloat(const struct FForceSelection& ForceSelection);
	static const class UDamageSource* GetDamageSourceFromClass(TSubclassOf<class UDamageSource> DamageSourceClass);
	static const class UGbxDamageType* GetDamageTypeFromClass(TSubclassOf<class UGbxDamageType> DamageTypeClass);
	static class FString GetSummary_ForceSelection(const struct FForceSelection& ForceSelection);
	static struct FPipelineDamageInput MakePipelineDamageInput(class AActor* DamageCauser, class AActor* DamageReceiver, TSubclassOf<class UGbxDamageType> DamageType, TSubclassOf<class UDamageSource> DamageSource, const struct FHitResult& HitInfo, const struct FVector& HitLocation, const struct FVector& HitDirection, const struct FVector& HitForceDirection, const struct FForceSelection& HitForceMagnitude);
	static void StopCausingAllDamage(class AActor* DamageCauser);
	static void StopCausingDamage(class AActor* DamageCauser, TSubclassOf<class UDamageData> DamageData);
	static void StopCausingDamageToTarget(class AActor* DamageCauser, class AActor* DamageTarget, TSubclassOf<class UDamageData> DamageData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageStatics">();
	}
	static class UDamageStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageStatics>();
	}
};
static_assert(alignof(UDamageStatics) == 0x000008, "Wrong alignment on UDamageStatics");
static_assert(sizeof(UDamageStatics) == 0x000028, "Wrong size on UDamageStatics");

// Class GbxGameSystemCore.DeathData
// 0x0018 (0x0048 - 0x0030)
class UDeathData final : public UGbxDataAsset
{
public:
	TArray<class UGameStatData*>                  DiedStats;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DissolveCorpseDelayBeforeDestroy;                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathData">();
	}
	static class UDeathData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathData>();
	}
};
static_assert(alignof(UDeathData) == 0x000008, "Wrong alignment on UDeathData");
static_assert(sizeof(UDeathData) == 0x000048, "Wrong size on UDeathData");
static_assert(offsetof(UDeathData, DiedStats) == 0x000030, "Member 'UDeathData::DiedStats' has a wrong offset!");
static_assert(offsetof(UDeathData, DissolveCorpseDelayBeforeDestroy) == 0x000040, "Member 'UDeathData::DissolveCorpseDelayBeforeDestroy' has a wrong offset!");

// Class GbxGameSystemCore.Decorator
// 0x0000 (0x0458 - 0x0458)
class ADecorator : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Decorator">();
	}
	static class ADecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADecorator>();
	}
};
static_assert(alignof(ADecorator) == 0x000008, "Wrong alignment on ADecorator");
static_assert(sizeof(ADecorator) == 0x000458, "Wrong size on ADecorator");

// Class GbxGameSystemCore.DrunkenWaveMovementComponent
// 0x0038 (0x01F0 - 0x01B8)
class UDrunkenWaveMovementComponent final : public UDrunkenBaseMovementComponent
{
public:
	TArray<struct FVector2DWaveform>              Waveforms;                                         // 0x01B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GlobalWaveformScale;                               // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRandomWaveOffsetTime;                           // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravityAffectsDrunkenness;                        // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrunkenGravityScalar;                              // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x18];                                     // 0x01D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrunkenWaveMovementComponent">();
	}
	static class UDrunkenWaveMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrunkenWaveMovementComponent>();
	}
};
static_assert(alignof(UDrunkenWaveMovementComponent) == 0x000008, "Wrong alignment on UDrunkenWaveMovementComponent");
static_assert(sizeof(UDrunkenWaveMovementComponent) == 0x0001F0, "Wrong size on UDrunkenWaveMovementComponent");
static_assert(offsetof(UDrunkenWaveMovementComponent, Waveforms) == 0x0001B8, "Member 'UDrunkenWaveMovementComponent::Waveforms' has a wrong offset!");
static_assert(offsetof(UDrunkenWaveMovementComponent, GlobalWaveformScale) == 0x0001C8, "Member 'UDrunkenWaveMovementComponent::GlobalWaveformScale' has a wrong offset!");
static_assert(offsetof(UDrunkenWaveMovementComponent, MaxRandomWaveOffsetTime) == 0x0001CC, "Member 'UDrunkenWaveMovementComponent::MaxRandomWaveOffsetTime' has a wrong offset!");
static_assert(offsetof(UDrunkenWaveMovementComponent, bGravityAffectsDrunkenness) == 0x0001D0, "Member 'UDrunkenWaveMovementComponent::bGravityAffectsDrunkenness' has a wrong offset!");
static_assert(offsetof(UDrunkenWaveMovementComponent, DrunkenGravityScalar) == 0x0001D4, "Member 'UDrunkenWaveMovementComponent::DrunkenGravityScalar' has a wrong offset!");

// Class GbxGameSystemCore.DynamicPhysicalAnimationComponent
// 0x01D8 (0x0350 - 0x0178)
class UDynamicPhysicalAnimationComponent final : public UActorComponent
{
public:
	class FName                                   PhysicalAnimationCollisionProfileName;             // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KinematicAnimationCollisionProfileName;            // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExclusionBones;                                    // 0x0188(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SupportBones;                                      // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x188];                                    // 0x01A8(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasPhysicallyAnimatingBones;                      // 0x0340(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341[0xF];                                      // 0x0341(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachBodyTo(class FName BodyName, class UPrimitiveComponent* AttachToComponent, class FName AttachToBodyName, float VelocitySpaceBlend, float BreakForce);
	void DetachBodyFromAllExternalRigidBodies(class FName BodyName);
	float GetStrengthMultiplier();
	void OnRigidBodyOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SetActiveProfile(const class UPhysicalAnimationProfileAsset* Profile);
	void SetEnablePhysicalAnimation(bool bEnable, class FName BodyName);
	void SetEnableRagdoll(bool bEnable);
	void SetHasAnimationPlaying(bool bPlaying);
	void SetRootMotionControl(EPhysicalAnimationRootMotionControl MotionControl);
	void SetSkeletalMeshComponent(class USkeletalMeshComponent* NewSkeletalMeshComponent);
	void SetStrengthMultiplier(float NewValue);

	EPhysicalAnimationRootMotionControl GetRootMotionControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicPhysicalAnimationComponent">();
	}
	static class UDynamicPhysicalAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicPhysicalAnimationComponent>();
	}
};
static_assert(alignof(UDynamicPhysicalAnimationComponent) == 0x000008, "Wrong alignment on UDynamicPhysicalAnimationComponent");
static_assert(sizeof(UDynamicPhysicalAnimationComponent) == 0x000350, "Wrong size on UDynamicPhysicalAnimationComponent");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, PhysicalAnimationCollisionProfileName) == 0x000178, "Member 'UDynamicPhysicalAnimationComponent::PhysicalAnimationCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, KinematicAnimationCollisionProfileName) == 0x000180, "Member 'UDynamicPhysicalAnimationComponent::KinematicAnimationCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, ExclusionBones) == 0x000188, "Member 'UDynamicPhysicalAnimationComponent::ExclusionBones' has a wrong offset!");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, SupportBones) == 0x000198, "Member 'UDynamicPhysicalAnimationComponent::SupportBones' has a wrong offset!");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, SkeletalMeshComponent) == 0x000330, "Member 'UDynamicPhysicalAnimationComponent::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, PhysicsAsset) == 0x000338, "Member 'UDynamicPhysicalAnimationComponent::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UDynamicPhysicalAnimationComponent, bHasPhysicallyAnimatingBones) == 0x000340, "Member 'UDynamicPhysicalAnimationComponent::bHasPhysicallyAnimatingBones' has a wrong offset!");

// Class GbxGameSystemCore.EnvQueryContext_AimStart
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_AimStart final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_AimStart">();
	}
	static class UEnvQueryContext_AimStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_AimStart>();
	}
};
static_assert(alignof(UEnvQueryContext_AimStart) == 0x000008, "Wrong alignment on UEnvQueryContext_AimStart");
static_assert(sizeof(UEnvQueryContext_AimStart) == 0x000028, "Wrong size on UEnvQueryContext_AimStart");

// Class GbxGameSystemCore.EnvQueryContext_AimEnd
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_AimEnd final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_AimEnd">();
	}
	static class UEnvQueryContext_AimEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_AimEnd>();
	}
};
static_assert(alignof(UEnvQueryContext_AimEnd) == 0x000008, "Wrong alignment on UEnvQueryContext_AimEnd");
static_assert(sizeof(UEnvQueryContext_AimEnd) == 0x000028, "Wrong size on UEnvQueryContext_AimEnd");

// Class GbxGameSystemCore.EnvQueryContext_Owner_AimStart
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_Owner_AimStart final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Owner_AimStart">();
	}
	static class UEnvQueryContext_Owner_AimStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Owner_AimStart>();
	}
};
static_assert(alignof(UEnvQueryContext_Owner_AimStart) == 0x000008, "Wrong alignment on UEnvQueryContext_Owner_AimStart");
static_assert(sizeof(UEnvQueryContext_Owner_AimStart) == 0x000028, "Wrong size on UEnvQueryContext_Owner_AimStart");

// Class GbxGameSystemCore.EnvQueryContext_Owner_AimEnd
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_Owner_AimEnd final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Owner_AimEnd">();
	}
	static class UEnvQueryContext_Owner_AimEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Owner_AimEnd>();
	}
};
static_assert(alignof(UEnvQueryContext_Owner_AimEnd) == 0x000008, "Wrong alignment on UEnvQueryContext_Owner_AimEnd");
static_assert(sizeof(UEnvQueryContext_Owner_AimEnd) == 0x000028, "Wrong size on UEnvQueryContext_Owner_AimEnd");

// Class GbxGameSystemCore.EnvQueryContext_LastResult
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_LastResult final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_LastResult">();
	}
	static class UEnvQueryContext_LastResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_LastResult>();
	}
};
static_assert(alignof(UEnvQueryContext_LastResult) == 0x000008, "Wrong alignment on UEnvQueryContext_LastResult");
static_assert(sizeof(UEnvQueryContext_LastResult) == 0x000028, "Wrong size on UEnvQueryContext_LastResult");

// Class GbxGameSystemCore.EnvQueryContext_Origin
// 0x0000 (0x0038 - 0x0038)
class UEnvQueryContext_Origin final : public UEnvQueryContext_EnvQueryParam
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Origin">();
	}
	static class UEnvQueryContext_Origin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Origin>();
	}
};
static_assert(alignof(UEnvQueryContext_Origin) == 0x000008, "Wrong alignment on UEnvQueryContext_Origin");
static_assert(sizeof(UEnvQueryContext_Origin) == 0x000038, "Wrong size on UEnvQueryContext_Origin");

// Class GbxGameSystemCore.EnvQueryContext_PlayerMaster
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_PlayerMaster final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_PlayerMaster">();
	}
	static class UEnvQueryContext_PlayerMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_PlayerMaster>();
	}
};
static_assert(alignof(UEnvQueryContext_PlayerMaster) == 0x000008, "Wrong alignment on UEnvQueryContext_PlayerMaster");
static_assert(sizeof(UEnvQueryContext_PlayerMaster) == 0x000028, "Wrong size on UEnvQueryContext_PlayerMaster");

// Class GbxGameSystemCore.EnvQueryContext_Players
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_Players final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Players">();
	}
	static class UEnvQueryContext_Players* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Players>();
	}
};
static_assert(alignof(UEnvQueryContext_Players) == 0x000008, "Wrong alignment on UEnvQueryContext_Players");
static_assert(sizeof(UEnvQueryContext_Players) == 0x000028, "Wrong size on UEnvQueryContext_Players");

// Class GbxGameSystemCore.EnvQueryContext_QuerierAimDirection
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_QuerierAimDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_QuerierAimDirection">();
	}
	static class UEnvQueryContext_QuerierAimDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_QuerierAimDirection>();
	}
};
static_assert(alignof(UEnvQueryContext_QuerierAimDirection) == 0x000008, "Wrong alignment on UEnvQueryContext_QuerierAimDirection");
static_assert(sizeof(UEnvQueryContext_QuerierAimDirection) == 0x000028, "Wrong size on UEnvQueryContext_QuerierAimDirection");

// Class GbxGameSystemCore.EnvQueryContext_QuerierAimDirection2D
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_QuerierAimDirection2D final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_QuerierAimDirection2D">();
	}
	static class UEnvQueryContext_QuerierAimDirection2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_QuerierAimDirection2D>();
	}
};
static_assert(alignof(UEnvQueryContext_QuerierAimDirection2D) == 0x000008, "Wrong alignment on UEnvQueryContext_QuerierAimDirection2D");
static_assert(sizeof(UEnvQueryContext_QuerierAimDirection2D) == 0x000028, "Wrong size on UEnvQueryContext_QuerierAimDirection2D");

// Class GbxGameSystemCore.EnvQueryContext_QuerierAimLocation
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_QuerierAimLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_QuerierAimLocation">();
	}
	static class UEnvQueryContext_QuerierAimLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_QuerierAimLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_QuerierAimLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_QuerierAimLocation");
static_assert(sizeof(UEnvQueryContext_QuerierAimLocation) == 0x000028, "Wrong size on UEnvQueryContext_QuerierAimLocation");

// Class GbxGameSystemCore.EnvQueryContext_QuerierMoveDirection
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_QuerierMoveDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_QuerierMoveDirection">();
	}
	static class UEnvQueryContext_QuerierMoveDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_QuerierMoveDirection>();
	}
};
static_assert(alignof(UEnvQueryContext_QuerierMoveDirection) == 0x000008, "Wrong alignment on UEnvQueryContext_QuerierMoveDirection");
static_assert(sizeof(UEnvQueryContext_QuerierMoveDirection) == 0x000028, "Wrong size on UEnvQueryContext_QuerierMoveDirection");

// Class GbxGameSystemCore.EnvQueryContext_TargetNavLocation
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_TargetNavLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_TargetNavLocation">();
	}
	static class UEnvQueryContext_TargetNavLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_TargetNavLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_TargetNavLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_TargetNavLocation");
static_assert(sizeof(UEnvQueryContext_TargetNavLocation) == 0x000028, "Wrong size on UEnvQueryContext_TargetNavLocation");

// Class GbxGameSystemCore.EnvQueryGenerator_TargetActorInfo
// 0x0048 (0x00A8 - 0x0060)
class UEnvQueryGenerator_TargetActorInfo final : public UEnvQueryGenerator
{
public:
	float                                         MaxAge;                                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHostiles;                                    // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFriendlies;                                  // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNeutrals;                                    // 0x0066(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActorTagCompositeQuery                TagQuery;                                          // 0x0068(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bUseAllowedTypes : 1;                              // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           AllowedTypes;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         AllowedTypesCache;                                 // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_TargetActorInfo">();
	}
	static class UEnvQueryGenerator_TargetActorInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_TargetActorInfo>();
	}
};
static_assert(alignof(UEnvQueryGenerator_TargetActorInfo) == 0x000008, "Wrong alignment on UEnvQueryGenerator_TargetActorInfo");
static_assert(sizeof(UEnvQueryGenerator_TargetActorInfo) == 0x0000A8, "Wrong size on UEnvQueryGenerator_TargetActorInfo");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, MaxAge) == 0x000060, "Member 'UEnvQueryGenerator_TargetActorInfo::MaxAge' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, bAllowHostiles) == 0x000064, "Member 'UEnvQueryGenerator_TargetActorInfo::bAllowHostiles' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, bAllowFriendlies) == 0x000065, "Member 'UEnvQueryGenerator_TargetActorInfo::bAllowFriendlies' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, bAllowNeutrals) == 0x000066, "Member 'UEnvQueryGenerator_TargetActorInfo::bAllowNeutrals' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, TagQuery) == 0x000068, "Member 'UEnvQueryGenerator_TargetActorInfo::TagQuery' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, AllowedTypes) == 0x000080, "Member 'UEnvQueryGenerator_TargetActorInfo::AllowedTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_TargetActorInfo, AllowedTypesCache) == 0x000090, "Member 'UEnvQueryGenerator_TargetActorInfo::AllowedTypesCache' has a wrong offset!");

// Class GbxGameSystemCore.EnvQueryItemType_Targetable
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryItemType_Targetable final : public UEnvQueryItemType_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryItemType_Targetable">();
	}
	static class UEnvQueryItemType_Targetable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryItemType_Targetable>();
	}
};
static_assert(alignof(UEnvQueryItemType_Targetable) == 0x000008, "Wrong alignment on UEnvQueryItemType_Targetable");
static_assert(sizeof(UEnvQueryItemType_Targetable) == 0x000030, "Wrong size on UEnvQueryItemType_Targetable");

// Class GbxGameSystemCore.EnvQueryItemType_TargetActorInfo
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryItemType_TargetActorInfo final : public UEnvQueryItemType_ActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryItemType_TargetActorInfo">();
	}
	static class UEnvQueryItemType_TargetActorInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryItemType_TargetActorInfo>();
	}
};
static_assert(alignof(UEnvQueryItemType_TargetActorInfo) == 0x000008, "Wrong alignment on UEnvQueryItemType_TargetActorInfo");
static_assert(sizeof(UEnvQueryItemType_TargetActorInfo) == 0x000030, "Wrong size on UEnvQueryItemType_TargetActorInfo");

// Class GbxGameSystemCore.EnvQueryContext_InputTarget
// 0x0000 (0x0038 - 0x0038)
class UEnvQueryContext_InputTarget final : public UEnvQueryContext_EnvQueryParam
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_InputTarget">();
	}
	static class UEnvQueryContext_InputTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_InputTarget>();
	}
};
static_assert(alignof(UEnvQueryContext_InputTarget) == 0x000008, "Wrong alignment on UEnvQueryContext_InputTarget");
static_assert(sizeof(UEnvQueryContext_InputTarget) == 0x000038, "Wrong size on UEnvQueryContext_InputTarget");

// Class GbxGameSystemCore.EnvQueryContext_InputTargetMoveDir
// 0x0000 (0x0038 - 0x0038)
class UEnvQueryContext_InputTargetMoveDir final : public UEnvQueryContext_EnvQueryParam
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_InputTargetMoveDir">();
	}
	static class UEnvQueryContext_InputTargetMoveDir* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_InputTargetMoveDir>();
	}
};
static_assert(alignof(UEnvQueryContext_InputTargetMoveDir) == 0x000008, "Wrong alignment on UEnvQueryContext_InputTargetMoveDir");
static_assert(sizeof(UEnvQueryContext_InputTargetMoveDir) == 0x000038, "Wrong size on UEnvQueryContext_InputTargetMoveDir");

// Class GbxGameSystemCore.EnvQueryParamsProvider
// 0x0000 (0x0028 - 0x0028)
class IEnvQueryParamsProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryParamsProvider">();
	}
	static class IEnvQueryParamsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEnvQueryParamsProvider>();
	}
};
static_assert(alignof(IEnvQueryParamsProvider) == 0x000008, "Wrong alignment on IEnvQueryParamsProvider");
static_assert(sizeof(IEnvQueryParamsProvider) == 0x000028, "Wrong size on IEnvQueryParamsProvider");

// Class GbxGameSystemCore.EnvQueryTest_ProjectilesHomingTowardsTarget
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_ProjectilesHomingTowardsTarget final : public UEnvQueryTest
{
public:
	bool                                          bMustBeActivelyHoming;                             // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ProjectilesHomingTowardsTarget">();
	}
	static class UEnvQueryTest_ProjectilesHomingTowardsTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ProjectilesHomingTowardsTarget>();
	}
};
static_assert(alignof(UEnvQueryTest_ProjectilesHomingTowardsTarget) == 0x000008, "Wrong alignment on UEnvQueryTest_ProjectilesHomingTowardsTarget");
static_assert(sizeof(UEnvQueryTest_ProjectilesHomingTowardsTarget) == 0x0001E0, "Wrong size on UEnvQueryTest_ProjectilesHomingTowardsTarget");
static_assert(offsetof(UEnvQueryTest_ProjectilesHomingTowardsTarget, bMustBeActivelyHoming) == 0x0001D8, "Member 'UEnvQueryTest_ProjectilesHomingTowardsTarget::bMustBeActivelyHoming' has a wrong offset!");

// Class GbxGameSystemCore.UseSystemFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUseSystemFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ResetUseCount(class AActor* Actor);
	static void SetIsUsable(class AActor* Actor, bool bNewIsUsable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseSystemFunctionLibrary">();
	}
	static class UUseSystemFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseSystemFunctionLibrary>();
	}
};
static_assert(alignof(UUseSystemFunctionLibrary) == 0x000008, "Wrong alignment on UUseSystemFunctionLibrary");
static_assert(sizeof(UUseSystemFunctionLibrary) == 0x000028, "Wrong size on UUseSystemFunctionLibrary");

// Class GbxGameSystemCore.EnvQueryTestAsset
// 0x0008 (0x0038 - 0x0030)
class UEnvQueryTestAsset final : public UGbxDataAsset
{
public:
	class UEnvQueryTest*                          EnvQueryTest;                                      // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTestAsset">();
	}
	static class UEnvQueryTestAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTestAsset>();
	}
};
static_assert(alignof(UEnvQueryTestAsset) == 0x000008, "Wrong alignment on UEnvQueryTestAsset");
static_assert(sizeof(UEnvQueryTestAsset) == 0x000038, "Wrong size on UEnvQueryTestAsset");
static_assert(offsetof(UEnvQueryTestAsset, EnvQueryTest) == 0x000030, "Member 'UEnvQueryTestAsset::EnvQueryTest' has a wrong offset!");

// Class GbxGameSystemCore.ExplosionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UExplosionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UParticleSystemComponent* PlayExplosion(class UExplosionData* ExplosionData, float Size, const struct FVector& ExplosionLocation, class UObject* Context, TSubclassOf<class UDamageType> DamageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionBlueprintLibrary">();
	}
	static class UExplosionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosionBlueprintLibrary>();
	}
};
static_assert(alignof(UExplosionBlueprintLibrary) == 0x000008, "Wrong alignment on UExplosionBlueprintLibrary");
static_assert(sizeof(UExplosionBlueprintLibrary) == 0x000028, "Wrong size on UExplosionBlueprintLibrary");

// Class GbxGameSystemCore.ExplosionComponent
// 0x0060 (0x01D8 - 0x0178)
class UExplosionComponent final : public UActorComponent
{
public:
	struct FGbxAttributeFloat                     ExplosionRadius;                                   // 0x0178(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ExplosionParticleSystem;                           // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      ExplosionEffectCollection;                         // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSystemSize;                                // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyParticleSystemSize;                         // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            ExplosionAudioEvent;                               // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundPerceptionProperties             SoundPerception;                                   // 0x01A8(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          Feedback;                                          // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFeedbackRangeScalar;                            // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCauseExplosionDamage;                             // 0x01C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocation;                                 // 0x01C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C6[0x2];                                      // 0x01C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOverride;                                  // 0x01C8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode(const struct FDamageInfo& DamageInfo);
	void SetExplosionLocation(const struct FVector& NewLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionComponent">();
	}
	static class UExplosionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosionComponent>();
	}
};
static_assert(alignof(UExplosionComponent) == 0x000008, "Wrong alignment on UExplosionComponent");
static_assert(sizeof(UExplosionComponent) == 0x0001D8, "Wrong size on UExplosionComponent");
static_assert(offsetof(UExplosionComponent, ExplosionRadius) == 0x000178, "Member 'UExplosionComponent::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ExplosionParticleSystem) == 0x000188, "Member 'UExplosionComponent::ExplosionParticleSystem' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ExplosionEffectCollection) == 0x000190, "Member 'UExplosionComponent::ExplosionEffectCollection' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ParticleSystemSize) == 0x000198, "Member 'UExplosionComponent::ParticleSystemSize' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, bModifyParticleSystemSize) == 0x00019C, "Member 'UExplosionComponent::bModifyParticleSystemSize' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, ExplosionAudioEvent) == 0x0001A0, "Member 'UExplosionComponent::ExplosionAudioEvent' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, SoundPerception) == 0x0001A8, "Member 'UExplosionComponent::SoundPerception' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, Feedback) == 0x0001B8, "Member 'UExplosionComponent::Feedback' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, MaxFeedbackRangeScalar) == 0x0001C0, "Member 'UExplosionComponent::MaxFeedbackRangeScalar' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, bCauseExplosionDamage) == 0x0001C4, "Member 'UExplosionComponent::bCauseExplosionDamage' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, bOverrideLocation) == 0x0001C5, "Member 'UExplosionComponent::bOverrideLocation' has a wrong offset!");
static_assert(offsetof(UExplosionComponent, LocationOverride) == 0x0001C8, "Member 'UExplosionComponent::LocationOverride' has a wrong offset!");

// Class GbxGameSystemCore.ExplosionData
// 0x00D0 (0x0100 - 0x0030)
class UExplosionData final : public UGbxDataAsset
{
public:
	class UExplosionSizeSelectionData*            DefaultExplosionSizeData;                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageTypeExplosionAssociation> DamageTypeSelections;                              // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseRadialBlurOverride;                            // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurSelection                   RadialBlurOverride;                                // 0x004C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EExplosionTinnitusDuration                    TinnitusDuration;                                  // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBasicExplosion;                                // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxSignificanceEvent                  SignificanceEvent;                                 // 0x0060(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCensorThisExplosion;                              // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          FeedbackOverride;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystemOverride;                            // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CensoredParticleSystemOverride;                    // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            AudioEventOverride;                                // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactOverride;                                    // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeedbackFalloffMinDistanceScalar;                  // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeedbackFalloffMaxDistanceScalar;                  // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FExplosionSizeProperties SelectExplosion(float Size, TSubclassOf<class UDamageType> DamageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionData">();
	}
	static class UExplosionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosionData>();
	}
};
static_assert(alignof(UExplosionData) == 0x000008, "Wrong alignment on UExplosionData");
static_assert(sizeof(UExplosionData) == 0x000100, "Wrong size on UExplosionData");
static_assert(offsetof(UExplosionData, DefaultExplosionSizeData) == 0x000030, "Member 'UExplosionData::DefaultExplosionSizeData' has a wrong offset!");
static_assert(offsetof(UExplosionData, DamageTypeSelections) == 0x000038, "Member 'UExplosionData::DamageTypeSelections' has a wrong offset!");
static_assert(offsetof(UExplosionData, bUseRadialBlurOverride) == 0x000048, "Member 'UExplosionData::bUseRadialBlurOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, RadialBlurOverride) == 0x00004C, "Member 'UExplosionData::RadialBlurOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, TinnitusDuration) == 0x000058, "Member 'UExplosionData::TinnitusDuration' has a wrong offset!");
static_assert(offsetof(UExplosionData, bUseBasicExplosion) == 0x000059, "Member 'UExplosionData::bUseBasicExplosion' has a wrong offset!");
static_assert(offsetof(UExplosionData, SignificanceEvent) == 0x000060, "Member 'UExplosionData::SignificanceEvent' has a wrong offset!");
static_assert(offsetof(UExplosionData, bCensorThisExplosion) == 0x000068, "Member 'UExplosionData::bCensorThisExplosion' has a wrong offset!");
static_assert(offsetof(UExplosionData, FeedbackOverride) == 0x000070, "Member 'UExplosionData::FeedbackOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, ParticleSystemOverride) == 0x000078, "Member 'UExplosionData::ParticleSystemOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, CensoredParticleSystemOverride) == 0x000080, "Member 'UExplosionData::CensoredParticleSystemOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, AudioEventOverride) == 0x000088, "Member 'UExplosionData::AudioEventOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, ImpactOverride) == 0x000090, "Member 'UExplosionData::ImpactOverride' has a wrong offset!");
static_assert(offsetof(UExplosionData, FeedbackFalloffMinDistanceScalar) == 0x000098, "Member 'UExplosionData::FeedbackFalloffMinDistanceScalar' has a wrong offset!");
static_assert(offsetof(UExplosionData, FeedbackFalloffMaxDistanceScalar) == 0x00009C, "Member 'UExplosionData::FeedbackFalloffMaxDistanceScalar' has a wrong offset!");

// Class GbxGameSystemCore.ExplosionSizeSelectionData
// 0x0010 (0x0040 - 0x0030)
class UExplosionSizeSelectionData final : public UGbxDataAsset
{
public:
	TArray<struct FExplosionSizeProperties>       SizeProperties;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FExplosionSizeProperties GetExplosionPropertiesBySize(float Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionSizeSelectionData">();
	}
	static class UExplosionSizeSelectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosionSizeSelectionData>();
	}
};
static_assert(alignof(UExplosionSizeSelectionData) == 0x000008, "Wrong alignment on UExplosionSizeSelectionData");
static_assert(sizeof(UExplosionSizeSelectionData) == 0x000040, "Wrong size on UExplosionSizeSelectionData");
static_assert(offsetof(UExplosionSizeSelectionData, SizeProperties) == 0x000030, "Member 'UExplosionSizeSelectionData::SizeProperties' has a wrong offset!");

// Class GbxGameSystemCore.EyesOfDeathComponent
// 0x0030 (0x0720 - 0x06F0)
class UEyesOfDeathComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x30];                                     // 0x06F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EyesOfDeathComponent">();
	}
	static class UEyesOfDeathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEyesOfDeathComponent>();
	}
};
static_assert(alignof(UEyesOfDeathComponent) == 0x000008, "Wrong alignment on UEyesOfDeathComponent");
static_assert(sizeof(UEyesOfDeathComponent) == 0x000720, "Wrong size on UEyesOfDeathComponent");

// Class GbxGameSystemCore.FeedbackData
// 0x03C8 (0x03F8 - 0x0030)
class UFeedbackData : public UGbxDataAsset
{
public:
	int32                                         FeedbackType;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForceFeedbackChannelDetails>   ControllerRumbleDetails;                           // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UForceFeedbackEffect*>           ExternalForceFeedbackEffects;                      // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FForceFeedbackChannelDetails>   MinControllerRumbleDetails;                        // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UForceFeedbackEffect*>           MinExternalForceFeedbackEffects;                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteControllerRumbleScale;                    // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShake>               CameraShakeClass;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               CameraShakeClassNegativeXAxis;                     // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               CameraShakeClassYAxis;                             // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               CameraShakeClassNegativeYAxis;                     // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationDuration;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendInTime;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendOutTime;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FROscillator                           RotOscillation;                                    // 0x00AC(0x0030)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x00DC(0x0030)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FFOscillator                           FOVOscillation;                                    // 0x010C(0x0010)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RandomShakeInterval;                               // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRandomShakeScalar;                              // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRandomShakeScalar;                              // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           BaseCameraScale;                                   // 0x0128(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FShakeScaleAssociation>         AdditionalCameraShakes;                            // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EFeedbackDataFirstPersonImpulseType           FirstPersonImpulseType;                            // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFeedbackDataFirstPersonImpulse        CustomFirstPersonImpulse;                          // 0x0174(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ParticleSystem;                                    // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWhenFinished;                                 // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ContentDims;                                       // 0x01E4(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenParticleScalingMode                    ScalingMode;                                       // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x01F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysVisible;                                    // 0x01F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickParticleEvenWhenPaused;                       // 0x01F3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLetSystemFinishAfterStopping;                     // 0x0200(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxHUDFeedbackImpulse                 HUDImpulse;                                        // 0x0208(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectFalloffMinDistance;                          // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectFalloffMaxDistance;                          // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFeedbackData*>                  AssociatedFeedbacks;                               // 0x0278(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUpdateSourceLocation;                             // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleDownOverTime;                                // 0x0289(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScaleOverTimeCurve;                            // 0x028A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B[0x5];                                      // 0x028B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ScaleOverTimeCurve;                                // 0x0290(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseContinuousAttributeScale;                      // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ContinuousScale;                                   // 0x0310(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ContinuousScaleCurve;                              // 0x0348(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bPlayRadialBlur;                                   // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurSelection                   RadialBlurInfo;                                    // 0x03C4(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideRadialBlurCenter;                         // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RadialBlurWorldSpaceCenter;                        // 0x03D4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialBlurMaxDistance;                             // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLoopingShakeInfo>              LoopingShakes;                                     // 0x03E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static void GetFeedbackDataRange(class UFeedbackData* FeedbackData, float* MinRange, float* MaxRange);
	static float GetFeedbackDuration(class UFeedbackData* FeedbackData);
	static void PerformDefaultFeedback(const struct FFeedbackTableRowHandle& Feedback, class APlayerController* Controller, float Scale, bool bLoop, class UObject* SourceContext);
	static void PerformDefaultFeedbackAtLocation(const struct FFeedbackTableRowHandle& Feedback, class APlayerController* Controller, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback);
	static void PerformDefaultFeedbackForAll(const struct FFeedbackTableRowHandle& Feedback, float Scale, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback);
	static void PerformDefaultFeedbackForAllAtLocation(const struct FFeedbackTableRowHandle& Feedback, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback);
	static void PerformFeedback(class UFeedbackData* FeedbackData, class APlayerController* Controller, float Scale, bool bLoop, class UObject* SourceContext);
	static void PerformFeedbackAtLocation(class UFeedbackData* FeedbackData, class APlayerController* Controller, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback);
	static void PerformFeedbackForAll(class UFeedbackData* FeedbackData, float Scale, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback);
	static void PerformFeedbackForAllAtLocation(class UFeedbackData* FeedbackData, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback);
	static void StopDefaultFeedback(const struct FFeedbackTableRowHandle& Feedback, class APlayerController* Controller);
	static void StopDefaultFeedbackForAll(const struct FFeedbackTableRowHandle& Feedback, class UObject* WorldContextObject);
	static void StopFeedback(class UFeedbackData* FeedbackData, class APlayerController* Controller);
	static void StopFeedbackForAll(class UFeedbackData* FeedbackData, class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeedbackData">();
	}
	static class UFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeedbackData>();
	}
};
static_assert(alignof(UFeedbackData) == 0x000008, "Wrong alignment on UFeedbackData");
static_assert(sizeof(UFeedbackData) == 0x0003F8, "Wrong size on UFeedbackData");
static_assert(offsetof(UFeedbackData, FeedbackType) == 0x000030, "Member 'UFeedbackData::FeedbackType' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ControllerRumbleDetails) == 0x000038, "Member 'UFeedbackData::ControllerRumbleDetails' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ExternalForceFeedbackEffects) == 0x000048, "Member 'UFeedbackData::ExternalForceFeedbackEffects' has a wrong offset!");
static_assert(offsetof(UFeedbackData, MinControllerRumbleDetails) == 0x000058, "Member 'UFeedbackData::MinControllerRumbleDetails' has a wrong offset!");
static_assert(offsetof(UFeedbackData, MinExternalForceFeedbackEffects) == 0x000068, "Member 'UFeedbackData::MinExternalForceFeedbackEffects' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bAbsoluteControllerRumbleScale) == 0x000078, "Member 'UFeedbackData::bAbsoluteControllerRumbleScale' has a wrong offset!");
static_assert(offsetof(UFeedbackData, CameraShakeClass) == 0x000080, "Member 'UFeedbackData::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(UFeedbackData, CameraShakeClassNegativeXAxis) == 0x000088, "Member 'UFeedbackData::CameraShakeClassNegativeXAxis' has a wrong offset!");
static_assert(offsetof(UFeedbackData, CameraShakeClassYAxis) == 0x000090, "Member 'UFeedbackData::CameraShakeClassYAxis' has a wrong offset!");
static_assert(offsetof(UFeedbackData, CameraShakeClassNegativeYAxis) == 0x000098, "Member 'UFeedbackData::CameraShakeClassNegativeYAxis' has a wrong offset!");
static_assert(offsetof(UFeedbackData, OscillationDuration) == 0x0000A0, "Member 'UFeedbackData::OscillationDuration' has a wrong offset!");
static_assert(offsetof(UFeedbackData, OscillationBlendInTime) == 0x0000A4, "Member 'UFeedbackData::OscillationBlendInTime' has a wrong offset!");
static_assert(offsetof(UFeedbackData, OscillationBlendOutTime) == 0x0000A8, "Member 'UFeedbackData::OscillationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFeedbackData, RotOscillation) == 0x0000AC, "Member 'UFeedbackData::RotOscillation' has a wrong offset!");
static_assert(offsetof(UFeedbackData, LocOscillation) == 0x0000DC, "Member 'UFeedbackData::LocOscillation' has a wrong offset!");
static_assert(offsetof(UFeedbackData, FOVOscillation) == 0x00010C, "Member 'UFeedbackData::FOVOscillation' has a wrong offset!");
static_assert(offsetof(UFeedbackData, RandomShakeInterval) == 0x00011C, "Member 'UFeedbackData::RandomShakeInterval' has a wrong offset!");
static_assert(offsetof(UFeedbackData, MaxRandomShakeScalar) == 0x000120, "Member 'UFeedbackData::MaxRandomShakeScalar' has a wrong offset!");
static_assert(offsetof(UFeedbackData, MinRandomShakeScalar) == 0x000124, "Member 'UFeedbackData::MinRandomShakeScalar' has a wrong offset!");
static_assert(offsetof(UFeedbackData, BaseCameraScale) == 0x000128, "Member 'UFeedbackData::BaseCameraScale' has a wrong offset!");
static_assert(offsetof(UFeedbackData, AdditionalCameraShakes) == 0x000160, "Member 'UFeedbackData::AdditionalCameraShakes' has a wrong offset!");
static_assert(offsetof(UFeedbackData, FirstPersonImpulseType) == 0x000170, "Member 'UFeedbackData::FirstPersonImpulseType' has a wrong offset!");
static_assert(offsetof(UFeedbackData, CustomFirstPersonImpulse) == 0x000174, "Member 'UFeedbackData::CustomFirstPersonImpulse' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ParticleSystem) == 0x0001D8, "Member 'UFeedbackData::ParticleSystem' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bHideWhenFinished) == 0x0001E0, "Member 'UFeedbackData::bHideWhenFinished' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ContentDims) == 0x0001E4, "Member 'UFeedbackData::ContentDims' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ParticleDepth) == 0x0001EC, "Member 'UFeedbackData::ParticleDepth' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ScalingMode) == 0x0001F0, "Member 'UFeedbackData::ScalingMode' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bOnlyOwnerSee) == 0x0001F1, "Member 'UFeedbackData::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bAlwaysVisible) == 0x0001F2, "Member 'UFeedbackData::bAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bTickParticleEvenWhenPaused) == 0x0001F3, "Member 'UFeedbackData::bTickParticleEvenWhenPaused' has a wrong offset!");
static_assert(offsetof(UFeedbackData, Tag) == 0x0001F8, "Member 'UFeedbackData::Tag' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bLetSystemFinishAfterStopping) == 0x000200, "Member 'UFeedbackData::bLetSystemFinishAfterStopping' has a wrong offset!");
static_assert(offsetof(UFeedbackData, HUDImpulse) == 0x000208, "Member 'UFeedbackData::HUDImpulse' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bLooping) == 0x000268, "Member 'UFeedbackData::bLooping' has a wrong offset!");
static_assert(offsetof(UFeedbackData, EffectFalloffMinDistance) == 0x00026C, "Member 'UFeedbackData::EffectFalloffMinDistance' has a wrong offset!");
static_assert(offsetof(UFeedbackData, EffectFalloffMaxDistance) == 0x000270, "Member 'UFeedbackData::EffectFalloffMaxDistance' has a wrong offset!");
static_assert(offsetof(UFeedbackData, AssociatedFeedbacks) == 0x000278, "Member 'UFeedbackData::AssociatedFeedbacks' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bUpdateSourceLocation) == 0x000288, "Member 'UFeedbackData::bUpdateSourceLocation' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bScaleDownOverTime) == 0x000289, "Member 'UFeedbackData::bScaleDownOverTime' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bUseScaleOverTimeCurve) == 0x00028A, "Member 'UFeedbackData::bUseScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ScaleOverTimeCurve) == 0x000290, "Member 'UFeedbackData::ScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bUseContinuousAttributeScale) == 0x000308, "Member 'UFeedbackData::bUseContinuousAttributeScale' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ContinuousScale) == 0x000310, "Member 'UFeedbackData::ContinuousScale' has a wrong offset!");
static_assert(offsetof(UFeedbackData, ContinuousScaleCurve) == 0x000348, "Member 'UFeedbackData::ContinuousScaleCurve' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bPlayRadialBlur) == 0x0003C0, "Member 'UFeedbackData::bPlayRadialBlur' has a wrong offset!");
static_assert(offsetof(UFeedbackData, RadialBlurInfo) == 0x0003C4, "Member 'UFeedbackData::RadialBlurInfo' has a wrong offset!");
static_assert(offsetof(UFeedbackData, bOverrideRadialBlurCenter) == 0x0003D0, "Member 'UFeedbackData::bOverrideRadialBlurCenter' has a wrong offset!");
static_assert(offsetof(UFeedbackData, RadialBlurWorldSpaceCenter) == 0x0003D4, "Member 'UFeedbackData::RadialBlurWorldSpaceCenter' has a wrong offset!");
static_assert(offsetof(UFeedbackData, RadialBlurMaxDistance) == 0x0003E0, "Member 'UFeedbackData::RadialBlurMaxDistance' has a wrong offset!");
static_assert(offsetof(UFeedbackData, LoopingShakes) == 0x0003E8, "Member 'UFeedbackData::LoopingShakes' has a wrong offset!");

// Class GbxGameSystemCore.FXVolumeManager
// 0x0050 (0x0078 - 0x0028)
class UFXVolumeManager final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerDestroyed(class AActor* DestroyedActor);
	void OnVolumeDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FXVolumeManager">();
	}
	static class UFXVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFXVolumeManager>();
	}
};
static_assert(alignof(UFXVolumeManager) == 0x000008, "Wrong alignment on UFXVolumeManager");
static_assert(sizeof(UFXVolumeManager) == 0x000078, "Wrong size on UFXVolumeManager");

// Class GbxGameSystemCore.FXVolume
// 0x0020 (0x04B0 - 0x0490)
class AFXVolume final : public AVolume
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TagName;                                           // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDepthPriorityWorld;                               // 0x04A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorEnteredVolume(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnActorLeftVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FXVolume">();
	}
	static class AFXVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFXVolume>();
	}
};
static_assert(alignof(AFXVolume) == 0x000008, "Wrong alignment on AFXVolume");
static_assert(sizeof(AFXVolume) == 0x0004B0, "Wrong size on AFXVolume");
static_assert(offsetof(AFXVolume, ParticleSystem) == 0x000490, "Member 'AFXVolume::ParticleSystem' has a wrong offset!");
static_assert(offsetof(AFXVolume, ParticleDepth) == 0x000498, "Member 'AFXVolume::ParticleDepth' has a wrong offset!");
static_assert(offsetof(AFXVolume, TagName) == 0x0004A0, "Member 'AFXVolume::TagName' has a wrong offset!");
static_assert(offsetof(AFXVolume, bDepthPriorityWorld) == 0x0004A8, "Member 'AFXVolume::bDepthPriorityWorld' has a wrong offset!");

// Class GbxGameSystemCore.GameplayTagBasedAttributeValueResolver
// 0x0048 (0x0070 - 0x0028)
class UGameplayTagBasedAttributeValueResolver final : public UAttributeValueResolver
{
public:
	TArray<struct FGameplayTagToValueMap>         TagToValueMap;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           ValueIfNoTagIsFound;                               // 0x0038(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTagBasedAttributeValueResolver">();
	}
	static class UGameplayTagBasedAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagBasedAttributeValueResolver>();
	}
};
static_assert(alignof(UGameplayTagBasedAttributeValueResolver) == 0x000008, "Wrong alignment on UGameplayTagBasedAttributeValueResolver");
static_assert(sizeof(UGameplayTagBasedAttributeValueResolver) == 0x000070, "Wrong size on UGameplayTagBasedAttributeValueResolver");
static_assert(offsetof(UGameplayTagBasedAttributeValueResolver, TagToValueMap) == 0x000028, "Member 'UGameplayTagBasedAttributeValueResolver::TagToValueMap' has a wrong offset!");
static_assert(offsetof(UGameplayTagBasedAttributeValueResolver, ValueIfNoTagIsFound) == 0x000038, "Member 'UGameplayTagBasedAttributeValueResolver::ValueIfNoTagIsFound' has a wrong offset!");

// Class GbxGameSystemCore.GameplayTagContainerComponent
// 0x0030 (0x01A8 - 0x0178)
class UGameplayTagContainerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0188(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UGameplayTagContainerComponent* GetGameplayTagContainerFromActor(const class AActor* Actor, EContainsTagComponent* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTagContainerComponent">();
	}
	static class UGameplayTagContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagContainerComponent>();
	}
};
static_assert(alignof(UGameplayTagContainerComponent) == 0x000008, "Wrong alignment on UGameplayTagContainerComponent");
static_assert(sizeof(UGameplayTagContainerComponent) == 0x0001A8, "Wrong size on UGameplayTagContainerComponent");
static_assert(offsetof(UGameplayTagContainerComponent, TagContainer) == 0x000188, "Member 'UGameplayTagContainerComponent::TagContainer' has a wrong offset!");

// Class GbxGameSystemCore.GameplayTask_RunEnvQuery
// 0x0028 (0x0090 - 0x0068)
class UGameplayTask_RunEnvQuery final : public UGameplayTask
{
public:
	UMulticastDelegateProperty_                   Success;                                           // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Failure;                                           // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetResultActor(const struct FEnvQueryResult& QueryResult, class AActor** ResultActor);
	static bool GetResultActors(const struct FEnvQueryResult& QueryResult, TArray<class AActor*>* ResultActors);
	static bool GetResultLocation(const struct FEnvQueryResult& QueryResult, struct FVector* ResultLocation);
	static bool GetResultLocations(const struct FEnvQueryResult& QueryResult, TArray<struct FVector>* ResultLocations);
	static class UGameplayTask_RunEnvQuery* RunEnvQuery(class AActor* QueryOwner, const struct FEnvQueryParams& QueryParams);
	static class UGameplayTask_RunEnvQuery* RunEnvQueryOnActor(class AActor* QueryOwner, const struct FEnvQueryParams& QueryParams, class AActor* Actor);
	static class UGameplayTask_RunEnvQuery* RunEnvQueryOnLocation(class AActor* QueryOwner, const struct FEnvQueryParams& QueryParams, const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_RunEnvQuery">();
	}
	static class UGameplayTask_RunEnvQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_RunEnvQuery>();
	}
};
static_assert(alignof(UGameplayTask_RunEnvQuery) == 0x000008, "Wrong alignment on UGameplayTask_RunEnvQuery");
static_assert(sizeof(UGameplayTask_RunEnvQuery) == 0x000090, "Wrong size on UGameplayTask_RunEnvQuery");
static_assert(offsetof(UGameplayTask_RunEnvQuery, Success) == 0x000068, "Member 'UGameplayTask_RunEnvQuery::Success' has a wrong offset!");
static_assert(offsetof(UGameplayTask_RunEnvQuery, Failure) == 0x000078, "Member 'UGameplayTask_RunEnvQuery::Failure' has a wrong offset!");

// Class GbxGameSystemCore.GameResourceData
// 0x0028 (0x0058 - 0x0030)
class UGameResourceData final : public UGbxDataAsset
{
public:
	class FText                                   ResourceName;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIntegerOnlyUpdates;                               // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSerializeInSavegame;                              // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameResourcePoolData*                  DefaultResourcePoolData;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourceData">();
	}
	static class UGameResourceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourceData>();
	}
};
static_assert(alignof(UGameResourceData) == 0x000008, "Wrong alignment on UGameResourceData");
static_assert(sizeof(UGameResourceData) == 0x000058, "Wrong size on UGameResourceData");
static_assert(offsetof(UGameResourceData, ResourceName) == 0x000030, "Member 'UGameResourceData::ResourceName' has a wrong offset!");
static_assert(offsetof(UGameResourceData, bIntegerOnlyUpdates) == 0x000048, "Member 'UGameResourceData::bIntegerOnlyUpdates' has a wrong offset!");
static_assert(offsetof(UGameResourceData, bSerializeInSavegame) == 0x000049, "Member 'UGameResourceData::bSerializeInSavegame' has a wrong offset!");
static_assert(offsetof(UGameResourceData, DefaultResourcePoolData) == 0x000050, "Member 'UGameResourceData::DefaultResourcePoolData' has a wrong offset!");

// Class GbxGameSystemCore.GameResourcePoolFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameResourcePoolFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AdjustResourcePoolValue(const struct FGameResourcePoolReference& InPool, float InValue);
	static void BreakResourcePoolReference(const struct FGameResourcePoolReference& InPool, bool* bValid, float* CurrentValue, float* MinValue, float* MaxValue);
	static void ClearResourcePoolRegenDelay(const struct FGameResourcePoolReference& InPool);
	static void ClearResourcePoolRegenDelayByGameResourceData(class AActor* Actor, class UGameResourceData* Resource);
	static void DeleteResourcePool(struct FGameResourcePoolReference& InPool);
	static void DrainResourcePoolByPercentage(const struct FGameResourcePoolReference& InPool, float Percentage, float MinPercentage);
	static bool EqualEqual_ResourceData(const struct FGameResourcePoolReference& ResourcePoolReference, class UGameResourceData* ResourceData);
	static bool EqualEqual_ResourcePoolData(const struct FGameResourcePoolReference& ResourcePoolReference, class UGameResourcePoolData* ResourcePoolData);
	static bool EqualEqual_ResourcePoolReference(const struct FGameResourcePoolReference& A, const struct FGameResourcePoolReference& B);
	static class FName GetDelegatePrefixForResourceEvent(struct FGameResourceUserEvent* InResourceUserEvent);
	static bool IsResourcePoolInState(const struct FGameResourcePoolReference& InPool, EGameResourcePoolState InState);
	static void RefillResourcePoolByPercentage(const struct FGameResourcePoolReference& InPool, float Percentage, float MaxPercentage);
	static void ResetResourcePoolRegenDelay(const struct FGameResourcePoolReference& InPool);
	static void ResetResourcePoolRegenDelayByGameResourceData(class AActor* Actor, class UGameResourceData* Resource);
	static void SetResourcePoolValue(const struct FGameResourcePoolReference& InPool, float InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameResourcePoolFunctionLibrary">();
	}
	static class UGameResourcePoolFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameResourcePoolFunctionLibrary>();
	}
};
static_assert(alignof(UGameResourcePoolFunctionLibrary) == 0x000008, "Wrong alignment on UGameResourcePoolFunctionLibrary");
static_assert(sizeof(UGameResourcePoolFunctionLibrary) == 0x000028, "Wrong size on UGameResourcePoolFunctionLibrary");

// Class GbxGameSystemCore.GameStatData
// 0x0038 (0x0068 - 0x0030)
class UGameStatData final : public UGbxDataAsset
{
public:
	int32                                         DefaultValue;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMinValue;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxValue;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMaxValue;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StatName;                                          // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bProfileStat;                                      // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartyStat;                                        // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStatData">();
	}
	static class UGameStatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStatData>();
	}
};
static_assert(alignof(UGameStatData) == 0x000008, "Wrong alignment on UGameStatData");
static_assert(sizeof(UGameStatData) == 0x000068, "Wrong size on UGameStatData");
static_assert(offsetof(UGameStatData, DefaultValue) == 0x000030, "Member 'UGameStatData::DefaultValue' has a wrong offset!");
static_assert(offsetof(UGameStatData, MinValue) == 0x000034, "Member 'UGameStatData::MinValue' has a wrong offset!");
static_assert(offsetof(UGameStatData, bHasMinValue) == 0x000038, "Member 'UGameStatData::bHasMinValue' has a wrong offset!");
static_assert(offsetof(UGameStatData, MaxValue) == 0x00003C, "Member 'UGameStatData::MaxValue' has a wrong offset!");
static_assert(offsetof(UGameStatData, bHasMaxValue) == 0x000040, "Member 'UGameStatData::bHasMaxValue' has a wrong offset!");
static_assert(offsetof(UGameStatData, StatName) == 0x000048, "Member 'UGameStatData::StatName' has a wrong offset!");
static_assert(offsetof(UGameStatData, bProfileStat) == 0x000060, "Member 'UGameStatData::bProfileStat' has a wrong offset!");
static_assert(offsetof(UGameStatData, bPartyStat) == 0x000061, "Member 'UGameStatData::bPartyStat' has a wrong offset!");

// Class GbxGameSystemCore.GameStatList
// 0x0010 (0x0040 - 0x0030)
class UGameStatList final : public UGbxDataAsset
{
public:
	TArray<class UGameStatData*>                  GameStats;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStatList">();
	}
	static class UGameStatList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStatList>();
	}
};
static_assert(alignof(UGameStatList) == 0x000008, "Wrong alignment on UGameStatList");
static_assert(sizeof(UGameStatList) == 0x000040, "Wrong size on UGameStatList");
static_assert(offsetof(UGameStatList, GameStats) == 0x000030, "Member 'UGameStatList::GameStats' has a wrong offset!");

// Class GbxGameSystemCore.GameStatsManager
// 0x0030 (0x0488 - 0x0458)
class AGameStatsManager final : public AActor
{
public:
	uint8                                         Pad_458[0x30];                                     // 0x0458(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetStatValue(class AActor* StatContext, class UGameStatData* GameStat);
	void IncrementStat(class AActor* StatContext, class UGameStatData* GameStat, int32 IncrementAmount);
	void UpdateStat(class AActor* StatContext, class UGameStatData* GameStat, int32 NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStatsManager">();
	}
	static class AGameStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStatsManager>();
	}
};
static_assert(alignof(AGameStatsManager) == 0x000008, "Wrong alignment on AGameStatsManager");
static_assert(sizeof(AGameStatsManager) == 0x000488, "Wrong size on AGameStatsManager");

// Class GbxGameSystemCore.GbxAction_BlueprintBase
// 0x0008 (0x0068 - 0x0060)
class UGbxAction_BlueprintBase : public UGbxAction
{
public:
	bool                                          bAutoCompleted;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_BlueprintBase">();
	}
	static class UGbxAction_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_BlueprintBase>();
	}
};
static_assert(alignof(UGbxAction_BlueprintBase) == 0x000008, "Wrong alignment on UGbxAction_BlueprintBase");
static_assert(sizeof(UGbxAction_BlueprintBase) == 0x000068, "Wrong size on UGbxAction_BlueprintBase");
static_assert(offsetof(UGbxAction_BlueprintBase, bAutoCompleted) == 0x000060, "Member 'UGbxAction_BlueprintBase::bAutoCompleted' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_DirectionContainer
// 0x0068 (0x00C8 - 0x0060)
class UGbxAction_DirectionContainer : public UGbxAction
{
public:
	TArray<struct FDirectionActionData>           DirectionList;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FRelativeDirectionData                 DirectionData;                                     // 0x0070(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EDirectionPlane                               Plane;                                             // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_DirectionContainer">();
	}
	static class UGbxAction_DirectionContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_DirectionContainer>();
	}
};
static_assert(alignof(UGbxAction_DirectionContainer) == 0x000008, "Wrong alignment on UGbxAction_DirectionContainer");
static_assert(sizeof(UGbxAction_DirectionContainer) == 0x0000C8, "Wrong size on UGbxAction_DirectionContainer");
static_assert(offsetof(UGbxAction_DirectionContainer, DirectionList) == 0x000060, "Member 'UGbxAction_DirectionContainer::DirectionList' has a wrong offset!");
static_assert(offsetof(UGbxAction_DirectionContainer, DirectionData) == 0x000070, "Member 'UGbxAction_DirectionContainer::DirectionData' has a wrong offset!");
static_assert(offsetof(UGbxAction_DirectionContainer, Plane) == 0x0000C0, "Member 'UGbxAction_DirectionContainer::Plane' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_Launch
// 0x0150 (0x0208 - 0x00B8)
class UGbxAction_Launch : public UGbxAction_SimpleAnim
{
public:
	float                                         VelocityMinimum;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityScale;                                     // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityUpBoost;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationTime;                                      // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimMeshList                          InAirAnims;                                        // 0x00C8(0x0078)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimMeshList                          RecoveryAnims;                                     // 0x0140(0x0078)(Edit, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AnimSlot;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      AnimInAir;                                         // 0x01C8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      AnimRecovery;                                      // 0x01D0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimActionDef                         InAirAnim;                                         // 0x01D8(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAnimActionDef                         RecoveryAnim;                                      // 0x01F0(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_Launch">();
	}
	static class UGbxAction_Launch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_Launch>();
	}
};
static_assert(alignof(UGbxAction_Launch) == 0x000008, "Wrong alignment on UGbxAction_Launch");
static_assert(sizeof(UGbxAction_Launch) == 0x000208, "Wrong size on UGbxAction_Launch");
static_assert(offsetof(UGbxAction_Launch, VelocityMinimum) == 0x0000B8, "Member 'UGbxAction_Launch::VelocityMinimum' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, VelocityScale) == 0x0000BC, "Member 'UGbxAction_Launch::VelocityScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, VelocityUpBoost) == 0x0000C0, "Member 'UGbxAction_Launch::VelocityUpBoost' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, RotationTime) == 0x0000C4, "Member 'UGbxAction_Launch::RotationTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, InAirAnims) == 0x0000C8, "Member 'UGbxAction_Launch::InAirAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, RecoveryAnims) == 0x000140, "Member 'UGbxAction_Launch::RecoveryAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, BlendInTime) == 0x0001B8, "Member 'UGbxAction_Launch::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, BlendOutTime) == 0x0001BC, "Member 'UGbxAction_Launch::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, AnimSlot) == 0x0001C0, "Member 'UGbxAction_Launch::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, AnimInAir) == 0x0001C8, "Member 'UGbxAction_Launch::AnimInAir' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, AnimRecovery) == 0x0001D0, "Member 'UGbxAction_Launch::AnimRecovery' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, InAirAnim) == 0x0001D8, "Member 'UGbxAction_Launch::InAirAnim' has a wrong offset!");
static_assert(offsetof(UGbxAction_Launch, RecoveryAnim) == 0x0001F0, "Member 'UGbxAction_Launch::RecoveryAnim' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_Ragdoll
// 0x00D0 (0x0188 - 0x00B8)
class UGbxAction_Ragdoll : public UGbxAction_SimpleAnim
{
public:
	struct FAnimActionDef                         RagdollAnim;                                       // 0x00B8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RagdollDelayTime;                                  // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpwardForceMultiplier;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TerminalResultantVelocity;                         // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHaltMotionBeforeImpulseApplication;               // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollAnimBlendInTime;                            // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimActionDef                         RagdollLoopingAnim;                                // 0x00E8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPlayLoopingAnimWhileNotIdle;                      // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRagdollTime;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AnimSlot;                                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAttachedObjectFollow>          AttachedObjects;                                   // 0x0110(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMotionMatchedAnimationTable*           RecoveryAnimations;                                // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHitReactionTag*                        DeathReactionTag;                                  // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanGetup;                                         // 0x0130(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GetupIdleTime;                                     // 0x0134(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GetupIdleSpeedThreshold;                           // 0x0138(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GetupTestBone;                                     // 0x0140(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         TestBoneUpAxis;                                    // 0x0148(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpAxisIsNegative;                                 // 0x0149(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         TestBoneForwardAxis;                               // 0x014A(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForwardAxisIsNegative;                            // 0x014B(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimActionDef                         GetupAnimUp;                                       // 0x0150(0x0018)(Deprecated, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimActionDef                         GetupAnimDown;                                     // 0x0168(0x0018)(Deprecated, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GetupBlendInTime;                                  // 0x0180(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GetupBlendOutTime;                                 // 0x0184(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_Ragdoll">();
	}
	static class UGbxAction_Ragdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_Ragdoll>();
	}
};
static_assert(alignof(UGbxAction_Ragdoll) == 0x000008, "Wrong alignment on UGbxAction_Ragdoll");
static_assert(sizeof(UGbxAction_Ragdoll) == 0x000188, "Wrong size on UGbxAction_Ragdoll");
static_assert(offsetof(UGbxAction_Ragdoll, RagdollAnim) == 0x0000B8, "Member 'UGbxAction_Ragdoll::RagdollAnim' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, RagdollDelayTime) == 0x0000D0, "Member 'UGbxAction_Ragdoll::RagdollDelayTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, UpwardForceMultiplier) == 0x0000D4, "Member 'UGbxAction_Ragdoll::UpwardForceMultiplier' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, TerminalResultantVelocity) == 0x0000D8, "Member 'UGbxAction_Ragdoll::TerminalResultantVelocity' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, bHaltMotionBeforeImpulseApplication) == 0x0000DC, "Member 'UGbxAction_Ragdoll::bHaltMotionBeforeImpulseApplication' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, RagdollAnimBlendInTime) == 0x0000E0, "Member 'UGbxAction_Ragdoll::RagdollAnimBlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, RagdollLoopingAnim) == 0x0000E8, "Member 'UGbxAction_Ragdoll::RagdollLoopingAnim' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, bPlayLoopingAnimWhileNotIdle) == 0x000100, "Member 'UGbxAction_Ragdoll::bPlayLoopingAnimWhileNotIdle' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, MinRagdollTime) == 0x000104, "Member 'UGbxAction_Ragdoll::MinRagdollTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, AnimSlot) == 0x000108, "Member 'UGbxAction_Ragdoll::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, AttachedObjects) == 0x000110, "Member 'UGbxAction_Ragdoll::AttachedObjects' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, RecoveryAnimations) == 0x000120, "Member 'UGbxAction_Ragdoll::RecoveryAnimations' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, DeathReactionTag) == 0x000128, "Member 'UGbxAction_Ragdoll::DeathReactionTag' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, bCanGetup) == 0x000130, "Member 'UGbxAction_Ragdoll::bCanGetup' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupIdleTime) == 0x000134, "Member 'UGbxAction_Ragdoll::GetupIdleTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupIdleSpeedThreshold) == 0x000138, "Member 'UGbxAction_Ragdoll::GetupIdleSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupTestBone) == 0x000140, "Member 'UGbxAction_Ragdoll::GetupTestBone' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, TestBoneUpAxis) == 0x000148, "Member 'UGbxAction_Ragdoll::TestBoneUpAxis' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, bUpAxisIsNegative) == 0x000149, "Member 'UGbxAction_Ragdoll::bUpAxisIsNegative' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, TestBoneForwardAxis) == 0x00014A, "Member 'UGbxAction_Ragdoll::TestBoneForwardAxis' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, bForwardAxisIsNegative) == 0x00014B, "Member 'UGbxAction_Ragdoll::bForwardAxisIsNegative' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupAnimUp) == 0x000150, "Member 'UGbxAction_Ragdoll::GetupAnimUp' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupAnimDown) == 0x000168, "Member 'UGbxAction_Ragdoll::GetupAnimDown' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupBlendInTime) == 0x000180, "Member 'UGbxAction_Ragdoll::GetupBlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_Ragdoll, GetupBlendOutTime) == 0x000184, "Member 'UGbxAction_Ragdoll::GetupBlendOutTime' has a wrong offset!");

// Class GbxGameSystemCore.GbxAction_StretchBones
// 0x0088 (0x0140 - 0x00B8)
class UGbxAction_StretchBones final : public UGbxAction_SimpleAnim
{
public:
	struct FAnimActionDef                         StretchAnimation;                                  // 0x00B8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimSlot;                                          // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStretchBonesSettings                  StretchBonesSettings;                              // 0x00E0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUniformStretch;                                   // 0x0110(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              TargetKey;                                         // 0x0118(0x0010)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0128(0x000C)(Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchBonesActorTrackingStyle               ActorTrackingStyle;                                // 0x0134(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceToGround;                                    // 0x0135(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136[0x2];                                      // 0x0136(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceToGroundDistance;                             // 0x0138(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPredictionDistance;                             // 0x013C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_StretchBones">();
	}
	static class UGbxAction_StretchBones* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_StretchBones>();
	}
};
static_assert(alignof(UGbxAction_StretchBones) == 0x000008, "Wrong alignment on UGbxAction_StretchBones");
static_assert(sizeof(UGbxAction_StretchBones) == 0x000140, "Wrong size on UGbxAction_StretchBones");
static_assert(offsetof(UGbxAction_StretchBones, StretchAnimation) == 0x0000B8, "Member 'UGbxAction_StretchBones::StretchAnimation' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, BlendInTime) == 0x0000D0, "Member 'UGbxAction_StretchBones::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, BlendOutTime) == 0x0000D4, "Member 'UGbxAction_StretchBones::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, AnimSlot) == 0x0000D8, "Member 'UGbxAction_StretchBones::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, StretchBonesSettings) == 0x0000E0, "Member 'UGbxAction_StretchBones::StretchBonesSettings' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, bUniformStretch) == 0x000110, "Member 'UGbxAction_StretchBones::bUniformStretch' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, TargetKey) == 0x000118, "Member 'UGbxAction_StretchBones::TargetKey' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, TargetOffset) == 0x000128, "Member 'UGbxAction_StretchBones::TargetOffset' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, ActorTrackingStyle) == 0x000134, "Member 'UGbxAction_StretchBones::ActorTrackingStyle' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, bTraceToGround) == 0x000135, "Member 'UGbxAction_StretchBones::bTraceToGround' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, TraceToGroundDistance) == 0x000138, "Member 'UGbxAction_StretchBones::TraceToGroundDistance' has a wrong offset!");
static_assert(offsetof(UGbxAction_StretchBones, MaxPredictionDistance) == 0x00013C, "Member 'UGbxAction_StretchBones::MaxPredictionDistance' has a wrong offset!");

// Class GbxGameSystemCore.StretchBonesBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UStretchBonesBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FGbxActionRegister> SetStretchBonesDistance(TArray<struct FGbxActionRegister>& GbxActionRegisters, float Distance);
	static TArray<struct FGbxActionRegister> SetStretchBonesTarget(TArray<struct FGbxActionRegister>& GbxActionRegisters, class AActor* TargetActor, const struct FVector& TargetPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StretchBonesBlueprintLibrary">();
	}
	static class UStretchBonesBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStretchBonesBlueprintLibrary>();
	}
};
static_assert(alignof(UStretchBonesBlueprintLibrary) == 0x000008, "Wrong alignment on UStretchBonesBlueprintLibrary");
static_assert(sizeof(UStretchBonesBlueprintLibrary) == 0x000028, "Wrong size on UStretchBonesBlueprintLibrary");

// Class GbxGameSystemCore.GbxActionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxActionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TSubclassOf<class UGbxAction> GetKeyedActionClass(const struct FGameplayTag& ActionKey, class AActor* Target);
	static class FString GetSummary_AnimActionDef(const struct FAnimActionDef& AnimActionDef);
	static class UGbxAction* K2_GetActionByClass(TSubclassOf<class UGbxAction> ActionClass, class AActor* Target);
	static float K2_GetMaxCurrentTime(class UGbxAction* Action);
	static float K2_GetTimeRemaining(class UGbxAction* Target);
	static void K2_JumpToNextSection(class UGbxAction* Action);
	static void K2_Pause(class UGbxAction* Action);
	static void K2_ProceedToNextSection(class UGbxAction* Action);
	static void K2_ReplicatedJumpToNextSection(class UGbxAction* Action);
	static void K2_ReplicatedProceedToNextSection(class UGbxAction* Action);
	static void K2_Resume(class UGbxAction* Action);
	static void K2_ShowGbxActionScreenLogs(bool bShowLogsOnScreen);
	static void K2_StopActionObj(class UGbxAction* Action, class AActor* Target);
	static void K2_UpdateActionDirection(class UGbxAction* Action, const struct FVector& Direction);
	static void K2_UpdateActionPlayRate(class UGbxAction* Action, float PlayRate);
	static TArray<struct FGbxActionRegister> SetFloatGbxActionRegister(TArray<struct FGbxActionRegister>& GbxActionRegisters, class FName RegisterKey, float Value, bool bReplicates);
	static TArray<struct FGbxActionRegister> SetIntGbxActionRegister(TArray<struct FGbxActionRegister>& GbxActionRegisters, class FName RegisterKey, int32 Value, bool bReplicates);
	static TArray<struct FGbxActionRegister> SetNameGbxActionRegister(TArray<struct FGbxActionRegister>& GbxActionRegisters, class FName RegisterKey, class FName Value, bool bReplicates);
	static TArray<struct FGbxActionRegister> SetObjectGbxActionRegister(TArray<struct FGbxActionRegister>& GbxActionRegisters, class FName RegisterKey, class UObject* Value, bool bReplicates);
	static void StopActionClass(TSubclassOf<class UGbxAction> ActionClass, class AActor* Target);
	static void StopActions(class AActor* Target);
	static void StopActionSlot(const class FName ActionSlotName, class AActor* Target);
	static void StopLoopingActionClass(TSubclassOf<class UGbxAction_Loop> ActionClass, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxActionBlueprintLibrary">();
	}
	static class UGbxActionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxActionBlueprintLibrary>();
	}
};
static_assert(alignof(UGbxActionBlueprintLibrary) == 0x000008, "Wrong alignment on UGbxActionBlueprintLibrary");
static_assert(sizeof(UGbxActionBlueprintLibrary) == 0x000028, "Wrong size on UGbxActionBlueprintLibrary");

// Class GbxGameSystemCore.GbxActionDataAsset
// 0x0000 (0x0030 - 0x0030)
class UGbxActionDataAsset final : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxActionDataAsset">();
	}
	static class UGbxActionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxActionDataAsset>();
	}
};
static_assert(alignof(UGbxActionDataAsset) == 0x000008, "Wrong alignment on UGbxActionDataAsset");
static_assert(sizeof(UGbxActionDataAsset) == 0x000030, "Wrong size on UGbxActionDataAsset");

// Class GbxGameSystemCore.GbxActionManager
// 0x0110 (0x0568 - 0x0458)
class AGbxActionManager final : public AActor
{
public:
	struct FActionStateNet                        ActionRepWrapper;                                  // 0x0458(0x0108)(Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxActionManager">();
	}
	static class AGbxActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxActionManager>();
	}
};
static_assert(alignof(AGbxActionManager) == 0x000008, "Wrong alignment on AGbxActionManager");
static_assert(sizeof(AGbxActionManager) == 0x000568, "Wrong size on AGbxActionManager");
static_assert(offsetof(AGbxActionManager, ActionRepWrapper) == 0x000458, "Member 'AGbxActionManager::ActionRepWrapper' has a wrong offset!");

// Class GbxGameSystemCore.GbxAnimBlueprintProfile
// 0x0278 (0x02A8 - 0x0030)
class UGbxAnimBlueprintProfile final : public UGbxDataAsset
{
public:
	bool                                          bImportedLegIKSettings;                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootIKTraceUpScale;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKTraceDownScale;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKOffsetInterpSpeed;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKTargetOffset;                                // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FootIKFootLODThreshold;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          MeshOffsetCharacterSpeedRange;                     // 0x0050(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MeshIKOffsetInterpSpeed;                           // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLimitFootDistanceToMeshOffset;              // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlopeAdaptation;                                   // 0x0060(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         SlopeAdaptationBone;                               // 0x0070(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngle;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeNormalMinInterpSpeed;                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeNormalMaxInterpSpeed;                         // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          SlopeNormalCharacterSpeedRange;                    // 0x0094(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FootIKLODThreshold;                                // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKLODInterpolationSpeed;                       // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenSizeSelection                   FootIkScreenSizeThreshold;                         // 0x00A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseFootIkScreenSizeThreshold;                     // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenSizeSelection                   FootIkTraceScreenSizeThreshold;                    // 0x00C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseFootIkTraceScreenSizeThreshold;                // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootIKReachPrecision;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FootIKMaxIterations;                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimLegIKDefinition>           FootIKLegsDefinition;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinVelocity;                                       // 0x0100(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x0104(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToModify;                                      // 0x0108(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ParentBoneToModify;                                // 0x0120(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EGbxLookAxisOption                            ParentLookAxis;                                    // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneBlendParams>               BonesToModify;                                     // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneBlendParams>               EyeBonesToModify;                                  // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LookAtBlinkAngleOverride;                          // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtBlinkAngleOverride;                      // 0x0164(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEyeMovement;                                   // 0x0165(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_166[0x2];                                      // 0x0166(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EyeShiftMin;                                       // 0x0168(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EyeShiftMax;                                       // 0x0174(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EyeGlanceMin;                                      // 0x0180(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EyeGlanceMax;                                      // 0x018C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EyeFocusTimeMin;                                   // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeFocusTimeMax;                                   // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeGlanceTimeMin;                                  // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeGlanceTimeMax;                                  // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeShiftTimeMin;                                   // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeShiftTimeMax;                                   // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LookAtEyeLODThreshold;                             // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LookAtLODThreshold;                                // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtLODInterpolationSpeed;                       // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenSizeSelection                   LookAtEyeScreenSizeThreshold;                      // 0x01C0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtEyeScreenSizeThreshold;                  // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScreenSizeSelection                   LookAtScreenSizeThreshold;                         // 0x01E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLookAtScreenSizeThreshold;                     // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForwardDynamicsNodeProfile>    ForwardDynamicsNodeList;                           // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TeethOffsetOverride;                               // 0x0218(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTeethOffsetOverride;                           // 0x0224(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         UpperTeethBoneRef;                                 // 0x0228(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                BoneTagToBoneOverrideNameMap;                      // 0x0240(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseUpperTeethBoneRefOverride;                     // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          DefaultIdleLoopAnimation;                          // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AnimBlueprintImportFunction(EAnimBPProfileImport ImportType);
	void RebuildBoneLists();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimBlueprintProfile">();
	}
	static class UGbxAnimBlueprintProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimBlueprintProfile>();
	}
};
static_assert(alignof(UGbxAnimBlueprintProfile) == 0x000008, "Wrong alignment on UGbxAnimBlueprintProfile");
static_assert(sizeof(UGbxAnimBlueprintProfile) == 0x0002A8, "Wrong size on UGbxAnimBlueprintProfile");
static_assert(offsetof(UGbxAnimBlueprintProfile, bImportedLegIKSettings) == 0x000030, "Member 'UGbxAnimBlueprintProfile::bImportedLegIKSettings' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKTraceUpScale) == 0x000034, "Member 'UGbxAnimBlueprintProfile::FootIKTraceUpScale' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKTraceDownScale) == 0x000038, "Member 'UGbxAnimBlueprintProfile::FootIKTraceDownScale' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKOffsetInterpSpeed) == 0x00003C, "Member 'UGbxAnimBlueprintProfile::FootIKOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKTargetOffset) == 0x000040, "Member 'UGbxAnimBlueprintProfile::FootIKTargetOffset' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKFootLODThreshold) == 0x00004C, "Member 'UGbxAnimBlueprintProfile::FootIKFootLODThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, MeshOffsetCharacterSpeedRange) == 0x000050, "Member 'UGbxAnimBlueprintProfile::MeshOffsetCharacterSpeedRange' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, MeshIKOffsetInterpSpeed) == 0x000058, "Member 'UGbxAnimBlueprintProfile::MeshIKOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bShouldLimitFootDistanceToMeshOffset) == 0x00005C, "Member 'UGbxAnimBlueprintProfile::bShouldLimitFootDistanceToMeshOffset' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, SlopeAdaptation) == 0x000060, "Member 'UGbxAnimBlueprintProfile::SlopeAdaptation' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, SlopeAdaptationBone) == 0x000070, "Member 'UGbxAnimBlueprintProfile::SlopeAdaptationBone' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, MaxSlopeAngle) == 0x000088, "Member 'UGbxAnimBlueprintProfile::MaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, SlopeNormalMinInterpSpeed) == 0x00008C, "Member 'UGbxAnimBlueprintProfile::SlopeNormalMinInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, SlopeNormalMaxInterpSpeed) == 0x000090, "Member 'UGbxAnimBlueprintProfile::SlopeNormalMaxInterpSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, SlopeNormalCharacterSpeedRange) == 0x000094, "Member 'UGbxAnimBlueprintProfile::SlopeNormalCharacterSpeedRange' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKLODThreshold) == 0x00009C, "Member 'UGbxAnimBlueprintProfile::FootIKLODThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKLODInterpolationSpeed) == 0x0000A0, "Member 'UGbxAnimBlueprintProfile::FootIKLODInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIkScreenSizeThreshold) == 0x0000A8, "Member 'UGbxAnimBlueprintProfile::FootIkScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseFootIkScreenSizeThreshold) == 0x0000C0, "Member 'UGbxAnimBlueprintProfile::bUseFootIkScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIkTraceScreenSizeThreshold) == 0x0000C8, "Member 'UGbxAnimBlueprintProfile::FootIkTraceScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseFootIkTraceScreenSizeThreshold) == 0x0000E0, "Member 'UGbxAnimBlueprintProfile::bUseFootIkTraceScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKReachPrecision) == 0x0000E4, "Member 'UGbxAnimBlueprintProfile::FootIKReachPrecision' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKMaxIterations) == 0x0000E8, "Member 'UGbxAnimBlueprintProfile::FootIKMaxIterations' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, FootIKLegsDefinition) == 0x0000F0, "Member 'UGbxAnimBlueprintProfile::FootIKLegsDefinition' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, MinVelocity) == 0x000100, "Member 'UGbxAnimBlueprintProfile::MinVelocity' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, MaxVelocity) == 0x000104, "Member 'UGbxAnimBlueprintProfile::MaxVelocity' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, BoneToModify) == 0x000108, "Member 'UGbxAnimBlueprintProfile::BoneToModify' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, ParentBoneToModify) == 0x000120, "Member 'UGbxAnimBlueprintProfile::ParentBoneToModify' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, ParentLookAxis) == 0x000138, "Member 'UGbxAnimBlueprintProfile::ParentLookAxis' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, BonesToModify) == 0x000140, "Member 'UGbxAnimBlueprintProfile::BonesToModify' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeBonesToModify) == 0x000150, "Member 'UGbxAnimBlueprintProfile::EyeBonesToModify' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, LookAtBlinkAngleOverride) == 0x000160, "Member 'UGbxAnimBlueprintProfile::LookAtBlinkAngleOverride' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseLookAtBlinkAngleOverride) == 0x000164, "Member 'UGbxAnimBlueprintProfile::bUseLookAtBlinkAngleOverride' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseEyeMovement) == 0x000165, "Member 'UGbxAnimBlueprintProfile::bUseEyeMovement' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeShiftMin) == 0x000168, "Member 'UGbxAnimBlueprintProfile::EyeShiftMin' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeShiftMax) == 0x000174, "Member 'UGbxAnimBlueprintProfile::EyeShiftMax' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeGlanceMin) == 0x000180, "Member 'UGbxAnimBlueprintProfile::EyeGlanceMin' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeGlanceMax) == 0x00018C, "Member 'UGbxAnimBlueprintProfile::EyeGlanceMax' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeFocusTimeMin) == 0x000198, "Member 'UGbxAnimBlueprintProfile::EyeFocusTimeMin' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeFocusTimeMax) == 0x00019C, "Member 'UGbxAnimBlueprintProfile::EyeFocusTimeMax' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeGlanceTimeMin) == 0x0001A0, "Member 'UGbxAnimBlueprintProfile::EyeGlanceTimeMin' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeGlanceTimeMax) == 0x0001A4, "Member 'UGbxAnimBlueprintProfile::EyeGlanceTimeMax' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeShiftTimeMin) == 0x0001A8, "Member 'UGbxAnimBlueprintProfile::EyeShiftTimeMin' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, EyeShiftTimeMax) == 0x0001AC, "Member 'UGbxAnimBlueprintProfile::EyeShiftTimeMax' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, LookAtEyeLODThreshold) == 0x0001B0, "Member 'UGbxAnimBlueprintProfile::LookAtEyeLODThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, LookAtLODThreshold) == 0x0001B4, "Member 'UGbxAnimBlueprintProfile::LookAtLODThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, LookAtLODInterpolationSpeed) == 0x0001B8, "Member 'UGbxAnimBlueprintProfile::LookAtLODInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, LookAtEyeScreenSizeThreshold) == 0x0001C0, "Member 'UGbxAnimBlueprintProfile::LookAtEyeScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseLookAtEyeScreenSizeThreshold) == 0x0001D8, "Member 'UGbxAnimBlueprintProfile::bUseLookAtEyeScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, LookAtScreenSizeThreshold) == 0x0001E0, "Member 'UGbxAnimBlueprintProfile::LookAtScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseLookAtScreenSizeThreshold) == 0x0001F8, "Member 'UGbxAnimBlueprintProfile::bUseLookAtScreenSizeThreshold' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, ForwardDynamicsNodeList) == 0x000200, "Member 'UGbxAnimBlueprintProfile::ForwardDynamicsNodeList' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, PhysicsAsset) == 0x000210, "Member 'UGbxAnimBlueprintProfile::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, TeethOffsetOverride) == 0x000218, "Member 'UGbxAnimBlueprintProfile::TeethOffsetOverride' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseTeethOffsetOverride) == 0x000224, "Member 'UGbxAnimBlueprintProfile::bUseTeethOffsetOverride' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, UpperTeethBoneRef) == 0x000228, "Member 'UGbxAnimBlueprintProfile::UpperTeethBoneRef' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, BoneTagToBoneOverrideNameMap) == 0x000240, "Member 'UGbxAnimBlueprintProfile::BoneTagToBoneOverrideNameMap' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, bUseUpperTeethBoneRefOverride) == 0x000290, "Member 'UGbxAnimBlueprintProfile::bUseUpperTeethBoneRefOverride' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, DefaultIdleLoopAnimation) == 0x000298, "Member 'UGbxAnimBlueprintProfile::DefaultIdleLoopAnimation' has a wrong offset!");
static_assert(offsetof(UGbxAnimBlueprintProfile, SlotName) == 0x0002A0, "Member 'UGbxAnimBlueprintProfile::SlotName' has a wrong offset!");

// Class GbxGameSystemCore.StatusEffectStackingStrategyData_Capped
// 0x0010 (0x0040 - 0x0030)
class UStatusEffectStackingStrategyData_Capped final : public UStatusEffectStackingStrategyData
{
public:
	int32                                         MaxCount;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCapPerOwner;                                      // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNoInfiniteDuration;                               // 0x0035(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStatusEffectStackingInstanceSelectionCriteria SelectionCriteria;                                 // 0x0036(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStatusEffectStackingInstanceReplacementCriteria ReplacementCriteria;                               // 0x0037(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatusEffectStackingStrategyData_DurationRefundData DurationRefund;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectStackingStrategyData_Capped">();
	}
	static class UStatusEffectStackingStrategyData_Capped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectStackingStrategyData_Capped>();
	}
};
static_assert(alignof(UStatusEffectStackingStrategyData_Capped) == 0x000008, "Wrong alignment on UStatusEffectStackingStrategyData_Capped");
static_assert(sizeof(UStatusEffectStackingStrategyData_Capped) == 0x000040, "Wrong size on UStatusEffectStackingStrategyData_Capped");
static_assert(offsetof(UStatusEffectStackingStrategyData_Capped, MaxCount) == 0x000030, "Member 'UStatusEffectStackingStrategyData_Capped::MaxCount' has a wrong offset!");
static_assert(offsetof(UStatusEffectStackingStrategyData_Capped, bCapPerOwner) == 0x000034, "Member 'UStatusEffectStackingStrategyData_Capped::bCapPerOwner' has a wrong offset!");
static_assert(offsetof(UStatusEffectStackingStrategyData_Capped, bNoInfiniteDuration) == 0x000035, "Member 'UStatusEffectStackingStrategyData_Capped::bNoInfiniteDuration' has a wrong offset!");
static_assert(offsetof(UStatusEffectStackingStrategyData_Capped, SelectionCriteria) == 0x000036, "Member 'UStatusEffectStackingStrategyData_Capped::SelectionCriteria' has a wrong offset!");
static_assert(offsetof(UStatusEffectStackingStrategyData_Capped, ReplacementCriteria) == 0x000037, "Member 'UStatusEffectStackingStrategyData_Capped::ReplacementCriteria' has a wrong offset!");
static_assert(offsetof(UStatusEffectStackingStrategyData_Capped, DurationRefund) == 0x000038, "Member 'UStatusEffectStackingStrategyData_Capped::DurationRefund' has a wrong offset!");

// Class GbxGameSystemCore.GbxAnimStateMachineDefinition
// 0x0028 (0x0058 - 0x0030)
class UGbxAnimStateMachineDefinition final : public UGbxDataAsset
{
public:
	class FName                                   Name_0;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           StateMachines;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAnimStateGroup>                StateGroups;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateMachineDefinition">();
	}
	static class UGbxAnimStateMachineDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateMachineDefinition>();
	}
};
static_assert(alignof(UGbxAnimStateMachineDefinition) == 0x000008, "Wrong alignment on UGbxAnimStateMachineDefinition");
static_assert(sizeof(UGbxAnimStateMachineDefinition) == 0x000058, "Wrong size on UGbxAnimStateMachineDefinition");
static_assert(offsetof(UGbxAnimStateMachineDefinition, Name_0) == 0x000030, "Member 'UGbxAnimStateMachineDefinition::Name_0' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateMachineDefinition, StateMachines) == 0x000038, "Member 'UGbxAnimStateMachineDefinition::StateMachines' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateMachineDefinition, StateGroups) == 0x000048, "Member 'UGbxAnimStateMachineDefinition::StateGroups' has a wrong offset!");

// Class GbxGameSystemCore.GbxAnimStateManager_Falling
// 0x0010 (0x0048 - 0x0038)
class UGbxAnimStateManager_Falling final : public UGbxAnimStateManager
{
public:
	class UGbxCharacterAnimInstance*              GbxCharAnimInst;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxCharacterMovementComponent*         GbxCharMoveComponent;                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_Falling">();
	}
	static class UGbxAnimStateManager_Falling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_Falling>();
	}
};
static_assert(alignof(UGbxAnimStateManager_Falling) == 0x000008, "Wrong alignment on UGbxAnimStateManager_Falling");
static_assert(sizeof(UGbxAnimStateManager_Falling) == 0x000048, "Wrong size on UGbxAnimStateManager_Falling");
static_assert(offsetof(UGbxAnimStateManager_Falling, GbxCharAnimInst) == 0x000038, "Member 'UGbxAnimStateManager_Falling::GbxCharAnimInst' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Falling, GbxCharMoveComponent) == 0x000040, "Member 'UGbxAnimStateManager_Falling::GbxCharMoveComponent' has a wrong offset!");

// Class GbxGameSystemCore.SignificanceInterface
// 0x0000 (0x0028 - 0x0028)
class ISignificanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignificanceInterface">();
	}
	static class ISignificanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISignificanceInterface>();
	}
};
static_assert(alignof(ISignificanceInterface) == 0x000008, "Wrong alignment on ISignificanceInterface");
static_assert(sizeof(ISignificanceInterface) == 0x000028, "Wrong size on ISignificanceInterface");

// Class GbxGameSystemCore.GbxAnimStateManager_RootMotion
// 0x0008 (0x0040 - 0x0038)
class UGbxAnimStateManager_RootMotion : public UGbxAnimStateManager
{
public:
	class UGbxCharacterMovementComponent*         GbxCharMoveComponent;                              // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_RootMotion">();
	}
	static class UGbxAnimStateManager_RootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_RootMotion>();
	}
};
static_assert(alignof(UGbxAnimStateManager_RootMotion) == 0x000008, "Wrong alignment on UGbxAnimStateManager_RootMotion");
static_assert(sizeof(UGbxAnimStateManager_RootMotion) == 0x000040, "Wrong size on UGbxAnimStateManager_RootMotion");
static_assert(offsetof(UGbxAnimStateManager_RootMotion, GbxCharMoveComponent) == 0x000038, "Member 'UGbxAnimStateManager_RootMotion::GbxCharMoveComponent' has a wrong offset!");

// Class GbxGameSystemCore.GbxAttributeData
// 0x0010 (0x0040 - 0x0030)
class UGbxAttributeData final : public UGbxDataAsset
{
public:
	class UAttributeContextResolver*              ContextResolver;                                   // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAttributeValueResolver*                ValueResolver;                                     // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanAddAndRemoveModifiers() const;
	bool CanAddModifiers() const;
	bool CanBindToOnChangedEvent() const;
	bool CanSetBaseValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributeData">();
	}
	static class UGbxAttributeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributeData>();
	}
};
static_assert(alignof(UGbxAttributeData) == 0x000008, "Wrong alignment on UGbxAttributeData");
static_assert(sizeof(UGbxAttributeData) == 0x000040, "Wrong size on UGbxAttributeData");
static_assert(offsetof(UGbxAttributeData, ContextResolver) == 0x000030, "Member 'UGbxAttributeData::ContextResolver' has a wrong offset!");
static_assert(offsetof(UGbxAttributeData, ValueResolver) == 0x000038, "Member 'UGbxAttributeData::ValueResolver' has a wrong offset!");

// Class GbxGameSystemCore.TargetingDebugServerRpcComponent
// 0x0000 (0x0178 - 0x0178)
class UTargetingDebugServerRpcComponent final : public UActorComponent
{
public:
	void SetInspectedActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingDebugServerRpcComponent">();
	}
	static class UTargetingDebugServerRpcComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingDebugServerRpcComponent>();
	}
};
static_assert(alignof(UTargetingDebugServerRpcComponent) == 0x000008, "Wrong alignment on UTargetingDebugServerRpcComponent");
static_assert(sizeof(UTargetingDebugServerRpcComponent) == 0x000178, "Wrong size on UTargetingDebugServerRpcComponent");

// Class GbxGameSystemCore.GbxAttributeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxAttributeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGbxAttributeModifierHandle AddModifierToGbxAttribute(class UGbxAttributeData* Attribute, class UObject* ContextSource, EGbxAttributeModifierType ModifierType, float ModifierValue, EGbxAttributeModifierActionExecOutput* ModifierActionResult);
	static void ApplyAttributeBaseValueData(const struct FAttributeBaseValueData& BaseValueData, class UObject* AttributeToSetContextSource, class UObject* ValueContext, EGbxAttributeModifierActionExecOutput* ModifierActionResult);
	static struct FGbxAttributeModifierHandle ApplyAttributeEffect(const struct FAttributeEffectData& Effect, class UObject* ModifierValueContext, class UObject* AttributeToModifyContextSource, EGbxAttributeModifierActionExecOutput* ModifierActionResult);
	static void ApplyMultipleAttributeBaseValueData(const TArray<struct FAttributeBaseValueData>& BaseValueData, class UObject* AttributeToSetContextSource, class UObject* ValueContext);
	static TArray<struct FGbxAttributeModifierHandle> ApplyMultipleAttributeEffects(const TArray<struct FAttributeEffectData>& Effects, class UObject* ModifierValueContext, class UObject* AttributeToModifyContextSource);
	static struct FGbxAttributeDelegateBindingHandle BindEventToOnAttributeChanged(class UGbxAttributeData* Attribute, class UObject* ContextSource, const TDelegate<void(float OldValue, float NewValue)>& Delegate);
	static void BindEventToOnFloatAttributeChanged(struct FGbxAttributeFloat& Attribute, const TDelegate<void(float OldValue, float NewValue)>& Delegate);
	static void BindEventToOnIntegerAttributeChanged(struct FGbxAttributeInteger& Attribute, const TDelegate<void(float OldValue, float NewValue)>& Delegate);
	static void BreakGbxAttributeFloat(const struct FGbxAttributeFloat& Attribute, float* Value, float* BaseValue);
	static void BreakGbxAttributeInteger(const struct FGbxAttributeInteger& Attribute, int32* Value, int32* BaseValue);
	static class FString Conv_AttributeInitializationDataToString(const struct FAttributeInitializationData& InitData);
	static float Conv_GbxAttributeFloatToFloat(const struct FGbxAttributeFloat& Attribute);
	static class FString Conv_GbxAttributeFloatToString(const struct FGbxAttributeFloat& Attribute);
	static int32 Conv_GbxAttributeIntegerToInteger(const struct FGbxAttributeInteger& Attribute);
	static class FString Conv_GbxAttributeIntegerToString(const struct FGbxAttributeInteger& Attribute);
	static class FString Conv_GbxAttributeModifierHandleToString(const struct FGbxAttributeModifierHandle& Attribute);
	static bool EqualEqual_GbxAttributeFloat(const struct FGbxAttributeFloat& A, const struct FGbxAttributeFloat& B);
	static bool EqualEqual_GbxAttributeFloatValue(const struct FGbxAttributeFloat& A, float B);
	static bool EqualEqual_GbxAttributeInteger(const struct FGbxAttributeInteger& A, const struct FGbxAttributeInteger& B);
	static bool EqualEqual_GbxAttributeIntegerValue(const struct FGbxAttributeInteger& A, int32 B);
	static float EvaluateAttributeInitializationData(const struct FAttributeInitializationData& InitializationData, class UObject* ContextSource);
	static float EvaluateAttributeInitializer(TSubclassOf<class UAttributeInitializer> Initializer, class UObject* ContextSource);
	static float GetValueFromAttributeDefinedRow(const struct FDataTableRowHandle& RowHandle, class UObject* ContextSource);
	static float GetValueOfAttribute(const class UGbxAttributeData* Attribute, class UObject* ContextSource, float DefaultValue);
	static bool GetValueOfAttributeAsBoolean(const class UGbxAttributeData* Attribute, class UObject* ContextSource, bool DefaultValue);
	static int32 GetValueOfAttributeAsInteger(const class UGbxAttributeData* Attribute, class UObject* ContextSource, int32 DefaultValue);
	static struct FGbxAttributeFloat MakeGbxAttributeFloat(float BaseValue);
	static struct FGbxAttributeInteger MakeGbxAttributeInteger(int32 BaseValue);
	static struct FGbxAttributeDelegateBindingHandle RefreshBindingToOnAttributeChangedEvent(const struct FGbxAttributeDelegateBindingHandle& BindingHandle, class UObject* ContextSource);
	static bool RemoveAttributeModifier(struct FGbxAttributeModifierHandle& ModifierHandle);
	static void RemoveModifierFromGbxAttribute(class UGbxAttributeData* Attribute, class UObject* ContextSource, struct FGbxAttributeModifierHandle& ModifierHandle, EGbxAttributeModifierActionExecOutput* ModifierActionResult);
	static void RemoveMultipleAttributeModifiers(TArray<struct FGbxAttributeModifierHandle>& ModifierHandles);
	static void UnbindAllEventsFromOnFloatAttributeChanged(struct FGbxAttributeFloat& Attribute);
	static void UnbindAllEventsFromOnIntegerAttributeChanged(struct FGbxAttributeInteger& Attribute);
	static void UnbindEventFromOnFloatAttributeChanged(struct FGbxAttributeFloat& Attribute, const TDelegate<void(float OldValue, float NewValue)>& Delegate);
	static void UnbindEventFromOnIntegerAttributeChanged(struct FGbxAttributeInteger& Attribute, const TDelegate<void(float OldValue, float NewValue)>& Delegate);
	static void UnbindFromOnAttributeChanged(const struct FGbxAttributeDelegateBindingHandle& BindingHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributeFunctionLibrary">();
	}
	static class UGbxAttributeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributeFunctionLibrary>();
	}
};
static_assert(alignof(UGbxAttributeFunctionLibrary) == 0x000008, "Wrong alignment on UGbxAttributeFunctionLibrary");
static_assert(sizeof(UGbxAttributeFunctionLibrary) == 0x000028, "Wrong size on UGbxAttributeFunctionLibrary");

// Class GbxGameSystemCore.GbxAttributesComponent
// 0x0010 (0x0188 - 0x0178)
class UGbxAttributesComponent : public UActorComponent
{
public:
	TArray<class UGbxAttributeSet*>               AttributeSets;                                     // 0x0178(0x0010)(Edit, ExportObject, Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool IsAttributeSetClassUnrelatedToExistingSet(const class UClass* AttributeSetClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributesComponent">();
	}
	static class UGbxAttributesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributesComponent>();
	}
};
static_assert(alignof(UGbxAttributesComponent) == 0x000008, "Wrong alignment on UGbxAttributesComponent");
static_assert(sizeof(UGbxAttributesComponent) == 0x000188, "Wrong size on UGbxAttributesComponent");
static_assert(offsetof(UGbxAttributesComponent, AttributeSets) == 0x000178, "Member 'UGbxAttributesComponent::AttributeSets' has a wrong offset!");

// Class GbxGameSystemCore.GbxAttributeSet
// 0x0008 (0x0030 - 0x0028)
class UGbxAttributeSet final : public UObject
{
public:
	class UAttributeContextResolver*              ContextResolver;                                   // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributeSet">();
	}
	static class UGbxAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributeSet>();
	}
};
static_assert(alignof(UGbxAttributeSet) == 0x000008, "Wrong alignment on UGbxAttributeSet");
static_assert(sizeof(UGbxAttributeSet) == 0x000030, "Wrong size on UGbxAttributeSet");
static_assert(offsetof(UGbxAttributeSet, ContextResolver) == 0x000028, "Member 'UGbxAttributeSet::ContextResolver' has a wrong offset!");

// Class GbxGameSystemCore.GbxAttributeSetBlueprint
// 0x0010 (0x00F8 - 0x00E8)
class UGbxAttributeSetBlueprint final : public UBlueprint
{
public:
	TArray<struct FPropertyToAttributeMapping>    PropertyToAttributeMapping;                        // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributeSetBlueprint">();
	}
	static class UGbxAttributeSetBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributeSetBlueprint>();
	}
};
static_assert(alignof(UGbxAttributeSetBlueprint) == 0x000008, "Wrong alignment on UGbxAttributeSetBlueprint");
static_assert(sizeof(UGbxAttributeSetBlueprint) == 0x0000F8, "Wrong size on UGbxAttributeSetBlueprint");
static_assert(offsetof(UGbxAttributeSetBlueprint, PropertyToAttributeMapping) == 0x0000E8, "Member 'UGbxAttributeSetBlueprint::PropertyToAttributeMapping' has a wrong offset!");

// Class GbxGameSystemCore.TrivialFoleyImplementationComponent
// 0x0038 (0x01B0 - 0x0178)
class UTrivialFoleyImplementationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            FootstepImpact;                                    // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      FootstepPhysmat;                                   // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 BodySkeletalMesh;                                  // 0x0190(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FootSockets;                                       // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFoleyMainComponent*                    CachedFoleyMainComponent;                          // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrivialFoleyImplementationComponent">();
	}
	static class UTrivialFoleyImplementationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrivialFoleyImplementationComponent>();
	}
};
static_assert(alignof(UTrivialFoleyImplementationComponent) == 0x000008, "Wrong alignment on UTrivialFoleyImplementationComponent");
static_assert(sizeof(UTrivialFoleyImplementationComponent) == 0x0001B0, "Wrong size on UTrivialFoleyImplementationComponent");
static_assert(offsetof(UTrivialFoleyImplementationComponent, FootstepImpact) == 0x000180, "Member 'UTrivialFoleyImplementationComponent::FootstepImpact' has a wrong offset!");
static_assert(offsetof(UTrivialFoleyImplementationComponent, FootstepPhysmat) == 0x000188, "Member 'UTrivialFoleyImplementationComponent::FootstepPhysmat' has a wrong offset!");
static_assert(offsetof(UTrivialFoleyImplementationComponent, BodySkeletalMesh) == 0x000190, "Member 'UTrivialFoleyImplementationComponent::BodySkeletalMesh' has a wrong offset!");
static_assert(offsetof(UTrivialFoleyImplementationComponent, FootSockets) == 0x000198, "Member 'UTrivialFoleyImplementationComponent::FootSockets' has a wrong offset!");
static_assert(offsetof(UTrivialFoleyImplementationComponent, CachedFoleyMainComponent) == 0x0001A8, "Member 'UTrivialFoleyImplementationComponent::CachedFoleyMainComponent' has a wrong offset!");

// Class GbxGameSystemCore.GbxAttributeSetContextResolver
// 0x0008 (0x0058 - 0x0050)
class UGbxAttributeSetContextResolver final : public UAttributeContextResolver
{
public:
	TSubclassOf<class UGbxAttributeSet>           AttributeSetClass;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributeSetContextResolver">();
	}
	static class UGbxAttributeSetContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributeSetContextResolver>();
	}
};
static_assert(alignof(UGbxAttributeSetContextResolver) == 0x000008, "Wrong alignment on UGbxAttributeSetContextResolver");
static_assert(sizeof(UGbxAttributeSetContextResolver) == 0x000058, "Wrong size on UGbxAttributeSetContextResolver");
static_assert(offsetof(UGbxAttributeSetContextResolver, AttributeSetClass) == 0x000050, "Member 'UGbxAttributeSetContextResolver::AttributeSetClass' has a wrong offset!");

// Class GbxGameSystemCore.GbxAttributeSetValueResolver
// 0x0000 (0x00B0 - 0x00B0)
class UGbxAttributeSetValueResolver final : public UAttributePropertyValueResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAttributeSetValueResolver">();
	}
	static class UGbxAttributeSetValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAttributeSetValueResolver>();
	}
};
static_assert(alignof(UGbxAttributeSetValueResolver) == 0x000008, "Wrong alignment on UGbxAttributeSetValueResolver");
static_assert(sizeof(UGbxAttributeSetValueResolver) == 0x0000B0, "Wrong size on UGbxAttributeSetValueResolver");

// Class GbxGameSystemCore.StatusEffect
// 0x0040 (0x0068 - 0x0028)
class UStatusEffect final : public UObject
{
public:
	class UStatusEffectStackingStrategyData*      StackingStrategy;                                  // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAttributeEffect>               AttributeEffects;                                  // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bDoesDamageOverTime;                               // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageSource>              DamageSourceClass;                                 // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectData*                      DataAssetCopy;                                     // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginEffect(class AActor* Target) const;
	void OnEndEffect(class AActor* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect">();
	}
	static class UStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect>();
	}
};
static_assert(alignof(UStatusEffect) == 0x000008, "Wrong alignment on UStatusEffect");
static_assert(sizeof(UStatusEffect) == 0x000068, "Wrong size on UStatusEffect");
static_assert(offsetof(UStatusEffect, StackingStrategy) == 0x000028, "Member 'UStatusEffect::StackingStrategy' has a wrong offset!");
static_assert(offsetof(UStatusEffect, AttributeEffects) == 0x000030, "Member 'UStatusEffect::AttributeEffects' has a wrong offset!");
static_assert(offsetof(UStatusEffect, bDoesDamageOverTime) == 0x000040, "Member 'UStatusEffect::bDoesDamageOverTime' has a wrong offset!");
static_assert(offsetof(UStatusEffect, DamageType) == 0x000048, "Member 'UStatusEffect::DamageType' has a wrong offset!");
static_assert(offsetof(UStatusEffect, DamageSourceClass) == 0x000050, "Member 'UStatusEffect::DamageSourceClass' has a wrong offset!");
static_assert(offsetof(UStatusEffect, DataAssetCopy) == 0x000058, "Member 'UStatusEffect::DataAssetCopy' has a wrong offset!");

// Class GbxGameSystemCore.GbxBlackboardKeySelectorExt
// 0x0000 (0x0028 - 0x0028)
class UGbxBlackboardKeySelectorExt final : public UBlueprintFunctionLibrary
{
public:
	static void ClearValue(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static class FString GetPropertyDescription(const struct FGbxBlackboardKeySelector& BBKey, class UProperty* Property);
	static class AActor* GetValueAsActor(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static bool GetValueAsBool(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static class UClass* GetValueAsClass(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static uint8 GetValueAsEnum(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static float GetValueAsFloat(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static int32 GetValueAsInt(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static class FName GetValueAsName(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static class UObject* GetValueAsObject(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static struct FRotator GetValueAsRotator(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static class FString GetValueAsString(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static struct FTargetActorInfo GetValueAsTargetActorInfo(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static struct FVector GetValueAsVector(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent);
	static void SetValueAsBool(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, bool Value);
	static void SetValueAsClass(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, class UClass* Value);
	static void SetValueAsEnum(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, uint8 Value);
	static void SetValueAsFlag(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const bool Value, float Duration);
	static void SetValueAsFloat(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, float Value);
	static void SetValueAsInt(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, int32 Value);
	static void SetValueAsName(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, class FName Value);
	static void SetValueAsObject(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, class UObject* Value);
	static void SetValueAsRotator(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const struct FRotator& Value);
	static void SetValueAsString(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const class FString& Value);
	static void SetValueAsTargetActorInfo(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const struct FTargetActorInfo& Value);
	static void SetValueAsVector(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const struct FVector& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxBlackboardKeySelectorExt">();
	}
	static class UGbxBlackboardKeySelectorExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxBlackboardKeySelectorExt>();
	}
};
static_assert(alignof(UGbxBlackboardKeySelectorExt) == 0x000008, "Wrong alignment on UGbxBlackboardKeySelectorExt");
static_assert(sizeof(UGbxBlackboardKeySelectorExt) == 0x000028, "Wrong size on UGbxBlackboardKeySelectorExt");

// Class GbxGameSystemCore.UsabilityDataSelection
// 0x0088 (0x00B8 - 0x0030)
class UUsabilityDataSelection final : public UGbxDataAsset
{
public:
	class UGbxCondition*                          EnabledCondition;                                  // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       PrimaryUseDefSelection;                            // 0x0038(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       PrimaryHoldUseDefSelection;                        // 0x0058(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       SecondaryUseDefSelection;                          // 0x0078(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUseDefSelection                       SecondaryHoldUseDefSelection;                      // 0x0098(0x0020)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsabilityDataSelection">();
	}
	static class UUsabilityDataSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsabilityDataSelection>();
	}
};
static_assert(alignof(UUsabilityDataSelection) == 0x000008, "Wrong alignment on UUsabilityDataSelection");
static_assert(sizeof(UUsabilityDataSelection) == 0x0000B8, "Wrong size on UUsabilityDataSelection");
static_assert(offsetof(UUsabilityDataSelection, EnabledCondition) == 0x000030, "Member 'UUsabilityDataSelection::EnabledCondition' has a wrong offset!");
static_assert(offsetof(UUsabilityDataSelection, PrimaryUseDefSelection) == 0x000038, "Member 'UUsabilityDataSelection::PrimaryUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsabilityDataSelection, PrimaryHoldUseDefSelection) == 0x000058, "Member 'UUsabilityDataSelection::PrimaryHoldUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsabilityDataSelection, SecondaryUseDefSelection) == 0x000078, "Member 'UUsabilityDataSelection::SecondaryUseDefSelection' has a wrong offset!");
static_assert(offsetof(UUsabilityDataSelection, SecondaryHoldUseDefSelection) == 0x000098, "Member 'UUsabilityDataSelection::SecondaryHoldUseDefSelection' has a wrong offset!");

// Class GbxGameSystemCore.GbxCameraShake
// 0x0000 (0x0180 - 0x0180)
class UGbxCameraShake final : public UCameraShake
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCameraShake">();
	}
	static class UGbxCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCameraShake>();
	}
};
static_assert(alignof(UGbxCameraShake) == 0x000008, "Wrong alignment on UGbxCameraShake");
static_assert(sizeof(UGbxCameraShake) == 0x000180, "Wrong size on UGbxCameraShake");

// Class GbxGameSystemCore.GbxCondition_ActorIsOfClass
// 0x0010 (0x0098 - 0x0088)
class UGbxCondition_ActorIsOfClass final : public UGbxCondition
{
public:
	class UClass*                                 InputClass;                                        // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckAbsolute;                                    // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_ActorIsOfClass">();
	}
	static class UGbxCondition_ActorIsOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_ActorIsOfClass>();
	}
};
static_assert(alignof(UGbxCondition_ActorIsOfClass) == 0x000008, "Wrong alignment on UGbxCondition_ActorIsOfClass");
static_assert(sizeof(UGbxCondition_ActorIsOfClass) == 0x000098, "Wrong size on UGbxCondition_ActorIsOfClass");
static_assert(offsetof(UGbxCondition_ActorIsOfClass, InputClass) == 0x000088, "Member 'UGbxCondition_ActorIsOfClass::InputClass' has a wrong offset!");
static_assert(offsetof(UGbxCondition_ActorIsOfClass, bCheckAbsolute) == 0x000090, "Member 'UGbxCondition_ActorIsOfClass::bCheckAbsolute' has a wrong offset!");

// Class GbxGameSystemCore.SceneBodySwitchFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class USceneBodySwitchFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeSwitch(class UObject* Context, class FName SwitchName, class FName StateName);
	static void ChangeSwitchExternal(class AActor* Actor, class FName SwitchName, class FName StateName);

	void EnumerateValidSwitchNames(TArray<class FName>* Names) const;
	void EnumerateValidSwitchStateNames(class FName SwitchName, TArray<class FName>* Names) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneBodySwitchFunctionLibrary">();
	}
	static class USceneBodySwitchFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneBodySwitchFunctionLibrary>();
	}
};
static_assert(alignof(USceneBodySwitchFunctionLibrary) == 0x000008, "Wrong alignment on USceneBodySwitchFunctionLibrary");
static_assert(sizeof(USceneBodySwitchFunctionLibrary) == 0x000028, "Wrong size on USceneBodySwitchFunctionLibrary");

// Class GbxGameSystemCore.GbxCondition_AttackedRecently
// 0x0080 (0x0108 - 0x0088)
class UGbxCondition_AttackedRecently final : public UGbxCondition
{
public:
	struct FGbxParam                              AttackedWithin;                                    // 0x0088(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_AttackedRecently">();
	}
	static class UGbxCondition_AttackedRecently* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_AttackedRecently>();
	}
};
static_assert(alignof(UGbxCondition_AttackedRecently) == 0x000008, "Wrong alignment on UGbxCondition_AttackedRecently");
static_assert(sizeof(UGbxCondition_AttackedRecently) == 0x000108, "Wrong size on UGbxCondition_AttackedRecently");
static_assert(offsetof(UGbxCondition_AttackedRecently, AttackedWithin) == 0x000088, "Member 'UGbxCondition_AttackedRecently::AttackedWithin' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_Blueprint
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_Blueprint : public UGbxCondition
{
public:
	bool EvaluateCondition(class UObject* Context, class UObject* OptionalContext) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_Blueprint">();
	}
	static class UGbxCondition_Blueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_Blueprint>();
	}
};
static_assert(alignof(UGbxCondition_Blueprint) == 0x000008, "Wrong alignment on UGbxCondition_Blueprint");
static_assert(sizeof(UGbxCondition_Blueprint) == 0x000088, "Wrong size on UGbxCondition_Blueprint");

// Class GbxGameSystemCore.GbxCondition_CharacterMass
// 0x0020 (0x00A8 - 0x0088)
class UGbxCondition_CharacterMass final : public UGbxCondition
{
public:
	EMassComparison                               ComparisonTest;                                    // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMassSelection                         Mass;                                              // 0x0090(0x0018)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_CharacterMass">();
	}
	static class UGbxCondition_CharacterMass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_CharacterMass>();
	}
};
static_assert(alignof(UGbxCondition_CharacterMass) == 0x000008, "Wrong alignment on UGbxCondition_CharacterMass");
static_assert(sizeof(UGbxCondition_CharacterMass) == 0x0000A8, "Wrong size on UGbxCondition_CharacterMass");
static_assert(offsetof(UGbxCondition_CharacterMass, ComparisonTest) == 0x000088, "Member 'UGbxCondition_CharacterMass::ComparisonTest' has a wrong offset!");
static_assert(offsetof(UGbxCondition_CharacterMass, Mass) == 0x000090, "Member 'UGbxCondition_CharacterMass::Mass' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_Comparison
// 0x0078 (0x0100 - 0x0088)
class UGbxCondition_Comparison final : public UGbxCondition
{
public:
	struct FAttributeInitializationData           OperandA;                                          // 0x0088(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	EConditionComparisonOperatorType              Operator;                                          // 0x00C0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           OperandB;                                          // 0x00C8(0x0038)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_Comparison">();
	}
	static class UGbxCondition_Comparison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_Comparison>();
	}
};
static_assert(alignof(UGbxCondition_Comparison) == 0x000008, "Wrong alignment on UGbxCondition_Comparison");
static_assert(sizeof(UGbxCondition_Comparison) == 0x000100, "Wrong size on UGbxCondition_Comparison");
static_assert(offsetof(UGbxCondition_Comparison, OperandA) == 0x000088, "Member 'UGbxCondition_Comparison::OperandA' has a wrong offset!");
static_assert(offsetof(UGbxCondition_Comparison, Operator) == 0x0000C0, "Member 'UGbxCondition_Comparison::Operator' has a wrong offset!");
static_assert(offsetof(UGbxCondition_Comparison, OperandB) == 0x0000C8, "Member 'UGbxCondition_Comparison::OperandB' has a wrong offset!");

// Class GbxGameSystemCore.TeleportInterface
// 0x0000 (0x0028 - 0x0028)
class ITeleportInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportInterface">();
	}
	static class ITeleportInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeleportInterface>();
	}
};
static_assert(alignof(ITeleportInterface) == 0x000008, "Wrong alignment on ITeleportInterface");
static_assert(sizeof(ITeleportInterface) == 0x000028, "Wrong size on ITeleportInterface");

// Class GbxGameSystemCore.GbxCondition_Compound
// 0x0018 (0x00A0 - 0x0088)
class UGbxCondition_Compound final : public UGbxCondition
{
public:
	class UGbxCondition*                          Condition1;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECompoundConditionOperatorType                Operator;                                          // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          Condition2;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_Compound">();
	}
	static class UGbxCondition_Compound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_Compound>();
	}
};
static_assert(alignof(UGbxCondition_Compound) == 0x000008, "Wrong alignment on UGbxCondition_Compound");
static_assert(sizeof(UGbxCondition_Compound) == 0x0000A0, "Wrong size on UGbxCondition_Compound");
static_assert(offsetof(UGbxCondition_Compound, Condition1) == 0x000088, "Member 'UGbxCondition_Compound::Condition1' has a wrong offset!");
static_assert(offsetof(UGbxCondition_Compound, Operator) == 0x000090, "Member 'UGbxCondition_Compound::Operator' has a wrong offset!");
static_assert(offsetof(UGbxCondition_Compound, Condition2) == 0x000098, "Member 'UGbxCondition_Compound::Condition2' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_Flag
// 0x0048 (0x00D0 - 0x0088)
class UGbxCondition_Flag final : public UGbxCondition
{
public:
	struct FGbxFlagEval                           FlagEval;                                          // 0x0088(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_Flag">();
	}
	static class UGbxCondition_Flag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_Flag>();
	}
};
static_assert(alignof(UGbxCondition_Flag) == 0x000008, "Wrong alignment on UGbxCondition_Flag");
static_assert(sizeof(UGbxCondition_Flag) == 0x0000D0, "Wrong size on UGbxCondition_Flag");
static_assert(offsetof(UGbxCondition_Flag, FlagEval) == 0x000088, "Member 'UGbxCondition_Flag::FlagEval' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_HasActorTags
// 0x0010 (0x0098 - 0x0088)
class UGbxCondition_HasActorTags final : public UGbxCondition
{
public:
	struct FActorTagCompositeQuery                ActorTagQuery;                                     // 0x0088(0x0010)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasActorTags">();
	}
	static class UGbxCondition_HasActorTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasActorTags>();
	}
};
static_assert(alignof(UGbxCondition_HasActorTags) == 0x000008, "Wrong alignment on UGbxCondition_HasActorTags");
static_assert(sizeof(UGbxCondition_HasActorTags) == 0x000098, "Wrong size on UGbxCondition_HasActorTags");
static_assert(offsetof(UGbxCondition_HasActorTags, ActorTagQuery) == 0x000088, "Member 'UGbxCondition_HasActorTags::ActorTagQuery' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_HasGameplayTags
// 0x0020 (0x00A8 - 0x0088)
class UGbxCondition_HasGameplayTags final : public UGbxCondition
{
public:
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0088(0x0020)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasGameplayTags">();
	}
	static class UGbxCondition_HasGameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasGameplayTags>();
	}
};
static_assert(alignof(UGbxCondition_HasGameplayTags) == 0x000008, "Wrong alignment on UGbxCondition_HasGameplayTags");
static_assert(sizeof(UGbxCondition_HasGameplayTags) == 0x0000A8, "Wrong size on UGbxCondition_HasGameplayTags");
static_assert(offsetof(UGbxCondition_HasGameplayTags, GameplayTags) == 0x000088, "Member 'UGbxCondition_HasGameplayTags::GameplayTags' has a wrong offset!");

// Class GbxGameSystemCore.SprintData
// 0x0038 (0x0068 - 0x0030)
class USprintData final : public UDataAsset
{
public:
	class UCurveFloat*                            SprintFOVCurve;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddModifierToBaseFOV;                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintFOVModifier;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFOVBlendInTime;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFOVBlendOutTime;                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFOVBlendInDelay;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          Feedback;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAttributeEffectData>           SprintAttributeEffects;                            // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintData">();
	}
	static class USprintData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintData>();
	}
};
static_assert(alignof(USprintData) == 0x000008, "Wrong alignment on USprintData");
static_assert(sizeof(USprintData) == 0x000068, "Wrong size on USprintData");
static_assert(offsetof(USprintData, SprintFOVCurve) == 0x000030, "Member 'USprintData::SprintFOVCurve' has a wrong offset!");
static_assert(offsetof(USprintData, bAddModifierToBaseFOV) == 0x000038, "Member 'USprintData::bAddModifierToBaseFOV' has a wrong offset!");
static_assert(offsetof(USprintData, SprintFOVModifier) == 0x00003C, "Member 'USprintData::SprintFOVModifier' has a wrong offset!");
static_assert(offsetof(USprintData, SprintFOVBlendInTime) == 0x000040, "Member 'USprintData::SprintFOVBlendInTime' has a wrong offset!");
static_assert(offsetof(USprintData, SprintFOVBlendOutTime) == 0x000044, "Member 'USprintData::SprintFOVBlendOutTime' has a wrong offset!");
static_assert(offsetof(USprintData, SprintFOVBlendInDelay) == 0x000048, "Member 'USprintData::SprintFOVBlendInDelay' has a wrong offset!");
static_assert(offsetof(USprintData, Feedback) == 0x000050, "Member 'USprintData::Feedback' has a wrong offset!");
static_assert(offsetof(USprintData, SprintAttributeEffects) == 0x000058, "Member 'USprintData::SprintAttributeEffects' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_HasInstigatedStatusEffect
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_HasInstigatedStatusEffect final : public UGbxCondition
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasInstigatedStatusEffect">();
	}
	static class UGbxCondition_HasInstigatedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasInstigatedStatusEffect>();
	}
};
static_assert(alignof(UGbxCondition_HasInstigatedStatusEffect) == 0x000008, "Wrong alignment on UGbxCondition_HasInstigatedStatusEffect");
static_assert(sizeof(UGbxCondition_HasInstigatedStatusEffect) == 0x000090, "Wrong size on UGbxCondition_HasInstigatedStatusEffect");
static_assert(offsetof(UGbxCondition_HasInstigatedStatusEffect, StatusEffectData) == 0x000088, "Member 'UGbxCondition_HasInstigatedStatusEffect::StatusEffectData' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_IsLowOnHealth
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_IsLowOnHealth final : public UGbxCondition
{
public:
	float                                         LowHealth;                                         // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEvaluateOnContextOwner;                           // 0x008C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsLowOnHealth">();
	}
	static class UGbxCondition_IsLowOnHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsLowOnHealth>();
	}
};
static_assert(alignof(UGbxCondition_IsLowOnHealth) == 0x000008, "Wrong alignment on UGbxCondition_IsLowOnHealth");
static_assert(sizeof(UGbxCondition_IsLowOnHealth) == 0x000090, "Wrong size on UGbxCondition_IsLowOnHealth");
static_assert(offsetof(UGbxCondition_IsLowOnHealth, LowHealth) == 0x000088, "Member 'UGbxCondition_IsLowOnHealth::LowHealth' has a wrong offset!");
static_assert(offsetof(UGbxCondition_IsLowOnHealth, bEvaluateOnContextOwner) == 0x00008C, "Member 'UGbxCondition_IsLowOnHealth::bEvaluateOnContextOwner' has a wrong offset!");

// Class GbxGameSystemCore.UserStatesInterface
// 0x0000 (0x0028 - 0x0028)
class IUserStatesInterface final : public IInterface
{
public:
	void BlueprintStateHandler(bool bFromLoad);

	bool HasEnableConditionsSetForAnyUserState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserStatesInterface">();
	}
	static class IUserStatesInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUserStatesInterface>();
	}
};
static_assert(alignof(IUserStatesInterface) == 0x000008, "Wrong alignment on IUserStatesInterface");
static_assert(sizeof(IUserStatesInterface) == 0x000028, "Wrong size on IUserStatesInterface");

// Class GbxGameSystemCore.GbxCondition_IsTargetAimedAtMe
// 0x0080 (0x0108 - 0x0088)
class UGbxCondition_IsTargetAimedAtMe final : public UGbxCondition
{
public:
	struct FGbxParam                              AngleThreshold;                                    // 0x0088(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsTargetAimedAtMe">();
	}
	static class UGbxCondition_IsTargetAimedAtMe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsTargetAimedAtMe>();
	}
};
static_assert(alignof(UGbxCondition_IsTargetAimedAtMe) == 0x000008, "Wrong alignment on UGbxCondition_IsTargetAimedAtMe");
static_assert(sizeof(UGbxCondition_IsTargetAimedAtMe) == 0x000108, "Wrong size on UGbxCondition_IsTargetAimedAtMe");
static_assert(offsetof(UGbxCondition_IsTargetAimedAtMe, AngleThreshold) == 0x000088, "Member 'UGbxCondition_IsTargetAimedAtMe::AngleThreshold' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_IsTrue
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_IsTrue final : public UGbxCondition
{
public:
	bool                                          bIsTrue;                                           // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsTrue">();
	}
	static class UGbxCondition_IsTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsTrue>();
	}
};
static_assert(alignof(UGbxCondition_IsTrue) == 0x000008, "Wrong alignment on UGbxCondition_IsTrue");
static_assert(sizeof(UGbxCondition_IsTrue) == 0x000090, "Wrong size on UGbxCondition_IsTrue");
static_assert(offsetof(UGbxCondition_IsTrue, bIsTrue) == 0x000088, "Member 'UGbxCondition_IsTrue::bIsTrue' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_List
// 0x0018 (0x00A0 - 0x0088)
class UGbxCondition_List : public UGbxCondition
{
public:
	ECompoundConditionOperatorType                Operator;                                          // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxCondition*>                  Conditions;                                        // 0x0090(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	class UClass* GetRequiredInterface() const;
	bool RequiresNativeClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_List">();
	}
	static class UGbxCondition_List* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_List>();
	}
};
static_assert(alignof(UGbxCondition_List) == 0x000008, "Wrong alignment on UGbxCondition_List");
static_assert(sizeof(UGbxCondition_List) == 0x0000A0, "Wrong size on UGbxCondition_List");
static_assert(offsetof(UGbxCondition_List, Operator) == 0x000088, "Member 'UGbxCondition_List::Operator' has a wrong offset!");
static_assert(offsetof(UGbxCondition_List, Conditions) == 0x000090, "Member 'UGbxCondition_List::Conditions' has a wrong offset!");

// Class GbxGameSystemCore.GbxCondition_SensedRecently
// 0x0098 (0x0120 - 0x0088)
class UGbxCondition_SensedRecently final : public UGbxCondition
{
public:
	struct FGbxParam                              SensedWithin;                                      // 0x0088(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UAISense>>           Senses;                                            // 0x0108(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bAnyTarget;                                        // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_SensedRecently">();
	}
	static class UGbxCondition_SensedRecently* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_SensedRecently>();
	}
};
static_assert(alignof(UGbxCondition_SensedRecently) == 0x000008, "Wrong alignment on UGbxCondition_SensedRecently");
static_assert(sizeof(UGbxCondition_SensedRecently) == 0x000120, "Wrong size on UGbxCondition_SensedRecently");
static_assert(offsetof(UGbxCondition_SensedRecently, SensedWithin) == 0x000088, "Member 'UGbxCondition_SensedRecently::SensedWithin' has a wrong offset!");
static_assert(offsetof(UGbxCondition_SensedRecently, Senses) == 0x000108, "Member 'UGbxCondition_SensedRecently::Senses' has a wrong offset!");
static_assert(offsetof(UGbxCondition_SensedRecently, bAnyTarget) == 0x000118, "Member 'UGbxCondition_SensedRecently::bAnyTarget' has a wrong offset!");

// Class GbxGameSystemCore.TargetActorInfoLibrary
// 0x0000 (0x0028 - 0x0028)
class UTargetActorInfoLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UTargetingComponent* FindActorTargetingComponent(class AActor* Actor);
	static struct FVector GetBestAttackLocation(const struct FTargetActorInfo& Info, struct FVector* OutTargetVelocity);
	static bool GetBestStimulus(const struct FTargetActorInfo& Info, struct FAIStimulus* Stimulus);
	static struct FVector GetBestStimulusLocation(const struct FTargetActorInfo& Info, float* Age);
	static struct FVector GetReceiverLocation(const struct FTargetActorInfo& Info, TSubclassOf<class UAISense> Sense);
	static bool GetStimulusForSense(const struct FTargetActorInfo& Info, TSubclassOf<class UAISense> Sense, struct FAIStimulus* Stimulus);
	static struct FVector GetStimulusLocation(const struct FTargetActorInfo& Info, TSubclassOf<class UAISense> Sense);
	static bool HasAnyKnownStimuli(const struct FTargetActorInfo& Info);
	static bool HasStimulusForSense(const struct FTargetActorInfo& Info, TSubclassOf<class UAISense> Sense);
	static bool IsDirectlySensed(const struct FTargetActorInfo& Info);
	static bool IsExistingTarget(const struct FTargetActorInfo& Info);
	static bool IsSenseActive(const struct FTargetActorInfo& Info, TSubclassOf<class UAISense> Sense);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetActorInfoLibrary">();
	}
	static class UTargetActorInfoLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetActorInfoLibrary>();
	}
};
static_assert(alignof(UTargetActorInfoLibrary) == 0x000008, "Wrong alignment on UTargetActorInfoLibrary");
static_assert(sizeof(UTargetActorInfoLibrary) == 0x000028, "Wrong size on UTargetActorInfoLibrary");

// Class GbxGameSystemCore.GbxCondition_TeamAttitude
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_TeamAttitude final : public UGbxCondition
{
public:
	uint8                                         bHostile : 1;                                      // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNeutral : 1;                                      // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFriendly : 1;                                     // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_TeamAttitude">();
	}
	static class UGbxCondition_TeamAttitude* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_TeamAttitude>();
	}
};
static_assert(alignof(UGbxCondition_TeamAttitude) == 0x000008, "Wrong alignment on UGbxCondition_TeamAttitude");
static_assert(sizeof(UGbxCondition_TeamAttitude) == 0x000090, "Wrong size on UGbxCondition_TeamAttitude");

// Class GbxGameSystemCore.GbxCondition_TeamCheck
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_TeamCheck final : public UGbxCondition
{
public:
	class UTeam*                                  InputTeam;                                         // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_TeamCheck">();
	}
	static class UGbxCondition_TeamCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_TeamCheck>();
	}
};
static_assert(alignof(UGbxCondition_TeamCheck) == 0x000008, "Wrong alignment on UGbxCondition_TeamCheck");
static_assert(sizeof(UGbxCondition_TeamCheck) == 0x000090, "Wrong size on UGbxCondition_TeamCheck");
static_assert(offsetof(UGbxCondition_TeamCheck, InputTeam) == 0x000088, "Member 'UGbxCondition_TeamCheck::InputTeam' has a wrong offset!");

// Class GbxGameSystemCore.GbxCustomizationInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxCustomizationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCustomizationInterface">();
	}
	static class IGbxCustomizationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxCustomizationInterface>();
	}
};
static_assert(alignof(IGbxCustomizationInterface) == 0x000008, "Wrong alignment on IGbxCustomizationInterface");
static_assert(sizeof(IGbxCustomizationInterface) == 0x000028, "Wrong size on IGbxCustomizationInterface");

// Class GbxGameSystemCore.GbxCustomizationTargetData
// 0x0018 (0x0048 - 0x0030)
class UGbxCustomizationTargetData final : public UGbxDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCustomizationTargetData">();
	}
	static class UGbxCustomizationTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCustomizationTargetData>();
	}
};
static_assert(alignof(UGbxCustomizationTargetData) == 0x000008, "Wrong alignment on UGbxCustomizationTargetData");
static_assert(sizeof(UGbxCustomizationTargetData) == 0x000048, "Wrong size on UGbxCustomizationTargetData");
static_assert(offsetof(UGbxCustomizationTargetData, DisplayName) == 0x000030, "Member 'UGbxCustomizationTargetData::DisplayName' has a wrong offset!");

// Class GbxGameSystemCore.GbxCustomizationTypeData
// 0x0070 (0x00A0 - 0x0030)
class UGbxCustomizationTypeData final : public UGbxDataAsset
{
public:
	class FText                                   CustomizationTypeName;                             // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CustomizationTypeDescription;                      // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUnique;                                           // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCustomizationTypeData*              DependentCustomizationType;                        // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCustomizationTargetData*            DependentCustomizationTarget;                      // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGameStatData>           AssociatedUnlockStat;                              // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCustomizationTypeData">();
	}
	static class UGbxCustomizationTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCustomizationTypeData>();
	}
};
static_assert(alignof(UGbxCustomizationTypeData) == 0x000008, "Wrong alignment on UGbxCustomizationTypeData");
static_assert(sizeof(UGbxCustomizationTypeData) == 0x0000A0, "Wrong size on UGbxCustomizationTypeData");
static_assert(offsetof(UGbxCustomizationTypeData, CustomizationTypeName) == 0x000030, "Member 'UGbxCustomizationTypeData::CustomizationTypeName' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationTypeData, CustomizationTypeDescription) == 0x000048, "Member 'UGbxCustomizationTypeData::CustomizationTypeDescription' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationTypeData, bUnique) == 0x000060, "Member 'UGbxCustomizationTypeData::bUnique' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationTypeData, DependentCustomizationType) == 0x000068, "Member 'UGbxCustomizationTypeData::DependentCustomizationType' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationTypeData, DependentCustomizationTarget) == 0x000070, "Member 'UGbxCustomizationTypeData::DependentCustomizationTarget' has a wrong offset!");
static_assert(offsetof(UGbxCustomizationTypeData, AssociatedUnlockStat) == 0x000078, "Member 'UGbxCustomizationTypeData::AssociatedUnlockStat' has a wrong offset!");

// Class GbxGameSystemCore.GbxDataTableFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxDataTableFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_DataTableValueHandleToString(const struct FDataTableValueHandle& ValueHandle);
	static bool GetDataTableValue(class UDataTable* Table, class FName RowName, class FName ValueName, class UScriptStruct* ValueInStructType, int32* OutValue);
	static float GetDataTableValueFromHandle(const struct FDataTableValueHandle& ValueHandle, class UObject* ContextSource, float DefaultValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDataTableFunctionLibrary">();
	}
	static class UGbxDataTableFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDataTableFunctionLibrary>();
	}
};
static_assert(alignof(UGbxDataTableFunctionLibrary) == 0x000008, "Wrong alignment on UGbxDataTableFunctionLibrary");
static_assert(sizeof(UGbxDataTableFunctionLibrary) == 0x000028, "Wrong size on UGbxDataTableFunctionLibrary");

// Class GbxGameSystemCore.GbxEnvQueryHotSpotProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxEnvQueryHotSpotProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxEnvQueryHotSpotProviderInterface">();
	}
	static class IGbxEnvQueryHotSpotProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxEnvQueryHotSpotProviderInterface>();
	}
};
static_assert(alignof(IGbxEnvQueryHotSpotProviderInterface) == 0x000008, "Wrong alignment on IGbxEnvQueryHotSpotProviderInterface");
static_assert(sizeof(IGbxEnvQueryHotSpotProviderInterface) == 0x000028, "Wrong size on IGbxEnvQueryHotSpotProviderInterface");

// Class GbxGameSystemCore.GbxEqsRenderingComponent
// 0x0120 (0x0850 - 0x0730)
class UGbxEqsRenderingComponent final : public UEQSRenderingComponent
{
public:
	uint8                                         Pad_730[0x8];                                      // 0x0730(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExecuteQuery;                                     // 0x0738(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEqsTraceDrawMode                             TraceDrawMode;                                     // 0x0739(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73A[0x6];                                      // 0x073A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExternalQueryParams;                               // 0x0740(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        EnvQueryParams;                                    // 0x0750(0x00B8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_808[0x48];                                     // 0x0808(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAvailableEnvQueryParamRefNames(TArray<class FString>* Names) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxEqsRenderingComponent">();
	}
	static class UGbxEqsRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxEqsRenderingComponent>();
	}
};
static_assert(alignof(UGbxEqsRenderingComponent) == 0x000008, "Wrong alignment on UGbxEqsRenderingComponent");
static_assert(sizeof(UGbxEqsRenderingComponent) == 0x000850, "Wrong size on UGbxEqsRenderingComponent");
static_assert(offsetof(UGbxEqsRenderingComponent, bExecuteQuery) == 0x000738, "Member 'UGbxEqsRenderingComponent::bExecuteQuery' has a wrong offset!");
static_assert(offsetof(UGbxEqsRenderingComponent, TraceDrawMode) == 0x000739, "Member 'UGbxEqsRenderingComponent::TraceDrawMode' has a wrong offset!");
static_assert(offsetof(UGbxEqsRenderingComponent, ExternalQueryParams) == 0x000740, "Member 'UGbxEqsRenderingComponent::ExternalQueryParams' has a wrong offset!");
static_assert(offsetof(UGbxEqsRenderingComponent, EnvQueryParams) == 0x000750, "Member 'UGbxEqsRenderingComponent::EnvQueryParams' has a wrong offset!");

// Class GbxGameSystemCore.GbxEventDelegateBinding
// 0x0010 (0x0038 - 0x0028)
class UGbxEventDelegateBinding final : public UDynamicBlueprintBinding
{
public:
	TArray<struct FGbxBlueprintlegateBinding>     DelegateBindings;                                  // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxEventDelegateBinding">();
	}
	static class UGbxEventDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxEventDelegateBinding>();
	}
};
static_assert(alignof(UGbxEventDelegateBinding) == 0x000008, "Wrong alignment on UGbxEventDelegateBinding");
static_assert(sizeof(UGbxEventDelegateBinding) == 0x000038, "Wrong size on UGbxEventDelegateBinding");
static_assert(offsetof(UGbxEventDelegateBinding, DelegateBindings) == 0x000028, "Member 'UGbxEventDelegateBinding::DelegateBindings' has a wrong offset!");

// Class GbxGameSystemCore.GbxFeedbackData
// 0x01E8 (0x0218 - 0x0030)
class UGbxFeedbackData final : public UGbxFeedbackBase
{
public:
	int32                                         FeedbackType;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FForceFeedbackChannelDetails>   ControllerRumbleDetails;                           // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UForceFeedbackEffect*>           ExternalControllerRumbleDetails;                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FForceFeedbackChannelDetails>   MinControllerRumbleDetails;                        // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UForceFeedbackEffect*>           MinExternalControllerRumbleDetails;                // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteControllerRumbleScale;                    // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShake>               CameraShakeBase;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               CameraShakeDirectionalY;                           // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomShakeInterval;                               // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRandomShakeScalar;                              // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRandomShakeScalar;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnique;                                           // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseContinuousAttributeScale;                      // 0x009D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ContinuousScale;                                   // 0x00A0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ContinuousScaleCurve;                              // 0x00D8(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bScaleDownOverTime;                                // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScaleOverTimeCurve;                            // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ScaleOverTimeCurve;                                // 0x0158(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bPlayRadialBlur;                                   // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurSelection                   RadialBlurInfo;                                    // 0x01D4(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideRadialBlurCenter;                         // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseContextAsWorldSpaceCenter;                     // 0x01E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E2[0x2];                                      // 0x01E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RadialBlurWorldSpaceCenter;                        // 0x01E4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialBlurMaxDistance;                             // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ScreenParticles;                                   // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWhenFinished;                                 // 0x0200(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ContentDims;                                       // 0x0204(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenParticleScalingMode                    ScalingMode;                                       // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x0211(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysVisible;                                    // 0x0212(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickParticleEvenWhenPaused;                       // 0x0213(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLetSystemFinishAfterStopping;                     // 0x0214(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFeedbackData">();
	}
	static class UGbxFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFeedbackData>();
	}
};
static_assert(alignof(UGbxFeedbackData) == 0x000008, "Wrong alignment on UGbxFeedbackData");
static_assert(sizeof(UGbxFeedbackData) == 0x000218, "Wrong size on UGbxFeedbackData");
static_assert(offsetof(UGbxFeedbackData, FeedbackType) == 0x000030, "Member 'UGbxFeedbackData::FeedbackType' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ControllerRumbleDetails) == 0x000038, "Member 'UGbxFeedbackData::ControllerRumbleDetails' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ExternalControllerRumbleDetails) == 0x000048, "Member 'UGbxFeedbackData::ExternalControllerRumbleDetails' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, MinControllerRumbleDetails) == 0x000058, "Member 'UGbxFeedbackData::MinControllerRumbleDetails' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, MinExternalControllerRumbleDetails) == 0x000068, "Member 'UGbxFeedbackData::MinExternalControllerRumbleDetails' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bAbsoluteControllerRumbleScale) == 0x000078, "Member 'UGbxFeedbackData::bAbsoluteControllerRumbleScale' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, CameraShakeBase) == 0x000080, "Member 'UGbxFeedbackData::CameraShakeBase' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, CameraShakeDirectionalY) == 0x000088, "Member 'UGbxFeedbackData::CameraShakeDirectionalY' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, RandomShakeInterval) == 0x000090, "Member 'UGbxFeedbackData::RandomShakeInterval' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, MaxRandomShakeScalar) == 0x000094, "Member 'UGbxFeedbackData::MaxRandomShakeScalar' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, MinRandomShakeScalar) == 0x000098, "Member 'UGbxFeedbackData::MinRandomShakeScalar' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bUnique) == 0x00009C, "Member 'UGbxFeedbackData::bUnique' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bUseContinuousAttributeScale) == 0x00009D, "Member 'UGbxFeedbackData::bUseContinuousAttributeScale' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ContinuousScale) == 0x0000A0, "Member 'UGbxFeedbackData::ContinuousScale' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ContinuousScaleCurve) == 0x0000D8, "Member 'UGbxFeedbackData::ContinuousScaleCurve' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bScaleDownOverTime) == 0x000150, "Member 'UGbxFeedbackData::bScaleDownOverTime' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bUseScaleOverTimeCurve) == 0x000151, "Member 'UGbxFeedbackData::bUseScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ScaleOverTimeCurve) == 0x000158, "Member 'UGbxFeedbackData::ScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bPlayRadialBlur) == 0x0001D0, "Member 'UGbxFeedbackData::bPlayRadialBlur' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, RadialBlurInfo) == 0x0001D4, "Member 'UGbxFeedbackData::RadialBlurInfo' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bOverrideRadialBlurCenter) == 0x0001E0, "Member 'UGbxFeedbackData::bOverrideRadialBlurCenter' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bUseContextAsWorldSpaceCenter) == 0x0001E1, "Member 'UGbxFeedbackData::bUseContextAsWorldSpaceCenter' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, RadialBlurWorldSpaceCenter) == 0x0001E4, "Member 'UGbxFeedbackData::RadialBlurWorldSpaceCenter' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, RadialBlurMaxDistance) == 0x0001F0, "Member 'UGbxFeedbackData::RadialBlurMaxDistance' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ScreenParticles) == 0x0001F8, "Member 'UGbxFeedbackData::ScreenParticles' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bHideWhenFinished) == 0x000200, "Member 'UGbxFeedbackData::bHideWhenFinished' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ContentDims) == 0x000204, "Member 'UGbxFeedbackData::ContentDims' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ParticleDepth) == 0x00020C, "Member 'UGbxFeedbackData::ParticleDepth' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, ScalingMode) == 0x000210, "Member 'UGbxFeedbackData::ScalingMode' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bOnlyOwnerSee) == 0x000211, "Member 'UGbxFeedbackData::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bAlwaysVisible) == 0x000212, "Member 'UGbxFeedbackData::bAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bTickParticleEvenWhenPaused) == 0x000213, "Member 'UGbxFeedbackData::bTickParticleEvenWhenPaused' has a wrong offset!");
static_assert(offsetof(UGbxFeedbackData, bLetSystemFinishAfterStopping) == 0x000214, "Member 'UGbxFeedbackData::bLetSystemFinishAfterStopping' has a wrong offset!");

// Class GbxGameSystemCore.GbxFeedbackManager
// 0x0018 (0x0040 - 0x0028)
class UGbxFeedbackManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFeedbackManager">();
	}
	static class UGbxFeedbackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFeedbackManager>();
	}
};
static_assert(alignof(UGbxFeedbackManager) == 0x000008, "Wrong alignment on UGbxFeedbackManager");
static_assert(sizeof(UGbxFeedbackManager) == 0x000040, "Wrong size on UGbxFeedbackManager");

// Class GbxGameSystemCore.GbxFlagFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxFlagFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool FlagDataFalseFor(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime);
	static bool FlagDataFalseWithin(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime);
	static bool FlagDataTrueFor(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime);
	static bool FlagDataTrueWithin(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime);
	static bool FlagFalseFor(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime);
	static bool FlagFalseWithin(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime);
	static bool FlagTrueFor(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime);
	static bool FlagTrueWithin(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime);
	static bool GetFlagDataValue(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource);
	static bool GetFlagValue(class UObject* WorldContextObject, const struct FGbxFlag& Flag);
	static void SetFlagDataTrueTimed(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource, float Duration);
	static void SetFlagDataValue(class UObject* WorldContextObject, const class UGbxFlagData* FlagData, class UObject* ContextSource, bool bNewValue);
	static void SetFlagTrueTimed(class UObject* WorldContextObject, struct FGbxFlag& Flag, float Duration);
	static void SetFlagValue(class UObject* WorldContextObject, struct FGbxFlag& Flag, bool bNewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFlagFunctionLibrary">();
	}
	static class UGbxFlagFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFlagFunctionLibrary>();
	}
};
static_assert(alignof(UGbxFlagFunctionLibrary) == 0x000008, "Wrong alignment on UGbxFlagFunctionLibrary");
static_assert(sizeof(UGbxFlagFunctionLibrary) == 0x000028, "Wrong size on UGbxFlagFunctionLibrary");

// Class GbxGameSystemCore.FlagPropertyTestContext
// 0x0018 (0x0040 - 0x0028)
class UFlagPropertyTestContext final : public UObject
{
public:
	struct FGbxFlag                               TestFlag;                                          // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FFlagPropertyTestStruct                TestStruct;                                        // 0x0034(0x000C)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagPropertyTestContext">();
	}
	static class UFlagPropertyTestContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagPropertyTestContext>();
	}
};
static_assert(alignof(UFlagPropertyTestContext) == 0x000008, "Wrong alignment on UFlagPropertyTestContext");
static_assert(sizeof(UFlagPropertyTestContext) == 0x000040, "Wrong size on UFlagPropertyTestContext");
static_assert(offsetof(UFlagPropertyTestContext, TestFlag) == 0x000028, "Member 'UFlagPropertyTestContext::TestFlag' has a wrong offset!");
static_assert(offsetof(UFlagPropertyTestContext, TestStruct) == 0x000034, "Member 'UFlagPropertyTestContext::TestStruct' has a wrong offset!");

// Class GbxGameSystemCore.WeaponUserInterface
// 0x0000 (0x0028 - 0x0028)
class IWeaponUserInterface : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponUserInterface">();
	}
	static class IWeaponUserInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponUserInterface>();
	}
};
static_assert(alignof(IWeaponUserInterface) == 0x000008, "Wrong alignment on IWeaponUserInterface");
static_assert(sizeof(IWeaponUserInterface) == 0x000028, "Wrong size on IWeaponUserInterface");

// Class GbxGameSystemCore.FlagPropertyTestContextResolver
// 0x0000 (0x0050 - 0x0050)
class UFlagPropertyTestContextResolver final : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagPropertyTestContextResolver">();
	}
	static class UFlagPropertyTestContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagPropertyTestContextResolver>();
	}
};
static_assert(alignof(UFlagPropertyTestContextResolver) == 0x000008, "Wrong alignment on UFlagPropertyTestContextResolver");
static_assert(sizeof(UFlagPropertyTestContextResolver) == 0x000050, "Wrong size on UFlagPropertyTestContextResolver");

// Class GbxGameSystemCore.SceneBodySwitchAction
// 0x0000 (0x0028 - 0x0028)
class USceneBodySwitchAction : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneBodySwitchAction">();
	}
	static class USceneBodySwitchAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneBodySwitchAction>();
	}
};
static_assert(alignof(USceneBodySwitchAction) == 0x000008, "Wrong alignment on USceneBodySwitchAction");
static_assert(sizeof(USceneBodySwitchAction) == 0x000028, "Wrong size on USceneBodySwitchAction");

// Class GbxGameSystemCore.GbxFlagValueResolver_Property
// 0x0080 (0x00A8 - 0x0028)
class UGbxFlagValueResolver_Property final : public UGbxFlagValueResolver
{
public:
	struct FParsedProperty                        Property;                                          // 0x0028(0x0080)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFlagValueResolver_Property">();
	}
	static class UGbxFlagValueResolver_Property* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFlagValueResolver_Property>();
	}
};
static_assert(alignof(UGbxFlagValueResolver_Property) == 0x000008, "Wrong alignment on UGbxFlagValueResolver_Property");
static_assert(sizeof(UGbxFlagValueResolver_Property) == 0x0000A8, "Wrong size on UGbxFlagValueResolver_Property");
static_assert(offsetof(UGbxFlagValueResolver_Property, Property) == 0x000028, "Member 'UGbxFlagValueResolver_Property::Property' has a wrong offset!");

// Class GbxGameSystemCore.BaseMenuStackMenuInfo
// 0x0000 (0x0028 - 0x0028)
class UBaseMenuStackMenuInfo : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMenuStackMenuInfo">();
	}
	static class UBaseMenuStackMenuInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseMenuStackMenuInfo>();
	}
};
static_assert(alignof(UBaseMenuStackMenuInfo) == 0x000008, "Wrong alignment on UBaseMenuStackMenuInfo");
static_assert(sizeof(UBaseMenuStackMenuInfo) == 0x000028, "Wrong size on UBaseMenuStackMenuInfo");

// Class GbxGameSystemCore.GbxGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UGbxGameplayStatics final : public UGameplayStatics
{
public:
	static struct FTransform AlignTransformToSurface(const struct FTransform& Transform, const struct FVector& SurfaceNormal);
	static class AGbxCharacter* GetAssociatedPrimaryCharacter(class AActor* Actor);
	static class APlayerController* GetPrimaryPlayerController(const class UObject* WorldContextObject);
	static void ProjectFromQueryToSimulation(const class UGbxSkeletalMeshComponent* Component, const class FName& BodyName, struct FVector& InOutHitPoint, struct FVector& InOutHitNormal);
	static void SetComponentTeamCollisionChannel(class USceneComponent* Component, ETeamCollisionChannel Channel, bool bOn, bool bPropagateToChildren);
	static void SetComponentTeamCollisionResponseToChannel(class USceneComponent* Component, ETeamCollisionChannel Channel, bool bIgnore, bool bPropagateToChildren);
	static void SetComponentTeamCollisionResponseWith(class USceneComponent* Component, class AActor* TeamActor, bool bIgnore, bool bPropagateToChildren);
	static bool SetPlayerMaster(class AActor* AIActor, class AActor* PlayerMaster);
	static void SetTeamCollisionChannel(class AActor* Actor, ETeamCollisionChannel Channel, bool bOn);
	static void SetTeamCollisionChannelFrom(class AActor* Actor, class AActor* TeamActor, bool bOn);
	static void SetTeamCollisionResponseToChannel(class AActor* Actor, ETeamCollisionChannel Channel, bool bIgnore);
	static void SetTeamCollisionResponseWith(class AActor* Actor, class AActor* TeamActor, bool bIgnore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameplayStatics">();
	}
	static class UGbxGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGameplayStatics>();
	}
};
static_assert(alignof(UGbxGameplayStatics) == 0x000008, "Wrong alignment on UGbxGameplayStatics");
static_assert(sizeof(UGbxGameplayStatics) == 0x000028, "Wrong size on UGbxGameplayStatics");

// Class GbxGameSystemCore.GbxGameStatsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxGameStatsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DecrementStat(class AActor* ContextActor, class UGameStatData* StatData, int32 Amount);
	static void DecrementStatForParty(class UObject* WorldContextObject, class UGameStatData* StatData, int32 Amount);
	static int32 GetStatValue(class AActor* ContextActor, class UGameStatData* StatData);
	static void IncrementStat(class AActor* ContextActor, class UGameStatData* StatData, int32 Amount);
	static void IncrementStatForParty(class UObject* WorldContextObject, class UGameStatData* StatData, int32 Amount);
	static void UpdateStat(class AActor* ContextActor, class UGameStatData* StatData, int32 NewValue);
	static void UpdateStatForParty(class UObject* WorldContextObject, class UGameStatData* StatData, int32 NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameStatsBlueprintLibrary">();
	}
	static class UGbxGameStatsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGameStatsBlueprintLibrary>();
	}
};
static_assert(alignof(UGbxGameStatsBlueprintLibrary) == 0x000008, "Wrong alignment on UGbxGameStatsBlueprintLibrary");
static_assert(sizeof(UGbxGameStatsBlueprintLibrary) == 0x000028, "Wrong size on UGbxGameStatsBlueprintLibrary");

// Class GbxGameSystemCore.ScreenParticleManagerComponent
// 0x0028 (0x01A0 - 0x0178)
class UScreenParticleManagerComponent final : public UActorComponent
{
public:
	TArray<struct FScreenParticleRecord>          ScreenParticleRecords;                             // 0x0178(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FParticlePropertyTracker>       TrackedParticleProperties;                         // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void HideScreenParticleForActor(class AActor* Actor, class UParticleSystem* Template, class FName Tag, bool bAllowParticleToFinish, bool bServerAuthority);
	static void ShowScreenParticleForActor(class AActor* Actor, class UParticleSystem* Template, bool bHideWhenFinished, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, bool bOnlyOwnerSee, bool bAlwaysVisible, class FName Tag, bool bAllowMultipleInstances, bool bServerAuthority, bool bTickEvenWhenPaused, bool bHideDuringInGameMenu);

	void ClientHideScreenParticle(class UParticleSystem* Template, class FName Tag, bool bAllowParticleToFinish);
	void ClientSetScreenParticleActorParameter(class UParticleSystem* Template, class FName Tag, class FName ParameterName, class AActor* Param);
	void ClientSetScreenParticleColorParameter(class UParticleSystem* Template, class FName Tag, class FName ParameterName, const struct FLinearColor& Param);
	void ClientSetScreenParticleFloatParameter(class UParticleSystem* Template, class FName Tag, class FName ParameterName, float Param);
	void ClientSetScreenParticleMaterialParameter(class UParticleSystem* Template, class FName Tag, class FName ParameterName, class UMaterialInterface* Param);
	void ClientSetScreenParticleVectorParameter(class UParticleSystem* Template, class FName Tag, class FName ParameterName, const struct FVector& Param);
	void ClientShowScreenParticle(class UParticleSystem* Template, bool bHideWhenFinished, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, bool bOnlyOwnerSee, bool bAlwaysVisible, class FName Tag, bool bAllowMultipleInstances, bool bTickEvenWhenPaused, bool bHideDuringInGameMenu, bool bDepthPriorityWorld);
	void ClientShowScreenParticleEx(class UParticleSystem* Template, uint8 InitFlags, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, class FName Tag);
	void ClientTrackParticleProperty(class UParticlePropertyTrackingData* TrackingData, class UParticleSystem* Template, class FName Tag, class FName PropertyName, float PropertyValue, bool bAddToValue, class UMaterialInterface* UsedMaterialProperty, class FName MaterialPropertyName);
	void OnScreenParticleFinished(class UParticleSystemComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenParticleManagerComponent">();
	}
	static class UScreenParticleManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenParticleManagerComponent>();
	}
};
static_assert(alignof(UScreenParticleManagerComponent) == 0x000008, "Wrong alignment on UScreenParticleManagerComponent");
static_assert(sizeof(UScreenParticleManagerComponent) == 0x0001A0, "Wrong size on UScreenParticleManagerComponent");
static_assert(offsetof(UScreenParticleManagerComponent, ScreenParticleRecords) == 0x000178, "Member 'UScreenParticleManagerComponent::ScreenParticleRecords' has a wrong offset!");
static_assert(offsetof(UScreenParticleManagerComponent, TrackedParticleProperties) == 0x000188, "Member 'UScreenParticleManagerComponent::TrackedParticleProperties' has a wrong offset!");

// Class GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxGameSystemCoreBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AreAllPlayersInVolume(class UObject* WorldContextObject, const TArray<class AVolume*>& Volumes, EPlayersInVolumeOutput* Branches);
	static void AreAllPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor, EPlayersOverlappingActorOutput* Branches);
	static void AreAllPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors, EPlayersOverlappingActorOutput* Branches);
	static void AreAnyPlayersInVolume(class UObject* WorldContextObject, const TArray<class AVolume*>& Volumes, EPlayersInVolumeOutput* Branches);
	static void AreAnyPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor, EPlayersOverlappingActorOutput* Branches);
	static void AreAnyPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors, EPlayersOverlappingActorOutput* Branches);
	static void BranchOnIsAutonomous(class AActor* Actor, EIsAutonomousOuput* Branches);
	static void BranchOnIsPlayer(class AActor* Actor, EIsPlayerExecOutput* Branches);
	static void GetActorListTrimmedToBestCluster(TArray<class AActor*>* OutputActors, struct FVector* ClusterMidpoint, const TArray<class AActor*>& InputActors, class AActor* SourceActor, float ClusterRadius, bool bPreferClusterContainingCurrentTarget);
	static bool GetAreAllPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor);
	static bool GetAreAllPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors);
	static bool GetAreAnyPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor);
	static bool GetAreAnyPlayersOverlappingActors(class UObject* WorldContextObject, const TArray<class AActor*>& Actors);
	static float GetCurveFloatValue(const struct FRuntimeFloatCurve& Curve, float InTime);
	static struct FVector GetRelativeDirection(const struct FRelativeDirectionData& RelativeDirectionData, const struct FVector& DefaultDirection, class AActor* SourceActor, const class FName& SourceSocketName, class AActor* TargetActor);
	static void HoverComponentAtActor(class USceneComponent* Component, class AActor* TargetActor, float Altitude, float Radius, float AccelerationTime, float Speed, float Duration, const struct FLatentActionInfo& LatentInfo);
	static bool IsContentCensored(class UObject* WorldContextObject);
	static bool IsPlayer(class AActor* Actor);
	static bool IsSplitScreen(class UGameInstance* GameInstance);
	static void ResourceLockAiming(class AActor* Actor, class FName Reason);
	static void ResourceLockAIThinking(class AActor* Actor, class FName Reason, bool bAbort);
	static void ResourceLockCrouching(class AActor* Actor, class FName Reason);
	static void ResourceLockDemigod(class AActor* Actor, class FName Reason);
	static void ResourceLockDodging(class AActor* Actor, class FName Reason);
	static void ResourceLockFootIk(class AActor* Actor, class FName Reason);
	static void ResourceLockFootIkTracing(class AActor* Actor, class FName Reason);
	static void ResourceLockGod(class AActor* Actor, class FName Reason);
	static void ResourceLockHandIk(class AActor* Actor, class FName Reason);
	static void ResourceLockJumping(class AActor* Actor, class FName Reason);
	static void ResourceLockLookAt(class AActor* Actor, class FName Reason);
	static void ResourceLockLookAtTargetLocation(class AActor* Actor, class FName Reason);
	static void ResourceLockMantling(class AActor* Actor, class FName Reason);
	static void ResourceLockMomentum(class AActor* Actor, class FName Reason);
	static void ResourceLockMovement(class AActor* Actor, class FName Reason);
	static void ResourceLockPhysicsRotation(class AActor* Actor, class FName Reason);
	static void ResourceLockRotation(class AActor* Actor, class FName Reason);
	static void ResourceLockTargetable(class AActor* Actor, class FName Reason, bool bTargetable);
	static void ResourceLockTickAndRefreshBones(class AActor* Actor, class FName Reason);
	static void ResourceLockTurns(class AActor* Actor, class FName Reason);
	static void ResourceUnlockAiming(class AActor* Actor, class FName Reason);
	static void ResourceUnlockAIThinking(class AActor* Actor, class FName Reason);
	static void ResourceUnlockCrouching(class AActor* Actor, class FName Reason);
	static void ResourceUnlockDemigod(class AActor* Actor, class FName Reason);
	static void ResourceUnlockDodging(class AActor* Actor, class FName Reason);
	static void ResourceUnlockFootIk(class AActor* Actor, class FName Reason);
	static void ResourceUnlockFootIkTracing(class AActor* Actor, class FName Reason);
	static void ResourceUnlockGod(class AActor* Actor, class FName Reason);
	static void ResourceUnlockHandIk(class AActor* Actor, class FName Reason);
	static void ResourceUnlockJumping(class AActor* Actor, class FName Reason);
	static void ResourceUnlockLookAt(class AActor* Actor, class FName Reason);
	static void ResourceUnlockLookAtTargetLocation(class AActor* Actor, class FName Reason);
	static void ResourceUnlockMantling(class AActor* Actor, class FName Reason);
	static void ResourceUnlockMomentum(class AActor* Actor, class FName Reason);
	static void ResourceUnlockMovement(class AActor* Actor, class FName Reason);
	static void ResourceUnlockRotation(class AActor* Actor, class FName Reason);
	static void ResourceUnlockTickAndRefreshBones(class AActor* Actor, class FName Reason);
	static void ResourceUnlockTurns(class AActor* Actor, class FName Reason);
	static void SetComponentPhysicalRotation(class UPrimitiveComponent* Target, float PitchRotation, float YawRotation, float RollRotation, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGameSystemCoreBlueprintLibrary">();
	}
	static class UGbxGameSystemCoreBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGameSystemCoreBlueprintLibrary>();
	}
};
static_assert(alignof(UGbxGameSystemCoreBlueprintLibrary) == 0x000008, "Wrong alignment on UGbxGameSystemCoreBlueprintLibrary");
static_assert(sizeof(UGbxGameSystemCoreBlueprintLibrary) == 0x000028, "Wrong size on UGbxGameSystemCoreBlueprintLibrary");

// Class GbxGameSystemCore.GbxHUDFeedbackData
// 0x0058 (0x0088 - 0x0030)
class UGbxHUDFeedbackData : public UGbxDataAsset
{
public:
	struct FVector                                MoveWeight;                                        // 0x0030(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveAcceleration;                                  // 0x003C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveDeceleration;                                  // 0x0048(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveMaxVelocity;                                   // 0x0054(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookWeight;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookAcceleration;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookDeceleration;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookMaxVelocity;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookMultiplier;                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHUDFeedbackData">();
	}
	static class UGbxHUDFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxHUDFeedbackData>();
	}
};
static_assert(alignof(UGbxHUDFeedbackData) == 0x000008, "Wrong alignment on UGbxHUDFeedbackData");
static_assert(sizeof(UGbxHUDFeedbackData) == 0x000088, "Wrong size on UGbxHUDFeedbackData");
static_assert(offsetof(UGbxHUDFeedbackData, MoveWeight) == 0x000030, "Member 'UGbxHUDFeedbackData::MoveWeight' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, MoveAcceleration) == 0x00003C, "Member 'UGbxHUDFeedbackData::MoveAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, MoveDeceleration) == 0x000048, "Member 'UGbxHUDFeedbackData::MoveDeceleration' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, MoveMaxVelocity) == 0x000054, "Member 'UGbxHUDFeedbackData::MoveMaxVelocity' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, LookWeight) == 0x000060, "Member 'UGbxHUDFeedbackData::LookWeight' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, LookAcceleration) == 0x000068, "Member 'UGbxHUDFeedbackData::LookAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, LookDeceleration) == 0x000070, "Member 'UGbxHUDFeedbackData::LookDeceleration' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, LookMaxVelocity) == 0x000078, "Member 'UGbxHUDFeedbackData::LookMaxVelocity' has a wrong offset!");
static_assert(offsetof(UGbxHUDFeedbackData, GamepadLookMultiplier) == 0x000080, "Member 'UGbxHUDFeedbackData::GamepadLookMultiplier' has a wrong offset!");

// Class GbxGameSystemCore.GbxInventoryCategoryData
// 0x0008 (0x0038 - 0x0030)
class UGbxInventoryCategoryData : public UGbxDataAsset
{
public:
	bool                                          bIsPremiumCurrencyCategory;                        // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxInventoryCategoryData">();
	}
	static class UGbxInventoryCategoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxInventoryCategoryData>();
	}
};
static_assert(alignof(UGbxInventoryCategoryData) == 0x000008, "Wrong alignment on UGbxInventoryCategoryData");
static_assert(sizeof(UGbxInventoryCategoryData) == 0x000038, "Wrong size on UGbxInventoryCategoryData");
static_assert(offsetof(UGbxInventoryCategoryData, bIsPremiumCurrencyCategory) == 0x000030, "Member 'UGbxInventoryCategoryData::bIsPremiumCurrencyCategory' has a wrong offset!");

// Class GbxGameSystemCore.GbxLevelSequenceControllableInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxLevelSequenceControllableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxLevelSequenceControllableInterface">();
	}
	static class IGbxLevelSequenceControllableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxLevelSequenceControllableInterface>();
	}
};
static_assert(alignof(IGbxLevelSequenceControllableInterface) == 0x000008, "Wrong alignment on IGbxLevelSequenceControllableInterface");
static_assert(sizeof(IGbxLevelSequenceControllableInterface) == 0x000028, "Wrong size on IGbxLevelSequenceControllableInterface");

// Class GbxGameSystemCore.SocketComponent
// 0x0000 (0x02D0 - 0x02D0)
class USocketComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocketComponent">();
	}
	static class USocketComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocketComponent>();
	}
};
static_assert(alignof(USocketComponent) == 0x000008, "Wrong alignment on USocketComponent");
static_assert(sizeof(USocketComponent) == 0x0002D0, "Wrong size on USocketComponent");

// Class GbxGameSystemCore.GbxMediaData
// 0x0020 (0x0050 - 0x0030)
class UGbxMediaData final : public UGbxDataAsset
{
public:
	TScriptInterface<class IMediaAudioSinkProviderInterface> AudioSinkProvider;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMediaTexture*                          MediaTexture;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaSource*                           MediaSource;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMediaData">();
	}
	static class UGbxMediaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMediaData>();
	}
};
static_assert(alignof(UGbxMediaData) == 0x000008, "Wrong alignment on UGbxMediaData");
static_assert(sizeof(UGbxMediaData) == 0x000050, "Wrong size on UGbxMediaData");
static_assert(offsetof(UGbxMediaData, AudioSinkProvider) == 0x000030, "Member 'UGbxMediaData::AudioSinkProvider' has a wrong offset!");
static_assert(offsetof(UGbxMediaData, MediaTexture) == 0x000040, "Member 'UGbxMediaData::MediaTexture' has a wrong offset!");
static_assert(offsetof(UGbxMediaData, MediaSource) == 0x000048, "Member 'UGbxMediaData::MediaSource' has a wrong offset!");

// Class GbxGameSystemCore.GbxMediaManager
// 0x0020 (0x0048 - 0x0028)
class UGbxMediaManager final : public UGbxBaseMediaManager
{
public:
	TArray<class UMediaPlayer*>                   ActiveMediaPlayers;                                // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMediaPlayer* GbxPlayMovie(class UObject* WorldContextObject, class UGbxMediaData* InMediaData);

	void OnMovieEndReached();
	void OnMovieMediaClosed();
	void OnMovieMediaOpenFailed(const class FString& DeviceUrl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMediaManager">();
	}
	static class UGbxMediaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMediaManager>();
	}
};
static_assert(alignof(UGbxMediaManager) == 0x000008, "Wrong alignment on UGbxMediaManager");
static_assert(sizeof(UGbxMediaManager) == 0x000048, "Wrong size on UGbxMediaManager");
static_assert(offsetof(UGbxMediaManager, ActiveMediaPlayers) == 0x000028, "Member 'UGbxMediaManager::ActiveMediaPlayers' has a wrong offset!");

// Class GbxGameSystemCore.GbxNavAvoidanceInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxNavAvoidanceInterface final : public IInterface
{
public:
	void SetObstacleAvoidanceLock(bool bDisable, const class FName& Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavAvoidanceInterface">();
	}
	static class IGbxNavAvoidanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxNavAvoidanceInterface>();
	}
};
static_assert(alignof(IGbxNavAvoidanceInterface) == 0x000008, "Wrong alignment on IGbxNavAvoidanceInterface");
static_assert(sizeof(IGbxNavAvoidanceInterface) == 0x000028, "Wrong size on IGbxNavAvoidanceInterface");

// Class GbxGameSystemCore.GbxPainCausingVolume
// 0x0038 (0x0500 - 0x04C8)
class AGbxPainCausingVolume final : public APainCausingVolume
{
public:
	struct FAttributeInitializationData           GbxDamagePerSec;                                   // 0x04C8(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPainCausingVolume">();
	}
	static class AGbxPainCausingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxPainCausingVolume>();
	}
};
static_assert(alignof(AGbxPainCausingVolume) == 0x000008, "Wrong alignment on AGbxPainCausingVolume");
static_assert(sizeof(AGbxPainCausingVolume) == 0x000500, "Wrong size on AGbxPainCausingVolume");
static_assert(offsetof(AGbxPainCausingVolume, GbxDamagePerSec) == 0x0004C8, "Member 'AGbxPainCausingVolume::GbxDamagePerSec' has a wrong offset!");

// Class GbxGameSystemCore.StanceComponent
// 0x00F8 (0x0270 - 0x0178)
class UStanceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStanceChanged;                                   // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStanceDataSelector*                    StanceSelector;                                    // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStanceStack                           StanceStack;                                       // 0x0198(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FStanceChangedEventArgs                StanceState;                                       // 0x01E8(0x0030)(Net, Transient, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<class UStanceType*, class UStanceData*>  DefaultStanceMap;                                  // 0x0218(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         TimeEnteredCurrentStance;                          // 0x0268(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearBlueprintStance();
	void ClearStanceLayer(EStanceStackLayer Layer);
	void OnRep_StanceState();
	void SetBlueprintStance(class UStanceDataProvider* NewStance);
	void SetStanceLayer(EStanceStackLayer Layer, class UStanceDataProvider* NewStance);
	void StackStanceChangedCallback(EStanceStackLayer PreviousLayer, class UStanceData* PreviousStance, EStanceStackLayer NextLayer, class UStanceData* NextStance);

	class UStanceData* FindStanceForType(class UStanceType* Type) const;
	class UStanceType* FindTypeForStance(class UStanceData* Stance) const;
	class UStanceData* GetStance() const;
	EStanceStackLayer GetStanceLayer() const;
	float GetTimeSpentInCurrentStance() const;
	bool IsInAnimStance(class UStanceDataProvider* Stance) const;
	bool IsInStance(class UStanceDataProvider* Stance) const;
	bool IsInStanceLayer(EStanceStackLayer Layer) const;
	bool IsInStanceType(class UStanceType* Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceComponent">();
	}
	static class UStanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceComponent>();
	}
};
static_assert(alignof(UStanceComponent) == 0x000008, "Wrong alignment on UStanceComponent");
static_assert(sizeof(UStanceComponent) == 0x000270, "Wrong size on UStanceComponent");
static_assert(offsetof(UStanceComponent, OnStanceChanged) == 0x000180, "Member 'UStanceComponent::OnStanceChanged' has a wrong offset!");
static_assert(offsetof(UStanceComponent, StanceSelector) == 0x000190, "Member 'UStanceComponent::StanceSelector' has a wrong offset!");
static_assert(offsetof(UStanceComponent, StanceStack) == 0x000198, "Member 'UStanceComponent::StanceStack' has a wrong offset!");
static_assert(offsetof(UStanceComponent, StanceState) == 0x0001E8, "Member 'UStanceComponent::StanceState' has a wrong offset!");
static_assert(offsetof(UStanceComponent, DefaultStanceMap) == 0x000218, "Member 'UStanceComponent::DefaultStanceMap' has a wrong offset!");
static_assert(offsetof(UStanceComponent, TimeEnteredCurrentStance) == 0x000268, "Member 'UStanceComponent::TimeEnteredCurrentStance' has a wrong offset!");

// Class GbxGameSystemCore.GbxParamExt
// 0x0000 (0x0028 - 0x0028)
class UGbxParamExt final : public UBlueprintFunctionLibrary
{
public:
	static float Evaluate(const struct FGbxParam& Param, class UObject* Context);
	static bool EvaluateBool(const struct FGbxParam& Param, class UObject* Context);
	static bool EvaluateBoolPure(const struct FGbxParam& Param, class UObject* Context);
	static float EvaluateInt(const struct FGbxParam& Param, class UObject* Context);
	static float EvaluateIntPure(const struct FGbxParam& Param, class UObject* Context);
	static float EvaluatePure(const struct FGbxParam& Param, class UObject* Context);
	static class FString GetNamedParamDescription(const struct FGbxNamedParam& Param);
	static class FText GetNamedParamDescriptionText(const struct FGbxNamedParam& Param);
	static class FString GetParamDescription(const struct FGbxParam& Param);
	static class FText GetParamDescriptionText(const struct FGbxParam& Param);
	static class FString GetParamPropertyDescription(const struct FGbxParam& Param, class UProperty* Property);
	static bool IsValueInRange(const struct FGbxParam& Param, float Value, class UObject* Context);
	static bool IsValueInRangePure(const struct FGbxParam& Param, float Value, class UObject* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxParamExt">();
	}
	static class UGbxParamExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxParamExt>();
	}
};
static_assert(alignof(UGbxParamExt) == 0x000008, "Wrong alignment on UGbxParamExt");
static_assert(sizeof(UGbxParamExt) == 0x000028, "Wrong size on UGbxParamExt");

// Class GbxGameSystemCore.GbxPerceptionComponent
// 0x0008 (0x0278 - 0x0270)
class UGbxPerceptionComponent final : public UAIPerceptionComponent
{
public:
	float                                         StimulusStrengthOverrideTime;                      // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPerceptionComponent">();
	}
	static class UGbxPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxPerceptionComponent>();
	}
};
static_assert(alignof(UGbxPerceptionComponent) == 0x000008, "Wrong alignment on UGbxPerceptionComponent");
static_assert(sizeof(UGbxPerceptionComponent) == 0x000278, "Wrong size on UGbxPerceptionComponent");
static_assert(offsetof(UGbxPerceptionComponent, StimulusStrengthOverrideTime) == 0x000270, "Member 'UGbxPerceptionComponent::StimulusStrengthOverrideTime' has a wrong offset!");

// Class GbxGameSystemCore.GbxPhysicsCollisionHandler
// 0x0008 (0x0048 - 0x0040)
class UGbxPhysicsCollisionHandler : public UPhysicsCollisionHandler
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPhysicsCollisionHandler">();
	}
	static class UGbxPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxPhysicsCollisionHandler>();
	}
};
static_assert(alignof(UGbxPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UGbxPhysicsCollisionHandler");
static_assert(sizeof(UGbxPhysicsCollisionHandler) == 0x000048, "Wrong size on UGbxPhysicsCollisionHandler");

// Class GbxGameSystemCore.GbxPhysicsSettings
// 0x0120 (0x0148 - 0x0028)
class UGbxPhysicsSettings final : public UObject
{
public:
	TMap<EPhysicalSurface, struct FSurfaceTypeInfo> SurfaceTypeInfoMap;                                // 0x0028(0x0050)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FRigidBodyImpactSettings               RigidBodyImpactSettings;                           // 0x0078(0x00B0)(Edit, Config, NativeAccessSpecifierPublic)
	struct FDestructionForceSmoothing             ForceSmoothing;                                    // 0x0128(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LowDamageThreshold;                                // 0x0134(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumDamageThreshold;                             // 0x0138(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighDamageThreshold;                               // 0x013C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollWeaponForceFeatherPercent;                  // 0x0140(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void StaticSetRigidBodySimulationInteractability(class USkeletalMeshComponent* Comp, bool bAesthetic, class FName BodyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPhysicsSettings">();
	}
	static class UGbxPhysicsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxPhysicsSettings>();
	}
};
static_assert(alignof(UGbxPhysicsSettings) == 0x000008, "Wrong alignment on UGbxPhysicsSettings");
static_assert(sizeof(UGbxPhysicsSettings) == 0x000148, "Wrong size on UGbxPhysicsSettings");
static_assert(offsetof(UGbxPhysicsSettings, SurfaceTypeInfoMap) == 0x000028, "Member 'UGbxPhysicsSettings::SurfaceTypeInfoMap' has a wrong offset!");
static_assert(offsetof(UGbxPhysicsSettings, RigidBodyImpactSettings) == 0x000078, "Member 'UGbxPhysicsSettings::RigidBodyImpactSettings' has a wrong offset!");
static_assert(offsetof(UGbxPhysicsSettings, ForceSmoothing) == 0x000128, "Member 'UGbxPhysicsSettings::ForceSmoothing' has a wrong offset!");
static_assert(offsetof(UGbxPhysicsSettings, LowDamageThreshold) == 0x000134, "Member 'UGbxPhysicsSettings::LowDamageThreshold' has a wrong offset!");
static_assert(offsetof(UGbxPhysicsSettings, MediumDamageThreshold) == 0x000138, "Member 'UGbxPhysicsSettings::MediumDamageThreshold' has a wrong offset!");
static_assert(offsetof(UGbxPhysicsSettings, HighDamageThreshold) == 0x00013C, "Member 'UGbxPhysicsSettings::HighDamageThreshold' has a wrong offset!");
static_assert(offsetof(UGbxPhysicsSettings, RagdollWeaponForceFeatherPercent) == 0x000140, "Member 'UGbxPhysicsSettings::RagdollWeaponForceFeatherPercent' has a wrong offset!");

// Class GbxGameSystemCore.GbxQueryManager
// 0x0088 (0x00B0 - 0x0028)
class UGbxQueryManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActiveQueries;                                  // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxQuery>                      Queries;                                           // 0x0038(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UWorld*                                 World;                                             // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQueryManager*                       EnvQueryManager;                                   // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x58];                                      // 0x0058(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyAIHotSpotListChangedFor(class AActor* OwnerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxQueryManager">();
	}
	static class UGbxQueryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxQueryManager>();
	}
};
static_assert(alignof(UGbxQueryManager) == 0x000008, "Wrong alignment on UGbxQueryManager");
static_assert(sizeof(UGbxQueryManager) == 0x0000B0, "Wrong size on UGbxQueryManager");
static_assert(offsetof(UGbxQueryManager, MaxActiveQueries) == 0x000030, "Member 'UGbxQueryManager::MaxActiveQueries' has a wrong offset!");
static_assert(offsetof(UGbxQueryManager, Queries) == 0x000038, "Member 'UGbxQueryManager::Queries' has a wrong offset!");
static_assert(offsetof(UGbxQueryManager, World) == 0x000048, "Member 'UGbxQueryManager::World' has a wrong offset!");
static_assert(offsetof(UGbxQueryManager, EnvQueryManager) == 0x000050, "Member 'UGbxQueryManager::EnvQueryManager' has a wrong offset!");

// Class GbxGameSystemCore.GbxSignificanceSettings
// 0x0050 (0x0088 - 0x0038)
class UGbxSignificanceSettings final : public UDeveloperSettings
{
public:
	TMap<class FName, struct FGbxSignificanceEventData> Events;                                            // 0x0038(0x0050)(Edit, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)

public:
	static void EnumerateSignificanceEvents(TArray<class FName>* OutEvents);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSignificanceSettings">();
	}
	static class UGbxSignificanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSignificanceSettings>();
	}
};
static_assert(alignof(UGbxSignificanceSettings) == 0x000008, "Wrong alignment on UGbxSignificanceSettings");
static_assert(sizeof(UGbxSignificanceSettings) == 0x000088, "Wrong size on UGbxSignificanceSettings");
static_assert(offsetof(UGbxSignificanceSettings, Events) == 0x000038, "Member 'UGbxSignificanceSettings::Events' has a wrong offset!");

// Class GbxGameSystemCore.GbxSkeletalMeshActor
// 0x0000 (0x04E0 - 0x04E0)
class AGbxSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSkeletalMeshActor">();
	}
	static class AGbxSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxSkeletalMeshActor>();
	}
};
static_assert(alignof(AGbxSkeletalMeshActor) == 0x000008, "Wrong alignment on AGbxSkeletalMeshActor");
static_assert(sizeof(AGbxSkeletalMeshActor) == 0x0004E0, "Wrong size on AGbxSkeletalMeshActor");

// Class GbxGameSystemCore.GbxStaticMeshComponent
// 0x0018 (0x07C0 - 0x07A8)
class UGbxStaticMeshComponent final : public UStaticMeshComponent
{
public:
	TArray<class UGbxCustomizationTargetData*>    CustomizationTargets;                              // 0x07A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxStaticMeshComponent">();
	}
	static class UGbxStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxStaticMeshComponent>();
	}
};
static_assert(alignof(UGbxStaticMeshComponent) == 0x000008, "Wrong alignment on UGbxStaticMeshComponent");
static_assert(sizeof(UGbxStaticMeshComponent) == 0x0007C0, "Wrong size on UGbxStaticMeshComponent");
static_assert(offsetof(UGbxStaticMeshComponent, CustomizationTargets) == 0x0007A8, "Member 'UGbxStaticMeshComponent::CustomizationTargets' has a wrong offset!");

// Class GbxGameSystemCore.GbxSubtitleManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxSubtitleManagerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSubtitleManagerInterface">();
	}
	static class IGbxSubtitleManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxSubtitleManagerInterface>();
	}
};
static_assert(alignof(IGbxSubtitleManagerInterface) == 0x000008, "Wrong alignment on IGbxSubtitleManagerInterface");
static_assert(sizeof(IGbxSubtitleManagerInterface) == 0x000028, "Wrong size on IGbxSubtitleManagerInterface");

// Class GbxGameSystemCore.GbxThreatSystemInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxThreatSystemInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxThreatSystemInterface">();
	}
	static class IGbxThreatSystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxThreatSystemInterface>();
	}
};
static_assert(alignof(IGbxThreatSystemInterface) == 0x000008, "Wrong alignment on IGbxThreatSystemInterface");
static_assert(sizeof(IGbxThreatSystemInterface) == 0x000028, "Wrong size on IGbxThreatSystemInterface");

// Class GbxGameSystemCore.GbxUIFormattableParameter
// 0x0000 (0x0028 - 0x0028)
class IGbxUIFormattableParameter final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUIFormattableParameter">();
	}
	static class IGbxUIFormattableParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxUIFormattableParameter>();
	}
};
static_assert(alignof(IGbxUIFormattableParameter) == 0x000008, "Wrong alignment on IGbxUIFormattableParameter");
static_assert(sizeof(IGbxUIFormattableParameter) == 0x000028, "Wrong size on IGbxUIFormattableParameter");

// Class GbxGameSystemCore.GbxUIName
// 0x0020 (0x0050 - 0x0030)
class UGbxUIName final : public UGbxDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	class FText GetFormattedText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUIName">();
	}
	static class UGbxUIName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUIName>();
	}
};
static_assert(alignof(UGbxUIName) == 0x000008, "Wrong alignment on UGbxUIName");
static_assert(sizeof(UGbxUIName) == 0x000050, "Wrong size on UGbxUIName");
static_assert(offsetof(UGbxUIName, DisplayName) == 0x000038, "Member 'UGbxUIName::DisplayName' has a wrong offset!");

// Class GbxGameSystemCore.GestaltPartData
// 0x0008 (0x0038 - 0x0030)
class UGestaltPartData : public UGbxDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestaltPartData">();
	}
	static class UGestaltPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestaltPartData>();
	}
};
static_assert(alignof(UGestaltPartData) == 0x000008, "Wrong alignment on UGestaltPartData");
static_assert(sizeof(UGestaltPartData) == 0x000038, "Wrong size on UGestaltPartData");

// Class GbxGameSystemCore.GestaltPartData_Mesh
// 0x0048 (0x0080 - 0x0038)
class UGestaltPartData_Mesh final : public UGestaltPartData
{
public:
	class UGestaltData*                           GestaltData;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   GestaltMeshPartName;                               // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AdditionalGestaltMeshPartNames;                    // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGestaltChildPartData>          ChildParts;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGestaltPartFoleyAccessory             FoleyAudioAccessory;                               // 0x0068(0x0018)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)

public:
	void EnumerateGestaltMeshPartNames(TArray<class FName>* OutPartNameList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestaltPartData_Mesh">();
	}
	static class UGestaltPartData_Mesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestaltPartData_Mesh>();
	}
};
static_assert(alignof(UGestaltPartData_Mesh) == 0x000008, "Wrong alignment on UGestaltPartData_Mesh");
static_assert(sizeof(UGestaltPartData_Mesh) == 0x000080, "Wrong size on UGestaltPartData_Mesh");
static_assert(offsetof(UGestaltPartData_Mesh, GestaltData) == 0x000038, "Member 'UGestaltPartData_Mesh::GestaltData' has a wrong offset!");
static_assert(offsetof(UGestaltPartData_Mesh, GestaltMeshPartName) == 0x000040, "Member 'UGestaltPartData_Mesh::GestaltMeshPartName' has a wrong offset!");
static_assert(offsetof(UGestaltPartData_Mesh, AdditionalGestaltMeshPartNames) == 0x000048, "Member 'UGestaltPartData_Mesh::AdditionalGestaltMeshPartNames' has a wrong offset!");
static_assert(offsetof(UGestaltPartData_Mesh, ChildParts) == 0x000058, "Member 'UGestaltPartData_Mesh::ChildParts' has a wrong offset!");
static_assert(offsetof(UGestaltPartData_Mesh, FoleyAudioAccessory) == 0x000068, "Member 'UGestaltPartData_Mesh::FoleyAudioAccessory' has a wrong offset!");

// Class GbxGameSystemCore.GestaltPartData_Random
// 0x0010 (0x0048 - 0x0038)
class UGestaltPartData_Random final : public UGestaltPartData
{
public:
	TArray<struct FGestaltRandomPartData>         RandomParts;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestaltPartData_Random">();
	}
	static class UGestaltPartData_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestaltPartData_Random>();
	}
};
static_assert(alignof(UGestaltPartData_Random) == 0x000008, "Wrong alignment on UGestaltPartData_Random");
static_assert(sizeof(UGestaltPartData_Random) == 0x000048, "Wrong size on UGestaltPartData_Random");
static_assert(offsetof(UGestaltPartData_Random, RandomParts) == 0x000038, "Member 'UGestaltPartData_Random::RandomParts' has a wrong offset!");

// Class GbxGameSystemCore.GestaltPartListData
// 0x0030 (0x0060 - 0x0030)
class UGestaltPartListData final : public UGbxDataAsset
{
public:
	TArray<class UGestaltPartData*>               RequiredParts;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGesaltOptionalPartData>        OptionalParts;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UGestaltPartData*>               SpecialParts;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestaltPartListData">();
	}
	static class UGestaltPartListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestaltPartListData>();
	}
};
static_assert(alignof(UGestaltPartListData) == 0x000008, "Wrong alignment on UGestaltPartListData");
static_assert(sizeof(UGestaltPartListData) == 0x000060, "Wrong size on UGestaltPartListData");
static_assert(offsetof(UGestaltPartListData, RequiredParts) == 0x000030, "Member 'UGestaltPartListData::RequiredParts' has a wrong offset!");
static_assert(offsetof(UGestaltPartListData, OptionalParts) == 0x000040, "Member 'UGestaltPartListData::OptionalParts' has a wrong offset!");
static_assert(offsetof(UGestaltPartListData, SpecialParts) == 0x000050, "Member 'UGestaltPartListData::SpecialParts' has a wrong offset!");

// Class GbxGameSystemCore.GlobalBoneModifyProfileState
// 0x0158 (0x0188 - 0x0030)
class UGlobalBoneModifyProfileState final : public UDataAsset
{
public:
	struct FBMPOverride                           DefaultTransform;                                  // 0x0030(0x0018)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class USkeleton>, struct FBMPOverride> SkeletonOverrides;                                 // 0x0048(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FBMPOverride> CharacterOverrides;                                // 0x0098(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<TSoftObjectPtr<class USkeleton>>         SkeletonExceptions;                                // 0x00E8(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSoftClassPtr<class UClass>>             CharacterExceptions;                               // 0x0138(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalBoneModifyProfileState">();
	}
	static class UGlobalBoneModifyProfileState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalBoneModifyProfileState>();
	}
};
static_assert(alignof(UGlobalBoneModifyProfileState) == 0x000008, "Wrong alignment on UGlobalBoneModifyProfileState");
static_assert(sizeof(UGlobalBoneModifyProfileState) == 0x000188, "Wrong size on UGlobalBoneModifyProfileState");
static_assert(offsetof(UGlobalBoneModifyProfileState, DefaultTransform) == 0x000030, "Member 'UGlobalBoneModifyProfileState::DefaultTransform' has a wrong offset!");
static_assert(offsetof(UGlobalBoneModifyProfileState, SkeletonOverrides) == 0x000048, "Member 'UGlobalBoneModifyProfileState::SkeletonOverrides' has a wrong offset!");
static_assert(offsetof(UGlobalBoneModifyProfileState, CharacterOverrides) == 0x000098, "Member 'UGlobalBoneModifyProfileState::CharacterOverrides' has a wrong offset!");
static_assert(offsetof(UGlobalBoneModifyProfileState, SkeletonExceptions) == 0x0000E8, "Member 'UGlobalBoneModifyProfileState::SkeletonExceptions' has a wrong offset!");
static_assert(offsetof(UGlobalBoneModifyProfileState, CharacterExceptions) == 0x000138, "Member 'UGlobalBoneModifyProfileState::CharacterExceptions' has a wrong offset!");

// Class GbxGameSystemCore.GlobalBoneModifyProfile
// 0x0058 (0x0080 - 0x0028)
class UGlobalBoneModifyProfile final : public UObject
{
public:
	TSet<class UGlobalBoneModifyProfileState*>    GlobalProfileSet;                                  // 0x0028(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalBoneModifyProfile">();
	}
	static class UGlobalBoneModifyProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalBoneModifyProfile>();
	}
};
static_assert(alignof(UGlobalBoneModifyProfile) == 0x000008, "Wrong alignment on UGlobalBoneModifyProfile");
static_assert(sizeof(UGlobalBoneModifyProfile) == 0x000080, "Wrong size on UGlobalBoneModifyProfile");
static_assert(offsetof(UGlobalBoneModifyProfile, GlobalProfileSet) == 0x000028, "Member 'UGlobalBoneModifyProfile::GlobalProfileSet' has a wrong offset!");

// Class GbxGameSystemCore.GlobalBoneModBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGlobalBoneModBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void K2_SetGBMP(const class UGlobalBoneModifyProfileState* State, bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalBoneModBlueprintLibrary">();
	}
	static class UGlobalBoneModBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalBoneModBlueprintLibrary>();
	}
};
static_assert(alignof(UGlobalBoneModBlueprintLibrary) == 0x000008, "Wrong alignment on UGlobalBoneModBlueprintLibrary");
static_assert(sizeof(UGlobalBoneModBlueprintLibrary) == 0x000028, "Wrong size on UGlobalBoneModBlueprintLibrary");

// Class GbxGameSystemCore.GravityOverrideVolume
// 0x0010 (0x04B0 - 0x04A0)
class AGravityOverrideVolume final : public APhysicsVolume
{
public:
	float                                         GravityZ;                                          // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTeamGravity;                                // 0x04A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverrideTeamGravity;                               // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GravityOverrideVolume">();
	}
	static class AGravityOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGravityOverrideVolume>();
	}
};
static_assert(alignof(AGravityOverrideVolume) == 0x000008, "Wrong alignment on AGravityOverrideVolume");
static_assert(sizeof(AGravityOverrideVolume) == 0x0004B0, "Wrong size on AGravityOverrideVolume");
static_assert(offsetof(AGravityOverrideVolume, GravityZ) == 0x0004A0, "Member 'AGravityOverrideVolume::GravityZ' has a wrong offset!");
static_assert(offsetof(AGravityOverrideVolume, bEnableTeamGravity) == 0x0004A4, "Member 'AGravityOverrideVolume::bEnableTeamGravity' has a wrong offset!");
static_assert(offsetof(AGravityOverrideVolume, OverrideTeamGravity) == 0x0004A8, "Member 'AGravityOverrideVolume::OverrideTeamGravity' has a wrong offset!");

// Class GbxGameSystemCore.HealthTypeData
// 0x0048 (0x0078 - 0x0030)
class UHealthTypeData final : public UGbxDataAsset
{
public:
	struct FLinearColor                           DisplayColor;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BarBackgroundFrameName;                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    BalanceData;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysMat;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      NoDamagePhysMat;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      HealthTypeModifierAttribute;                       // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthTypeData">();
	}
	static class UHealthTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthTypeData>();
	}
};
static_assert(alignof(UHealthTypeData) == 0x000008, "Wrong alignment on UHealthTypeData");
static_assert(sizeof(UHealthTypeData) == 0x000078, "Wrong size on UHealthTypeData");
static_assert(offsetof(UHealthTypeData, DisplayColor) == 0x000030, "Member 'UHealthTypeData::DisplayColor' has a wrong offset!");
static_assert(offsetof(UHealthTypeData, BarBackgroundFrameName) == 0x000040, "Member 'UHealthTypeData::BarBackgroundFrameName' has a wrong offset!");
static_assert(offsetof(UHealthTypeData, BalanceData) == 0x000050, "Member 'UHealthTypeData::BalanceData' has a wrong offset!");
static_assert(offsetof(UHealthTypeData, PhysMat) == 0x000060, "Member 'UHealthTypeData::PhysMat' has a wrong offset!");
static_assert(offsetof(UHealthTypeData, NoDamagePhysMat) == 0x000068, "Member 'UHealthTypeData::NoDamagePhysMat' has a wrong offset!");
static_assert(offsetof(UHealthTypeData, HealthTypeModifierAttribute) == 0x000070, "Member 'UHealthTypeData::HealthTypeModifierAttribute' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitReactionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddHitReactionDeathLayer(class AActor* Actor, TSubclassOf<class UHitReactionLayer> Layer);
	static void AddHitReactionLiveLayer(class AActor* Actor, TSubclassOf<class UHitReactionLayer> Layer);
	static bool IsHitReactionTagActive(class AActor* Actor, class UHitReactionTag* Tag);
	static int32 K2_GetBoneIndexFromAction(class UGbxAction* Action);
	static float K2_GetForceFromAction(class UGbxAction* Action);
	static float K2_GetHealthPercentFromAction(class UGbxAction* Action);
	static class UObject* K2_GetHitCauserFromAction(class UGbxAction* Action);
	static struct FVector K2_GetHitDirectionFromAction(class UGbxAction* Action, bool bLocalSpace);
	static struct FVector K2_GetHitLocationFromAction(class UGbxAction* Action);
	static void RemoveHitReactionDeathLayer(class AActor* Actor, TSubclassOf<class UHitReactionLayer> Layer);
	static void RemoveHitReactionLiveLayer(class AActor* Actor, TSubclassOf<class UHitReactionLayer> Layer);
	static void ResourceLockHitReactions(class AActor* Actor, class FName Reason);
	static void ResourceUnlockHitReactions(class AActor* Actor, class FName Reason);
	static void ScriptDeath(class AActor* Actor, class AActor* Causer, class UHitReactionTag* Tag, const struct FVector& LocalHitDirection, class FName BoneName, const struct FForceSelection& Force);
	static void ScriptHitReaction(class AActor* Actor, class AActor* Causer, class UHitReactionTag* Tag, const struct FVector& LocalHitDirection, class FName BoneName, const struct FForceSelection& Force);
	static void SetHitReactionData(class AActor* Actor, class UHitReactionData* HitReactionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionBlueprintLibrary">();
	}
	static class UHitReactionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionBlueprintLibrary>();
	}
};
static_assert(alignof(UHitReactionBlueprintLibrary) == 0x000008, "Wrong alignment on UHitReactionBlueprintLibrary");
static_assert(sizeof(UHitReactionBlueprintLibrary) == 0x000028, "Wrong size on UHitReactionBlueprintLibrary");

// Class GbxGameSystemCore.HitReactionLayer_Blueprint
// 0x0000 (0x0030 - 0x0030)
class UHitReactionLayer_Blueprint : public UHitReactionLayer
{
public:
	class UHitReactionTag* EvaluateTag(class UDamageComponent* Receiver, class UDamageCauserComponent* Causer, float DamageAmount, const class UGbxDamageType* DamageType, const class UDamageSource* DamageSource, class UHitRegionData* HitRegion, float Force, class UHitReactionTag* PreviousTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer_Blueprint">();
	}
	static class UHitReactionLayer_Blueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer_Blueprint>();
	}
};
static_assert(alignof(UHitReactionLayer_Blueprint) == 0x000008, "Wrong alignment on UHitReactionLayer_Blueprint");
static_assert(sizeof(UHitReactionLayer_Blueprint) == 0x000030, "Wrong size on UHitReactionLayer_Blueprint");

// Class GbxGameSystemCore.HitReactionLayer_Combine
// 0x0028 (0x0058 - 0x0030)
class UHitReactionLayer_Combine final : public UHitReactionLayer
{
public:
	TArray<TSubclassOf<class UHitReactionLayer>>  SubLayers;                                         // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UHitReactionTag*>                PriorityList;                                      // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bMissingTagsAreHighestPriority;                    // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer_Combine">();
	}
	static class UHitReactionLayer_Combine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer_Combine>();
	}
};
static_assert(alignof(UHitReactionLayer_Combine) == 0x000008, "Wrong alignment on UHitReactionLayer_Combine");
static_assert(sizeof(UHitReactionLayer_Combine) == 0x000058, "Wrong size on UHitReactionLayer_Combine");
static_assert(offsetof(UHitReactionLayer_Combine, SubLayers) == 0x000030, "Member 'UHitReactionLayer_Combine::SubLayers' has a wrong offset!");
static_assert(offsetof(UHitReactionLayer_Combine, PriorityList) == 0x000040, "Member 'UHitReactionLayer_Combine::PriorityList' has a wrong offset!");
static_assert(offsetof(UHitReactionLayer_Combine, bMissingTagsAreHighestPriority) == 0x000050, "Member 'UHitReactionLayer_Combine::bMissingTagsAreHighestPriority' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionLayer_Condition
// 0x0020 (0x0050 - 0x0030)
class UHitReactionLayer_Condition : public UHitReactionLayer
{
public:
	TArray<struct FHitReactionCondition>          Conditions;                                        // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EHitReactionConditionCombine                  Combine;                                           // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHitReactionLayer>          SubLayer;                                          // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer_Condition">();
	}
	static class UHitReactionLayer_Condition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer_Condition>();
	}
};
static_assert(alignof(UHitReactionLayer_Condition) == 0x000008, "Wrong alignment on UHitReactionLayer_Condition");
static_assert(sizeof(UHitReactionLayer_Condition) == 0x000050, "Wrong size on UHitReactionLayer_Condition");
static_assert(offsetof(UHitReactionLayer_Condition, Conditions) == 0x000030, "Member 'UHitReactionLayer_Condition::Conditions' has a wrong offset!");
static_assert(offsetof(UHitReactionLayer_Condition, Combine) == 0x000040, "Member 'UHitReactionLayer_Condition::Combine' has a wrong offset!");
static_assert(offsetof(UHitReactionLayer_Condition, SubLayer) == 0x000048, "Member 'UHitReactionLayer_Condition::SubLayer' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionLayer_Cooldown
// 0x0018 (0x0048 - 0x0030)
class UHitReactionLayer_Cooldown : public UHitReactionLayer
{
public:
	float                                         DefaultCooldown;                                   // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitReactionCooldownData>       Cooldowns;                                         // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer_Cooldown">();
	}
	static class UHitReactionLayer_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer_Cooldown>();
	}
};
static_assert(alignof(UHitReactionLayer_Cooldown) == 0x000008, "Wrong alignment on UHitReactionLayer_Cooldown");
static_assert(sizeof(UHitReactionLayer_Cooldown) == 0x000048, "Wrong size on UHitReactionLayer_Cooldown");
static_assert(offsetof(UHitReactionLayer_Cooldown, DefaultCooldown) == 0x000030, "Member 'UHitReactionLayer_Cooldown::DefaultCooldown' has a wrong offset!");
static_assert(offsetof(UHitReactionLayer_Cooldown, Cooldowns) == 0x000038, "Member 'UHitReactionLayer_Cooldown::Cooldowns' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionLayer_Priority
// 0x0020 (0x0050 - 0x0030)
class UHitReactionLayer_Priority : public UHitReactionLayer
{
public:
	TArray<class UHitReactionTag*>                PriorityList;                                      // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UHitReactionTag*>                CanInterruptSelf;                                  // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionLayer_Priority">();
	}
	static class UHitReactionLayer_Priority* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionLayer_Priority>();
	}
};
static_assert(alignof(UHitReactionLayer_Priority) == 0x000008, "Wrong alignment on UHitReactionLayer_Priority");
static_assert(sizeof(UHitReactionLayer_Priority) == 0x000050, "Wrong size on UHitReactionLayer_Priority");
static_assert(offsetof(UHitReactionLayer_Priority, PriorityList) == 0x000030, "Member 'UHitReactionLayer_Priority::PriorityList' has a wrong offset!");
static_assert(offsetof(UHitReactionLayer_Priority, CanInterruptSelf) == 0x000040, "Member 'UHitReactionLayer_Priority::CanInterruptSelf' has a wrong offset!");

// Class GbxGameSystemCore.HitReactionTag
// 0x0010 (0x0040 - 0x0030)
class UHitReactionTag final : public UGbxDataAsset
{
public:
	class UCharacterSoundTag*                     SoundTag;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        CensoredTag;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionTag">();
	}
	static class UHitReactionTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionTag>();
	}
};
static_assert(alignof(UHitReactionTag) == 0x000008, "Wrong alignment on UHitReactionTag");
static_assert(sizeof(UHitReactionTag) == 0x000040, "Wrong size on UHitReactionTag");
static_assert(offsetof(UHitReactionTag, SoundTag) == 0x000030, "Member 'UHitReactionTag::SoundTag' has a wrong offset!");
static_assert(offsetof(UHitReactionTag, CensoredTag) == 0x000038, "Member 'UHitReactionTag::CensoredTag' has a wrong offset!");

// Class GbxGameSystemCore.HitRegionFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitRegionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AssociateComponentWithHitRegion(class AActor* Actor, class UPrimitiveComponent* ComponentToAssociate, class UHitRegionData* HitRegion);
	static void RefillHitRegionHealthByAmount(float RefillAmount, class AActor* Actor, class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent);
	static void RefillHitRegionHealthByPercent(float RefillPercent, class AActor* Actor, class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent);
	static void ResetAllHitRegionHealth(class AActor* Actor);
	static void ResetHitRegionHealth(class AActor* Actor, class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitRegionFunctionLibrary">();
	}
	static class UHitRegionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitRegionFunctionLibrary>();
	}
};
static_assert(alignof(UHitRegionFunctionLibrary) == 0x000008, "Wrong alignment on UHitRegionFunctionLibrary");
static_assert(sizeof(UHitRegionFunctionLibrary) == 0x000028, "Wrong size on UHitRegionFunctionLibrary");

// Class GbxGameSystemCore.IGbxProjectileManager
// 0x0000 (0x0028 - 0x0028)
class UIGbxProjectileManager : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGbxProjectileManager">();
	}
	static class UIGbxProjectileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGbxProjectileManager>();
	}
};
static_assert(alignof(UIGbxProjectileManager) == 0x000008, "Wrong alignment on UIGbxProjectileManager");
static_assert(sizeof(UIGbxProjectileManager) == 0x000028, "Wrong size on UIGbxProjectileManager");

// Class GbxGameSystemCore.GbxReplicatorProxyData
// 0x0000 (0x0028 - 0x0028)
class IGbxReplicatorProxyData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxReplicatorProxyData">();
	}
	static class IGbxReplicatorProxyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxReplicatorProxyData>();
	}
};
static_assert(alignof(IGbxReplicatorProxyData) == 0x000008, "Wrong alignment on IGbxReplicatorProxyData");
static_assert(sizeof(IGbxReplicatorProxyData) == 0x000028, "Wrong size on IGbxReplicatorProxyData");

// Class GbxGameSystemCore.InspectionInfoProvider
// 0x0000 (0x0028 - 0x0028)
class IInspectionInfoProvider final : public IInterface
{
public:
	void GetInspectionInfo(struct FInspectionInfo& InspectionInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectionInfoProvider">();
	}
	static class IInspectionInfoProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInspectionInfoProvider>();
	}
};
static_assert(alignof(IInspectionInfoProvider) == 0x000008, "Wrong alignment on IInspectionInfoProvider");
static_assert(sizeof(IInspectionInfoProvider) == 0x000028, "Wrong size on IInspectionInfoProvider");

// Class GbxGameSystemCore.ImpactData
// 0x02F0 (0x0320 - 0x0030)
class UImpactData final : public UGbxDataAsset
{
public:
	class UImpactData*                            ParentImpact;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EImpactUsage                                  Usage;                                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideParentUnconditionalResponse;              // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpactResponseEffect                  UnconditionalResponse;                             // 0x0040(0x0140)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideParentDefaultResponse;                    // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpactResponseEffect                  DefaultResponse;                                   // 0x0190(0x0140)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FImpactResponseInfo>            ImpactResponses;                                   // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UWwiseEvent*                            DefaultImpactWwiseEvent;                           // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FImpactTriggerInfo                     TriggerInfo;                                       // 0x02E8(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxSignificanceEvent                  DefaultSignificanceEvent;                          // 0x02F0(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         LayeredPhysicalResponseQuality;                    // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LayeredParentPhysicalResponseQuality;              // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideParentProximityThrottling;                // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableProximityThrottling;                        // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x16];                                     // 0x0302(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         FrameLimit;                                        // 0x0318(0x0002)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMassWwiseParameter;                            // 0x031A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31B[0x5];                                      // 0x031B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactData">();
	}
	static class UImpactData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpactData>();
	}
};
static_assert(alignof(UImpactData) == 0x000010, "Wrong alignment on UImpactData");
static_assert(sizeof(UImpactData) == 0x000320, "Wrong size on UImpactData");
static_assert(offsetof(UImpactData, ParentImpact) == 0x000030, "Member 'UImpactData::ParentImpact' has a wrong offset!");
static_assert(offsetof(UImpactData, Usage) == 0x000038, "Member 'UImpactData::Usage' has a wrong offset!");
static_assert(offsetof(UImpactData, bOverrideParentUnconditionalResponse) == 0x000039, "Member 'UImpactData::bOverrideParentUnconditionalResponse' has a wrong offset!");
static_assert(offsetof(UImpactData, UnconditionalResponse) == 0x000040, "Member 'UImpactData::UnconditionalResponse' has a wrong offset!");
static_assert(offsetof(UImpactData, bOverrideParentDefaultResponse) == 0x000180, "Member 'UImpactData::bOverrideParentDefaultResponse' has a wrong offset!");
static_assert(offsetof(UImpactData, DefaultResponse) == 0x000190, "Member 'UImpactData::DefaultResponse' has a wrong offset!");
static_assert(offsetof(UImpactData, ImpactResponses) == 0x0002D0, "Member 'UImpactData::ImpactResponses' has a wrong offset!");
static_assert(offsetof(UImpactData, DefaultImpactWwiseEvent) == 0x0002E0, "Member 'UImpactData::DefaultImpactWwiseEvent' has a wrong offset!");
static_assert(offsetof(UImpactData, TriggerInfo) == 0x0002E8, "Member 'UImpactData::TriggerInfo' has a wrong offset!");
static_assert(offsetof(UImpactData, DefaultSignificanceEvent) == 0x0002F0, "Member 'UImpactData::DefaultSignificanceEvent' has a wrong offset!");
static_assert(offsetof(UImpactData, LayeredPhysicalResponseQuality) == 0x0002F8, "Member 'UImpactData::LayeredPhysicalResponseQuality' has a wrong offset!");
static_assert(offsetof(UImpactData, LayeredParentPhysicalResponseQuality) == 0x0002FC, "Member 'UImpactData::LayeredParentPhysicalResponseQuality' has a wrong offset!");
static_assert(offsetof(UImpactData, bOverrideParentProximityThrottling) == 0x000300, "Member 'UImpactData::bOverrideParentProximityThrottling' has a wrong offset!");
static_assert(offsetof(UImpactData, bEnableProximityThrottling) == 0x000301, "Member 'UImpactData::bEnableProximityThrottling' has a wrong offset!");
static_assert(offsetof(UImpactData, FrameLimit) == 0x000318, "Member 'UImpactData::FrameLimit' has a wrong offset!");
static_assert(offsetof(UImpactData, bUseMassWwiseParameter) == 0x00031A, "Member 'UImpactData::bUseMassWwiseParameter' has a wrong offset!");

// Class GbxGameSystemCore.ImpactDataOverride
// 0x0000 (0x0028 - 0x0028)
class IImpactDataOverride final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactDataOverride">();
	}
	static class IImpactDataOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<IImpactDataOverride>();
	}
};
static_assert(alignof(IImpactDataOverride) == 0x000008, "Wrong alignment on IImpactDataOverride");
static_assert(sizeof(IImpactDataOverride) == 0x000028, "Wrong size on IImpactDataOverride");

// Class GbxGameSystemCore.PooledImpactDecalComponent
// 0x0020 (0x0740 - 0x0720)
class UPooledImpactDecalComponent final : public UDecalComponent
{
public:
	uint8                                         Pad_720[0x20];                                     // 0x0720(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledImpactDecalComponent">();
	}
	static class UPooledImpactDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPooledImpactDecalComponent>();
	}
};
static_assert(alignof(UPooledImpactDecalComponent) == 0x000008, "Wrong alignment on UPooledImpactDecalComponent");
static_assert(sizeof(UPooledImpactDecalComponent) == 0x000740, "Wrong size on UPooledImpactDecalComponent");

// Class GbxGameSystemCore.UIStatData_Text
// 0x0030 (0x0098 - 0x0068)
class UUIStatData_Text final : public UUIStatData
{
public:
	class FText                                   Text;                                              // 0x0068(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   TextWithAdditionalInput;                           // 0x0080(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatData_Text">();
	}
	static class UUIStatData_Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatData_Text>();
	}
};
static_assert(alignof(UUIStatData_Text) == 0x000008, "Wrong alignment on UUIStatData_Text");
static_assert(sizeof(UUIStatData_Text) == 0x000098, "Wrong size on UUIStatData_Text");
static_assert(offsetof(UUIStatData_Text, Text) == 0x000068, "Member 'UUIStatData_Text::Text' has a wrong offset!");
static_assert(offsetof(UUIStatData_Text, TextWithAdditionalInput) == 0x000080, "Member 'UUIStatData_Text::TextWithAdditionalInput' has a wrong offset!");

// Class GbxGameSystemCore.ImpactFXManagerComponent
// 0x0090 (0x0208 - 0x0178)
class UImpactFXManagerComponent final : public UActorComponent
{
public:
	bool                                          bScaleImpactDecalEffects;                          // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            BounceEffect;                                      // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceEffectThreshold;                             // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceEffectFrequency;                             // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignBounceEffectToVelocity;                      // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            SlideEffect;                                       // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideEffectThreshold;                              // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideEffectStopThreshold;                          // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideEffectFrequency;                              // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSlideEffectDelay;                             // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideSlideEffectOrigin;                        // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlideEffectOriginSocket;                           // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffectsEnabled;                                   // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoEnableCollisionNotifications;                 // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C2[0x36];                                     // 0x01C2(0x0036)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FImpactFXManagerTrackingData>   ActiveSlideEffects;                                // 0x01F8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnTrackedComponentDeactivated(class UActorComponent* Component);
	void OnTrackedParticleSystemFinished(class UParticleSystemComponent* PSC);
	void SetEffectsEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactFXManagerComponent">();
	}
	static class UImpactFXManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpactFXManagerComponent>();
	}
};
static_assert(alignof(UImpactFXManagerComponent) == 0x000008, "Wrong alignment on UImpactFXManagerComponent");
static_assert(sizeof(UImpactFXManagerComponent) == 0x000208, "Wrong size on UImpactFXManagerComponent");
static_assert(offsetof(UImpactFXManagerComponent, bScaleImpactDecalEffects) == 0x000178, "Member 'UImpactFXManagerComponent::bScaleImpactDecalEffects' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, BounceEffect) == 0x000180, "Member 'UImpactFXManagerComponent::BounceEffect' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, BounceEffectThreshold) == 0x000188, "Member 'UImpactFXManagerComponent::BounceEffectThreshold' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, BounceEffectFrequency) == 0x00018C, "Member 'UImpactFXManagerComponent::BounceEffectFrequency' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, bAlignBounceEffectToVelocity) == 0x000190, "Member 'UImpactFXManagerComponent::bAlignBounceEffectToVelocity' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, SlideEffect) == 0x000198, "Member 'UImpactFXManagerComponent::SlideEffect' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, SlideEffectThreshold) == 0x0001A0, "Member 'UImpactFXManagerComponent::SlideEffectThreshold' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, SlideEffectStopThreshold) == 0x0001A4, "Member 'UImpactFXManagerComponent::SlideEffectStopThreshold' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, SlideEffectFrequency) == 0x0001A8, "Member 'UImpactFXManagerComponent::SlideEffectFrequency' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, StartSlideEffectDelay) == 0x0001AC, "Member 'UImpactFXManagerComponent::StartSlideEffectDelay' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, bOverrideSlideEffectOrigin) == 0x0001B0, "Member 'UImpactFXManagerComponent::bOverrideSlideEffectOrigin' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, SlideEffectOriginSocket) == 0x0001B8, "Member 'UImpactFXManagerComponent::SlideEffectOriginSocket' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, bEffectsEnabled) == 0x0001C0, "Member 'UImpactFXManagerComponent::bEffectsEnabled' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, bAutoEnableCollisionNotifications) == 0x0001C1, "Member 'UImpactFXManagerComponent::bAutoEnableCollisionNotifications' has a wrong offset!");
static_assert(offsetof(UImpactFXManagerComponent, ActiveSlideEffects) == 0x0001F8, "Member 'UImpactFXManagerComponent::ActiveSlideEffects' has a wrong offset!");

// Class GbxGameSystemCore.InspectionInfoFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UInspectionInfoFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAboveActorOutput(struct FInspectionInfo& InspectionInfo, const class FString& String, EDebugDisplayVerbosityLevel Verbosity);
	static void AddScreenOutput(struct FInspectionInfo& InspectionInfo, const class FString& String, EDebugDisplayVerbosityLevel Verbosity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectionInfoFunctionLibrary">();
	}
	static class UInspectionInfoFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectionInfoFunctionLibrary>();
	}
};
static_assert(alignof(UInspectionInfoFunctionLibrary) == 0x000008, "Wrong alignment on UInspectionInfoFunctionLibrary");
static_assert(sizeof(UInspectionInfoFunctionLibrary) == 0x000028, "Wrong size on UInspectionInfoFunctionLibrary");

// Class GbxGameSystemCore.InterpComponent
// 0x00A0 (0x0218 - 0x0178)
class UInterpComponent final : public UActorComponent
{
public:
	bool                                          bRemoveOnCompletion;                               // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdateVelocity;                                   // 0x0179(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClearVelocity;                                    // 0x017A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bManualTick;                                       // 0x017B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInterpYawOnly;                                    // 0x017C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBallistics;                                       // 0x017D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMatchRotationToVelocity;                          // 0x017E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetToInitialWhenFinished;                         // 0x017F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRelative;                                         // 0x0180(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InterpActor;                                       // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AController*                            InterpController;                                  // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPawnMovementComponent*                 InterpMoveComp;                                    // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInterpMode                                   InterpLocMode;                                     // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpLocTime;                                     // 0x01A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InterpLocElapsedTime;                              // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                InterpLocDiff;                                     // 0x01AC(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                InterpLocPrev;                                     // 0x01B8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInterpMode                                   InterpRotMode;                                     // 0x01C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpRotTime;                                     // 0x01C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InterpRotElapsedTime;                              // 0x01CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               InterpRotDiff;                                     // 0x01D0(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               InterpRotPrev;                                     // 0x01DC(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               InitialRotation;                                   // 0x01E8(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                BallisticsStartLoc;                                // 0x01F4(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BallisticsStartVelocity;                           // 0x0200(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BallisticsGravity;                                 // 0x020C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BallisticsStartTime;                               // 0x0210(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BallisticsTotalTime;                               // 0x0214(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float InterpBallistics(const struct FVector& StartLoc, const struct FVector& EndLoc, float LeapSpeed, float LeapAngle);
	struct FVector InterpBallisticsByTime(const struct FVector& StartLoc, const struct FVector& EndLoc, float LeapTime, float LeapGravity);
	void InterpDeltaLocation(const struct FVector& DeltaLoc, float InterpTime, bool bLinear, bool bNoZ, bool bInRelative);
	void InterpDeltaRotation(const struct FRotator& DeltaRot, float InterpTime, bool bLinear, bool bYawOnly, bool bInRelative);
	void InterpLocation(const struct FVector& NewLoc, float InterpTime, bool bLinear, bool bNoZ, bool bInRelative);
	void InterpRotation(const struct FRotator& NewRot, float InterpTime, bool bLinear, bool bYawOnly, bool bInRelative);
	void ManualTick(float DeltaTime);
	void MatchRotationToVelocity(bool bInSetToInitialWhenFinished);
	void SetClearVelocity(bool bNewClearVelocity);
	void SetManualTick(bool bManual);
	void SetRemoveOnCompletion(bool bRemove);
	void SetUpdateVelocity(bool bNewUpdateVelocity);
	void Stop();

	bool IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpComponent">();
	}
	static class UInterpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpComponent>();
	}
};
static_assert(alignof(UInterpComponent) == 0x000008, "Wrong alignment on UInterpComponent");
static_assert(sizeof(UInterpComponent) == 0x000218, "Wrong size on UInterpComponent");
static_assert(offsetof(UInterpComponent, bRemoveOnCompletion) == 0x000178, "Member 'UInterpComponent::bRemoveOnCompletion' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bUpdateVelocity) == 0x000179, "Member 'UInterpComponent::bUpdateVelocity' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bClearVelocity) == 0x00017A, "Member 'UInterpComponent::bClearVelocity' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bManualTick) == 0x00017B, "Member 'UInterpComponent::bManualTick' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bInterpYawOnly) == 0x00017C, "Member 'UInterpComponent::bInterpYawOnly' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bBallistics) == 0x00017D, "Member 'UInterpComponent::bBallistics' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bMatchRotationToVelocity) == 0x00017E, "Member 'UInterpComponent::bMatchRotationToVelocity' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bSetToInitialWhenFinished) == 0x00017F, "Member 'UInterpComponent::bSetToInitialWhenFinished' has a wrong offset!");
static_assert(offsetof(UInterpComponent, bRelative) == 0x000180, "Member 'UInterpComponent::bRelative' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpActor) == 0x000188, "Member 'UInterpComponent::InterpActor' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpController) == 0x000190, "Member 'UInterpComponent::InterpController' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpMoveComp) == 0x000198, "Member 'UInterpComponent::InterpMoveComp' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpLocMode) == 0x0001A0, "Member 'UInterpComponent::InterpLocMode' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpLocTime) == 0x0001A4, "Member 'UInterpComponent::InterpLocTime' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpLocElapsedTime) == 0x0001A8, "Member 'UInterpComponent::InterpLocElapsedTime' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpLocDiff) == 0x0001AC, "Member 'UInterpComponent::InterpLocDiff' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpLocPrev) == 0x0001B8, "Member 'UInterpComponent::InterpLocPrev' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpRotMode) == 0x0001C4, "Member 'UInterpComponent::InterpRotMode' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpRotTime) == 0x0001C8, "Member 'UInterpComponent::InterpRotTime' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpRotElapsedTime) == 0x0001CC, "Member 'UInterpComponent::InterpRotElapsedTime' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpRotDiff) == 0x0001D0, "Member 'UInterpComponent::InterpRotDiff' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InterpRotPrev) == 0x0001DC, "Member 'UInterpComponent::InterpRotPrev' has a wrong offset!");
static_assert(offsetof(UInterpComponent, InitialRotation) == 0x0001E8, "Member 'UInterpComponent::InitialRotation' has a wrong offset!");
static_assert(offsetof(UInterpComponent, BallisticsStartLoc) == 0x0001F4, "Member 'UInterpComponent::BallisticsStartLoc' has a wrong offset!");
static_assert(offsetof(UInterpComponent, BallisticsStartVelocity) == 0x000200, "Member 'UInterpComponent::BallisticsStartVelocity' has a wrong offset!");
static_assert(offsetof(UInterpComponent, BallisticsGravity) == 0x00020C, "Member 'UInterpComponent::BallisticsGravity' has a wrong offset!");
static_assert(offsetof(UInterpComponent, BallisticsStartTime) == 0x000210, "Member 'UInterpComponent::BallisticsStartTime' has a wrong offset!");
static_assert(offsetof(UInterpComponent, BallisticsTotalTime) == 0x000214, "Member 'UInterpComponent::BallisticsTotalTime' has a wrong offset!");

// Class GbxGameSystemCore.Ladder
// 0x00E8 (0x0540 - 0x0458)
class ALadder : public AActor
{
public:
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EComponentMobility                            Mobility;                                          // 0x0460(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SegmentMesh;                                       // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             SegmentMeshMaterialOverrides;                      // 0x0470(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            TopMesh;                                           // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             TopMeshMaterialOverrides;                          // 0x0488(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         BottomAndTopMeshLDMaxDrawDistance;                 // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bBottomAndTopMeshNeverDistanceCull : 1;            // 0x049C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_49D[0x3];                                      // 0x049D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BottomMesh;                                        // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             BottomMeshMaterialOverrides;                       // 0x04A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         SegmentSpacing;                                    // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                SegmentOffset;                                     // 0x04BC(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SegmentRotation;                                   // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TopOffset;                                         // 0x04CC(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopRotation;                                       // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BottomOffset;                                      // 0x04DC(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BottomRotation;                                    // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VolumeDepth;                                       // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VolumeWidth;                                       // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VolumeExtraTopHeight;                              // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VolumeExtraBottomHeight;                           // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopVolumeDepth;                                    // 0x04FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                VolumeOffset;                                      // 0x0500(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterOffset;                                   // 0x050C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumSegments;                                       // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bHideTopMesh : 1;                                  // 0x0514(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bHideBottomMesh : 1;                               // 0x0514(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          SegmentMeshComponent;                              // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   TopMeshComponent;                                  // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   BottomMeshComponent;                               // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          VolumeBoxComponent;                                // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          TopVolumeBoxComponent;                             // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ladder">();
	}
	static class ALadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadder>();
	}
};
static_assert(alignof(ALadder) == 0x000008, "Wrong alignment on ALadder");
static_assert(sizeof(ALadder) == 0x000540, "Wrong size on ALadder");
static_assert(offsetof(ALadder, Mobility) == 0x000460, "Member 'ALadder::Mobility' has a wrong offset!");
static_assert(offsetof(ALadder, SegmentMesh) == 0x000468, "Member 'ALadder::SegmentMesh' has a wrong offset!");
static_assert(offsetof(ALadder, SegmentMeshMaterialOverrides) == 0x000470, "Member 'ALadder::SegmentMeshMaterialOverrides' has a wrong offset!");
static_assert(offsetof(ALadder, TopMesh) == 0x000480, "Member 'ALadder::TopMesh' has a wrong offset!");
static_assert(offsetof(ALadder, TopMeshMaterialOverrides) == 0x000488, "Member 'ALadder::TopMeshMaterialOverrides' has a wrong offset!");
static_assert(offsetof(ALadder, BottomAndTopMeshLDMaxDrawDistance) == 0x000498, "Member 'ALadder::BottomAndTopMeshLDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(ALadder, BottomMesh) == 0x0004A0, "Member 'ALadder::BottomMesh' has a wrong offset!");
static_assert(offsetof(ALadder, BottomMeshMaterialOverrides) == 0x0004A8, "Member 'ALadder::BottomMeshMaterialOverrides' has a wrong offset!");
static_assert(offsetof(ALadder, SegmentSpacing) == 0x0004B8, "Member 'ALadder::SegmentSpacing' has a wrong offset!");
static_assert(offsetof(ALadder, SegmentOffset) == 0x0004BC, "Member 'ALadder::SegmentOffset' has a wrong offset!");
static_assert(offsetof(ALadder, SegmentRotation) == 0x0004C8, "Member 'ALadder::SegmentRotation' has a wrong offset!");
static_assert(offsetof(ALadder, TopOffset) == 0x0004CC, "Member 'ALadder::TopOffset' has a wrong offset!");
static_assert(offsetof(ALadder, TopRotation) == 0x0004D8, "Member 'ALadder::TopRotation' has a wrong offset!");
static_assert(offsetof(ALadder, BottomOffset) == 0x0004DC, "Member 'ALadder::BottomOffset' has a wrong offset!");
static_assert(offsetof(ALadder, BottomRotation) == 0x0004E8, "Member 'ALadder::BottomRotation' has a wrong offset!");
static_assert(offsetof(ALadder, VolumeDepth) == 0x0004EC, "Member 'ALadder::VolumeDepth' has a wrong offset!");
static_assert(offsetof(ALadder, VolumeWidth) == 0x0004F0, "Member 'ALadder::VolumeWidth' has a wrong offset!");
static_assert(offsetof(ALadder, VolumeExtraTopHeight) == 0x0004F4, "Member 'ALadder::VolumeExtraTopHeight' has a wrong offset!");
static_assert(offsetof(ALadder, VolumeExtraBottomHeight) == 0x0004F8, "Member 'ALadder::VolumeExtraBottomHeight' has a wrong offset!");
static_assert(offsetof(ALadder, TopVolumeDepth) == 0x0004FC, "Member 'ALadder::TopVolumeDepth' has a wrong offset!");
static_assert(offsetof(ALadder, VolumeOffset) == 0x000500, "Member 'ALadder::VolumeOffset' has a wrong offset!");
static_assert(offsetof(ALadder, CharacterOffset) == 0x00050C, "Member 'ALadder::CharacterOffset' has a wrong offset!");
static_assert(offsetof(ALadder, NumSegments) == 0x000510, "Member 'ALadder::NumSegments' has a wrong offset!");
static_assert(offsetof(ALadder, SegmentMeshComponent) == 0x000518, "Member 'ALadder::SegmentMeshComponent' has a wrong offset!");
static_assert(offsetof(ALadder, TopMeshComponent) == 0x000520, "Member 'ALadder::TopMeshComponent' has a wrong offset!");
static_assert(offsetof(ALadder, BottomMeshComponent) == 0x000528, "Member 'ALadder::BottomMeshComponent' has a wrong offset!");
static_assert(offsetof(ALadder, VolumeBoxComponent) == 0x000530, "Member 'ALadder::VolumeBoxComponent' has a wrong offset!");
static_assert(offsetof(ALadder, TopVolumeBoxComponent) == 0x000538, "Member 'ALadder::TopVolumeBoxComponent' has a wrong offset!");

// Class GbxGameSystemCore.LadderVolume
// 0x0020 (0x04B0 - 0x0490)
class ALadderVolume final : public AVolume
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClimbDirection;                                    // 0x0498(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Normal;                                            // 0x04A4(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderVolume">();
	}
	static class ALadderVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadderVolume>();
	}
};
static_assert(alignof(ALadderVolume) == 0x000008, "Wrong alignment on ALadderVolume");
static_assert(sizeof(ALadderVolume) == 0x0004B0, "Wrong size on ALadderVolume");
static_assert(offsetof(ALadderVolume, ClimbDirection) == 0x000498, "Member 'ALadderVolume::ClimbDirection' has a wrong offset!");
static_assert(offsetof(ALadderVolume, Normal) == 0x0004A4, "Member 'ALadderVolume::Normal' has a wrong offset!");

// Class GbxGameSystemCore.LandingData
// 0x0010 (0x0040 - 0x0030)
class ULandingData final : public UGbxDataAsset
{
public:
	TArray<struct FLandingInfo>                   LandingData;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingData">();
	}
	static class ULandingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandingData>();
	}
};
static_assert(alignof(ULandingData) == 0x000008, "Wrong alignment on ULandingData");
static_assert(sizeof(ULandingData) == 0x000040, "Wrong size on ULandingData");
static_assert(offsetof(ULandingData, LandingData) == 0x000030, "Member 'ULandingData::LandingData' has a wrong offset!");

// Class GbxGameSystemCore.MantleData
// 0x0038 (0x0068 - 0x0030)
class UMantleData final : public UGbxDataAsset
{
public:
	TArray<struct FMantleActionData>              Actions;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ActionSlotToEnd;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAlignToEdgeAngle;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdjustedHeightDifference;                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredLedgeDepth;                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallHopHeightMax;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallHopDestinationHeightMax;                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallHopDestinationHeightMin;                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallHopDepth;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MantleData">();
	}
	static class UMantleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMantleData>();
	}
};
static_assert(alignof(UMantleData) == 0x000008, "Wrong alignment on UMantleData");
static_assert(sizeof(UMantleData) == 0x000068, "Wrong size on UMantleData");
static_assert(offsetof(UMantleData, Actions) == 0x000030, "Member 'UMantleData::Actions' has a wrong offset!");
static_assert(offsetof(UMantleData, ActionSlotToEnd) == 0x000040, "Member 'UMantleData::ActionSlotToEnd' has a wrong offset!");
static_assert(offsetof(UMantleData, MaxAlignToEdgeAngle) == 0x000048, "Member 'UMantleData::MaxAlignToEdgeAngle' has a wrong offset!");
static_assert(offsetof(UMantleData, MaxAdjustedHeightDifference) == 0x00004C, "Member 'UMantleData::MaxAdjustedHeightDifference' has a wrong offset!");
static_assert(offsetof(UMantleData, RequiredLedgeDepth) == 0x000050, "Member 'UMantleData::RequiredLedgeDepth' has a wrong offset!");
static_assert(offsetof(UMantleData, WallHopHeightMax) == 0x000054, "Member 'UMantleData::WallHopHeightMax' has a wrong offset!");
static_assert(offsetof(UMantleData, WallHopDestinationHeightMax) == 0x000058, "Member 'UMantleData::WallHopDestinationHeightMax' has a wrong offset!");
static_assert(offsetof(UMantleData, WallHopDestinationHeightMin) == 0x00005C, "Member 'UMantleData::WallHopDestinationHeightMin' has a wrong offset!");
static_assert(offsetof(UMantleData, WallHopDepth) == 0x000060, "Member 'UMantleData::WallHopDepth' has a wrong offset!");

// Class GbxGameSystemCore.ModifierMathAttributeValueResolver
// 0x0048 (0x0070 - 0x0028)
class UModifierMathAttributeValueResolver final : public UAttributeValueResolver
{
public:
	struct FAttributeInitializationData           BaseValue;                                         // 0x0028(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FModifierMathAttributeValueResolverStackEntry> ModifierStack;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModifierMathAttributeValueResolver">();
	}
	static class UModifierMathAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModifierMathAttributeValueResolver>();
	}
};
static_assert(alignof(UModifierMathAttributeValueResolver) == 0x000008, "Wrong alignment on UModifierMathAttributeValueResolver");
static_assert(sizeof(UModifierMathAttributeValueResolver) == 0x000070, "Wrong size on UModifierMathAttributeValueResolver");
static_assert(offsetof(UModifierMathAttributeValueResolver, BaseValue) == 0x000028, "Member 'UModifierMathAttributeValueResolver::BaseValue' has a wrong offset!");
static_assert(offsetof(UModifierMathAttributeValueResolver, ModifierStack) == 0x000060, "Member 'UModifierMathAttributeValueResolver::ModifierStack' has a wrong offset!");

// Class GbxGameSystemCore.MotionControlLibrary
// 0x0000 (0x0028 - 0x0028)
class UMotionControlLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FRotator Spin(const struct FRotator& CurrentRotation, float RotationRate, const struct FVector& RotationAxis, float DeltaTime);
	static float UpdateSpeed(float CurrentSpeed, float TargetSpeed, float Acceleration, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionControlLibrary">();
	}
	static class UMotionControlLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionControlLibrary>();
	}
};
static_assert(alignof(UMotionControlLibrary) == 0x000008, "Wrong alignment on UMotionControlLibrary");
static_assert(sizeof(UMotionControlLibrary) == 0x000028, "Wrong size on UMotionControlLibrary");

// Class GbxGameSystemCore.OrbitingActorComponent
// 0x01A8 (0x0320 - 0x0178)
class UOrbitingActorComponent final : public UActorComponent
{
public:
	class AActor*                                 TargetActor;                                       // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BaseOrbitOffset;                                   // 0x0180(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ApproachSpeed;                                     // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothingDistance;                                 // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmoothingDuration;                                 // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrbitOscillationInfo                  XAxisOscillation;                                  // 0x0198(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FOrbitOscillationInfo                  YAxisOscillation;                                  // 0x0218(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FOrbitOscillationInfo                  ZAxisOscillation;                                  // 0x0298(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsInOrbit;                                        // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothingAlpha;                                    // 0x031C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_TargetActor(class AActor* LastTarget);
	void SetTargetActor(class AActor* NewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrbitingActorComponent">();
	}
	static class UOrbitingActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrbitingActorComponent>();
	}
};
static_assert(alignof(UOrbitingActorComponent) == 0x000008, "Wrong alignment on UOrbitingActorComponent");
static_assert(sizeof(UOrbitingActorComponent) == 0x000320, "Wrong size on UOrbitingActorComponent");
static_assert(offsetof(UOrbitingActorComponent, TargetActor) == 0x000178, "Member 'UOrbitingActorComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, BaseOrbitOffset) == 0x000180, "Member 'UOrbitingActorComponent::BaseOrbitOffset' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, ApproachSpeed) == 0x00018C, "Member 'UOrbitingActorComponent::ApproachSpeed' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, SmoothingDistance) == 0x000190, "Member 'UOrbitingActorComponent::SmoothingDistance' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, SmoothingDuration) == 0x000194, "Member 'UOrbitingActorComponent::SmoothingDuration' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, XAxisOscillation) == 0x000198, "Member 'UOrbitingActorComponent::XAxisOscillation' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, YAxisOscillation) == 0x000218, "Member 'UOrbitingActorComponent::YAxisOscillation' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, ZAxisOscillation) == 0x000298, "Member 'UOrbitingActorComponent::ZAxisOscillation' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, bIsInOrbit) == 0x000318, "Member 'UOrbitingActorComponent::bIsInOrbit' has a wrong offset!");
static_assert(offsetof(UOrbitingActorComponent, SmoothingAlpha) == 0x00031C, "Member 'UOrbitingActorComponent::SmoothingAlpha' has a wrong offset!");

// Class GbxGameSystemCore.ParticleAttributeParameterEvaluator
// 0x0018 (0x0040 - 0x0028)
class UParticleAttributeParameterEvaluator final : public UParticleParameterEvaluator
{
public:
	class UGbxAttributeData*                      Attribute;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEvaluateEveryFrame;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleAttributeParameterEvaluator">();
	}
	static class UParticleAttributeParameterEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleAttributeParameterEvaluator>();
	}
};
static_assert(alignof(UParticleAttributeParameterEvaluator) == 0x000008, "Wrong alignment on UParticleAttributeParameterEvaluator");
static_assert(sizeof(UParticleAttributeParameterEvaluator) == 0x000040, "Wrong size on UParticleAttributeParameterEvaluator");
static_assert(offsetof(UParticleAttributeParameterEvaluator, Attribute) == 0x000028, "Member 'UParticleAttributeParameterEvaluator::Attribute' has a wrong offset!");
static_assert(offsetof(UParticleAttributeParameterEvaluator, ParameterName) == 0x000030, "Member 'UParticleAttributeParameterEvaluator::ParameterName' has a wrong offset!");
static_assert(offsetof(UParticleAttributeParameterEvaluator, bEvaluateEveryFrame) == 0x000038, "Member 'UParticleAttributeParameterEvaluator::bEvaluateEveryFrame' has a wrong offset!");

// Class GbxGameSystemCore.ParticlePropertyTrackingData
// 0x0020 (0x0050 - 0x0030)
class UParticlePropertyTrackingData final : public UGbxDataAsset
{
public:
	float                                         MinValue;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopTrackingWhenMinReached;                       // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopTrackingWhenMaxReached;                       // 0x0039(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopTrackingWhenPrimaryCharacterIsDeadOrNone;     // 0x003A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyParticleWhenTrackingStopped;               // 0x003B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeValueOverTime;                              // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValueChangePerSecond;                              // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseChangeOnUpdate;                              // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PauseDuration;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticlePropertyTrackingData">();
	}
	static class UParticlePropertyTrackingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticlePropertyTrackingData>();
	}
};
static_assert(alignof(UParticlePropertyTrackingData) == 0x000008, "Wrong alignment on UParticlePropertyTrackingData");
static_assert(sizeof(UParticlePropertyTrackingData) == 0x000050, "Wrong size on UParticlePropertyTrackingData");
static_assert(offsetof(UParticlePropertyTrackingData, MinValue) == 0x000030, "Member 'UParticlePropertyTrackingData::MinValue' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, MaxValue) == 0x000034, "Member 'UParticlePropertyTrackingData::MaxValue' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, bStopTrackingWhenMinReached) == 0x000038, "Member 'UParticlePropertyTrackingData::bStopTrackingWhenMinReached' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, bStopTrackingWhenMaxReached) == 0x000039, "Member 'UParticlePropertyTrackingData::bStopTrackingWhenMaxReached' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, bStopTrackingWhenPrimaryCharacterIsDeadOrNone) == 0x00003A, "Member 'UParticlePropertyTrackingData::bStopTrackingWhenPrimaryCharacterIsDeadOrNone' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, bDestroyParticleWhenTrackingStopped) == 0x00003B, "Member 'UParticlePropertyTrackingData::bDestroyParticleWhenTrackingStopped' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, bChangeValueOverTime) == 0x00003C, "Member 'UParticlePropertyTrackingData::bChangeValueOverTime' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, ValueChangePerSecond) == 0x000040, "Member 'UParticlePropertyTrackingData::ValueChangePerSecond' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, bPauseChangeOnUpdate) == 0x000044, "Member 'UParticlePropertyTrackingData::bPauseChangeOnUpdate' has a wrong offset!");
static_assert(offsetof(UParticlePropertyTrackingData, PauseDuration) == 0x000048, "Member 'UParticlePropertyTrackingData::PauseDuration' has a wrong offset!");

// Class GbxGameSystemCore.PawnAttachmentFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPawnAttachmentFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AttachPawnToSlot(class AActor* Actor, class FName SlotName, class APawn* Pawn, bool bInstant);
	static void DetachPawnFromActor(class APawn* Pawn, bool bInstant);
	static void DetachPawnFromSlot(class AActor* Actor, class FName SlotName, bool bInstant);
	static class UPawnAttachSlotComponent* FindPawnAttachSlotComponent(class APawn* Pawn);
	static struct FPawnAttachmentQueryResult QueryPawnAttachment(class APawn* Pawn);
	static void RequestDetachPawnFromActor(class APawn* Pawn);
	static void RequestDetachPawnFromSlot(class AActor* Actor, class FName SlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnAttachmentFunctionLibrary">();
	}
	static class UPawnAttachmentFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnAttachmentFunctionLibrary>();
	}
};
static_assert(alignof(UPawnAttachmentFunctionLibrary) == 0x000008, "Wrong alignment on UPawnAttachmentFunctionLibrary");
static_assert(sizeof(UPawnAttachmentFunctionLibrary) == 0x000028, "Wrong size on UPawnAttachmentFunctionLibrary");

// Class GbxGameSystemCore.PawnAttributeContextResolver
// 0x0000 (0x0050 - 0x0050)
class UPawnAttributeContextResolver final : public UAttributeContextResolver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnAttributeContextResolver">();
	}
	static class UPawnAttributeContextResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnAttributeContextResolver>();
	}
};
static_assert(alignof(UPawnAttributeContextResolver) == 0x000008, "Wrong alignment on UPawnAttributeContextResolver");
static_assert(sizeof(UPawnAttributeContextResolver) == 0x000050, "Wrong size on UPawnAttributeContextResolver");

// Class GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent
// 0x0018 (0x0190 - 0x0178)
class UProjectileAimViewPointHomingTargetComponent final : public UActorComponent
{
public:
	float                                         LookAheadDistance;                                 // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileHomingComponent*             HomingComponent;                                   // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AController*                            TargetController;                                  // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetTargetActor(class AActor* InTargetActor);
	void SetTargetController(class AController* InTargetController);

	struct FVector GetCurrentHomingLoc() const;
	class AController* GetTargetController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileAimViewPointHomingTargetComponent">();
	}
	static class UProjectileAimViewPointHomingTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileAimViewPointHomingTargetComponent>();
	}
};
static_assert(alignof(UProjectileAimViewPointHomingTargetComponent) == 0x000008, "Wrong alignment on UProjectileAimViewPointHomingTargetComponent");
static_assert(sizeof(UProjectileAimViewPointHomingTargetComponent) == 0x000190, "Wrong size on UProjectileAimViewPointHomingTargetComponent");
static_assert(offsetof(UProjectileAimViewPointHomingTargetComponent, LookAheadDistance) == 0x000178, "Member 'UProjectileAimViewPointHomingTargetComponent::LookAheadDistance' has a wrong offset!");
static_assert(offsetof(UProjectileAimViewPointHomingTargetComponent, HomingComponent) == 0x000180, "Member 'UProjectileAimViewPointHomingTargetComponent::HomingComponent' has a wrong offset!");
static_assert(offsetof(UProjectileAimViewPointHomingTargetComponent, TargetController) == 0x000188, "Member 'UProjectileAimViewPointHomingTargetComponent::TargetController' has a wrong offset!");

// Class GbxGameSystemCore.RangedFeedbackData
// 0x0000 (0x03F8 - 0x03F8)
class URangedFeedbackData final : public UFeedbackData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedFeedbackData">();
	}
	static class URangedFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangedFeedbackData>();
	}
};
static_assert(alignof(URangedFeedbackData) == 0x000008, "Wrong alignment on URangedFeedbackData");
static_assert(sizeof(URangedFeedbackData) == 0x0003F8, "Wrong size on URangedFeedbackData");

// Class GbxGameSystemCore.ReferenceActor
// 0x0008 (0x0460 - 0x0458)
class AReferenceActor final : public AActor
{
public:
	class FName                                   PreviewClass;                                      // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EnumeratePreviewClasses(TArray<class FName>* ClasssList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReferenceActor">();
	}
	static class AReferenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReferenceActor>();
	}
};
static_assert(alignof(AReferenceActor) == 0x000008, "Wrong alignment on AReferenceActor");
static_assert(sizeof(AReferenceActor) == 0x000460, "Wrong size on AReferenceActor");
static_assert(offsetof(AReferenceActor, PreviewClass) == 0x000458, "Member 'AReferenceActor::PreviewClass' has a wrong offset!");

// Class GbxGameSystemCore.ReplicatedEmitter
// 0x0090 (0x0538 - 0x04A8)
class AReplicatedEmitter final : public AEmitter
{
public:
	bool                                          bOwnerNoSeeEmitter;                                // 0x04A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedEmitterTemplateOptions      TemplateOptions;                                   // 0x04B0(0x0018)(Net, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEmitterFloatParam>             ReplicatedFloatParams;                             // 0x04C8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEmitterVectorParam>            ReplicatedVectorParams;                            // 0x04D8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEmitterColorParam>             ReplicatedColorParams;                             // 0x04E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FEmitterWwiseEvent                     ReplicatedWwiseEvent;                              // 0x04F8(0x0040)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_OwnerNoSeeEmitter();
	void OnRep_ReplicatedColorParams();
	void OnRep_ReplicatedFloatParams();
	void OnRep_ReplicatedVectorParams();
	void OnRep_ReplicatedWwiseEvent();
	void OnRep_TemplateOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicatedEmitter">();
	}
	static class AReplicatedEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplicatedEmitter>();
	}
};
static_assert(alignof(AReplicatedEmitter) == 0x000008, "Wrong alignment on AReplicatedEmitter");
static_assert(sizeof(AReplicatedEmitter) == 0x000538, "Wrong size on AReplicatedEmitter");
static_assert(offsetof(AReplicatedEmitter, bOwnerNoSeeEmitter) == 0x0004A8, "Member 'AReplicatedEmitter::bOwnerNoSeeEmitter' has a wrong offset!");
static_assert(offsetof(AReplicatedEmitter, TemplateOptions) == 0x0004B0, "Member 'AReplicatedEmitter::TemplateOptions' has a wrong offset!");
static_assert(offsetof(AReplicatedEmitter, ReplicatedFloatParams) == 0x0004C8, "Member 'AReplicatedEmitter::ReplicatedFloatParams' has a wrong offset!");
static_assert(offsetof(AReplicatedEmitter, ReplicatedVectorParams) == 0x0004D8, "Member 'AReplicatedEmitter::ReplicatedVectorParams' has a wrong offset!");
static_assert(offsetof(AReplicatedEmitter, ReplicatedColorParams) == 0x0004E8, "Member 'AReplicatedEmitter::ReplicatedColorParams' has a wrong offset!");
static_assert(offsetof(AReplicatedEmitter, ReplicatedWwiseEvent) == 0x0004F8, "Member 'AReplicatedEmitter::ReplicatedWwiseEvent' has a wrong offset!");

// Class GbxGameSystemCore.ResourceWeightAttributeValueResolver
// 0x0120 (0x0148 - 0x0028)
class UResourceWeightAttributeValueResolver final : public UAttributeValueResolver
{
public:
	class UGameResourceData*                      Resource;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ResourceThreshold;                                 // 0x0030(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           AboveThresholdWeight;                              // 0x0068(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           NoPoolWeight;                                      // 0x00A0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MinBelowThresholdWeight;                           // 0x00D8(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           MaxBelowThresholdWeight;                           // 0x0110(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceWeightAttributeValueResolver">();
	}
	static class UResourceWeightAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourceWeightAttributeValueResolver>();
	}
};
static_assert(alignof(UResourceWeightAttributeValueResolver) == 0x000008, "Wrong alignment on UResourceWeightAttributeValueResolver");
static_assert(sizeof(UResourceWeightAttributeValueResolver) == 0x000148, "Wrong size on UResourceWeightAttributeValueResolver");
static_assert(offsetof(UResourceWeightAttributeValueResolver, Resource) == 0x000028, "Member 'UResourceWeightAttributeValueResolver::Resource' has a wrong offset!");
static_assert(offsetof(UResourceWeightAttributeValueResolver, ResourceThreshold) == 0x000030, "Member 'UResourceWeightAttributeValueResolver::ResourceThreshold' has a wrong offset!");
static_assert(offsetof(UResourceWeightAttributeValueResolver, AboveThresholdWeight) == 0x000068, "Member 'UResourceWeightAttributeValueResolver::AboveThresholdWeight' has a wrong offset!");
static_assert(offsetof(UResourceWeightAttributeValueResolver, NoPoolWeight) == 0x0000A0, "Member 'UResourceWeightAttributeValueResolver::NoPoolWeight' has a wrong offset!");
static_assert(offsetof(UResourceWeightAttributeValueResolver, MinBelowThresholdWeight) == 0x0000D8, "Member 'UResourceWeightAttributeValueResolver::MinBelowThresholdWeight' has a wrong offset!");
static_assert(offsetof(UResourceWeightAttributeValueResolver, MaxBelowThresholdWeight) == 0x000110, "Member 'UResourceWeightAttributeValueResolver::MaxBelowThresholdWeight' has a wrong offset!");

// Class GbxGameSystemCore.RigidBodyActor
// 0x0008 (0x0460 - 0x0458)
class ARigidBodyActor : public AActor
{
public:
	class URigidBodyComponent*                    RigidBodyComponent;                                // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RigidBodyActor">();
	}
	static class ARigidBodyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARigidBodyActor>();
	}
};
static_assert(alignof(ARigidBodyActor) == 0x000008, "Wrong alignment on ARigidBodyActor");
static_assert(sizeof(ARigidBodyActor) == 0x000460, "Wrong size on ARigidBodyActor");
static_assert(offsetof(ARigidBodyActor, RigidBodyComponent) == 0x000458, "Member 'ARigidBodyActor::RigidBodyComponent' has a wrong offset!");

// Class GbxGameSystemCore.SaveGameActorInterface
// 0x0000 (0x0028 - 0x0028)
class ISaveGameActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameActorInterface">();
	}
	static class ISaveGameActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISaveGameActorInterface>();
	}
};
static_assert(alignof(ISaveGameActorInterface) == 0x000008, "Wrong alignment on ISaveGameActorInterface");
static_assert(sizeof(ISaveGameActorInterface) == 0x000028, "Wrong size on ISaveGameActorInterface");

// Class GbxGameSystemCore.SceneBodySwitchComponent
// 0x0090 (0x0360 - 0x02D0)
class USceneBodySwitchComponent final : public USceneComponent
{
public:
	class FName                                   DefaultState;                                      // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneBodySwitchAction*                 DetachAction;                                      // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSceneComponentSwitchRecord>    ComponentRecords;                                  // 0x02F0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<int8>                                  ReplicatedState;                                   // 0x0300(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleParticleSystemFinished(class UParticleSystemComponent* PSC);
	void HandleWwiseEventFinished(class UWwiseAudioComponent* WAC, class UWwiseEvent* WwiseEvent);
	void OnRep_ReplicatedState();

	void GetValidSwitchStateNames(TArray<class FName>* OutNames) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneBodySwitchComponent">();
	}
	static class USceneBodySwitchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneBodySwitchComponent>();
	}
};
static_assert(alignof(USceneBodySwitchComponent) == 0x000008, "Wrong alignment on USceneBodySwitchComponent");
static_assert(sizeof(USceneBodySwitchComponent) == 0x000360, "Wrong size on USceneBodySwitchComponent");
static_assert(offsetof(USceneBodySwitchComponent, DefaultState) == 0x0002D0, "Member 'USceneBodySwitchComponent::DefaultState' has a wrong offset!");
static_assert(offsetof(USceneBodySwitchComponent, DetachAction) == 0x0002D8, "Member 'USceneBodySwitchComponent::DetachAction' has a wrong offset!");
static_assert(offsetof(USceneBodySwitchComponent, ComponentRecords) == 0x0002F0, "Member 'USceneBodySwitchComponent::ComponentRecords' has a wrong offset!");
static_assert(offsetof(USceneBodySwitchComponent, ReplicatedState) == 0x000300, "Member 'USceneBodySwitchComponent::ReplicatedState' has a wrong offset!");

// Class GbxGameSystemCore.SpawnSimulatedActorSwitchAction
// 0x00C8 (0x00F0 - 0x0028)
class USpawnSimulatedActorSwitchAction final : public USceneBodySwitchAction
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInheritVelocity : 1;                              // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableSpeedRange : 1;                             // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableAngularSpeedRange : 1;                      // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EAxis                                         DefaultAxis;                                       // 0x0031(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRelativeDirectionData                 Direction;                                         // 0x0038(0x0050)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x008C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRelativeDirectionData                 RotationAxis;                                      // 0x0090(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AngularSpeed;                                      // 0x00E0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngularSpeed;                                   // 0x00E4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeSpan;                                          // 0x00E8(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnSimulatedActorSwitchAction">();
	}
	static class USpawnSimulatedActorSwitchAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnSimulatedActorSwitchAction>();
	}
};
static_assert(alignof(USpawnSimulatedActorSwitchAction) == 0x000008, "Wrong alignment on USpawnSimulatedActorSwitchAction");
static_assert(sizeof(USpawnSimulatedActorSwitchAction) == 0x0000F0, "Wrong size on USpawnSimulatedActorSwitchAction");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, ActorClass) == 0x000028, "Member 'USpawnSimulatedActorSwitchAction::ActorClass' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, DefaultAxis) == 0x000031, "Member 'USpawnSimulatedActorSwitchAction::DefaultAxis' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, Direction) == 0x000038, "Member 'USpawnSimulatedActorSwitchAction::Direction' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, Speed) == 0x000088, "Member 'USpawnSimulatedActorSwitchAction::Speed' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, MaxSpeed) == 0x00008C, "Member 'USpawnSimulatedActorSwitchAction::MaxSpeed' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, RotationAxis) == 0x000090, "Member 'USpawnSimulatedActorSwitchAction::RotationAxis' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, AngularSpeed) == 0x0000E0, "Member 'USpawnSimulatedActorSwitchAction::AngularSpeed' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, MaxAngularSpeed) == 0x0000E4, "Member 'USpawnSimulatedActorSwitchAction::MaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(USpawnSimulatedActorSwitchAction, LifeSpan) == 0x0000E8, "Member 'USpawnSimulatedActorSwitchAction::LifeSpan' has a wrong offset!");

// Class GbxGameSystemCore.StanceBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UStanceBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearStance(class AActor* Target);
	static bool EqualEqual_StanceDataStanceData(class UStanceData* A, class UStanceData* B);
	static bool EqualEqual_StanceTypeStanceType(class UStanceType* A, class UStanceType* B);
	static bool IsInStance(class UAnimInstance* AnimInstance, class UStanceDataProvider* Stance);
	static bool IsStanceComponentInStance(class UStanceComponent* StanceComponent, class UStanceDataProvider* Stance);
	static void SetStance(class AActor* Target, class UStanceDataProvider* Stance);
	static class UStanceComponent* TryGetStanceComponent(class AAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceBlueprintLibrary">();
	}
	static class UStanceBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceBlueprintLibrary>();
	}
};
static_assert(alignof(UStanceBlueprintLibrary) == 0x000008, "Wrong alignment on UStanceBlueprintLibrary");
static_assert(sizeof(UStanceBlueprintLibrary) == 0x000028, "Wrong size on UStanceBlueprintLibrary");

// Class GbxGameSystemCore.StatusEffectModifierAttributePropertyValueResolver
// 0x0028 (0x00D8 - 0x00B0)
class UStatusEffectModifierAttributePropertyValueResolver final : public UAttributePropertyValueResolver
{
public:
	TSoftObjectPtr<class UStatusEffectData>       StatusEffectData;                                  // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectModifierAttributePropertyValueResolver">();
	}
	static class UStatusEffectModifierAttributePropertyValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectModifierAttributePropertyValueResolver>();
	}
};
static_assert(alignof(UStatusEffectModifierAttributePropertyValueResolver) == 0x000008, "Wrong alignment on UStatusEffectModifierAttributePropertyValueResolver");
static_assert(sizeof(UStatusEffectModifierAttributePropertyValueResolver) == 0x0000D8, "Wrong size on UStatusEffectModifierAttributePropertyValueResolver");
static_assert(offsetof(UStatusEffectModifierAttributePropertyValueResolver, StatusEffectData) == 0x0000B0, "Member 'UStatusEffectModifierAttributePropertyValueResolver::StatusEffectData' has a wrong offset!");

// Class GbxGameSystemCore.TargetableComponent
// 0x02C8 (0x0480 - 0x01B8)
class UTargetableComponent final : public UTeamComponent
{
public:
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FResourceLock                          SightSenseLock;                                    // 0x01C0(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x10];                                     // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSearchableByFindProjectileEQSTargetGenerator;     // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetable;                                     // 0x0269(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTargetableByHumanPlayers;                       // 0x026A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTargetableByAIPlayers;                          // 0x026B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTargetableByNonPlayers;                         // 0x026C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnlyTargetableIfPlayersAreThreatened;             // 0x026D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxUIName*                             TargetUIName;                                      // 0x0270(0x0008)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   TargetName;                                        // 0x0278(0x0018)(Net, NativeAccessSpecifierPrivate)
	class FName                                   TargetSocket;                                      // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTargetLocationBoundsSettings          TargetSocketBounds;                                // 0x0298(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bUseTargetSocketBounds;                            // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTargetLocationSettings>        AdditionalTargetSockets;                           // 0x02A8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0xA0];                                     // 0x02B8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTargetingComponent*>            TargetingMe;                                       // 0x0358(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x30];                                     // 0x0368(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleSections;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FResourceLock                          UntargetableLock;                                  // 0x03A0(0x0098)(Net, Transient, NativeAccessSpecifierPrivate)
	TArray<class FName>                           MeleeTargetingSockets;                             // 0x0438(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOverrideMeleeSocket>           ConditionalMeleeTargetingSockets;                  // 0x0448(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FName>                           TargetProxyComponents;                             // 0x0458(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                TargetProxies;                                     // 0x0468(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bAllowCharacterHoming;                             // 0x0478(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimAssistSnapTargetType                      AimAssistSnapTargetType;                           // 0x0479(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetTracking;                                   // 0x047A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableBulletMagnetism;                           // 0x047B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetTargetNameString();
	void OnRep_TargetUIName();
	void SetIsTargetable(bool IsTargetable);
	void SetIsTargetableByAIPlayers(bool IsTargetable);
	void SetIsTargetableByHumanPlayers(bool IsTargetable);
	void SetIsTargetableByNonPlayers(bool IsTargetable);
	void SetTargetName(const class FText& NewTargetName);
	void SetTargetUIName(const class UGbxUIName* NewTargetUIName);

	void GetAvailableSocketNames(TArray<class FName>* Array) const;
	struct FVector GetClosestTargetLocation(const struct FVector& Origin, const struct FVector& Direction) const;
	struct FVector GetTargetLocation() const;
	TArray<struct FVector> GetTargetLocations() const;
	void GetTargetProxyComponentNames(TArray<class FName>* Array) const;
	class FName GetTargetSocketName() const;
	bool IsTargetable() const;
	bool IsTargetableByActor(const class AActor* Actor) const;
	bool IsTargetableByAIPlayers() const;
	bool IsTargetableByController(const class AController* Controller) const;
	bool IsTargetableByHumanPlayers() const;
	bool IsTargetableByNonPlayers() const;
	bool IsTargetableByPawn(const class APawn* Pawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableComponent">();
	}
	static class UTargetableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetableComponent>();
	}
};
static_assert(alignof(UTargetableComponent) == 0x000008, "Wrong alignment on UTargetableComponent");
static_assert(sizeof(UTargetableComponent) == 0x000480, "Wrong size on UTargetableComponent");
static_assert(offsetof(UTargetableComponent, SightSenseLock) == 0x0001C0, "Member 'UTargetableComponent::SightSenseLock' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bSearchableByFindProjectileEQSTargetGenerator) == 0x000268, "Member 'UTargetableComponent::bSearchableByFindProjectileEQSTargetGenerator' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bIsTargetable) == 0x000269, "Member 'UTargetableComponent::bIsTargetable' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bIsTargetableByHumanPlayers) == 0x00026A, "Member 'UTargetableComponent::bIsTargetableByHumanPlayers' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bIsTargetableByAIPlayers) == 0x00026B, "Member 'UTargetableComponent::bIsTargetableByAIPlayers' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bIsTargetableByNonPlayers) == 0x00026C, "Member 'UTargetableComponent::bIsTargetableByNonPlayers' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bOnlyTargetableIfPlayersAreThreatened) == 0x00026D, "Member 'UTargetableComponent::bOnlyTargetableIfPlayersAreThreatened' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetUIName) == 0x000270, "Member 'UTargetableComponent::TargetUIName' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetName) == 0x000278, "Member 'UTargetableComponent::TargetName' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetSocket) == 0x000290, "Member 'UTargetableComponent::TargetSocket' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetSocketBounds) == 0x000298, "Member 'UTargetableComponent::TargetSocketBounds' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bUseTargetSocketBounds) == 0x0002A4, "Member 'UTargetableComponent::bUseTargetSocketBounds' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, AdditionalTargetSockets) == 0x0002A8, "Member 'UTargetableComponent::AdditionalTargetSockets' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetingMe) == 0x000358, "Member 'UTargetableComponent::TargetingMe' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, CapsuleSections) == 0x000398, "Member 'UTargetableComponent::CapsuleSections' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, UntargetableLock) == 0x0003A0, "Member 'UTargetableComponent::UntargetableLock' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, MeleeTargetingSockets) == 0x000438, "Member 'UTargetableComponent::MeleeTargetingSockets' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, ConditionalMeleeTargetingSockets) == 0x000448, "Member 'UTargetableComponent::ConditionalMeleeTargetingSockets' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetProxyComponents) == 0x000458, "Member 'UTargetableComponent::TargetProxyComponents' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, TargetProxies) == 0x000468, "Member 'UTargetableComponent::TargetProxies' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bAllowCharacterHoming) == 0x000478, "Member 'UTargetableComponent::bAllowCharacterHoming' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, AimAssistSnapTargetType) == 0x000479, "Member 'UTargetableComponent::AimAssistSnapTargetType' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bTargetTracking) == 0x00047A, "Member 'UTargetableComponent::bTargetTracking' has a wrong offset!");
static_assert(offsetof(UTargetableComponent, bDisableBulletMagnetism) == 0x00047B, "Member 'UTargetableComponent::bDisableBulletMagnetism' has a wrong offset!");

// Class GbxGameSystemCore.TargetingComponent
// 0xE618 (0xE790 - 0x0178)
class UTargetingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0xB8];                                     // 0x0178(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   TargetListChangedBpEvent;                          // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueryFrequency;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bQueryImmediately;                                 // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvQueryParams                        QueryParams;                                       // 0x0258(0x00B8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxBlackboardKeySelector>      BlackboardKeys;                                    // 0x0328(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0xE430];                                   // 0x0338(0xE430)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOnlyTargetThreatsToPlayers;                       // 0xE768(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E769[0x17];                                    // 0xE769(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetableComponent*                   CurrentTargetable;                                 // 0xE780(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E788[0x8];                                     // 0xE788(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSetBestTarget(class AActor* NewBestTarget);

	bool DoesBestTargetHaveStimulusForSense(TSubclassOf<class UAISense> Sense, float MaxAge, int32 TargetIndex) const;
	struct FVector GetBestAttackTargetLocation(struct FVector* OutTargetVelocity, int32 TargetIndex) const;
	class UTargetableComponent* GetBestTargetableComponent(int32 TargetIndex) const;
	class AActor* GetBestTargetActor(int32 TargetIndex) const;
	bool GetBestTargetInfo(struct FTargetActorInfo* TargetInfo, int32 TargetIndex) const;
	struct FVector GetBestTargetLocation(int32 TargetIndex) const;
	class AActor* GetBestThreatActor(bool bRequireFirsthandKnowledge) const;
	class AActor* GetTargetActorAt(int32 TargetIndex) const;
	bool GetTargetInfoAt(int32 TargetIndex, struct FTargetActorInfo* TargetInfo) const;
	int32 GetTargetInfoCount() const;
	bool GetTargetInfoForActor(const class AActor* Actor, struct FTargetActorInfo* TargetInfo) const;
	bool GetTargetLocationForActor(const class AActor* Actor, struct FVector* TargetLocation) const;
	bool HasTarget(const class AActor* Actor) const;
	bool HasTargets() const;
	bool IsBestTargetDirectlySensed(int32 TargetIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingComponent">();
	}
	static class UTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingComponent>();
	}
};
static_assert(alignof(UTargetingComponent) == 0x000008, "Wrong alignment on UTargetingComponent");
static_assert(sizeof(UTargetingComponent) == 0x00E790, "Wrong size on UTargetingComponent");
static_assert(offsetof(UTargetingComponent, TargetListChangedBpEvent) == 0x000230, "Member 'UTargetingComponent::TargetListChangedBpEvent' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, QueryFrequency) == 0x000250, "Member 'UTargetingComponent::QueryFrequency' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, bQueryImmediately) == 0x000254, "Member 'UTargetingComponent::bQueryImmediately' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, QueryParams) == 0x000258, "Member 'UTargetingComponent::QueryParams' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, BlackboardKeys) == 0x000328, "Member 'UTargetingComponent::BlackboardKeys' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, bOnlyTargetThreatsToPlayers) == 0x00E768, "Member 'UTargetingComponent::bOnlyTargetThreatsToPlayers' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CurrentTargetable) == 0x00E780, "Member 'UTargetingComponent::CurrentTargetable' has a wrong offset!");

// Class GbxGameSystemCore.Team
// 0x0080 (0x00B0 - 0x0030)
class UTeam final : public UGbxDataAsset
{
public:
	class FString                                 DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 SelfAttitude;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 DefaultAttitude;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 DefaultAttitudeFromTeams;                          // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultAttitudeFromTeams;                      // 0x0043(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTeamAttitudeSetEntry>          AttitudeTowardTeams;                               // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTeamAttitudeSetEntry>          AttitudeFromTeams;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableTeamCollisionChannel;                       // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamCollisionChannel                         TeamCollisionChannel;                              // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x46];                                      // 0x006A(0x0046)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ETeamAttitude GetAttitudeToward(const class UTeam* Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Team">();
	}
	static class UTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeam>();
	}
};
static_assert(alignof(UTeam) == 0x000008, "Wrong alignment on UTeam");
static_assert(sizeof(UTeam) == 0x0000B0, "Wrong size on UTeam");
static_assert(offsetof(UTeam, DisplayName) == 0x000030, "Member 'UTeam::DisplayName' has a wrong offset!");
static_assert(offsetof(UTeam, SelfAttitude) == 0x000040, "Member 'UTeam::SelfAttitude' has a wrong offset!");
static_assert(offsetof(UTeam, DefaultAttitude) == 0x000041, "Member 'UTeam::DefaultAttitude' has a wrong offset!");
static_assert(offsetof(UTeam, DefaultAttitudeFromTeams) == 0x000042, "Member 'UTeam::DefaultAttitudeFromTeams' has a wrong offset!");
static_assert(offsetof(UTeam, bUseDefaultAttitudeFromTeams) == 0x000043, "Member 'UTeam::bUseDefaultAttitudeFromTeams' has a wrong offset!");
static_assert(offsetof(UTeam, AttitudeTowardTeams) == 0x000048, "Member 'UTeam::AttitudeTowardTeams' has a wrong offset!");
static_assert(offsetof(UTeam, AttitudeFromTeams) == 0x000058, "Member 'UTeam::AttitudeFromTeams' has a wrong offset!");
static_assert(offsetof(UTeam, bEnableTeamCollisionChannel) == 0x000068, "Member 'UTeam::bEnableTeamCollisionChannel' has a wrong offset!");
static_assert(offsetof(UTeam, TeamCollisionChannel) == 0x000069, "Member 'UTeam::TeamCollisionChannel' has a wrong offset!");

// Class GbxGameSystemCore.TerritoryComponent
// 0x0090 (0x0780 - 0x06F0)
class UTerritoryComponent final : public UPrimitiveComponent
{
public:
	struct FTerritoryData                         PatrolTerritory;                                   // 0x06F0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FTerritoryData                         ThreatTerritory;                                   // 0x0710(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FTerritoryData                         CombatTerritory;                                   // 0x0730(0x0020)(Edit, NativeAccessSpecifierPrivate)
	ETerritoryCombatProxyType                     CombatProxy;                                       // 0x0750(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseCombatProxy;                                   // 0x0751(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlwaysAwareInThreatArea;                          // 0x0752(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETerritoryDrawStyle                           DrawStyle;                                         // 0x0753(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_754[0x14];                                     // 0x0754(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTerritoryComponent*>            LinkedTerritories;                                 // 0x0768(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerritoryComponent">();
	}
	static class UTerritoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerritoryComponent>();
	}
};
static_assert(alignof(UTerritoryComponent) == 0x000008, "Wrong alignment on UTerritoryComponent");
static_assert(sizeof(UTerritoryComponent) == 0x000780, "Wrong size on UTerritoryComponent");
static_assert(offsetof(UTerritoryComponent, PatrolTerritory) == 0x0006F0, "Member 'UTerritoryComponent::PatrolTerritory' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, ThreatTerritory) == 0x000710, "Member 'UTerritoryComponent::ThreatTerritory' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, CombatTerritory) == 0x000730, "Member 'UTerritoryComponent::CombatTerritory' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, CombatProxy) == 0x000750, "Member 'UTerritoryComponent::CombatProxy' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, bUseCombatProxy) == 0x000751, "Member 'UTerritoryComponent::bUseCombatProxy' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, bAlwaysAwareInThreatArea) == 0x000752, "Member 'UTerritoryComponent::bAlwaysAwareInThreatArea' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, DrawStyle) == 0x000753, "Member 'UTerritoryComponent::DrawStyle' has a wrong offset!");
static_assert(offsetof(UTerritoryComponent, LinkedTerritories) == 0x000768, "Member 'UTerritoryComponent::LinkedTerritories' has a wrong offset!");

// Class GbxGameSystemCore.UIStatData_Numeric_Formula
// 0x0008 (0x0228 - 0x0220)
class UUIStatData_Numeric_Formula final : public UUIStatData_Numeric
{
public:
	class UUIStatFormulaEvaluator*                Formula;                                           // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatData_Numeric_Formula">();
	}
	static class UUIStatData_Numeric_Formula* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatData_Numeric_Formula>();
	}
};
static_assert(alignof(UUIStatData_Numeric_Formula) == 0x000008, "Wrong alignment on UUIStatData_Numeric_Formula");
static_assert(sizeof(UUIStatData_Numeric_Formula) == 0x000228, "Wrong size on UUIStatData_Numeric_Formula");
static_assert(offsetof(UUIStatData_Numeric_Formula, Formula) == 0x000220, "Member 'UUIStatData_Numeric_Formula::Formula' has a wrong offset!");

// Class GbxGameSystemCore.UIStatAttributeEffectProvider
// 0x0000 (0x0028 - 0x0028)
class IUIStatAttributeEffectProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatAttributeEffectProvider">();
	}
	static class IUIStatAttributeEffectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUIStatAttributeEffectProvider>();
	}
};
static_assert(alignof(IUIStatAttributeEffectProvider) == 0x000008, "Wrong alignment on IUIStatAttributeEffectProvider");
static_assert(sizeof(IUIStatAttributeEffectProvider) == 0x000028, "Wrong size on IUIStatAttributeEffectProvider");

// Class GbxGameSystemCore.UsableTypeDefinition
// 0x0070 (0x00A0 - 0x0030)
class UUsableTypeDefinition final : public UGbxDataAsset
{
public:
	class FText                                   ActionText;                                        // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   InputActionOverride;                               // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayLockedIcon;                                // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePrompt;                                       // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCostsToUse;                                       // 0x0052(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxInventoryCategoryData*              CurrencyType;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsableTypeCostContext                        CostContext;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           Cost;                                              // 0x0068(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UsableTypeDefinition">();
	}
	static class UUsableTypeDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUsableTypeDefinition>();
	}
};
static_assert(alignof(UUsableTypeDefinition) == 0x000008, "Wrong alignment on UUsableTypeDefinition");
static_assert(sizeof(UUsableTypeDefinition) == 0x0000A0, "Wrong size on UUsableTypeDefinition");
static_assert(offsetof(UUsableTypeDefinition, ActionText) == 0x000030, "Member 'UUsableTypeDefinition::ActionText' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, InputActionOverride) == 0x000048, "Member 'UUsableTypeDefinition::InputActionOverride' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, bDisplayLockedIcon) == 0x000050, "Member 'UUsableTypeDefinition::bDisplayLockedIcon' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, bHidePrompt) == 0x000051, "Member 'UUsableTypeDefinition::bHidePrompt' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, bCostsToUse) == 0x000052, "Member 'UUsableTypeDefinition::bCostsToUse' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, CurrencyType) == 0x000058, "Member 'UUsableTypeDefinition::CurrencyType' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, CostContext) == 0x000060, "Member 'UUsableTypeDefinition::CostContext' has a wrong offset!");
static_assert(offsetof(UUsableTypeDefinition, Cost) == 0x000068, "Member 'UUsableTypeDefinition::Cost' has a wrong offset!");

// Class GbxGameSystemCore.WeaponInterface
// 0x0000 (0x0028 - 0x0028)
class IWeaponInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponInterface">();
	}
	static class IWeaponInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponInterface>();
	}
};
static_assert(alignof(IWeaponInterface) == 0x000008, "Wrong alignment on IWeaponInterface");
static_assert(sizeof(IWeaponInterface) == 0x000028, "Wrong size on IWeaponInterface");

// Class GbxGameSystemCore.WeatherTemplate
// 0x0010 (0x0040 - 0x0030)
class UWeatherTemplate final : public UGbxDataAsset
{
public:
	class UParticleSystem*                        WorldSpaceParticleTemplate;                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ScreenSpaceParticleTemplate;                       // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherTemplate">();
	}
	static class UWeatherTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherTemplate>();
	}
};
static_assert(alignof(UWeatherTemplate) == 0x000008, "Wrong alignment on UWeatherTemplate");
static_assert(sizeof(UWeatherTemplate) == 0x000040, "Wrong size on UWeatherTemplate");
static_assert(offsetof(UWeatherTemplate, WorldSpaceParticleTemplate) == 0x000030, "Member 'UWeatherTemplate::WorldSpaceParticleTemplate' has a wrong offset!");
static_assert(offsetof(UWeatherTemplate, ScreenSpaceParticleTemplate) == 0x000038, "Member 'UWeatherTemplate::ScreenSpaceParticleTemplate' has a wrong offset!");

}

