#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NavigationSystem

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum NavigationSystem.EHavokNavMeshVertexSelectionMethod
// NumValues: 0x0003
enum class EHavokNavMeshVertexSelectionMethod : uint8
{
	PROPORTIONAL_TO_AREA                     = 0,
	PROPORTIONAL_TO_VERTICES                 = 1,
	PROPORTIONAL_TO_MAX                      = 2,
};

// Enum NavigationSystem.EHavokNavMeshWalkableTriangleSeetings
// NumValues: 0x0004
enum class EHavokNavMeshWalkableTriangleSeetings : uint8
{
	ONLY_FIX_WALKABLE                        = 0,
	PREFER_WALKABLE                          = 1,
	PREFER_UNWALKABLE                        = 2,
	EHavokNavMeshWalkableTriangleSeetings_MAX = 3,
};

// Enum NavigationSystem.EHavokNavMeshCharacterWidthUsage
// NumValues: 0x0004
enum class EHavokNavMeshCharacterWidthUsage : uint8
{
	NONE                                     = 0,
	BLOCK_EDGES                              = 1,
	SHRINK_NAV_MESH                          = 2,
	EHavokNavMeshCharacterWidthUsage_MAX     = 3,
};

// Enum NavigationSystem.EHavokNavMeshEdgeMatchingMetric
// NumValues: 0x0003
enum class EHavokNavMeshEdgeMatchingMetric : uint8
{
	ORDER_BY_OVERLAP                         = 0,
	ORDER_BY_DISTANCE                        = 1,
	ORDER_BY_MAX                             = 2,
};

// Enum NavigationSystem.EHavokNavVolumeCellWidthToResolutionRounding
// NumValues: 0x0003
enum class EHavokNavVolumeCellWidthToResolutionRounding : uint8
{
	RoundToZero                              = 0,
	RoundToNearest                           = 1,
	EHavokNavVolumeCellWidthToResolutionRounding_MAX = 2,
};

// Enum NavigationSystem.EHavokUserEdgeDirection
// NumValues: 0x0005
enum class EHavokUserEdgeDirection : uint8
{
	Blocked                                  = 0,
	AToB                                     = 1,
	BToA                                     = 2,
	Bidirectional                            = 3,
	EHavokUserEdgeDirection_MAX              = 4,
};

// Enum NavigationSystem.EHavokNavMaterial
// NumValues: 0x0004
enum class EHavokNavMaterial : uint8
{
	Walkable                                 = 1,
	Cutting                                  = 2,
	WalkableAndCutting                       = 3,
	EHavokNavMaterial_MAX                    = 4,
};

// Enum NavigationSystem.ERuntimeGenerationType
// NumValues: 0x0005
enum class ERuntimeGenerationType : uint8
{
	Static                                   = 0,
	DynamicModifiersOnly                     = 1,
	Dynamic                                  = 2,
	LegacyGeneration                         = 3,
	ERuntimeGenerationType_MAX               = 4,
};

// Enum NavigationSystem.ENavCostDisplay
// NumValues: 0x0004
enum class ENavCostDisplay : uint8
{
	TotalCost                                = 0,
	HeuristicOnly                            = 1,
	RealCostOnly                             = 2,
	ENavCostDisplay_MAX                      = 3,
};

// Enum NavigationSystem.ERecastPartitioning
// NumValues: 0x0004
enum class ERecastPartitioning : uint8
{
	Monotone                                 = 0,
	Watershed                                = 1,
	ChunkyMonotone                           = 2,
	ERecastPartitioning_MAX                  = 3,
};

// ScriptStruct NavigationSystem.HavokNavVolumeMergingSettings
// 0x0020 (0x0020 - 0x0000)
struct FHavokNavVolumeMergingSettings final
{
public:
	float                                         NodeWeight;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeWeight;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEstimateNewEdges;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IterationsStabilizationThreshold;                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMergingIterations;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomSeed;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimpleFirstMergePass;                          // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokNavVolumeMergingSettings) == 0x000004, "Wrong alignment on FHavokNavVolumeMergingSettings");
static_assert(sizeof(FHavokNavVolumeMergingSettings) == 0x000020, "Wrong size on FHavokNavVolumeMergingSettings");
static_assert(offsetof(FHavokNavVolumeMergingSettings, NodeWeight) == 0x000000, "Member 'FHavokNavVolumeMergingSettings::NodeWeight' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, EdgeWeight) == 0x000004, "Member 'FHavokNavVolumeMergingSettings::EdgeWeight' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, bEstimateNewEdges) == 0x000008, "Member 'FHavokNavVolumeMergingSettings::bEstimateNewEdges' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, IterationsStabilizationThreshold) == 0x00000C, "Member 'FHavokNavVolumeMergingSettings::IterationsStabilizationThreshold' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, MaxMergingIterations) == 0x000010, "Member 'FHavokNavVolumeMergingSettings::MaxMergingIterations' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, RandomSeed) == 0x000014, "Member 'FHavokNavVolumeMergingSettings::RandomSeed' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, Multiplier) == 0x000018, "Member 'FHavokNavVolumeMergingSettings::Multiplier' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeMergingSettings, bUseSimpleFirstMergePass) == 0x00001C, "Member 'FHavokNavVolumeMergingSettings::bUseSimpleFirstMergePass' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavMeshExtraVertexSettings
// 0x0024 (0x0024 - 0x0000)
struct FHavokNavMeshExtraVertexSettings final
{
public:
	EHavokNavMeshVertexSelectionMethod            VertexSelectionMethod;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VertexFraction;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AreaFraction;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPartitionArea;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSmoothingIterations;                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IterationDamping;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAddVerticesOnBoundaryEdges : 1;                   // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAddVerticesOnPartitionBorders : 1;                // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoundaryEdgeSplitLength;                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartitionBordersSplitLength;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokNavMeshExtraVertexSettings) == 0x000004, "Wrong alignment on FHavokNavMeshExtraVertexSettings");
static_assert(sizeof(FHavokNavMeshExtraVertexSettings) == 0x000024, "Wrong size on FHavokNavMeshExtraVertexSettings");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, VertexSelectionMethod) == 0x000000, "Member 'FHavokNavMeshExtraVertexSettings::VertexSelectionMethod' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, VertexFraction) == 0x000004, "Member 'FHavokNavMeshExtraVertexSettings::VertexFraction' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, AreaFraction) == 0x000008, "Member 'FHavokNavMeshExtraVertexSettings::AreaFraction' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, MinPartitionArea) == 0x00000C, "Member 'FHavokNavMeshExtraVertexSettings::MinPartitionArea' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, NumSmoothingIterations) == 0x000010, "Member 'FHavokNavMeshExtraVertexSettings::NumSmoothingIterations' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, IterationDamping) == 0x000014, "Member 'FHavokNavMeshExtraVertexSettings::IterationDamping' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, BoundaryEdgeSplitLength) == 0x00001C, "Member 'FHavokNavMeshExtraVertexSettings::BoundaryEdgeSplitLength' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshExtraVertexSettings, PartitionBordersSplitLength) == 0x000020, "Member 'FHavokNavMeshExtraVertexSettings::PartitionBordersSplitLength' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokTraversalAnalysisSettings
// 0x0020 (0x0020 - 0x0000)
struct FHavokTraversalAnalysisSettings final
{
public:
	TArray<class UHavokTraversalType*>            TraversalTypes;                                    // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MinEdgeLength;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSectionDistance;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaiseEdgeHeightLimit;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokTraversalAnalysisSettings) == 0x000008, "Wrong alignment on FHavokTraversalAnalysisSettings");
static_assert(sizeof(FHavokTraversalAnalysisSettings) == 0x000020, "Wrong size on FHavokTraversalAnalysisSettings");
static_assert(offsetof(FHavokTraversalAnalysisSettings, TraversalTypes) == 0x000000, "Member 'FHavokTraversalAnalysisSettings::TraversalTypes' has a wrong offset!");
static_assert(offsetof(FHavokTraversalAnalysisSettings, MinEdgeLength) == 0x000010, "Member 'FHavokTraversalAnalysisSettings::MinEdgeLength' has a wrong offset!");
static_assert(offsetof(FHavokTraversalAnalysisSettings, MaxSectionDistance) == 0x000014, "Member 'FHavokTraversalAnalysisSettings::MaxSectionDistance' has a wrong offset!");
static_assert(offsetof(FHavokTraversalAnalysisSettings, RaiseEdgeHeightLimit) == 0x000018, "Member 'FHavokTraversalAnalysisSettings::RaiseEdgeHeightLimit' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavMeshSimplificationSettings
// 0x007C (0x007C - 0x0000)
struct FHavokNavMeshSimplificationSettings final
{
public:
	float                                         MaxBorderSimplifyArea;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxConcaveBorderSimlifyArea;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCorridorWidth;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCorridorWidth;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoleReplacementArea;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AabbReplacementAreaFraction;                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLoopShrinkFraction;                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBorderHeightError;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBorderDistanceError;                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPartitionSize;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseHeightPartitioning : 1;                        // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPartitionHeightError;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseConservativeHeightPartitioning : 1;            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HertelMehlhornHeightError;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosPlanarityThreshold;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonConvexityThreshold;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryEdgeFilterThreshold;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSharedVertexHorizontalError;                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSharedVertexVerticalError;                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBoundaryVertexHorizontalError;                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBoundaryVertexVerticalError;                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMergeLongestEdgesFirst : 1;                       // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHavokNavMeshExtraVertexSettings       ExtraVertexSettings;                               // 0x0058(0x0024)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokNavMeshSimplificationSettings) == 0x000004, "Wrong alignment on FHavokNavMeshSimplificationSettings");
static_assert(sizeof(FHavokNavMeshSimplificationSettings) == 0x00007C, "Wrong size on FHavokNavMeshSimplificationSettings");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxBorderSimplifyArea) == 0x000000, "Member 'FHavokNavMeshSimplificationSettings::MaxBorderSimplifyArea' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxConcaveBorderSimlifyArea) == 0x000004, "Member 'FHavokNavMeshSimplificationSettings::MaxConcaveBorderSimlifyArea' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MinCorridorWidth) == 0x000008, "Member 'FHavokNavMeshSimplificationSettings::MinCorridorWidth' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxCorridorWidth) == 0x00000C, "Member 'FHavokNavMeshSimplificationSettings::MaxCorridorWidth' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, HoleReplacementArea) == 0x000010, "Member 'FHavokNavMeshSimplificationSettings::HoleReplacementArea' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, AabbReplacementAreaFraction) == 0x000014, "Member 'FHavokNavMeshSimplificationSettings::AabbReplacementAreaFraction' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxLoopShrinkFraction) == 0x000018, "Member 'FHavokNavMeshSimplificationSettings::MaxLoopShrinkFraction' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxBorderHeightError) == 0x00001C, "Member 'FHavokNavMeshSimplificationSettings::MaxBorderHeightError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxBorderDistanceError) == 0x000020, "Member 'FHavokNavMeshSimplificationSettings::MaxBorderDistanceError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxPartitionSize) == 0x000024, "Member 'FHavokNavMeshSimplificationSettings::MaxPartitionSize' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxPartitionHeightError) == 0x00002C, "Member 'FHavokNavMeshSimplificationSettings::MaxPartitionHeightError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, HertelMehlhornHeightError) == 0x000034, "Member 'FHavokNavMeshSimplificationSettings::HertelMehlhornHeightError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, CosPlanarityThreshold) == 0x000038, "Member 'FHavokNavMeshSimplificationSettings::CosPlanarityThreshold' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, NonConvexityThreshold) == 0x00003C, "Member 'FHavokNavMeshSimplificationSettings::NonConvexityThreshold' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, BoundaryEdgeFilterThreshold) == 0x000040, "Member 'FHavokNavMeshSimplificationSettings::BoundaryEdgeFilterThreshold' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxSharedVertexHorizontalError) == 0x000044, "Member 'FHavokNavMeshSimplificationSettings::MaxSharedVertexHorizontalError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxSharedVertexVerticalError) == 0x000048, "Member 'FHavokNavMeshSimplificationSettings::MaxSharedVertexVerticalError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxBoundaryVertexHorizontalError) == 0x00004C, "Member 'FHavokNavMeshSimplificationSettings::MaxBoundaryVertexHorizontalError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, MaxBoundaryVertexVerticalError) == 0x000050, "Member 'FHavokNavMeshSimplificationSettings::MaxBoundaryVertexVerticalError' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshSimplificationSettings, ExtraVertexSettings) == 0x000058, "Member 'FHavokNavMeshSimplificationSettings::ExtraVertexSettings' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavMeshOverlappingTrianglesSettings
// 0x000C (0x000C - 0x0000)
struct FHavokNavMeshOverlappingTrianglesSettings final
{
public:
	float                                         CoplanarityTolerance;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayCastLengthMultiplier;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHavokNavMeshWalkableTriangleSeetings         WalkableTriangleSetting;                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokNavMeshOverlappingTrianglesSettings) == 0x000004, "Wrong alignment on FHavokNavMeshOverlappingTrianglesSettings");
static_assert(sizeof(FHavokNavMeshOverlappingTrianglesSettings) == 0x00000C, "Wrong size on FHavokNavMeshOverlappingTrianglesSettings");
static_assert(offsetof(FHavokNavMeshOverlappingTrianglesSettings, CoplanarityTolerance) == 0x000000, "Member 'FHavokNavMeshOverlappingTrianglesSettings::CoplanarityTolerance' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshOverlappingTrianglesSettings, RayCastLengthMultiplier) == 0x000004, "Member 'FHavokNavMeshOverlappingTrianglesSettings::RayCastLengthMultiplier' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshOverlappingTrianglesSettings, WalkableTriangleSetting) == 0x000008, "Member 'FHavokNavMeshOverlappingTrianglesSettings::WalkableTriangleSetting' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavVolumePruningSettings
// 0x0008 (0x0008 - 0x0000)
struct FHavokNavVolumePruningSettings final
{
public:
	float                                         MinRegionVolume;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToSeedPoints;                           // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokNavVolumePruningSettings) == 0x000004, "Wrong alignment on FHavokNavVolumePruningSettings");
static_assert(sizeof(FHavokNavVolumePruningSettings) == 0x000008, "Wrong size on FHavokNavVolumePruningSettings");
static_assert(offsetof(FHavokNavVolumePruningSettings, MinRegionVolume) == 0x000000, "Member 'FHavokNavVolumePruningSettings::MinRegionVolume' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumePruningSettings, MinDistanceToSeedPoints) == 0x000004, "Member 'FHavokNavVolumePruningSettings::MinDistanceToSeedPoints' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavMeshRegionPruningSettings
// 0x0014 (0x0014 - 0x0000)
struct FHavokNavMeshRegionPruningSettings final
{
public:
	float                                         MinRegionArea;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToSeedPoints;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BorderPreservationTolerance;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPreserveVerticalBorderRegions : 1;                // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPruneBeforeTriangulation : 1;                     // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseRegionSeeds;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokNavMeshRegionPruningSettings) == 0x000004, "Wrong alignment on FHavokNavMeshRegionPruningSettings");
static_assert(sizeof(FHavokNavMeshRegionPruningSettings) == 0x000014, "Wrong size on FHavokNavMeshRegionPruningSettings");
static_assert(offsetof(FHavokNavMeshRegionPruningSettings, MinRegionArea) == 0x000000, "Member 'FHavokNavMeshRegionPruningSettings::MinRegionArea' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshRegionPruningSettings, MinDistanceToSeedPoints) == 0x000004, "Member 'FHavokNavMeshRegionPruningSettings::MinDistanceToSeedPoints' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshRegionPruningSettings, BorderPreservationTolerance) == 0x000008, "Member 'FHavokNavMeshRegionPruningSettings::BorderPreservationTolerance' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshRegionPruningSettings, bUseRegionSeeds) == 0x000010, "Member 'FHavokNavMeshRegionPruningSettings::bUseRegionSeeds' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavMeshEdgeMatchingSettings
// 0x0028 (0x0028 - 0x0000)
struct FHavokNavMeshEdgeMatchingSettings final
{
public:
	float                                         MaxStepHeight;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSeparation;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOverhang;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehindFaceTolerance;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosPlanarAlignmentAngle;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosVerticalAlignmentAngle;                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinEdgeOverlap;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeParallelTolerance;                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeTraversibilityHorizontalEpsilon;               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSafeEdgeTraversibilityHorizontalEpsilon : 1;   // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokNavMeshEdgeMatchingSettings) == 0x000004, "Wrong alignment on FHavokNavMeshEdgeMatchingSettings");
static_assert(sizeof(FHavokNavMeshEdgeMatchingSettings) == 0x000028, "Wrong size on FHavokNavMeshEdgeMatchingSettings");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, MaxStepHeight) == 0x000000, "Member 'FHavokNavMeshEdgeMatchingSettings::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, MaxSeparation) == 0x000004, "Member 'FHavokNavMeshEdgeMatchingSettings::MaxSeparation' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, MaxOverhang) == 0x000008, "Member 'FHavokNavMeshEdgeMatchingSettings::MaxOverhang' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, BehindFaceTolerance) == 0x00000C, "Member 'FHavokNavMeshEdgeMatchingSettings::BehindFaceTolerance' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, CosPlanarAlignmentAngle) == 0x000010, "Member 'FHavokNavMeshEdgeMatchingSettings::CosPlanarAlignmentAngle' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, CosVerticalAlignmentAngle) == 0x000014, "Member 'FHavokNavMeshEdgeMatchingSettings::CosVerticalAlignmentAngle' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, MinEdgeOverlap) == 0x000018, "Member 'FHavokNavMeshEdgeMatchingSettings::MinEdgeOverlap' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, EdgeParallelTolerance) == 0x00001C, "Member 'FHavokNavMeshEdgeMatchingSettings::EdgeParallelTolerance' has a wrong offset!");
static_assert(offsetof(FHavokNavMeshEdgeMatchingSettings, EdgeTraversibilityHorizontalEpsilon) == 0x000020, "Member 'FHavokNavMeshEdgeMatchingSettings::EdgeTraversibilityHorizontalEpsilon' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavSectionFixedBound
// 0x0048 (0x0048 - 0x0000)
struct FHavokNavSectionFixedBound final
{
public:
	TSubclassOf<class UHavokNavLayer>             Layer;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   WorldBoxBound;                                     // 0x0008(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        WorldConvexHullPoints;                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  DominationGuid;                                    // 0x0038(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokNavSectionFixedBound) == 0x000008, "Wrong alignment on FHavokNavSectionFixedBound");
static_assert(sizeof(FHavokNavSectionFixedBound) == 0x000048, "Wrong size on FHavokNavSectionFixedBound");
static_assert(offsetof(FHavokNavSectionFixedBound, Layer) == 0x000000, "Member 'FHavokNavSectionFixedBound::Layer' has a wrong offset!");
static_assert(offsetof(FHavokNavSectionFixedBound, WorldBoxBound) == 0x000008, "Member 'FHavokNavSectionFixedBound::WorldBoxBound' has a wrong offset!");
static_assert(offsetof(FHavokNavSectionFixedBound, WorldConvexHullPoints) == 0x000028, "Member 'FHavokNavSectionFixedBound::WorldConvexHullPoints' has a wrong offset!");
static_assert(offsetof(FHavokNavSectionFixedBound, DominationGuid) == 0x000038, "Member 'FHavokNavSectionFixedBound::DominationGuid' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavVolumeBorderSettings
// 0x0008 (0x0008 - 0x0000)
struct FHavokNavVolumeBorderSettings final
{
public:
	float                                         Border;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBorderCells;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokNavVolumeBorderSettings) == 0x000004, "Wrong alignment on FHavokNavVolumeBorderSettings");
static_assert(sizeof(FHavokNavVolumeBorderSettings) == 0x000008, "Wrong size on FHavokNavVolumeBorderSettings");
static_assert(offsetof(FHavokNavVolumeBorderSettings, Border) == 0x000000, "Member 'FHavokNavVolumeBorderSettings::Border' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeBorderSettings, bUseBorderCells) == 0x000004, "Member 'FHavokNavVolumeBorderSettings::bUseBorderCells' has a wrong offset!");

// ScriptStruct NavigationSystem.HavokNavVolumeChunkSettings
// 0x0008 (0x0008 - 0x0000)
struct FHavokNavVolumeChunkSettings final
{
public:
	uint16                                        MaxChunkSizeX;                                     // 0x0000(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        MaxChunkSizeY;                                     // 0x0002(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        MaxChunkSizeZ;                                     // 0x0004(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoGreedyMergeAfterCombine;                        // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHavokNavVolumeChunkSettings) == 0x000002, "Wrong alignment on FHavokNavVolumeChunkSettings");
static_assert(sizeof(FHavokNavVolumeChunkSettings) == 0x000008, "Wrong size on FHavokNavVolumeChunkSettings");
static_assert(offsetof(FHavokNavVolumeChunkSettings, MaxChunkSizeX) == 0x000000, "Member 'FHavokNavVolumeChunkSettings::MaxChunkSizeX' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeChunkSettings, MaxChunkSizeY) == 0x000002, "Member 'FHavokNavVolumeChunkSettings::MaxChunkSizeY' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeChunkSettings, MaxChunkSizeZ) == 0x000004, "Member 'FHavokNavVolumeChunkSettings::MaxChunkSizeZ' has a wrong offset!");
static_assert(offsetof(FHavokNavVolumeChunkSettings, bDoGreedyMergeAfterCombine) == 0x000006, "Member 'FHavokNavVolumeChunkSettings::bDoGreedyMergeAfterCombine' has a wrong offset!");

// ScriptStruct NavigationSystem.NavCollisionBox
// 0x0018 (0x0018 - 0x0000)
struct FNavCollisionBox final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x000C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavCollisionBox) == 0x000004, "Wrong alignment on FNavCollisionBox");
static_assert(sizeof(FNavCollisionBox) == 0x000018, "Wrong size on FNavCollisionBox");
static_assert(offsetof(FNavCollisionBox, Offset) == 0x000000, "Member 'FNavCollisionBox::Offset' has a wrong offset!");
static_assert(offsetof(FNavCollisionBox, Extent) == 0x00000C, "Member 'FNavCollisionBox::Extent' has a wrong offset!");

// ScriptStruct NavigationSystem.NavCollisionCylinder
// 0x0014 (0x0014 - 0x0000)
struct FNavCollisionCylinder final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavCollisionCylinder) == 0x000004, "Wrong alignment on FNavCollisionCylinder");
static_assert(sizeof(FNavCollisionCylinder) == 0x000014, "Wrong size on FNavCollisionCylinder");
static_assert(offsetof(FNavCollisionCylinder, Offset) == 0x000000, "Member 'FNavCollisionCylinder::Offset' has a wrong offset!");
static_assert(offsetof(FNavCollisionCylinder, Radius) == 0x00000C, "Member 'FNavCollisionCylinder::Radius' has a wrong offset!");
static_assert(offsetof(FNavCollisionCylinder, Height) == 0x000010, "Member 'FNavCollisionCylinder::Height' has a wrong offset!");

// ScriptStruct NavigationSystem.SupportedAreaData
// 0x0020 (0x0020 - 0x0000)
struct FSupportedAreaData final
{
public:
	class FString                                 AreaClassName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaID;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 AreaClass;                                         // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportedAreaData) == 0x000008, "Wrong alignment on FSupportedAreaData");
static_assert(sizeof(FSupportedAreaData) == 0x000020, "Wrong size on FSupportedAreaData");
static_assert(offsetof(FSupportedAreaData, AreaClassName) == 0x000000, "Member 'FSupportedAreaData::AreaClassName' has a wrong offset!");
static_assert(offsetof(FSupportedAreaData, AreaID) == 0x000010, "Member 'FSupportedAreaData::AreaID' has a wrong offset!");
static_assert(offsetof(FSupportedAreaData, AreaClass) == 0x000018, "Member 'FSupportedAreaData::AreaClass' has a wrong offset!");

// ScriptStruct NavigationSystem.NavGraphNode
// 0x0018 (0x0018 - 0x0000)
struct FNavGraphNode final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavGraphNode) == 0x000008, "Wrong alignment on FNavGraphNode");
static_assert(sizeof(FNavGraphNode) == 0x000018, "Wrong size on FNavGraphNode");
static_assert(offsetof(FNavGraphNode, Owner) == 0x000000, "Member 'FNavGraphNode::Owner' has a wrong offset!");

// ScriptStruct NavigationSystem.NavGraphEdge
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FNavGraphEdge final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavGraphEdge) == 0x000008, "Wrong alignment on FNavGraphEdge");
static_assert(sizeof(FNavGraphEdge) == 0x000018, "Wrong size on FNavGraphEdge");

// ScriptStruct NavigationSystem.NavigationFilterFlags
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FNavigationFilterFlags final
{
public:
	uint8                                         bNavFlag0 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag1 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag2 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag3 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag4 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag5 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag6 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag7 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag8 : 1;                                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag9 : 1;                                     // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag10 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag11 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag12 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag13 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag14 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag15 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationFilterFlags) == 0x000004, "Wrong alignment on FNavigationFilterFlags");
static_assert(sizeof(FNavigationFilterFlags) == 0x000004, "Wrong size on FNavigationFilterFlags");

// ScriptStruct NavigationSystem.NavigationFilterArea
// 0x0018 (0x0018 - 0x0000)
struct FNavigationFilterArea final
{
public:
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelCostOverride;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnteringCostOverride;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsExcluded : 1;                                   // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideTravelCost : 1;                           // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideEnteringCost : 1;                         // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationFilterArea) == 0x000008, "Wrong alignment on FNavigationFilterArea");
static_assert(sizeof(FNavigationFilterArea) == 0x000018, "Wrong size on FNavigationFilterArea");
static_assert(offsetof(FNavigationFilterArea, AreaClass) == 0x000000, "Member 'FNavigationFilterArea::AreaClass' has a wrong offset!");
static_assert(offsetof(FNavigationFilterArea, TravelCostOverride) == 0x000008, "Member 'FNavigationFilterArea::TravelCostOverride' has a wrong offset!");
static_assert(offsetof(FNavigationFilterArea, EnteringCostOverride) == 0x00000C, "Member 'FNavigationFilterArea::EnteringCostOverride' has a wrong offset!");

}

