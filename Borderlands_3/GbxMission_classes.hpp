#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxMission

#include "Basic.hpp"

#include "GbxUI_classes.hpp"
#include "GbxRuntime_classes.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxDialog_structs.hpp"
#include "GbxMission_structs.hpp"
#include "Engine_classes.hpp"
#include "GbxTravelStation_classes.hpp"


namespace SDK
{

// Class GbxMission.MissionIconInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionIconInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionIconInterface">();
	}
	static class IMissionIconInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionIconInterface>();
	}
};
static_assert(alignof(IMissionIconInterface) == 0x000008, "Wrong alignment on IMissionIconInterface");
static_assert(sizeof(IMissionIconInterface) == 0x000028, "Wrong size on IMissionIconInterface");

// Class GbxMission.MissionDirectorComponent
// 0x00E0 (0x03B0 - 0x02D0)
class UMissionDirectorComponent : public USceneComponent
{
public:
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           Missions;                                          // 0x02E8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMissionObjectiveSetReference>  MissionEntryPoints;                                // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          MissionDirectorEnableCondition;                    // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxUIFormattedText                    MissionDirectorName;                               // 0x0318(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionDirectorEnabled;                          // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionDirectorDisabled;                         // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionsInitialized;                             // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ActivateAvailableMission();
	void AddMission(TSubclassOf<class UMission> InMission);
	void ClearMissions();
	void GetAllMissions(TArray<TSubclassOf<class UMission>>* AllMissions);
	void IsAnyMissionActive(EMissionActiveResult* OutResult);
	void IsAnyMissionAvailable(EMissionAvailableResult* OutResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionDirectorComponent">();
	}
	static class UMissionDirectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionDirectorComponent>();
	}
};
static_assert(alignof(UMissionDirectorComponent) == 0x000008, "Wrong alignment on UMissionDirectorComponent");
static_assert(sizeof(UMissionDirectorComponent) == 0x0003B0, "Wrong size on UMissionDirectorComponent");
static_assert(offsetof(UMissionDirectorComponent, Missions) == 0x0002E8, "Member 'UMissionDirectorComponent::Missions' has a wrong offset!");
static_assert(offsetof(UMissionDirectorComponent, MissionEntryPoints) == 0x000300, "Member 'UMissionDirectorComponent::MissionEntryPoints' has a wrong offset!");
static_assert(offsetof(UMissionDirectorComponent, MissionDirectorEnableCondition) == 0x000310, "Member 'UMissionDirectorComponent::MissionDirectorEnableCondition' has a wrong offset!");
static_assert(offsetof(UMissionDirectorComponent, MissionDirectorName) == 0x000318, "Member 'UMissionDirectorComponent::MissionDirectorName' has a wrong offset!");
static_assert(offsetof(UMissionDirectorComponent, OnMissionDirectorEnabled) == 0x000380, "Member 'UMissionDirectorComponent::OnMissionDirectorEnabled' has a wrong offset!");
static_assert(offsetof(UMissionDirectorComponent, OnMissionDirectorDisabled) == 0x000390, "Member 'UMissionDirectorComponent::OnMissionDirectorDisabled' has a wrong offset!");
static_assert(offsetof(UMissionDirectorComponent, OnMissionsInitialized) == 0x0003A0, "Member 'UMissionDirectorComponent::OnMissionsInitialized' has a wrong offset!");

// Class GbxMission.MissionObserverInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionObserverInterface : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObserverInterface">();
	}
	static class IMissionObserverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionObserverInterface>();
	}
};
static_assert(alignof(IMissionObserverInterface) == 0x000008, "Wrong alignment on IMissionObserverInterface");
static_assert(sizeof(IMissionObserverInterface) == 0x000028, "Wrong size on IMissionObserverInterface");

// Class GbxMission.MissionRewardData
// 0x0000 (0x0030 - 0x0030)
class UMissionRewardData : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionRewardData">();
	}
	static class UMissionRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionRewardData>();
	}
};
static_assert(alignof(UMissionRewardData) == 0x000008, "Wrong alignment on UMissionRewardData");
static_assert(sizeof(UMissionRewardData) == 0x000030, "Wrong size on UMissionRewardData");

// Class GbxMission.Mission
// 0x03E0 (0x0408 - 0x0028)
class UMission : public UObject
{
public:
	class AMissionTrackerBase*                    MissionTrackerBase;                                // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAutomaticDebugActivation;                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxUIFormattedText                    FormattedMissionName;                              // 0x0038(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGbxUIFormattedText                    PreAcceptanceSummary;                              // 0x00A0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGbxUIFormattedText                    PostAcceptanceSummary;                             // 0x0108(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x2];                                      // 0x0170(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bImmediatelyAdvanceToFirstSet;                     // 0x0172(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseImmediatelyAdvanceToFirstSet;                  // 0x0173(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediatelyAdvanceToFirstSetIfNotInMissionLevel;  // 0x0174(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPlayKickoff;                                  // 0x0175(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoPlayKickoff;                               // 0x0176(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlotCritical;                                     // 0x0177(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatable;                                       // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SecondsToComplete;                                 // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFailOnTimerExpiration;                            // 0x0180(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyDisplayTimer;                                 // 0x0181(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x6];                                      // 0x0182(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionRewardData*                     RewardData;                                        // 0x0188(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDependencyViewDummy;                              // 0x0190(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstPlotMission;                               // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x6];                                      // 0x0192(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           MissionDependencies;                               // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FMissionObjectiveDependency            ObjectiveDependency;                               // 0x01A8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMissionObjectiveSet*>           ObjectiveSets;                                     // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UMissionObjective*>              Objectives;                                        // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<struct FMissionObjectiveChain>         ObjectiveChains;                                   // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UMissionPhase*>                  MissionPhases;                                     // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)
	TSubclassOf<class UChallenge>                 MissionChallenge;                                  // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFailOnTravel;                                     // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionObjectiveSet*                   StartCriticalSectionSet;                           // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   StopCriticalSectionSet;                            // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobalMissionBlocker;                             // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           BlockedMissions;                                   // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   StartBlockingSet;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   StopBlockingSet;                                   // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogConversation                    KickoffConversation;                               // 0x0288(0x000C)(BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActivityPriority;                                  // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxUIFormattedText                    Description;                                       // 0x02A0(0x0068)(Edit, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTravelLocationData>     TravelStation;                                     // 0x0308(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bActivateMissionDialogScriptInAnyMap;              // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDialogScriptData>       MissionActivationDialogScript;                     // 0x0338(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDialogTimeSlotReference               KickoffDialog;                                     // 0x0360(0x0040)(Edit, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   NextMissionInChain;                                // 0x03A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AssociatedMissionGraph;                            // 0x03C8(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CookedActivityObjectId;                            // 0x03F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateMission(class UMissionObjectiveSet* InitialObjectiveSet, bool bSetAsTrackedMission);
	void AddTimeToMission(int32 SecondsToAdd);
	void AdvanceObjectiveSet(class UMissionObjectiveSet* ObjectiveSet);
	void ClearObjective(class UMissionObjective* Objective);
	void CompleteMission();
	void EndKickoff();
	void FailMission();
	int32 GetMissionRemainingSeconds();
	void JumpToObjectiveSet(class UMissionObjectiveSet* ObjectiveSet, bool bIsBranchingMission);
	void MissionActive();
	void MissionActiveLoad();
	void MissionComplete();
	void MissionCompleteLoad();
	void MissionFailed();
	bool MissionGameModeEvent(class FName EventName);
	void MissionKickoff();
	void MissionNotStarted();
	bool MissionRemoteEvent(class FName EventName);
	void MissionTimerExpired();
	void StartMissionTimer();
	void StopMissionTimer();
	void ThwartObjectiveAndAdvanceObjectiveSet(class UMissionObjective* ObjectiveToThwart, class UMissionObjectiveSet* ObjectiveSet, bool bJumpToSet);
	void UnpauseObjectiveChain(class UMissionObjective* Objective);
	void UpdateObjective(class UMissionObjective* Objective, class UObject* Context, uint8 Amount);

	void GetObjectiveSetsList(TArray<class UMissionObjectiveSet*>* ObjectiveSetsList) const;
	void GetObjectivesList(TArray<class UMissionObjective*>* ObjectivesList) const;
	void GetPausableChainedObjectivesList(TArray<class UMissionObjective*>* ObjectivesList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mission">();
	}
	static class UMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMission>();
	}
};
static_assert(alignof(UMission) == 0x000008, "Wrong alignment on UMission");
static_assert(sizeof(UMission) == 0x000408, "Wrong size on UMission");
static_assert(offsetof(UMission, MissionTrackerBase) == 0x000028, "Member 'UMission::MissionTrackerBase' has a wrong offset!");
static_assert(offsetof(UMission, bAllowAutomaticDebugActivation) == 0x000030, "Member 'UMission::bAllowAutomaticDebugActivation' has a wrong offset!");
static_assert(offsetof(UMission, FormattedMissionName) == 0x000038, "Member 'UMission::FormattedMissionName' has a wrong offset!");
static_assert(offsetof(UMission, PreAcceptanceSummary) == 0x0000A0, "Member 'UMission::PreAcceptanceSummary' has a wrong offset!");
static_assert(offsetof(UMission, PostAcceptanceSummary) == 0x000108, "Member 'UMission::PostAcceptanceSummary' has a wrong offset!");
static_assert(offsetof(UMission, bImmediatelyAdvanceToFirstSet) == 0x000172, "Member 'UMission::bImmediatelyAdvanceToFirstSet' has a wrong offset!");
static_assert(offsetof(UMission, bUseImmediatelyAdvanceToFirstSet) == 0x000173, "Member 'UMission::bUseImmediatelyAdvanceToFirstSet' has a wrong offset!");
static_assert(offsetof(UMission, bImmediatelyAdvanceToFirstSetIfNotInMissionLevel) == 0x000174, "Member 'UMission::bImmediatelyAdvanceToFirstSetIfNotInMissionLevel' has a wrong offset!");
static_assert(offsetof(UMission, bAutoPlayKickoff) == 0x000175, "Member 'UMission::bAutoPlayKickoff' has a wrong offset!");
static_assert(offsetof(UMission, bUseAutoPlayKickoff) == 0x000176, "Member 'UMission::bUseAutoPlayKickoff' has a wrong offset!");
static_assert(offsetof(UMission, bPlotCritical) == 0x000177, "Member 'UMission::bPlotCritical' has a wrong offset!");
static_assert(offsetof(UMission, bRepeatable) == 0x000178, "Member 'UMission::bRepeatable' has a wrong offset!");
static_assert(offsetof(UMission, SecondsToComplete) == 0x00017C, "Member 'UMission::SecondsToComplete' has a wrong offset!");
static_assert(offsetof(UMission, bFailOnTimerExpiration) == 0x000180, "Member 'UMission::bFailOnTimerExpiration' has a wrong offset!");
static_assert(offsetof(UMission, bOnlyDisplayTimer) == 0x000181, "Member 'UMission::bOnlyDisplayTimer' has a wrong offset!");
static_assert(offsetof(UMission, RewardData) == 0x000188, "Member 'UMission::RewardData' has a wrong offset!");
static_assert(offsetof(UMission, bDependencyViewDummy) == 0x000190, "Member 'UMission::bDependencyViewDummy' has a wrong offset!");
static_assert(offsetof(UMission, bIsFirstPlotMission) == 0x000191, "Member 'UMission::bIsFirstPlotMission' has a wrong offset!");
static_assert(offsetof(UMission, MissionDependencies) == 0x000198, "Member 'UMission::MissionDependencies' has a wrong offset!");
static_assert(offsetof(UMission, ObjectiveDependency) == 0x0001A8, "Member 'UMission::ObjectiveDependency' has a wrong offset!");
static_assert(offsetof(UMission, ObjectiveSets) == 0x000200, "Member 'UMission::ObjectiveSets' has a wrong offset!");
static_assert(offsetof(UMission, Objectives) == 0x000210, "Member 'UMission::Objectives' has a wrong offset!");
static_assert(offsetof(UMission, ObjectiveChains) == 0x000220, "Member 'UMission::ObjectiveChains' has a wrong offset!");
static_assert(offsetof(UMission, MissionPhases) == 0x000230, "Member 'UMission::MissionPhases' has a wrong offset!");
static_assert(offsetof(UMission, MissionChallenge) == 0x000240, "Member 'UMission::MissionChallenge' has a wrong offset!");
static_assert(offsetof(UMission, bFailOnTravel) == 0x000248, "Member 'UMission::bFailOnTravel' has a wrong offset!");
static_assert(offsetof(UMission, StartCriticalSectionSet) == 0x000250, "Member 'UMission::StartCriticalSectionSet' has a wrong offset!");
static_assert(offsetof(UMission, StopCriticalSectionSet) == 0x000258, "Member 'UMission::StopCriticalSectionSet' has a wrong offset!");
static_assert(offsetof(UMission, bGlobalMissionBlocker) == 0x000260, "Member 'UMission::bGlobalMissionBlocker' has a wrong offset!");
static_assert(offsetof(UMission, BlockedMissions) == 0x000268, "Member 'UMission::BlockedMissions' has a wrong offset!");
static_assert(offsetof(UMission, StartBlockingSet) == 0x000278, "Member 'UMission::StartBlockingSet' has a wrong offset!");
static_assert(offsetof(UMission, StopBlockingSet) == 0x000280, "Member 'UMission::StopBlockingSet' has a wrong offset!");
static_assert(offsetof(UMission, KickoffConversation) == 0x000288, "Member 'UMission::KickoffConversation' has a wrong offset!");
static_assert(offsetof(UMission, ActivityPriority) == 0x000294, "Member 'UMission::ActivityPriority' has a wrong offset!");
static_assert(offsetof(UMission, bIsHidden) == 0x000298, "Member 'UMission::bIsHidden' has a wrong offset!");
static_assert(offsetof(UMission, Description) == 0x0002A0, "Member 'UMission::Description' has a wrong offset!");
static_assert(offsetof(UMission, TravelStation) == 0x000308, "Member 'UMission::TravelStation' has a wrong offset!");
static_assert(offsetof(UMission, bActivateMissionDialogScriptInAnyMap) == 0x000330, "Member 'UMission::bActivateMissionDialogScriptInAnyMap' has a wrong offset!");
static_assert(offsetof(UMission, MissionActivationDialogScript) == 0x000338, "Member 'UMission::MissionActivationDialogScript' has a wrong offset!");
static_assert(offsetof(UMission, KickoffDialog) == 0x000360, "Member 'UMission::KickoffDialog' has a wrong offset!");
static_assert(offsetof(UMission, NextMissionInChain) == 0x0003A0, "Member 'UMission::NextMissionInChain' has a wrong offset!");
static_assert(offsetof(UMission, AssociatedMissionGraph) == 0x0003C8, "Member 'UMission::AssociatedMissionGraph' has a wrong offset!");
static_assert(offsetof(UMission, CookedActivityObjectId) == 0x0003F0, "Member 'UMission::CookedActivityObjectId' has a wrong offset!");

// Class GbxMission.MissionReferenceInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionReferenceInterface final : public IInterface
{
public:
	bool CheckForMissionReferenceErrors() const;
	void GetMissionClassReferences(TArray<TSubclassOf<class UMission>>* OutMissions) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionReferenceInterface">();
	}
	static class IMissionReferenceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionReferenceInterface>();
	}
};
static_assert(alignof(IMissionReferenceInterface) == 0x000008, "Wrong alignment on IMissionReferenceInterface");
static_assert(sizeof(IMissionReferenceInterface) == 0x000028, "Wrong size on IMissionReferenceInterface");

// Class GbxMission.MissionGraph
// 0x0040 (0x0068 - 0x0028)
class UMissionGraph : public UObject
{
public:
	int32                                         GraphPriorityID;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GraphDisplayName;                                  // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowReferencedMissionDummy;                       // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UMission>>           ReferencedMissions;                                // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDownloadableContentData*               DLCExpansionData;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionGraph">();
	}
	static class UMissionGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionGraph>();
	}
};
static_assert(alignof(UMissionGraph) == 0x000008, "Wrong alignment on UMissionGraph");
static_assert(sizeof(UMissionGraph) == 0x000068, "Wrong size on UMissionGraph");
static_assert(offsetof(UMissionGraph, GraphPriorityID) == 0x000028, "Member 'UMissionGraph::GraphPriorityID' has a wrong offset!");
static_assert(offsetof(UMissionGraph, GraphDisplayName) == 0x000030, "Member 'UMissionGraph::GraphDisplayName' has a wrong offset!");
static_assert(offsetof(UMissionGraph, bShowReferencedMissionDummy) == 0x000048, "Member 'UMissionGraph::bShowReferencedMissionDummy' has a wrong offset!");
static_assert(offsetof(UMissionGraph, ReferencedMissions) == 0x000050, "Member 'UMissionGraph::ReferencedMissions' has a wrong offset!");
static_assert(offsetof(UMissionGraph, DLCExpansionData) == 0x000060, "Member 'UMissionGraph::DLCExpansionData' has a wrong offset!");

// Class GbxMission.MissionAttributeValueResolver
// 0x0008 (0x0030 - 0x0028)
class UMissionAttributeValueResolver final : public UAttributeValueResolver
{
public:
	EMissionValueType                             ValueToResolve;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionAttributeValueResolver">();
	}
	static class UMissionAttributeValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionAttributeValueResolver>();
	}
};
static_assert(alignof(UMissionAttributeValueResolver) == 0x000008, "Wrong alignment on UMissionAttributeValueResolver");
static_assert(sizeof(UMissionAttributeValueResolver) == 0x000030, "Wrong size on UMissionAttributeValueResolver");
static_assert(offsetof(UMissionAttributeValueResolver, ValueToResolve) == 0x000028, "Member 'UMissionAttributeValueResolver::ValueToResolve' has a wrong offset!");

// Class GbxMission.GlobalMissionGraph
// 0x0010 (0x0078 - 0x0068)
class UGlobalMissionGraph : public UMissionGraph
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalMissionGraph">();
	}
	static class UGlobalMissionGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalMissionGraph>();
	}
};
static_assert(alignof(UGlobalMissionGraph) == 0x000008, "Wrong alignment on UGlobalMissionGraph");
static_assert(sizeof(UGlobalMissionGraph) == 0x000078, "Wrong size on UGlobalMissionGraph");

// Class GbxMission.MissionTrackerBase
// 0x0048 (0x04A0 - 0x0458)
class AMissionTrackerBase : public AActor
{
public:
	TArray<struct FMissionProgress>               MissionList;                                       // 0x0458(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UMission>                   TrackedMission;                                    // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x20];                                     // 0x0470(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDataValidated;                                    // 0x0490(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGlobalMissionGraph*                    GlobalMissionGraph;                                // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionTrackerBase">();
	}
	static class AMissionTrackerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionTrackerBase>();
	}
};
static_assert(alignof(AMissionTrackerBase) == 0x000008, "Wrong alignment on AMissionTrackerBase");
static_assert(sizeof(AMissionTrackerBase) == 0x0004A0, "Wrong size on AMissionTrackerBase");
static_assert(offsetof(AMissionTrackerBase, MissionList) == 0x000458, "Member 'AMissionTrackerBase::MissionList' has a wrong offset!");
static_assert(offsetof(AMissionTrackerBase, TrackedMission) == 0x000468, "Member 'AMissionTrackerBase::TrackedMission' has a wrong offset!");
static_assert(offsetof(AMissionTrackerBase, bDataValidated) == 0x000490, "Member 'AMissionTrackerBase::bDataValidated' has a wrong offset!");
static_assert(offsetof(AMissionTrackerBase, GlobalMissionGraph) == 0x000498, "Member 'AMissionTrackerBase::GlobalMissionGraph' has a wrong offset!");

// Class GbxMission.MissionEnableCondition
// 0x0018 (0x00A0 - 0x0088)
class UMissionEnableCondition : public UGbxCondition
{
public:
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableCondition">();
	}
	static class UMissionEnableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableCondition>();
	}
};
static_assert(alignof(UMissionEnableCondition) == 0x000008, "Wrong alignment on UMissionEnableCondition");
static_assert(sizeof(UMissionEnableCondition) == 0x0000A0, "Wrong size on UMissionEnableCondition");

// Class GbxMission.MissionEnableConditionObjectiveSet
// 0x0050 (0x00F0 - 0x00A0)
class UMissionEnableConditionObjectiveSet final : public UMissionEnableCondition
{
public:
	struct FMissionObjectiveSetReference          ObjectiveSetRef;                                   // 0x00A0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EMissionObjectiveSetStatus                    ObjectiveSetStatus;                                // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionEnableConditionObjectiveSetObjectiveStatus ObjectivesStatus;                                  // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionObjectiveSet">();
	}
	static class UMissionEnableConditionObjectiveSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionObjectiveSet>();
	}
};
static_assert(alignof(UMissionEnableConditionObjectiveSet) == 0x000008, "Wrong alignment on UMissionEnableConditionObjectiveSet");
static_assert(sizeof(UMissionEnableConditionObjectiveSet) == 0x0000F0, "Wrong size on UMissionEnableConditionObjectiveSet");
static_assert(offsetof(UMissionEnableConditionObjectiveSet, ObjectiveSetRef) == 0x0000A0, "Member 'UMissionEnableConditionObjectiveSet::ObjectiveSetRef' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjectiveSet, ObjectiveSetStatus) == 0x0000E8, "Member 'UMissionEnableConditionObjectiveSet::ObjectiveSetStatus' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjectiveSet, ObjectivesStatus) == 0x0000E9, "Member 'UMissionEnableConditionObjectiveSet::ObjectivesStatus' has a wrong offset!");

// Class GbxMission.MissionIconComponent
// 0x00C0 (0x07B0 - 0x06F0)
#pragma pack(push, 0x1)
class alignas(0x10) UMissionIconComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x20];                                     // 0x06F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          IconEnabledCondition;                              // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        WaypointRadius;                                    // 0x0718(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAreaWaypoint;                                 // 0x071C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71D[0x3];                                      // 0x071D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPrimitiveComponent>        AreaComponentClassOverride;                        // 0x0720(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIconRadiusDrawStyle                          DrawStyle;                                         // 0x0728(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0xF];                                      // 0x0729(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        AttractParticleTemplate;                           // 0x0738(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             AttractParticleTransform;                          // 0x0740(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSyncAttachedParticles;                            // 0x0770(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToWaypointSocket;                           // 0x0771(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_772[0x6];                                      // 0x0772(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnIconEnabled;                                     // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnIconDisabled;                                    // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0798(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_799[0xF];                                      // 0x0799(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EnabledConditionRequiresNativeClass();
	class UClass* GetRequiredInterface();
	bool IsIconEnabled();
	void OnRep_Enabled(bool bPreviouslyEnabled);
	void SetDisabledState(bool bDisabled);
	bool SetIconEnabledCondition(class UGbxCondition* EnabledCondition);
	void SetIconState(EMissionIconState InState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionIconComponent">();
	}
	static class UMissionIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionIconComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMissionIconComponent) == 0x000010, "Wrong alignment on UMissionIconComponent");
static_assert(sizeof(UMissionIconComponent) == 0x0007B0, "Wrong size on UMissionIconComponent");
static_assert(offsetof(UMissionIconComponent, IconEnabledCondition) == 0x000710, "Member 'UMissionIconComponent::IconEnabledCondition' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, WaypointRadius) == 0x000718, "Member 'UMissionIconComponent::WaypointRadius' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, bHideAreaWaypoint) == 0x00071C, "Member 'UMissionIconComponent::bHideAreaWaypoint' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, AreaComponentClassOverride) == 0x000720, "Member 'UMissionIconComponent::AreaComponentClassOverride' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, DrawStyle) == 0x000728, "Member 'UMissionIconComponent::DrawStyle' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, AttractParticleTemplate) == 0x000738, "Member 'UMissionIconComponent::AttractParticleTemplate' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, AttractParticleTransform) == 0x000740, "Member 'UMissionIconComponent::AttractParticleTransform' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, bSyncAttachedParticles) == 0x000770, "Member 'UMissionIconComponent::bSyncAttachedParticles' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, bAttachToWaypointSocket) == 0x000771, "Member 'UMissionIconComponent::bAttachToWaypointSocket' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, OnIconEnabled) == 0x000778, "Member 'UMissionIconComponent::OnIconEnabled' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, OnIconDisabled) == 0x000788, "Member 'UMissionIconComponent::OnIconDisabled' has a wrong offset!");
static_assert(offsetof(UMissionIconComponent, bEnabled) == 0x000798, "Member 'UMissionIconComponent::bEnabled' has a wrong offset!");

// Class GbxMission.MissionObserverPlayerInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionObserverPlayerInterface final : public IMissionObserverInterface
{
public:
	void ClientReceiveMissionData(const struct FReplicatedMissionData& MissionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObserverPlayerInterface">();
	}
	static class IMissionObserverPlayerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionObserverPlayerInterface>();
	}
};
static_assert(alignof(IMissionObserverPlayerInterface) == 0x000008, "Wrong alignment on IMissionObserverPlayerInterface");
static_assert(sizeof(IMissionObserverPlayerInterface) == 0x000028, "Wrong size on IMissionObserverPlayerInterface");

// Class GbxMission.MissionTracker
// 0x0208 (0x06A8 - 0x04A0)
class AMissionTracker : public AMissionTrackerBase
{
public:
	class UMission*                               DebugActivatedMission;                             // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   JumpedTooObjectiveSet;                             // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0xB8];                                     // 0x04B0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDefendMissionTargetData               DefendTarget;                                      // 0x0568(0x0010)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x1];                                      // 0x0578(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLevelLoadEventsIssued;                            // 0x0579(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57A[0x6E];                                     // 0x057A(0x006E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IMissionObserverInterface>> AllMissionsObservers;                              // 0x05E8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IMissionIconObserverInterface>> MissionIconObservers;                              // 0x0600(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x50];                                     // 0x0610(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveMissionIconData>         ActiveIcons;                                       // 0x0660(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_670[0x38];                                     // 0x0670(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveIcons();
	void OnRep_LevelLoadEventsIssued();
	void OnStatIncrement(class AActor* StatContext, class UGameStatData* StatId, int32 Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionTracker">();
	}
	static class AMissionTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionTracker>();
	}
};
static_assert(alignof(AMissionTracker) == 0x000008, "Wrong alignment on AMissionTracker");
static_assert(sizeof(AMissionTracker) == 0x0006A8, "Wrong size on AMissionTracker");
static_assert(offsetof(AMissionTracker, DebugActivatedMission) == 0x0004A0, "Member 'AMissionTracker::DebugActivatedMission' has a wrong offset!");
static_assert(offsetof(AMissionTracker, JumpedTooObjectiveSet) == 0x0004A8, "Member 'AMissionTracker::JumpedTooObjectiveSet' has a wrong offset!");
static_assert(offsetof(AMissionTracker, DefendTarget) == 0x000568, "Member 'AMissionTracker::DefendTarget' has a wrong offset!");
static_assert(offsetof(AMissionTracker, bLevelLoadEventsIssued) == 0x000579, "Member 'AMissionTracker::bLevelLoadEventsIssued' has a wrong offset!");
static_assert(offsetof(AMissionTracker, AllMissionsObservers) == 0x0005E8, "Member 'AMissionTracker::AllMissionsObservers' has a wrong offset!");
static_assert(offsetof(AMissionTracker, MissionIconObservers) == 0x000600, "Member 'AMissionTracker::MissionIconObservers' has a wrong offset!");
static_assert(offsetof(AMissionTracker, ActiveIcons) == 0x000660, "Member 'AMissionTracker::ActiveIcons' has a wrong offset!");

// Class GbxMission.PlayerMissionComponent
// 0x0028 (0x01A0 - 0x0178)
class UPlayerMissionComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnMissionDataChanged;                              // 0x0178(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMissionPlaythroughData>        MissionPlaythroughs;                               // 0x0188(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AMissionTracker*                        CachedMissionTracker;                              // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClientDormantObjectiveAdded(TSubclassOf<class UMission> MissionClass, class UMissionObjective* Objective);
	void ClientDormantObjectiveRemoved(TSubclassOf<class UMission> MissionClass, class UMissionObjective* Objective, bool bIssueActiveEvent);
	void ClientMissionRegistered(TSubclassOf<class UMission> MissionClass);
	void ClientMissionTimerChanged(TSubclassOf<class UMission> MissionClass, float SecondsToAdd);
	void ClientMissionTimerStarted(TSubclassOf<class UMission> MissionClass);
	void ClientMissionTimerStopped(TSubclassOf<class UMission> MissionClass);
	void ClientObjectiveChainUnpaused(TSubclassOf<class UMission> MissionClass, class UMissionObjective* Objective);
	void ClientObjectiveCleared(TSubclassOf<class UMission> MissionClass, class UMissionObjective* ClearedObjective);
	void ClientObjectiveSetCompleted(TSubclassOf<class UMission> MissionClass, class UMissionObjectiveSet* CompletedObjectiveSet);
	void ClientObjectiveUpdated(TSubclassOf<class UMission> MissionClass, class UMissionObjective* UpdatedObjective, uint32 ObjectiveBit, uint8 Amount);
	void ClientTrackedMissionChanged(TSubclassOf<class UMission> MissionClass);
	void ClientUpdateActiveObjectiveSet(TSubclassOf<class UMission> MissionClass, class UMissionObjectiveSet* ActiveObjectiveSet, const TArray<class UMissionObjective*>& DormantObjectives);
	void ClientUpdateMissionStatus(TSubclassOf<class UMission> MissionClass, EMissionStatus Status);
	void ServerSetTrackedMission(TSubclassOf<class UMission> MissionClass);
	void ServerTrackNextActiveMissionInList();
	void ServerTrackPreviousActiveMissionInList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMissionComponent">();
	}
	static class UPlayerMissionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMissionComponent>();
	}
};
static_assert(alignof(UPlayerMissionComponent) == 0x000008, "Wrong alignment on UPlayerMissionComponent");
static_assert(sizeof(UPlayerMissionComponent) == 0x0001A0, "Wrong size on UPlayerMissionComponent");
static_assert(offsetof(UPlayerMissionComponent, OnMissionDataChanged) == 0x000178, "Member 'UPlayerMissionComponent::OnMissionDataChanged' has a wrong offset!");
static_assert(offsetof(UPlayerMissionComponent, MissionPlaythroughs) == 0x000188, "Member 'UPlayerMissionComponent::MissionPlaythroughs' has a wrong offset!");
static_assert(offsetof(UPlayerMissionComponent, CachedMissionTracker) == 0x000198, "Member 'UPlayerMissionComponent::CachedMissionTracker' has a wrong offset!");

// Class GbxMission.MissionCondition_List
// 0x0018 (0x00B8 - 0x00A0)
class UMissionCondition_List final : public UGbxCondition_List
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_List">();
	}
	static class UMissionCondition_List* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_List>();
	}
};
static_assert(alignof(UMissionCondition_List) == 0x000008, "Wrong alignment on UMissionCondition_List");
static_assert(sizeof(UMissionCondition_List) == 0x0000B8, "Wrong size on UMissionCondition_List");

// Class GbxMission.MissionDebugMenu
// 0x0020 (0x0318 - 0x02F8)
class UMissionDebugMenu final : public UGbxDebugMenuSubmenu
{
public:
	class UMissionGraph*                          MissionGraphToUse;                                 // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayObjectName;                                // 0x0300(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMission*>                       Missions;                                          // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AdvanceMission(const class FName& MissionId);
	void AdvanceToObjectiveSet(const class FName& MissionId, const class FName& ObjectiveSetId);
	void CompleteMission(const class FName& MissionId);
	void GetItemsForMissionGraph(TArray<struct FGbxCascadingListItemData>* OutItems);
	void GetItemsForMissionStatus(EMissionDebugStatus Status, TArray<struct FGbxCascadingListItemData>* OutItems);
	void SelectMissionGraph(const class FName& MissionGraphId);

	EMissionStatus GetMissionStatus(const class FName& MissionId) const;
	class UMission* GetMissionWithId(const class FName& MissionId) const;
	void GetObjectiveSetItemsForMission(const class FName& MissionId, TArray<struct FGbxCascadingListItemData>* OutItems) const;
	void NotifyMissionActivationCheatStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionDebugMenu">();
	}
	static class UMissionDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionDebugMenu>();
	}
};
static_assert(alignof(UMissionDebugMenu) == 0x000008, "Wrong alignment on UMissionDebugMenu");
static_assert(sizeof(UMissionDebugMenu) == 0x000318, "Wrong size on UMissionDebugMenu");
static_assert(offsetof(UMissionDebugMenu, MissionGraphToUse) == 0x0002F8, "Member 'UMissionDebugMenu::MissionGraphToUse' has a wrong offset!");
static_assert(offsetof(UMissionDebugMenu, bDisplayObjectName) == 0x000300, "Member 'UMissionDebugMenu::bDisplayObjectName' has a wrong offset!");
static_assert(offsetof(UMissionDebugMenu, Missions) == 0x000308, "Member 'UMissionDebugMenu::Missions' has a wrong offset!");

// Class GbxMission.MissionEnableConditionBreadcrumbLinkedObjective
// 0x0050 (0x00F0 - 0x00A0)
class UMissionEnableConditionBreadcrumbLinkedObjective final : public UMissionEnableCondition
{
public:
	struct FMissionObjectiveReferenceWeak         ObjectiveRef;                                      // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionBreadcrumbLinkedObjective">();
	}
	static class UMissionEnableConditionBreadcrumbLinkedObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionBreadcrumbLinkedObjective>();
	}
};
static_assert(alignof(UMissionEnableConditionBreadcrumbLinkedObjective) == 0x000008, "Wrong alignment on UMissionEnableConditionBreadcrumbLinkedObjective");
static_assert(sizeof(UMissionEnableConditionBreadcrumbLinkedObjective) == 0x0000F0, "Wrong size on UMissionEnableConditionBreadcrumbLinkedObjective");
static_assert(offsetof(UMissionEnableConditionBreadcrumbLinkedObjective, ObjectiveRef) == 0x0000A0, "Member 'UMissionEnableConditionBreadcrumbLinkedObjective::ObjectiveRef' has a wrong offset!");

// Class GbxMission.MissionEnableConditionKickoff
// 0x0028 (0x00C8 - 0x00A0)
class UMissionEnableConditionKickoff final : public UMissionEnableCondition
{
public:
	TSoftClassPtr<class UClass>                   MissionClass;                                      // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionKickoff">();
	}
	static class UMissionEnableConditionKickoff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionKickoff>();
	}
};
static_assert(alignof(UMissionEnableConditionKickoff) == 0x000008, "Wrong alignment on UMissionEnableConditionKickoff");
static_assert(sizeof(UMissionEnableConditionKickoff) == 0x0000C8, "Wrong size on UMissionEnableConditionKickoff");
static_assert(offsetof(UMissionEnableConditionKickoff, MissionClass) == 0x0000A0, "Member 'UMissionEnableConditionKickoff::MissionClass' has a wrong offset!");

// Class GbxMission.MissionEnableConditionMission
// 0x0030 (0x00D0 - 0x00A0)
class UMissionEnableConditionMission final : public UMissionEnableCondition
{
public:
	TSoftClassPtr<class UClass>                   MissionClass;                                      // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionStatus                                MissionStatus;                                     // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionMission">();
	}
	static class UMissionEnableConditionMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionMission>();
	}
};
static_assert(alignof(UMissionEnableConditionMission) == 0x000008, "Wrong alignment on UMissionEnableConditionMission");
static_assert(sizeof(UMissionEnableConditionMission) == 0x0000D0, "Wrong size on UMissionEnableConditionMission");
static_assert(offsetof(UMissionEnableConditionMission, MissionClass) == 0x0000A0, "Member 'UMissionEnableConditionMission::MissionClass' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionMission, MissionStatus) == 0x0000C8, "Member 'UMissionEnableConditionMission::MissionStatus' has a wrong offset!");

// Class GbxMission.MissionEnableConditionMissionAvailable
// 0x0028 (0x00C8 - 0x00A0)
class UMissionEnableConditionMissionAvailable final : public UMissionEnableCondition
{
public:
	TSoftClassPtr<class UClass>                   MissionClass;                                      // 0x00A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionMissionAvailable">();
	}
	static class UMissionEnableConditionMissionAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionMissionAvailable>();
	}
};
static_assert(alignof(UMissionEnableConditionMissionAvailable) == 0x000008, "Wrong alignment on UMissionEnableConditionMissionAvailable");
static_assert(sizeof(UMissionEnableConditionMissionAvailable) == 0x0000C8, "Wrong size on UMissionEnableConditionMissionAvailable");
static_assert(offsetof(UMissionEnableConditionMissionAvailable, MissionClass) == 0x0000A0, "Member 'UMissionEnableConditionMissionAvailable::MissionClass' has a wrong offset!");

// Class GbxMission.MissionEnableConditionObjective
// 0x0058 (0x00F8 - 0x00A0)
class UMissionEnableConditionObjective final : public UMissionEnableCondition
{
public:
	struct FMissionObjectiveReferenceWeak         ObjectiveRef;                                      // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EMissionObjectiveStatus                       ObjectiveStatus;                                   // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreObjectiveBit;                               // 0x00F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionObjective">();
	}
	static class UMissionEnableConditionObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionObjective>();
	}
};
static_assert(alignof(UMissionEnableConditionObjective) == 0x000008, "Wrong alignment on UMissionEnableConditionObjective");
static_assert(sizeof(UMissionEnableConditionObjective) == 0x0000F8, "Wrong size on UMissionEnableConditionObjective");
static_assert(offsetof(UMissionEnableConditionObjective, ObjectiveRef) == 0x0000A0, "Member 'UMissionEnableConditionObjective::ObjectiveRef' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjective, ObjectiveStatus) == 0x0000F0, "Member 'UMissionEnableConditionObjective::ObjectiveStatus' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjective, bIgnoreObjectiveBit) == 0x0000F1, "Member 'UMissionEnableConditionObjective::bIgnoreObjectiveBit' has a wrong offset!");

// Class GbxMission.MissionEnableConditionObjectiveCount
// 0x0060 (0x0100 - 0x00A0)
class UMissionEnableConditionObjectiveCount final : public UMissionEnableCondition
{
public:
	struct FMissionObjectiveReferenceWeak         ObjectiveRef;                                      // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EObjectiveCountComparisonOperatorType         ComparisonOperator;                                // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ObjectiveProgress;                                 // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireActiveObjective;                           // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnableConditionObjectiveCount">();
	}
	static class UMissionEnableConditionObjectiveCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnableConditionObjectiveCount>();
	}
};
static_assert(alignof(UMissionEnableConditionObjectiveCount) == 0x000008, "Wrong alignment on UMissionEnableConditionObjectiveCount");
static_assert(sizeof(UMissionEnableConditionObjectiveCount) == 0x000100, "Wrong size on UMissionEnableConditionObjectiveCount");
static_assert(offsetof(UMissionEnableConditionObjectiveCount, ObjectiveRef) == 0x0000A0, "Member 'UMissionEnableConditionObjectiveCount::ObjectiveRef' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjectiveCount, ComparisonOperator) == 0x0000F0, "Member 'UMissionEnableConditionObjectiveCount::ComparisonOperator' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjectiveCount, ObjectiveProgress) == 0x0000F4, "Member 'UMissionEnableConditionObjectiveCount::ObjectiveProgress' has a wrong offset!");
static_assert(offsetof(UMissionEnableConditionObjectiveCount, bRequireActiveObjective) == 0x0000F8, "Member 'UMissionEnableConditionObjectiveCount::bRequireActiveObjective' has a wrong offset!");

// Class GbxMission.MissionFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMissionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateMission(class UObject* WorldContextObject, TSubclassOf<class UMission> MissionClass);
	static void ActivateMissionAtObjectiveSet(class UObject* WorldContextObject, const struct FMissionObjectiveSetReference& ObjectiveSetRef);
	static void AdvanceMissionObjectiveSetRef(class UObject* WorldContextObject, const struct FMissionObjectiveSetReference& ObjectiveSetRef);
	static void AdvanceToBreadcrumbObjective(class UObject* WorldContextObject, const struct FMissionObjectiveReference& BreadcrumbObjectiveRef);
	static void CompleteMission(class UObject* WorldContextObject, TSubclassOf<class UMission> MissionClass);
	static class UMission* CreateMission(class UObject* WorldContextObject, TSubclassOf<class UMission> MissionClass);
	static void DebugJumpToMissionObjectiveSetRef(class UObject* WorldContextObject, const struct FMissionObjectiveSetReference& ObjectiveSetRef, bool bIsBranchingMission);
	static bool EqualEqual_MissionObjectiveReference(const struct FMissionObjectiveReference& A, const struct FMissionObjectiveReference& B);
	static bool EqualEqual_MissionObjectiveSetReference(const struct FMissionObjectiveSetReference& A, const struct FMissionObjectiveSetReference& B);
	static void FillMissionEventRef(struct FMissionEventReference& MissionEventRef, TSubclassOf<class UMission>& MissionClass, class FName EventName);
	static void FillMissionObjectiveRef(struct FMissionObjectiveReference& MissionObjectiveRef, TSubclassOf<class UMission>& MissionClass, class FName Objective);
	static void FillMissionObjectiveRefWeak(struct FMissionObjectiveReferenceWeak& MissionObjectiveRef, TSubclassOf<class UMission>& MissionClass, class FName Objective);
	static void FillMissionObjectiveSetRef(struct FMissionObjectiveSetReference& MissionObjectiveSetRef, TSubclassOf<class UMission>& MissionClass, class FName ObjectiveSet);
	static TArray<class UMission*> GetActiveMissions(class UObject* WorldContextObject);
	static TSubclassOf<class UMission> GetActivePlotMission(class UObject* WorldContextObject);
	static TSubclassOf<class UMission> GetCurrentlyTrackedMission(class UObject* WorldContextObject);
	static void GetEventNameListForMission(TSubclassOf<class UMission> MissionClass, TArray<class FName>* NamesList);
	static class UMission* GetMission(class UObject* WorldContextObject, TSubclassOf<class UMission> MissionClass);
	static TSubclassOf<class UMission> GetMissionClassFromObjectiveReference(const struct FMissionObjectiveReference& ObjectiveReference);
	static TSubclassOf<class UMission> GetMissionClassFromObjectiveReferenceWeak(const struct FMissionObjectiveReferenceWeak& ObjectiveReference);
	static int32 GetMissionLevel(class UMission* MissionObj);
	static void GetMissionObjectiveCount(class UObject* WorldContextObject, const struct FMissionObjectiveReference& ObjectiveRef, int32* CurrentObjectiveCount, int32* TotalObjectiveCount);
	static EMissionObjectiveSetStatus GetMissionObjectiveSetStatusRef(class UObject* WorldContextObject, const struct FMissionObjectiveSetReference& ObjectiveSetRef);
	static EMissionObjectiveStatus GetMissionObjectiveStatusRef(class UObject* WorldContextObject, const struct FMissionObjectiveReference& ObjectiveRef, class UObject* OptionalContext);
	static EMissionStatus GetMissionStatus(class UObject* WorldContextObject, TSubclassOf<class UMission> MissionClass);
	static void GetObjectiveNameListForMission(TSubclassOf<class UMission> MissionClass, TArray<class FName>* NamesList);
	static void GetObjectiveNameListForMissionFromAssetSubclass(TSoftClassPtr<class UClass> Mission, TArray<class FName>* NamesList);
	static void GetObjectiveSetListForMission(TSubclassOf<class UMission> MissionClass, TArray<class UMissionObjectiveSet*>* ObjectiveSetList);
	static void GetObjectiveSetNameListForMission(TSubclassOf<class UMission> MissionClass, TArray<class FName>* NamesList);
	static void GetObjectiveSetNameListForMissionFromAssetSubclass(TSoftClassPtr<class UClass> MissionClass, TArray<class FName>* NamesList);
	static int32 GetPlotMissionIndex(class UMission* MissionObj);
	static void GetSoftObjectiveSetListForMission(TSoftClassPtr<class UClass> MissionClass, TArray<TSoftObjectPtr<class UMissionObjectiveSet>>* SoftObjectiveSetList);
	static void JumpToMissionObjectiveSetRef(class UObject* WorldContextObject, const struct FMissionObjectiveSetReference& ObjectiveSetRef, bool bIsBranchingMission);
	static TSubclassOf<class UMission> ResolveMissionSoftClassReference(TSoftClassPtr<class UClass> Mission);
	static void SendMissionEvent(class UObject* WorldContextObject, const struct FMissionEventReference& EventRef, class UObject* OptionalContext);
	static void SendMissionEventWithContext(const struct FMissionEventReference& EventRef, class UObject* WorldContextObject, class UObject* OptionalContext);
	static void TrackActiveMission(class UObject* WorldContextObject, TSubclassOf<class UMission> MissionClass);
	static void TrackNextActiveMissionInList(class UObject* WorldContextObject);
	static void TrackPreviousActiveMissionInList(class UObject* WorldContextObject);
	static void UpdateMissionObjectiveRef(class UObject* WorldContextObject, const struct FMissionObjectiveReference& ObjectiveRef);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionFunctionLibrary">();
	}
	static class UMissionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionFunctionLibrary>();
	}
};
static_assert(alignof(UMissionFunctionLibrary) == 0x000008, "Wrong alignment on UMissionFunctionLibrary");
static_assert(sizeof(UMissionFunctionLibrary) == 0x000028, "Wrong size on UMissionFunctionLibrary");

// Class GbxMission.MissionIconObserverInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionIconObserverInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionIconObserverInterface">();
	}
	static class IMissionIconObserverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionIconObserverInterface>();
	}
};
static_assert(alignof(IMissionIconObserverInterface) == 0x000008, "Wrong alignment on IMissionIconObserverInterface");
static_assert(sizeof(IMissionIconObserverInterface) == 0x000028, "Wrong size on IMissionIconObserverInterface");

// Class GbxMission.MissionLocationData
// 0x0038 (0x0068 - 0x0030)
class UMissionLocationData final : public UTravelLocationData
{
public:
	TSoftObjectPtr<class UTravelStationData>      DefaultStation;                                    // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMissionLocation>               MissionLocations;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool EnabledConditionRequiresNativeClass();
	class UClass* GetRequiredInterface();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionLocationData">();
	}
	static class UMissionLocationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionLocationData>();
	}
};
static_assert(alignof(UMissionLocationData) == 0x000008, "Wrong alignment on UMissionLocationData");
static_assert(sizeof(UMissionLocationData) == 0x000068, "Wrong size on UMissionLocationData");
static_assert(offsetof(UMissionLocationData, DefaultStation) == 0x000030, "Member 'UMissionLocationData::DefaultStation' has a wrong offset!");
static_assert(offsetof(UMissionLocationData, MissionLocations) == 0x000058, "Member 'UMissionLocationData::MissionLocations' has a wrong offset!");

// Class GbxMission.MissionObjective
// 0x00B0 (0x00D8 - 0x0028)
class UMissionObjective final : public UObject
{
public:
	uint8                                         ObjectiveCount;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameStatData*                          GameStat;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxUIFormattedText                    FormattedProgressMessage;                          // 0x0038(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bRememberIndividualState;                          // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllOrNothing;                                     // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearIfActiveSetNotComplete;                      // 0x00A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUpdateIfActivatedInMissionLevel;              // 0x00A3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvisible;                                        // 0x00A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreadcrumb;                                       // 0x00A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreadcrumbNoClear;                                // 0x00A6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreadcrumbLinked;                                 // 0x00A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptional;                                         // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseObjectiveChain;                              // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdvanceChainOnLevelLoad;                          // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsPlanetTravel;                                // 0x00AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrantsStarterGear;                                // 0x00AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfAnyPlayerInVehicle;                   // 0x00AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfNoPlayersInVehicle;                   // 0x00AE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfMissionVehicleNotSpawned;             // 0x00AF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfTravelIdActive;                       // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfTravelIdNotActive;                    // 0x00B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfMissionWeaponWielded;                 // 0x00B2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfMissionWeaponNotWielded;              // 0x00B3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfStateStable;                          // 0x00B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveIfStateTransitioning;                   // 0x00B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoClearWhenNoLongerDormant;                     // 0x00B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bObjectiveChainHead;                               // 0x00B7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bObjectiveChainMember;                             // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiredForObjectiveSetAdvance;                   // 0x00B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressEmptyCheckbox;                            // 0x00BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMissionRewardData*                     OptionalRewardData;                                // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectiveGuid;                                     // 0x00C8(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjective">();
	}
	static class UMissionObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjective>();
	}
};
static_assert(alignof(UMissionObjective) == 0x000008, "Wrong alignment on UMissionObjective");
static_assert(sizeof(UMissionObjective) == 0x0000D8, "Wrong size on UMissionObjective");
static_assert(offsetof(UMissionObjective, ObjectiveCount) == 0x000028, "Member 'UMissionObjective::ObjectiveCount' has a wrong offset!");
static_assert(offsetof(UMissionObjective, GameStat) == 0x000030, "Member 'UMissionObjective::GameStat' has a wrong offset!");
static_assert(offsetof(UMissionObjective, FormattedProgressMessage) == 0x000038, "Member 'UMissionObjective::FormattedProgressMessage' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bRememberIndividualState) == 0x0000A0, "Member 'UMissionObjective::bRememberIndividualState' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bAllOrNothing) == 0x0000A1, "Member 'UMissionObjective::bAllOrNothing' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bClearIfActiveSetNotComplete) == 0x0000A2, "Member 'UMissionObjective::bClearIfActiveSetNotComplete' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bAutoUpdateIfActivatedInMissionLevel) == 0x0000A3, "Member 'UMissionObjective::bAutoUpdateIfActivatedInMissionLevel' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bInvisible) == 0x0000A4, "Member 'UMissionObjective::bInvisible' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bBreadcrumb) == 0x0000A5, "Member 'UMissionObjective::bBreadcrumb' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bBreadcrumbNoClear) == 0x0000A6, "Member 'UMissionObjective::bBreadcrumbNoClear' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bBreadcrumbLinked) == 0x0000A7, "Member 'UMissionObjective::bBreadcrumbLinked' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOptional) == 0x0000A8, "Member 'UMissionObjective::bOptional' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bPauseObjectiveChain) == 0x0000A9, "Member 'UMissionObjective::bPauseObjectiveChain' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bAdvanceChainOnLevelLoad) == 0x0000AA, "Member 'UMissionObjective::bAdvanceChainOnLevelLoad' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bWantsPlanetTravel) == 0x0000AB, "Member 'UMissionObjective::bWantsPlanetTravel' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bGrantsStarterGear) == 0x0000AC, "Member 'UMissionObjective::bGrantsStarterGear' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfAnyPlayerInVehicle) == 0x0000AD, "Member 'UMissionObjective::bOnlyActiveIfAnyPlayerInVehicle' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfNoPlayersInVehicle) == 0x0000AE, "Member 'UMissionObjective::bOnlyActiveIfNoPlayersInVehicle' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfMissionVehicleNotSpawned) == 0x0000AF, "Member 'UMissionObjective::bOnlyActiveIfMissionVehicleNotSpawned' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfTravelIdActive) == 0x0000B0, "Member 'UMissionObjective::bOnlyActiveIfTravelIdActive' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfTravelIdNotActive) == 0x0000B1, "Member 'UMissionObjective::bOnlyActiveIfTravelIdNotActive' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfMissionWeaponWielded) == 0x0000B2, "Member 'UMissionObjective::bOnlyActiveIfMissionWeaponWielded' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfMissionWeaponNotWielded) == 0x0000B3, "Member 'UMissionObjective::bOnlyActiveIfMissionWeaponNotWielded' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfStateStable) == 0x0000B4, "Member 'UMissionObjective::bOnlyActiveIfStateStable' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bOnlyActiveIfStateTransitioning) == 0x0000B5, "Member 'UMissionObjective::bOnlyActiveIfStateTransitioning' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bAutoClearWhenNoLongerDormant) == 0x0000B6, "Member 'UMissionObjective::bAutoClearWhenNoLongerDormant' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bObjectiveChainHead) == 0x0000B7, "Member 'UMissionObjective::bObjectiveChainHead' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bObjectiveChainMember) == 0x0000B8, "Member 'UMissionObjective::bObjectiveChainMember' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bRequiredForObjectiveSetAdvance) == 0x0000B9, "Member 'UMissionObjective::bRequiredForObjectiveSetAdvance' has a wrong offset!");
static_assert(offsetof(UMissionObjective, bSuppressEmptyCheckbox) == 0x0000BA, "Member 'UMissionObjective::bSuppressEmptyCheckbox' has a wrong offset!");
static_assert(offsetof(UMissionObjective, OptionalRewardData) == 0x0000C0, "Member 'UMissionObjective::OptionalRewardData' has a wrong offset!");
static_assert(offsetof(UMissionObjective, ObjectiveGuid) == 0x0000C8, "Member 'UMissionObjective::ObjectiveGuid' has a wrong offset!");

// Class GbxMission.MissionObjectiveReferenceInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionObjectiveReferenceInterface final : public IInterface
{
public:
	void GetMissionObjectiveReferences(TArray<struct FMissionObjectiveReference>* OutMissionObjectives) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjectiveReferenceInterface">();
	}
	static class IMissionObjectiveReferenceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionObjectiveReferenceInterface>();
	}
};
static_assert(alignof(IMissionObjectiveReferenceInterface) == 0x000008, "Wrong alignment on IMissionObjectiveReferenceInterface");
static_assert(sizeof(IMissionObjectiveReferenceInterface) == 0x000028, "Wrong size on IMissionObjectiveReferenceInterface");

// Class GbxMission.MissionObjectiveSet
// 0x0148 (0x0170 - 0x0028)
class UMissionObjectiveSet final : public UObject
{
public:
	TArray<class UMissionObjective*>              Objectives;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTravelLocationData>     StationOverride;                                   // 0x0038(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMissionObjective*                      BreadcrumbLinkedObjective;                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionObjective*                      DisplayedBreadcrumbLinkedObjective;                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   NextSet;                                           // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCompleteMission;                               // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAdvanceToNextSet;                             // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutOfMapWaypoints;                                // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContainsRequiredObjectives;                       // 0x007B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContainsClearIfNotCompleteObjectives;             // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxUIFormattedText                    DescriptionOverride;                               // 0x0080(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGbxUIFormattedText                    PreAcceptanceSummaryOverride;                      // 0x00E8(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectiveSetGuid;                                  // 0x0150(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ObjOrderPos;                                       // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjectiveSet">();
	}
	static class UMissionObjectiveSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObjectiveSet>();
	}
};
static_assert(alignof(UMissionObjectiveSet) == 0x000008, "Wrong alignment on UMissionObjectiveSet");
static_assert(sizeof(UMissionObjectiveSet) == 0x000170, "Wrong size on UMissionObjectiveSet");
static_assert(offsetof(UMissionObjectiveSet, Objectives) == 0x000028, "Member 'UMissionObjectiveSet::Objectives' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, StationOverride) == 0x000038, "Member 'UMissionObjectiveSet::StationOverride' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, BreadcrumbLinkedObjective) == 0x000060, "Member 'UMissionObjectiveSet::BreadcrumbLinkedObjective' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, DisplayedBreadcrumbLinkedObjective) == 0x000068, "Member 'UMissionObjectiveSet::DisplayedBreadcrumbLinkedObjective' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, NextSet) == 0x000070, "Member 'UMissionObjectiveSet::NextSet' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, bCanCompleteMission) == 0x000078, "Member 'UMissionObjectiveSet::bCanCompleteMission' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, bAutoAdvanceToNextSet) == 0x000079, "Member 'UMissionObjectiveSet::bAutoAdvanceToNextSet' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, bOutOfMapWaypoints) == 0x00007A, "Member 'UMissionObjectiveSet::bOutOfMapWaypoints' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, bContainsRequiredObjectives) == 0x00007B, "Member 'UMissionObjectiveSet::bContainsRequiredObjectives' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, bContainsClearIfNotCompleteObjectives) == 0x00007C, "Member 'UMissionObjectiveSet::bContainsClearIfNotCompleteObjectives' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, DescriptionOverride) == 0x000080, "Member 'UMissionObjectiveSet::DescriptionOverride' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, PreAcceptanceSummaryOverride) == 0x0000E8, "Member 'UMissionObjectiveSet::PreAcceptanceSummaryOverride' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, ObjectiveSetGuid) == 0x000150, "Member 'UMissionObjectiveSet::ObjectiveSetGuid' has a wrong offset!");
static_assert(offsetof(UMissionObjectiveSet, ObjOrderPos) == 0x000160, "Member 'UMissionObjectiveSet::ObjOrderPos' has a wrong offset!");

// Class GbxMission.MissionObjectiveSetReferenceInterface
// 0x0000 (0x0028 - 0x0028)
class IMissionObjectiveSetReferenceInterface final : public IInterface
{
public:
	void GetMissionObjectiveSetReferences(TArray<struct FMissionObjectiveSetReference>* OutMissionObjectiveSets) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObjectiveSetReferenceInterface">();
	}
	static class IMissionObjectiveSetReferenceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMissionObjectiveSetReferenceInterface>();
	}
};
static_assert(alignof(IMissionObjectiveSetReferenceInterface) == 0x000008, "Wrong alignment on IMissionObjectiveSetReferenceInterface");
static_assert(sizeof(IMissionObjectiveSetReferenceInterface) == 0x000028, "Wrong size on IMissionObjectiveSetReferenceInterface");

// Class GbxMission.MissionObserverComponent
// 0x0090 (0x0208 - 0x0178)
class UMissionObserverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UMission>>           Missions;                                          // 0x0188(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ObjectiveBit;                                      // 0x0198(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NumberOfObjectiveBits;                             // 0x019C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableObjectiveBit;                               // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnMissionUpdate;                                   // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionObjectiveUpdate;                          // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionObjectiveSetUpdate;                       // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMissionsInitialized;                             // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FMissionObserverEvent>          ObserverEventList;                                 // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMissionEnableConditionEvent>   OnLoadEventList;                                   // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool GetUpdateEventObject(TArray<class UObject*>* OutMissionInitialized, TArray<class UObject*>* OutMissionUpdate, TArray<class UObject*>* OutMissionObjectiveUpdate, TArray<class UObject*>* OutMissionObjectiveSetUpdate);
	void ObserverMission(TSubclassOf<class UMission> MissionClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionObserverComponent">();
	}
	static class UMissionObserverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionObserverComponent>();
	}
};
static_assert(alignof(UMissionObserverComponent) == 0x000008, "Wrong alignment on UMissionObserverComponent");
static_assert(sizeof(UMissionObserverComponent) == 0x000208, "Wrong size on UMissionObserverComponent");
static_assert(offsetof(UMissionObserverComponent, Missions) == 0x000188, "Member 'UMissionObserverComponent::Missions' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, ObjectiveBit) == 0x000198, "Member 'UMissionObserverComponent::ObjectiveBit' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, NumberOfObjectiveBits) == 0x00019C, "Member 'UMissionObserverComponent::NumberOfObjectiveBits' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, bEnableObjectiveBit) == 0x0001A0, "Member 'UMissionObserverComponent::bEnableObjectiveBit' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, OnMissionUpdate) == 0x0001A8, "Member 'UMissionObserverComponent::OnMissionUpdate' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, OnMissionObjectiveUpdate) == 0x0001B8, "Member 'UMissionObserverComponent::OnMissionObjectiveUpdate' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, OnMissionObjectiveSetUpdate) == 0x0001C8, "Member 'UMissionObserverComponent::OnMissionObjectiveSetUpdate' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, OnMissionsInitialized) == 0x0001D8, "Member 'UMissionObserverComponent::OnMissionsInitialized' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, ObserverEventList) == 0x0001E8, "Member 'UMissionObserverComponent::ObserverEventList' has a wrong offset!");
static_assert(offsetof(UMissionObserverComponent, OnLoadEventList) == 0x0001F8, "Member 'UMissionObserverComponent::OnLoadEventList' has a wrong offset!");

// Class GbxMission.MissionPhase
// 0x0018 (0x0040 - 0x0028)
class UMissionPhase final : public UObject
{
public:
	TArray<class UMissionObjectiveSet*>           ObjectiveSets;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, NativeAccessSpecifierPublic)
	int32                                         PhaseIndex;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPhase">();
	}
	static class UMissionPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionPhase>();
	}
};
static_assert(alignof(UMissionPhase) == 0x000008, "Wrong alignment on UMissionPhase");
static_assert(sizeof(UMissionPhase) == 0x000040, "Wrong size on UMissionPhase");
static_assert(offsetof(UMissionPhase, ObjectiveSets) == 0x000028, "Member 'UMissionPhase::ObjectiveSets' has a wrong offset!");
static_assert(offsetof(UMissionPhase, PhaseIndex) == 0x000038, "Member 'UMissionPhase::PhaseIndex' has a wrong offset!");

}

