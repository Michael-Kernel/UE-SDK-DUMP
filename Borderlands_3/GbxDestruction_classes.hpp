#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxDestruction

#include "Basic.hpp"

#include "GbxDestruction_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "GbxAudio_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "ApexDestruction_classes.hpp"


namespace SDK
{

// Class GbxDestruction.ClothActor
// 0x0018 (0x0470 - 0x0458)
class AClothActor : public AActor
{
public:
	struct FWindDirectionalSensitivity            WindSensitivity;                                   // 0x0458(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothActor">();
	}
	static class AClothActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothActor>();
	}
};
static_assert(alignof(AClothActor) == 0x000008, "Wrong alignment on AClothActor");
static_assert(sizeof(AClothActor) == 0x000470, "Wrong size on AClothActor");
static_assert(offsetof(AClothActor, WindSensitivity) == 0x000458, "Member 'AClothActor::WindSensitivity' has a wrong offset!");

// Class GbxDestruction.ClothSkeletalMeshActor
// 0x0018 (0x0488 - 0x0470)
class AClothSkeletalMeshActor final : public AClothActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x10];                                     // 0x0478(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothSkeletalMeshActor">();
	}
	static class AClothSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothSkeletalMeshActor>();
	}
};
static_assert(alignof(AClothSkeletalMeshActor) == 0x000008, "Wrong alignment on AClothSkeletalMeshActor");
static_assert(sizeof(AClothSkeletalMeshActor) == 0x000488, "Wrong size on AClothSkeletalMeshActor");
static_assert(offsetof(AClothSkeletalMeshActor, SkeletalMeshComponent) == 0x000470, "Member 'AClothSkeletalMeshActor::SkeletalMeshComponent' has a wrong offset!");

// Class GbxDestruction.ClothStaticMeshActor
// 0x0008 (0x0478 - 0x0470)
class AClothStaticMeshActor : public AClothActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0470(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothStaticMeshActor">();
	}
	static class AClothStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothStaticMeshActor>();
	}
};
static_assert(alignof(AClothStaticMeshActor) == 0x000008, "Wrong alignment on AClothStaticMeshActor");
static_assert(sizeof(AClothStaticMeshActor) == 0x000478, "Wrong size on AClothStaticMeshActor");
static_assert(offsetof(AClothStaticMeshActor, StaticMeshComponent) == 0x000470, "Member 'AClothStaticMeshActor::StaticMeshComponent' has a wrong offset!");

// Class GbxDestruction.ClothManager
// 0x0048 (0x04A0 - 0x0458)
class AClothManager final : public AClothManagerInterface
{
public:
	uint8                                         Pad_458[0x40];                                     // 0x0458(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAllowedSimCost;                                 // 0x0498(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOffScreenBeforeSimulationPause;                // 0x049C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClothManager">();
	}
	static class AClothManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClothManager>();
	}
};
static_assert(alignof(AClothManager) == 0x000008, "Wrong alignment on AClothManager");
static_assert(sizeof(AClothManager) == 0x0004A0, "Wrong size on AClothManager");
static_assert(offsetof(AClothManager, MaxAllowedSimCost) == 0x000498, "Member 'AClothManager::MaxAllowedSimCost' has a wrong offset!");
static_assert(offsetof(AClothManager, TimeOffScreenBeforeSimulationPause) == 0x00049C, "Member 'AClothManager::TimeOffScreenBeforeSimulationPause' has a wrong offset!");

// Class GbxDestruction.GbxDestructibleComponent
// 0x0090 (0x0BD0 - 0x0B40)
class UGbxDestructibleComponent : public UDestructibleComponent
{
public:
	uint8                                         Pad_B40[0x2C];                                     // 0x0B40(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsToWaitAfterNotRenderedToCleanUp;            // 0x0B6C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbabilityOfTransientChunk;                       // 0x0B70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractureEventRefireDelay;                          // 0x0B74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnGbxComponentFracture;                            // 0x0B80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EDestructibleRelevance                        DestructibleRelevance;                             // 0x0B90(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ChunkCollisionChannel;                             // 0x0B91(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B92[0x6];                                      // 0x0B92(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            ChunkImpactData;                                   // 0x0B98(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayFractureEventOnDebris;                        // 0x0BA0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportChunksBlockPawnMovement;                   // 0x0BA1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAssetDamageThreshold;                     // 0x0BA2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA3[0x1];                                      // 0x0BA3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MetersDroppedToBreak;                              // 0x0BA4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDestructibleDamageThresholdMagnitude         DamageThresholdMagnitude;                          // 0x0BA8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA9[0x3];                                      // 0x0BA9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ImpactDamageDefaultDepth;                          // 0x0BAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoComputeMaterialStrength;                      // 0x0BB0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccumulateImpactDamage;                           // 0x0BB1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB2[0x2];                                      // 0x0BB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactVelocityThresholdOverride;                   // 0x0BB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTotalMass;                                     // 0x0BB8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB9[0x3];                                      // 0x0BB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalMass;                                         // 0x0BBC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDebrisLifetime;                           // 0x0BC0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC1[0x3];                                      // 0x0BC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebrisLifetimeMin;                                 // 0x0BC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLifetimeMax;                                 // 0x0BC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractureEffectOverlapPercent;                      // 0x0BCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FractureRandomChunk();
	float GetDamageRequiredToFracture(int32 Depth);
	void SetFracturable(bool bFracturable);

	float GetTotalPercentFractured() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDestructibleComponent">();
	}
	static class UGbxDestructibleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDestructibleComponent>();
	}
};
static_assert(alignof(UGbxDestructibleComponent) == 0x000008, "Wrong alignment on UGbxDestructibleComponent");
static_assert(sizeof(UGbxDestructibleComponent) == 0x000BD0, "Wrong size on UGbxDestructibleComponent");
static_assert(offsetof(UGbxDestructibleComponent, SecondsToWaitAfterNotRenderedToCleanUp) == 0x000B6C, "Member 'UGbxDestructibleComponent::SecondsToWaitAfterNotRenderedToCleanUp' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, ProbabilityOfTransientChunk) == 0x000B70, "Member 'UGbxDestructibleComponent::ProbabilityOfTransientChunk' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, FractureEventRefireDelay) == 0x000B74, "Member 'UGbxDestructibleComponent::FractureEventRefireDelay' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, OnGbxComponentFracture) == 0x000B80, "Member 'UGbxDestructibleComponent::OnGbxComponentFracture' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, DestructibleRelevance) == 0x000B90, "Member 'UGbxDestructibleComponent::DestructibleRelevance' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, ChunkCollisionChannel) == 0x000B91, "Member 'UGbxDestructibleComponent::ChunkCollisionChannel' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, ChunkImpactData) == 0x000B98, "Member 'UGbxDestructibleComponent::ChunkImpactData' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bPlayFractureEventOnDebris) == 0x000BA0, "Member 'UGbxDestructibleComponent::bPlayFractureEventOnDebris' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bSupportChunksBlockPawnMovement) == 0x000BA1, "Member 'UGbxDestructibleComponent::bSupportChunksBlockPawnMovement' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bOverrideAssetDamageThreshold) == 0x000BA2, "Member 'UGbxDestructibleComponent::bOverrideAssetDamageThreshold' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, MetersDroppedToBreak) == 0x000BA4, "Member 'UGbxDestructibleComponent::MetersDroppedToBreak' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, DamageThresholdMagnitude) == 0x000BA8, "Member 'UGbxDestructibleComponent::DamageThresholdMagnitude' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, ImpactDamageDefaultDepth) == 0x000BAC, "Member 'UGbxDestructibleComponent::ImpactDamageDefaultDepth' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bAutoComputeMaterialStrength) == 0x000BB0, "Member 'UGbxDestructibleComponent::bAutoComputeMaterialStrength' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bAccumulateImpactDamage) == 0x000BB1, "Member 'UGbxDestructibleComponent::bAccumulateImpactDamage' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, ImpactVelocityThresholdOverride) == 0x000BB4, "Member 'UGbxDestructibleComponent::ImpactVelocityThresholdOverride' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bUseTotalMass) == 0x000BB8, "Member 'UGbxDestructibleComponent::bUseTotalMass' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, TotalMass) == 0x000BBC, "Member 'UGbxDestructibleComponent::TotalMass' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, bOverrideDebrisLifetime) == 0x000BC0, "Member 'UGbxDestructibleComponent::bOverrideDebrisLifetime' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, DebrisLifetimeMin) == 0x000BC4, "Member 'UGbxDestructibleComponent::DebrisLifetimeMin' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, DebrisLifetimeMax) == 0x000BC8, "Member 'UGbxDestructibleComponent::DebrisLifetimeMax' has a wrong offset!");
static_assert(offsetof(UGbxDestructibleComponent, FractureEffectOverlapPercent) == 0x000BCC, "Member 'UGbxDestructibleComponent::FractureEffectOverlapPercent' has a wrong offset!");

// Class GbxDestruction.GbxDestructibleActor
// 0x0080 (0x04F8 - 0x0478)
class AGbxDestructibleActor : public ADestructibleActor
{
public:
	struct FGbxDestructibleNetBuffer              FractureBuffer;                                    // 0x0478(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGbxDestructibleNetBuffer              TransformBuffer;                                   // 0x0498(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x38];                                     // 0x04B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SyncID;                                            // 0x04F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FractureBuffer();
	void OnRep_SyncID();
	void OnRep_TransformBuffer();
	void SetFracturable(bool bFracturable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDestructibleActor">();
	}
	static class AGbxDestructibleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxDestructibleActor>();
	}
};
static_assert(alignof(AGbxDestructibleActor) == 0x000008, "Wrong alignment on AGbxDestructibleActor");
static_assert(sizeof(AGbxDestructibleActor) == 0x0004F8, "Wrong size on AGbxDestructibleActor");
static_assert(offsetof(AGbxDestructibleActor, FractureBuffer) == 0x000478, "Member 'AGbxDestructibleActor::FractureBuffer' has a wrong offset!");
static_assert(offsetof(AGbxDestructibleActor, TransformBuffer) == 0x000498, "Member 'AGbxDestructibleActor::TransformBuffer' has a wrong offset!");
static_assert(offsetof(AGbxDestructibleActor, SyncID) == 0x0004F0, "Member 'AGbxDestructibleActor::SyncID' has a wrong offset!");

// Class GbxDestruction.GbxUserDestructibleSyncManager
// 0x00A0 (0x04F8 - 0x0458)
class AGbxUserDestructibleSyncManager final : public AActor
{
public:
	uint8                                         Pad_458[0xA0];                                     // 0x0458(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUserDestructibleSyncManager">();
	}
	static class AGbxUserDestructibleSyncManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxUserDestructibleSyncManager>();
	}
};
static_assert(alignof(AGbxUserDestructibleSyncManager) == 0x000008, "Wrong alignment on AGbxUserDestructibleSyncManager");
static_assert(sizeof(AGbxUserDestructibleSyncManager) == 0x0004F8, "Wrong size on AGbxUserDestructibleSyncManager");

}

