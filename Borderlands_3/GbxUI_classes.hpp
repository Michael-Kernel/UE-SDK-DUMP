#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxUI

#include "Basic.hpp"

#include "GbxRuntime_classes.hpp"
#include "GbxUI_structs.hpp"
#include "ScaleformUI_structs.hpp"
#include "ScaleformUI_classes.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class GbxUI.GbxUserWidget
// 0x00B0 (0x02B8 - 0x0208)
class UGbxUserWidget : public UUserWidget
{
public:
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             LabelTextBlock;                                    // 0x0218(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ValueTextBlock;                                    // 0x0220(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectedImage;                                     // 0x0228(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterAsFocusableWidget;                        // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxFocusableWidgetMouseBehavior              MouseFocusBehavior;                                // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxFocusableWidgetStyleData*           FocusableWidgetStyleData;                          // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnFocusedAudioEventName;                           // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnClickedAudioEventName;                           // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverCreateMouseFocusButton;                      // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBUTTON*                                MouseFocusButton;                                  // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> OnWidgetClicked;                                   // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> OnWidgetFocused;                                   // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavUp;                              // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavDown;                            // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavLeft;                            // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavRight;                           // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocusOnMenuCreation;                              // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGbxUmgMenu>             MenuThatOwnsFocus;                                 // 0x02A4(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AudioDataTable;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool IsFocusableWidgetStateFocused(EGbxFocusableWidgetState State);
	static bool IsFocusableWidgetStateHovered(EGbxFocusableWidgetState State);

	void GetAllChildWidgetsOfClass(TSubclassOf<class UWidget> TargetClass, TArray<class UWidget*>& OutputArray);
	void GotoAndStop(const struct FFrameTime& StopTime, const class UWidgetAnimation* InAnimation);
	void HandleFocusableWidgetStateChanged(EGbxFocusableWidgetState NewState, bool bBecameFocused, bool bLostFocus);
	void OnFocusableWidgetClicked();
	void OnFocusableWidgetHovered();
	void OnFocusableWidgetPressed();
	void OnFocusableWidgetReleased();
	void OnFocusableWidgetUnhovered();
	void SetLabelText(const class FText& LabelText);

	bool IsRegisteredAsFocusableWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUserWidget">();
	}
	static class UGbxUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUserWidget>();
	}
};
static_assert(alignof(UGbxUserWidget) == 0x000008, "Wrong alignment on UGbxUserWidget");
static_assert(sizeof(UGbxUserWidget) == 0x0002B8, "Wrong size on UGbxUserWidget");
static_assert(offsetof(UGbxUserWidget, LabelTextBlock) == 0x000218, "Member 'UGbxUserWidget::LabelTextBlock' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, ValueTextBlock) == 0x000220, "Member 'UGbxUserWidget::ValueTextBlock' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, SelectedImage) == 0x000228, "Member 'UGbxUserWidget::SelectedImage' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, bRegisterAsFocusableWidget) == 0x000230, "Member 'UGbxUserWidget::bRegisterAsFocusableWidget' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, MouseFocusBehavior) == 0x000231, "Member 'UGbxUserWidget::MouseFocusBehavior' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, FocusableWidgetStyleData) == 0x000238, "Member 'UGbxUserWidget::FocusableWidgetStyleData' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, OnFocusedAudioEventName) == 0x000240, "Member 'UGbxUserWidget::OnFocusedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, OnClickedAudioEventName) == 0x000248, "Member 'UGbxUserWidget::OnClickedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, bNeverCreateMouseFocusButton) == 0x000250, "Member 'UGbxUserWidget::bNeverCreateMouseFocusButton' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, MouseFocusButton) == 0x000258, "Member 'UGbxUserWidget::MouseFocusButton' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, OnWidgetClicked) == 0x000260, "Member 'UGbxUserWidget::OnWidgetClicked' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, OnWidgetFocused) == 0x000270, "Member 'UGbxUserWidget::OnWidgetFocused' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, FocusableWidgetNavUp) == 0x000280, "Member 'UGbxUserWidget::FocusableWidgetNavUp' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, FocusableWidgetNavDown) == 0x000288, "Member 'UGbxUserWidget::FocusableWidgetNavDown' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, FocusableWidgetNavLeft) == 0x000290, "Member 'UGbxUserWidget::FocusableWidgetNavLeft' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, FocusableWidgetNavRight) == 0x000298, "Member 'UGbxUserWidget::FocusableWidgetNavRight' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, bFocusOnMenuCreation) == 0x0002A0, "Member 'UGbxUserWidget::bFocusOnMenuCreation' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, MenuThatOwnsFocus) == 0x0002A4, "Member 'UGbxUserWidget::MenuThatOwnsFocus' has a wrong offset!");
static_assert(offsetof(UGbxUserWidget, AudioDataTable) == 0x0002B0, "Member 'UGbxUserWidget::AudioDataTable' has a wrong offset!");

// Class GbxUI.GbxUmgMenu
// 0x0038 (0x02F0 - 0x02B8)
class UGbxUmgMenu : public UGbxUserWidget
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxUmgMenuData*                        MenuData;                                          // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   PCOwner;                                           // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxMenuStack*                          MenuStackOwner;                                    // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxWidgetFocusManager*                 FocusManager;                                      // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxHintBar*                            HintBar;                                           // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x5];                                      // 0x02E8(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxFocusableWidgetMouseBehavior              DefaultMouseFocusBehavior;                         // 0x02ED(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMenuActivate();
	void HandleMenuAspectRatioChanged(float NewAspectRatio);
	void HandleMenuDeactivate();
	void HandleMenuDeinit();
	void HandleMenuInit();
	void HandleMenuInputAction(const class FName& InputAction, int32 ControllerId);
	void HandleMenuInputDeviceChanged(EGbxMenuInputDevice NewInputDevice);
	void MenuStack_Clear();
	void MenuStack_Pop();
	void MenuStack_PopTo(const class UObject* Menu);
	class UObject* MenuStack_PopToSwitchTo(const class UObject* Menu, class UGbxMenuData* MenuDataIn);
	class UObject* MenuStack_Push(class UGbxMenuData* MenuDataIn);
	class UObject* MenuStack_SwitchTo(class UGbxMenuData* MenuDataIn);
	void NavigateBack();
	void PopulateHintBar();
	void RegisterFocusableWidget(class UObject* Widget, const struct FGbxFocusableWidgetAdjacencyInfo& AdjacencyInfo);
	void RegisterFocusableWidgetWithAdjacency(class UObject* Widget, class UObject* AdjacentUp, class UObject* AdjacentDown, class UObject* AdjacentLeft, class UObject* AdjacentRight);
	void RegisterStagePlacedHint(const TScriptInterface<class IGbxHintWidget>& InHintWidget, const class FName InInputAction);
	void SetFocusableWidgetAdjancency(class UObject* Widget, class UObject* AdjacentUp, class UObject* AdjacentDown, class UObject* AdjacentLeft, class UObject* AdjacentRight);
	void SetFocusedWidget(class UObject* Widget, bool bFromMouse);
	void SetHintBarContainer(const TScriptInterface<class IGbxHintBarWidgetContainer>& InContainer);
	void SetSlateFocusedWidget(class UWidget* Widget);
	void SetWidgetAdjacency(class UObject* Widget, const struct FGbxFocusableWidgetAdjacencyInfo& AdjacencyInfo);

	EGbxMenuInputDevice GetCurrentInputDevice() const;
	class UObject* GetFocusedWidget() const;
	class UGbxListItemFactory* GetListItemFactory() const;
	bool IsActiveMenuOnStack() const;
	bool IsWidgetFocused(const class UObject* WidgetInQuestion) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUmgMenu">();
	}
	static class UGbxUmgMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUmgMenu>();
	}
};
static_assert(alignof(UGbxUmgMenu) == 0x000008, "Wrong alignment on UGbxUmgMenu");
static_assert(sizeof(UGbxUmgMenu) == 0x0002F0, "Wrong size on UGbxUmgMenu");
static_assert(offsetof(UGbxUmgMenu, MenuData) == 0x0002C0, "Member 'UGbxUmgMenu::MenuData' has a wrong offset!");
static_assert(offsetof(UGbxUmgMenu, PCOwner) == 0x0002C8, "Member 'UGbxUmgMenu::PCOwner' has a wrong offset!");
static_assert(offsetof(UGbxUmgMenu, MenuStackOwner) == 0x0002D0, "Member 'UGbxUmgMenu::MenuStackOwner' has a wrong offset!");
static_assert(offsetof(UGbxUmgMenu, FocusManager) == 0x0002D8, "Member 'UGbxUmgMenu::FocusManager' has a wrong offset!");
static_assert(offsetof(UGbxUmgMenu, HintBar) == 0x0002E0, "Member 'UGbxUmgMenu::HintBar' has a wrong offset!");
static_assert(offsetof(UGbxUmgMenu, DefaultMouseFocusBehavior) == 0x0002ED, "Member 'UGbxUmgMenu::DefaultMouseFocusBehavior' has a wrong offset!");

// Class GbxUI.GbxGFxObject
// 0x0138 (0x0170 - 0x0038)
class UGbxGFxObject : public UGFxObject
{
public:
	class UGbxGFxMovie*                           OwningMovie;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x130];                                     // 0x0040(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RotateAboutPoint(const float Degrees, const struct FVector2D& Point);
	void SetBaseDisplayTransform(const struct FTransform& Transform);
	void SetOffsetDisplayTransform(const struct FTransform& Transform);

	struct FTransform GetBaseDisplayTransform() const;
	struct FTransform GetOffsetDisplayTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxObject">();
	}
	static class UGbxGFxObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxObject>();
	}
};
static_assert(alignof(UGbxGFxObject) == 0x000008, "Wrong alignment on UGbxGFxObject");
static_assert(sizeof(UGbxGFxObject) == 0x000170, "Wrong size on UGbxGFxObject");
static_assert(offsetof(UGbxGFxObject, OwningMovie) == 0x000038, "Member 'UGbxGFxObject::OwningMovie' has a wrong offset!");

// Class GbxUI.GbxGFxGridScrollingList
// 0x01B0 (0x0320 - 0x0170)
class UGbxGFxGridScrollingList : public UGbxGFxObject
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   SelectionChangedDelegate;                          // 0x0180(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ItemPressedDelegate;                               // 0x0190(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   ItemClickedDelegate;                               // 0x01A8(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ItemSecondaryClickedDelegate;                      // 0x01B8(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x18];                                     // 0x01C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxGFxListConfig                      Config;                                            // 0x01E0(0x0090)(Transient, NativeAccessSpecifierPublic)
	int32                                         SelectedIndex;                                     // 0x0270(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedIndexWhenFocusWasLost;                     // 0x0274(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxScrollingListCellInfo>      AllCells;                                          // 0x0278(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FGbxScrollingListCellInfo>      UnusedCellPool;                                    // 0x0288(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          GridArea;                                          // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          GridMask;                                          // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PositionOfFirstItem;                               // 0x02A8(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextUniqueId;                                      // 0x02B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewWindowSize;                                    // 0x02B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxUIScroller                         UiScroller;                                        // 0x02B8(0x0034)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsContentDirty;                                   // 0x02EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AverageItemDims;                                   // 0x02F0(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxSlider*                          ScrollBar;                                         // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScrollbarIsChildOfThis;                           // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x1F];                                     // 0x0301(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollBarPositionUpdated(float SliderPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxGridScrollingList">();
	}
	static class UGbxGFxGridScrollingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxGridScrollingList>();
	}
};
static_assert(alignof(UGbxGFxGridScrollingList) == 0x000008, "Wrong alignment on UGbxGFxGridScrollingList");
static_assert(sizeof(UGbxGFxGridScrollingList) == 0x000320, "Wrong size on UGbxGFxGridScrollingList");
static_assert(offsetof(UGbxGFxGridScrollingList, SelectionChangedDelegate) == 0x000180, "Member 'UGbxGFxGridScrollingList::SelectionChangedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, ItemPressedDelegate) == 0x000190, "Member 'UGbxGFxGridScrollingList::ItemPressedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, ItemClickedDelegate) == 0x0001A8, "Member 'UGbxGFxGridScrollingList::ItemClickedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, ItemSecondaryClickedDelegate) == 0x0001B8, "Member 'UGbxGFxGridScrollingList::ItemSecondaryClickedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, Config) == 0x0001E0, "Member 'UGbxGFxGridScrollingList::Config' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, SelectedIndex) == 0x000270, "Member 'UGbxGFxGridScrollingList::SelectedIndex' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, SelectedIndexWhenFocusWasLost) == 0x000274, "Member 'UGbxGFxGridScrollingList::SelectedIndexWhenFocusWasLost' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, AllCells) == 0x000278, "Member 'UGbxGFxGridScrollingList::AllCells' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, UnusedCellPool) == 0x000288, "Member 'UGbxGFxGridScrollingList::UnusedCellPool' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, GridArea) == 0x000298, "Member 'UGbxGFxGridScrollingList::GridArea' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, GridMask) == 0x0002A0, "Member 'UGbxGFxGridScrollingList::GridMask' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, PositionOfFirstItem) == 0x0002A8, "Member 'UGbxGFxGridScrollingList::PositionOfFirstItem' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, NextUniqueId) == 0x0002B0, "Member 'UGbxGFxGridScrollingList::NextUniqueId' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, ViewWindowSize) == 0x0002B4, "Member 'UGbxGFxGridScrollingList::ViewWindowSize' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, UiScroller) == 0x0002B8, "Member 'UGbxGFxGridScrollingList::UiScroller' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, bIsContentDirty) == 0x0002EC, "Member 'UGbxGFxGridScrollingList::bIsContentDirty' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, AverageItemDims) == 0x0002F0, "Member 'UGbxGFxGridScrollingList::AverageItemDims' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, ScrollBar) == 0x0002F8, "Member 'UGbxGFxGridScrollingList::ScrollBar' has a wrong offset!");
static_assert(offsetof(UGbxGFxGridScrollingList, bScrollbarIsChildOfThis) == 0x000300, "Member 'UGbxGFxGridScrollingList::bScrollbarIsChildOfThis' has a wrong offset!");

// Class GbxUI.GbxGFxHintBarContainer
// 0x0020 (0x0340 - 0x0320)
class UGbxGFxHintBarContainer final : public UGbxGFxGridScrollingList
{
public:
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGbxHintBar>             HintBarOwningBar;                                  // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGbxPlayerController>    HintBarOwnerPC;                                    // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxHintBarContainer">();
	}
	static class UGbxGFxHintBarContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxHintBarContainer>();
	}
};
static_assert(alignof(UGbxGFxHintBarContainer) == 0x000008, "Wrong alignment on UGbxGFxHintBarContainer");
static_assert(sizeof(UGbxGFxHintBarContainer) == 0x000340, "Wrong size on UGbxGFxHintBarContainer");
static_assert(offsetof(UGbxGFxHintBarContainer, HintBarOwningBar) == 0x000328, "Member 'UGbxGFxHintBarContainer::HintBarOwningBar' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintBarContainer, HintBarOwnerPC) == 0x000330, "Member 'UGbxGFxHintBarContainer::HintBarOwnerPC' has a wrong offset!");

// Class GbxUI.GbxGFxMovie
// 0x02C8 (0x04D8 - 0x0210)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxMovie : public UGFxMoviePlayer
{
public:
	class USwfMovie*                              MovieData;                                         // 0x0210(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxScaleMode                                 ScaleModeType;                                     // 0x0218(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGFxAlign                                     AlignmentType;                                     // 0x0219(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnchorToViewport;                                 // 0x021A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B[0x1];                                      // 0x021B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxGFxAnchor                          AnchorData;                                        // 0x021C(0x0018)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0xC];                                      // 0x0234(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AudioDataTable;                                    // 0x0240(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxGFxMovieClipAppendix               GetChildAppendix;                                  // 0x0248(0x0060)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGbxGFxMovieGetChildStrategy                  GetChildStrategy;                                  // 0x02A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          CachedStage;                                       // 0x02B0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          GbxRoot;                                           // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          GetChildRoot;                                      // 0x02C0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CachedGbxRootPosition;                             // 0x02C8(0x0008)(BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTransitioning;                                  // 0x02E8(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTimeout;                                 // 0x02EC(0x0004)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x140];                                    // 0x02F0(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxPlayerController*                   OwningGPC;                                         // 0x0430(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x68];                                     // 0x0438(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxGFxObject*>                  Tickables;                                         // 0x04A0(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x11];                                     // 0x04B0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGbxMovieStarted;                                  // 0x04C1(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C2[0x16];                                     // 0x04C2(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const class UGbxGFxMovie* SpawnGbxGFxMovie(class AGbxPlayerController* GbxPlayerController, TSubclassOf<class UGbxGFxMovie> MovieClass);

	void ApplyNewAudioSettings(class UDataTable* NewDataTable, EUIAudioSettingOperation MergeOperation) const;
	void ExtAnimationFinished(const class FString& TargetName) const;
	void ExtTransitionComplete() const;
	struct FTransform GetBaseDisplayTransform() const;
	struct FVector2D GetMovieDimensions() const;
	struct FTransform GetOffsetDisplayTransform() const;
	class AGbxPlayerController* GetOwningPlayerController() const;
	class APawn* GetOwningPlayerPawn() const;
	struct FVector2D GetStageDimensions() const;
	struct FVector2D GetViewportDimensions() const;
	struct FVector2D GetViewportOffset() const;
	bool RunUIEventAudio(class FName EventName, const class FString& ProviderHistory) const;
	void SetAnchor(const struct FGbxGFxAnchor& Anchor) const;
	void SetAudioEnabled(bool bEnabled) const;
	void SetBaseDisplayTransform(const struct FTransform& Transform) const;
	void SetOffsetDisplayTransform(const struct FTransform& Transform) const;
	void SetViewportToPlayerScreen(class AGbxPlayerController* Pc) const;
	void SpawnMovie(class AGbxPlayerController* NewGPCOwner, class UTextureRenderTarget2D* RenderTarget) const;
	struct FBox2D TranslateRectToScreen(const struct FBox2D& Rect) const;
	struct FVector2D TranslateScreenToLocal(const struct FVector2D& Point, bool bUseMovieDimensions) const;
	struct FVector2D TranslateToScreen(const struct FVector2D& Point) const;
	bool TranslateWorldToLocal(const struct FVector& LocationWorldSpace, struct FVector2D* OutPositionLocal, bool bPlayerViewportRelative, bool bUseMovieDimensions) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMovie">();
	}
	static class UGbxGFxMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMovie>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxMovie) == 0x000008, "Wrong alignment on UGbxGFxMovie");
static_assert(sizeof(UGbxGFxMovie) == 0x0004D8, "Wrong size on UGbxGFxMovie");
static_assert(offsetof(UGbxGFxMovie, MovieData) == 0x000210, "Member 'UGbxGFxMovie::MovieData' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, ScaleModeType) == 0x000218, "Member 'UGbxGFxMovie::ScaleModeType' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, AlignmentType) == 0x000219, "Member 'UGbxGFxMovie::AlignmentType' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, bAnchorToViewport) == 0x00021A, "Member 'UGbxGFxMovie::bAnchorToViewport' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, AnchorData) == 0x00021C, "Member 'UGbxGFxMovie::AnchorData' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, AudioDataTable) == 0x000240, "Member 'UGbxGFxMovie::AudioDataTable' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, GetChildAppendix) == 0x000248, "Member 'UGbxGFxMovie::GetChildAppendix' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, GetChildStrategy) == 0x0002A8, "Member 'UGbxGFxMovie::GetChildStrategy' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, CachedStage) == 0x0002B0, "Member 'UGbxGFxMovie::CachedStage' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, GbxRoot) == 0x0002B8, "Member 'UGbxGFxMovie::GbxRoot' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, GetChildRoot) == 0x0002C0, "Member 'UGbxGFxMovie::GetChildRoot' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, CachedGbxRootPosition) == 0x0002C8, "Member 'UGbxGFxMovie::CachedGbxRootPosition' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, bIsTransitioning) == 0x0002E8, "Member 'UGbxGFxMovie::bIsTransitioning' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, TransitionTimeout) == 0x0002EC, "Member 'UGbxGFxMovie::TransitionTimeout' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, OwningGPC) == 0x000430, "Member 'UGbxGFxMovie::OwningGPC' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, Tickables) == 0x0004A0, "Member 'UGbxGFxMovie::Tickables' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovie, bGbxMovieStarted) == 0x0004C1, "Member 'UGbxGFxMovie::bGbxMovieStarted' has a wrong offset!");

// Class GbxUI.GbxGFxComboBoxScrollingList
// 0x0010 (0x0330 - 0x0320)
class UGbxGFxComboBoxScrollingList final : public UGbxGFxGridScrollingList
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxComboBoxScrollingList">();
	}
	static class UGbxGFxComboBoxScrollingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxComboBoxScrollingList>();
	}
};
static_assert(alignof(UGbxGFxComboBoxScrollingList) == 0x000008, "Wrong alignment on UGbxGFxComboBoxScrollingList");
static_assert(sizeof(UGbxGFxComboBoxScrollingList) == 0x000330, "Wrong size on UGbxGFxComboBoxScrollingList");

// Class GbxUI.GbxGFxMenu
// 0x01A8 (0x0680 - 0x04D8)
class UGbxGFxMenu : public UGbxGFxMovie
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxFocusableWidgetMouseBehavior              DefaultMouseFocusBehavior;                         // 0x04E0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxMenuData*                        MenuData;                                          // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonFocusedAudioEventName;                       // 0x04F0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonClickedAudioEventName;                       // 0x0500(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SliderAudioEventName;                              // 0x0510(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpinnerAudioEventName;                             // 0x0520(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NavigateBackAudioEventName;                        // 0x0530(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenMenuAudioEventName;                            // 0x0540(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloseMenuAudioEventName;                           // 0x0548(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMenuTransitionOutCompleted;                      // 0x0550(0x0010)(BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMenuInputChanged;                                // 0x0560(0x0010)(BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGbxGFxListAlignment                          HintBarAlignment;                                  // 0x0570(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCallMenuTickOnlyIfMenuIsStarted;                  // 0x0571(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplitscreenRootOffset;                             // 0x0574(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxContextualMenu*                  OwnedContextualMenu;                               // 0x0578(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxMenu*                            ActiveDialog;                                      // 0x0580(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_588[0x4];                                      // 0x0588(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGbxPlayerController>    PCOwner;                                           // 0x058C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGbxCharacter>           PrimaryCharacterOwner;                             // 0x0594(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGbxMenuStack>           MenuStackOwner;                                    // 0x059C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DrawPriority;                                      // 0x05A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxWidgetFocusManager*                 FocusManager;                                      // 0x05A8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxHintBar*                            HintBar;                                           // 0x05B0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxHintBarContainer*                HintBarContainer;                                  // 0x05B8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxMouseBlocker*                    MouseBlockerClip;                                  // 0x05C0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsDismiss;                                     // 0x05C8(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C9[0x3];                                      // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGbxGameInstance>        GameInstanceRef;                                   // 0x05CC(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGbxUIGlobals>           UIGlobalsRef;                                      // 0x05D4(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x2];                                      // 0x05DC(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCachedLastInputFromMouse;                         // 0x05DE(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReceiveMouseEvenIfNotActive;                      // 0x05DF(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInitedFromStash;                                // 0x05E0(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMouseHitsAllowedYet;                              // 0x05E1(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGotFirstMouseMove;                                // 0x05E2(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E3[0xD];                                      // 0x05E3(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          MenuContentClip;                                   // 0x05F0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          MenuLayoutsClip;                                   // 0x05F8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          MenuLayoutClip;                                    // 0x0600(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSplitScreenLayout;                              // 0x0608(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_609[0x17];                                     // 0x0609(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlockPauseMenu;                                   // 0x0620(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGFxMenuWasStarted;                                // 0x0621(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_622[0x6];                                      // 0x0622(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxButton*                          LastFocusedButton;                                 // 0x0628(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x50];                                     // 0x0630(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UObject* GetFocusedWidget() const;
	bool IsWidgetFocused(const class UObject* WidgetInQuestion) const;
	void MenuStack_Clear() const;
	void RegisterFocusableWidget(TScriptInterface<class IGbxFocusableWidget> Widget, const struct FGbxFocusableWidgetAdjacencyInfo& AdjacencyInfo) const;
	void RegisterFocusableWidgetWithAdjacency(TScriptInterface<class IGbxFocusableWidget> Widget, class UObject* AdjacentUp, class UObject* AdjacentDown, class UObject* AdjacentLeft, class UObject* AdjacentRight) const;
	void SetFocusableWidgetAdjancency(TScriptInterface<class IGbxFocusableWidget> Widget, class UObject* AdjacentUp, class UObject* AdjacentDown, class UObject* AdjacentLeft, class UObject* AdjacentRight) const;
	void SetFocusedWidget(TScriptInterface<class IGbxFocusableWidget> WidgetToFocus, bool bFromMouse) const;
	void SetWidgetAdjacency(TScriptInterface<class IGbxFocusableWidget> Widget, const struct FGbxFocusableWidgetAdjacencyInfo& AdjacencyInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenu">();
	}
	static class UGbxGFxMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenu>();
	}
};
static_assert(alignof(UGbxGFxMenu) == 0x000008, "Wrong alignment on UGbxGFxMenu");
static_assert(sizeof(UGbxGFxMenu) == 0x000680, "Wrong size on UGbxGFxMenu");
static_assert(offsetof(UGbxGFxMenu, DefaultMouseFocusBehavior) == 0x0004E0, "Member 'UGbxGFxMenu::DefaultMouseFocusBehavior' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, MenuData) == 0x0004E8, "Member 'UGbxGFxMenu::MenuData' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, ButtonFocusedAudioEventName) == 0x0004F0, "Member 'UGbxGFxMenu::ButtonFocusedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, ButtonClickedAudioEventName) == 0x000500, "Member 'UGbxGFxMenu::ButtonClickedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, SliderAudioEventName) == 0x000510, "Member 'UGbxGFxMenu::SliderAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, SpinnerAudioEventName) == 0x000520, "Member 'UGbxGFxMenu::SpinnerAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, NavigateBackAudioEventName) == 0x000530, "Member 'UGbxGFxMenu::NavigateBackAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, OpenMenuAudioEventName) == 0x000540, "Member 'UGbxGFxMenu::OpenMenuAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, CloseMenuAudioEventName) == 0x000548, "Member 'UGbxGFxMenu::CloseMenuAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, OnMenuTransitionOutCompleted) == 0x000550, "Member 'UGbxGFxMenu::OnMenuTransitionOutCompleted' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, OnMenuInputChanged) == 0x000560, "Member 'UGbxGFxMenu::OnMenuInputChanged' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, HintBarAlignment) == 0x000570, "Member 'UGbxGFxMenu::HintBarAlignment' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bCallMenuTickOnlyIfMenuIsStarted) == 0x000571, "Member 'UGbxGFxMenu::bCallMenuTickOnlyIfMenuIsStarted' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, SplitscreenRootOffset) == 0x000574, "Member 'UGbxGFxMenu::SplitscreenRootOffset' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, OwnedContextualMenu) == 0x000578, "Member 'UGbxGFxMenu::OwnedContextualMenu' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, ActiveDialog) == 0x000580, "Member 'UGbxGFxMenu::ActiveDialog' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, PCOwner) == 0x00058C, "Member 'UGbxGFxMenu::PCOwner' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, PrimaryCharacterOwner) == 0x000594, "Member 'UGbxGFxMenu::PrimaryCharacterOwner' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, MenuStackOwner) == 0x00059C, "Member 'UGbxGFxMenu::MenuStackOwner' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, DrawPriority) == 0x0005A4, "Member 'UGbxGFxMenu::DrawPriority' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, FocusManager) == 0x0005A8, "Member 'UGbxGFxMenu::FocusManager' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, HintBar) == 0x0005B0, "Member 'UGbxGFxMenu::HintBar' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, HintBarContainer) == 0x0005B8, "Member 'UGbxGFxMenu::HintBarContainer' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, MouseBlockerClip) == 0x0005C0, "Member 'UGbxGFxMenu::MouseBlockerClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bWantsDismiss) == 0x0005C8, "Member 'UGbxGFxMenu::bWantsDismiss' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, GameInstanceRef) == 0x0005CC, "Member 'UGbxGFxMenu::GameInstanceRef' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, UIGlobalsRef) == 0x0005D4, "Member 'UGbxGFxMenu::UIGlobalsRef' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bCachedLastInputFromMouse) == 0x0005DE, "Member 'UGbxGFxMenu::bCachedLastInputFromMouse' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bReceiveMouseEvenIfNotActive) == 0x0005DF, "Member 'UGbxGFxMenu::bReceiveMouseEvenIfNotActive' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bIsInitedFromStash) == 0x0005E0, "Member 'UGbxGFxMenu::bIsInitedFromStash' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bMouseHitsAllowedYet) == 0x0005E1, "Member 'UGbxGFxMenu::bMouseHitsAllowedYet' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bGotFirstMouseMove) == 0x0005E2, "Member 'UGbxGFxMenu::bGotFirstMouseMove' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, MenuContentClip) == 0x0005F0, "Member 'UGbxGFxMenu::MenuContentClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, MenuLayoutsClip) == 0x0005F8, "Member 'UGbxGFxMenu::MenuLayoutsClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, MenuLayoutClip) == 0x000600, "Member 'UGbxGFxMenu::MenuLayoutClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bIsSplitScreenLayout) == 0x000608, "Member 'UGbxGFxMenu::bIsSplitScreenLayout' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bBlockPauseMenu) == 0x000620, "Member 'UGbxGFxMenu::bBlockPauseMenu' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, bGFxMenuWasStarted) == 0x000621, "Member 'UGbxGFxMenu::bGFxMenuWasStarted' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenu, LastFocusedButton) == 0x000628, "Member 'UGbxGFxMenu::LastFocusedButton' has a wrong offset!");

// Class GbxUI.GbxCoreDialogBoxHelpers
// 0x0000 (0x0028 - 0x0028)
class UGbxCoreDialogBoxHelpers final : public UBlueprintFunctionLibrary
{
public:
	static class UGbxDialogBox* ShowBlockingDialog(class AGbxPlayerController* Pc, const class FText& HeaderText, const class FText& MessageText, bool bBlocksAllUsers);
	static class UGbxDialogBox* ShowConfirmCancelDialog(class AGbxPlayerController* Pc, const class FText& HeaderText, const class FText& MessageText, bool bAnyUserCanInteract);
	static class UGbxDialogBox* ShowDialog(class AGbxPlayerController* Pc, const struct FGbxDialogBoxInfo& DialogBoxInfo);
	static class UGbxDialogBox* ShowOkayDialog(class AGbxPlayerController* Pc, const class FText& HeaderText, const class FText& MessageText, bool bAnyUserCanInteract, EGbxDialogBoxHelpersDialogTemplate Template);
	static class UGbxDialogBox* ShowYesNoDialog(class AGbxPlayerController* Pc, const class FText& HeaderText, const class FText& MessageText, bool bAnyUserCanInteract);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCoreDialogBoxHelpers">();
	}
	static class UGbxCoreDialogBoxHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCoreDialogBoxHelpers>();
	}
};
static_assert(alignof(UGbxCoreDialogBoxHelpers) == 0x000008, "Wrong alignment on UGbxCoreDialogBoxHelpers");
static_assert(sizeof(UGbxCoreDialogBoxHelpers) == 0x000028, "Wrong size on UGbxCoreDialogBoxHelpers");

// Class GbxUI.GbxGFxHUDWidget
// 0x0158 (0x0630 - 0x04D8)
class UGbxGFxHUDWidget : public UGbxGFxMovie
{
public:
	uint8                                         Pad_4D8[0x68];                                     // 0x04D8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	EGFxHUDWidgetAnchorType                       AnchorType;                                        // 0x0540(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LayoutInstanceStringOverride;                      // 0x0548(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnchorBoneName;                                    // 0x0558(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxContextSensitivePromptTime;                     // 0x0560(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeUntilStopAdvancing;                         // 0x0564(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShowFrameName;                                     // 0x0570(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HideFrameName;                                     // 0x0580(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OnFrameName;                                       // 0x0590(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OffFrameName;                                      // 0x05A0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxHintWidget*                      ContextSensitivePrompt;                            // 0x05B0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InstanceString;                                    // 0x05B8(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGbxHUD>                 OwningHUD;                                         // 0x05C8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UGbxGFxHUDContainer>     OwningHUDContainer;                                // 0x05D0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGbxPlayerController>    OwningPC;                                          // 0x05D8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class APawn>                   OwningPawn;                                        // 0x05E0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          IconTransitionWrapper;                             // 0x05E8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          InitializationClip;                                // 0x05F0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x14];                                     // 0x05F8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGameInstance>           GameInstanceRef;                                   // 0x060C(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UGbxUIGlobals>           UIGlobalsRef;                                      // 0x0614(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61C[0x8];                                      // 0x061C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDynamicallyLoaded : 1;                            // 0x0624(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_625[0xB];                                      // 0x0625(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExtHideAnimationFinished() const;
	void ExtInitAnimationFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxHUDWidget">();
	}
	static class UGbxGFxHUDWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxHUDWidget>();
	}
};
static_assert(alignof(UGbxGFxHUDWidget) == 0x000008, "Wrong alignment on UGbxGFxHUDWidget");
static_assert(sizeof(UGbxGFxHUDWidget) == 0x000630, "Wrong size on UGbxGFxHUDWidget");
static_assert(offsetof(UGbxGFxHUDWidget, AnchorType) == 0x000540, "Member 'UGbxGFxHUDWidget::AnchorType' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, LayoutInstanceStringOverride) == 0x000548, "Member 'UGbxGFxHUDWidget::LayoutInstanceStringOverride' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, AnchorBoneName) == 0x000558, "Member 'UGbxGFxHUDWidget::AnchorBoneName' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, MaxContextSensitivePromptTime) == 0x000560, "Member 'UGbxGFxHUDWidget::MaxContextSensitivePromptTime' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, MaxTimeUntilStopAdvancing) == 0x000564, "Member 'UGbxGFxHUDWidget::MaxTimeUntilStopAdvancing' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, ShowFrameName) == 0x000570, "Member 'UGbxGFxHUDWidget::ShowFrameName' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, HideFrameName) == 0x000580, "Member 'UGbxGFxHUDWidget::HideFrameName' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, OnFrameName) == 0x000590, "Member 'UGbxGFxHUDWidget::OnFrameName' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, OffFrameName) == 0x0005A0, "Member 'UGbxGFxHUDWidget::OffFrameName' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, ContextSensitivePrompt) == 0x0005B0, "Member 'UGbxGFxHUDWidget::ContextSensitivePrompt' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, InstanceString) == 0x0005B8, "Member 'UGbxGFxHUDWidget::InstanceString' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, OwningHUD) == 0x0005C8, "Member 'UGbxGFxHUDWidget::OwningHUD' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, OwningHUDContainer) == 0x0005D0, "Member 'UGbxGFxHUDWidget::OwningHUDContainer' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, OwningPC) == 0x0005D8, "Member 'UGbxGFxHUDWidget::OwningPC' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, OwningPawn) == 0x0005E0, "Member 'UGbxGFxHUDWidget::OwningPawn' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, IconTransitionWrapper) == 0x0005E8, "Member 'UGbxGFxHUDWidget::IconTransitionWrapper' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, InitializationClip) == 0x0005F0, "Member 'UGbxGFxHUDWidget::InitializationClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, GameInstanceRef) == 0x00060C, "Member 'UGbxGFxHUDWidget::GameInstanceRef' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDWidget, UIGlobalsRef) == 0x000614, "Member 'UGbxGFxHUDWidget::UIGlobalsRef' has a wrong offset!");

// Class GbxUI.GbxMenuData
// 0x0018 (0x0048 - 0x0030)
class UGbxMenuData : public UGbxDataAsset
{
public:
	bool                                          bHideMenusBeneath;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowsMouse;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxMenuInputMode                             InputMode;                                         // 0x0032(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxMenuParentType                            ParentType;                                        // 0x0033(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAttemptPop;                                   // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMenuStashing;                                  // 0x0035(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateIfPoppedTo;                               // 0x0036(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UDialogEvent*                           IdleDialogEvent;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogParameter*                       IdleDialogTargetParamater;                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuData">();
	}
	static class UGbxMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuData>();
	}
};
static_assert(alignof(UGbxMenuData) == 0x000008, "Wrong alignment on UGbxMenuData");
static_assert(sizeof(UGbxMenuData) == 0x000048, "Wrong size on UGbxMenuData");
static_assert(offsetof(UGbxMenuData, bHideMenusBeneath) == 0x000030, "Member 'UGbxMenuData::bHideMenusBeneath' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, bShowsMouse) == 0x000031, "Member 'UGbxMenuData::bShowsMouse' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, InputMode) == 0x000032, "Member 'UGbxMenuData::InputMode' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, ParentType) == 0x000033, "Member 'UGbxMenuData::ParentType' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, bAutoAttemptPop) == 0x000034, "Member 'UGbxMenuData::bAutoAttemptPop' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, bUseMenuStashing) == 0x000035, "Member 'UGbxMenuData::bUseMenuStashing' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, bActivateIfPoppedTo) == 0x000036, "Member 'UGbxMenuData::bActivateIfPoppedTo' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, IdleDialogEvent) == 0x000038, "Member 'UGbxMenuData::IdleDialogEvent' has a wrong offset!");
static_assert(offsetof(UGbxMenuData, IdleDialogTargetParamater) == 0x000040, "Member 'UGbxMenuData::IdleDialogTargetParamater' has a wrong offset!");

// Class GbxUI.GbxCrosshairDataAsset
// 0x0020 (0x0050 - 0x0030)
class UGbxCrosshairDataAsset final : public UGbxDataAsset
{
public:
	class FString                                 CrosshairFrameName;                                // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     CrosshairActorClass;                               // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideMinSpreadReticle;                             // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAccuracyReticle;                              // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChargeClipState                              ChargeClipState;                                   // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCrosshairDataAsset">();
	}
	static class UGbxCrosshairDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCrosshairDataAsset>();
	}
};
static_assert(alignof(UGbxCrosshairDataAsset) == 0x000008, "Wrong alignment on UGbxCrosshairDataAsset");
static_assert(sizeof(UGbxCrosshairDataAsset) == 0x000050, "Wrong size on UGbxCrosshairDataAsset");
static_assert(offsetof(UGbxCrosshairDataAsset, CrosshairFrameName) == 0x000030, "Member 'UGbxCrosshairDataAsset::CrosshairFrameName' has a wrong offset!");
static_assert(offsetof(UGbxCrosshairDataAsset, CrosshairActorClass) == 0x000040, "Member 'UGbxCrosshairDataAsset::CrosshairActorClass' has a wrong offset!");
static_assert(offsetof(UGbxCrosshairDataAsset, bHideMinSpreadReticle) == 0x000048, "Member 'UGbxCrosshairDataAsset::bHideMinSpreadReticle' has a wrong offset!");
static_assert(offsetof(UGbxCrosshairDataAsset, bHideAccuracyReticle) == 0x000049, "Member 'UGbxCrosshairDataAsset::bHideAccuracyReticle' has a wrong offset!");
static_assert(offsetof(UGbxCrosshairDataAsset, ChargeClipState) == 0x00004A, "Member 'UGbxCrosshairDataAsset::ChargeClipState' has a wrong offset!");

// Class GbxUI.GbxHUDContainer
// 0x0028 (0x02E0 - 0x02B8)
class UGbxHUDContainer : public UGbxUserWidget
{
public:
	class UCanvasPanel*                           RootPanel;                                         // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   OwningPlayerController;                            // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxHUD*                                OwningHUD;                                         // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectedContainerZOrder;                          // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           DebugPanel;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleActivate();
	void HandleDeactivate();
	void HandleDeinit();
	void HandleInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHUDContainer">();
	}
	static class UGbxHUDContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxHUDContainer>();
	}
};
static_assert(alignof(UGbxHUDContainer) == 0x000008, "Wrong alignment on UGbxHUDContainer");
static_assert(sizeof(UGbxHUDContainer) == 0x0002E0, "Wrong size on UGbxHUDContainer");
static_assert(offsetof(UGbxHUDContainer, RootPanel) == 0x0002B8, "Member 'UGbxHUDContainer::RootPanel' has a wrong offset!");
static_assert(offsetof(UGbxHUDContainer, OwningPlayerController) == 0x0002C0, "Member 'UGbxHUDContainer::OwningPlayerController' has a wrong offset!");
static_assert(offsetof(UGbxHUDContainer, OwningHUD) == 0x0002C8, "Member 'UGbxHUDContainer::OwningHUD' has a wrong offset!");
static_assert(offsetof(UGbxHUDContainer, ProjectedContainerZOrder) == 0x0002D0, "Member 'UGbxHUDContainer::ProjectedContainerZOrder' has a wrong offset!");
static_assert(offsetof(UGbxHUDContainer, DebugPanel) == 0x0002D8, "Member 'UGbxHUDContainer::DebugPanel' has a wrong offset!");

// Class GbxUI.GbxMenuSwitcherSubmenu
// 0x0008 (0x02F8 - 0x02F0)
class UGbxMenuSwitcherSubmenu : public UGbxUmgMenu
{
public:
	TWeakObjectPtr<class UGbxMenuSwitcher>        OwnerMenuSwitcher;                                 // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuSwitcherSubmenu">();
	}
	static class UGbxMenuSwitcherSubmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuSwitcherSubmenu>();
	}
};
static_assert(alignof(UGbxMenuSwitcherSubmenu) == 0x000008, "Wrong alignment on UGbxMenuSwitcherSubmenu");
static_assert(sizeof(UGbxMenuSwitcherSubmenu) == 0x0002F8, "Wrong size on UGbxMenuSwitcherSubmenu");
static_assert(offsetof(UGbxMenuSwitcherSubmenu, OwnerMenuSwitcher) == 0x0002F0, "Member 'UGbxMenuSwitcherSubmenu::OwnerMenuSwitcher' has a wrong offset!");

// Class GbxUI.GbxListItem
// 0x0030 (0x02E8 - 0x02B8)
class UGbxListItem : public UGbxUserWidget
{
public:
	TDelegate<void(class UGbxListItem* Item)>     OnListItemValueChanged;                            // 0x02B8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TScriptInterface<class IGbxList>              ListOwner;                                         // 0x02C8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   ChangedAudioEventName;                             // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetItemIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxListItem">();
	}
	static class UGbxListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxListItem>();
	}
};
static_assert(alignof(UGbxListItem) == 0x000008, "Wrong alignment on UGbxListItem");
static_assert(sizeof(UGbxListItem) == 0x0002E8, "Wrong size on UGbxListItem");
static_assert(offsetof(UGbxListItem, OnListItemValueChanged) == 0x0002B8, "Member 'UGbxListItem::OnListItemValueChanged' has a wrong offset!");
static_assert(offsetof(UGbxListItem, ListOwner) == 0x0002C8, "Member 'UGbxListItem::ListOwner' has a wrong offset!");
static_assert(offsetof(UGbxListItem, ChangedAudioEventName) == 0x0002D8, "Member 'UGbxListItem::ChangedAudioEventName' has a wrong offset!");

// Class GbxUI.GbxDebugMenuSubmenu
// 0x0000 (0x02F8 - 0x02F8)
class UGbxDebugMenuSubmenu : public UGbxMenuSwitcherSubmenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDebugMenuSubmenu">();
	}
	static class UGbxDebugMenuSubmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDebugMenuSubmenu>();
	}
};
static_assert(alignof(UGbxDebugMenuSubmenu) == 0x000008, "Wrong alignment on UGbxDebugMenuSubmenu");
static_assert(sizeof(UGbxDebugMenuSubmenu) == 0x0002F8, "Wrong size on UGbxDebugMenuSubmenu");

// Class GbxUI.GbxGFxMenuData
// 0x0078 (0x00C0 - 0x0048)
class UGbxGFxMenuData : public UGbxMenuData
{
public:
	TSoftClassPtr<class UClass>                   MovieClass;                                        // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransitionMovieClipTarget;                         // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransitionOutAnimation;                            // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionOutTimeout;                              // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxHUDStateData*                       OverrideHUDState;                                  // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GFxMenuDrawPriorityBoost;                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        CreatedMenus;                                      // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenuData">();
	}
	static class UGbxGFxMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenuData>();
	}
};
static_assert(alignof(UGbxGFxMenuData) == 0x000008, "Wrong alignment on UGbxGFxMenuData");
static_assert(sizeof(UGbxGFxMenuData) == 0x0000C0, "Wrong size on UGbxGFxMenuData");
static_assert(offsetof(UGbxGFxMenuData, MovieClass) == 0x000048, "Member 'UGbxGFxMenuData::MovieClass' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuData, TransitionMovieClipTarget) == 0x000070, "Member 'UGbxGFxMenuData::TransitionMovieClipTarget' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuData, TransitionOutAnimation) == 0x000080, "Member 'UGbxGFxMenuData::TransitionOutAnimation' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuData, TransitionOutTimeout) == 0x000090, "Member 'UGbxGFxMenuData::TransitionOutTimeout' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuData, OverrideHUDState) == 0x000098, "Member 'UGbxGFxMenuData::OverrideHUDState' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuData, GFxMenuDrawPriorityBoost) == 0x0000A8, "Member 'UGbxGFxMenuData::GFxMenuDrawPriorityBoost' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuData, CreatedMenus) == 0x0000B0, "Member 'UGbxGFxMenuData::CreatedMenus' has a wrong offset!");

// Class GbxUI.GbxDebugRumbleMenu
// 0x0040 (0x0338 - 0x02F8)
class UGbxDebugRumbleMenu final : public UGbxDebugMenuSubmenu
{
public:
	float                                         SliderStepSize;                                    // 0x02F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxScrollBoxList*                      ContentPanel;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxListItemNumber*                     LeftLargeSlider;                                   // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxListItemNumber*                     LeftSmallSlider;                                   // 0x0310(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxListItemNumber*                     RightLargeSlider;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxListItemNumber*                     RightSmallSlider;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSliderValueChanged(class UGbxListItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDebugRumbleMenu">();
	}
	static class UGbxDebugRumbleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDebugRumbleMenu>();
	}
};
static_assert(alignof(UGbxDebugRumbleMenu) == 0x000008, "Wrong alignment on UGbxDebugRumbleMenu");
static_assert(sizeof(UGbxDebugRumbleMenu) == 0x000338, "Wrong size on UGbxDebugRumbleMenu");
static_assert(offsetof(UGbxDebugRumbleMenu, SliderStepSize) == 0x0002F8, "Member 'UGbxDebugRumbleMenu::SliderStepSize' has a wrong offset!");
static_assert(offsetof(UGbxDebugRumbleMenu, ContentPanel) == 0x000300, "Member 'UGbxDebugRumbleMenu::ContentPanel' has a wrong offset!");
static_assert(offsetof(UGbxDebugRumbleMenu, LeftLargeSlider) == 0x000308, "Member 'UGbxDebugRumbleMenu::LeftLargeSlider' has a wrong offset!");
static_assert(offsetof(UGbxDebugRumbleMenu, LeftSmallSlider) == 0x000310, "Member 'UGbxDebugRumbleMenu::LeftSmallSlider' has a wrong offset!");
static_assert(offsetof(UGbxDebugRumbleMenu, RightLargeSlider) == 0x000318, "Member 'UGbxDebugRumbleMenu::RightLargeSlider' has a wrong offset!");
static_assert(offsetof(UGbxDebugRumbleMenu, RightSmallSlider) == 0x000320, "Member 'UGbxDebugRumbleMenu::RightSmallSlider' has a wrong offset!");

// Class GbxUI.GbxFullScreenMovie
// 0x0008 (0x02C0 - 0x02B8)
class UGbxFullScreenMovie final : public UGbxUserWidget
{
public:
	class UMediaPlayer*                           CurrentPlayer;                                     // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnMovieFinishedPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFullScreenMovie">();
	}
	static class UGbxFullScreenMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFullScreenMovie>();
	}
};
static_assert(alignof(UGbxFullScreenMovie) == 0x000008, "Wrong alignment on UGbxFullScreenMovie");
static_assert(sizeof(UGbxFullScreenMovie) == 0x0002C0, "Wrong size on UGbxFullScreenMovie");
static_assert(offsetof(UGbxFullScreenMovie, CurrentPlayer) == 0x0002B8, "Member 'UGbxFullScreenMovie::CurrentPlayer' has a wrong offset!");

// Class GbxUI.GbxGFxButton
// 0x0158 (0x02C8 - 0x0170)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxButton : public UGbxGFxObject
{
public:
	uint8                                         Pad_170[0x28];                                     // 0x0170(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxFocusableWidgetMouseBehavior              MouseFocusBehavior;                                // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnFocusedAudioEventName;                           // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnClickedAudioEventName;                           // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnClicked;                                         // 0x01B0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnSecondaryClicked;                                // 0x01C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnFocused;                                         // 0x01D0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnUnfocused;                                       // 0x01E0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnPressed;                                         // 0x01F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnReleased;                                        // 0x0200(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnHovered;                                         // 0x0210(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnUnhovered;                                       // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxGFxButton* BUTTON, struct FGbxMenuInputEvent& InputInfo)> OnHeld;                                            // 0x0230(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxGFxMenu>             OwningMenu;                                        // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxTextField*                          Label;                                             // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x18];                                     // 0x0250(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxObject*                          AppearanceFrameClip;                               // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeButtonHeld;                                    // 0x0270(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSentHeldEvent;                                 // 0x0274(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWantsHeld;                                        // 0x0275(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreNextClick;                                  // 0x0276(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNewIndicatorUsesLabels;                           // 0x0277(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x50];                                     // 0x0278(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsFocusableWidgetStateDisabled(EGbxFocusableWidgetState State);
	static bool IsFocusableWidgetStateDown(EGbxFocusableWidgetState State);
	static bool IsFocusableWidgetStateFocused(EGbxFocusableWidgetState State);
	static bool IsFocusableWidgetStateHovered(EGbxFocusableWidgetState State);
	static bool IsFocusableWidgetStateUp(EGbxFocusableWidgetState State);

	void GbxGFxButtonEvent__DelegateSignature(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);
	void K2_HandleFocusableWidgetStateChanged(EGbxFocusableWidgetState NewState, bool bBecameFocused, bool bLostFocus);
	void RefreshView(EGbxFocusableWidgetState PrevState);
	void SetButtonType(EGbxGFxButtonType InButtonType);
	void SetCheckedState(EGbxGFxButtonCheckedState InCheckedState, bool bShouldRefresh);
	void SetLabelText(const class FText& Text, bool bForceUpdate);
	void SetLockedState(EGbxGFxButtonLockedState InLockedState, bool bShouldRefresh);

	EGbxGFxButtonType GetButtonType() const;
	EGbxGFxButtonCheckedState GetCheckedState() const;
	EGbxGFxButtonLockedState GetLockedState() const;
	bool IsChecked() const;
	bool IsLocked() const;
	bool IsRegisteredAsFocusableWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxButton">();
	}
	static class UGbxGFxButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxButton>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxButton) == 0x000008, "Wrong alignment on UGbxGFxButton");
static_assert(sizeof(UGbxGFxButton) == 0x0002C8, "Wrong size on UGbxGFxButton");
static_assert(offsetof(UGbxGFxButton, MouseFocusBehavior) == 0x000198, "Member 'UGbxGFxButton::MouseFocusBehavior' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnFocusedAudioEventName) == 0x0001A0, "Member 'UGbxGFxButton::OnFocusedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnClickedAudioEventName) == 0x0001A8, "Member 'UGbxGFxButton::OnClickedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnClicked) == 0x0001B0, "Member 'UGbxGFxButton::OnClicked' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnSecondaryClicked) == 0x0001C0, "Member 'UGbxGFxButton::OnSecondaryClicked' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnFocused) == 0x0001D0, "Member 'UGbxGFxButton::OnFocused' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnUnfocused) == 0x0001E0, "Member 'UGbxGFxButton::OnUnfocused' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnPressed) == 0x0001F0, "Member 'UGbxGFxButton::OnPressed' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnReleased) == 0x000200, "Member 'UGbxGFxButton::OnReleased' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnHovered) == 0x000210, "Member 'UGbxGFxButton::OnHovered' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnUnhovered) == 0x000220, "Member 'UGbxGFxButton::OnUnhovered' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OnHeld) == 0x000230, "Member 'UGbxGFxButton::OnHeld' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, OwningMenu) == 0x000240, "Member 'UGbxGFxButton::OwningMenu' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, Label) == 0x000248, "Member 'UGbxGFxButton::Label' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, AppearanceFrameClip) == 0x000268, "Member 'UGbxGFxButton::AppearanceFrameClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, TimeButtonHeld) == 0x000270, "Member 'UGbxGFxButton::TimeButtonHeld' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, bHasSentHeldEvent) == 0x000274, "Member 'UGbxGFxButton::bHasSentHeldEvent' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, bWantsHeld) == 0x000275, "Member 'UGbxGFxButton::bWantsHeld' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, bIgnoreNextClick) == 0x000276, "Member 'UGbxGFxButton::bIgnoreNextClick' has a wrong offset!");
static_assert(offsetof(UGbxGFxButton, bNewIndicatorUsesLabels) == 0x000277, "Member 'UGbxGFxButton::bNewIndicatorUsesLabels' has a wrong offset!");

// Class GbxUI.GbxFocusableWidget
// 0x0000 (0x0028 - 0x0028)
class IGbxFocusableWidget final : public IInterface
{
public:
	void SetFocusableWidgetEnabled(bool bEnabled);

	EGbxFocusableWidgetState GetFocusableWidgetState() const;
	bool IsFocusableWidgetEnabled() const;
	bool IsFocusableWidgetFocused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFocusableWidget">();
	}
	static class IGbxFocusableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxFocusableWidget>();
	}
};
static_assert(alignof(IGbxFocusableWidget) == 0x000008, "Wrong alignment on IGbxFocusableWidget");
static_assert(sizeof(IGbxFocusableWidget) == 0x000028, "Wrong size on IGbxFocusableWidget");

// Class GbxUI.GbxGFxListCell
// 0x0040 (0x0308 - 0x02C8)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxListCell : public UGbxGFxButton
{
public:
	class UGbxGFxGridScrollingList*               OwningList;                                        // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          CellBounds;                                        // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ListIndex;                                         // 0x02D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PositionInContainer;                               // 0x02DC(0x0008)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TopOffsetPosition;                                 // 0x02E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BottomOffsetPosition;                              // 0x02E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftOffsetPosition;                                // 0x02EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightOffsetPosition;                               // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReadjustingFocus;                               // 0x02F4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x13];                                     // 0x02F5(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxListCell">();
	}
	static class UGbxGFxListCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxListCell>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxListCell) == 0x000008, "Wrong alignment on UGbxGFxListCell");
static_assert(sizeof(UGbxGFxListCell) == 0x000308, "Wrong size on UGbxGFxListCell");
static_assert(offsetof(UGbxGFxListCell, OwningList) == 0x0002C8, "Member 'UGbxGFxListCell::OwningList' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, CellBounds) == 0x0002D0, "Member 'UGbxGFxListCell::CellBounds' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, ListIndex) == 0x0002D8, "Member 'UGbxGFxListCell::ListIndex' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, PositionInContainer) == 0x0002DC, "Member 'UGbxGFxListCell::PositionInContainer' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, TopOffsetPosition) == 0x0002E4, "Member 'UGbxGFxListCell::TopOffsetPosition' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, BottomOffsetPosition) == 0x0002E8, "Member 'UGbxGFxListCell::BottomOffsetPosition' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, LeftOffsetPosition) == 0x0002EC, "Member 'UGbxGFxListCell::LeftOffsetPosition' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, RightOffsetPosition) == 0x0002F0, "Member 'UGbxGFxListCell::RightOffsetPosition' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCell, bIsReadjustingFocus) == 0x0002F4, "Member 'UGbxGFxListCell::bIsReadjustingFocus' has a wrong offset!");

// Class GbxUI.GbxUmgMenuData
// 0x0010 (0x0058 - 0x0048)
class UGbxUmgMenuData : public UGbxMenuData
{
public:
	TSubclassOf<class UGbxUmgMenu>                MenuClass;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxListItemFactory*                    ListItemFactory;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUmgMenuData">();
	}
	static class UGbxUmgMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUmgMenuData>();
	}
};
static_assert(alignof(UGbxUmgMenuData) == 0x000008, "Wrong alignment on UGbxUmgMenuData");
static_assert(sizeof(UGbxUmgMenuData) == 0x000058, "Wrong size on UGbxUmgMenuData");
static_assert(offsetof(UGbxUmgMenuData, MenuClass) == 0x000048, "Member 'UGbxUmgMenuData::MenuClass' has a wrong offset!");
static_assert(offsetof(UGbxUmgMenuData, ListItemFactory) == 0x000050, "Member 'UGbxUmgMenuData::ListItemFactory' has a wrong offset!");

// Class GbxUI.GbxMenuSwitcherMenuData
// 0x0010 (0x0068 - 0x0058)
class UGbxMenuSwitcherMenuData : public UGbxUmgMenuData
{
public:
	TArray<struct FGbxMenuSwitcherSubmenuInfo>    Submenus;                                          // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuSwitcherMenuData">();
	}
	static class UGbxMenuSwitcherMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuSwitcherMenuData>();
	}
};
static_assert(alignof(UGbxMenuSwitcherMenuData) == 0x000008, "Wrong alignment on UGbxMenuSwitcherMenuData");
static_assert(sizeof(UGbxMenuSwitcherMenuData) == 0x000068, "Wrong size on UGbxMenuSwitcherMenuData");
static_assert(offsetof(UGbxMenuSwitcherMenuData, Submenus) == 0x000058, "Member 'UGbxMenuSwitcherMenuData::Submenus' has a wrong offset!");

// Class GbxUI.GbxDebugMenuData
// 0x0000 (0x0068 - 0x0068)
class UGbxDebugMenuData final : public UGbxMenuSwitcherMenuData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDebugMenuData">();
	}
	static class UGbxDebugMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDebugMenuData>();
	}
};
static_assert(alignof(UGbxDebugMenuData) == 0x000008, "Wrong alignment on UGbxDebugMenuData");
static_assert(sizeof(UGbxDebugMenuData) == 0x000068, "Wrong size on UGbxDebugMenuData");

// Class GbxUI.GbxGFxListCellWithData
// 0x0010 (0x0318 - 0x0308)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxListCellWithData : public UGbxGFxListCell
{
public:
	class FName                                   TextID;                                            // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataAsset*                             DataAsset;                                         // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxListCellWithData">();
	}
	static class UGbxGFxListCellWithData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxListCellWithData>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxListCellWithData) == 0x000008, "Wrong alignment on UGbxGFxListCellWithData");
static_assert(sizeof(UGbxGFxListCellWithData) == 0x000318, "Wrong size on UGbxGFxListCellWithData");
static_assert(offsetof(UGbxGFxListCellWithData, TextID) == 0x000308, "Member 'UGbxGFxListCellWithData::TextID' has a wrong offset!");
static_assert(offsetof(UGbxGFxListCellWithData, DataAsset) == 0x000310, "Member 'UGbxGFxListCellWithData::DataAsset' has a wrong offset!");

// Class GbxUI.GbxGFxDropDownList
// 0x0080 (0x01F0 - 0x0170)
class UGbxGFxDropDownList final : public UGbxGFxObject
{
public:
	class UGbxTextField*                          CurrentSelectionText;                              // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxSlider*                          ListScrollBar;                                     // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxButton*                          DropDownButton;                                    // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxButton*                          TopButton;                                         // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          DropDownListContainer;                             // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxComboBoxScrollingList*           DropDownList;                                      // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           EntriesList;                                       // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FText                                   CurrentlySelectedEntry;                            // 0x01B8(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x20];                                     // 0x01D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDropDownButtonClicked(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);
	void OnEntryClicked(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxDropDownList">();
	}
	static class UGbxGFxDropDownList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxDropDownList>();
	}
};
static_assert(alignof(UGbxGFxDropDownList) == 0x000008, "Wrong alignment on UGbxGFxDropDownList");
static_assert(sizeof(UGbxGFxDropDownList) == 0x0001F0, "Wrong size on UGbxGFxDropDownList");
static_assert(offsetof(UGbxGFxDropDownList, CurrentSelectionText) == 0x000170, "Member 'UGbxGFxDropDownList::CurrentSelectionText' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, ListScrollBar) == 0x000178, "Member 'UGbxGFxDropDownList::ListScrollBar' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, DropDownButton) == 0x000180, "Member 'UGbxGFxDropDownList::DropDownButton' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, TopButton) == 0x000188, "Member 'UGbxGFxDropDownList::TopButton' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, DropDownListContainer) == 0x000190, "Member 'UGbxGFxDropDownList::DropDownListContainer' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, DropDownList) == 0x000198, "Member 'UGbxGFxDropDownList::DropDownList' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, EntriesList) == 0x0001A8, "Member 'UGbxGFxDropDownList::EntriesList' has a wrong offset!");
static_assert(offsetof(UGbxGFxDropDownList, CurrentlySelectedEntry) == 0x0001B8, "Member 'UGbxGFxDropDownList::CurrentlySelectedEntry' has a wrong offset!");

// Class GbxUI.GbxGFxListItemSpinner
// 0x0048 (0x0360 - 0x0318)
class UGbxGFxListItemSpinner : public UGbxGFxListCellWithData
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxSpinner*                            SpinnerItem;                                       // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x38];                                     // 0x0328(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpinnerValueUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxListItemSpinner">();
	}
	static class UGbxGFxListItemSpinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxListItemSpinner>();
	}
};
static_assert(alignof(UGbxGFxListItemSpinner) == 0x000008, "Wrong alignment on UGbxGFxListItemSpinner");
static_assert(sizeof(UGbxGFxListItemSpinner) == 0x000360, "Wrong size on UGbxGFxListItemSpinner");
static_assert(offsetof(UGbxGFxListItemSpinner, SpinnerItem) == 0x000320, "Member 'UGbxGFxListItemSpinner::SpinnerItem' has a wrong offset!");

// Class GbxUI.GbxGFxMenuSwitcherSubmenu
// 0x0008 (0x0688 - 0x0680)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxMenuSwitcherSubmenu : public UGbxGFxMenu
{
public:
	TWeakObjectPtr<class UGbxGFxMenuSwitcher>     OwnerMenuSwitcher;                                 // 0x0680(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenuSwitcherSubmenu">();
	}
	static class UGbxGFxMenuSwitcherSubmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenuSwitcherSubmenu>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxMenuSwitcherSubmenu) == 0x000008, "Wrong alignment on UGbxGFxMenuSwitcherSubmenu");
static_assert(sizeof(UGbxGFxMenuSwitcherSubmenu) == 0x000688, "Wrong size on UGbxGFxMenuSwitcherSubmenu");
static_assert(offsetof(UGbxGFxMenuSwitcherSubmenu, OwnerMenuSwitcher) == 0x000680, "Member 'UGbxGFxMenuSwitcherSubmenu::OwnerMenuSwitcher' has a wrong offset!");

// Class GbxUI.GbxGFxMovieLoader
// 0x0028 (0x0198 - 0x0170)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxMovieLoader : public UGbxGFxObject
{
public:
	UMulticastDelegateProperty_                   OnMovieLoadCompleteDelegate;                       // 0x0170(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	class UGbxGFxObject*                          LoadedMovie;                                       // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USwfMovie*                              QueuedLoadMovie;                                   // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USwfMovie*                              CurrentMovie;                                      // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMovieLoader">();
	}
	static class UGbxGFxMovieLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMovieLoader>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxMovieLoader) == 0x000008, "Wrong alignment on UGbxGFxMovieLoader");
static_assert(sizeof(UGbxGFxMovieLoader) == 0x000198, "Wrong size on UGbxGFxMovieLoader");
static_assert(offsetof(UGbxGFxMovieLoader, OnMovieLoadCompleteDelegate) == 0x000170, "Member 'UGbxGFxMovieLoader::OnMovieLoadCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovieLoader, LoadedMovie) == 0x000180, "Member 'UGbxGFxMovieLoader::LoadedMovie' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovieLoader, QueuedLoadMovie) == 0x000188, "Member 'UGbxGFxMovieLoader::QueuedLoadMovie' has a wrong offset!");
static_assert(offsetof(UGbxGFxMovieLoader, CurrentMovie) == 0x000190, "Member 'UGbxGFxMovieLoader::CurrentMovie' has a wrong offset!");

// Class GbxUI.GbxGFxProgressBar
// 0x01A8 (0x0318 - 0x0170)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxProgressBar : public UGbxGFxObject
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Percent;                                           // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFillFrames;                                     // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDeltaBarFrames;                                 // 0x0180(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBackgroundBarFrames;                            // 0x0184(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxProgressBarInterpolator            DefaultInterpolator;                               // 0x0188(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGbxProgressBarRange>           Ranges;                                            // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 EdgeFlashID;                                       // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EdgeFlashInnerID;                                  // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FillBarId;                                         // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeltaBarId;                                        // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundBarId;                                   // 0x0200(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentValueLabelId;                               // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaxValueLabelId;                                   // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x88];                                     // 0x0230(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnInterpolationComplete;                           // 0x02B8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class FName& RangeName)>       OnEnterRange;                                      // 0x02C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxProgressBarInterpolator            Interpolator;                                      // 0x02D8(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool EnteredPercentRange(float RangeMin, float RangeMax, float OldValue, float CurrentValue, bool bIncreasing, bool bDecreasing);
	static bool PassedPercentThreshold(float Threshold, float OldValue, float CurrentValue, bool bIncreasing, bool bDecreasing);

	void HandleEnterPercentRange(const class FName& RangeName);
	void HandlePercentChanged(float OldValue, float CurrentValue, bool bIsInterpolating, const struct FGbxProgressBarInterpolator& ActiveInterpolator);
	void InterpolateToPercent(float InPercent);
	void InterpolateToPercentWithInterpolator(float InPercent, const struct FGbxProgressBarInterpolator& Interpolator_0);
	void SetCurrentValueText(const class FText& Text);
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetMaxValueText(const class FText& Text);
	void SetPercent(float InPercent);

	float GetPercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxProgressBar">();
	}
	static class UGbxGFxProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxProgressBar>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxProgressBar) == 0x000008, "Wrong alignment on UGbxGFxProgressBar");
static_assert(sizeof(UGbxGFxProgressBar) == 0x000318, "Wrong size on UGbxGFxProgressBar");
static_assert(offsetof(UGbxGFxProgressBar, Percent) == 0x000178, "Member 'UGbxGFxProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, NumFillFrames) == 0x00017C, "Member 'UGbxGFxProgressBar::NumFillFrames' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, NumDeltaBarFrames) == 0x000180, "Member 'UGbxGFxProgressBar::NumDeltaBarFrames' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, NumBackgroundBarFrames) == 0x000184, "Member 'UGbxGFxProgressBar::NumBackgroundBarFrames' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, DefaultInterpolator) == 0x000188, "Member 'UGbxGFxProgressBar::DefaultInterpolator' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, Ranges) == 0x0001B0, "Member 'UGbxGFxProgressBar::Ranges' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, EdgeFlashID) == 0x0001C0, "Member 'UGbxGFxProgressBar::EdgeFlashID' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, EdgeFlashInnerID) == 0x0001D0, "Member 'UGbxGFxProgressBar::EdgeFlashInnerID' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, FillBarId) == 0x0001E0, "Member 'UGbxGFxProgressBar::FillBarId' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, DeltaBarId) == 0x0001F0, "Member 'UGbxGFxProgressBar::DeltaBarId' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, BackgroundBarId) == 0x000200, "Member 'UGbxGFxProgressBar::BackgroundBarId' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, CurrentValueLabelId) == 0x000210, "Member 'UGbxGFxProgressBar::CurrentValueLabelId' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, MaxValueLabelId) == 0x000220, "Member 'UGbxGFxProgressBar::MaxValueLabelId' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, OnInterpolationComplete) == 0x0002B8, "Member 'UGbxGFxProgressBar::OnInterpolationComplete' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, OnEnterRange) == 0x0002C8, "Member 'UGbxGFxProgressBar::OnEnterRange' has a wrong offset!");
static_assert(offsetof(UGbxGFxProgressBar, Interpolator) == 0x0002D8, "Member 'UGbxGFxProgressBar::Interpolator' has a wrong offset!");

// Class GbxUI.GbxGFxRechargeableProgressBar
// 0x0028 (0x0340 - 0x0318)
class UGbxGFxRechargeableProgressBar final : public UGbxGFxProgressBar
{
public:
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxRechargeableProgressBar">();
	}
	static class UGbxGFxRechargeableProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxRechargeableProgressBar>();
	}
};
static_assert(alignof(UGbxGFxRechargeableProgressBar) == 0x000008, "Wrong alignment on UGbxGFxRechargeableProgressBar");
static_assert(sizeof(UGbxGFxRechargeableProgressBar) == 0x000340, "Wrong size on UGbxGFxRechargeableProgressBar");

// Class GbxUI.GbxGFxMenuSwitcher
// 0x0020 (0x06A0 - 0x0680)
class UGbxGFxMenuSwitcher : public UGbxGFxMenu
{
public:
	TWeakObjectPtr<class UGbxGFxMenuSwitcherSubmenu> CurrentSubmenu;                                    // 0x0680(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentSubmenuId;                                  // 0x0688(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PreviousSubmenuId;                                 // 0x0690(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSubMenus;                                       // 0x0698(0x0004)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenuSwitcher">();
	}
	static class UGbxGFxMenuSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenuSwitcher>();
	}
};
static_assert(alignof(UGbxGFxMenuSwitcher) == 0x000008, "Wrong alignment on UGbxGFxMenuSwitcher");
static_assert(sizeof(UGbxGFxMenuSwitcher) == 0x0006A0, "Wrong size on UGbxGFxMenuSwitcher");
static_assert(offsetof(UGbxGFxMenuSwitcher, CurrentSubmenu) == 0x000680, "Member 'UGbxGFxMenuSwitcher::CurrentSubmenu' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcher, CurrentSubmenuId) == 0x000688, "Member 'UGbxGFxMenuSwitcher::CurrentSubmenuId' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcher, PreviousSubmenuId) == 0x000690, "Member 'UGbxGFxMenuSwitcher::PreviousSubmenuId' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcher, NumSubMenus) == 0x000698, "Member 'UGbxGFxMenuSwitcher::NumSubMenus' has a wrong offset!");

// Class GbxUI.GbxGridListWidget
// 0x00A0 (0x01E8 - 0x0148)
class UGbxGridListWidget final : public UGridPanel
{
public:
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedColumn;                                    // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedRow;                                       // 0x0164(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedIndexWhenFocusWasLost;                     // 0x0168(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxUmgMenu>             MenuThatOwnsFocus;                                 // 0x016C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridColumns;                                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridRows;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGridWidgetFill                            GridFill;                                          // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UGbxListItem* Item)>     SelectionChangedDelegate;                          // 0x0180(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxListItem* ClickedItem)> ItemClickedDelegate;                               // 0x0190(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EGbxListWrapMode                              RowWrapMode;                                       // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxListWrapMode                              ColumnWrapMode;                                    // 0x01A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxFocusableWidgetMouseBehavior              DefaultItemSelectionBehavior;                      // 0x01A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A3[0x5];                                      // 0x01A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxListItemFactory*                    ListItemFactory;                                   // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxListItem>               DefaultListItemClass;                              // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxListFocusChangedAction                    FocusChangeAction;                                 // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterAsFocusableWidget;                        // 0x01B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BA[0x6];                                      // 0x01BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FocusableWidgetNavUp;                              // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavDown;                            // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavLeft;                            // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavRight;                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocusOnMenuCreation;                              // 0x01E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGridListWidget">();
	}
	static class UGbxGridListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGridListWidget>();
	}
};
static_assert(alignof(UGbxGridListWidget) == 0x000008, "Wrong alignment on UGbxGridListWidget");
static_assert(sizeof(UGbxGridListWidget) == 0x0001E8, "Wrong size on UGbxGridListWidget");
static_assert(offsetof(UGbxGridListWidget, SelectedColumn) == 0x000160, "Member 'UGbxGridListWidget::SelectedColumn' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, SelectedRow) == 0x000164, "Member 'UGbxGridListWidget::SelectedRow' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, SelectedIndexWhenFocusWasLost) == 0x000168, "Member 'UGbxGridListWidget::SelectedIndexWhenFocusWasLost' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, MenuThatOwnsFocus) == 0x00016C, "Member 'UGbxGridListWidget::MenuThatOwnsFocus' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, GridColumns) == 0x000174, "Member 'UGbxGridListWidget::GridColumns' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, GridRows) == 0x000178, "Member 'UGbxGridListWidget::GridRows' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, GridFill) == 0x00017C, "Member 'UGbxGridListWidget::GridFill' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, SelectionChangedDelegate) == 0x000180, "Member 'UGbxGridListWidget::SelectionChangedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, ItemClickedDelegate) == 0x000190, "Member 'UGbxGridListWidget::ItemClickedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, RowWrapMode) == 0x0001A0, "Member 'UGbxGridListWidget::RowWrapMode' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, ColumnWrapMode) == 0x0001A1, "Member 'UGbxGridListWidget::ColumnWrapMode' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, DefaultItemSelectionBehavior) == 0x0001A2, "Member 'UGbxGridListWidget::DefaultItemSelectionBehavior' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, ListItemFactory) == 0x0001A8, "Member 'UGbxGridListWidget::ListItemFactory' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, DefaultListItemClass) == 0x0001B0, "Member 'UGbxGridListWidget::DefaultListItemClass' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, FocusChangeAction) == 0x0001B8, "Member 'UGbxGridListWidget::FocusChangeAction' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, bRegisterAsFocusableWidget) == 0x0001B9, "Member 'UGbxGridListWidget::bRegisterAsFocusableWidget' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, FocusableWidgetNavUp) == 0x0001C0, "Member 'UGbxGridListWidget::FocusableWidgetNavUp' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, FocusableWidgetNavDown) == 0x0001C8, "Member 'UGbxGridListWidget::FocusableWidgetNavDown' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, FocusableWidgetNavLeft) == 0x0001D0, "Member 'UGbxGridListWidget::FocusableWidgetNavLeft' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, FocusableWidgetNavRight) == 0x0001D8, "Member 'UGbxGridListWidget::FocusableWidgetNavRight' has a wrong offset!");
static_assert(offsetof(UGbxGridListWidget, bFocusOnMenuCreation) == 0x0001E0, "Member 'UGbxGridListWidget::bFocusOnMenuCreation' has a wrong offset!");

// Class GbxUI.GbxGFxListItemNumber
// 0x0088 (0x03A0 - 0x0318)
class UGbxGFxListItemNumber : public UGbxGFxListCellWithData
{
public:
	int32                                         SliderRepeatsToAccelerate;                         // 0x0318(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SliderMaxIncreases;                                // 0x031C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SliderFastestSteps;                                // 0x0320(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x1C];                                     // 0x0324(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxSlider*                          SliderItem;                                        // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxTextField*                          ValueItem;                                         // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x50];                                     // 0x0350(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSliderUpdated(float SliderPct);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxListItemNumber">();
	}
	static class UGbxGFxListItemNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxListItemNumber>();
	}
};
static_assert(alignof(UGbxGFxListItemNumber) == 0x000008, "Wrong alignment on UGbxGFxListItemNumber");
static_assert(sizeof(UGbxGFxListItemNumber) == 0x0003A0, "Wrong size on UGbxGFxListItemNumber");
static_assert(offsetof(UGbxGFxListItemNumber, SliderRepeatsToAccelerate) == 0x000318, "Member 'UGbxGFxListItemNumber::SliderRepeatsToAccelerate' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemNumber, SliderMaxIncreases) == 0x00031C, "Member 'UGbxGFxListItemNumber::SliderMaxIncreases' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemNumber, SliderFastestSteps) == 0x000320, "Member 'UGbxGFxListItemNumber::SliderFastestSteps' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemNumber, SliderItem) == 0x000340, "Member 'UGbxGFxListItemNumber::SliderItem' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemNumber, ValueItem) == 0x000348, "Member 'UGbxGFxListItemNumber::ValueItem' has a wrong offset!");

// Class GbxUI.GbxHUDWidget
// 0x0058 (0x0310 - 0x02B8)
class UGbxHUDWidget : public UGbxUserWidget
{
public:
	struct FGeometry                              CachedGeometry;                                    // 0x02B8(0x0038)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxHUDContainer*                       OwningHUDContainer;                                // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxHUD*                                OwningHUD;                                         // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxPlayerController*                   OwningPlayerController;                            // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActivate();
	void HandleDeactivate();
	void HandleDeinit();
	void HandleInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHUDWidget">();
	}
	static class UGbxHUDWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxHUDWidget>();
	}
};
static_assert(alignof(UGbxHUDWidget) == 0x000008, "Wrong alignment on UGbxHUDWidget");
static_assert(sizeof(UGbxHUDWidget) == 0x000310, "Wrong size on UGbxHUDWidget");
static_assert(offsetof(UGbxHUDWidget, CachedGeometry) == 0x0002B8, "Member 'UGbxHUDWidget::CachedGeometry' has a wrong offset!");
static_assert(offsetof(UGbxHUDWidget, OwningHUDContainer) == 0x0002F0, "Member 'UGbxHUDWidget::OwningHUDContainer' has a wrong offset!");
static_assert(offsetof(UGbxHUDWidget, OwningHUD) == 0x0002F8, "Member 'UGbxHUDWidget::OwningHUD' has a wrong offset!");
static_assert(offsetof(UGbxHUDWidget, OwningPlayerController) == 0x000300, "Member 'UGbxHUDWidget::OwningPlayerController' has a wrong offset!");

// Class GbxUI.GbxGFxPooledGridList
// 0x0098 (0x03B8 - 0x0320)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxPooledGridList : public UGbxGFxGridScrollingList
{
public:
	TDelegate<void(struct FGbxGFxListCellUpdateInfo& UpdateInfo)> CellChangedDelegate;                               // 0x0320(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGbxGFxListCellUpdateInfo& UpdateInfo)> CellFocusedDelegate;                               // 0x0330(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGbxGFxListCellUpdateInfo& UpdateInfo)> CellClickedDelegate;                               // 0x0340(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxGFxPooledGridListConfig            PooledConfig;                                      // 0x0350(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         HelperDataDirDim;                                  // 0x0380(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HelperDataItemsInDir;                              // 0x0384(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HelperDataItemsPerDir;                             // 0x0388(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HelperDataFirstItemIndex;                          // 0x038C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HelperDataNumVisibleItems;                         // 0x0390(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HelperDataScrollOffset;                            // 0x0394(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGbxGFxPooledGridPoolInfo>      MasterCellPool;                                    // 0x0398(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxPooledGridList">();
	}
	static class UGbxGFxPooledGridList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxPooledGridList>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxPooledGridList) == 0x000008, "Wrong alignment on UGbxGFxPooledGridList");
static_assert(sizeof(UGbxGFxPooledGridList) == 0x0003B8, "Wrong size on UGbxGFxPooledGridList");
static_assert(offsetof(UGbxGFxPooledGridList, CellChangedDelegate) == 0x000320, "Member 'UGbxGFxPooledGridList::CellChangedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, CellFocusedDelegate) == 0x000330, "Member 'UGbxGFxPooledGridList::CellFocusedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, CellClickedDelegate) == 0x000340, "Member 'UGbxGFxPooledGridList::CellClickedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, PooledConfig) == 0x000350, "Member 'UGbxGFxPooledGridList::PooledConfig' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, HelperDataDirDim) == 0x000380, "Member 'UGbxGFxPooledGridList::HelperDataDirDim' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, HelperDataItemsInDir) == 0x000384, "Member 'UGbxGFxPooledGridList::HelperDataItemsInDir' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, HelperDataItemsPerDir) == 0x000388, "Member 'UGbxGFxPooledGridList::HelperDataItemsPerDir' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, HelperDataFirstItemIndex) == 0x00038C, "Member 'UGbxGFxPooledGridList::HelperDataFirstItemIndex' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, HelperDataNumVisibleItems) == 0x000390, "Member 'UGbxGFxPooledGridList::HelperDataNumVisibleItems' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, HelperDataScrollOffset) == 0x000394, "Member 'UGbxGFxPooledGridList::HelperDataScrollOffset' has a wrong offset!");
static_assert(offsetof(UGbxGFxPooledGridList, MasterCellPool) == 0x000398, "Member 'UGbxGFxPooledGridList::MasterCellPool' has a wrong offset!");

// Class GbxUI.GbxGFxRadioButtonList
// 0x0000 (0x0320 - 0x0320)
class UGbxGFxRadioButtonList : public UGbxGFxGridScrollingList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxRadioButtonList">();
	}
	static class UGbxGFxRadioButtonList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxRadioButtonList>();
	}
};
static_assert(alignof(UGbxGFxRadioButtonList) == 0x000008, "Wrong alignment on UGbxGFxRadioButtonList");
static_assert(sizeof(UGbxGFxRadioButtonList) == 0x000320, "Wrong size on UGbxGFxRadioButtonList");

// Class GbxUI.GbxMenuSwitcher
// 0x0018 (0x0308 - 0x02F0)
class UGbxMenuSwitcher : public UGbxUmgMenu
{
public:
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NextPage();
	void PrevPage();
	void SwitchToPage(class FName SubMenuId);

	class FName GetCurrentSubmenuId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuSwitcher">();
	}
	static class UGbxMenuSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuSwitcher>();
	}
};
static_assert(alignof(UGbxMenuSwitcher) == 0x000008, "Wrong alignment on UGbxMenuSwitcher");
static_assert(sizeof(UGbxMenuSwitcher) == 0x000308, "Wrong size on UGbxMenuSwitcher");

// Class GbxUI.GbxDebugMenu
// 0x0028 (0x0330 - 0x0308)
class UGbxDebugMenu final : public UGbxMenuSwitcher
{
public:
	class UGbxGridListWidget*                     CategoryList;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBUTTON*                                CloseButton;                                       // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           SubmenuContainer;                                  // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HiddenSubmenus;                                    // 0x0320(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPrivate)

public:
	void OnCategorySelected(class UGbxUserWidget* Widget, const struct FGbxMenuInputEvent& InputInfo);
	void OnCloseClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDebugMenu">();
	}
	static class UGbxDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDebugMenu>();
	}
};
static_assert(alignof(UGbxDebugMenu) == 0x000008, "Wrong alignment on UGbxDebugMenu");
static_assert(sizeof(UGbxDebugMenu) == 0x000330, "Wrong size on UGbxDebugMenu");
static_assert(offsetof(UGbxDebugMenu, CategoryList) == 0x000308, "Member 'UGbxDebugMenu::CategoryList' has a wrong offset!");
static_assert(offsetof(UGbxDebugMenu, CloseButton) == 0x000310, "Member 'UGbxDebugMenu::CloseButton' has a wrong offset!");
static_assert(offsetof(UGbxDebugMenu, SubmenuContainer) == 0x000318, "Member 'UGbxDebugMenu::SubmenuContainer' has a wrong offset!");
static_assert(offsetof(UGbxDebugMenu, HiddenSubmenus) == 0x000320, "Member 'UGbxDebugMenu::HiddenSubmenus' has a wrong offset!");

// Class GbxUI.GbxGFxContextualMenuData
// 0x0080 (0x0140 - 0x00C0)
class UGbxGFxContextualMenuData final : public UGbxGFxMenuData
{
public:
	struct FContextualMenuInfo                    ContextualMenuInfo;                                // 0x00C0(0x0080)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxContextualMenuData">();
	}
	static class UGbxGFxContextualMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxContextualMenuData>();
	}
};
static_assert(alignof(UGbxGFxContextualMenuData) == 0x000008, "Wrong alignment on UGbxGFxContextualMenuData");
static_assert(sizeof(UGbxGFxContextualMenuData) == 0x000140, "Wrong size on UGbxGFxContextualMenuData");
static_assert(offsetof(UGbxGFxContextualMenuData, ContextualMenuInfo) == 0x0000C0, "Member 'UGbxGFxContextualMenuData::ContextualMenuInfo' has a wrong offset!");

// Class GbxUI.GbxGFxEditableTextField
// 0x0110 (0x0418 - 0x0308)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxEditableTextField : public UGbxGFxListCell
{
public:
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConfirmOnFocusOut;                                // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EditText;                                          // 0x0318(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMultiline;                                        // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGFxVirtualKeyboardType                       KeyboardType;                                      // 0x0329(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoseFocusOnConfirm;                               // 0x032A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32B[0xBD];                                     // 0x032B(0x00BD)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnTextSubmittedAudioEventName;                     // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnTextEditAbortedAudioEventName;                   // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnTextInputAudioEventName;                         // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxEditableTextField">();
	}
	static class UGbxGFxEditableTextField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxEditableTextField>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxEditableTextField) == 0x000008, "Wrong alignment on UGbxGFxEditableTextField");
static_assert(sizeof(UGbxGFxEditableTextField) == 0x000418, "Wrong size on UGbxGFxEditableTextField");
static_assert(offsetof(UGbxGFxEditableTextField, bConfirmOnFocusOut) == 0x000310, "Member 'UGbxGFxEditableTextField::bConfirmOnFocusOut' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, EditText) == 0x000318, "Member 'UGbxGFxEditableTextField::EditText' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, bMultiline) == 0x000328, "Member 'UGbxGFxEditableTextField::bMultiline' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, KeyboardType) == 0x000329, "Member 'UGbxGFxEditableTextField::KeyboardType' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, bLoseFocusOnConfirm) == 0x00032A, "Member 'UGbxGFxEditableTextField::bLoseFocusOnConfirm' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, OnTextSubmittedAudioEventName) == 0x0003E8, "Member 'UGbxGFxEditableTextField::OnTextSubmittedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, OnTextEditAbortedAudioEventName) == 0x0003F0, "Member 'UGbxGFxEditableTextField::OnTextEditAbortedAudioEventName' has a wrong offset!");
static_assert(offsetof(UGbxGFxEditableTextField, OnTextInputAudioEventName) == 0x0003F8, "Member 'UGbxGFxEditableTextField::OnTextInputAudioEventName' has a wrong offset!");

// Class GbxUI.GbxHUD
// 0x00B0 (0x0628 - 0x0578)
class AGbxHUD : public AHUD
{
public:
	uint8                                         Pad_578[0x18];                                     // 0x0578(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxHUDStateManager                    HudStateManager;                                   // 0x0590(0x0040)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisplayScaleformHUD;                              // 0x05D0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ChangedFromPawn;                                   // 0x05D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxHUDContainer*                    GFxHUDContainer;                                   // 0x05E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxHUDData*                            OverrideContainerDefinition;                       // 0x05F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x10];                                     // 0x05F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxMenuInputDevice                           CurrentInputDevice;                                // 0x0608(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGbxPlayerController>    OwningPC;                                          // 0x060C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AGbxCharacter>           OwningPrimaryCharacter;                            // 0x0614(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   OwningPawn;                                        // 0x061C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ClearHUDStates(class AGbxPlayerController* PlayerController);
	static void ClearToDefaultHUDState(class AGbxPlayerController* PlayerController);
	static class UGbxHUDStateData* GetCurrentHUDState(class AGbxPlayerController* PlayerController);
	static void GotoHUDState(class AGbxPlayerController* PlayerController, class UGbxHUDStateData* State);
	static void GotoPreviousHUDState(class AGbxPlayerController* PlayerController);
	static void PopHUDState(class AGbxPlayerController* PlayerController);
	static void PopSpecifiedHUDState(class AGbxPlayerController* PlayerController, class UGbxHUDStateData* State);
	static void PopToHUDState(class AGbxPlayerController* PlayerController, class UGbxHUDStateData* State);
	static void PopToSwitchToHUDState(class AGbxPlayerController* PlayerController, class UGbxHUDStateData* PopToState, class UGbxHUDStateData* SwitchToState);
	static void PushHUDState(class AGbxPlayerController* PlayerController, class UGbxHUDStateData* State, bool bAllowDuplicatePush);
	static void SetHUDContainer(class AGbxPlayerController* PlayerController, const class UGbxHUDData* ContainerDefinition);
	static void SwitchToHUDState(class AGbxPlayerController* PlayerController, class UGbxHUDStateData* State);

	void OnPawnChanged(class APawn* Pawn, class APawn* OldPawn);
	void OnPrimaryCharacterChanged(class AGbxCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHUD">();
	}
	static class AGbxHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxHUD>();
	}
};
static_assert(alignof(AGbxHUD) == 0x000008, "Wrong alignment on AGbxHUD");
static_assert(sizeof(AGbxHUD) == 0x000628, "Wrong size on AGbxHUD");
static_assert(offsetof(AGbxHUD, HudStateManager) == 0x000590, "Member 'AGbxHUD::HudStateManager' has a wrong offset!");
static_assert(offsetof(AGbxHUD, bDisplayScaleformHUD) == 0x0005D0, "Member 'AGbxHUD::bDisplayScaleformHUD' has a wrong offset!");
static_assert(offsetof(AGbxHUD, ChangedFromPawn) == 0x0005D8, "Member 'AGbxHUD::ChangedFromPawn' has a wrong offset!");
static_assert(offsetof(AGbxHUD, GFxHUDContainer) == 0x0005E8, "Member 'AGbxHUD::GFxHUDContainer' has a wrong offset!");
static_assert(offsetof(AGbxHUD, OverrideContainerDefinition) == 0x0005F0, "Member 'AGbxHUD::OverrideContainerDefinition' has a wrong offset!");
static_assert(offsetof(AGbxHUD, CurrentInputDevice) == 0x000608, "Member 'AGbxHUD::CurrentInputDevice' has a wrong offset!");
static_assert(offsetof(AGbxHUD, OwningPC) == 0x00060C, "Member 'AGbxHUD::OwningPC' has a wrong offset!");
static_assert(offsetof(AGbxHUD, OwningPrimaryCharacter) == 0x000614, "Member 'AGbxHUD::OwningPrimaryCharacter' has a wrong offset!");
static_assert(offsetof(AGbxHUD, OwningPawn) == 0x00061C, "Member 'AGbxHUD::OwningPawn' has a wrong offset!");

// Class GbxUI.GbxGFxGridScrollingListPaged
// 0x0010 (0x0330 - 0x0320)
class UGbxGFxGridScrollingListPaged : public UGbxGFxGridScrollingList
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxGridScrollingListPaged">();
	}
	static class UGbxGFxGridScrollingListPaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxGridScrollingListPaged>();
	}
};
static_assert(alignof(UGbxGFxGridScrollingListPaged) == 0x000008, "Wrong alignment on UGbxGFxGridScrollingListPaged");
static_assert(sizeof(UGbxGFxGridScrollingListPaged) == 0x000330, "Wrong size on UGbxGFxGridScrollingListPaged");

// Class GbxUI.GbxRichTextBlock
// 0x0020 (0x0380 - 0x0360)
class UGbxRichTextBlock final : public URichTextBlock
{
public:
	int16                                         Baseline;                                          // 0x0360(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0x2];                                      // 0x0362(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ShadowOffset;                                      // 0x0364(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x036C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxRichTextBlock">();
	}
	static class UGbxRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxRichTextBlock>();
	}
};
static_assert(alignof(UGbxRichTextBlock) == 0x000008, "Wrong alignment on UGbxRichTextBlock");
static_assert(sizeof(UGbxRichTextBlock) == 0x000380, "Wrong size on UGbxRichTextBlock");
static_assert(offsetof(UGbxRichTextBlock, Baseline) == 0x000360, "Member 'UGbxRichTextBlock::Baseline' has a wrong offset!");
static_assert(offsetof(UGbxRichTextBlock, ShadowOffset) == 0x000364, "Member 'UGbxRichTextBlock::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UGbxRichTextBlock, ShadowColorAndOpacity) == 0x00036C, "Member 'UGbxRichTextBlock::ShadowColorAndOpacity' has a wrong offset!");

// Class GbxUI.GbxGFxMenuSwitcherMenuData
// 0x0020 (0x00E0 - 0x00C0)
class UGbxGFxMenuSwitcherMenuData : public UGbxGFxMenuData
{
public:
	TArray<struct FGbxGFxMenuSwitcherSubmenuInfo> CurrentSubmenus;                                   // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FGbxGFxMenuSwitcherSubmenuInfo> Submenus;                                          // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenuSwitcherMenuData">();
	}
	static class UGbxGFxMenuSwitcherMenuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenuSwitcherMenuData>();
	}
};
static_assert(alignof(UGbxGFxMenuSwitcherMenuData) == 0x000008, "Wrong alignment on UGbxGFxMenuSwitcherMenuData");
static_assert(sizeof(UGbxGFxMenuSwitcherMenuData) == 0x0000E0, "Wrong size on UGbxGFxMenuSwitcherMenuData");
static_assert(offsetof(UGbxGFxMenuSwitcherMenuData, CurrentSubmenus) == 0x0000C0, "Member 'UGbxGFxMenuSwitcherMenuData::CurrentSubmenus' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherMenuData, Submenus) == 0x0000D0, "Member 'UGbxGFxMenuSwitcherMenuData::Submenus' has a wrong offset!");

// Class GbxUI.GbxListItemText
// 0x0000 (0x02E8 - 0x02E8)
class UGbxListItemText : public UGbxListItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxListItemText">();
	}
	static class UGbxListItemText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxListItemText>();
	}
};
static_assert(alignof(UGbxListItemText) == 0x000008, "Wrong alignment on UGbxListItemText");
static_assert(sizeof(UGbxListItemText) == 0x0002E8, "Wrong size on UGbxListItemText");

// Class GbxUI.GbxGFxMenuSwitcherNavCell
// 0x0028 (0x0330 - 0x0308)
class UGbxGFxMenuSwitcherNavCell final : public UGbxGFxListCell
{
public:
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOuterFocusedState;                                // 0x0328(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenuSwitcherNavCell">();
	}
	static class UGbxGFxMenuSwitcherNavCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenuSwitcherNavCell>();
	}
};
static_assert(alignof(UGbxGFxMenuSwitcherNavCell) == 0x000008, "Wrong alignment on UGbxGFxMenuSwitcherNavCell");
static_assert(sizeof(UGbxGFxMenuSwitcherNavCell) == 0x000330, "Wrong size on UGbxGFxMenuSwitcherNavCell");
static_assert(offsetof(UGbxGFxMenuSwitcherNavCell, bOuterFocusedState) == 0x000328, "Member 'UGbxGFxMenuSwitcherNavCell::bOuterFocusedState' has a wrong offset!");

// Class GbxUI.GbxGFxHUDContainer
// 0x00E8 (0x05C0 - 0x04D8)
class UGbxGFxHUDContainer : public UGbxGFxMovie
{
public:
	uint8                                         Pad_4D8[0x38];                                     // 0x04D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxGFxHUDWidget*>               Widgets;                                           // 0x0510(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UGbxHUDData*                            HUDData;                                           // 0x0520(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxHUDFeedbackManager                 FeedbackManager;                                   // 0x0528(0x0068)(BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGbxPlayerController>    OwningPC;                                          // 0x0598(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AGbxHUD>                 OwningHUD;                                         // 0x05A0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   OwningPawn;                                        // 0x05A8(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bViewportNeedsRefresh;                             // 0x05B0(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFinishedInitializing;                             // 0x05B1(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B2[0xE];                                      // 0x05B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxHUDContainer">();
	}
	static class UGbxGFxHUDContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxHUDContainer>();
	}
};
static_assert(alignof(UGbxGFxHUDContainer) == 0x000008, "Wrong alignment on UGbxGFxHUDContainer");
static_assert(sizeof(UGbxGFxHUDContainer) == 0x0005C0, "Wrong size on UGbxGFxHUDContainer");
static_assert(offsetof(UGbxGFxHUDContainer, Widgets) == 0x000510, "Member 'UGbxGFxHUDContainer::Widgets' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, HUDData) == 0x000520, "Member 'UGbxGFxHUDContainer::HUDData' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, FeedbackManager) == 0x000528, "Member 'UGbxGFxHUDContainer::FeedbackManager' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, OwningPC) == 0x000598, "Member 'UGbxGFxHUDContainer::OwningPC' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, OwningHUD) == 0x0005A0, "Member 'UGbxGFxHUDContainer::OwningHUD' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, OwningPawn) == 0x0005A8, "Member 'UGbxGFxHUDContainer::OwningPawn' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, bViewportNeedsRefresh) == 0x0005B0, "Member 'UGbxGFxHUDContainer::bViewportNeedsRefresh' has a wrong offset!");
static_assert(offsetof(UGbxGFxHUDContainer, bFinishedInitializing) == 0x0005B1, "Member 'UGbxGFxHUDContainer::bFinishedInitializing' has a wrong offset!");

// Class GbxUI.GbxUILibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxUILibrary : public UBlueprintFunctionLibrary
{
public:
	static class FString AbbreviateNumberText(float ValueToFormat);
	static class UGbxListItemBoolean* CreateBooleanListItem(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, bool InitialValue);
	static class UGbxListItemBoolean* CreateBooleanListItemWithDelegates(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, bool InitialValue, TDelegate<void(class UGbxListItem* Item)> ChangedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	static class UGbxListItemComboBox* CreateComboBoxListItem(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, const TArray<class FText>& Items, int32 InitialIndex);
	static class UGbxListItemComboBox* CreateComboBoxListItemWithDelegates(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, const TArray<class FText>& Items, int32 InitialIndex, TDelegate<void(class UGbxListItem* Item)> ChangedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	static class UGbxListItem* CreateDefaultListItem(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer);
	static class UGbxListItem* CreateDefaultListItemWithDelegates(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> ClickedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	static class UGbxListItem* CreateListItem(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, TSubclassOf<class UGbxListItem> ItemClass);
	static class UGbxListItem* CreateListItemWithDelegates(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, TSubclassOf<class UGbxListItem> ItemClass, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> ClickedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	static class UGbxListItemNumber* CreateNumberListItem(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, float InitialValue, float SliderMin, float SliderMax, float SliderStep);
	static class UGbxListItemNumber* CreateNumberListItemWithDelegates(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, float InitialValue, float SliderMin, float SliderMax, float SliderStep, TDelegate<void(class UGbxListItem* Item)> ChangedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	static class UGbxListItemText* CreateTextListItem(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText);
	static class UGbxListItemText* CreateTextListItemWithDelegates(TScriptInterface<class IGbxList> OwningList, class APlayerController* OwningPlayer, const class FText& LabelText, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> ClickedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	static class UGbxFullScreenMovie* PlayFullScreenMovie(class AGbxPlayerController* GbxPC, class UMediaSource* MediaSource, bool bPlayOnceAndDestroy);
	static void SendTextToDebugHUD(const class UObject* WorldContextObject, const class FText& Text, const struct FLinearColor& Color, int32 TextSize, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUILibrary">();
	}
	static class UGbxUILibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUILibrary>();
	}
};
static_assert(alignof(UGbxUILibrary) == 0x000008, "Wrong alignment on UGbxUILibrary");
static_assert(sizeof(UGbxUILibrary) == 0x000028, "Wrong size on UGbxUILibrary");

// Class GbxUI.GbxFocusableWidgetStyleData
// 0x0190 (0x01C0 - 0x0030)
class UGbxFocusableWidgetStyleData final : public UGbxDataAsset
{
public:
	TArray<struct FGbxFocusableWidgetItemStyle>   Styles;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGbxFocusableWidgetItemStyle           DefaultFocusedStyle;                               // 0x0040(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGbxFocusableWidgetItemStyle           DefaultNotFocusedStyle;                            // 0x0100(0x00C0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxFocusableWidgetStyleData">();
	}
	static class UGbxFocusableWidgetStyleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxFocusableWidgetStyleData>();
	}
};
static_assert(alignof(UGbxFocusableWidgetStyleData) == 0x000008, "Wrong alignment on UGbxFocusableWidgetStyleData");
static_assert(sizeof(UGbxFocusableWidgetStyleData) == 0x0001C0, "Wrong size on UGbxFocusableWidgetStyleData");
static_assert(offsetof(UGbxFocusableWidgetStyleData, Styles) == 0x000030, "Member 'UGbxFocusableWidgetStyleData::Styles' has a wrong offset!");
static_assert(offsetof(UGbxFocusableWidgetStyleData, DefaultFocusedStyle) == 0x000040, "Member 'UGbxFocusableWidgetStyleData::DefaultFocusedStyle' has a wrong offset!");
static_assert(offsetof(UGbxFocusableWidgetStyleData, DefaultNotFocusedStyle) == 0x000100, "Member 'UGbxFocusableWidgetStyleData::DefaultNotFocusedStyle' has a wrong offset!");

// Class GbxUI.GbxUIGlobals
// 0x0258 (0x0288 - 0x0030)
class UGbxUIGlobals : public UGbxDataAsset
{
public:
	class UGbxInputToGlyphMap*                    InputToGlyphMap;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxPlatformToGlyphMap*                 PlatformToGlyphMap;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultPlatformGlyphHeight;                        // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxDialogBoxData*                      DialogBoxTemplates;                                // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxListItemFactory*                    DefaultListItemFactory;                            // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxFullScreenMovie>        FullScreenMovieWidget;                             // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaPlayer*                           FullScreenMediaPlayer;                             // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxHUDData*>                    PersistentWidgetGroups;                            // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        MaxWidgetLoadTimePerFrameInMs;                     // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxContextualMenuData*              GFxContextualMenuTemplate;                         // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MarkupStartCharacter;                              // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MarkupEndCharacter;                                // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FTextMarkupDictionaryEntry> MarkupDictionary;                                  // 0x00A8(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              DefaultGlyphSize;                                  // 0x00F8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GlyphMarkupStartCharacter;                         // 0x0100(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GlyphMarkupEndCharacter;                           // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FText>                ClosedCaptioningTable;                             // 0x0120(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGbxMenuData*>                   AlwaysLoadedGFxMenus;                              // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USwfMovie>>       AlwaysLoadedGFxMovies;                             // 0x0180(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         HintGlyphVSpace;                                   // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftClassPtr<class UClass>, struct FGbxMenuSplitscreenLayouts> SplitscreenLayouts;                                // 0x0198(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, struct FGbxDLCMenuSplitscreenLayouts> DLCSplitscreenLayouts;                             // 0x01E8(0x0050)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FSoftObjectPath, struct FGbxDLCMenuSplitscreenLayouts> SoftDLCSpltiscreenLayouts;                         // 0x0238(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUIGlobals">();
	}
	static class UGbxUIGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUIGlobals>();
	}
};
static_assert(alignof(UGbxUIGlobals) == 0x000008, "Wrong alignment on UGbxUIGlobals");
static_assert(sizeof(UGbxUIGlobals) == 0x000288, "Wrong size on UGbxUIGlobals");
static_assert(offsetof(UGbxUIGlobals, InputToGlyphMap) == 0x000030, "Member 'UGbxUIGlobals::InputToGlyphMap' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, PlatformToGlyphMap) == 0x000038, "Member 'UGbxUIGlobals::PlatformToGlyphMap' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, DefaultPlatformGlyphHeight) == 0x000040, "Member 'UGbxUIGlobals::DefaultPlatformGlyphHeight' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, DialogBoxTemplates) == 0x000048, "Member 'UGbxUIGlobals::DialogBoxTemplates' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, DefaultListItemFactory) == 0x000050, "Member 'UGbxUIGlobals::DefaultListItemFactory' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, FullScreenMovieWidget) == 0x000058, "Member 'UGbxUIGlobals::FullScreenMovieWidget' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, FullScreenMediaPlayer) == 0x000060, "Member 'UGbxUIGlobals::FullScreenMediaPlayer' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, PersistentWidgetGroups) == 0x000068, "Member 'UGbxUIGlobals::PersistentWidgetGroups' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, MaxWidgetLoadTimePerFrameInMs) == 0x000078, "Member 'UGbxUIGlobals::MaxWidgetLoadTimePerFrameInMs' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, GFxContextualMenuTemplate) == 0x000080, "Member 'UGbxUIGlobals::GFxContextualMenuTemplate' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, MarkupStartCharacter) == 0x000088, "Member 'UGbxUIGlobals::MarkupStartCharacter' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, MarkupEndCharacter) == 0x000098, "Member 'UGbxUIGlobals::MarkupEndCharacter' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, MarkupDictionary) == 0x0000A8, "Member 'UGbxUIGlobals::MarkupDictionary' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, DefaultGlyphSize) == 0x0000F8, "Member 'UGbxUIGlobals::DefaultGlyphSize' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, GlyphMarkupStartCharacter) == 0x000100, "Member 'UGbxUIGlobals::GlyphMarkupStartCharacter' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, GlyphMarkupEndCharacter) == 0x000110, "Member 'UGbxUIGlobals::GlyphMarkupEndCharacter' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, ClosedCaptioningTable) == 0x000120, "Member 'UGbxUIGlobals::ClosedCaptioningTable' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, AlwaysLoadedGFxMenus) == 0x000170, "Member 'UGbxUIGlobals::AlwaysLoadedGFxMenus' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, AlwaysLoadedGFxMovies) == 0x000180, "Member 'UGbxUIGlobals::AlwaysLoadedGFxMovies' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, HintGlyphVSpace) == 0x000190, "Member 'UGbxUIGlobals::HintGlyphVSpace' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, SplitscreenLayouts) == 0x000198, "Member 'UGbxUIGlobals::SplitscreenLayouts' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, DLCSplitscreenLayouts) == 0x0001E8, "Member 'UGbxUIGlobals::DLCSplitscreenLayouts' has a wrong offset!");
static_assert(offsetof(UGbxUIGlobals, SoftDLCSpltiscreenLayouts) == 0x000238, "Member 'UGbxUIGlobals::SoftDLCSpltiscreenLayouts' has a wrong offset!");

// Class GbxUI.GbxCascadingList
// 0x0060 (0x0318 - 0x02B8)
class UGbxCascadingList final : public UGbxUserWidget
{
public:
	TSubclassOf<class UGbxListItem>               DefaultListItemClass;                              // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxGridListWidget*>             ListViews;                                         // 0x02C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGbxCascadingListItemData& ItemData, class UGbxListItem* ItemView, class FName& ParentId)> OnItemSelected;                                    // 0x02D0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGbxCascadingListItemData& ItemData, class UGbxListItem* ItemView, class FName& ParentId)> OnItemClicked;                                     // 0x02E0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(struct FGbxCascadingListItemData& ItemData, class UGbxListItem* ItemView, class FName& ParentId)> OnItemCreated;                                     // 0x02F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxGridListWidget*                     ActiveList;                                        // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGbxCascadingListItemData>      NavigationStack;                                   // 0x0308(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Clear();
	void OnItemClicked_Internal(class UGbxListItem* Item);
	void OnItemSelected_Internal(class UGbxListItem* Item);
	void OnShiftListsBack();
	void OnShiftListsForward();
	void Pop();
	void PushItems(const TArray<struct FGbxCascadingListItemData>& Items);
	void SetActiveList(class UGbxGridListWidget* List);

	int32 GetStackDepth() const;
	bool HasItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCascadingList">();
	}
	static class UGbxCascadingList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCascadingList>();
	}
};
static_assert(alignof(UGbxCascadingList) == 0x000008, "Wrong alignment on UGbxCascadingList");
static_assert(sizeof(UGbxCascadingList) == 0x000318, "Wrong size on UGbxCascadingList");
static_assert(offsetof(UGbxCascadingList, DefaultListItemClass) == 0x0002B8, "Member 'UGbxCascadingList::DefaultListItemClass' has a wrong offset!");
static_assert(offsetof(UGbxCascadingList, ListViews) == 0x0002C0, "Member 'UGbxCascadingList::ListViews' has a wrong offset!");
static_assert(offsetof(UGbxCascadingList, OnItemSelected) == 0x0002D0, "Member 'UGbxCascadingList::OnItemSelected' has a wrong offset!");
static_assert(offsetof(UGbxCascadingList, OnItemClicked) == 0x0002E0, "Member 'UGbxCascadingList::OnItemClicked' has a wrong offset!");
static_assert(offsetof(UGbxCascadingList, OnItemCreated) == 0x0002F0, "Member 'UGbxCascadingList::OnItemCreated' has a wrong offset!");
static_assert(offsetof(UGbxCascadingList, ActiveList) == 0x000300, "Member 'UGbxCascadingList::ActiveList' has a wrong offset!");
static_assert(offsetof(UGbxCascadingList, NavigationStack) == 0x000308, "Member 'UGbxCascadingList::NavigationStack' has a wrong offset!");

// Class GbxUI.GbxComboBoxDropdownMenu
// 0x0028 (0x0318 - 0x02F0)
class UGbxComboBoxDropdownMenu final : public UGbxUmgMenu
{
public:
	TArray<struct FGbxComboBoxItemInfo>           ChoiceListArray;                                   // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UWidget*                                ChoiceListContainer;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGridListWidget*                     ChoiceList;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxComboBox>            ComboBoxOwner;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DismissWithoutChanging();
	void OnChoiceClicked(class UGbxListItem* ListItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxComboBoxDropdownMenu">();
	}
	static class UGbxComboBoxDropdownMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxComboBoxDropdownMenu>();
	}
};
static_assert(alignof(UGbxComboBoxDropdownMenu) == 0x000008, "Wrong alignment on UGbxComboBoxDropdownMenu");
static_assert(sizeof(UGbxComboBoxDropdownMenu) == 0x000318, "Wrong size on UGbxComboBoxDropdownMenu");
static_assert(offsetof(UGbxComboBoxDropdownMenu, ChoiceListArray) == 0x0002F0, "Member 'UGbxComboBoxDropdownMenu::ChoiceListArray' has a wrong offset!");
static_assert(offsetof(UGbxComboBoxDropdownMenu, ChoiceListContainer) == 0x000300, "Member 'UGbxComboBoxDropdownMenu::ChoiceListContainer' has a wrong offset!");
static_assert(offsetof(UGbxComboBoxDropdownMenu, ChoiceList) == 0x000308, "Member 'UGbxComboBoxDropdownMenu::ChoiceList' has a wrong offset!");
static_assert(offsetof(UGbxComboBoxDropdownMenu, ComboBoxOwner) == 0x000310, "Member 'UGbxComboBoxDropdownMenu::ComboBoxOwner' has a wrong offset!");

// Class GbxUI.GbxComboBox
// 0x0070 (0x0358 - 0x02E8)
class UGbxComboBox final : public UGbxListItem
{
public:
	TSubclassOf<class UGbxComboBoxDropdownMenu>   DropdownMenuClass;                                 // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DropdownMenuOffset;                                // 0x02F0(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 NewReferenceIndex)>      OnComboChoiceChanged;                              // 0x02F8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGbxComboBoxItemInfo>           ChoiceListArray;                                   // 0x0308(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         CurrentChoiceReferenceIndex;                       // 0x0318(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              LastKnownGeometry;                                 // 0x031C(0x0038)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComboBoxClicked(class UGbxUserWidget* Widget, const struct FGbxMenuInputEvent& InputInfo);

	int32 GetCurentChoiceReferenceIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxComboBox">();
	}
	static class UGbxComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxComboBox>();
	}
};
static_assert(alignof(UGbxComboBox) == 0x000008, "Wrong alignment on UGbxComboBox");
static_assert(sizeof(UGbxComboBox) == 0x000358, "Wrong size on UGbxComboBox");
static_assert(offsetof(UGbxComboBox, DropdownMenuClass) == 0x0002E8, "Member 'UGbxComboBox::DropdownMenuClass' has a wrong offset!");
static_assert(offsetof(UGbxComboBox, DropdownMenuOffset) == 0x0002F0, "Member 'UGbxComboBox::DropdownMenuOffset' has a wrong offset!");
static_assert(offsetof(UGbxComboBox, OnComboChoiceChanged) == 0x0002F8, "Member 'UGbxComboBox::OnComboChoiceChanged' has a wrong offset!");
static_assert(offsetof(UGbxComboBox, ChoiceListArray) == 0x000308, "Member 'UGbxComboBox::ChoiceListArray' has a wrong offset!");
static_assert(offsetof(UGbxComboBox, CurrentChoiceReferenceIndex) == 0x000318, "Member 'UGbxComboBox::CurrentChoiceReferenceIndex' has a wrong offset!");
static_assert(offsetof(UGbxComboBox, LastKnownGeometry) == 0x00031C, "Member 'UGbxComboBox::LastKnownGeometry' has a wrong offset!");

// Class GbxUI.GbxDialogBoxData
// 0x0070 (0x00C8 - 0x0058)
class UGbxDialogBoxData final : public UGbxUmgMenuData
{
public:
	struct FGbxDialogBoxInfo                      DialogInfo;                                        // 0x0058(0x0060)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FGbxDialogBoxTemplateMapItem>   Templates;                                         // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDialogBoxData">();
	}
	static class UGbxDialogBoxData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDialogBoxData>();
	}
};
static_assert(alignof(UGbxDialogBoxData) == 0x000008, "Wrong alignment on UGbxDialogBoxData");
static_assert(sizeof(UGbxDialogBoxData) == 0x0000C8, "Wrong size on UGbxDialogBoxData");
static_assert(offsetof(UGbxDialogBoxData, DialogInfo) == 0x000058, "Member 'UGbxDialogBoxData::DialogInfo' has a wrong offset!");
static_assert(offsetof(UGbxDialogBoxData, Templates) == 0x0000B8, "Member 'UGbxDialogBoxData::Templates' has a wrong offset!");

// Class GbxUI.GbxDialogBox
// 0x00E0 (0x03D0 - 0x02F0)
class UGbxDialogBox final : public UGbxUmgMenu
{
public:
	bool                                          bWantsToDismiss;                                   // 0x02F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeaderText;                                        // 0x02F8(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class FText                                   BodyText;                                          // 0x0310(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0xA0];                                     // 0x0328(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxScrollBoxList*                      ChoiceList;                                        // 0x03C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Dismiss();
	void OnChoiceClicked(class UGbxListItem* ClickedItem);
	void SetBodyText(const class FText& NewText, bool bClearFormatArgs);
	void SetBodyTextFormatArg(const class FString& ArgName, const class FText& ReplacementText);
	void SetHeaderText(const class FText& NewText, bool bClearFormatArgs);
	void SetHeaderTextFormatArg(const class FString& ArgName, const class FText& ReplacementText);
	void SetupDialog(const struct FGbxDialogBoxInfo& DialogBoxInfo);
	void UpdateText(const class FText& NewHeaderText, const class FText& NewBodyText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDialogBox">();
	}
	static class UGbxDialogBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDialogBox>();
	}
};
static_assert(alignof(UGbxDialogBox) == 0x000008, "Wrong alignment on UGbxDialogBox");
static_assert(sizeof(UGbxDialogBox) == 0x0003D0, "Wrong size on UGbxDialogBox");
static_assert(offsetof(UGbxDialogBox, bWantsToDismiss) == 0x0002F0, "Member 'UGbxDialogBox::bWantsToDismiss' has a wrong offset!");
static_assert(offsetof(UGbxDialogBox, HeaderText) == 0x0002F8, "Member 'UGbxDialogBox::HeaderText' has a wrong offset!");
static_assert(offsetof(UGbxDialogBox, BodyText) == 0x000310, "Member 'UGbxDialogBox::BodyText' has a wrong offset!");
static_assert(offsetof(UGbxDialogBox, ChoiceList) == 0x0003C8, "Member 'UGbxDialogBox::ChoiceList' has a wrong offset!");

// Class GbxUI.GbxDialogBoxChoiceWidget
// 0x0008 (0x02F0 - 0x02E8)
class UGbxDialogBoxChoiceWidget final : public UGbxListItem
{
public:
	class FName                                   ChoiceNameId;                                      // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDialogBoxChoiceWidget">();
	}
	static class UGbxDialogBoxChoiceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxDialogBoxChoiceWidget>();
	}
};
static_assert(alignof(UGbxDialogBoxChoiceWidget) == 0x000008, "Wrong alignment on UGbxDialogBoxChoiceWidget");
static_assert(sizeof(UGbxDialogBoxChoiceWidget) == 0x0002F0, "Wrong size on UGbxDialogBoxChoiceWidget");
static_assert(offsetof(UGbxDialogBoxChoiceWidget, ChoiceNameId) == 0x0002E8, "Member 'UGbxDialogBoxChoiceWidget::ChoiceNameId' has a wrong offset!");

// Class GbxUI.GbxDragDropContainerInterface
// 0x0000 (0x0028 - 0x0028)
class IGbxDragDropContainerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxDragDropContainerInterface">();
	}
	static class IGbxDragDropContainerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxDragDropContainerInterface>();
	}
};
static_assert(alignof(IGbxDragDropContainerInterface) == 0x000008, "Wrong alignment on IGbxDragDropContainerInterface");
static_assert(sizeof(IGbxDragDropContainerInterface) == 0x000028, "Wrong size on IGbxDragDropContainerInterface");

// Class GbxUI.GbxGFxContextualMenu
// 0x00E0 (0x0760 - 0x0680)
class UGbxGFxContextualMenu final : public UGbxGFxMenu
{
public:
	TArray<struct FGbxGFxContextualMenuLocTableData> LocTable;                                          // 0x0680(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGFxObject*                             ContextualMenu;                                    // 0x0690(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGFxGridScrollingList*               ContentPanel;                                      // 0x0698(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxTextField*                          ToolTipsTextField;                                 // 0x06A0(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x20];                                     // 0x06A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RemoveFriendText;                                  // 0x06C8(0x0018)(BlueprintReadOnly, Config, NativeAccessSpecifierPrivate)
	class FText                                   AddShiftFriendText;                                // 0x06E0(0x0018)(BlueprintReadOnly, Config, NativeAccessSpecifierPrivate)
	class FText                                   RemoveShiftFriendText;                             // 0x06F8(0x0018)(BlueprintReadOnly, Config, NativeAccessSpecifierPrivate)
	class FText                                   BlockShiftUserText;                                // 0x0710(0x0018)(BlueprintReadOnly, Config, NativeAccessSpecifierPrivate)
	class FText                                   UnblockShiftUserText;                              // 0x0728(0x0018)(BlueprintReadOnly, Config, NativeAccessSpecifierPrivate)
	class FText                                   ReportShiftPlayerText;                             // 0x0740(0x0018)(BlueprintReadOnly, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnContextualMenuItemClicked(class UGbxGFxButton* PressedButton, const struct FGbxMenuInputEvent& InputInfo) const;
	void OnSelectionChanged(class UGbxGFxListCell* Item) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxContextualMenu">();
	}
	static class UGbxGFxContextualMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxContextualMenu>();
	}
};
static_assert(alignof(UGbxGFxContextualMenu) == 0x000008, "Wrong alignment on UGbxGFxContextualMenu");
static_assert(sizeof(UGbxGFxContextualMenu) == 0x000760, "Wrong size on UGbxGFxContextualMenu");
static_assert(offsetof(UGbxGFxContextualMenu, LocTable) == 0x000680, "Member 'UGbxGFxContextualMenu::LocTable' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, ContextualMenu) == 0x000690, "Member 'UGbxGFxContextualMenu::ContextualMenu' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, ContentPanel) == 0x000698, "Member 'UGbxGFxContextualMenu::ContentPanel' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, ToolTipsTextField) == 0x0006A0, "Member 'UGbxGFxContextualMenu::ToolTipsTextField' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, RemoveFriendText) == 0x0006C8, "Member 'UGbxGFxContextualMenu::RemoveFriendText' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, AddShiftFriendText) == 0x0006E0, "Member 'UGbxGFxContextualMenu::AddShiftFriendText' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, RemoveShiftFriendText) == 0x0006F8, "Member 'UGbxGFxContextualMenu::RemoveShiftFriendText' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, BlockShiftUserText) == 0x000710, "Member 'UGbxGFxContextualMenu::BlockShiftUserText' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, UnblockShiftUserText) == 0x000728, "Member 'UGbxGFxContextualMenu::UnblockShiftUserText' has a wrong offset!");
static_assert(offsetof(UGbxGFxContextualMenu, ReportShiftPlayerText) == 0x000740, "Member 'UGbxGFxContextualMenu::ReportShiftPlayerText' has a wrong offset!");

// Class GbxUI.GbxGFxContextualMenuHelpers
// 0x0000 (0x0028 - 0x0028)
class UGbxGFxContextualMenuHelpers final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxContextualMenuHelpers">();
	}
	static class UGbxGFxContextualMenuHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxContextualMenuHelpers>();
	}
};
static_assert(alignof(UGbxGFxContextualMenuHelpers) == 0x000008, "Wrong alignment on UGbxGFxContextualMenuHelpers");
static_assert(sizeof(UGbxGFxContextualMenuHelpers) == 0x000028, "Wrong size on UGbxGFxContextualMenuHelpers");

// Class GbxUI.GbxGFxDragDropManager
// 0x0088 (0x00B0 - 0x0028)
class UGbxGFxDragDropManager final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDropButtonHovered(class UGbxGFxButton* HoveredButton, const struct FGbxMenuInputEvent& InputInfo);
	void OnDropButtonUnhovered(class UGbxGFxButton* UnhoveredButton, const struct FGbxMenuInputEvent& InputInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxDragDropManager">();
	}
	static class UGbxGFxDragDropManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxDragDropManager>();
	}
};
static_assert(alignof(UGbxGFxDragDropManager) == 0x000008, "Wrong alignment on UGbxGFxDragDropManager");
static_assert(sizeof(UGbxGFxDragDropManager) == 0x0000B0, "Wrong size on UGbxGFxDragDropManager");

// Class GbxUI.GbxGFxHintWidget
// 0x00C8 (0x03D0 - 0x0308)
class UGbxGFxHintWidget final : public UGbxGFxListCell
{
public:
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGbxHintBar>             HintBarOwnerBar;                                   // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGbxPlayerController>    HintBarOwnerPC;                                    // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxHintInfo                           HintBarHintInfo;                                   // 0x0320(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxTextField*                          HintText;                                          // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          HoldToPressBar;                                    // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxProgressBar*                     HoldToPressGamepad;                                // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxProgressBar*                     HoldToPressKeyboard;                               // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxProgressBar*                     HoldToPressKeyboardWide;                           // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxProgressBar*                     HoldToPressKeyboardXWide;                          // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          HintCaret;                                         // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasInitialHintTextWidth;                          // 0x03B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialHintTextWidth;                              // 0x03B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHoldToPressGlyphType                         HoldToPressType;                                   // 0x03B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ManualPressToHoldProgress;                         // 0x03BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasBroadcastPressToHoldEvent;                     // 0x03C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHintVisible;                                    // 0x03C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAvailable;                                      // 0x03C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputNeedsResetBeforeShowingProgress;             // 0x03C3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExternalHintHeldProgress;                          // 0x03C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnThisHintClicked(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxHintWidget">();
	}
	static class UGbxGFxHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxHintWidget>();
	}
};
static_assert(alignof(UGbxGFxHintWidget) == 0x000008, "Wrong alignment on UGbxGFxHintWidget");
static_assert(sizeof(UGbxGFxHintWidget) == 0x0003D0, "Wrong size on UGbxGFxHintWidget");
static_assert(offsetof(UGbxGFxHintWidget, HintBarOwnerBar) == 0x000310, "Member 'UGbxGFxHintWidget::HintBarOwnerBar' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HintBarOwnerPC) == 0x000318, "Member 'UGbxGFxHintWidget::HintBarOwnerPC' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HintBarHintInfo) == 0x000320, "Member 'UGbxGFxHintWidget::HintBarHintInfo' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HintText) == 0x000378, "Member 'UGbxGFxHintWidget::HintText' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HoldToPressBar) == 0x000380, "Member 'UGbxGFxHintWidget::HoldToPressBar' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HoldToPressGamepad) == 0x000388, "Member 'UGbxGFxHintWidget::HoldToPressGamepad' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HoldToPressKeyboard) == 0x000390, "Member 'UGbxGFxHintWidget::HoldToPressKeyboard' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HoldToPressKeyboardWide) == 0x000398, "Member 'UGbxGFxHintWidget::HoldToPressKeyboardWide' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HoldToPressKeyboardXWide) == 0x0003A0, "Member 'UGbxGFxHintWidget::HoldToPressKeyboardXWide' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HintCaret) == 0x0003A8, "Member 'UGbxGFxHintWidget::HintCaret' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, bHasInitialHintTextWidth) == 0x0003B0, "Member 'UGbxGFxHintWidget::bHasInitialHintTextWidth' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, InitialHintTextWidth) == 0x0003B4, "Member 'UGbxGFxHintWidget::InitialHintTextWidth' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, HoldToPressType) == 0x0003B8, "Member 'UGbxGFxHintWidget::HoldToPressType' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, ManualPressToHoldProgress) == 0x0003BC, "Member 'UGbxGFxHintWidget::ManualPressToHoldProgress' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, bHasBroadcastPressToHoldEvent) == 0x0003C0, "Member 'UGbxGFxHintWidget::bHasBroadcastPressToHoldEvent' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, bIsHintVisible) == 0x0003C1, "Member 'UGbxGFxHintWidget::bIsHintVisible' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, bIsAvailable) == 0x0003C2, "Member 'UGbxGFxHintWidget::bIsAvailable' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, bInputNeedsResetBeforeShowingProgress) == 0x0003C3, "Member 'UGbxGFxHintWidget::bInputNeedsResetBeforeShowingProgress' has a wrong offset!");
static_assert(offsetof(UGbxGFxHintWidget, ExternalHintHeldProgress) == 0x0003C4, "Member 'UGbxGFxHintWidget::ExternalHintHeldProgress' has a wrong offset!");

// Class GbxUI.GbxGFxListItemComboBox
// 0x0038 (0x0350 - 0x0318)
class UGbxGFxListItemComboBox final : public UGbxGFxListCellWithData
{
public:
	class UGbxGFxDropDownList*                    DropDownListItem;                                  // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDropDownButtonClicked();
	void OnOwningListSelectionChanged(class UGbxGFxListCell* Item);
	void OnSelectionUpdated(class UGbxGFxListCell* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxListItemComboBox">();
	}
	static class UGbxGFxListItemComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxListItemComboBox>();
	}
};
static_assert(alignof(UGbxGFxListItemComboBox) == 0x000008, "Wrong alignment on UGbxGFxListItemComboBox");
static_assert(sizeof(UGbxGFxListItemComboBox) == 0x000350, "Wrong size on UGbxGFxListItemComboBox");
static_assert(offsetof(UGbxGFxListItemComboBox, DropDownListItem) == 0x000318, "Member 'UGbxGFxListItemComboBox::DropDownListItem' has a wrong offset!");

// Class GbxUI.GbxGFxListItemControls
// 0x0088 (0x03A0 - 0x0318)
class UGbxGFxListItemControls final : public UGbxGFxListCellWithData
{
public:
	uint8                                         Pad_318[0x48];                                     // 0x0318(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxTextField*                          TitleItem;                                         // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGFxObject*                          BadBindingIcon;                                    // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGFxObject*                          RebindButton;                                      // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGFxObject*                          LinkedRebindButton;                                // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x20];                                     // 0x0380(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxListItemControls">();
	}
	static class UGbxGFxListItemControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxListItemControls>();
	}
};
static_assert(alignof(UGbxGFxListItemControls) == 0x000008, "Wrong alignment on UGbxGFxListItemControls");
static_assert(sizeof(UGbxGFxListItemControls) == 0x0003A0, "Wrong size on UGbxGFxListItemControls");
static_assert(offsetof(UGbxGFxListItemControls, TitleItem) == 0x000360, "Member 'UGbxGFxListItemControls::TitleItem' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemControls, BadBindingIcon) == 0x000368, "Member 'UGbxGFxListItemControls::BadBindingIcon' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemControls, RebindButton) == 0x000370, "Member 'UGbxGFxListItemControls::RebindButton' has a wrong offset!");
static_assert(offsetof(UGbxGFxListItemControls, LinkedRebindButton) == 0x000378, "Member 'UGbxGFxListItemControls::LinkedRebindButton' has a wrong offset!");

// Class GbxUI.GbxGFxMediaPlayer
// 0x0070 (0x0098 - 0x0028)
class UGbxGFxMediaPlayer final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnMovieStartedPlaying;                             // 0x0028(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMovieStoppedPlaying;                             // 0x0038(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	struct FGbxGFxMediaPlayerConfig               PlayerConfig;                                      // 0x0048(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FGbxGFxMaterialRenderer                MaterialRenderer;                                  // 0x0078(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GbxGFxMediaPlayerEvent__DelegateSignature();
	void OnMovieEndReached();
	void OnMovieMediaClosed();
	void OnMovieMediaOpened(const class FString& OpenedUrl);
	void OnMovieMediaOpenFailed(const class FString& FailedUrl);
	void OnMoviePlaybackResumed();
	void OnMoviePlaybackSuspended();
	void OnMovieSeekCompleted();
	void OnMovieTracksChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMediaPlayer">();
	}
	static class UGbxGFxMediaPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMediaPlayer>();
	}
};
static_assert(alignof(UGbxGFxMediaPlayer) == 0x000008, "Wrong alignment on UGbxGFxMediaPlayer");
static_assert(sizeof(UGbxGFxMediaPlayer) == 0x000098, "Wrong size on UGbxGFxMediaPlayer");
static_assert(offsetof(UGbxGFxMediaPlayer, OnMovieStartedPlaying) == 0x000028, "Member 'UGbxGFxMediaPlayer::OnMovieStartedPlaying' has a wrong offset!");
static_assert(offsetof(UGbxGFxMediaPlayer, OnMovieStoppedPlaying) == 0x000038, "Member 'UGbxGFxMediaPlayer::OnMovieStoppedPlaying' has a wrong offset!");
static_assert(offsetof(UGbxGFxMediaPlayer, PlayerConfig) == 0x000048, "Member 'UGbxGFxMediaPlayer::PlayerConfig' has a wrong offset!");
static_assert(offsetof(UGbxGFxMediaPlayer, MaterialRenderer) == 0x000078, "Member 'UGbxGFxMediaPlayer::MaterialRenderer' has a wrong offset!");
static_assert(offsetof(UGbxGFxMediaPlayer, MediaPlayer) == 0x000090, "Member 'UGbxGFxMediaPlayer::MediaPlayer' has a wrong offset!");

// Class GbxUI.GbxGFxMenuSwitcherNavWidget
// 0x0090 (0x0200 - 0x0170)
class UGbxGFxMenuSwitcherNavWidget final : public UGbxGFxObject
{
public:
	TDelegate<void(class FName ItemId)>           OnNavTabClickedDelegate;                           // 0x0170(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxGFxHintWidget*                      PrevTabHintClip;                                   // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGFxHintWidget*                      NextTabHintClip;                                   // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGFxGridScrollingList*               NavListClip;                                       // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x30];                                     // 0x0198(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxGFxMenuSwitchNavWidgetType                NavType;                                           // 0x01C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxGFxMenuSwitcherSubmenuInfo> NavListSubmenuDatas;                               // 0x01D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGbxGFxMenuSwitcherNavWidgetCustomItem> NavListItemDatas;                                  // 0x01E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTabClicked(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMenuSwitcherNavWidget">();
	}
	static class UGbxGFxMenuSwitcherNavWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMenuSwitcherNavWidget>();
	}
};
static_assert(alignof(UGbxGFxMenuSwitcherNavWidget) == 0x000008, "Wrong alignment on UGbxGFxMenuSwitcherNavWidget");
static_assert(sizeof(UGbxGFxMenuSwitcherNavWidget) == 0x000200, "Wrong size on UGbxGFxMenuSwitcherNavWidget");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, OnNavTabClickedDelegate) == 0x000170, "Member 'UGbxGFxMenuSwitcherNavWidget::OnNavTabClickedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, PrevTabHintClip) == 0x000180, "Member 'UGbxGFxMenuSwitcherNavWidget::PrevTabHintClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, NextTabHintClip) == 0x000188, "Member 'UGbxGFxMenuSwitcherNavWidget::NextTabHintClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, NavListClip) == 0x000190, "Member 'UGbxGFxMenuSwitcherNavWidget::NavListClip' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, NavType) == 0x0001C8, "Member 'UGbxGFxMenuSwitcherNavWidget::NavType' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, NavListSubmenuDatas) == 0x0001D0, "Member 'UGbxGFxMenuSwitcherNavWidget::NavListSubmenuDatas' has a wrong offset!");
static_assert(offsetof(UGbxGFxMenuSwitcherNavWidget, NavListItemDatas) == 0x0001E0, "Member 'UGbxGFxMenuSwitcherNavWidget::NavListItemDatas' has a wrong offset!");

// Class GbxUI.GbxGFxSprite
// 0x0008 (0x0178 - 0x0170)
#pragma pack(push, 0x1)
class alignas(0x08) UGbxGFxSprite : public UGbxGFxObject
{
public:
	class UGbxGFxObject*                          Graphics;                                          // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxSprite">();
	}
	static class UGbxGFxSprite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxSprite>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxGFxSprite) == 0x000008, "Wrong alignment on UGbxGFxSprite");
static_assert(sizeof(UGbxGFxSprite) == 0x000178, "Wrong size on UGbxGFxSprite");
static_assert(offsetof(UGbxGFxSprite, Graphics) == 0x000170, "Member 'UGbxGFxSprite::Graphics' has a wrong offset!");

// Class GbxUI.GbxGFxMouseBlocker
// 0x0008 (0x0180 - 0x0178)
class UGbxGFxMouseBlocker final : public UGbxGFxSprite
{
public:
	bool                                          bIsBlocking;                                       // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMouseBlocker">();
	}
	static class UGbxGFxMouseBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMouseBlocker>();
	}
};
static_assert(alignof(UGbxGFxMouseBlocker) == 0x000008, "Wrong alignment on UGbxGFxMouseBlocker");
static_assert(sizeof(UGbxGFxMouseBlocker) == 0x000180, "Wrong size on UGbxGFxMouseBlocker");
static_assert(offsetof(UGbxGFxMouseBlocker, bIsBlocking) == 0x000178, "Member 'UGbxGFxMouseBlocker::bIsBlocking' has a wrong offset!");

// Class GbxUI.GbxGFxMouseCapturePanel
// 0x00E0 (0x0250 - 0x0170)
class UGbxGFxMouseCapturePanel final : public UGbxGFxObject
{
public:
	uint8                                         Pad_170[0xE0];                                     // 0x0170(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxMouseCapturePanel">();
	}
	static class UGbxGFxMouseCapturePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxMouseCapturePanel>();
	}
};
static_assert(alignof(UGbxGFxMouseCapturePanel) == 0x000008, "Wrong alignment on UGbxGFxMouseCapturePanel");
static_assert(sizeof(UGbxGFxMouseCapturePanel) == 0x000250, "Wrong size on UGbxGFxMouseCapturePanel");

// Class GbxUI.GbxGFxSlider
// 0x00C8 (0x0390 - 0x02C8)
class UGbxGFxSlider final : public UGbxGFxButton
{
public:
	struct FGbxGFxSliderAcceleration              SliderAcceleration;                                // 0x02C8(0x0010)(Config, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxGFxButton*                          UpOrLeftButton;                                    // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxButton*                          DownOrRightButton;                                 // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxButton*                          SliderThumb;                                       // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxButton*                          SliderTrack;                                       // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          SliderTrackButton;                                 // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          MaskFill;                                          // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxGFxObject*                          SliderDefaultThumb;                                // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x80];                                     // 0x0310(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginLeftSlide(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);
	void BeginRightSlide(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);
	void EndSlide(class UGbxGFxButton* BUTTON, const struct FGbxMenuInputEvent& InputInfo);
	void GbxGFxSliderUpdateEvent__DelegateSignature(float SliderPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxSlider">();
	}
	static class UGbxGFxSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxSlider>();
	}
};
static_assert(alignof(UGbxGFxSlider) == 0x000008, "Wrong alignment on UGbxGFxSlider");
static_assert(sizeof(UGbxGFxSlider) == 0x000390, "Wrong size on UGbxGFxSlider");
static_assert(offsetof(UGbxGFxSlider, SliderAcceleration) == 0x0002C8, "Member 'UGbxGFxSlider::SliderAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, UpOrLeftButton) == 0x0002D8, "Member 'UGbxGFxSlider::UpOrLeftButton' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, DownOrRightButton) == 0x0002E0, "Member 'UGbxGFxSlider::DownOrRightButton' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, SliderThumb) == 0x0002E8, "Member 'UGbxGFxSlider::SliderThumb' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, SliderTrack) == 0x0002F0, "Member 'UGbxGFxSlider::SliderTrack' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, SliderTrackButton) == 0x0002F8, "Member 'UGbxGFxSlider::SliderTrackButton' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, MaskFill) == 0x000300, "Member 'UGbxGFxSlider::MaskFill' has a wrong offset!");
static_assert(offsetof(UGbxGFxSlider, SliderDefaultThumb) == 0x000308, "Member 'UGbxGFxSlider::SliderDefaultThumb' has a wrong offset!");

// Class GbxUI.GbxGuidePanel
// 0x0000 (0x0128 - 0x0128)
class UGbxGuidePanel final : public UCanvasPanel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGuidePanel">();
	}
	static class UGbxGuidePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGuidePanel>();
	}
};
static_assert(alignof(UGbxGuidePanel) == 0x000008, "Wrong alignment on UGbxGuidePanel");
static_assert(sizeof(UGbxGuidePanel) == 0x000128, "Wrong size on UGbxGuidePanel");

// Class GbxUI.GbxHintBarWidgetContainer
// 0x0000 (0x0028 - 0x0028)
class IGbxHintBarWidgetContainer final : public IInterface
{
public:
	void HintBarAppendHint(const struct FGbxHintInfo& HintInfo);
	void HintBarClearAllHints();
	void HintBarInitOwnerInfo(class UGbxHintBar* HintBarOwner, const class AGbxPlayerController* PlayerControllerContext);
	void HintBarSetVisible(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHintBarWidgetContainer">();
	}
	static class IGbxHintBarWidgetContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxHintBarWidgetContainer>();
	}
};
static_assert(alignof(IGbxHintBarWidgetContainer) == 0x000008, "Wrong alignment on IGbxHintBarWidgetContainer");
static_assert(sizeof(IGbxHintBarWidgetContainer) == 0x000028, "Wrong size on IGbxHintBarWidgetContainer");

// Class GbxUI.GbxHintBar
// 0x0080 (0x00A8 - 0x0028)
class UGbxHintBar final : public UObject
{
public:
	class UObject*                                Container;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IGbxHintBarWidgetContainer> ContainerInterface;                                // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGbxMenu>              MenuOwner;                                         // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGbxHintInfo>                   HintInfos;                                         // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxHintWidgetMapItem>          StagePlacedHints;                                  // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAreHintsVisible;                                  // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInputBlocked;                                   // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideOnOwnerMenuDeactivate;                        // 0x00A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendInputActionEvenIfOwnerIsDeactivated;          // 0x00A3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHintClicked(const class FName& InputAction, bool bHeld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHintBar">();
	}
	static class UGbxHintBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxHintBar>();
	}
};
static_assert(alignof(UGbxHintBar) == 0x000008, "Wrong alignment on UGbxHintBar");
static_assert(sizeof(UGbxHintBar) == 0x0000A8, "Wrong size on UGbxHintBar");
static_assert(offsetof(UGbxHintBar, Container) == 0x000028, "Member 'UGbxHintBar::Container' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, ContainerInterface) == 0x000040, "Member 'UGbxHintBar::ContainerInterface' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, MenuOwner) == 0x000050, "Member 'UGbxHintBar::MenuOwner' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, HintInfos) == 0x000060, "Member 'UGbxHintBar::HintInfos' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, StagePlacedHints) == 0x000080, "Member 'UGbxHintBar::StagePlacedHints' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, bAreHintsVisible) == 0x0000A0, "Member 'UGbxHintBar::bAreHintsVisible' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, bIsInputBlocked) == 0x0000A1, "Member 'UGbxHintBar::bIsInputBlocked' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, bHideOnOwnerMenuDeactivate) == 0x0000A2, "Member 'UGbxHintBar::bHideOnOwnerMenuDeactivate' has a wrong offset!");
static_assert(offsetof(UGbxHintBar, bSendInputActionEvenIfOwnerIsDeactivated) == 0x0000A3, "Member 'UGbxHintBar::bSendInputActionEvenIfOwnerIsDeactivated' has a wrong offset!");

// Class GbxUI.GbxHintWidget
// 0x0000 (0x0028 - 0x0028)
class IGbxHintWidget final : public IInterface
{
public:
	void HintWidgetInitOwnerInfo(class UGbxHintBar* HintBarOwner, const class AGbxPlayerController* PlayerControllerContext);
	void HintWidgetSetInfo(const struct FGbxHintInfo& HintInfo);
	void HintWidgetSetVisible(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHintWidget">();
	}
	static class IGbxHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxHintWidget>();
	}
};
static_assert(alignof(IGbxHintWidget) == 0x000008, "Wrong alignment on IGbxHintWidget");
static_assert(sizeof(IGbxHintWidget) == 0x000028, "Wrong size on IGbxHintWidget");

// Class GbxUI.GbxHUDData
// 0x00A8 (0x00D8 - 0x0030)
class UGbxHUDData final : public UGbxDataAsset
{
public:
	TSubclassOf<class UGbxGFxHUDContainer>        ContainerClass;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxGFxHUDWidgetInfo>           Widgets;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      StandardLayout;                                    // 0x0048(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      TwoPlayerHorizontalLayout;                         // 0x0058(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      TwoPlayerVerticalLayout;                           // 0x0068(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      FourPlayerLayout;                                  // 0x0078(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      StandardLayoutGearUpMode;                          // 0x0088(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      TwoPlayerHorizontalLayoutGearUpMode;               // 0x0098(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      TwoPlayerVerticalLayoutGearUpMode;                 // 0x00A8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxHUDLayoutData                      FourPlayerLayoutGearUpMode;                        // 0x00B8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxGFxHUDFeedbackData*                 FeedbackData;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxHUDStateData*                       StartState;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHUDData">();
	}
	static class UGbxHUDData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxHUDData>();
	}
};
static_assert(alignof(UGbxHUDData) == 0x000008, "Wrong alignment on UGbxHUDData");
static_assert(sizeof(UGbxHUDData) == 0x0000D8, "Wrong size on UGbxHUDData");
static_assert(offsetof(UGbxHUDData, ContainerClass) == 0x000030, "Member 'UGbxHUDData::ContainerClass' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, Widgets) == 0x000038, "Member 'UGbxHUDData::Widgets' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, StandardLayout) == 0x000048, "Member 'UGbxHUDData::StandardLayout' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, TwoPlayerHorizontalLayout) == 0x000058, "Member 'UGbxHUDData::TwoPlayerHorizontalLayout' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, TwoPlayerVerticalLayout) == 0x000068, "Member 'UGbxHUDData::TwoPlayerVerticalLayout' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, FourPlayerLayout) == 0x000078, "Member 'UGbxHUDData::FourPlayerLayout' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, StandardLayoutGearUpMode) == 0x000088, "Member 'UGbxHUDData::StandardLayoutGearUpMode' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, TwoPlayerHorizontalLayoutGearUpMode) == 0x000098, "Member 'UGbxHUDData::TwoPlayerHorizontalLayoutGearUpMode' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, TwoPlayerVerticalLayoutGearUpMode) == 0x0000A8, "Member 'UGbxHUDData::TwoPlayerVerticalLayoutGearUpMode' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, FourPlayerLayoutGearUpMode) == 0x0000B8, "Member 'UGbxHUDData::FourPlayerLayoutGearUpMode' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, FeedbackData) == 0x0000C8, "Member 'UGbxHUDData::FeedbackData' has a wrong offset!");
static_assert(offsetof(UGbxHUDData, StartState) == 0x0000D0, "Member 'UGbxHUDData::StartState' has a wrong offset!");

// Class GbxUI.HUDDataProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IHUDDataProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDDataProviderInterface">();
	}
	static class IHUDDataProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDDataProviderInterface>();
	}
};
static_assert(alignof(IHUDDataProviderInterface) == 0x000008, "Wrong alignment on IHUDDataProviderInterface");
static_assert(sizeof(IHUDDataProviderInterface) == 0x000028, "Wrong size on IHUDDataProviderInterface");

// Class GbxUI.GbxGFxHUDFeedbackData
// 0x0010 (0x0098 - 0x0088)
class UGbxGFxHUDFeedbackData final : public UGbxHUDFeedbackData
{
public:
	TArray<TSoftClassPtr<class UClass>>           ValidWidgetTypes;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxGFxHUDFeedbackData">();
	}
	static class UGbxGFxHUDFeedbackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxGFxHUDFeedbackData>();
	}
};
static_assert(alignof(UGbxGFxHUDFeedbackData) == 0x000008, "Wrong alignment on UGbxGFxHUDFeedbackData");
static_assert(sizeof(UGbxGFxHUDFeedbackData) == 0x000098, "Wrong size on UGbxGFxHUDFeedbackData");
static_assert(offsetof(UGbxGFxHUDFeedbackData, ValidWidgetTypes) == 0x000088, "Member 'UGbxGFxHUDFeedbackData::ValidWidgetTypes' has a wrong offset!");

// Class GbxUI.GbxHUDStateData
// 0x0028 (0x0058 - 0x0030)
class UGbxHUDStateData final : public UGbxDataAsset
{
public:
	class FName                                   StateName;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDInitializationAnimationSet                InitializationAnimSet;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxHUDStateListType                          ListType;                                          // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ValidWidgetTypes;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          StayOnTopOfStack;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxHUDStateData">();
	}
	static class UGbxHUDStateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxHUDStateData>();
	}
};
static_assert(alignof(UGbxHUDStateData) == 0x000008, "Wrong alignment on UGbxHUDStateData");
static_assert(sizeof(UGbxHUDStateData) == 0x000058, "Wrong size on UGbxHUDStateData");
static_assert(offsetof(UGbxHUDStateData, StateName) == 0x000030, "Member 'UGbxHUDStateData::StateName' has a wrong offset!");
static_assert(offsetof(UGbxHUDStateData, InitializationAnimSet) == 0x000038, "Member 'UGbxHUDStateData::InitializationAnimSet' has a wrong offset!");
static_assert(offsetof(UGbxHUDStateData, ListType) == 0x000039, "Member 'UGbxHUDStateData::ListType' has a wrong offset!");
static_assert(offsetof(UGbxHUDStateData, ValidWidgetTypes) == 0x000040, "Member 'UGbxHUDStateData::ValidWidgetTypes' has a wrong offset!");
static_assert(offsetof(UGbxHUDStateData, StayOnTopOfStack) == 0x000050, "Member 'UGbxHUDStateData::StayOnTopOfStack' has a wrong offset!");

// Class GbxUI.GbxList
// 0x0000 (0x0028 - 0x0028)
class IGbxList final : public IInterface
{
public:
	void InsertListItem(class UGbxListItem* Item);
	bool MoveSelectionDown();
	bool MoveSelectionLeft();
	bool MoveSelectionRight();
	bool MoveSelectionUp();
	void OnItemClicked(class UGbxListItem* Item);
	void RemoveAllListItems();
	void RemoveListItem(class UGbxListItem* Item);
	void SetItemClickedDelegate(TDelegate<void(class UGbxListItem* ClickedItem)> InItemClickedDelegate);
	void SetSelectedIndex(int32 NewSelection, bool bScrollIntoView, bool bAnimateScroll);
	void SetSelectedItem(class UGbxListItem* Item, bool bScrollIntoView, bool bAnimateScroll);
	void SetSelectionChangedDelegate(TDelegate<void(class UGbxListItem* Item)> InSelectionChangedDelegate);
	void TryToAcquireMenuFocus(bool bFromMouse);

	TSubclassOf<class UGbxListItem> GetDefaultItemClass() const;
	class UGbxListItem* GetItemAtIndex(int32 Index_0) const;
	class UGbxListItemFactory* GetListItemFactory() const;
	int32 GetNumItemsInList() const;
	int32 GetSelectedIndex() const;
	class UGbxListItem* GetSelectedItem() const;
	bool IsListEnabled() const;
	bool IsListFocused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxList">();
	}
	static class IGbxList* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxList>();
	}
};
static_assert(alignof(IGbxList) == 0x000008, "Wrong alignment on IGbxList");
static_assert(sizeof(IGbxList) == 0x000028, "Wrong size on IGbxList");

// Class GbxUI.GbxListItemBoolean
// 0x0008 (0x02F0 - 0x02E8)
class UGbxListItemBoolean : public UGbxListItem
{
public:
	class UCheckBox*                              ValueCheckBox;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleFocusableWidgetPressed(const struct FGbxMenuInputEvent& InputInfo);
	void SetChecked(bool bChecked);

	bool IsChecked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxListItemBoolean">();
	}
	static class UGbxListItemBoolean* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxListItemBoolean>();
	}
};
static_assert(alignof(UGbxListItemBoolean) == 0x000008, "Wrong alignment on UGbxListItemBoolean");
static_assert(sizeof(UGbxListItemBoolean) == 0x0002F0, "Wrong size on UGbxListItemBoolean");
static_assert(offsetof(UGbxListItemBoolean, ValueCheckBox) == 0x0002E8, "Member 'UGbxListItemBoolean::ValueCheckBox' has a wrong offset!");

// Class GbxUI.GbxListItemComboBox
// 0x0018 (0x0300 - 0x02E8)
class UGbxListItemComboBox : public UGbxListItem
{
public:
	class UComboBoxString*                        ValueComboBox;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnComboBoxSelectionChanged;                        // 0x02F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void InitializeComboBox(const TArray<class FText>& Items, const int32 InitialValue);
	void ListItemComboBoxSelectionChangedDelegate__DelegateSignature(int32 NewSelectedIndex);
	void OnValueComboBoxChanged(const class FString& SelectedItem, ESelectInfo SelectionType);
	void SelectNextOption();
	void SelectPreviousOption();
	void SetSelectedOptionIndex(int32 Index_0);

	int32 GetSelectedOptionIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxListItemComboBox">();
	}
	static class UGbxListItemComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxListItemComboBox>();
	}
};
static_assert(alignof(UGbxListItemComboBox) == 0x000008, "Wrong alignment on UGbxListItemComboBox");
static_assert(sizeof(UGbxListItemComboBox) == 0x000300, "Wrong size on UGbxListItemComboBox");
static_assert(offsetof(UGbxListItemComboBox, ValueComboBox) == 0x0002E8, "Member 'UGbxListItemComboBox::ValueComboBox' has a wrong offset!");
static_assert(offsetof(UGbxListItemComboBox, OnComboBoxSelectionChanged) == 0x0002F0, "Member 'UGbxListItemComboBox::OnComboBoxSelectionChanged' has a wrong offset!");

// Class GbxUI.GbxListItemFactory
// 0x0028 (0x0058 - 0x0030)
class UGbxListItemFactory final : public UDataAsset
{
public:
	TSubclassOf<class UGbxListItem>               DefaultListItem;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxListItemText>           BasicTextListItem;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxListItemBoolean>        BooleanListItem;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxListItemNumber>         NumberListItem;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxListItemComboBox>       ComboBoxListItem;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGbxListItem* CreateItem(class APlayerController* Owner, TScriptInterface<class IGbxList> Parent, TSubclassOf<class UGbxListItem> ItemClass);
	static class UGbxListItem* CreateItemWithDelegates(class APlayerController* Owner, TScriptInterface<class IGbxList> Parent, TSubclassOf<class UGbxListItem> ItemClass, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> ClickedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);

	class UGbxListItemBoolean* CreateBooleanItem(class APlayerController* Owner, TScriptInterface<class IGbxList> Parent, const class FText& LabelText, bool InitialValue, TDelegate<void(class UGbxListItem* Item)> ChangedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	class UGbxListItemComboBox* CreateComboBoxItem(class APlayerController* Owner, TScriptInterface<class IGbxList> Parent, const class FText& LabelText, const TArray<class FText>& Items, int32 InitialIndex, TDelegate<void(class UGbxListItem* Item)> ChangedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	class UGbxListItemNumber* CreateNumberItem(class APlayerController* Owner, TScriptInterface<class IGbxList> Parent, const class FText& LabelText, float InitialValue, float SliderMin, float SliderMax, float SliderStep, TDelegate<void(class UGbxListItem* Item)> ChangedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);
	class UGbxListItemText* CreateTextItem(class APlayerController* Owner, TScriptInterface<class IGbxList> Parent, const class FText& LabelText, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> ClickedDelegate, TDelegate<void(class UGbxUserWidget* Widget, struct FGbxMenuInputEvent& InputInfo)> SelectedDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxListItemFactory">();
	}
	static class UGbxListItemFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxListItemFactory>();
	}
};
static_assert(alignof(UGbxListItemFactory) == 0x000008, "Wrong alignment on UGbxListItemFactory");
static_assert(sizeof(UGbxListItemFactory) == 0x000058, "Wrong size on UGbxListItemFactory");
static_assert(offsetof(UGbxListItemFactory, DefaultListItem) == 0x000030, "Member 'UGbxListItemFactory::DefaultListItem' has a wrong offset!");
static_assert(offsetof(UGbxListItemFactory, BasicTextListItem) == 0x000038, "Member 'UGbxListItemFactory::BasicTextListItem' has a wrong offset!");
static_assert(offsetof(UGbxListItemFactory, BooleanListItem) == 0x000040, "Member 'UGbxListItemFactory::BooleanListItem' has a wrong offset!");
static_assert(offsetof(UGbxListItemFactory, NumberListItem) == 0x000048, "Member 'UGbxListItemFactory::NumberListItem' has a wrong offset!");
static_assert(offsetof(UGbxListItemFactory, ComboBoxListItem) == 0x000050, "Member 'UGbxListItemFactory::ComboBoxListItem' has a wrong offset!");

// Class GbxUI.GbxListItemNumber
// 0x0030 (0x0318 - 0x02E8)
class UGbxListItemNumber : public UGbxListItem
{
public:
	class USlider*                                ValueSlider;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x28];                                     // 0x02F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecrementSlider();
	float GetCurrentValue();
	void IncrementSlider();
	void OnSliderValueChanged(float NewPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxListItemNumber">();
	}
	static class UGbxListItemNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxListItemNumber>();
	}
};
static_assert(alignof(UGbxListItemNumber) == 0x000008, "Wrong alignment on UGbxListItemNumber");
static_assert(sizeof(UGbxListItemNumber) == 0x000318, "Wrong size on UGbxListItemNumber");
static_assert(offsetof(UGbxListItemNumber, ValueSlider) == 0x0002E8, "Member 'UGbxListItemNumber::ValueSlider' has a wrong offset!");

// Class GbxUI.GbxMenu
// 0x0000 (0x0028 - 0x0028)
class IGbxMenu final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenu">();
	}
	static class IGbxMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxMenu>();
	}
};
static_assert(alignof(IGbxMenu) == 0x000008, "Wrong alignment on IGbxMenu");
static_assert(sizeof(IGbxMenu) == 0x000028, "Wrong size on IGbxMenu");

// Class GbxUI.GbxMenuInputSettings
// 0x0040 (0x0068 - 0x0028)
class UGbxMenuInputSettings final : public UObject
{
public:
	struct FGbxMenuKeyRepeatInfo                  KeyRepeatConfig;                                   // 0x0028(0x0018)(Edit, Transient, Config, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AxisAsButtonThreshold;                             // 0x0040(0x0004)(Edit, ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisThreshold;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxMenuInputAction>            ActionMappings;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, Transient, Config, NativeAccessSpecifierPublic)
	TArray<struct FGbxMenuInputAxisAction>        AxisMappings;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, Transient, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuInputSettings">();
	}
	static class UGbxMenuInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuInputSettings>();
	}
};
static_assert(alignof(UGbxMenuInputSettings) == 0x000008, "Wrong alignment on UGbxMenuInputSettings");
static_assert(sizeof(UGbxMenuInputSettings) == 0x000068, "Wrong size on UGbxMenuInputSettings");
static_assert(offsetof(UGbxMenuInputSettings, KeyRepeatConfig) == 0x000028, "Member 'UGbxMenuInputSettings::KeyRepeatConfig' has a wrong offset!");
static_assert(offsetof(UGbxMenuInputSettings, AxisAsButtonThreshold) == 0x000040, "Member 'UGbxMenuInputSettings::AxisAsButtonThreshold' has a wrong offset!");
static_assert(offsetof(UGbxMenuInputSettings, AxisThreshold) == 0x000044, "Member 'UGbxMenuInputSettings::AxisThreshold' has a wrong offset!");
static_assert(offsetof(UGbxMenuInputSettings, ActionMappings) == 0x000048, "Member 'UGbxMenuInputSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(UGbxMenuInputSettings, AxisMappings) == 0x000058, "Member 'UGbxMenuInputSettings::AxisMappings' has a wrong offset!");

// Class GbxUI.GbxMenuInput
// 0x00C8 (0x00F0 - 0x0028)
class UGbxMenuInput final : public UObject
{
public:
	TDelegate<void(struct FGbxMenuInputEvent& InputEvent)> UnpairedInputHandlerDelegate;                      // 0x0028(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowDebugKeyStates;                               // 0x0048(0x0001)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FramesToIgnoreMouseMoves;                          // 0x004C(0x0004)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IGbxMenuInputListener>> InputListeners;                                    // 0x0050(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FGbxMenuKeyRepeatInfo                  KeyRepeatConfig;                                   // 0x0060(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisAsButtonThreshold;                             // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AxisThreshold;                                     // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGbxMenuInputAction>            ActionMappings;                                    // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGbxMenuInputAxisAction>        AxisMappings;                                      // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGbxMenuInputRawMousePos>       MousePoses;                                        // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuInput">();
	}
	static class UGbxMenuInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuInput>();
	}
};
static_assert(alignof(UGbxMenuInput) == 0x000008, "Wrong alignment on UGbxMenuInput");
static_assert(sizeof(UGbxMenuInput) == 0x0000F0, "Wrong size on UGbxMenuInput");
static_assert(offsetof(UGbxMenuInput, UnpairedInputHandlerDelegate) == 0x000028, "Member 'UGbxMenuInput::UnpairedInputHandlerDelegate' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, bShowDebugKeyStates) == 0x000048, "Member 'UGbxMenuInput::bShowDebugKeyStates' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, FramesToIgnoreMouseMoves) == 0x00004C, "Member 'UGbxMenuInput::FramesToIgnoreMouseMoves' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, InputListeners) == 0x000050, "Member 'UGbxMenuInput::InputListeners' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, KeyRepeatConfig) == 0x000060, "Member 'UGbxMenuInput::KeyRepeatConfig' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, AxisAsButtonThreshold) == 0x000098, "Member 'UGbxMenuInput::AxisAsButtonThreshold' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, AxisThreshold) == 0x00009C, "Member 'UGbxMenuInput::AxisThreshold' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, ActionMappings) == 0x0000A0, "Member 'UGbxMenuInput::ActionMappings' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, AxisMappings) == 0x0000B0, "Member 'UGbxMenuInput::AxisMappings' has a wrong offset!");
static_assert(offsetof(UGbxMenuInput, MousePoses) == 0x0000C0, "Member 'UGbxMenuInput::MousePoses' has a wrong offset!");

// Class GbxUI.GbxMenuInputListener
// 0x0000 (0x0028 - 0x0028)
class IGbxMenuInputListener final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuInputListener">();
	}
	static class IGbxMenuInputListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGbxMenuInputListener>();
	}
};
static_assert(alignof(IGbxMenuInputListener) == 0x000008, "Wrong alignment on IGbxMenuInputListener");
static_assert(sizeof(IGbxMenuInputListener) == 0x000028, "Wrong size on IGbxMenuInputListener");

// Class GbxUI.GbxMenuStackMenuInfo
// 0x0018 (0x0040 - 0x0028)
class UGbxMenuStackMenuInfo final : public UBaseMenuStackMenuInfo
{
public:
	TScriptInterface<class IGbxMenu>              MenuObject;                                        // 0x0028(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UGbxMenuData*                           MenuData;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuStackMenuInfo">();
	}
	static class UGbxMenuStackMenuInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuStackMenuInfo>();
	}
};
static_assert(alignof(UGbxMenuStackMenuInfo) == 0x000008, "Wrong alignment on UGbxMenuStackMenuInfo");
static_assert(sizeof(UGbxMenuStackMenuInfo) == 0x000040, "Wrong size on UGbxMenuStackMenuInfo");
static_assert(offsetof(UGbxMenuStackMenuInfo, MenuObject) == 0x000028, "Member 'UGbxMenuStackMenuInfo::MenuObject' has a wrong offset!");
static_assert(offsetof(UGbxMenuStackMenuInfo, MenuData) == 0x000038, "Member 'UGbxMenuStackMenuInfo::MenuData' has a wrong offset!");

// Class GbxUI.GbxMenuStack
// 0x0160 (0x0188 - 0x0028)
class UGbxMenuStack final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGbxPlayerController>    PCOwner;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxMenuInput>           MenuInput;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxMenuStackMenuInfo*>          MenuStack;                                         // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UGbxMenuStackMenuInfo*>          MenuDeleteList;                                    // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FGbxMenuInputEvent>             QueuedInputActions;                                // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FGbxMenuInputEvent>             UnpairedInputCache;                                // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FGbxMenuAxisInputEvent>         QueuedAxisInputActions;                            // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UGbxMenuStackMenuInfo*>          PopupMenus;                                        // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         PriorityBase;                                      // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PriorityDelta;                                     // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PopupMenuPriorityBase;                             // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStackHasChanged;                                  // 0x00AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTicking;                                        // 0x00AD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingMenuInit;                                  // 0x00AE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingMenuDeinit;                                // 0x00AF(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingMenuDeactivate;                            // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisAsButtonThreshold;                             // 0x00B4(0x0004)(ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxMenuInputDevice                           CurrentInputDevice;                                // 0x00B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastInputFromMouse;                               // 0x00B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlockAllRawInput;                                  // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsProcessingInput;                                // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProcessingInputCancelled;                         // 0x00C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStackHidden;                                      // 0x00C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x65];                                      // 0x00C3(0x0065)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPrePushMenuDelegate;                             // 0x0128(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMenuActivatedDelegate;                           // 0x0138(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnStackEmptied;                                    // 0x0148(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UGbxMenuData*>                   PassiveMenuLoadQueue;                              // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxMenuStackMenuInfo*                  PassiveLoadingMenu;                                // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGameInstance*                       CachedGameInstance;                                // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Clear();
	void Draw();
	int32 GetIndexOfMenu(const class UObject* Menu);
	class UObject* GetMenuAtIndex(int32 Index_0);
	class UObject* GetTopMenu();
	void HandleRawInput(const struct FKey& Key, EInputEvent EVENTTYPE, int32 ControllerId);
	void Pop();
	void PopTo(const class UObject* Menu);
	class UObject* PopToSwitchTo(const class UObject* Menu, class UGbxMenuData* MenuData);
	class UObject* Push(class UGbxMenuData* MenuData);
	void SetBlockAllRawInput(bool bShouldBlock);
	void SetBlockingMode(bool bShouldBlock);
	class UObject* SwitchTo(class UGbxMenuData* MenuData);
	void Tick(float DeltaTime);

	EGbxMenuInputDevice GetCurrentInputDevice() const;
	int32 Num() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMenuStack">();
	}
	static class UGbxMenuStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMenuStack>();
	}
};
static_assert(alignof(UGbxMenuStack) == 0x000008, "Wrong alignment on UGbxMenuStack");
static_assert(sizeof(UGbxMenuStack) == 0x000188, "Wrong size on UGbxMenuStack");
static_assert(offsetof(UGbxMenuStack, PCOwner) == 0x000030, "Member 'UGbxMenuStack::PCOwner' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, MenuInput) == 0x000038, "Member 'UGbxMenuStack::MenuInput' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, MenuStack) == 0x000040, "Member 'UGbxMenuStack::MenuStack' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, MenuDeleteList) == 0x000050, "Member 'UGbxMenuStack::MenuDeleteList' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, QueuedInputActions) == 0x000060, "Member 'UGbxMenuStack::QueuedInputActions' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, UnpairedInputCache) == 0x000070, "Member 'UGbxMenuStack::UnpairedInputCache' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, QueuedAxisInputActions) == 0x000080, "Member 'UGbxMenuStack::QueuedAxisInputActions' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, PopupMenus) == 0x000090, "Member 'UGbxMenuStack::PopupMenus' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, PriorityBase) == 0x0000A0, "Member 'UGbxMenuStack::PriorityBase' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, PriorityDelta) == 0x0000A4, "Member 'UGbxMenuStack::PriorityDelta' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, PopupMenuPriorityBase) == 0x0000A8, "Member 'UGbxMenuStack::PopupMenuPriorityBase' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bStackHasChanged) == 0x0000AC, "Member 'UGbxMenuStack::bStackHasChanged' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bIsTicking) == 0x0000AD, "Member 'UGbxMenuStack::bIsTicking' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bIsDoingMenuInit) == 0x0000AE, "Member 'UGbxMenuStack::bIsDoingMenuInit' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bIsDoingMenuDeinit) == 0x0000AF, "Member 'UGbxMenuStack::bIsDoingMenuDeinit' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bIsDoingMenuDeactivate) == 0x0000B0, "Member 'UGbxMenuStack::bIsDoingMenuDeactivate' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, AxisAsButtonThreshold) == 0x0000B4, "Member 'UGbxMenuStack::AxisAsButtonThreshold' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, CurrentInputDevice) == 0x0000B8, "Member 'UGbxMenuStack::CurrentInputDevice' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bLastInputFromMouse) == 0x0000B9, "Member 'UGbxMenuStack::bLastInputFromMouse' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, BlockAllRawInput) == 0x0000BC, "Member 'UGbxMenuStack::BlockAllRawInput' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bIsProcessingInput) == 0x0000C0, "Member 'UGbxMenuStack::bIsProcessingInput' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bProcessingInputCancelled) == 0x0000C1, "Member 'UGbxMenuStack::bProcessingInputCancelled' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, bStackHidden) == 0x0000C2, "Member 'UGbxMenuStack::bStackHidden' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, OnPrePushMenuDelegate) == 0x000128, "Member 'UGbxMenuStack::OnPrePushMenuDelegate' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, OnMenuActivatedDelegate) == 0x000138, "Member 'UGbxMenuStack::OnMenuActivatedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, OnStackEmptied) == 0x000148, "Member 'UGbxMenuStack::OnStackEmptied' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, PassiveMenuLoadQueue) == 0x000158, "Member 'UGbxMenuStack::PassiveMenuLoadQueue' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, PassiveLoadingMenu) == 0x000168, "Member 'UGbxMenuStack::PassiveLoadingMenu' has a wrong offset!");
static_assert(offsetof(UGbxMenuStack, CachedGameInstance) == 0x000180, "Member 'UGbxMenuStack::CachedGameInstance' has a wrong offset!");

// Class GbxUI.GbxMeshWidget
// 0x0028 (0x0128 - 0x0100)
class UGbxMeshWidget final : public UWidget
{
public:
	class USlateVectorArtData*                    MeshData;                                          // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumUnits;                                       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x1C];                                     // 0x010C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxMeshWidget">();
	}
	static class UGbxMeshWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxMeshWidget>();
	}
};
static_assert(alignof(UGbxMeshWidget) == 0x000008, "Wrong alignment on UGbxMeshWidget");
static_assert(sizeof(UGbxMeshWidget) == 0x000128, "Wrong size on UGbxMeshWidget");
static_assert(offsetof(UGbxMeshWidget, MeshData) == 0x000100, "Member 'UGbxMeshWidget::MeshData' has a wrong offset!");
static_assert(offsetof(UGbxMeshWidget, MaxNumUnits) == 0x000108, "Member 'UGbxMeshWidget::MaxNumUnits' has a wrong offset!");

// Class GbxUI.GbxNoClipCanvasPanel
// 0x0010 (0x0138 - 0x0128)
class UGbxNoClipCanvasPanel final : public UCanvasPanel
{
public:
	struct FVector2D                              ClipZoneAdjustmentMin;                             // 0x0128(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ClipZoneAdjustmentMax;                             // 0x0130(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNoClipCanvasPanel">();
	}
	static class UGbxNoClipCanvasPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNoClipCanvasPanel>();
	}
};
static_assert(alignof(UGbxNoClipCanvasPanel) == 0x000008, "Wrong alignment on UGbxNoClipCanvasPanel");
static_assert(sizeof(UGbxNoClipCanvasPanel) == 0x000138, "Wrong size on UGbxNoClipCanvasPanel");
static_assert(offsetof(UGbxNoClipCanvasPanel, ClipZoneAdjustmentMin) == 0x000128, "Member 'UGbxNoClipCanvasPanel::ClipZoneAdjustmentMin' has a wrong offset!");
static_assert(offsetof(UGbxNoClipCanvasPanel, ClipZoneAdjustmentMax) == 0x000130, "Member 'UGbxNoClipCanvasPanel::ClipZoneAdjustmentMax' has a wrong offset!");

// Class GbxUI.GbxProgressBar
// 0x00F0 (0x03A8 - 0x02B8)
class UGbxProgressBar final : public UGbxUserWidget
{
public:
	class UTexture2D*                             FillTexture;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDeltaBar;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DeltaTexture;                                      // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DeltaEffectTexture;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BackgroundTexture;                                 // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxProgressBarFillDirection                  FillDirection;                                     // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Percent;                                           // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shear;                                             // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxProgressBarInterpolator            DefaultInterpolator;                               // 0x02EC(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxProgressBarRange>           Ranges;                                            // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterpolationComplete;                           // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class FName& RangeName)>       OnEnterRange;                                      // 0x0338(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UImage*                                 Fill;                                              // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DeltaEffect;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Background;                                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             CurrentValueText;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MaxValueText;                                      // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxUserWidget*                         PercentAnimationOwner;                             // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       PercentAnimation;                                  // 0x0378(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool EnteredPercentRange(float RangeMin, float RangeMax, float OldValue, float CurrentValue, bool bIncreasing, bool bDecreasing);
	static bool PassedPercentThreshold(float Threshold, float OldValue, float CurrentValue, bool bIncreasing, bool bDecreasing);

	void GbxProgressBarEvent__DelegateSignature();
	void GbxProgressBarRangeEvent__DelegateSignature(const class FName& RangeName);
	void HandleEnterPercentRange(const class FName& RangeName);
	void HandlePercentChanged(float OldValue, float CurrentValue, bool bIsInterpolating, const struct FGbxProgressBarInterpolator& ActiveInterpolator);
	void HandleShowDeltaEffect(class UWidget* Effect, float OldValue, float CurrentValue);
	void InterpolateToPercent(float InPercent);
	void InterpolateToPercentWithInterpolator(float InPercent, const struct FGbxProgressBarInterpolator& Interpolator);
	void SetCurrentValueText(const class FText& Text);
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetMaxValueText(const class FText& Text);
	void SetPercent(float InPercent);
	void SetShear(float InShear);

	float GetPercent() const;
	float GetShear() const;
	bool IsInterpolating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxProgressBar">();
	}
	static class UGbxProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxProgressBar>();
	}
};
static_assert(alignof(UGbxProgressBar) == 0x000008, "Wrong alignment on UGbxProgressBar");
static_assert(sizeof(UGbxProgressBar) == 0x0003A8, "Wrong size on UGbxProgressBar");
static_assert(offsetof(UGbxProgressBar, FillTexture) == 0x0002B8, "Member 'UGbxProgressBar::FillTexture' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, bShowDeltaBar) == 0x0002C0, "Member 'UGbxProgressBar::bShowDeltaBar' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, DeltaTexture) == 0x0002C8, "Member 'UGbxProgressBar::DeltaTexture' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, DeltaEffectTexture) == 0x0002D0, "Member 'UGbxProgressBar::DeltaEffectTexture' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, BackgroundTexture) == 0x0002D8, "Member 'UGbxProgressBar::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, FillDirection) == 0x0002E0, "Member 'UGbxProgressBar::FillDirection' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, Percent) == 0x0002E4, "Member 'UGbxProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, Shear) == 0x0002E8, "Member 'UGbxProgressBar::Shear' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, DefaultInterpolator) == 0x0002EC, "Member 'UGbxProgressBar::DefaultInterpolator' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, Ranges) == 0x000318, "Member 'UGbxProgressBar::Ranges' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, OnInterpolationComplete) == 0x000328, "Member 'UGbxProgressBar::OnInterpolationComplete' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, OnEnterRange) == 0x000338, "Member 'UGbxProgressBar::OnEnterRange' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, Fill) == 0x000348, "Member 'UGbxProgressBar::Fill' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, DeltaEffect) == 0x000350, "Member 'UGbxProgressBar::DeltaEffect' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, Background) == 0x000358, "Member 'UGbxProgressBar::Background' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, CurrentValueText) == 0x000360, "Member 'UGbxProgressBar::CurrentValueText' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, MaxValueText) == 0x000368, "Member 'UGbxProgressBar::MaxValueText' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, PercentAnimationOwner) == 0x000370, "Member 'UGbxProgressBar::PercentAnimationOwner' has a wrong offset!");
static_assert(offsetof(UGbxProgressBar, PercentAnimation) == 0x000378, "Member 'UGbxProgressBar::PercentAnimation' has a wrong offset!");

// Class GbxUI.GbxRetainerBox
// 0x0010 (0x0158 - 0x0148)
class UGbxRetainerBox final : public URetainerBox
{
public:
	TDelegate<void(struct FVector2D& InMousePosAsUV)> TransformDelegate;                                 // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxRetainerBox">();
	}
	static class UGbxRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxRetainerBox>();
	}
};
static_assert(alignof(UGbxRetainerBox) == 0x000008, "Wrong alignment on UGbxRetainerBox");
static_assert(sizeof(UGbxRetainerBox) == 0x000158, "Wrong size on UGbxRetainerBox");
static_assert(offsetof(UGbxRetainerBox, TransformDelegate) == 0x000148, "Member 'UGbxRetainerBox::TransformDelegate' has a wrong offset!");

// Class GbxUI.GbxScrollBoxList
// 0x0090 (0x08F0 - 0x0860)
class UGbxScrollBoxList final : public UScrollBox
{
public:
	uint8                                         Pad_860[0x18];                                     // 0x0860(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedIndex;                                     // 0x0878(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedIndexWhenFocusWasLost;                     // 0x087C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxUmgMenu>             MenuThatOwnsFocus;                                 // 0x0880(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxListItem* Item)>     SelectionChangedDelegate;                          // 0x0888(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGbxListItem* ClickedItem)> ItemClickedDelegate;                               // 0x0898(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EGbxScrollBoxListWrapMode                     WrapMode;                                          // 0x08A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxFocusableWidgetMouseBehavior              DefaultItemSelectionBehavior;                      // 0x08A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AA[0x6];                                      // 0x08AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxListItemFactory*                    ListItemFactory;                                   // 0x08B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxListItem>               DefaultListItemClass;                              // 0x08B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxScrollBoxListFocusChangedAction           FocusChangeAction;                                 // 0x08C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterAsFocusableWidget;                        // 0x08C1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C2[0x6];                                      // 0x08C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FocusableWidgetNavUp;                              // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavDown;                            // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavLeft;                            // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FocusableWidgetNavRight;                           // 0x08E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocusOnMenuCreation;                              // 0x08E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E9[0x7];                                      // 0x08E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxScrollBoxList">();
	}
	static class UGbxScrollBoxList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxScrollBoxList>();
	}
};
static_assert(alignof(UGbxScrollBoxList) == 0x000008, "Wrong alignment on UGbxScrollBoxList");
static_assert(sizeof(UGbxScrollBoxList) == 0x0008F0, "Wrong size on UGbxScrollBoxList");
static_assert(offsetof(UGbxScrollBoxList, SelectedIndex) == 0x000878, "Member 'UGbxScrollBoxList::SelectedIndex' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, SelectedIndexWhenFocusWasLost) == 0x00087C, "Member 'UGbxScrollBoxList::SelectedIndexWhenFocusWasLost' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, MenuThatOwnsFocus) == 0x000880, "Member 'UGbxScrollBoxList::MenuThatOwnsFocus' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, SelectionChangedDelegate) == 0x000888, "Member 'UGbxScrollBoxList::SelectionChangedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, ItemClickedDelegate) == 0x000898, "Member 'UGbxScrollBoxList::ItemClickedDelegate' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, WrapMode) == 0x0008A8, "Member 'UGbxScrollBoxList::WrapMode' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, DefaultItemSelectionBehavior) == 0x0008A9, "Member 'UGbxScrollBoxList::DefaultItemSelectionBehavior' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, ListItemFactory) == 0x0008B0, "Member 'UGbxScrollBoxList::ListItemFactory' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, DefaultListItemClass) == 0x0008B8, "Member 'UGbxScrollBoxList::DefaultListItemClass' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, FocusChangeAction) == 0x0008C0, "Member 'UGbxScrollBoxList::FocusChangeAction' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, bRegisterAsFocusableWidget) == 0x0008C1, "Member 'UGbxScrollBoxList::bRegisterAsFocusableWidget' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, FocusableWidgetNavUp) == 0x0008C8, "Member 'UGbxScrollBoxList::FocusableWidgetNavUp' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, FocusableWidgetNavDown) == 0x0008D0, "Member 'UGbxScrollBoxList::FocusableWidgetNavDown' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, FocusableWidgetNavLeft) == 0x0008D8, "Member 'UGbxScrollBoxList::FocusableWidgetNavLeft' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, FocusableWidgetNavRight) == 0x0008E0, "Member 'UGbxScrollBoxList::FocusableWidgetNavRight' has a wrong offset!");
static_assert(offsetof(UGbxScrollBoxList, bFocusOnMenuCreation) == 0x0008E8, "Member 'UGbxScrollBoxList::bFocusOnMenuCreation' has a wrong offset!");

// Class GbxUI.GbxSpinner
// 0x0058 (0x0320 - 0x02C8)
class UGbxSpinner final : public UGbxGFxButton
{
public:
	uint8                                         Pad_2C8[0x28];                                     // 0x02C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxButton*                          LeftButton;                                        // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxButton*                          RightButton;                                       // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxTextField*                          ChoiceText;                                        // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x18];                                     // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpinLeft(class UGbxGFxButton* PressedButton, const struct FGbxMenuInputEvent& InputInfo);
	void SpinnerValueUpdatedEvent__DelegateSignature();
	void SpinRight(class UGbxGFxButton* PressedButton, const struct FGbxMenuInputEvent& InputInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSpinner">();
	}
	static class UGbxSpinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSpinner>();
	}
};
static_assert(alignof(UGbxSpinner) == 0x000008, "Wrong alignment on UGbxSpinner");
static_assert(sizeof(UGbxSpinner) == 0x000320, "Wrong size on UGbxSpinner");
static_assert(offsetof(UGbxSpinner, LeftButton) == 0x0002F0, "Member 'UGbxSpinner::LeftButton' has a wrong offset!");
static_assert(offsetof(UGbxSpinner, RightButton) == 0x0002F8, "Member 'UGbxSpinner::RightButton' has a wrong offset!");
static_assert(offsetof(UGbxSpinner, ChoiceText) == 0x000300, "Member 'UGbxSpinner::ChoiceText' has a wrong offset!");

// Class GbxUI.GbxTextField
// 0x0120 (0x0290 - 0x0170)
class UGbxTextField final : public UGbxGFxObject
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxGFxSlider*                          ScrollBar;                                         // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x108];                                    // 0x0188(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnScrollBarPositionUpdated(float SliderPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTextField">();
	}
	static class UGbxTextField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTextField>();
	}
};
static_assert(alignof(UGbxTextField) == 0x000008, "Wrong alignment on UGbxTextField");
static_assert(sizeof(UGbxTextField) == 0x000290, "Wrong size on UGbxTextField");
static_assert(offsetof(UGbxTextField, ScrollBar) == 0x000180, "Member 'UGbxTextField::ScrollBar' has a wrong offset!");

// Class GbxUI.UIAccessors
// 0x0000 (0x0028 - 0x0028)
class IUIAccessors final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAccessors">();
	}
	static class IUIAccessors* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUIAccessors>();
	}
};
static_assert(alignof(IUIAccessors) == 0x000008, "Wrong alignment on IUIAccessors");
static_assert(sizeof(IUIAccessors) == 0x000028, "Wrong size on IUIAccessors");

// Class GbxUI.GbxUILocalization
// 0x0000 (0x0028 - 0x0028)
class UGbxUILocalization final : public UBlueprintFunctionLibrary
{
public:
	static class FText FKeyToGFxHTMLText(const struct FKey& Key, class AGbxPlayerController* Pc, EGbxActionToTextType GlyphType, float GlyphHeight);
	static class FText InputActionToGFxHTMLText(const class FName ActionName, class AGbxPlayerController* Pc, EGbxActionToTextType GlyphType, float GlyphHeight, int32 VSpace);
	static struct FSlateBrush InputActionToGlyph(const class FName ActionName, class AGbxPlayerController* Pc, EGbxActionToTextType GlyphType);
	static class FText InputActionToRichText(const class FName ActionName, class AGbxPlayerController* Pc, EGbxActionToTextType GlyphType, const struct FVector2D& GlyphSize);
	static class FText InputActionToText(const class FName ActionName, class AGbxPlayerController* Pc, EGbxActionToTextType GlyphType);
	static bool IsInputActionGlyphAvailable(const class FName ActionName, class AGbxPlayerController* Pc, EGbxActionToTextType GlyphType);
	static bool IsPlatformGlyphAvailable(const class FName Platform, class AGbxPlayerController* Pc);
	static class FText PlatformToGFxHTMLText(const class FName Platform, class AGbxPlayerController* Pc, float GlyphHeight, int32 VSpace);
	static struct FSlateBrush PlatformToGlyph(const class FName Platform, class AGbxPlayerController* Pc);
	static class FText PlatformToRichText(const class FName Platform, class AGbxPlayerController* Pc, const struct FVector2D& GlyphSize);
	static class FText PlatformToText(const class FName Platform, class AGbxPlayerController* Pc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUILocalization">();
	}
	static class UGbxUILocalization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUILocalization>();
	}
};
static_assert(alignof(UGbxUILocalization) == 0x000008, "Wrong alignment on UGbxUILocalization");
static_assert(sizeof(UGbxUILocalization) == 0x000028, "Wrong size on UGbxUILocalization");

// Class GbxUI.GbxInputToGlyphMap
// 0x0020 (0x0050 - 0x0030)
class UGbxInputToGlyphMap final : public UGbxDataAsset
{
public:
	TArray<struct FGbxInputToGlyphMapItem>        InputMap;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FGbxInputToGlyphSpecialActionItem> SpecialInputActionMap;                             // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxInputToGlyphMap">();
	}
	static class UGbxInputToGlyphMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxInputToGlyphMap>();
	}
};
static_assert(alignof(UGbxInputToGlyphMap) == 0x000008, "Wrong alignment on UGbxInputToGlyphMap");
static_assert(sizeof(UGbxInputToGlyphMap) == 0x000050, "Wrong size on UGbxInputToGlyphMap");
static_assert(offsetof(UGbxInputToGlyphMap, InputMap) == 0x000030, "Member 'UGbxInputToGlyphMap::InputMap' has a wrong offset!");
static_assert(offsetof(UGbxInputToGlyphMap, SpecialInputActionMap) == 0x000040, "Member 'UGbxInputToGlyphMap::SpecialInputActionMap' has a wrong offset!");

// Class GbxUI.GbxPlatformToGlyphMap
// 0x0050 (0x0080 - 0x0030)
class UGbxPlatformToGlyphMap final : public UGbxDataAsset
{
public:
	TMap<class FName, struct FSlateBrush>         PlatformMap;                                       // 0x0030(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPlatformToGlyphMap">();
	}
	static class UGbxPlatformToGlyphMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxPlatformToGlyphMap>();
	}
};
static_assert(alignof(UGbxPlatformToGlyphMap) == 0x000008, "Wrong alignment on UGbxPlatformToGlyphMap");
static_assert(sizeof(UGbxPlatformToGlyphMap) == 0x000080, "Wrong size on UGbxPlatformToGlyphMap");
static_assert(offsetof(UGbxPlatformToGlyphMap, PlatformMap) == 0x000030, "Member 'UGbxPlatformToGlyphMap::PlatformMap' has a wrong offset!");

// Class GbxUI.GbxUISpinnerWidget
// 0x0020 (0x02D8 - 0x02B8)
class UGbxUISpinnerWidget final : public UGbxUserWidget
{
public:
	class UCanvasPanel*                           SpinnerDisplayStrip;                               // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TotalDigitsDisplayed;                              // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationTime;                                     // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentValue;                                      // 0x02C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTransitionUpwards;                                // 0x02C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentDistanceRemaining;                          // 0x02CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentAnimSpeed;                                  // 0x02D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         NewValueToGoTo;                                    // 0x02D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxSpinnerWidgetGoToMethod                   AnimationType;                                     // 0x02D5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float MoveToNumber(uint8 NewNumber, EGbxSpinnerWidgetGoToMethod GoToMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUISpinnerWidget">();
	}
	static class UGbxUISpinnerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUISpinnerWidget>();
	}
};
static_assert(alignof(UGbxUISpinnerWidget) == 0x000008, "Wrong alignment on UGbxUISpinnerWidget");
static_assert(sizeof(UGbxUISpinnerWidget) == 0x0002D8, "Wrong size on UGbxUISpinnerWidget");
static_assert(offsetof(UGbxUISpinnerWidget, SpinnerDisplayStrip) == 0x0002B8, "Member 'UGbxUISpinnerWidget::SpinnerDisplayStrip' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, TotalDigitsDisplayed) == 0x0002C0, "Member 'UGbxUISpinnerWidget::TotalDigitsDisplayed' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, AnimationTime) == 0x0002C4, "Member 'UGbxUISpinnerWidget::AnimationTime' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, CurrentValue) == 0x0002C8, "Member 'UGbxUISpinnerWidget::CurrentValue' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, bTransitionUpwards) == 0x0002C9, "Member 'UGbxUISpinnerWidget::bTransitionUpwards' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, CurrentDistanceRemaining) == 0x0002CC, "Member 'UGbxUISpinnerWidget::CurrentDistanceRemaining' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, CurrentAnimSpeed) == 0x0002D0, "Member 'UGbxUISpinnerWidget::CurrentAnimSpeed' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, NewValueToGoTo) == 0x0002D4, "Member 'UGbxUISpinnerWidget::NewValueToGoTo' has a wrong offset!");
static_assert(offsetof(UGbxUISpinnerWidget, AnimationType) == 0x0002D5, "Member 'UGbxUISpinnerWidget::AnimationType' has a wrong offset!");

// Class GbxUI.GbxWidgetComponent
// 0x0028 (0x0870 - 0x0848)
class UGbxWidgetComponent final : public UWidgetComponent
{
public:
	class UCurveFloat*                            DistanceScaleCurve;                                // 0x0848(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DistanceAlphaCurve;                                // 0x0850(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                DistanceAlphaBorder;                               // 0x0858(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGbxPlayerController*                   TrackedPlayerController;                           // 0x0860(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxUserWidget*                         GbxWidget;                                         // 0x0868(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDistanceAlphaBorder(class UBorder* NewDistanceAlphaBorder);
	void SetDistanceAlphaCurve(class UCurveFloat* NewDistanceAlphaCurve);
	void SetDistanceScaleCurve(class UCurveFloat* NewDistanceScaleCurve);
	void Setup(const TSubclassOf<class UUserWidget>& NewWidgetClass, const class AGbxPlayerController* NewTrackedPlayer, class USceneComponent* ParentComponent, EWidgetSpace WidgetSpace, int32 NewLayerZOrder, class FName CollisionProfile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxWidgetComponent">();
	}
	static class UGbxWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxWidgetComponent>();
	}
};
static_assert(alignof(UGbxWidgetComponent) == 0x000008, "Wrong alignment on UGbxWidgetComponent");
static_assert(sizeof(UGbxWidgetComponent) == 0x000870, "Wrong size on UGbxWidgetComponent");
static_assert(offsetof(UGbxWidgetComponent, DistanceScaleCurve) == 0x000848, "Member 'UGbxWidgetComponent::DistanceScaleCurve' has a wrong offset!");
static_assert(offsetof(UGbxWidgetComponent, DistanceAlphaCurve) == 0x000850, "Member 'UGbxWidgetComponent::DistanceAlphaCurve' has a wrong offset!");
static_assert(offsetof(UGbxWidgetComponent, DistanceAlphaBorder) == 0x000858, "Member 'UGbxWidgetComponent::DistanceAlphaBorder' has a wrong offset!");
static_assert(offsetof(UGbxWidgetComponent, TrackedPlayerController) == 0x000860, "Member 'UGbxWidgetComponent::TrackedPlayerController' has a wrong offset!");
static_assert(offsetof(UGbxWidgetComponent, GbxWidget) == 0x000868, "Member 'UGbxWidgetComponent::GbxWidget' has a wrong offset!");

// Class GbxUI.GbxWidgetFocusManager
// 0x0068 (0x0090 - 0x0028)
class UGbxWidgetFocusManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                OwnerMenu;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                FocusedWidget;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxFocusableWidgetInfo>        RegisteredWidgets;                                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x28];                                      // 0x0068(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxWidgetFocusManager">();
	}
	static class UGbxWidgetFocusManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxWidgetFocusManager>();
	}
};
static_assert(alignof(UGbxWidgetFocusManager) == 0x000008, "Wrong alignment on UGbxWidgetFocusManager");
static_assert(sizeof(UGbxWidgetFocusManager) == 0x000090, "Wrong size on UGbxWidgetFocusManager");
static_assert(offsetof(UGbxWidgetFocusManager, OwnerMenu) == 0x000038, "Member 'UGbxWidgetFocusManager::OwnerMenu' has a wrong offset!");
static_assert(offsetof(UGbxWidgetFocusManager, FocusedWidget) == 0x000048, "Member 'UGbxWidgetFocusManager::FocusedWidget' has a wrong offset!");
static_assert(offsetof(UGbxWidgetFocusManager, RegisteredWidgets) == 0x000058, "Member 'UGbxWidgetFocusManager::RegisteredWidgets' has a wrong offset!");

// Class GbxUI.GbxWorldSpaceProxyWidget
// 0x0048 (0x0300 - 0x02B8)
class UGbxWorldSpaceProxyWidget final : public UGbxUserWidget
{
public:
	float                                         Depth;                                             // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x02BC(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x3C];                                     // 0x02C4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetWorldLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxWorldSpaceProxyWidget">();
	}
	static class UGbxWorldSpaceProxyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxWorldSpaceProxyWidget>();
	}
};
static_assert(alignof(UGbxWorldSpaceProxyWidget) == 0x000008, "Wrong alignment on UGbxWorldSpaceProxyWidget");
static_assert(sizeof(UGbxWorldSpaceProxyWidget) == 0x000300, "Wrong size on UGbxWorldSpaceProxyWidget");
static_assert(offsetof(UGbxWorldSpaceProxyWidget, Depth) == 0x0002B8, "Member 'UGbxWorldSpaceProxyWidget::Depth' has a wrong offset!");
static_assert(offsetof(UGbxWorldSpaceProxyWidget, Alignment) == 0x0002BC, "Member 'UGbxWorldSpaceProxyWidget::Alignment' has a wrong offset!");

// Class GbxUI.InWorldDamageNumber
// 0x0030 (0x02E8 - 0x02B8)
class UInWorldDamageNumber final : public UGbxUserWidget
{
public:
	class UGbxRichTextBlock*                      DisplayField;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           DisplayPanel;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageAnimationPairing>        DamageAnimationPairings;                           // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AGbxPlayerController*                   InstigatingPlayer;                                 // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       DamageNumberContainer;                             // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ImpulseAnimationCompleted(class UUserWidget* AssociatedWidget);
	void OnWentOffscreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InWorldDamageNumber">();
	}
	static class UInWorldDamageNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInWorldDamageNumber>();
	}
};
static_assert(alignof(UInWorldDamageNumber) == 0x000008, "Wrong alignment on UInWorldDamageNumber");
static_assert(sizeof(UInWorldDamageNumber) == 0x0002E8, "Wrong size on UInWorldDamageNumber");
static_assert(offsetof(UInWorldDamageNumber, DisplayField) == 0x0002B8, "Member 'UInWorldDamageNumber::DisplayField' has a wrong offset!");
static_assert(offsetof(UInWorldDamageNumber, DisplayPanel) == 0x0002C0, "Member 'UInWorldDamageNumber::DisplayPanel' has a wrong offset!");
static_assert(offsetof(UInWorldDamageNumber, DamageAnimationPairings) == 0x0002C8, "Member 'UInWorldDamageNumber::DamageAnimationPairings' has a wrong offset!");
static_assert(offsetof(UInWorldDamageNumber, InstigatingPlayer) == 0x0002D8, "Member 'UInWorldDamageNumber::InstigatingPlayer' has a wrong offset!");
static_assert(offsetof(UInWorldDamageNumber, DamageNumberContainer) == 0x0002E0, "Member 'UInWorldDamageNumber::DamageNumberContainer' has a wrong offset!");

}

