#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxInventory

#include "Basic.hpp"

#include "GbxInventory_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function GbxInventory.InventoryGenericPartExpansionData.EnumeratePartListForPartType
// 0x0018 (0x0018 - 0x0000)
struct InventoryGenericPartExpansionData_EnumeratePartListForPartType final
{
public:
	uint8                                         PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorPartData*>                 OutPartList;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryGenericPartExpansionData_EnumeratePartListForPartType) == 0x000008, "Wrong alignment on InventoryGenericPartExpansionData_EnumeratePartListForPartType");
static_assert(sizeof(InventoryGenericPartExpansionData_EnumeratePartListForPartType) == 0x000018, "Wrong size on InventoryGenericPartExpansionData_EnumeratePartListForPartType");
static_assert(offsetof(InventoryGenericPartExpansionData_EnumeratePartListForPartType, PartType) == 0x000000, "Member 'InventoryGenericPartExpansionData_EnumeratePartListForPartType::PartType' has a wrong offset!");
static_assert(offsetof(InventoryGenericPartExpansionData_EnumeratePartListForPartType, OutPartList) == 0x000008, "Member 'InventoryGenericPartExpansionData_EnumeratePartListForPartType::OutPartList' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.CanBePickedUp
// 0x0010 (0x0010 - 0x0000)
struct InventoryItemPickup_CanBePickedUp final
{
public:
	class AActor*                                 Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsedByOther;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHeld;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForMassPickup;                                    // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000B(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryItemPickup_CanBePickedUp) == 0x000008, "Wrong alignment on InventoryItemPickup_CanBePickedUp");
static_assert(sizeof(InventoryItemPickup_CanBePickedUp) == 0x000010, "Wrong size on InventoryItemPickup_CanBePickedUp");
static_assert(offsetof(InventoryItemPickup_CanBePickedUp, Other) == 0x000000, "Member 'InventoryItemPickup_CanBePickedUp::Other' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_CanBePickedUp, UsedByOther) == 0x000008, "Member 'InventoryItemPickup_CanBePickedUp::UsedByOther' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_CanBePickedUp, bUseHeld) == 0x000009, "Member 'InventoryItemPickup_CanBePickedUp::bUseHeld' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_CanBePickedUp, bForMassPickup) == 0x00000A, "Member 'InventoryItemPickup_CanBePickedUp::bForMassPickup' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_CanBePickedUp, ReturnValue) == 0x00000B, "Member 'InventoryItemPickup_CanBePickedUp::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GiveInventoryToUser
// 0x0010 (0x0010 - 0x0000)
struct InventoryItemPickup_GiveInventoryToUser final
{
public:
	class AActor*                                 Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoEquip;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryItemPickup_GiveInventoryToUser) == 0x000008, "Wrong alignment on InventoryItemPickup_GiveInventoryToUser");
static_assert(sizeof(InventoryItemPickup_GiveInventoryToUser) == 0x000010, "Wrong size on InventoryItemPickup_GiveInventoryToUser");
static_assert(offsetof(InventoryItemPickup_GiveInventoryToUser, Other) == 0x000000, "Member 'InventoryItemPickup_GiveInventoryToUser::Other' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_GiveInventoryToUser, bAutoEquip) == 0x000008, "Member 'InventoryItemPickup_GiveInventoryToUser::bAutoEquip' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.IsPickupInitialized
// 0x0001 (0x0001 - 0x0000)
struct InventoryItemPickup_IsPickupInitialized final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_IsPickupInitialized) == 0x000001, "Wrong alignment on InventoryItemPickup_IsPickupInitialized");
static_assert(sizeof(InventoryItemPickup_IsPickupInitialized) == 0x000001, "Wrong size on InventoryItemPickup_IsPickupInitialized");
static_assert(offsetof(InventoryItemPickup_IsPickupInitialized, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_IsPickupInitialized::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.OnLookedAtByPlayer
// 0x0020 (0x0020 - 0x0000)
struct InventoryItemPickup_OnLookedAtByPlayer final
{
public:
	class APlayerController*                      InstigatingPlayer;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInteractWith;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NewUsableComponentImpactPoint;                     // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewUsableDistanceAway;                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryItemPickup_OnLookedAtByPlayer) == 0x000008, "Wrong alignment on InventoryItemPickup_OnLookedAtByPlayer");
static_assert(sizeof(InventoryItemPickup_OnLookedAtByPlayer) == 0x000020, "Wrong size on InventoryItemPickup_OnLookedAtByPlayer");
static_assert(offsetof(InventoryItemPickup_OnLookedAtByPlayer, InstigatingPlayer) == 0x000000, "Member 'InventoryItemPickup_OnLookedAtByPlayer::InstigatingPlayer' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_OnLookedAtByPlayer, bCanInteractWith) == 0x000008, "Member 'InventoryItemPickup_OnLookedAtByPlayer::bCanInteractWith' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_OnLookedAtByPlayer, NewUsableComponentImpactPoint) == 0x00000C, "Member 'InventoryItemPickup_OnLookedAtByPlayer::NewUsableComponentImpactPoint' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_OnLookedAtByPlayer, NewUsableDistanceAway) == 0x000018, "Member 'InventoryItemPickup_OnLookedAtByPlayer::NewUsableDistanceAway' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.OnPickedUpEvent
// 0x0008 (0x0008 - 0x0000)
struct InventoryItemPickup_OnPickedUpEvent final
{
public:
	class AActor*                                 WasPickedUpBy;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_OnPickedUpEvent) == 0x000008, "Wrong alignment on InventoryItemPickup_OnPickedUpEvent");
static_assert(sizeof(InventoryItemPickup_OnPickedUpEvent) == 0x000008, "Wrong size on InventoryItemPickup_OnPickedUpEvent");
static_assert(offsetof(InventoryItemPickup_OnPickedUpEvent, WasPickedUpBy) == 0x000000, "Member 'InventoryItemPickup_OnPickedUpEvent::WasPickedUpBy' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.OnUsedBy
// 0x0018 (0x0018 - 0x0000)
struct InventoryItemPickup_OnUsedBy final
{
public:
	struct FUseEvent                              UseEvent;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_OnUsedBy) == 0x000008, "Wrong alignment on InventoryItemPickup_OnUsedBy");
static_assert(sizeof(InventoryItemPickup_OnUsedBy) == 0x000018, "Wrong size on InventoryItemPickup_OnUsedBy");
static_assert(offsetof(InventoryItemPickup_OnUsedBy, UseEvent) == 0x000000, "Member 'InventoryItemPickup_OnUsedBy::UseEvent' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.SetCanOnlyBePickedUpByOwner
// 0x0010 (0x0010 - 0x0000)
struct InventoryItemPickup_SetCanOnlyBePickedUpByOwner final
{
public:
	bool                                          bNewCanOnlyBePickedUpByOwnerController;            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            OwnerController;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_SetCanOnlyBePickedUpByOwner) == 0x000008, "Wrong alignment on InventoryItemPickup_SetCanOnlyBePickedUpByOwner");
static_assert(sizeof(InventoryItemPickup_SetCanOnlyBePickedUpByOwner) == 0x000010, "Wrong size on InventoryItemPickup_SetCanOnlyBePickedUpByOwner");
static_assert(offsetof(InventoryItemPickup_SetCanOnlyBePickedUpByOwner, bNewCanOnlyBePickedUpByOwnerController) == 0x000000, "Member 'InventoryItemPickup_SetCanOnlyBePickedUpByOwner::bNewCanOnlyBePickedUpByOwnerController' has a wrong offset!");
static_assert(offsetof(InventoryItemPickup_SetCanOnlyBePickedUpByOwner, OwnerController) == 0x000008, "Member 'InventoryItemPickup_SetCanOnlyBePickedUpByOwner::OwnerController' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryBalanceStateComponent
// 0x0008 (0x0008 - 0x0000)
struct InventoryItemPickup_GetInventoryBalanceStateComponent final
{
public:
	class UInventoryBalanceStateComponent*        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryBalanceStateComponent) == 0x000008, "Wrong alignment on InventoryItemPickup_GetInventoryBalanceStateComponent");
static_assert(sizeof(InventoryItemPickup_GetInventoryBalanceStateComponent) == 0x000008, "Wrong size on InventoryItemPickup_GetInventoryBalanceStateComponent");
static_assert(offsetof(InventoryItemPickup_GetInventoryBalanceStateComponent, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryBalanceStateComponent::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryDisplayRarityOutline
// 0x0001 (0x0001 - 0x0000)
struct InventoryItemPickup_GetInventoryDisplayRarityOutline final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryDisplayRarityOutline) == 0x000001, "Wrong alignment on InventoryItemPickup_GetInventoryDisplayRarityOutline");
static_assert(sizeof(InventoryItemPickup_GetInventoryDisplayRarityOutline) == 0x000001, "Wrong size on InventoryItemPickup_GetInventoryDisplayRarityOutline");
static_assert(offsetof(InventoryItemPickup_GetInventoryDisplayRarityOutline, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryDisplayRarityOutline::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryRarityColorFX
// 0x0010 (0x0010 - 0x0000)
struct InventoryItemPickup_GetInventoryRarityColorFX final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryRarityColorFX) == 0x000004, "Wrong alignment on InventoryItemPickup_GetInventoryRarityColorFX");
static_assert(sizeof(InventoryItemPickup_GetInventoryRarityColorFX) == 0x000010, "Wrong size on InventoryItemPickup_GetInventoryRarityColorFX");
static_assert(offsetof(InventoryItemPickup_GetInventoryRarityColorFX, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryRarityColorFX::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryRarityColorOutline
// 0x0010 (0x0010 - 0x0000)
struct InventoryItemPickup_GetInventoryRarityColorOutline final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryRarityColorOutline) == 0x000004, "Wrong alignment on InventoryItemPickup_GetInventoryRarityColorOutline");
static_assert(sizeof(InventoryItemPickup_GetInventoryRarityColorOutline) == 0x000010, "Wrong size on InventoryItemPickup_GetInventoryRarityColorOutline");
static_assert(offsetof(InventoryItemPickup_GetInventoryRarityColorOutline, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryRarityColorOutline::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryRarityLifeSpanType
// 0x0001 (0x0001 - 0x0000)
struct InventoryItemPickup_GetInventoryRarityLifeSpanType final
{
public:
	EDropLifeSpanType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryRarityLifeSpanType) == 0x000001, "Wrong alignment on InventoryItemPickup_GetInventoryRarityLifeSpanType");
static_assert(sizeof(InventoryItemPickup_GetInventoryRarityLifeSpanType) == 0x000001, "Wrong size on InventoryItemPickup_GetInventoryRarityLifeSpanType");
static_assert(offsetof(InventoryItemPickup_GetInventoryRarityLifeSpanType, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryRarityLifeSpanType::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryRarityLootAudioStinger
// 0x0008 (0x0008 - 0x0000)
struct InventoryItemPickup_GetInventoryRarityLootAudioStinger final
{
public:
	class UWwiseEvent*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryRarityLootAudioStinger) == 0x000008, "Wrong alignment on InventoryItemPickup_GetInventoryRarityLootAudioStinger");
static_assert(sizeof(InventoryItemPickup_GetInventoryRarityLootAudioStinger) == 0x000008, "Wrong size on InventoryItemPickup_GetInventoryRarityLootAudioStinger");
static_assert(offsetof(InventoryItemPickup_GetInventoryRarityLootAudioStinger, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryRarityLootAudioStinger::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetInventoryRarityLootBeamOverride
// 0x0008 (0x0008 - 0x0000)
struct InventoryItemPickup_GetInventoryRarityLootBeamOverride final
{
public:
	class UParticleSystem*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetInventoryRarityLootBeamOverride) == 0x000008, "Wrong alignment on InventoryItemPickup_GetInventoryRarityLootBeamOverride");
static_assert(sizeof(InventoryItemPickup_GetInventoryRarityLootBeamOverride) == 0x000008, "Wrong size on InventoryItemPickup_GetInventoryRarityLootBeamOverride");
static_assert(offsetof(InventoryItemPickup_GetInventoryRarityLootBeamOverride, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetInventoryRarityLootBeamOverride::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryItemPickup.GetMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct InventoryItemPickup_GetMeshComponent final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryItemPickup_GetMeshComponent) == 0x000008, "Wrong alignment on InventoryItemPickup_GetMeshComponent");
static_assert(sizeof(InventoryItemPickup_GetMeshComponent) == 0x000008, "Wrong size on InventoryItemPickup_GetMeshComponent");
static_assert(offsetof(InventoryItemPickup_GetMeshComponent, ReturnValue) == 0x000000, "Member 'InventoryItemPickup_GetMeshComponent::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryAspectData.K2_CloneAppearance
// 0x0018 (0x0018 - 0x0000)
struct InventoryAspectData_K2_CloneAppearance final
{
public:
	class AActor*                                 CloneActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InventoryActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInventoryBalanceStateComponent*  InventoryBalanceState;                             // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryAspectData_K2_CloneAppearance) == 0x000008, "Wrong alignment on InventoryAspectData_K2_CloneAppearance");
static_assert(sizeof(InventoryAspectData_K2_CloneAppearance) == 0x000018, "Wrong size on InventoryAspectData_K2_CloneAppearance");
static_assert(offsetof(InventoryAspectData_K2_CloneAppearance, CloneActor) == 0x000000, "Member 'InventoryAspectData_K2_CloneAppearance::CloneActor' has a wrong offset!");
static_assert(offsetof(InventoryAspectData_K2_CloneAppearance, InventoryActor) == 0x000008, "Member 'InventoryAspectData_K2_CloneAppearance::InventoryActor' has a wrong offset!");
static_assert(offsetof(InventoryAspectData_K2_CloneAppearance, InventoryBalanceState) == 0x000010, "Member 'InventoryAspectData_K2_CloneAppearance::InventoryBalanceState' has a wrong offset!");

// Function GbxInventory.InventoryAspectData.K2_GetFriendlyDescription
// 0x0010 (0x0010 - 0x0000)
struct InventoryAspectData_K2_GetFriendlyDescription final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryAspectData_K2_GetFriendlyDescription) == 0x000008, "Wrong alignment on InventoryAspectData_K2_GetFriendlyDescription");
static_assert(sizeof(InventoryAspectData_K2_GetFriendlyDescription) == 0x000010, "Wrong size on InventoryAspectData_K2_GetFriendlyDescription");
static_assert(offsetof(InventoryAspectData_K2_GetFriendlyDescription, ReturnValue) == 0x000000, "Member 'InventoryAspectData_K2_GetFriendlyDescription::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryAspectData.K2_OnApplyAspect
// 0x0010 (0x0010 - 0x0000)
struct InventoryAspectData_K2_OnApplyAspect final
{
public:
	class AActor*                                 InventoryActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInventoryBalanceStateComponent*  InventoryBalanceState;                             // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryAspectData_K2_OnApplyAspect) == 0x000008, "Wrong alignment on InventoryAspectData_K2_OnApplyAspect");
static_assert(sizeof(InventoryAspectData_K2_OnApplyAspect) == 0x000010, "Wrong size on InventoryAspectData_K2_OnApplyAspect");
static_assert(offsetof(InventoryAspectData_K2_OnApplyAspect, InventoryActor) == 0x000000, "Member 'InventoryAspectData_K2_OnApplyAspect::InventoryActor' has a wrong offset!");
static_assert(offsetof(InventoryAspectData_K2_OnApplyAspect, InventoryBalanceState) == 0x000008, "Member 'InventoryAspectData_K2_OnApplyAspect::InventoryBalanceState' has a wrong offset!");

// Function GbxInventory.InventoryAspectData.K2_OnBeginPlay
// 0x0010 (0x0010 - 0x0000)
struct InventoryAspectData_K2_OnBeginPlay final
{
public:
	class AActor*                                 InventoryActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInventoryBalanceStateComponent*  InventoryBalanceState;                             // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryAspectData_K2_OnBeginPlay) == 0x000008, "Wrong alignment on InventoryAspectData_K2_OnBeginPlay");
static_assert(sizeof(InventoryAspectData_K2_OnBeginPlay) == 0x000010, "Wrong size on InventoryAspectData_K2_OnBeginPlay");
static_assert(offsetof(InventoryAspectData_K2_OnBeginPlay, InventoryActor) == 0x000000, "Member 'InventoryAspectData_K2_OnBeginPlay::InventoryActor' has a wrong offset!");
static_assert(offsetof(InventoryAspectData_K2_OnBeginPlay, InventoryBalanceState) == 0x000008, "Member 'InventoryAspectData_K2_OnBeginPlay::InventoryBalanceState' has a wrong offset!");

// Function GbxInventory.LootableComponent.GetAttachedPickups
// 0x0010 (0x0010 - 0x0000)
struct LootableComponent_GetAttachedPickups final
{
public:
	TArray<class ADroppedInventoryItemPickup*>    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootableComponent_GetAttachedPickups) == 0x000008, "Wrong alignment on LootableComponent_GetAttachedPickups");
static_assert(sizeof(LootableComponent_GetAttachedPickups) == 0x000010, "Wrong size on LootableComponent_GetAttachedPickups");
static_assert(offsetof(LootableComponent_GetAttachedPickups, ReturnValue) == 0x000000, "Member 'LootableComponent_GetAttachedPickups::ReturnValue' has a wrong offset!");

// Function GbxInventory.LootableComponent.InitializeLootConfigurations
// 0x0008 (0x0008 - 0x0000)
struct LootableComponent_InitializeLootConfigurations final
{
public:
	class ULootableBalanceData*                   LootableBalanceData;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootableComponent_InitializeLootConfigurations) == 0x000008, "Wrong alignment on LootableComponent_InitializeLootConfigurations");
static_assert(sizeof(LootableComponent_InitializeLootConfigurations) == 0x000008, "Wrong size on LootableComponent_InitializeLootConfigurations");
static_assert(offsetof(LootableComponent_InitializeLootConfigurations, LootableBalanceData) == 0x000000, "Member 'LootableComponent_InitializeLootConfigurations::LootableBalanceData' has a wrong offset!");

// Function GbxInventory.LootableComponent.SetBalanceContextOverride
// 0x0010 (0x0010 - 0x0000)
struct LootableComponent_SetBalanceContextOverride final
{
public:
	class AActor*                                 NewOverrideContext;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseForGameStage;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LootableComponent_SetBalanceContextOverride) == 0x000008, "Wrong alignment on LootableComponent_SetBalanceContextOverride");
static_assert(sizeof(LootableComponent_SetBalanceContextOverride) == 0x000010, "Wrong size on LootableComponent_SetBalanceContextOverride");
static_assert(offsetof(LootableComponent_SetBalanceContextOverride, NewOverrideContext) == 0x000000, "Member 'LootableComponent_SetBalanceContextOverride::NewOverrideContext' has a wrong offset!");
static_assert(offsetof(LootableComponent_SetBalanceContextOverride, bOnlyUseForGameStage) == 0x000008, "Member 'LootableComponent_SetBalanceContextOverride::bOnlyUseForGameStage' has a wrong offset!");

// Function GbxInventory.LootableComponent.SpawnAndAttachLoot
// 0x0008 (0x0008 - 0x0000)
struct LootableComponent_SpawnAndAttachLoot final
{
public:
	class FName                                   SelectedConfigurationName;                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootableComponent_SpawnAndAttachLoot) == 0x000004, "Wrong alignment on LootableComponent_SpawnAndAttachLoot");
static_assert(sizeof(LootableComponent_SpawnAndAttachLoot) == 0x000008, "Wrong size on LootableComponent_SpawnAndAttachLoot");
static_assert(offsetof(LootableComponent_SpawnAndAttachLoot, SelectedConfigurationName) == 0x000000, "Member 'LootableComponent_SpawnAndAttachLoot::SelectedConfigurationName' has a wrong offset!");

// Function GbxInventory.LootableComponent.SpawnAndDropLoot
// 0x0008 (0x0008 - 0x0000)
struct LootableComponent_SpawnAndDropLoot final
{
public:
	class FName                                   SelectedConfigurationName;                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootableComponent_SpawnAndDropLoot) == 0x000004, "Wrong alignment on LootableComponent_SpawnAndDropLoot");
static_assert(sizeof(LootableComponent_SpawnAndDropLoot) == 0x000008, "Wrong size on LootableComponent_SpawnAndDropLoot");
static_assert(offsetof(LootableComponent_SpawnAndDropLoot, SelectedConfigurationName) == 0x000000, "Member 'LootableComponent_SpawnAndDropLoot::SelectedConfigurationName' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.NotifyAttached
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_NotifyAttached final
{
public:
	class APawn*                                  Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_NotifyAttached) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_NotifyAttached");
static_assert(sizeof(InventoryBalanceStateComponent_NotifyAttached) == 0x000008, "Wrong size on InventoryBalanceStateComponent_NotifyAttached");
static_assert(offsetof(InventoryBalanceStateComponent_NotifyAttached, Instigator) == 0x000000, "Member 'InventoryBalanceStateComponent_NotifyAttached::Instigator' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.NotifyEquipped
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_NotifyEquipped final
{
public:
	class APawn*                                  NewInstigator;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_NotifyEquipped) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_NotifyEquipped");
static_assert(sizeof(InventoryBalanceStateComponent_NotifyEquipped) == 0x000008, "Wrong size on InventoryBalanceStateComponent_NotifyEquipped");
static_assert(offsetof(InventoryBalanceStateComponent_NotifyEquipped, NewInstigator) == 0x000000, "Member 'InventoryBalanceStateComponent_NotifyEquipped::NewInstigator' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.NotifyUnequipped
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_NotifyUnequipped final
{
public:
	class APawn*                                  OldInstigator;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_NotifyUnequipped) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_NotifyUnequipped");
static_assert(sizeof(InventoryBalanceStateComponent_NotifyUnequipped) == 0x000008, "Wrong size on InventoryBalanceStateComponent_NotifyUnequipped");
static_assert(offsetof(InventoryBalanceStateComponent_NotifyUnequipped, OldInstigator) == 0x000000, "Member 'InventoryBalanceStateComponent_NotifyUnequipped::OldInstigator' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.CloneAppearance
// 0x0018 (0x0018 - 0x0000)
struct InventoryBalanceStateComponent_CloneAppearance final
{
public:
	class AActor*                                 DestActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ParentComp;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryBalanceStateComponent_CloneAppearance) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_CloneAppearance");
static_assert(sizeof(InventoryBalanceStateComponent_CloneAppearance) == 0x000018, "Wrong size on InventoryBalanceStateComponent_CloneAppearance");
static_assert(offsetof(InventoryBalanceStateComponent_CloneAppearance, DestActor) == 0x000000, "Member 'InventoryBalanceStateComponent_CloneAppearance::DestActor' has a wrong offset!");
static_assert(offsetof(InventoryBalanceStateComponent_CloneAppearance, ParentComp) == 0x000008, "Member 'InventoryBalanceStateComponent_CloneAppearance::ParentComp' has a wrong offset!");
static_assert(offsetof(InventoryBalanceStateComponent_CloneAppearance, bAbsoluteScale) == 0x000010, "Member 'InventoryBalanceStateComponent_CloneAppearance::bAbsoluteScale' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetCustomizationPartList
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_GetCustomizationPartList final
{
public:
	TArray<class UInventoryCustomizationPartData*> ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetCustomizationPartList) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetCustomizationPartList");
static_assert(sizeof(InventoryBalanceStateComponent_GetCustomizationPartList) == 0x000010, "Wrong size on InventoryBalanceStateComponent_GetCustomizationPartList");
static_assert(offsetof(InventoryBalanceStateComponent_GetCustomizationPartList, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetCustomizationPartList::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetDamageType
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetDamageType final
{
public:
	TSubclassOf<class UGbxDamageType>             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetDamageType) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetDamageType");
static_assert(sizeof(InventoryBalanceStateComponent_GetDamageType) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetDamageType");
static_assert(offsetof(InventoryBalanceStateComponent_GetDamageType, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetDamageType::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct InventoryBalanceStateComponent_GetDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetDisplayName) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetDisplayName");
static_assert(sizeof(InventoryBalanceStateComponent_GetDisplayName) == 0x000018, "Wrong size on InventoryBalanceStateComponent_GetDisplayName");
static_assert(offsetof(InventoryBalanceStateComponent_GetDisplayName, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetDisplayName::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetGenericPartList
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_GetGenericPartList final
{
public:
	TArray<class UInventoryGenericPartData*>      ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetGenericPartList) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetGenericPartList");
static_assert(sizeof(InventoryBalanceStateComponent_GetGenericPartList) == 0x000010, "Wrong size on InventoryBalanceStateComponent_GetGenericPartList");
static_assert(offsetof(InventoryBalanceStateComponent_GetGenericPartList, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetGenericPartList::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryBalanceData
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryBalanceData final
{
public:
	class UInventoryBalanceData*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryBalanceData) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryBalanceData");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryBalanceData) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetInventoryBalanceData");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryBalanceData, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryBalanceData::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryData
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryData final
{
public:
	class UInventoryData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryData) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryData");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryData) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetInventoryData");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryData, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryData::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryDisplayRarityOutline
// 0x0001 (0x0001 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline) == 0x000001, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline) == 0x000001, "Wrong size on InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryDisplayRarityOutline::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityColorFX
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityColorFX final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityColorFX) == 0x000004, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityColorFX");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityColorFX) == 0x000010, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityColorFX");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityColorFX, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityColorFX::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityColorOutline
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityColorOutline final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityColorOutline) == 0x000004, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityColorOutline");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityColorOutline) == 0x000010, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityColorOutline");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityColorOutline, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityColorOutline::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityData
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityData final
{
public:
	class UInventoryRarityData*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityData) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityData");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityData) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityData");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityData, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityData::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityDisplayName
// 0x0018 (0x0018 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityDisplayName) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityDisplayName");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityDisplayName) == 0x000018, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityDisplayName");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityDisplayName, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityDisplayName::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityFrameName
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityFrameName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityFrameName) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityFrameName");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityFrameName) == 0x000010, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityFrameName");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityFrameName, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityFrameName::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityLifeSpan
// 0x0004 (0x0004 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityLifeSpan final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityLifeSpan) == 0x000004, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityLifeSpan");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityLifeSpan) == 0x000004, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityLifeSpan");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityLifeSpan, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityLifeSpan::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityLifeSpanType
// 0x0001 (0x0001 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType final
{
public:
	EDropLifeSpanType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType) == 0x000001, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType) == 0x000001, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityLifeSpanType::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityLootAudioStinger
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger final
{
public:
	class UWwiseEvent*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityLootAudioStinger::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityLootBeamHeight
// 0x0004 (0x0004 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight) == 0x000004, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight) == 0x000004, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityLootBeamHeight::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryRarityLootBeamOverride
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride final
{
public:
	class UParticleSystem*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryRarityLootBeamOverride::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetInventoryScoreValue
// 0x0004 (0x0004 - 0x0000)
struct InventoryBalanceStateComponent_GetInventoryScoreValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetInventoryScoreValue) == 0x000004, "Wrong alignment on InventoryBalanceStateComponent_GetInventoryScoreValue");
static_assert(sizeof(InventoryBalanceStateComponent_GetInventoryScoreValue) == 0x000004, "Wrong size on InventoryBalanceStateComponent_GetInventoryScoreValue");
static_assert(offsetof(InventoryBalanceStateComponent_GetInventoryScoreValue, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetInventoryScoreValue::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetManufacturer
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_GetManufacturer final
{
public:
	class UManufacturerData*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetManufacturer) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetManufacturer");
static_assert(sizeof(InventoryBalanceStateComponent_GetManufacturer) == 0x000008, "Wrong size on InventoryBalanceStateComponent_GetManufacturer");
static_assert(offsetof(InventoryBalanceStateComponent_GetManufacturer, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetManufacturer::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetMonetaryValue
// 0x0004 (0x0004 - 0x0000)
struct InventoryBalanceStateComponent_GetMonetaryValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetMonetaryValue) == 0x000004, "Wrong alignment on InventoryBalanceStateComponent_GetMonetaryValue");
static_assert(sizeof(InventoryBalanceStateComponent_GetMonetaryValue) == 0x000004, "Wrong size on InventoryBalanceStateComponent_GetMonetaryValue");
static_assert(offsetof(InventoryBalanceStateComponent_GetMonetaryValue, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetMonetaryValue::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetPartList
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_GetPartList final
{
public:
	TArray<class UInventoryPartData*>             ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetPartList) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_GetPartList");
static_assert(sizeof(InventoryBalanceStateComponent_GetPartList) == 0x000010, "Wrong size on InventoryBalanceStateComponent_GetPartList");
static_assert(offsetof(InventoryBalanceStateComponent_GetPartList, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetPartList::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.GetReRollCount
// 0x0001 (0x0001 - 0x0000)
struct InventoryBalanceStateComponent_GetReRollCount final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_GetReRollCount) == 0x000001, "Wrong alignment on InventoryBalanceStateComponent_GetReRollCount");
static_assert(sizeof(InventoryBalanceStateComponent_GetReRollCount) == 0x000001, "Wrong size on InventoryBalanceStateComponent_GetReRollCount");
static_assert(offsetof(InventoryBalanceStateComponent_GetReRollCount, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_GetReRollCount::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.IsManufactureredBy
// 0x0010 (0x0010 - 0x0000)
struct InventoryBalanceStateComponent_IsManufactureredBy final
{
public:
	const class UManufacturerData*                Manufacturer;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryBalanceStateComponent_IsManufactureredBy) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_IsManufactureredBy");
static_assert(sizeof(InventoryBalanceStateComponent_IsManufactureredBy) == 0x000010, "Wrong size on InventoryBalanceStateComponent_IsManufactureredBy");
static_assert(offsetof(InventoryBalanceStateComponent_IsManufactureredBy, Manufacturer) == 0x000000, "Member 'InventoryBalanceStateComponent_IsManufactureredBy::Manufacturer' has a wrong offset!");
static_assert(offsetof(InventoryBalanceStateComponent_IsManufactureredBy, ReturnValue) == 0x000008, "Member 'InventoryBalanceStateComponent_IsManufactureredBy::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBalanceStateComponent.K2_GetDamageType
// 0x0008 (0x0008 - 0x0000)
struct InventoryBalanceStateComponent_K2_GetDamageType final
{
public:
	TSubclassOf<class UGbxDamageType>             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBalanceStateComponent_K2_GetDamageType) == 0x000008, "Wrong alignment on InventoryBalanceStateComponent_K2_GetDamageType");
static_assert(sizeof(InventoryBalanceStateComponent_K2_GetDamageType) == 0x000008, "Wrong size on InventoryBalanceStateComponent_K2_GetDamageType");
static_assert(offsetof(InventoryBalanceStateComponent_K2_GetDamageType, ReturnValue) == 0x000000, "Member 'InventoryBalanceStateComponent_K2_GetDamageType::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetInventoryDisplayDescription
// 0x0020 (0x0020 - 0x0000)
struct InventoryListComponent_GetInventoryDisplayDescription final
{
public:
	class AActor*                                 InventoryActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetInventoryDisplayDescription) == 0x000008, "Wrong alignment on InventoryListComponent_GetInventoryDisplayDescription");
static_assert(sizeof(InventoryListComponent_GetInventoryDisplayDescription) == 0x000020, "Wrong size on InventoryListComponent_GetInventoryDisplayDescription");
static_assert(offsetof(InventoryListComponent_GetInventoryDisplayDescription, InventoryActor) == 0x000000, "Member 'InventoryListComponent_GetInventoryDisplayDescription::InventoryActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetInventoryDisplayDescription, ReturnValue) == 0x000008, "Member 'InventoryListComponent_GetInventoryDisplayDescription::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetInventoryDisplayName
// 0x0020 (0x0020 - 0x0000)
struct InventoryListComponent_GetInventoryDisplayName final
{
public:
	class AActor*                                 InventoryActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetInventoryDisplayName) == 0x000008, "Wrong alignment on InventoryListComponent_GetInventoryDisplayName");
static_assert(sizeof(InventoryListComponent_GetInventoryDisplayName) == 0x000020, "Wrong size on InventoryListComponent_GetInventoryDisplayName");
static_assert(offsetof(InventoryListComponent_GetInventoryDisplayName, InventoryActor) == 0x000000, "Member 'InventoryListComponent_GetInventoryDisplayName::InventoryActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetInventoryDisplayName, ReturnValue) == 0x000008, "Member 'InventoryListComponent_GetInventoryDisplayName::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetInventoryListEntryDisplayDescription
// 0x0058 (0x0058 - 0x0000)
struct InventoryListComponent_GetInventoryListEntryDisplayDescription final
{
public:
	struct FInventoryListEntry                    ListEntry;                                         // 0x0000(0x0040)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetInventoryListEntryDisplayDescription) == 0x000008, "Wrong alignment on InventoryListComponent_GetInventoryListEntryDisplayDescription");
static_assert(sizeof(InventoryListComponent_GetInventoryListEntryDisplayDescription) == 0x000058, "Wrong size on InventoryListComponent_GetInventoryListEntryDisplayDescription");
static_assert(offsetof(InventoryListComponent_GetInventoryListEntryDisplayDescription, ListEntry) == 0x000000, "Member 'InventoryListComponent_GetInventoryListEntryDisplayDescription::ListEntry' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetInventoryListEntryDisplayDescription, ReturnValue) == 0x000040, "Member 'InventoryListComponent_GetInventoryListEntryDisplayDescription::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetInventoryListEntryDisplayName
// 0x0058 (0x0058 - 0x0000)
struct InventoryListComponent_GetInventoryListEntryDisplayName final
{
public:
	struct FInventoryListEntry                    ListEntry;                                         // 0x0000(0x0040)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetInventoryListEntryDisplayName) == 0x000008, "Wrong alignment on InventoryListComponent_GetInventoryListEntryDisplayName");
static_assert(sizeof(InventoryListComponent_GetInventoryListEntryDisplayName) == 0x000058, "Wrong size on InventoryListComponent_GetInventoryListEntryDisplayName");
static_assert(offsetof(InventoryListComponent_GetInventoryListEntryDisplayName, ListEntry) == 0x000000, "Member 'InventoryListComponent_GetInventoryListEntryDisplayName::ListEntry' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetInventoryListEntryDisplayName, ReturnValue) == 0x000040, "Member 'InventoryListComponent_GetInventoryListEntryDisplayName::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.AddCategory
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_AddCategory final
{
public:
	const class UInventoryCategoryData*           ItemCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrackQuantity;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_AddCategory) == 0x000008, "Wrong alignment on InventoryListComponent_AddCategory");
static_assert(sizeof(InventoryListComponent_AddCategory) == 0x000010, "Wrong size on InventoryListComponent_AddCategory");
static_assert(offsetof(InventoryListComponent_AddCategory, ItemCategory) == 0x000000, "Member 'InventoryListComponent_AddCategory::ItemCategory' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddCategory, TrackQuantity) == 0x000008, "Member 'InventoryListComponent_AddCategory::TrackQuantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddCategory, ReturnValue) == 0x000009, "Member 'InventoryListComponent_AddCategory::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.AddExternalItem
// 0x0028 (0x0028 - 0x0000)
struct InventoryListComponent_AddExternalItem final
{
public:
	const class UInventoryCategoryData*           ItemCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToAdd;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddedByPickup;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoEquip;                                        // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConditionalDestroyActor;                          // 0x0016(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredSlot;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBypassInventoryFull;                              // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryListEntryHandle              ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_AddExternalItem) == 0x000008, "Wrong alignment on InventoryListComponent_AddExternalItem");
static_assert(sizeof(InventoryListComponent_AddExternalItem) == 0x000028, "Wrong size on InventoryListComponent_AddExternalItem");
static_assert(offsetof(InventoryListComponent_AddExternalItem, ItemCategory) == 0x000000, "Member 'InventoryListComponent_AddExternalItem::ItemCategory' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, ActorToAdd) == 0x000008, "Member 'InventoryListComponent_AddExternalItem::ActorToAdd' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, Quantity) == 0x000010, "Member 'InventoryListComponent_AddExternalItem::Quantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, AddedByPickup) == 0x000014, "Member 'InventoryListComponent_AddExternalItem::AddedByPickup' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, bAutoEquip) == 0x000015, "Member 'InventoryListComponent_AddExternalItem::bAutoEquip' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, bConditionalDestroyActor) == 0x000016, "Member 'InventoryListComponent_AddExternalItem::bConditionalDestroyActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, DesiredSlot) == 0x000018, "Member 'InventoryListComponent_AddExternalItem::DesiredSlot' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, bBypassInventoryFull) == 0x00001C, "Member 'InventoryListComponent_AddExternalItem::bBypassInventoryFull' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItem, ReturnValue) == 0x000020, "Member 'InventoryListComponent_AddExternalItem::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.AddExternalItemEx
// 0x0028 (0x0028 - 0x0000)
struct InventoryListComponent_AddExternalItemEx final
{
public:
	const class UInventoryCategoryData*           ItemCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToAdd;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags_0;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConditionalDestroyActor;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredSlot;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBypassInventoryFull;                              // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryListEntryHandle              ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_AddExternalItemEx) == 0x000008, "Wrong alignment on InventoryListComponent_AddExternalItemEx");
static_assert(sizeof(InventoryListComponent_AddExternalItemEx) == 0x000028, "Wrong size on InventoryListComponent_AddExternalItemEx");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, ItemCategory) == 0x000000, "Member 'InventoryListComponent_AddExternalItemEx::ItemCategory' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, ActorToAdd) == 0x000008, "Member 'InventoryListComponent_AddExternalItemEx::ActorToAdd' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, Quantity) == 0x000010, "Member 'InventoryListComponent_AddExternalItemEx::Quantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, Flags_0) == 0x000014, "Member 'InventoryListComponent_AddExternalItemEx::Flags_0' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, bConditionalDestroyActor) == 0x000018, "Member 'InventoryListComponent_AddExternalItemEx::bConditionalDestroyActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, DesiredSlot) == 0x00001C, "Member 'InventoryListComponent_AddExternalItemEx::DesiredSlot' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, bBypassInventoryFull) == 0x000020, "Member 'InventoryListComponent_AddExternalItemEx::bBypassInventoryFull' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddExternalItemEx, ReturnValue) == 0x000024, "Member 'InventoryListComponent_AddExternalItemEx::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.AddItemFromPickup
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_AddItemFromPickup final
{
public:
	class AInventoryItemPickup*                   PickupActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryListEntryHandle              ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_AddItemFromPickup) == 0x000008, "Wrong alignment on InventoryListComponent_AddItemFromPickup");
static_assert(sizeof(InventoryListComponent_AddItemFromPickup) == 0x000010, "Wrong size on InventoryListComponent_AddItemFromPickup");
static_assert(offsetof(InventoryListComponent_AddItemFromPickup, PickupActor) == 0x000000, "Member 'InventoryListComponent_AddItemFromPickup::PickupActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddItemFromPickup, ReturnValue) == 0x000008, "Member 'InventoryListComponent_AddItemFromPickup::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.AddOrUpdateCategoryOnly
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_AddOrUpdateCategoryOnly final
{
public:
	const class UInventoryCategoryData*           ItemCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_AddOrUpdateCategoryOnly) == 0x000008, "Wrong alignment on InventoryListComponent_AddOrUpdateCategoryOnly");
static_assert(sizeof(InventoryListComponent_AddOrUpdateCategoryOnly) == 0x000010, "Wrong size on InventoryListComponent_AddOrUpdateCategoryOnly");
static_assert(offsetof(InventoryListComponent_AddOrUpdateCategoryOnly, ItemCategory) == 0x000000, "Member 'InventoryListComponent_AddOrUpdateCategoryOnly::ItemCategory' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_AddOrUpdateCategoryOnly, Quantity) == 0x000008, "Member 'InventoryListComponent_AddOrUpdateCategoryOnly::Quantity' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.CanUseSelected
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_CanUseSelected final
{
public:
	const class UInventoryCategoryData*           ChildTypeToUse;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_CanUseSelected) == 0x000008, "Wrong alignment on InventoryListComponent_CanUseSelected");
static_assert(sizeof(InventoryListComponent_CanUseSelected) == 0x000010, "Wrong size on InventoryListComponent_CanUseSelected");
static_assert(offsetof(InventoryListComponent_CanUseSelected, ChildTypeToUse) == 0x000000, "Member 'InventoryListComponent_CanUseSelected::ChildTypeToUse' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_CanUseSelected, Quantity) == 0x000008, "Member 'InventoryListComponent_CanUseSelected::Quantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_CanUseSelected, ReturnValue) == 0x00000C, "Member 'InventoryListComponent_CanUseSelected::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ClearInventory
// 0x0001 (0x0001 - 0x0000)
struct InventoryListComponent_ClearInventory final
{
public:
	bool                                          DestroyInventory;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_ClearInventory) == 0x000001, "Wrong alignment on InventoryListComponent_ClearInventory");
static_assert(sizeof(InventoryListComponent_ClearInventory) == 0x000001, "Wrong size on InventoryListComponent_ClearInventory");
static_assert(offsetof(InventoryListComponent_ClearInventory, DestroyInventory) == 0x000000, "Member 'InventoryListComponent_ClearInventory::DestroyInventory' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetAndConsumeItem
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_GetAndConsumeItem final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetAndConsumeItem) == 0x000008, "Wrong alignment on InventoryListComponent_GetAndConsumeItem");
static_assert(sizeof(InventoryListComponent_GetAndConsumeItem) == 0x000010, "Wrong size on InventoryListComponent_GetAndConsumeItem");
static_assert(offsetof(InventoryListComponent_GetAndConsumeItem, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_GetAndConsumeItem::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetAndConsumeItem, Quantity) == 0x000004, "Member 'InventoryListComponent_GetAndConsumeItem::Quantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetAndConsumeItem, ReturnValue) == 0x000008, "Member 'InventoryListComponent_GetAndConsumeItem::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetAndConsumeSelected
// 0x0018 (0x0018 - 0x0000)
struct InventoryListComponent_GetAndConsumeSelected final
{
public:
	const class UInventoryCategoryData*           TypeToConsume;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetAndConsumeSelected) == 0x000008, "Wrong alignment on InventoryListComponent_GetAndConsumeSelected");
static_assert(sizeof(InventoryListComponent_GetAndConsumeSelected) == 0x000018, "Wrong size on InventoryListComponent_GetAndConsumeSelected");
static_assert(offsetof(InventoryListComponent_GetAndConsumeSelected, TypeToConsume) == 0x000000, "Member 'InventoryListComponent_GetAndConsumeSelected::TypeToConsume' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetAndConsumeSelected, Quantity) == 0x000008, "Member 'InventoryListComponent_GetAndConsumeSelected::Quantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetAndConsumeSelected, ReturnValue) == 0x000010, "Member 'InventoryListComponent_GetAndConsumeSelected::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetCategoryItemQuantity
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_GetCategoryItemQuantity final
{
public:
	const class UInventoryCategoryData*           ItemCategory;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_GetCategoryItemQuantity) == 0x000008, "Wrong alignment on InventoryListComponent_GetCategoryItemQuantity");
static_assert(sizeof(InventoryListComponent_GetCategoryItemQuantity) == 0x000010, "Wrong size on InventoryListComponent_GetCategoryItemQuantity");
static_assert(offsetof(InventoryListComponent_GetCategoryItemQuantity, ItemCategory) == 0x000000, "Member 'InventoryListComponent_GetCategoryItemQuantity::ItemCategory' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetCategoryItemQuantity, ReturnValue) == 0x000008, "Member 'InventoryListComponent_GetCategoryItemQuantity::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetCategoryOnlyInventoryHandles
// 0x0018 (0x0018 - 0x0000)
struct InventoryListComponent_GetCategoryOnlyInventoryHandles final
{
public:
	const class UInventoryCategoryData*           ChildTypeToGet;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInventoryListEntryHandle>      ItemHandleList;                                    // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetCategoryOnlyInventoryHandles) == 0x000008, "Wrong alignment on InventoryListComponent_GetCategoryOnlyInventoryHandles");
static_assert(sizeof(InventoryListComponent_GetCategoryOnlyInventoryHandles) == 0x000018, "Wrong size on InventoryListComponent_GetCategoryOnlyInventoryHandles");
static_assert(offsetof(InventoryListComponent_GetCategoryOnlyInventoryHandles, ChildTypeToGet) == 0x000000, "Member 'InventoryListComponent_GetCategoryOnlyInventoryHandles::ChildTypeToGet' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetCategoryOnlyInventoryHandles, ItemHandleList) == 0x000008, "Member 'InventoryListComponent_GetCategoryOnlyInventoryHandles::ItemHandleList' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetInventoryHandlesOfType
// 0x0018 (0x0018 - 0x0000)
struct InventoryListComponent_GetInventoryHandlesOfType final
{
public:
	const class UInventoryCategoryData*           ChildTypeToGet;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInventoryListEntryHandle>      ItemHandleList;                                    // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetInventoryHandlesOfType) == 0x000008, "Wrong alignment on InventoryListComponent_GetInventoryHandlesOfType");
static_assert(sizeof(InventoryListComponent_GetInventoryHandlesOfType) == 0x000018, "Wrong size on InventoryListComponent_GetInventoryHandlesOfType");
static_assert(offsetof(InventoryListComponent_GetInventoryHandlesOfType, ChildTypeToGet) == 0x000000, "Member 'InventoryListComponent_GetInventoryHandlesOfType::ChildTypeToGet' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetInventoryHandlesOfType, ItemHandleList) == 0x000008, "Member 'InventoryListComponent_GetInventoryHandlesOfType::ItemHandleList' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetItem
// 0x0050 (0x0050 - 0x0000)
struct InventoryListComponent_GetItem final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryListEntry                    ListEntry;                                         // 0x0008(0x0040)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_GetItem) == 0x000008, "Wrong alignment on InventoryListComponent_GetItem");
static_assert(sizeof(InventoryListComponent_GetItem) == 0x000050, "Wrong size on InventoryListComponent_GetItem");
static_assert(offsetof(InventoryListComponent_GetItem, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_GetItem::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetItem, ListEntry) == 0x000008, "Member 'InventoryListComponent_GetItem::ListEntry' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetItem, ReturnValue) == 0x000048, "Member 'InventoryListComponent_GetItem::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetSelectedItemQuantity
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_GetSelectedItemQuantity final
{
public:
	const class UInventoryCategoryData*           ChildTypeToGet;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxQuantity;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetSelectedItemQuantity) == 0x000008, "Wrong alignment on InventoryListComponent_GetSelectedItemQuantity");
static_assert(sizeof(InventoryListComponent_GetSelectedItemQuantity) == 0x000010, "Wrong size on InventoryListComponent_GetSelectedItemQuantity");
static_assert(offsetof(InventoryListComponent_GetSelectedItemQuantity, ChildTypeToGet) == 0x000000, "Member 'InventoryListComponent_GetSelectedItemQuantity::ChildTypeToGet' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetSelectedItemQuantity, Quantity) == 0x000008, "Member 'InventoryListComponent_GetSelectedItemQuantity::Quantity' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetSelectedItemQuantity, MaxQuantity) == 0x00000C, "Member 'InventoryListComponent_GetSelectedItemQuantity::MaxQuantity' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetStoredInventoryActor
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_GetStoredInventoryActor final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetStoredInventoryActor) == 0x000008, "Wrong alignment on InventoryListComponent_GetStoredInventoryActor");
static_assert(sizeof(InventoryListComponent_GetStoredInventoryActor) == 0x000010, "Wrong size on InventoryListComponent_GetStoredInventoryActor");
static_assert(offsetof(InventoryListComponent_GetStoredInventoryActor, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_GetStoredInventoryActor::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_GetStoredInventoryActor, ReturnValue) == 0x000008, "Member 'InventoryListComponent_GetStoredInventoryActor::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.HasActorInList
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_HasActorInList final
{
public:
	class AActor*                                 ItemActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_HasActorInList) == 0x000008, "Wrong alignment on InventoryListComponent_HasActorInList");
static_assert(sizeof(InventoryListComponent_HasActorInList) == 0x000010, "Wrong size on InventoryListComponent_HasActorInList");
static_assert(offsetof(InventoryListComponent_HasActorInList, ItemActor) == 0x000000, "Member 'InventoryListComponent_HasActorInList::ItemActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_HasActorInList, ReturnValue) == 0x000008, "Member 'InventoryListComponent_HasActorInList::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerAddCustomizationPartToInventoryActor
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_ServerAddCustomizationPartToInventoryActor final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryCustomizationPartData*        Part;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_ServerAddCustomizationPartToInventoryActor) == 0x000008, "Wrong alignment on InventoryListComponent_ServerAddCustomizationPartToInventoryActor");
static_assert(sizeof(InventoryListComponent_ServerAddCustomizationPartToInventoryActor) == 0x000010, "Wrong size on InventoryListComponent_ServerAddCustomizationPartToInventoryActor");
static_assert(offsetof(InventoryListComponent_ServerAddCustomizationPartToInventoryActor, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_ServerAddCustomizationPartToInventoryActor::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerAddCustomizationPartToInventoryActor, Part) == 0x000008, "Member 'InventoryListComponent_ServerAddCustomizationPartToInventoryActor::Part' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerConsumeItem
// 0x0008 (0x0008 - 0x0000)
struct InventoryListComponent_ServerConsumeItem final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_ServerConsumeItem) == 0x000004, "Wrong alignment on InventoryListComponent_ServerConsumeItem");
static_assert(sizeof(InventoryListComponent_ServerConsumeItem) == 0x000008, "Wrong size on InventoryListComponent_ServerConsumeItem");
static_assert(offsetof(InventoryListComponent_ServerConsumeItem, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_ServerConsumeItem::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerConsumeItem, Quantity) == 0x000004, "Member 'InventoryListComponent_ServerConsumeItem::Quantity' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerDropItem
// 0x001C (0x001C - 0x0000)
struct InventoryListComponent_ServerDropItem final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialLocation;                                   // 0x0004(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InitialRotation;                                   // 0x0010(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_ServerDropItem) == 0x000004, "Wrong alignment on InventoryListComponent_ServerDropItem");
static_assert(sizeof(InventoryListComponent_ServerDropItem) == 0x00001C, "Wrong size on InventoryListComponent_ServerDropItem");
static_assert(offsetof(InventoryListComponent_ServerDropItem, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_ServerDropItem::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerDropItem, InitialLocation) == 0x000004, "Member 'InventoryListComponent_ServerDropItem::InitialLocation' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerDropItem, InitialRotation) == 0x000010, "Member 'InventoryListComponent_ServerDropItem::InitialRotation' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerRemoveCustomizationPartFromInventoryActor
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryCustomizationPartData*        Part;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor) == 0x000008, "Wrong alignment on InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor");
static_assert(sizeof(InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor) == 0x000010, "Wrong size on InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor");
static_assert(offsetof(InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor, Part) == 0x000008, "Member 'InventoryListComponent_ServerRemoveCustomizationPartFromInventoryActor::Part' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerRemoveItem
// 0x0004 (0x0004 - 0x0000)
struct InventoryListComponent_ServerRemoveItem final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_ServerRemoveItem) == 0x000004, "Wrong alignment on InventoryListComponent_ServerRemoveItem");
static_assert(sizeof(InventoryListComponent_ServerRemoveItem) == 0x000004, "Wrong size on InventoryListComponent_ServerRemoveItem");
static_assert(offsetof(InventoryListComponent_ServerRemoveItem, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_ServerRemoveItem::InventoryItemHandle' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerSetItemsUIFlags
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_ServerSetItemsUIFlags final
{
public:
	class UInventoryCategoryData*                 Category;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags_0;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FlagsMask;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_ServerSetItemsUIFlags) == 0x000008, "Wrong alignment on InventoryListComponent_ServerSetItemsUIFlags");
static_assert(sizeof(InventoryListComponent_ServerSetItemsUIFlags) == 0x000010, "Wrong size on InventoryListComponent_ServerSetItemsUIFlags");
static_assert(offsetof(InventoryListComponent_ServerSetItemsUIFlags, Category) == 0x000000, "Member 'InventoryListComponent_ServerSetItemsUIFlags::Category' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerSetItemsUIFlags, Flags_0) == 0x000008, "Member 'InventoryListComponent_ServerSetItemsUIFlags::Flags_0' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerSetItemsUIFlags, FlagsMask) == 0x000009, "Member 'InventoryListComponent_ServerSetItemsUIFlags::FlagsMask' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerSetItemUIFlags
// 0x0008 (0x0008 - 0x0000)
struct InventoryListComponent_ServerSetItemUIFlags final
{
public:
	struct FInventoryListEntryHandle              Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags_0;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FlagsMask;                                         // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_ServerSetItemUIFlags) == 0x000004, "Wrong alignment on InventoryListComponent_ServerSetItemUIFlags");
static_assert(sizeof(InventoryListComponent_ServerSetItemUIFlags) == 0x000008, "Wrong size on InventoryListComponent_ServerSetItemUIFlags");
static_assert(offsetof(InventoryListComponent_ServerSetItemUIFlags, Handle) == 0x000000, "Member 'InventoryListComponent_ServerSetItemUIFlags::Handle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerSetItemUIFlags, Flags_0) == 0x000004, "Member 'InventoryListComponent_ServerSetItemUIFlags::Flags_0' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerSetItemUIFlags, FlagsMask) == 0x000005, "Member 'InventoryListComponent_ServerSetItemUIFlags::FlagsMask' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.ServerTransferItem
// 0x0018 (0x0018 - 0x0000)
struct InventoryListComponent_ServerTransferItem final
{
public:
	struct FInventoryListEntryHandle              InventoryItemHandle;                               // 0x0000(0x0004)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DestinationActor;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_ServerTransferItem) == 0x000008, "Wrong alignment on InventoryListComponent_ServerTransferItem");
static_assert(sizeof(InventoryListComponent_ServerTransferItem) == 0x000018, "Wrong size on InventoryListComponent_ServerTransferItem");
static_assert(offsetof(InventoryListComponent_ServerTransferItem, InventoryItemHandle) == 0x000000, "Member 'InventoryListComponent_ServerTransferItem::InventoryItemHandle' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerTransferItem, DestinationActor) == 0x000008, "Member 'InventoryListComponent_ServerTransferItem::DestinationActor' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_ServerTransferItem, Quantity) == 0x000010, "Member 'InventoryListComponent_ServerTransferItem::Quantity' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.SizeInInventory
// 0x0010 (0x0010 - 0x0000)
struct InventoryListComponent_SizeInInventory final
{
public:
	class AInventoryItemPickup*                   PickupToTest;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_SizeInInventory) == 0x000008, "Wrong alignment on InventoryListComponent_SizeInInventory");
static_assert(sizeof(InventoryListComponent_SizeInInventory) == 0x000010, "Wrong size on InventoryListComponent_SizeInInventory");
static_assert(offsetof(InventoryListComponent_SizeInInventory, PickupToTest) == 0x000000, "Member 'InventoryListComponent_SizeInInventory::PickupToTest' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_SizeInInventory, ReturnValue) == 0x000008, "Member 'InventoryListComponent_SizeInInventory::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.CanSwapItemForPickup
// 0x0018 (0x0018 - 0x0000)
struct InventoryListComponent_CanSwapItemForPickup final
{
public:
	class AActor*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInventoryItemPickup*                   Pickup;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryListComponent_CanSwapItemForPickup) == 0x000008, "Wrong alignment on InventoryListComponent_CanSwapItemForPickup");
static_assert(sizeof(InventoryListComponent_CanSwapItemForPickup) == 0x000018, "Wrong size on InventoryListComponent_CanSwapItemForPickup");
static_assert(offsetof(InventoryListComponent_CanSwapItemForPickup, Item) == 0x000000, "Member 'InventoryListComponent_CanSwapItemForPickup::Item' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_CanSwapItemForPickup, Pickup) == 0x000008, "Member 'InventoryListComponent_CanSwapItemForPickup::Pickup' has a wrong offset!");
static_assert(offsetof(InventoryListComponent_CanSwapItemForPickup, ReturnValue) == 0x000010, "Member 'InventoryListComponent_CanSwapItemForPickup::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetInventoryItemCount
// 0x0004 (0x0004 - 0x0000)
struct InventoryListComponent_GetInventoryItemCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetInventoryItemCount) == 0x000004, "Wrong alignment on InventoryListComponent_GetInventoryItemCount");
static_assert(sizeof(InventoryListComponent_GetInventoryItemCount) == 0x000004, "Wrong size on InventoryListComponent_GetInventoryItemCount");
static_assert(offsetof(InventoryListComponent_GetInventoryItemCount, ReturnValue) == 0x000000, "Member 'InventoryListComponent_GetInventoryItemCount::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.GetMaxInventoryItems
// 0x0004 (0x0004 - 0x0000)
struct InventoryListComponent_GetMaxInventoryItems final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_GetMaxInventoryItems) == 0x000004, "Wrong alignment on InventoryListComponent_GetMaxInventoryItems");
static_assert(sizeof(InventoryListComponent_GetMaxInventoryItems) == 0x000004, "Wrong size on InventoryListComponent_GetMaxInventoryItems");
static_assert(offsetof(InventoryListComponent_GetMaxInventoryItems, ReturnValue) == 0x000000, "Member 'InventoryListComponent_GetMaxInventoryItems::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryListComponent.IsInventoryFull
// 0x0001 (0x0001 - 0x0000)
struct InventoryListComponent_IsInventoryFull final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryListComponent_IsInventoryFull) == 0x000001, "Wrong alignment on InventoryListComponent_IsInventoryFull");
static_assert(sizeof(InventoryListComponent_IsInventoryFull) == 0x000001, "Wrong size on InventoryListComponent_IsInventoryFull");
static_assert(offsetof(InventoryListComponent_IsInventoryFull, ReturnValue) == 0x000000, "Member 'InventoryListComponent_IsInventoryFull::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryData.EnumeratePickupFlyToTargets
// 0x0010 (0x0010 - 0x0000)
struct InventoryData_EnumeratePickupFlyToTargets final
{
public:
	TArray<class FName>                           Targets;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryData_EnumeratePickupFlyToTargets) == 0x000008, "Wrong alignment on InventoryData_EnumeratePickupFlyToTargets");
static_assert(sizeof(InventoryData_EnumeratePickupFlyToTargets) == 0x000010, "Wrong size on InventoryData_EnumeratePickupFlyToTargets");
static_assert(offsetof(InventoryData_EnumeratePickupFlyToTargets, Targets) == 0x000000, "Member 'InventoryData_EnumeratePickupFlyToTargets::Targets' has a wrong offset!");

// Function GbxInventory.DroppedInventoryItemPickup.OnPhysicsSleep
// 0x0010 (0x0010 - 0x0000)
struct DroppedInventoryItemPickup_OnPhysicsSleep final
{
public:
	class UPrimitiveComponent*                    WakingComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroppedInventoryItemPickup_OnPhysicsSleep) == 0x000008, "Wrong alignment on DroppedInventoryItemPickup_OnPhysicsSleep");
static_assert(sizeof(DroppedInventoryItemPickup_OnPhysicsSleep) == 0x000010, "Wrong size on DroppedInventoryItemPickup_OnPhysicsSleep");
static_assert(offsetof(DroppedInventoryItemPickup_OnPhysicsSleep, WakingComponent) == 0x000000, "Member 'DroppedInventoryItemPickup_OnPhysicsSleep::WakingComponent' has a wrong offset!");
static_assert(offsetof(DroppedInventoryItemPickup_OnPhysicsSleep, BoneName) == 0x000008, "Member 'DroppedInventoryItemPickup_OnPhysicsSleep::BoneName' has a wrong offset!");

// Function GbxInventory.DroppedInventoryItemPickup.OnPhysicsWake
// 0x0010 (0x0010 - 0x0000)
struct DroppedInventoryItemPickup_OnPhysicsWake final
{
public:
	class UPrimitiveComponent*                    WakingComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroppedInventoryItemPickup_OnPhysicsWake) == 0x000008, "Wrong alignment on DroppedInventoryItemPickup_OnPhysicsWake");
static_assert(sizeof(DroppedInventoryItemPickup_OnPhysicsWake) == 0x000010, "Wrong size on DroppedInventoryItemPickup_OnPhysicsWake");
static_assert(offsetof(DroppedInventoryItemPickup_OnPhysicsWake, WakingComponent) == 0x000000, "Member 'DroppedInventoryItemPickup_OnPhysicsWake::WakingComponent' has a wrong offset!");
static_assert(offsetof(DroppedInventoryItemPickup_OnPhysicsWake, BoneName) == 0x000008, "Member 'DroppedInventoryItemPickup_OnPhysicsWake::BoneName' has a wrong offset!");

// Function GbxInventory.DroppedInventoryItemPickup.OnPickupHit
// 0x00B8 (0x00B8 - 0x0000)
struct DroppedInventoryItemPickup_OnPickupHit final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0028(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DroppedInventoryItemPickup_OnPickupHit) == 0x000008, "Wrong alignment on DroppedInventoryItemPickup_OnPickupHit");
static_assert(sizeof(DroppedInventoryItemPickup_OnPickupHit) == 0x0000B8, "Wrong size on DroppedInventoryItemPickup_OnPickupHit");
static_assert(offsetof(DroppedInventoryItemPickup_OnPickupHit, HitComponent) == 0x000000, "Member 'DroppedInventoryItemPickup_OnPickupHit::HitComponent' has a wrong offset!");
static_assert(offsetof(DroppedInventoryItemPickup_OnPickupHit, OtherActor) == 0x000008, "Member 'DroppedInventoryItemPickup_OnPickupHit::OtherActor' has a wrong offset!");
static_assert(offsetof(DroppedInventoryItemPickup_OnPickupHit, OtherComp) == 0x000010, "Member 'DroppedInventoryItemPickup_OnPickupHit::OtherComp' has a wrong offset!");
static_assert(offsetof(DroppedInventoryItemPickup_OnPickupHit, NormalImpulse) == 0x000018, "Member 'DroppedInventoryItemPickup_OnPickupHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(DroppedInventoryItemPickup_OnPickupHit, Hit) == 0x000028, "Member 'DroppedInventoryItemPickup_OnPickupHit::Hit' has a wrong offset!");

// Function GbxInventory.InventoryBlueprintLibrary.BuildInventory
// 0x0088 (0x0088 - 0x0000)
struct InventoryBlueprintLibrary_BuildInventory final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreatePickup;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryBalanceStateInitializationData InitData;                                          // 0x0018(0x0068)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBlueprintLibrary_BuildInventory) == 0x000008, "Wrong alignment on InventoryBlueprintLibrary_BuildInventory");
static_assert(sizeof(InventoryBlueprintLibrary_BuildInventory) == 0x000088, "Wrong size on InventoryBlueprintLibrary_BuildInventory");
static_assert(offsetof(InventoryBlueprintLibrary_BuildInventory, WorldContextObject) == 0x000000, "Member 'InventoryBlueprintLibrary_BuildInventory::WorldContextObject' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_BuildInventory, bCreatePickup) == 0x000008, "Member 'InventoryBlueprintLibrary_BuildInventory::bCreatePickup' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_BuildInventory, SpawnLocation) == 0x00000C, "Member 'InventoryBlueprintLibrary_BuildInventory::SpawnLocation' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_BuildInventory, InitData) == 0x000018, "Member 'InventoryBlueprintLibrary_BuildInventory::InitData' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_BuildInventory, ReturnValue) == 0x000080, "Member 'InventoryBlueprintLibrary_BuildInventory::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBlueprintLibrary.CloneInventory
// 0x0010 (0x0010 - 0x0000)
struct InventoryBlueprintLibrary_CloneInventory final
{
public:
	class AActor*                                 SourceInventory;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBlueprintLibrary_CloneInventory) == 0x000008, "Wrong alignment on InventoryBlueprintLibrary_CloneInventory");
static_assert(sizeof(InventoryBlueprintLibrary_CloneInventory) == 0x000010, "Wrong size on InventoryBlueprintLibrary_CloneInventory");
static_assert(offsetof(InventoryBlueprintLibrary_CloneInventory, SourceInventory) == 0x000000, "Member 'InventoryBlueprintLibrary_CloneInventory::SourceInventory' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_CloneInventory, ReturnValue) == 0x000008, "Member 'InventoryBlueprintLibrary_CloneInventory::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBlueprintLibrary.CreateInventory
// 0x0088 (0x0088 - 0x0000)
struct InventoryBlueprintLibrary_CreateInventory final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreatePickup;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryBalanceStateInitializationData InitData;                                          // 0x0018(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBlueprintLibrary_CreateInventory) == 0x000008, "Wrong alignment on InventoryBlueprintLibrary_CreateInventory");
static_assert(sizeof(InventoryBlueprintLibrary_CreateInventory) == 0x000088, "Wrong size on InventoryBlueprintLibrary_CreateInventory");
static_assert(offsetof(InventoryBlueprintLibrary_CreateInventory, WorldContextObject) == 0x000000, "Member 'InventoryBlueprintLibrary_CreateInventory::WorldContextObject' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_CreateInventory, bCreatePickup) == 0x000008, "Member 'InventoryBlueprintLibrary_CreateInventory::bCreatePickup' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_CreateInventory, SpawnLocation) == 0x00000C, "Member 'InventoryBlueprintLibrary_CreateInventory::SpawnLocation' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_CreateInventory, InitData) == 0x000018, "Member 'InventoryBlueprintLibrary_CreateInventory::InitData' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_CreateInventory, ReturnValue) == 0x000080, "Member 'InventoryBlueprintLibrary_CreateInventory::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBlueprintLibrary.GetInventoryBalanceState
// 0x0010 (0x0010 - 0x0000)
struct InventoryBlueprintLibrary_GetInventoryBalanceState final
{
public:
	class AActor*                                 Inventory;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryBalanceStateComponent*        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBlueprintLibrary_GetInventoryBalanceState) == 0x000008, "Wrong alignment on InventoryBlueprintLibrary_GetInventoryBalanceState");
static_assert(sizeof(InventoryBlueprintLibrary_GetInventoryBalanceState) == 0x000010, "Wrong size on InventoryBlueprintLibrary_GetInventoryBalanceState");
static_assert(offsetof(InventoryBlueprintLibrary_GetInventoryBalanceState, Inventory) == 0x000000, "Member 'InventoryBlueprintLibrary_GetInventoryBalanceState::Inventory' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_GetInventoryBalanceState, ReturnValue) == 0x000008, "Member 'InventoryBlueprintLibrary_GetInventoryBalanceState::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryBlueprintLibrary.GetPossibleGenericParts
// 0x0040 (0x0040 - 0x0000)
struct InventoryBlueprintLibrary_GetPossibleGenericParts final
{
public:
	class UInventoryBalanceStateComponent*        InventoryBalanceState;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bMustHaveAllTags;                                  // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExcludeCurrentlySelectedParts;                    // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInventoryGenericPartData*>      ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryBlueprintLibrary_GetPossibleGenericParts) == 0x000008, "Wrong alignment on InventoryBlueprintLibrary_GetPossibleGenericParts");
static_assert(sizeof(InventoryBlueprintLibrary_GetPossibleGenericParts) == 0x000040, "Wrong size on InventoryBlueprintLibrary_GetPossibleGenericParts");
static_assert(offsetof(InventoryBlueprintLibrary_GetPossibleGenericParts, InventoryBalanceState) == 0x000000, "Member 'InventoryBlueprintLibrary_GetPossibleGenericParts::InventoryBalanceState' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_GetPossibleGenericParts, Tags) == 0x000008, "Member 'InventoryBlueprintLibrary_GetPossibleGenericParts::Tags' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_GetPossibleGenericParts, bMustHaveAllTags) == 0x000028, "Member 'InventoryBlueprintLibrary_GetPossibleGenericParts::bMustHaveAllTags' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_GetPossibleGenericParts, bExcludeCurrentlySelectedParts) == 0x000029, "Member 'InventoryBlueprintLibrary_GetPossibleGenericParts::bExcludeCurrentlySelectedParts' has a wrong offset!");
static_assert(offsetof(InventoryBlueprintLibrary_GetPossibleGenericParts, ReturnValue) == 0x000030, "Member 'InventoryBlueprintLibrary_GetPossibleGenericParts::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryPartData.GetMonetaryValueModifier
// 0x0038 (0x0038 - 0x0000)
struct InventoryPartData_GetMonetaryValueModifier final
{
public:
	struct FAttributeInitializationData           ReturnValue;                                       // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryPartData_GetMonetaryValueModifier) == 0x000008, "Wrong alignment on InventoryPartData_GetMonetaryValueModifier");
static_assert(sizeof(InventoryPartData_GetMonetaryValueModifier) == 0x000038, "Wrong size on InventoryPartData_GetMonetaryValueModifier");
static_assert(offsetof(InventoryPartData_GetMonetaryValueModifier, ReturnValue) == 0x000000, "Member 'InventoryPartData_GetMonetaryValueModifier::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetDisplayRarityOutline
// 0x0001 (0x0001 - 0x0000)
struct InventoryRarityData_GetDisplayRarityOutline final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetDisplayRarityOutline) == 0x000001, "Wrong alignment on InventoryRarityData_GetDisplayRarityOutline");
static_assert(sizeof(InventoryRarityData_GetDisplayRarityOutline) == 0x000001, "Wrong size on InventoryRarityData_GetDisplayRarityOutline");
static_assert(offsetof(InventoryRarityData_GetDisplayRarityOutline, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetDisplayRarityOutline::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetItemScoreRarityModifier
// 0x0038 (0x0038 - 0x0000)
struct InventoryRarityData_GetItemScoreRarityModifier final
{
public:
	struct FAttributeInitializationData           ReturnValue;                                       // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetItemScoreRarityModifier) == 0x000008, "Wrong alignment on InventoryRarityData_GetItemScoreRarityModifier");
static_assert(sizeof(InventoryRarityData_GetItemScoreRarityModifier) == 0x000038, "Wrong size on InventoryRarityData_GetItemScoreRarityModifier");
static_assert(offsetof(InventoryRarityData_GetItemScoreRarityModifier, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetItemScoreRarityModifier::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityColorFX
// 0x0010 (0x0010 - 0x0000)
struct InventoryRarityData_GetRarityColorFX final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityColorFX) == 0x000004, "Wrong alignment on InventoryRarityData_GetRarityColorFX");
static_assert(sizeof(InventoryRarityData_GetRarityColorFX) == 0x000010, "Wrong size on InventoryRarityData_GetRarityColorFX");
static_assert(offsetof(InventoryRarityData_GetRarityColorFX, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityColorFX::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityColorOutline
// 0x0010 (0x0010 - 0x0000)
struct InventoryRarityData_GetRarityColorOutline final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityColorOutline) == 0x000004, "Wrong alignment on InventoryRarityData_GetRarityColorOutline");
static_assert(sizeof(InventoryRarityData_GetRarityColorOutline) == 0x000010, "Wrong size on InventoryRarityData_GetRarityColorOutline");
static_assert(offsetof(InventoryRarityData_GetRarityColorOutline, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityColorOutline::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityDisplayName
// 0x0018 (0x0018 - 0x0000)
struct InventoryRarityData_GetRarityDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityDisplayName) == 0x000008, "Wrong alignment on InventoryRarityData_GetRarityDisplayName");
static_assert(sizeof(InventoryRarityData_GetRarityDisplayName) == 0x000018, "Wrong size on InventoryRarityData_GetRarityDisplayName");
static_assert(offsetof(InventoryRarityData_GetRarityDisplayName, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityDisplayName::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityLifeSpan
// 0x0004 (0x0004 - 0x0000)
struct InventoryRarityData_GetRarityLifeSpan final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityLifeSpan) == 0x000004, "Wrong alignment on InventoryRarityData_GetRarityLifeSpan");
static_assert(sizeof(InventoryRarityData_GetRarityLifeSpan) == 0x000004, "Wrong size on InventoryRarityData_GetRarityLifeSpan");
static_assert(offsetof(InventoryRarityData_GetRarityLifeSpan, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityLifeSpan::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityLifeSpanType
// 0x0001 (0x0001 - 0x0000)
struct InventoryRarityData_GetRarityLifeSpanType final
{
public:
	EDropLifeSpanType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityLifeSpanType) == 0x000001, "Wrong alignment on InventoryRarityData_GetRarityLifeSpanType");
static_assert(sizeof(InventoryRarityData_GetRarityLifeSpanType) == 0x000001, "Wrong size on InventoryRarityData_GetRarityLifeSpanType");
static_assert(offsetof(InventoryRarityData_GetRarityLifeSpanType, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityLifeSpanType::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityLootAudioStinger
// 0x0008 (0x0008 - 0x0000)
struct InventoryRarityData_GetRarityLootAudioStinger final
{
public:
	class UWwiseEvent*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityLootAudioStinger) == 0x000008, "Wrong alignment on InventoryRarityData_GetRarityLootAudioStinger");
static_assert(sizeof(InventoryRarityData_GetRarityLootAudioStinger) == 0x000008, "Wrong size on InventoryRarityData_GetRarityLootAudioStinger");
static_assert(offsetof(InventoryRarityData_GetRarityLootAudioStinger, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityLootAudioStinger::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityLootBeamHeight
// 0x0004 (0x0004 - 0x0000)
struct InventoryRarityData_GetRarityLootBeamHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityLootBeamHeight) == 0x000004, "Wrong alignment on InventoryRarityData_GetRarityLootBeamHeight");
static_assert(sizeof(InventoryRarityData_GetRarityLootBeamHeight) == 0x000004, "Wrong size on InventoryRarityData_GetRarityLootBeamHeight");
static_assert(offsetof(InventoryRarityData_GetRarityLootBeamHeight, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityLootBeamHeight::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityLootBeamOverride
// 0x0010 (0x0010 - 0x0000)
struct InventoryRarityData_GetRarityLootBeamOverride final
{
public:
	bool                                          bInventoryHasAFoilPart;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityLootBeamOverride) == 0x000008, "Wrong alignment on InventoryRarityData_GetRarityLootBeamOverride");
static_assert(sizeof(InventoryRarityData_GetRarityLootBeamOverride) == 0x000010, "Wrong size on InventoryRarityData_GetRarityLootBeamOverride");
static_assert(offsetof(InventoryRarityData_GetRarityLootBeamOverride, bInventoryHasAFoilPart) == 0x000000, "Member 'InventoryRarityData_GetRarityLootBeamOverride::bInventoryHasAFoilPart' has a wrong offset!");
static_assert(offsetof(InventoryRarityData_GetRarityLootBeamOverride, ReturnValue) == 0x000008, "Member 'InventoryRarityData_GetRarityLootBeamOverride::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRarityOutlineDepthStencilValue
// 0x0004 (0x0004 - 0x0000)
struct InventoryRarityData_GetRarityOutlineDepthStencilValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRarityOutlineDepthStencilValue) == 0x000004, "Wrong alignment on InventoryRarityData_GetRarityOutlineDepthStencilValue");
static_assert(sizeof(InventoryRarityData_GetRarityOutlineDepthStencilValue) == 0x000004, "Wrong size on InventoryRarityData_GetRarityOutlineDepthStencilValue");
static_assert(offsetof(InventoryRarityData_GetRarityOutlineDepthStencilValue, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRarityOutlineDepthStencilValue::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryRarityData.GetRaritySortValue
// 0x0004 (0x0004 - 0x0000)
struct InventoryRarityData_GetRaritySortValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryRarityData_GetRaritySortValue) == 0x000004, "Wrong alignment on InventoryRarityData_GetRaritySortValue");
static_assert(sizeof(InventoryRarityData_GetRaritySortValue) == 0x000004, "Wrong size on InventoryRarityData_GetRaritySortValue");
static_assert(offsetof(InventoryRarityData_GetRaritySortValue, ReturnValue) == 0x000000, "Member 'InventoryRarityData_GetRaritySortValue::ReturnValue' has a wrong offset!");

// Function GbxInventory.InventoryOwnerInterface.AttachedItemPickedUp
// 0x0010 (0x0010 - 0x0000)
struct InventoryOwnerInterface_AttachedItemPickedUp final
{
public:
	class AInventoryItemPickup*                   InventoryItemPickedUp;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PickedUpBy;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryOwnerInterface_AttachedItemPickedUp) == 0x000008, "Wrong alignment on InventoryOwnerInterface_AttachedItemPickedUp");
static_assert(sizeof(InventoryOwnerInterface_AttachedItemPickedUp) == 0x000010, "Wrong size on InventoryOwnerInterface_AttachedItemPickedUp");
static_assert(offsetof(InventoryOwnerInterface_AttachedItemPickedUp, InventoryItemPickedUp) == 0x000000, "Member 'InventoryOwnerInterface_AttachedItemPickedUp::InventoryItemPickedUp' has a wrong offset!");
static_assert(offsetof(InventoryOwnerInterface_AttachedItemPickedUp, PickedUpBy) == 0x000008, "Member 'InventoryOwnerInterface_AttachedItemPickedUp::PickedUpBy' has a wrong offset!");

// Function GbxInventory.ItemPoolPartSelectionOverrideData.EnumerateInventoryParts
// 0x0018 (0x0018 - 0x0000)
struct ItemPoolPartSelectionOverrideData_EnumerateInventoryParts final
{
public:
	uint8                                         PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorPartData*>                 OutPartList;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemPoolPartSelectionOverrideData_EnumerateInventoryParts) == 0x000008, "Wrong alignment on ItemPoolPartSelectionOverrideData_EnumerateInventoryParts");
static_assert(sizeof(ItemPoolPartSelectionOverrideData_EnumerateInventoryParts) == 0x000018, "Wrong size on ItemPoolPartSelectionOverrideData_EnumerateInventoryParts");
static_assert(offsetof(ItemPoolPartSelectionOverrideData_EnumerateInventoryParts, PartType) == 0x000000, "Member 'ItemPoolPartSelectionOverrideData_EnumerateInventoryParts::PartType' has a wrong offset!");
static_assert(offsetof(ItemPoolPartSelectionOverrideData_EnumerateInventoryParts, OutPartList) == 0x000008, "Member 'ItemPoolPartSelectionOverrideData_EnumerateInventoryParts::OutPartList' has a wrong offset!");

// Function GbxInventory.LootFunctionLibrary.SpawnItemsRaw
// 0x0048 (0x0048 - 0x0000)
struct LootFunctionLibrary_SpawnItemsRaw final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UItemPoolListData*>              ItemPoolLists;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FItemPoolInfo>                  ExtraItemPools;                                    // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         GameStage;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x002C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0038(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialVelocity;                                   // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootFunctionLibrary_SpawnItemsRaw) == 0x000008, "Wrong alignment on LootFunctionLibrary_SpawnItemsRaw");
static_assert(sizeof(LootFunctionLibrary_SpawnItemsRaw) == 0x000048, "Wrong size on LootFunctionLibrary_SpawnItemsRaw");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, WorldContextObject) == 0x000000, "Member 'LootFunctionLibrary_SpawnItemsRaw::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, ItemPoolLists) == 0x000008, "Member 'LootFunctionLibrary_SpawnItemsRaw::ItemPoolLists' has a wrong offset!");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, ExtraItemPools) == 0x000018, "Member 'LootFunctionLibrary_SpawnItemsRaw::ExtraItemPools' has a wrong offset!");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, GameStage) == 0x000028, "Member 'LootFunctionLibrary_SpawnItemsRaw::GameStage' has a wrong offset!");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, Location) == 0x00002C, "Member 'LootFunctionLibrary_SpawnItemsRaw::Location' has a wrong offset!");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, Rotation) == 0x000038, "Member 'LootFunctionLibrary_SpawnItemsRaw::Rotation' has a wrong offset!");
static_assert(offsetof(LootFunctionLibrary_SpawnItemsRaw, InitialVelocity) == 0x000044, "Member 'LootFunctionLibrary_SpawnItemsRaw::InitialVelocity' has a wrong offset!");

}

