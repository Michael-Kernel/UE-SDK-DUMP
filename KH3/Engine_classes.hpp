#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Engine

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InputCore_structs.hpp"
#include "PacketHandler_classes.hpp"


namespace SDK
{

// Class Engine.Actor
// 0x1EF72DC0 (0x1EF72E00 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AActor : public UObject
{
public:
	struct FActorTickFunction                     PrimaryActorTick;                                  // 0x0040(0x1EF72E00)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CustomTimeDilation;                                // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHidden : 1;                                       // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetTemporary : 1;                                 // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetStartup : 1;                                   // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyRelevantToOwner : 1;                          // 0x00A4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysRelevant : 1;                               // 0x00A4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReplicateMovement : 1;                            // 0x00A4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Net, DisableEditOnInstance, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTearOff : 1;                                      // 0x00A4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExchangedRoles : 1;                               // 0x00A4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A5_0 : 1;                                   // 0x00A5(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bNetLoadOnClient : 1;                              // 0x00A5(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetUseOwnerRelevancy : 1;                         // 0x00A5(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockInput : 1;                                   // 0x00A5(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A5_4 : 1;                                   // 0x00A5(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bAllowTickBeforeBeginPlay : 1;                     // 0x00A5(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A5_6 : 2;                                   // 0x00A5(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         BitPad_A6_0 : 1;                                   // 0x00A6(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bActorEnableCollision : 1;                         // 0x00A6(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_A6_2 : 1;                                   // 0x00A6(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bReplicates : 1;                                   // 0x00A6(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A7[0x1];                                       // 0x00A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NetDriverName;                                     // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENetRole                                      RemoteRole;                                        // 0x00B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x00B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRepMovement                           ReplicatedMovement;                                // 0x00C0(0x112E9AF0)(Edit, Net, DisableEditOnInstance, RepNotify, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FRepAttachment                         AttachmentReplication;                             // 0x00F8(0x112E9AF0)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ENetRole                                      Role;                                              // 0x0138(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x1];                                      // 0x0139(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EAutoReceiveInput                             AutoReceiveInput;                                  // 0x013A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x1];                                      // 0x013B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputPriority;                                     // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputComponent*                        InputComponent;                                    // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputConsumeOptions                          InputConsumeOption;                                // 0x0148(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetCullDistanceSquared;                            // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NetTag;                                            // 0x0150(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetUpdateFrequency;                                // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinNetUpdateFrequency;                             // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetPriority;                                       // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoDestroyWhenFinished : 1;                      // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeDamaged : 1;                                 // 0x0168(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActorIsBeingDestroyed : 1;                        // 0x0168(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_168_3 : 1;                                  // 0x0168(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bCollideWhenPlacing : 1;                           // 0x0168(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFindCameraComponentWhenViewTarget : 1;            // 0x0168(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRelevantForNetworkReplays : 1;                    // 0x0168(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateOverlapEventsDuringLevelStreaming : 1;    // 0x0168(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanBeInCluster : 1;                               // 0x0169(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ESpawnActorCollisionHandlingMethod            SpawnCollisionHandlingMethod;                      // 0x016A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B[0x5];                                      // 0x016B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Instigator;                                        // 0x0170(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Children;                                          // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootComponent;                                     // 0x0188(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AMatineeActor*>                  ControllingMatineeActors;                          // 0x0190(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         InitialLifeSpan;                                   // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4[0xC];                                      // 0x01A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Layers;                                            // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ParentComponentActor;                              // 0x01C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UChildActorComponent>    ParentComponent;                                   // 0x01C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAllowReceiveTickEventOnDedicatedServer : 1;       // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_1D0_1 : 3;                                  // 0x01D0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bActorSeamlessTraveled : 1;                        // 0x01D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoresOriginShifting : 1;                        // 0x01D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableAutoLODGeneration : 1;                      // 0x01D0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x01D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint64                                        HiddenEditorViews;                                 // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTakeAnyDamage;                                   // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTakePointDamage;                                 // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorBeginOverlap;                               // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorEndOverlap;                                 // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBeginCursorOver;                                 // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndCursorOver;                                   // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClicked;                                         // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReleased;                                        // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchBegin;                                 // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchEnd;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchEnter;                                 // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchLeave;                                 // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorHit;                                        // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDestroyed;                                       // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndPlay;                                         // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0xA0];                                     // 0x02E0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                BlueprintCreatedComponents;                        // 0x0380(0x0010)(ExportObject, ZeroConstructor, NonTransactional, ContainsInstancedReference, TextExportTransient, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                InstanceComponents;                                // 0x0390(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_ObjectType                              M_ObjType;                                         // 0x03B0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_bDisableObjTypeTimeDilation : 1;                 // 0x03B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         M_bIgnoreDangle : 1;                               // 0x03B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         M_bIgnoreWallRun : 1;                              // 0x03B4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         M_bPermissionLockOn : 1;                           // 0x03B4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         M_bDisableObjTypeCollision : 1;                    // 0x03B4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_AttackHitResponseType                   M_DefaultAttackHitResponse;                        // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstructionFactor;                                 // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_CameraFadeAlpha;                                 // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x1C];                                     // 0x03C4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UActorComponent* AddComponent(class FName TemplateName, bool bManualAttachment, const struct FTransform& RelativeTransform, const class UObject* ComponentTemplateContext);
	void AddTickPrerequisiteActor(class AActor* PrerequisiteActor);
	void AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
	void DetachRootComponentFromParent(bool bMaintainWorldPosition);
	void DisableInput(class APlayerController* PlayerController);
	void EnableInput(class APlayerController* PlayerController);
	void FlushNetDormancy();
	void ForceNetUpdate();
	float GetGameTimeSinceCreation();
	bool GetTickableWhenPaused();
	void K2_AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_AddActorLocalTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_AddActorWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_AttachRootComponentTo(class USceneComponent* InParent, class FName InSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies);
	void K2_AttachRootComponentToActor(class AActor* InParentActor, class FName InSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies);
	void K2_AttachToActor(class AActor* ParentActor, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	void K2_AttachToComponent(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	void K2_DestroyActor();
	void K2_DestroyComponent(class UActorComponent* Component);
	void K2_DetachFromActor(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule);
	void K2_OnBecomeViewTarget(class APlayerController* Pc);
	void K2_OnEndViewTarget(class APlayerController* Pc);
	void K2_OnReset();
	bool K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	bool K2_SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_SetActorRelativeTransform(const struct FTransform& NewRelativeTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	bool K2_SetActorRotation(const struct FRotator& NewRotation, bool bTeleportPhysics);
	bool K2_SetActorTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport);
	void K2_SqEX_AttachActorToActor(class AActor* InParentActor, class FName InBoneSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies);
	struct FVector K2_SqEX_GetActorBoneLocation(class FName InBoneSocketName);
	float K2_SqEX_GetCameraFadeAlpha();
	void K2_SqEX_SetCameraFadeAlpha(float InAlpha);
	bool K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation);
	class UMaterialInstanceDynamic* MakeMIDForMaterial(class UMaterialInterface* Parent);
	void MakeNoise(float Loudness, class APawn* NoiseInstigator, const struct FVector& NoiseLocation, float MaxRange, class FName Tag);
	void OnRep_AttachmentReplication();
	void OnRep_Instigator();
	void OnRep_Owner();
	void OnRep_ReplicatedMovement();
	void OnRep_ReplicateMovement();
	void OnRep_SQEX_ObjType();
	void OnSetActorHiddenInGame(bool bNewHidden);
	void ReceiveActorBeginCursorOver();
	void ReceiveActorBeginOverlap(class AActor* OtherActor);
	void ReceiveActorEndCursorOver();
	void ReceiveActorEndOverlap(class AActor* OtherActor);
	void ReceiveActorOnClicked(const struct FKey& ButtonPressed);
	void ReceiveActorOnInputTouchBegin(const ETouchIndex FingerIndex);
	void ReceiveActorOnInputTouchEnd(const ETouchIndex FingerIndex);
	void ReceiveActorOnInputTouchEnter(const ETouchIndex FingerIndex);
	void ReceiveActorOnInputTouchLeave(const ETouchIndex FingerIndex);
	void ReceiveActorOnReleased(const struct FKey& ButtonReleased);
	void ReceiveAnyDamage(float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void ReceiveBeginPlay();
	void ReceiveDestroyed();
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ReceivePointDamage(float Damage, const class UDamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser, const struct FHitResult& HitInfo);
	void ReceiveRadialDamage(float DamageReceived, const class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);
	void ReceiveTick(float DeltaSeconds);
	void RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor);
	void RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
	void SetActorEnableCollision(bool bNewActorEnableCollision);
	void SetActorHiddenInGame(bool bNewHidden);
	void SetActorRelativeScale3D(const struct FVector& NewRelativeScale);
	void SetActorScale3D(const struct FVector& NewScale3D);
	void SetActorTickEnabled(bool bEnabled);
	void SetActorTickInterval(float TickInterval);
	void SetLifeSpan(float InLifespan);
	void SetOwner(class AActor* NewOwner);
	void SetReplicateMovement(bool bInReplicateMovement);
	void SetReplicates(bool bInReplicates);
	void SetTickableWhenPaused(bool bTickableWhenPaused);
	void SetTickGroup(ETickingGroup NewTickGroup);
	void SnapRootComponentTo(class AActor* InParentActor, class FName InSocketName);
	void SQEX_EnableCollisionFromBrueprint(bool Enable);
	void SQEX_RegisterTickFunctionFromBlueprint(bool Enable, bool DoComponents);
	void SQEX_RegisterTickFunctionFromBlueprintEx(bool Enable, bool DoComponents, const TArray<class UActorComponent*>& IgnoreComponents);
	void SqEX_ServerSetObjType(ESQEX_ObjectType InObjType);
	void SQEX_SetHiddenFromBrueprint(bool Hidden);
	void TearOff();
	void UserConstructionScript();

	bool ActorHasTag(class FName Tag) const;
	void GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent) const;
	bool GetActorEnableCollision() const;
	void GetActorEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation) const;
	struct FVector GetActorForwardVector() const;
	struct FVector GetActorRelativeScale3D() const;
	struct FVector GetActorRightVector() const;
	struct FVector GetActorScale3D() const;
	float GetActorTickInterval() const;
	float GetActorTimeDilation() const;
	struct FVector GetActorUpVector() const;
	void GetAllChildActors(TArray<class AActor*>* ChildActors, bool bIncludeDescendants) const;
	void GetAttachedActors(TArray<class AActor*>* OutActors) const;
	class AActor* GetAttachParentActor() const;
	class FName GetAttachParentSocketName() const;
	class UActorComponent* GetComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const;
	TArray<class UActorComponent*> GetComponentsByClass(TSubclassOf<class UActorComponent> ComponentClass) const;
	TArray<class UActorComponent*> GetComponentsByTag(TSubclassOf<class UActorComponent> ComponentClass, class FName Tag) const;
	float GetDistanceTo(const class AActor* OtherActor) const;
	float GetDotProductTo(const class AActor* OtherActor) const;
	float GetHorizontalDistanceTo(const class AActor* OtherActor) const;
	float GetHorizontalDotProductTo(const class AActor* OtherActor) const;
	float GetInputAxisKeyValue(const struct FKey& InputAxisKey) const;
	float GetInputAxisValue(const class FName InputAxisName) const;
	struct FVector GetInputVectorAxisValue(const struct FKey& InputAxisKey) const;
	class APawn* GetInstigator() const;
	class AController* GetInstigatorController() const;
	float GetLifeSpan() const;
	void GetOverlappingActors(TArray<class AActor*>* OverlappingActors, TSubclassOf<class AActor> ClassFilter) const;
	void GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OverlappingComponents) const;
	class AActor* GetOwner() const;
	class AActor* GetParentActor() const;
	class UChildActorComponent* GetParentComponent() const;
	ENetRole GetRemoteRole() const;
	float GetSquaredDistanceTo(const class AActor* OtherActor) const;
	struct FVector GetTargetActorLocation() const;
	struct FTransform GetTransform() const;
	struct FVector GetVelocity() const;
	float GetVerticalDistanceTo(const class AActor* OtherActor) const;
	bool HasAuthority() const;
	bool IsActorBeingDestroyed() const;
	bool IsActorTickEnabled() const;
	bool IsChildActor() const;
	bool IsOverlappingActor(const class AActor* Other) const;
	struct FVector K2_GetActorLocation() const;
	struct FRotator K2_GetActorRotation() const;
	class USceneComponent* K2_GetRootComponent() const;
	struct FVector K2_SqEX_GetLockonCursorLookAtPos(int32 InIndex) const;
	struct FVector K2_SqEX_GetLockonCursorPos(int32 InIndex) const;
	int32 K2_SqEX_GetLockonCursorPosNum() const;
	ESQEX_ObjectType K2_SqEX_GetObjType() const;
	bool K2_SqEX_IsLockonCursorPosValid(int32 InIndex) const;
	bool SQEX_IsEnableCollisionFromBrueprint() const;
	bool SQEX_IsHidden() const;
	bool SQEX_IsHiddenFromBrueprint() const;
	bool SqEX_IsObjTypeCamera() const;
	bool SqEX_IsObjTypeEnemy() const;
	bool SqEX_IsObjTypeFriend() const;
	bool SqEX_IsObjTypeGimmick() const;
	bool SqEX_IsObjTypePlayer() const;
	bool SqEX_IsObjTypePrize() const;
	bool SqEX_IsObjTypeProjectile() const;
	bool SqEX_IsObjTypeVehicle() const;
	bool SQEX_IsRegisterTickFunctionFromBlueprint() const;
	bool WasRecentlyRendered(float Tolerance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Actor">();
	}
	static class AActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AActor) == 0x1EF72E00, "Wrong alignment on AActor");
static_assert(sizeof(AActor) == 0x1EF72E00, "Wrong size on AActor");
static_assert(offsetof(AActor, PrimaryActorTick) == 0x000040, "Member 'AActor::PrimaryActorTick' has a wrong offset!");
static_assert(offsetof(AActor, CustomTimeDilation) == 0x0000A0, "Member 'AActor::CustomTimeDilation' has a wrong offset!");
static_assert(offsetof(AActor, NetDriverName) == 0x0000A8, "Member 'AActor::NetDriverName' has a wrong offset!");
static_assert(offsetof(AActor, RemoteRole) == 0x0000B0, "Member 'AActor::RemoteRole' has a wrong offset!");
static_assert(offsetof(AActor, Owner) == 0x0000B8, "Member 'AActor::Owner' has a wrong offset!");
static_assert(offsetof(AActor, ReplicatedMovement) == 0x0000C0, "Member 'AActor::ReplicatedMovement' has a wrong offset!");
static_assert(offsetof(AActor, AttachmentReplication) == 0x0000F8, "Member 'AActor::AttachmentReplication' has a wrong offset!");
static_assert(offsetof(AActor, Role) == 0x000138, "Member 'AActor::Role' has a wrong offset!");
static_assert(offsetof(AActor, AutoReceiveInput) == 0x00013A, "Member 'AActor::AutoReceiveInput' has a wrong offset!");
static_assert(offsetof(AActor, InputPriority) == 0x00013C, "Member 'AActor::InputPriority' has a wrong offset!");
static_assert(offsetof(AActor, InputComponent) == 0x000140, "Member 'AActor::InputComponent' has a wrong offset!");
static_assert(offsetof(AActor, InputConsumeOption) == 0x000148, "Member 'AActor::InputConsumeOption' has a wrong offset!");
static_assert(offsetof(AActor, NetCullDistanceSquared) == 0x00014C, "Member 'AActor::NetCullDistanceSquared' has a wrong offset!");
static_assert(offsetof(AActor, NetTag) == 0x000150, "Member 'AActor::NetTag' has a wrong offset!");
static_assert(offsetof(AActor, NetUpdateFrequency) == 0x000158, "Member 'AActor::NetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AActor, MinNetUpdateFrequency) == 0x00015C, "Member 'AActor::MinNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AActor, NetPriority) == 0x000160, "Member 'AActor::NetPriority' has a wrong offset!");
static_assert(offsetof(AActor, SpawnCollisionHandlingMethod) == 0x00016A, "Member 'AActor::SpawnCollisionHandlingMethod' has a wrong offset!");
static_assert(offsetof(AActor, Instigator) == 0x000170, "Member 'AActor::Instigator' has a wrong offset!");
static_assert(offsetof(AActor, Children) == 0x000178, "Member 'AActor::Children' has a wrong offset!");
static_assert(offsetof(AActor, RootComponent) == 0x000188, "Member 'AActor::RootComponent' has a wrong offset!");
static_assert(offsetof(AActor, ControllingMatineeActors) == 0x000190, "Member 'AActor::ControllingMatineeActors' has a wrong offset!");
static_assert(offsetof(AActor, InitialLifeSpan) == 0x0001A0, "Member 'AActor::InitialLifeSpan' has a wrong offset!");
static_assert(offsetof(AActor, Layers) == 0x0001B0, "Member 'AActor::Layers' has a wrong offset!");
static_assert(offsetof(AActor, ParentComponentActor) == 0x0001C0, "Member 'AActor::ParentComponentActor' has a wrong offset!");
static_assert(offsetof(AActor, ParentComponent) == 0x0001C8, "Member 'AActor::ParentComponent' has a wrong offset!");
static_assert(offsetof(AActor, Tags) == 0x0001D8, "Member 'AActor::Tags' has a wrong offset!");
static_assert(offsetof(AActor, HiddenEditorViews) == 0x0001E8, "Member 'AActor::HiddenEditorViews' has a wrong offset!");
static_assert(offsetof(AActor, OnTakeAnyDamage) == 0x0001F0, "Member 'AActor::OnTakeAnyDamage' has a wrong offset!");
static_assert(offsetof(AActor, OnTakePointDamage) == 0x000200, "Member 'AActor::OnTakePointDamage' has a wrong offset!");
static_assert(offsetof(AActor, OnActorBeginOverlap) == 0x000210, "Member 'AActor::OnActorBeginOverlap' has a wrong offset!");
static_assert(offsetof(AActor, OnActorEndOverlap) == 0x000220, "Member 'AActor::OnActorEndOverlap' has a wrong offset!");
static_assert(offsetof(AActor, OnBeginCursorOver) == 0x000230, "Member 'AActor::OnBeginCursorOver' has a wrong offset!");
static_assert(offsetof(AActor, OnEndCursorOver) == 0x000240, "Member 'AActor::OnEndCursorOver' has a wrong offset!");
static_assert(offsetof(AActor, OnClicked) == 0x000250, "Member 'AActor::OnClicked' has a wrong offset!");
static_assert(offsetof(AActor, OnReleased) == 0x000260, "Member 'AActor::OnReleased' has a wrong offset!");
static_assert(offsetof(AActor, OnInputTouchBegin) == 0x000270, "Member 'AActor::OnInputTouchBegin' has a wrong offset!");
static_assert(offsetof(AActor, OnInputTouchEnd) == 0x000280, "Member 'AActor::OnInputTouchEnd' has a wrong offset!");
static_assert(offsetof(AActor, OnInputTouchEnter) == 0x000290, "Member 'AActor::OnInputTouchEnter' has a wrong offset!");
static_assert(offsetof(AActor, OnInputTouchLeave) == 0x0002A0, "Member 'AActor::OnInputTouchLeave' has a wrong offset!");
static_assert(offsetof(AActor, OnActorHit) == 0x0002B0, "Member 'AActor::OnActorHit' has a wrong offset!");
static_assert(offsetof(AActor, OnDestroyed) == 0x0002C0, "Member 'AActor::OnDestroyed' has a wrong offset!");
static_assert(offsetof(AActor, OnEndPlay) == 0x0002D0, "Member 'AActor::OnEndPlay' has a wrong offset!");
static_assert(offsetof(AActor, BlueprintCreatedComponents) == 0x000380, "Member 'AActor::BlueprintCreatedComponents' has a wrong offset!");
static_assert(offsetof(AActor, InstanceComponents) == 0x000390, "Member 'AActor::InstanceComponents' has a wrong offset!");
static_assert(offsetof(AActor, M_ObjType) == 0x0003B0, "Member 'AActor::M_ObjType' has a wrong offset!");
static_assert(offsetof(AActor, M_DefaultAttackHitResponse) == 0x0003B8, "Member 'AActor::M_DefaultAttackHitResponse' has a wrong offset!");
static_assert(offsetof(AActor, ObstructionFactor) == 0x0003BC, "Member 'AActor::ObstructionFactor' has a wrong offset!");
static_assert(offsetof(AActor, M_CameraFadeAlpha) == 0x0003C0, "Member 'AActor::M_CameraFadeAlpha' has a wrong offset!");

// Class Engine.MaterialExpression
// 0x0038 (0x0078 - 0x0040)
class UMaterialExpression : public UObject
{
public:
	class UMaterial*                              Material;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialFunction*                      Function;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BorderColor;                                       // 0x0060(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRealtimePreview : 1;                              // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNeedToUpdatePreview : 1;                          // 0x0064(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsParameterExpression : 1;                        // 0x0064(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCommentBubbleVisible : 1;                         // 0x0064(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowOutputNameOnPin : 1;                          // 0x0064(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowMaskColorsOnPin : 1;                          // 0x0064(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHidePreviewWindow : 1;                            // 0x0064(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCollapsed : 1;                                    // 0x0064(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShaderInputData : 1;                              // 0x0065(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowInputs : 1;                                   // 0x0065(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowOutputs : 1;                                  // 0x0065(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExpressionOutput>              Outputs;                                           // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpression">();
	}
	static class UMaterialExpression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpression>();
	}
};
static_assert(alignof(UMaterialExpression) == 0x000008, "Wrong alignment on UMaterialExpression");
static_assert(sizeof(UMaterialExpression) == 0x000078, "Wrong size on UMaterialExpression");
static_assert(offsetof(UMaterialExpression, Material) == 0x000040, "Member 'UMaterialExpression::Material' has a wrong offset!");
static_assert(offsetof(UMaterialExpression, Function) == 0x000048, "Member 'UMaterialExpression::Function' has a wrong offset!");
static_assert(offsetof(UMaterialExpression, Desc) == 0x000050, "Member 'UMaterialExpression::Desc' has a wrong offset!");
static_assert(offsetof(UMaterialExpression, BorderColor) == 0x000060, "Member 'UMaterialExpression::BorderColor' has a wrong offset!");
static_assert(offsetof(UMaterialExpression, Outputs) == 0x000068, "Member 'UMaterialExpression::Outputs' has a wrong offset!");

// Class Engine.MaterialExpressionConstantBiasScale
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionConstantBiasScale final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionConstantBiasScale">();
	}
	static class UMaterialExpressionConstantBiasScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionConstantBiasScale>();
	}
};
static_assert(alignof(UMaterialExpressionConstantBiasScale) == 0x112F2730, "Wrong alignment on UMaterialExpressionConstantBiasScale");
static_assert(sizeof(UMaterialExpressionConstantBiasScale) == 0x112F2730, "Wrong size on UMaterialExpressionConstantBiasScale");
static_assert(offsetof(UMaterialExpressionConstantBiasScale, Input) == 0x000078, "Member 'UMaterialExpressionConstantBiasScale::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionConstantBiasScale, Bias) == 0x0000B0, "Member 'UMaterialExpressionConstantBiasScale::Bias' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionConstantBiasScale, Scale) == 0x0000B4, "Member 'UMaterialExpressionConstantBiasScale::Scale' has a wrong offset!");

// Class Engine.BodySetup
// 0x11389E20 (0x11389E60 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x11389E60) UBodySetup : public UObject
{
public:
	struct FKAggregateGeom                        AggGeom;                                           // 0x0040(0x0048)(Edit, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0088(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsType                                  PhysicsType;                                       // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAlwaysFullAnimWeight : 1;                         // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConsiderForBounds : 1;                            // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMeshCollideAll : 1;                               // 0x0094(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoubleSidedGeometry : 1;                          // 0x0094(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateNonMirroredCollision : 1;                 // 0x0094(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSharedCookedData : 1;                             // 0x0094(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateMirroredCollision : 1;                    // 0x0094(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMaterial;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyCollisionResponse                        CollisionReponse;                                  // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           CollisionTraceFlag;                                // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0xE];                                       // 0x00A2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBodyInstance                          DefaultInstance;                                   // 0x00B0(0x11389E60)(Edit, NativeAccessSpecifierPublic)
	struct FWalkableSlopeOverride                 WalkableSlopeOverride;                             // 0x02E0(0x11389E60)(Edit, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         BuildScale;                                        // 0x02F0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BuildScale3D;                                      // 0x02F4(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0xB8];                                     // 0x0300(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodySetup">();
	}
	static class UBodySetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodySetup>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBodySetup) == 0x11389E60, "Wrong alignment on UBodySetup");
static_assert(sizeof(UBodySetup) == 0x11389E60, "Wrong size on UBodySetup");
static_assert(offsetof(UBodySetup, AggGeom) == 0x000040, "Member 'UBodySetup::AggGeom' has a wrong offset!");
static_assert(offsetof(UBodySetup, BoneName) == 0x000088, "Member 'UBodySetup::BoneName' has a wrong offset!");
static_assert(offsetof(UBodySetup, PhysicsType) == 0x000090, "Member 'UBodySetup::PhysicsType' has a wrong offset!");
static_assert(offsetof(UBodySetup, PhysMaterial) == 0x000098, "Member 'UBodySetup::PhysMaterial' has a wrong offset!");
static_assert(offsetof(UBodySetup, CollisionReponse) == 0x0000A0, "Member 'UBodySetup::CollisionReponse' has a wrong offset!");
static_assert(offsetof(UBodySetup, CollisionTraceFlag) == 0x0000A1, "Member 'UBodySetup::CollisionTraceFlag' has a wrong offset!");
static_assert(offsetof(UBodySetup, DefaultInstance) == 0x0000B0, "Member 'UBodySetup::DefaultInstance' has a wrong offset!");
static_assert(offsetof(UBodySetup, WalkableSlopeOverride) == 0x0002E0, "Member 'UBodySetup::WalkableSlopeOverride' has a wrong offset!");
static_assert(offsetof(UBodySetup, BuildScale) == 0x0002F0, "Member 'UBodySetup::BuildScale' has a wrong offset!");
static_assert(offsetof(UBodySetup, BuildScale3D) == 0x0002F4, "Member 'UBodySetup::BuildScale3D' has a wrong offset!");

// Class Engine.MovementComponent
// 0x0000 (0xD38D - 0xD38D)
#pragma pack(push, 0x1)
class alignas(0xD38D) UMovementComponent : public UActorComponent
{
public:
	class USceneComponent*                        UpdatedComponent;                                  // 0x0200(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0208(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x4];                                      // 0x0210(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0214(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bConstrainToPlane : 1;                             // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSnapToPlaneAtStart : 1;                           // 0x0220(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPlaneConstraintAxisSetting                   PlaneConstraintAxisSetting;                        // 0x0224(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlaneConstraintNormal;                             // 0x0228(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PlaneConstraintOrigin;                             // 0x0234(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUpdateOnlyIfRendered : 1;                         // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoUpdateTickRegistration : 1;                   // 0x0240(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTickBeforeOwner : 1;                              // 0x0240(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoRegisterUpdatedComponent : 1;                 // 0x0240(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, struct FHitResult* OutHit, bool bSweep, bool bTeleport);
	void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);
	void SetPlaneConstraintAxisSetting(EPlaneConstraintAxisSetting NewAxisSetting);
	void SetPlaneConstraintEnabled(bool bEnabled);
	void SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up);
	void SetPlaneConstraintNormal(const struct FVector& PlaneNormal);
	void SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin);
	void SetUpdatedComponent(class USceneComponent* NewUpdatedComponent);
	void SnapUpdatedComponentToPlane();
	void StopMovementImmediately();

	struct FVector ConstrainDirectionToPlane(const struct FVector& Direction) const;
	struct FVector ConstrainLocationToPlane(const struct FVector& Location) const;
	struct FVector ConstrainNormalToPlane(const struct FVector& Normal) const;
	float GetGravityZ() const;
	float GetMaxSpeed() const;
	class APhysicsVolume* GetPhysicsVolume() const;
	EPlaneConstraintAxisSetting GetPlaneConstraintAxisSetting() const;
	const struct FVector GetPlaneConstraintNormal() const;
	const struct FVector GetPlaneConstraintOrigin() const;
	bool IsExceedingMaxSpeed(float MaxSpeed) const;
	float K2_GetMaxSpeedModifier() const;
	float K2_GetModifiedMaxSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementComponent">();
	}
	static class UMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMovementComponent) == 0x00D38D, "Wrong alignment on UMovementComponent");
static_assert(sizeof(UMovementComponent) == 0x00D38D, "Wrong size on UMovementComponent");
static_assert(offsetof(UMovementComponent, UpdatedComponent) == 0x000200, "Member 'UMovementComponent::UpdatedComponent' has a wrong offset!");
static_assert(offsetof(UMovementComponent, UpdatedPrimitive) == 0x000208, "Member 'UMovementComponent::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(UMovementComponent, Velocity) == 0x000214, "Member 'UMovementComponent::Velocity' has a wrong offset!");
static_assert(offsetof(UMovementComponent, PlaneConstraintAxisSetting) == 0x000224, "Member 'UMovementComponent::PlaneConstraintAxisSetting' has a wrong offset!");
static_assert(offsetof(UMovementComponent, PlaneConstraintNormal) == 0x000228, "Member 'UMovementComponent::PlaneConstraintNormal' has a wrong offset!");
static_assert(offsetof(UMovementComponent, PlaneConstraintOrigin) == 0x000234, "Member 'UMovementComponent::PlaneConstraintOrigin' has a wrong offset!");

// Class Engine.NavMovementComponent
// 0x56D4 (0x12A61 - 0xD38D)
#pragma pack(push, 0x1)
class alignas(0x12A61) UNavMovementComponent : public UMovementComponent
{
public:
	struct FNavAgentProperties                    NavAgentProps;                                     // 0x0248(0x12A61)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedPathBrakingDistance;                          // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUpdateNavAgentWithOwnersCollision : 1;            // 0x026C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseAccelerationForPaths : 1;                      // 0x026C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, GlobalConfig, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseFixedBrakingDistanceForPaths : 1;              // 0x026C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementProperties                    MovementState;                                     // 0x0270(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0xC];                                      // 0x0274(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopActiveMovement();
	void StopMovementKeepPathing();

	bool IsCrouching() const;
	bool IsFalling() const;
	bool IsFlying() const;
	bool IsMovingOnGround() const;
	bool IsSwimming() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMovementComponent">();
	}
	static class UNavMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNavMovementComponent) == 0x012A61, "Wrong alignment on UNavMovementComponent");
static_assert(sizeof(UNavMovementComponent) == 0x012A61, "Wrong size on UNavMovementComponent");
static_assert(offsetof(UNavMovementComponent, NavAgentProps) == 0x000248, "Member 'UNavMovementComponent::NavAgentProps' has a wrong offset!");
static_assert(offsetof(UNavMovementComponent, FixedPathBrakingDistance) == 0x000268, "Member 'UNavMovementComponent::FixedPathBrakingDistance' has a wrong offset!");
static_assert(offsetof(UNavMovementComponent, MovementState) == 0x000270, "Member 'UNavMovementComponent::MovementState' has a wrong offset!");

// Class Engine.PawnMovementComponent
// 0x0000 (0x12A61 - 0x12A61)
#pragma pack(push, 0x1)
class alignas(0x12A61) UPawnMovementComponent : public UNavMovementComponent
{
public:
	class APawn*                                  PawnOwner;                                         // 0x0280(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddInputVector(const struct FVector& WorldVector, bool bForce);
	struct FVector ConsumeInputVector();

	struct FVector GetLastInputVector() const;
	class APawn* GetPawnOwner() const;
	struct FVector GetPendingInputVector() const;
	bool IsMoveInputIgnored() const;
	struct FVector K2_GetInputVector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnMovementComponent">();
	}
	static class UPawnMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPawnMovementComponent) == 0x012A61, "Wrong alignment on UPawnMovementComponent");
static_assert(sizeof(UPawnMovementComponent) == 0x012A61, "Wrong size on UPawnMovementComponent");
static_assert(offsetof(UPawnMovementComponent, PawnOwner) == 0x000280, "Member 'UPawnMovementComponent::PawnOwner' has a wrong offset!");

// Class Engine.MaterialExpressionSceneDepth
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSceneDepth final : public UMaterialExpression
{
public:
	EMaterialSceneAttributeInputMode              InputMode;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Input;                                             // 0x0080(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Coordinates;                                       // 0x00B8(0x112F2730)(Deprecated, NativeAccessSpecifierPublic)
	struct FVector2D                              ConstInput;                                        // 0x00F0(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSceneDepth">();
	}
	static class UMaterialExpressionSceneDepth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSceneDepth>();
	}
};
static_assert(alignof(UMaterialExpressionSceneDepth) == 0x112F2730, "Wrong alignment on UMaterialExpressionSceneDepth");
static_assert(sizeof(UMaterialExpressionSceneDepth) == 0x112F2730, "Wrong size on UMaterialExpressionSceneDepth");
static_assert(offsetof(UMaterialExpressionSceneDepth, InputMode) == 0x000078, "Member 'UMaterialExpressionSceneDepth::InputMode' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneDepth, Input) == 0x000080, "Member 'UMaterialExpressionSceneDepth::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneDepth, Coordinates) == 0x0000B8, "Member 'UMaterialExpressionSceneDepth::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneDepth, ConstInput) == 0x0000F0, "Member 'UMaterialExpressionSceneDepth::ConstInput' has a wrong offset!");

// Class Engine.Pawn
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) APawn : public AActor
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseControllerRotationPitch : 1;                   // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseControllerRotationYaw : 1;                     // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseControllerRotationRoll : 1;                    // 0x03E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanAffectNavigationGeneration : 1;                // 0x03E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseEyeHeight;                                     // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoReceiveInput                             AutoPossessPlayer;                                 // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoPossessAI                                AutoPossessAI;                                     // 0x03F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F2[0x6];                                      // 0x03F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AController>                AIControllerClass;                                 // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerState;                                       // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RemoteViewPitch;                                   // 0x0408(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            LastHitBy;                                         // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Controller;                                        // 0x0418(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ControlInputVector;                                // 0x0428(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastControlInputVector;                            // 0x0434(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class AActor* GetMovementBaseActor(const class APawn* Pawn);

	void AddControllerPitchInput(float Val);
	void AddControllerRollInput(float Val);
	void AddControllerYawInput(float Val);
	void AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce);
	struct FVector ConsumeMovementInputVector();
	void DetachFromControllerPendingDestroy();
	void LaunchPawn(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride);
	void OnRep_Controller();
	void OnRep_PlayerState();
	void PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker);
	void ReceivePossessed(class AController* NewController);
	void ReceiveUnpossessed(class AController* OldController);
	void SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate);
	void SpawnDefaultController();

	struct FRotator GetBaseAimRotation() const;
	class AController* GetController() const;
	struct FRotator GetControlRotation() const;
	struct FVector GetLastMovementInputVector() const;
	class UPawnMovementComponent* GetMovementComponent() const;
	struct FVector GetNavAgentLocation() const;
	struct FVector GetPendingMovementInputVector() const;
	bool IsControlled() const;
	bool IsLocallyControlled() const;
	bool IsMoveInputIgnored() const;
	bool IsPlayerControlled() const;
	struct FVector K2_GetMovementInputVector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pawn">();
	}
	static class APawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<APawn>();
	}
};
#pragma pack(pop)
static_assert(alignof(APawn) == 0x1EF72E00, "Wrong alignment on APawn");
static_assert(sizeof(APawn) == 0x1EF72E00, "Wrong size on APawn");
static_assert(offsetof(APawn, BaseEyeHeight) == 0x0003EC, "Member 'APawn::BaseEyeHeight' has a wrong offset!");
static_assert(offsetof(APawn, AutoPossessPlayer) == 0x0003F0, "Member 'APawn::AutoPossessPlayer' has a wrong offset!");
static_assert(offsetof(APawn, AutoPossessAI) == 0x0003F1, "Member 'APawn::AutoPossessAI' has a wrong offset!");
static_assert(offsetof(APawn, AIControllerClass) == 0x0003F8, "Member 'APawn::AIControllerClass' has a wrong offset!");
static_assert(offsetof(APawn, PlayerState) == 0x000400, "Member 'APawn::PlayerState' has a wrong offset!");
static_assert(offsetof(APawn, RemoteViewPitch) == 0x000408, "Member 'APawn::RemoteViewPitch' has a wrong offset!");
static_assert(offsetof(APawn, LastHitBy) == 0x000410, "Member 'APawn::LastHitBy' has a wrong offset!");
static_assert(offsetof(APawn, Controller) == 0x000418, "Member 'APawn::Controller' has a wrong offset!");
static_assert(offsetof(APawn, ControlInputVector) == 0x000428, "Member 'APawn::ControlInputVector' has a wrong offset!");
static_assert(offsetof(APawn, LastControlInputVector) == 0x000434, "Member 'APawn::LastControlInputVector' has a wrong offset!");

// Class Engine.BlueprintAsyncActionBase
// 0x0000 (0x0040 - 0x0040)
class UBlueprintAsyncActionBase : public UObject
{
public:
	void Activate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintAsyncActionBase">();
	}
	static class UBlueprintAsyncActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintAsyncActionBase>();
	}
};
static_assert(alignof(UBlueprintAsyncActionBase) == 0x000008, "Wrong alignment on UBlueprintAsyncActionBase");
static_assert(sizeof(UBlueprintAsyncActionBase) == 0x000040, "Wrong size on UBlueprintAsyncActionBase");

// Class Engine.AsyncActionLoadPrimaryAssetBase
// 0x0048 (0x0088 - 0x0040)
class UAsyncActionLoadPrimaryAssetBase : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionLoadPrimaryAssetBase">();
	}
	static class UAsyncActionLoadPrimaryAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionLoadPrimaryAssetBase>();
	}
};
static_assert(alignof(UAsyncActionLoadPrimaryAssetBase) == 0x000008, "Wrong alignment on UAsyncActionLoadPrimaryAssetBase");
static_assert(sizeof(UAsyncActionLoadPrimaryAssetBase) == 0x000088, "Wrong size on UAsyncActionLoadPrimaryAssetBase");

// Class Engine.AsyncActionLoadPrimaryAssetList
// 0x0010 (0x0098 - 0x0088)
class UAsyncActionLoadPrimaryAssetList final : public UAsyncActionLoadPrimaryAssetBase
{
public:
	UMulticastDelegateProperty_                   Completed;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncActionLoadPrimaryAssetList* AsyncLoadPrimaryAssetList(const TArray<struct FPrimaryAssetId>& PrimaryAssetList, const TArray<class FName>& LoadBundles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionLoadPrimaryAssetList">();
	}
	static class UAsyncActionLoadPrimaryAssetList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionLoadPrimaryAssetList>();
	}
};
static_assert(alignof(UAsyncActionLoadPrimaryAssetList) == 0x000008, "Wrong alignment on UAsyncActionLoadPrimaryAssetList");
static_assert(sizeof(UAsyncActionLoadPrimaryAssetList) == 0x000098, "Wrong size on UAsyncActionLoadPrimaryAssetList");
static_assert(offsetof(UAsyncActionLoadPrimaryAssetList, Completed) == 0x000088, "Member 'UAsyncActionLoadPrimaryAssetList::Completed' has a wrong offset!");

// Class Engine.AnimNotify
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetNotifyName() const;
	bool Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify">();
	}
	static class UAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify>();
	}
};
static_assert(alignof(UAnimNotify) == 0x000008, "Wrong alignment on UAnimNotify");
static_assert(sizeof(UAnimNotify) == 0x000050, "Wrong size on UAnimNotify");

// Class Engine.Polys
// 0x0010 (0x0050 - 0x0040)
class UPolys final : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Polys">();
	}
	static class UPolys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolys>();
	}
};
static_assert(alignof(UPolys) == 0x000008, "Wrong alignment on UPolys");
static_assert(sizeof(UPolys) == 0x000050, "Wrong size on UPolys");

// Class Engine.ExponentialHeightFogComponent
// 0x1390 (0x112EAE80 - 0x112E9AF0)
class UExponentialHeightFogComponent final : public USceneComponent
{
public:
	float                                         FogDensity;                                        // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x041C(0x112EAE80)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           InscatteringColorCubemap;                          // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InscatteringColorCubemapAngle;                     // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InscatteringTextureTint;                           // 0x043C(0x112EAE80)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullyDirectionalInscatteringColorDistance;         // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonDirectionalInscatteringColorDistance;           // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringExponent;                   // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringStartDistance;              // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x045C(0x112EAE80)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity;                                     // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogCutoffDistance;                                 // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVolumetricFog;                              // 0x047C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47D[0x3];                                      // 0x047D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricFogScatteringDistribution;               // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 VolumetricFogAlbedo;                               // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VolumetricFogEmissive;                             // 0x0488(0x112EAE80)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogExtinctionScale;                      // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogDistance;                             // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightColorsWithFogInscatteringColors;     // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_HeightFogDirectivity                    SQEXHeightFogDirectivityMode;                      // 0x04A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A2[0x2];                                      // 0x04A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SQEXHeightFogPositiveSize;                         // 0x04A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SQEXHeightFogNegativeSize;                         // 0x04B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexUsePostprocessExpFogParam;                    // 0x04BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BD[0x3];                                      // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SQEXHeightFogInterpolationDistance;                // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXHeightFogInterpolationExponent;                // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXDeepFallOffDepth;                              // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXDeepFallOffRate;                               // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXDeepFallOffRestoreExponent;                    // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0xC];                                      // 0x04D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDirectionalInscatteringColor(const struct FLinearColor& Value);
	void SetDirectionalInscatteringExponent(float Value);
	void SetDirectionalInscatteringStartDistance(float Value);
	void SetFogCutoffDistance(float Value);
	void SetFogDensity(float Value);
	void SetFogHeightFalloff(float Value);
	void SetFogInscatteringColor(const struct FLinearColor& Value);
	void SetFogMaxOpacity(float Value);
	void SetFullyDirectionalInscatteringColorDistance(float Value);
	void SetInscatteringColorCubemap(class UTextureCube* Value);
	void SetInscatteringColorCubemapAngle(float Value);
	void SetInscatteringTextureTint(const struct FLinearColor& Value);
	void SetNonDirectionalInscatteringColorDistance(float Value);
	void SetSQEXHeightFogNegativeSize(const struct FVector& Value);
	void SetSQEXHeightFogPositiveSize(const struct FVector& Value);
	void SetStartDistance(float Value);
	void SetVolumetricFog(bool bNewValue);
	void SetVolumetricFogAlbedo(const struct FColor& NewValue);
	void SetVolumetricFogDistance(float NewValue);
	void SetVolumetricFogEmissive(const struct FLinearColor& NewValue);
	void SetVolumetricFogExtinctionScale(float NewValue);
	void SetVolumetricFogScatteringDistribution(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExponentialHeightFogComponent">();
	}
	static class UExponentialHeightFogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExponentialHeightFogComponent>();
	}
};
static_assert(alignof(UExponentialHeightFogComponent) == 0x112EAE80, "Wrong alignment on UExponentialHeightFogComponent");
static_assert(sizeof(UExponentialHeightFogComponent) == 0x112EAE80, "Wrong size on UExponentialHeightFogComponent");
static_assert(offsetof(UExponentialHeightFogComponent, FogDensity) == 0x000418, "Member 'UExponentialHeightFogComponent::FogDensity' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, FogInscatteringColor) == 0x00041C, "Member 'UExponentialHeightFogComponent::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, InscatteringColorCubemap) == 0x000430, "Member 'UExponentialHeightFogComponent::InscatteringColorCubemap' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, InscatteringColorCubemapAngle) == 0x000438, "Member 'UExponentialHeightFogComponent::InscatteringColorCubemapAngle' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, InscatteringTextureTint) == 0x00043C, "Member 'UExponentialHeightFogComponent::InscatteringTextureTint' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, FullyDirectionalInscatteringColorDistance) == 0x00044C, "Member 'UExponentialHeightFogComponent::FullyDirectionalInscatteringColorDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, NonDirectionalInscatteringColorDistance) == 0x000450, "Member 'UExponentialHeightFogComponent::NonDirectionalInscatteringColorDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, DirectionalInscatteringExponent) == 0x000454, "Member 'UExponentialHeightFogComponent::DirectionalInscatteringExponent' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, DirectionalInscatteringStartDistance) == 0x000458, "Member 'UExponentialHeightFogComponent::DirectionalInscatteringStartDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, DirectionalInscatteringColor) == 0x00045C, "Member 'UExponentialHeightFogComponent::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, FogHeightFalloff) == 0x00046C, "Member 'UExponentialHeightFogComponent::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, FogMaxOpacity) == 0x000470, "Member 'UExponentialHeightFogComponent::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, StartDistance) == 0x000474, "Member 'UExponentialHeightFogComponent::StartDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, FogCutoffDistance) == 0x000478, "Member 'UExponentialHeightFogComponent::FogCutoffDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, bEnableVolumetricFog) == 0x00047C, "Member 'UExponentialHeightFogComponent::bEnableVolumetricFog' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, VolumetricFogScatteringDistribution) == 0x000480, "Member 'UExponentialHeightFogComponent::VolumetricFogScatteringDistribution' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, VolumetricFogAlbedo) == 0x000484, "Member 'UExponentialHeightFogComponent::VolumetricFogAlbedo' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, VolumetricFogEmissive) == 0x000488, "Member 'UExponentialHeightFogComponent::VolumetricFogEmissive' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, VolumetricFogExtinctionScale) == 0x000498, "Member 'UExponentialHeightFogComponent::VolumetricFogExtinctionScale' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, VolumetricFogDistance) == 0x00049C, "Member 'UExponentialHeightFogComponent::VolumetricFogDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, bOverrideLightColorsWithFogInscatteringColors) == 0x0004A0, "Member 'UExponentialHeightFogComponent::bOverrideLightColorsWithFogInscatteringColors' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXHeightFogDirectivityMode) == 0x0004A1, "Member 'UExponentialHeightFogComponent::SQEXHeightFogDirectivityMode' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXHeightFogPositiveSize) == 0x0004A4, "Member 'UExponentialHeightFogComponent::SQEXHeightFogPositiveSize' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXHeightFogNegativeSize) == 0x0004B0, "Member 'UExponentialHeightFogComponent::SQEXHeightFogNegativeSize' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, bSqexUsePostprocessExpFogParam) == 0x0004BC, "Member 'UExponentialHeightFogComponent::bSqexUsePostprocessExpFogParam' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXHeightFogInterpolationDistance) == 0x0004C0, "Member 'UExponentialHeightFogComponent::SQEXHeightFogInterpolationDistance' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXHeightFogInterpolationExponent) == 0x0004C4, "Member 'UExponentialHeightFogComponent::SQEXHeightFogInterpolationExponent' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXDeepFallOffDepth) == 0x0004C8, "Member 'UExponentialHeightFogComponent::SQEXDeepFallOffDepth' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXDeepFallOffRate) == 0x0004CC, "Member 'UExponentialHeightFogComponent::SQEXDeepFallOffRate' has a wrong offset!");
static_assert(offsetof(UExponentialHeightFogComponent, SQEXDeepFallOffRestoreExponent) == 0x0004D0, "Member 'UExponentialHeightFogComponent::SQEXDeepFallOffRestoreExponent' has a wrong offset!");

// Class Engine.MaterialExpressionParameter
// 0x112E8CA8 (0x112E8D20 - 0x0078)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UMaterialExpressionParameter : public UMaterialExpression
{
public:
	class FName                                   ParameterName;                                     // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0080(0x112E8D20)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Group;                                             // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParameter">();
	}
	static class UMaterialExpressionParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParameter>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaterialExpressionParameter) == 0x112E8D20, "Wrong alignment on UMaterialExpressionParameter");
static_assert(sizeof(UMaterialExpressionParameter) == 0x112E8D20, "Wrong size on UMaterialExpressionParameter");
static_assert(offsetof(UMaterialExpressionParameter, ParameterName) == 0x000078, "Member 'UMaterialExpressionParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParameter, ExpressionGUID) == 0x000080, "Member 'UMaterialExpressionParameter::ExpressionGUID' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParameter, Group) == 0x000090, "Member 'UMaterialExpressionParameter::Group' has a wrong offset!");

// Class Engine.CheatManager
// 0x0050 (0x0090 - 0x0040)
class UCheatManager : public UObject
{
public:
	class ADebugCameraController*                 DebugCameraControllerRef;                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADebugCameraController>     DebugCameraControllerClass;                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BugIt(const class FString& ScreenShotDescription);
	void BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll);
	void BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, class FString* GoString, class FString* LocString);
	void ChangeSize(float F);
	void CheatScript(const class FString& ScriptName);
	void DamageTarget(float DamageAmount);
	void DebugCapsuleSweep();
	void DebugCapsuleSweepCapture();
	void DebugCapsuleSweepChannel(ECollisionChannel Channel);
	void DebugCapsuleSweepClear();
	void DebugCapsuleSweepComplex(bool bTraceComplex);
	void DebugCapsuleSweepPawn();
	void DebugCapsuleSweepSize(float HalfHeight, float Radius);
	void DestroyAll(TSubclassOf<class AActor> AClass);
	void DestroyAllPawnsExceptTarget();
	void DestroyPawns(TSubclassOf<class APawn> AClass);
	void DestroyTarget();
	void DisableDebugCamera();
	void DumpChatState();
	void DumpOnlineSessionState();
	void DumpPartyState();
	void DumpVoiceMutingState();
	void EnableDebugCamera();
	void FlushLog();
	void Fly();
	void FreezeFrame(float Delay);
	void Ghost();
	void God();
	void InvertMouse();
	void LogLoc();
	void OnlyLoadLevel(class FName PackageName);
	void PlayersOnly();
	void RebuildNavigation();
	void ReceiveEndPlay();
	void ReceiveInitCheatManager();
	void ServerToggleAILogging();
	void SetMouseSensitivityToDefault();
	void SetNavDrawDistance(float DrawDistance);
	void SetWorldOrigin();
	void Slomo(float NewTimeDilation);
	void StreamLevelIn(class FName PackageName);
	void StreamLevelOut(class FName PackageName);
	void Summon(const class FString& ClassName);
	void Teleport();
	void TestCollisionDistance();
	void ToggleAILogging();
	void ToggleDebugCamera();
	void ViewActor(class FName ActorName);
	void ViewClass(TSubclassOf<class AActor> DesiredClass);
	void ViewPlayer(const class FString& S);
	void ViewSelf();
	void Walk();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatManager">();
	}
	static class UCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatManager>();
	}
};
static_assert(alignof(UCheatManager) == 0x000008, "Wrong alignment on UCheatManager");
static_assert(sizeof(UCheatManager) == 0x000090, "Wrong size on UCheatManager");
static_assert(offsetof(UCheatManager, DebugCameraControllerRef) == 0x000040, "Member 'UCheatManager::DebugCameraControllerRef' has a wrong offset!");
static_assert(offsetof(UCheatManager, DebugCameraControllerClass) == 0x000048, "Member 'UCheatManager::DebugCameraControllerClass' has a wrong offset!");

// Class Engine.InterpTrackInst
// 0x0000 (0x0040 - 0x0040)
class UInterpTrackInst : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInst">();
	}
	static class UInterpTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInst>();
	}
};
static_assert(alignof(UInterpTrackInst) == 0x000008, "Wrong alignment on UInterpTrackInst");
static_assert(sizeof(UInterpTrackInst) == 0x000040, "Wrong size on UInterpTrackInst");

// Class Engine.InterpTrackInstToggle
// 0x0010 (0x0050 - 0x0040)
class UInterpTrackInstToggle final : public UInterpTrackInst
{
public:
	ETrackToggleAction                            Action;                                            // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastUpdatePosition;                                // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSavedActiveState : 1;                             // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstToggle">();
	}
	static class UInterpTrackInstToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstToggle>();
	}
};
static_assert(alignof(UInterpTrackInstToggle) == 0x000008, "Wrong alignment on UInterpTrackInstToggle");
static_assert(sizeof(UInterpTrackInstToggle) == 0x000050, "Wrong size on UInterpTrackInstToggle");
static_assert(offsetof(UInterpTrackInstToggle, Action) == 0x000040, "Member 'UInterpTrackInstToggle::Action' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstToggle, LastUpdatePosition) == 0x000044, "Member 'UInterpTrackInstToggle::LastUpdatePosition' has a wrong offset!");

// Class Engine.ParticleModule
// 0x0010 (0x0050 - 0x0040)
class UParticleModule : public UObject
{
public:
	uint8                                         bSpawnModule : 1;                                  // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateModule : 1;                                 // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinalUpdateModule : 1;                            // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinalTickComponentModule : 1;                     // 0x0040(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bParticleUpdateModule : 1;                         // 0x0040(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateForGPUEmitter : 1;                          // 0x0040(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCurvesAsColor : 1;                                // 0x0040(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         b3DDrawMode : 1;                                   // 0x0040(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugSphareSizeScale;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSupported3DDrawMode : 1;                          // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnabled : 1;                                      // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEditable : 1;                                     // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         LODDuplicate : 1;                                  // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsRandomSeed : 1;                           // 0x0048(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequiresLoopingNotification : 1;                  // 0x0048(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         LODValidity;                                       // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModule">();
	}
	static class UParticleModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModule>();
	}
};
static_assert(alignof(UParticleModule) == 0x000008, "Wrong alignment on UParticleModule");
static_assert(sizeof(UParticleModule) == 0x000050, "Wrong size on UParticleModule");
static_assert(offsetof(UParticleModule, DebugSphareSizeScale) == 0x000044, "Member 'UParticleModule::DebugSphareSizeScale' has a wrong offset!");
static_assert(offsetof(UParticleModule, LODValidity) == 0x00004C, "Member 'UParticleModule::LODValidity' has a wrong offset!");

// Class Engine.ParticleModuleKillBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleKillBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleKillBase">();
	}
	static class UParticleModuleKillBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleKillBase>();
	}
};
static_assert(alignof(UParticleModuleKillBase) == 0x000008, "Wrong alignment on UParticleModuleKillBase");
static_assert(sizeof(UParticleModuleKillBase) == 0x000050, "Wrong size on UParticleModuleKillBase");

// Class Engine.Light
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ALight : public AActor
{
public:
	class ULightComponent*                        LightComponent;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnabled : 1;                                      // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bEnabled();
	void SetAffectTranslucentLighting(bool bNewValue);
	void SetBrightness(float NewBrightness);
	void SetCastShadows(bool bNewValue);
	void SetEnabled(bool bSetEnabled);
	void SetLightColor(const struct FLinearColor& NewLightColor);
	void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
	void SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial);
	void SetLightFunctionScale(const struct FVector& NewLightFunctionScale);
	void ToggleEnabled();

	float GetBrightness() const;
	struct FLinearColor GetLightColor() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Light">();
	}
	static class ALight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALight>();
	}
};
#pragma pack(pop)
static_assert(alignof(ALight) == 0x1EF72E00, "Wrong alignment on ALight");
static_assert(sizeof(ALight) == 0x1EF72E00, "Wrong size on ALight");
static_assert(offsetof(ALight, LightComponent) == 0x0003E0, "Member 'ALight::LightComponent' has a wrong offset!");

// Class Engine.PointLight
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APointLight final : public ALight
{
public:
	class UPointLightComponent*                   PointLightComponent;                               // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetLightFalloffExponent(float NewLightFalloffExponent);
	void SetRadius(float NewRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointLight">();
	}
	static class APointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<APointLight>();
	}
};
static_assert(alignof(APointLight) == 0x1EF72E00, "Wrong alignment on APointLight");
static_assert(sizeof(APointLight) == 0x1EF72E00, "Wrong size on APointLight");
static_assert(offsetof(APointLight, PointLightComponent) == 0x0003F0, "Member 'APointLight::PointLightComponent' has a wrong offset!");

// Class Engine.Console
// 0x0108 (0x0148 - 0x0040)
class UConsole final : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayer*                           ConsoleTargetPlayer;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultTexture_Black;                              // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultTexture_White;                              // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         HistoryBuffer;                                     // 0x0080(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xB8];                                      // 0x0090(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Console">();
	}
	static class UConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsole>();
	}
};
static_assert(alignof(UConsole) == 0x000008, "Wrong alignment on UConsole");
static_assert(sizeof(UConsole) == 0x000148, "Wrong size on UConsole");
static_assert(offsetof(UConsole, ConsoleTargetPlayer) == 0x000050, "Member 'UConsole::ConsoleTargetPlayer' has a wrong offset!");
static_assert(offsetof(UConsole, DefaultTexture_Black) == 0x000058, "Member 'UConsole::DefaultTexture_Black' has a wrong offset!");
static_assert(offsetof(UConsole, DefaultTexture_White) == 0x000060, "Member 'UConsole::DefaultTexture_White' has a wrong offset!");
static_assert(offsetof(UConsole, HistoryBuffer) == 0x000080, "Member 'UConsole::HistoryBuffer' has a wrong offset!");

// Class Engine.Info
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AInfo : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Info">();
	}
	static class AInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInfo>();
	}
};
#pragma pack(pop)
static_assert(alignof(AInfo) == 0x1EF72E00, "Wrong alignment on AInfo");
static_assert(sizeof(AInfo) == 0x1EF72E00, "Wrong size on AInfo");

// Class Engine.GameStateBase
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AGameStateBase : public AInfo
{
public:
	TSubclassOf<class AGameModeBase>              GameModeClass;                                     // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameModeBase*                          AuthorityGameMode;                                 // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatorPawn>             SpectatorClass;                                    // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APlayerState*>                   PlayerArray;                                       // 0x03F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bReplicatedHasBegunPlay;                           // 0x0408(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedWorldTimeSeconds;                        // 0x040C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerWorldTimeSecondsDelta;                       // 0x0410(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerWorldTimeSecondsUpdateFrequency;             // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SQEX_ObjTypeTimeDilation[0x10];                    // 0x0420(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        SQEX_ObjTypeStopFlag;                              // 0x0460(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        SQEX_ObjTypeVisibleFlag;                           // 0x0464(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        SQEX_ObjTypeCollisionDisableFlag;                  // 0x0468(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0xD84];                                    // 0x046C(0x0D84)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_GameModeClass();
	void OnRep_ReplicatedHasBegunPlay();
	void OnRep_ReplicatedWorldTimeSeconds();
	void OnRep_SpectatorClass();
	void SqEX_OnRep_ObjTypeCollisionDisableFlag(uint32 OldValue);
	void SqEX_OnRep_ObjTypeStopFlag(uint32 OldValue);
	void SqEX_OnRep_ObjTypeTimeDilation();
	void SqEX_OnRep_ObjTypeVisibleFlag(uint32 OldValue);

	float GetPlayerRespawnDelay(class AController* Controller) const;
	float GetPlayerStartTime(class AController* Controller) const;
	float GetServerWorldTimeSeconds() const;
	bool HasBegunPlay() const;
	bool HasMatchStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateBase">();
	}
	static class AGameStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGameStateBase) == 0x1EF72E00, "Wrong alignment on AGameStateBase");
static_assert(sizeof(AGameStateBase) == 0x1EF72E00, "Wrong size on AGameStateBase");
static_assert(offsetof(AGameStateBase, GameModeClass) == 0x0003E0, "Member 'AGameStateBase::GameModeClass' has a wrong offset!");
static_assert(offsetof(AGameStateBase, AuthorityGameMode) == 0x0003E8, "Member 'AGameStateBase::AuthorityGameMode' has a wrong offset!");
static_assert(offsetof(AGameStateBase, SpectatorClass) == 0x0003F0, "Member 'AGameStateBase::SpectatorClass' has a wrong offset!");
static_assert(offsetof(AGameStateBase, PlayerArray) == 0x0003F8, "Member 'AGameStateBase::PlayerArray' has a wrong offset!");
static_assert(offsetof(AGameStateBase, bReplicatedHasBegunPlay) == 0x000408, "Member 'AGameStateBase::bReplicatedHasBegunPlay' has a wrong offset!");
static_assert(offsetof(AGameStateBase, ReplicatedWorldTimeSeconds) == 0x00040C, "Member 'AGameStateBase::ReplicatedWorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(AGameStateBase, ServerWorldTimeSecondsDelta) == 0x000410, "Member 'AGameStateBase::ServerWorldTimeSecondsDelta' has a wrong offset!");
static_assert(offsetof(AGameStateBase, ServerWorldTimeSecondsUpdateFrequency) == 0x000414, "Member 'AGameStateBase::ServerWorldTimeSecondsUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AGameStateBase, SQEX_ObjTypeTimeDilation) == 0x000420, "Member 'AGameStateBase::SQEX_ObjTypeTimeDilation' has a wrong offset!");
static_assert(offsetof(AGameStateBase, SQEX_ObjTypeStopFlag) == 0x000460, "Member 'AGameStateBase::SQEX_ObjTypeStopFlag' has a wrong offset!");
static_assert(offsetof(AGameStateBase, SQEX_ObjTypeVisibleFlag) == 0x000464, "Member 'AGameStateBase::SQEX_ObjTypeVisibleFlag' has a wrong offset!");
static_assert(offsetof(AGameStateBase, SQEX_ObjTypeCollisionDisableFlag) == 0x000468, "Member 'AGameStateBase::SQEX_ObjTypeCollisionDisableFlag' has a wrong offset!");

// Class Engine.MaterialExpressionArcsine
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArcsine final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArcsine">();
	}
	static class UMaterialExpressionArcsine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArcsine>();
	}
};
static_assert(alignof(UMaterialExpressionArcsine) == 0x112F2730, "Wrong alignment on UMaterialExpressionArcsine");
static_assert(sizeof(UMaterialExpressionArcsine) == 0x112F2730, "Wrong size on UMaterialExpressionArcsine");
static_assert(offsetof(UMaterialExpressionArcsine, Input) == 0x000078, "Member 'UMaterialExpressionArcsine::Input' has a wrong offset!");

// Class Engine.PrimitiveComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UPrimitiveComponent : public USceneComponent
{
public:
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDrawDistance;                                   // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LDMaxDrawDistance;                                 // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SQEX_IsForceLODDisable;                            // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SQEX_IsForceDitherdLODTransitionDisable;           // 0x0429(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x2];                                      // 0x042A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedMaxDrawDistance;                             // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneDepthPriorityGroup                      DepthPriorityGroup;                                // 0x0430(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneDepthPriorityGroup                      ViewOwnerDepthPriorityGroup;                       // 0x0431(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_432[0x2];                                      // 0x0432(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_434_0 : 3;                                  // 0x0434(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bAlwaysCreatePhysicsState : 1;                     // 0x0434(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateOverlapEvents : 1;                        // 0x0434(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMultiBodyOverlap : 1;                             // 0x0434(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckAsyncSceneOnMove : 1;                        // 0x0434(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTraceComplexOnMove : 1;                           // 0x0434(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReturnMaterialOnMove : 1;                         // 0x0435(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseViewOwnerDepthPriorityGroup : 1;               // 0x0435(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowCullDistanceVolume : 1;                      // 0x0435(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasMotionBlurVelocityMeshes : 1;                  // 0x0435(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisibleInReflectionCaptures : 1;                  // 0x0435(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderInMainPass : 1;                             // 0x0435(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderInMono : 1;                                 // 0x0435(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReceivesDecals : 1;                               // 0x0435(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOwnerNoSee : 1;                                   // 0x0436(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyOwnerSee : 1;                                 // 0x0436(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTreatAsBackgroundForOcclusion : 1;                // 0x0436(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseAsOccluder : 1;                                // 0x0436(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSelectable : 1;                                   // 0x0436(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceMipStreaming : 1;                            // 0x0436(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasPerInstanceHitProxies : 1;                     // 0x0436(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CastShadow : 1;                                    // 0x0436(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDynamicIndirectLighting : 1;                // 0x0437(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDistanceFieldLighting : 1;                  // 0x0437(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastDynamicShadow : 1;                            // 0x0437(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastStaticShadow : 1;                             // 0x0437(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXTranslucentGhostDraw : 1;                     // 0x0437(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastVolumetricTranslucentShadow : 1;              // 0x0437(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSelfShadowOnly : 1;                               // 0x0437(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastFarShadow : 1;                                // 0x0437(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastInsetShadow : 1;                              // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastCinematicShadow : 1;                          // 0x0438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastHiddenShadow : 1;                             // 0x0438(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadowAsTwoSided : 1;                         // 0x0438(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLightAsIfStatic : 1;                              // 0x0438(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLightAttachmentsAsGroup : 1;                      // 0x0438(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexEnableLightAttachmentsChiledAsGroup : 1;      // 0x0438(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EIndirectLightingCacheQuality                 IndirectLightingCacheQuality;                      // 0x043C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSqexDisablePointSnap : 1;                         // 0x0440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReceiveCombinedCSMAndStaticShadowsFromStationaryLights : 1; // 0x0440(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSingleSampleShadowFromStationaryLights : 1;       // 0x0440(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightingChannels                      LightingChannels;                                  // 0x0444(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	ESQEX_OverwriteDiscrenment                    SQEXOverwriteDiscrenment;                          // 0x0447(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_ShadowQuality                           SQEXShadowQuality;                                 // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_ShadowResolution                        SQEXShadowResolution;                              // 0x0449(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSQEXEnableAura : 1;                               // 0x044C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXEnableAura2 : 1;                              // 0x044C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXEnableGlare : 1;                              // 0x044C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXForceDisableAura : 1;                         // 0x044C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXForceDisableGlare : 1;                        // 0x044C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXVolumeUpscale : 1;                            // 0x044C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreRadialImpulse : 1;                          // 0x044C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreRadialForce : 1;                            // 0x044C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyImpulseOnDamage : 1;                         // 0x044D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AlwaysLoadOnClient : 1;                            // 0x044D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AlwaysLoadOnServer : 1;                            // 0x044D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEditorCompositing : 1;                         // 0x044D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderCustomDepth : 1;                            // 0x044D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_44E[0x2];                                      // 0x044E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomDepthStencilValue;                           // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERendererStencilMask                          CustomDepthStencilWriteMask;                       // 0x0454(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSqexRenderForceDynamicPass : 1;                   // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexCaptureOnlyVisible : 1;                       // 0x0458(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexDisableCapture : 1;                           // 0x0458(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_OBJECT_TYPE_TRANSLUCENCYSORTPRIORITY    SQEXTranslucencySortPriority;                      // 0x045C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45D[0x3];                                      // 0x045D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslucencySortPriority;                          // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibilityId;                                      // 0x0464(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x4];                                      // 0x0468(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LpvBiasMultiplier;                                 // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBodyInstance                          BodyInstance;                                      // 0x0470(0x11389E60)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHasCustomNavigableGeometry                   bHasCustomNavigableGeometry;                       // 0x06A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A9[0x3];                                      // 0x06A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoundsScale;                                       // 0x06AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSubmitTime;                                    // 0x06B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRenderTime;                                    // 0x06B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRenderTimeOnScreen;                            // 0x06B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECanBeCharacterBase                           CanBeCharacterBase;                                // 0x06BC(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6BD[0x1];                                      // 0x06BD(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ECanBeCharacterBase                           CanCharacterStepUpOn;                              // 0x06BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BF[0x1];                                      // 0x06BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         MoveIgnoreActors;                                  // 0x06C0(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            MoveIgnoreComponents;                              // 0x06D0(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnComponentHit;                                    // 0x06F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnComponentBeginOverlap;                           // 0x0700(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnComponentEndOverlap;                             // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnComponentWake;                                   // 0x0720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnComponentSleep;                                  // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_740[0x10];                                     // 0x0740(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnBeginCursorOver;                                 // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndCursorOver;                                   // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClicked;                                         // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReleased;                                        // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchBegin;                                 // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchEnd;                                   // 0x07A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchEnter;                                 // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInputTouchLeave;                                 // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x18];                                     // 0x07D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    LODParentPrimitive;                                // 0x07E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrimitiveComponentPostPhysicsTickFunction PostPhysicsComponentTick;                          // 0x07F0(0x0060)(NativeAccessSpecifierPublic)
	ESQEX_AI_ThinkType                            M_FriendAIThinkType;                               // 0x0850(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESQEX_OverlappedForceType                     M_OverlappedForceType;                             // 0x0851(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_852[0x2];                                      // 0x0852(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         M_bDisableImpartVelocity : 1;                      // 0x0854(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bIgnoreActorComponentsBounds : 1;                // 0x0854(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bEnableDangle : 1;                            // 0x0854(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableWallRun : 1;                           // 0x0854(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableWallKick : 1;                          // 0x0854(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableAutoRun : 1;                           // 0x0854(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableSlopeSlide : 1;                        // 0x0854(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableDiveFall : 1;                          // 0x0854(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableForceSlopeSlide : 1;                   // 0x0855(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bEnableOverlapShutOutEye : 1;                 // 0x0855(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bDisableBaseAdjustWhenAwake : 1;              // 0x0855(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         SQEX_bDisableIKOnBase : 1;                         // 0x0855(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_856[0x12];                                     // 0x0856(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAngularImpulse(const struct FVector& Impulse, class FName BoneName, bool bVelChange);
	void AddForce(const struct FVector& Force, class FName BoneName, bool bAccelChange);
	void AddForceAtLocation(const struct FVector& Force, const struct FVector& Location, class FName BoneName);
	void AddForceAtLocationLocal(const struct FVector& Force, const struct FVector& Location, class FName BoneName);
	void AddImpulse(const struct FVector& Impulse, class FName BoneName, bool bVelChange);
	void AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, class FName BoneName);
	void AddRadialForce(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bAccelChange);
	void AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bVelChange);
	void AddTorque(const struct FVector& Torque, class FName BoneName, bool bAccelChange);
	void ClearMoveIgnoreActors();
	void ClearMoveIgnoreComponents();
	TArray<class AActor*> CopyArrayOfMoveIgnoreActors();
	TArray<class UPrimitiveComponent*> CopyArrayOfMoveIgnoreComponents();
	class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamic(int32 ElementIndex);
	class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent);
	class UMaterialInstanceDynamic* CreateDynamicMaterialInstance(int32 ElementIndex, class UMaterialInterface* SourceMaterial);
	struct FVector GetPhysicsAngularVelocity(class FName BoneName);
	struct FVector GetPhysicsLinearVelocity(class FName BoneName);
	struct FVector GetPhysicsLinearVelocityAtPoint(const struct FVector& Point, class FName BoneName);
	void IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore);
	void IgnoreComponentWhenMoving(class UPrimitiveComponent* Component, bool bShouldIgnore);
	bool IsAnyRigidBodyAwake();
	bool K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit);
	void PutRigidBodyToSleep(class FName BoneName);
	void SetAllMassScale(float InMassScale);
	void SetAllPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent);
	void SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent);
	void SetAngularDamping(float InDamping);
	void SetBoundsScale(float NewBoundsScale);
	void SetCastShadow(bool NewCastShadow);
	void SetCenterOfMass(const struct FVector& CenterOfMassOffset, class FName BoneName);
	void SetCollisionEnabled(ECollisionEnabled NewType);
	void SetCollisionObjectType(ECollisionChannel Channel);
	void SetCollisionProfileName(class FName InCollisionProfileName);
	void SetCollisionResponseToAllChannels(ECollisionResponse NewResponse);
	void SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse);
	void SetConstraintMode(EDOFMode ConstraintMode);
	void SetCullDistance(float NewCullDistance);
	void SetCustomDepthStencilValue(int32 Value);
	void SetCustomDepthStencilWriteMask(ERendererStencilMask WriteMaskBit);
	void SetEnableGravity(bool bGravityEnabled);
	void SetLinearDamping(float InDamping);
	void SetLockedAxis(EDOFMode LockedAxis);
	void SetMassOverrideInKg(class FName BoneName, float MassInKg, bool bOverrideMass);
	void SetMassScale(class FName BoneName, float InMassScale);
	void SetMaterial(int32 ElementIndex, class UMaterialInterface* Material);
	void SetMaterialByName(class FName MaterialSlotName, class UMaterialInterface* Material);
	void SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision);
	void SetOnlyOwnerSee(bool bNewOnlyOwnerSee);
	void SetOwnerNoSee(bool bNewOwnerNoSee);
	void SetPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent, class FName BoneName);
	void SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, class FName BoneName);
	void SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, class FName BoneName);
	void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
	void SetReceivesDecals(bool bNewReceivesDecals);
	void SetRenderCustomDepth(bool bValue);
	void SetRenderInMainPass(bool bValue);
	void SetRenderInMono(bool bValue);
	void SetSimulatePhysics(bool bSimulate);
	void SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights);
	void SetSqexCaptureOnlyVisible(bool bValue);
	void SetSqexDisableCapture(bool bValue);
	void SetSqexRenderForceDynamicPass(bool bValue);
	void SetSQEXTranslucentSortPriority(ESQEX_OBJECT_TYPE_TRANSLUCENCYSORTPRIORITY NewSQEXTranslucentSortPriority);
	void SetTranslucentSortPriority(int32 NewTranslucentSortPriority);
	void SetWalkableSlopeOverride(const struct FWalkableSlopeOverride& NewOverride);
	bool SQEX_SetReceivesDecals(bool InReceivesDecals);
	void SqEX_SetWalkableSlopeOverride(const class FName InName, const struct FWalkableSlopeOverride& NewOverride);
	void WakeAllRigidBodies();
	void WakeRigidBody(class FName BoneName);

	bool CanCharacterStepUp(class APawn* Pawn) const;
	float GetAngularDamping() const;
	struct FVector GetCenterOfMass(class FName BoneName) const;
	float GetClosestPointOnCollision(const struct FVector& Point, struct FVector* OutPointOnBody, class FName BoneName) const;
	ECollisionEnabled GetCollisionEnabled() const;
	ECollisionChannel GetCollisionObjectType() const;
	class FName GetCollisionProfileName() const;
	ECollisionResponse GetCollisionResponseToChannel(ECollisionChannel Channel) const;
	struct FVector GetInertiaTensor(class FName BoneName) const;
	float GetLinearDamping() const;
	float GetMass() const;
	float GetMassScale(class FName BoneName) const;
	class UMaterialInterface* GetMaterial(int32 ElementIndex) const;
	class UMaterialInterface* GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex) const;
	int32 GetNumMaterials() const;
	void GetOverlappingActors(TArray<class AActor*>* OverlappingActors, TSubclassOf<class AActor> ClassFilter) const;
	void GetOverlappingComponents(TArray<class UPrimitiveComponent*>* InOverlappingComponents) const;
	const struct FWalkableSlopeOverride GetWalkableSlopeOverride() const;
	bool IsGravityEnabled() const;
	bool IsOverlappingActor(const class AActor* Other) const;
	bool IsOverlappingComponent(const class UPrimitiveComponent* OtherComp) const;
	bool K2_IsCollisionEnabled() const;
	bool K2_IsPhysicsCollisionEnabled() const;
	bool K2_IsQueryCollisionEnabled() const;
	struct FVector ScaleByMomentOfInertia(const struct FVector& InputVector, class FName BoneName) const;
	const struct FWalkableSlopeOverride SqEX_GetWalkableSlopeOverride(const class FName InName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimitiveComponent">();
	}
	static class UPrimitiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrimitiveComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPrimitiveComponent) == 0x112E9AF0, "Wrong alignment on UPrimitiveComponent");
static_assert(sizeof(UPrimitiveComponent) == 0x112E9AF0, "Wrong size on UPrimitiveComponent");
static_assert(offsetof(UPrimitiveComponent, MinDrawDistance) == 0x000420, "Member 'UPrimitiveComponent::MinDrawDistance' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LDMaxDrawDistance) == 0x000424, "Member 'UPrimitiveComponent::LDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, SQEX_IsForceLODDisable) == 0x000428, "Member 'UPrimitiveComponent::SQEX_IsForceLODDisable' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, SQEX_IsForceDitherdLODTransitionDisable) == 0x000429, "Member 'UPrimitiveComponent::SQEX_IsForceDitherdLODTransitionDisable' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, CachedMaxDrawDistance) == 0x00042C, "Member 'UPrimitiveComponent::CachedMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, DepthPriorityGroup) == 0x000430, "Member 'UPrimitiveComponent::DepthPriorityGroup' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, ViewOwnerDepthPriorityGroup) == 0x000431, "Member 'UPrimitiveComponent::ViewOwnerDepthPriorityGroup' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, IndirectLightingCacheQuality) == 0x00043C, "Member 'UPrimitiveComponent::IndirectLightingCacheQuality' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LightingChannels) == 0x000444, "Member 'UPrimitiveComponent::LightingChannels' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, SQEXOverwriteDiscrenment) == 0x000447, "Member 'UPrimitiveComponent::SQEXOverwriteDiscrenment' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, SQEXShadowQuality) == 0x000448, "Member 'UPrimitiveComponent::SQEXShadowQuality' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, SQEXShadowResolution) == 0x000449, "Member 'UPrimitiveComponent::SQEXShadowResolution' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, CustomDepthStencilValue) == 0x000450, "Member 'UPrimitiveComponent::CustomDepthStencilValue' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, CustomDepthStencilWriteMask) == 0x000454, "Member 'UPrimitiveComponent::CustomDepthStencilWriteMask' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, SQEXTranslucencySortPriority) == 0x00045C, "Member 'UPrimitiveComponent::SQEXTranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, TranslucencySortPriority) == 0x000460, "Member 'UPrimitiveComponent::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, VisibilityId) == 0x000464, "Member 'UPrimitiveComponent::VisibilityId' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LpvBiasMultiplier) == 0x00046C, "Member 'UPrimitiveComponent::LpvBiasMultiplier' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, BodyInstance) == 0x000470, "Member 'UPrimitiveComponent::BodyInstance' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, bHasCustomNavigableGeometry) == 0x0006A8, "Member 'UPrimitiveComponent::bHasCustomNavigableGeometry' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, BoundsScale) == 0x0006AC, "Member 'UPrimitiveComponent::BoundsScale' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LastSubmitTime) == 0x0006B0, "Member 'UPrimitiveComponent::LastSubmitTime' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LastRenderTime) == 0x0006B4, "Member 'UPrimitiveComponent::LastRenderTime' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LastRenderTimeOnScreen) == 0x0006B8, "Member 'UPrimitiveComponent::LastRenderTimeOnScreen' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, CanBeCharacterBase) == 0x0006BC, "Member 'UPrimitiveComponent::CanBeCharacterBase' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, CanCharacterStepUpOn) == 0x0006BE, "Member 'UPrimitiveComponent::CanCharacterStepUpOn' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, MoveIgnoreActors) == 0x0006C0, "Member 'UPrimitiveComponent::MoveIgnoreActors' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, MoveIgnoreComponents) == 0x0006D0, "Member 'UPrimitiveComponent::MoveIgnoreComponents' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnComponentHit) == 0x0006F0, "Member 'UPrimitiveComponent::OnComponentHit' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnComponentBeginOverlap) == 0x000700, "Member 'UPrimitiveComponent::OnComponentBeginOverlap' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnComponentEndOverlap) == 0x000710, "Member 'UPrimitiveComponent::OnComponentEndOverlap' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnComponentWake) == 0x000720, "Member 'UPrimitiveComponent::OnComponentWake' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnComponentSleep) == 0x000730, "Member 'UPrimitiveComponent::OnComponentSleep' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnBeginCursorOver) == 0x000750, "Member 'UPrimitiveComponent::OnBeginCursorOver' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnEndCursorOver) == 0x000760, "Member 'UPrimitiveComponent::OnEndCursorOver' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnClicked) == 0x000770, "Member 'UPrimitiveComponent::OnClicked' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnReleased) == 0x000780, "Member 'UPrimitiveComponent::OnReleased' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnInputTouchBegin) == 0x000790, "Member 'UPrimitiveComponent::OnInputTouchBegin' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnInputTouchEnd) == 0x0007A0, "Member 'UPrimitiveComponent::OnInputTouchEnd' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnInputTouchEnter) == 0x0007B0, "Member 'UPrimitiveComponent::OnInputTouchEnter' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, OnInputTouchLeave) == 0x0007C0, "Member 'UPrimitiveComponent::OnInputTouchLeave' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, LODParentPrimitive) == 0x0007E8, "Member 'UPrimitiveComponent::LODParentPrimitive' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, PostPhysicsComponentTick) == 0x0007F0, "Member 'UPrimitiveComponent::PostPhysicsComponentTick' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, M_FriendAIThinkType) == 0x000850, "Member 'UPrimitiveComponent::M_FriendAIThinkType' has a wrong offset!");
static_assert(offsetof(UPrimitiveComponent, M_OverlappedForceType) == 0x000851, "Member 'UPrimitiveComponent::M_OverlappedForceType' has a wrong offset!");

// Class Engine.MeshComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UMeshComponent : public UPrimitiveComponent
{
public:
	TArray<class UMaterialInterface*>             OverrideMaterials;                                 // 0x0868(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             M_OverrideMaterials;                               // 0x0878(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_888[0xF8];                                     // 0x0888(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetScalarParameterValueOnMaterials(const class FName ParameterName, const float ParameterValue);
	void SetVectorParameterValueOnMaterials(const class FName ParameterName, const struct FVector& ParameterValue);

	int32 GetMaterialIndex(class FName MaterialSlotName) const;
	TArray<class UMaterialInterface*> GetMaterials() const;
	TArray<class FName> GetMaterialSlotNames() const;
	bool IsMaterialSlotNameValid(class FName MaterialSlotName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshComponent">();
	}
	static class UMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMeshComponent) == 0x112E9AF0, "Wrong alignment on UMeshComponent");
static_assert(sizeof(UMeshComponent) == 0x112E9AF0, "Wrong size on UMeshComponent");
static_assert(offsetof(UMeshComponent, OverrideMaterials) == 0x000868, "Member 'UMeshComponent::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(UMeshComponent, M_OverrideMaterials) == 0x000878, "Member 'UMeshComponent::M_OverrideMaterials' has a wrong offset!");

// Class Engine.SkinnedMeshComponent
// 0x1BA0 (0x112EB690 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112EB690) USkinnedMeshComponent : public UMeshComponent
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0980(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkinnedMeshComponent>   MasterPoseComponent;                               // 0x0988(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_990[0x60];                                     // 0x0990(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseBoundsFromMasterPoseComponent : 1;             // 0x09F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9F1[0x37];                                     // 0x09F1(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          PhysicsAssetOverride;                              // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLodModel;                                    // 0x0A30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLodModel;                                       // 0x0A34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A38[0x10];                                     // 0x0A38(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkelMeshComponentLODInfo>      LODInfo;                                           // 0x0A48(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         StreamingDistanceMultiplier;                       // 0x0A58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 WireframeColor;                                    // 0x0A5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bForceWireframe : 1;                               // 0x0A60(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayBones : 1;                                 // 0x0A60(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMorphTarget : 1;                           // 0x0A60(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideSkin : 1;                                     // 0x0A60(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A60_4 : 4;                                  // 0x0A60(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_A61[0x17];                                     // 0x0A61(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bPerBoneMotionBlur : 1;                            // 0x0A78(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bComponentUseFixedSkelBounds : 1;                  // 0x0A78(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConsiderAllBodiesForBounds : 1;                   // 0x0A78(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexCastCapsuleIndirectShadowSelf : 1;            // 0x0A78(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexEnableCameraFadeWithOneSidePoly : 1;          // 0x0A78(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A79[0x3];                                      // 0x0A79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMeshComponentUpdateFlag                      MeshComponentUpdateFlag;                           // 0x0A7C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A7D[0x3];                                      // 0x0A7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceMeshObjectUpdate : 1;                        // 0x0A80(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanHighlightSelectedSections : 1;                 // 0x0A80(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecentlyRendered : 1;                             // 0x0A80(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A81[0x3];                                      // 0x0A81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         CustomSortAlternateIndexMode;                      // 0x0A84(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A85[0x3];                                      // 0x0A85(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCastCapsuleDirectShadow : 1;                      // 0x0A88(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastCapsuleIndirectShadow : 1;                    // 0x0A88(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A89[0x3];                                      // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleIndirectShadowMinVisibility;                // 0x0A8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCPUSkinning : 1;                                  // 0x0A90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bDisableAutoPhysShadowAssetDetect : 1;        // 0x0A90(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A91[0x13];                                     // 0x0A91(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxSphereBounds                       CachedLocalBounds;                                 // 0x0AA4(0x112EB690)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCachedLocalBoundsUpToDate;                        // 0x0AC0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableUpdateRateOptimizations;                    // 0x0AC1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayDebugUpdateRateOptimizations;              // 0x0AC2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC3[0x65];                                     // 0x0AC3(0x0065)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSkinWeightOverride(int32 LODIndex);
	void ClearVertexColorOverride(int32 LODIndex);
	void HideBoneByName(class FName BoneName, EPhysBodyOp PhysBodyOption);
	bool IsBoneHiddenByName(class FName BoneName);
	void SetCapsuleIndirectShadowMinVisibility(float NewValue);
	void SetCastCapsuleDirectShadow(bool bNewValue);
	void SetCastCapsuleIndirectShadow(bool bNewValue);
	void SetForcedLOD(int32 InNewForcedLOD);
	void SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent);
	void SetMinLOD(int32 InNewMinLOD);
	void SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit);
	void SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose);
	void SetSkinWeightOverride(int32 LODIndex, const TArray<struct FSkelMeshSkinWeightInfo>& SkinWeights);
	void SetVertexColorOverride_LinearColor(int32 LODIndex, const TArray<struct FLinearColor>& VertexColors);
	void SQEX_SetAnimVisibleDistanceFactorThesholds(const TArray<float>& ThesholdsArray);
	void TransformFromBoneSpace(class FName BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation);
	void UnHideBoneByName(class FName BoneName);

	bool BoneIsChildOf(class FName BoneName, class FName ParentBoneName) const;
	class FName FindClosestBone_K2(const struct FVector& TestLocation, struct FVector* BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset) const;
	int32 GetBoneIndex(class FName BoneName) const;
	class FName GetBoneName(int32 BoneIndex) const;
	int32 GetNumBones() const;
	class FName GetParentBone(class FName BoneName) const;
	class FName GetSocketBoneName(class FName InSocketName) const;
	void TransformToBoneSpace(class FName BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinnedMeshComponent">();
	}
	static class USkinnedMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinnedMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USkinnedMeshComponent) == 0x112EB690, "Wrong alignment on USkinnedMeshComponent");
static_assert(sizeof(USkinnedMeshComponent) == 0x112EB690, "Wrong size on USkinnedMeshComponent");
static_assert(offsetof(USkinnedMeshComponent, SkeletalMesh) == 0x000980, "Member 'USkinnedMeshComponent::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, MasterPoseComponent) == 0x000988, "Member 'USkinnedMeshComponent::MasterPoseComponent' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, PhysicsAssetOverride) == 0x000A28, "Member 'USkinnedMeshComponent::PhysicsAssetOverride' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, ForcedLodModel) == 0x000A30, "Member 'USkinnedMeshComponent::ForcedLodModel' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, MinLodModel) == 0x000A34, "Member 'USkinnedMeshComponent::MinLodModel' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, LODInfo) == 0x000A48, "Member 'USkinnedMeshComponent::LODInfo' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, StreamingDistanceMultiplier) == 0x000A58, "Member 'USkinnedMeshComponent::StreamingDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, WireframeColor) == 0x000A5C, "Member 'USkinnedMeshComponent::WireframeColor' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, MeshComponentUpdateFlag) == 0x000A7C, "Member 'USkinnedMeshComponent::MeshComponentUpdateFlag' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, CustomSortAlternateIndexMode) == 0x000A84, "Member 'USkinnedMeshComponent::CustomSortAlternateIndexMode' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, CapsuleIndirectShadowMinVisibility) == 0x000A8C, "Member 'USkinnedMeshComponent::CapsuleIndirectShadowMinVisibility' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, CachedLocalBounds) == 0x000AA4, "Member 'USkinnedMeshComponent::CachedLocalBounds' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, bCachedLocalBoundsUpToDate) == 0x000AC0, "Member 'USkinnedMeshComponent::bCachedLocalBoundsUpToDate' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, bEnableUpdateRateOptimizations) == 0x000AC1, "Member 'USkinnedMeshComponent::bEnableUpdateRateOptimizations' has a wrong offset!");
static_assert(offsetof(USkinnedMeshComponent, bDisplayDebugUpdateRateOptimizations) == 0x000AC2, "Member 'USkinnedMeshComponent::bDisplayDebugUpdateRateOptimizations' has a wrong offset!");

// Class Engine.MaterialExpressionArcsineFast
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArcsineFast final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArcsineFast">();
	}
	static class UMaterialExpressionArcsineFast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArcsineFast>();
	}
};
static_assert(alignof(UMaterialExpressionArcsineFast) == 0x112F2730, "Wrong alignment on UMaterialExpressionArcsineFast");
static_assert(sizeof(UMaterialExpressionArcsineFast) == 0x112F2730, "Wrong size on UMaterialExpressionArcsineFast");
static_assert(offsetof(UMaterialExpressionArcsineFast, Input) == 0x000078, "Member 'UMaterialExpressionArcsineFast::Input' has a wrong offset!");

// Class Engine.InterpTrackInstAnimControl
// 0x0008 (0x0048 - 0x0040)
class UInterpTrackInstAnimControl final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstAnimControl">();
	}
	static class UInterpTrackInstAnimControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstAnimControl>();
	}
};
static_assert(alignof(UInterpTrackInstAnimControl) == 0x000008, "Wrong alignment on UInterpTrackInstAnimControl");
static_assert(sizeof(UInterpTrackInstAnimControl) == 0x000048, "Wrong size on UInterpTrackInstAnimControl");
static_assert(offsetof(UInterpTrackInstAnimControl, LastUpdatePosition) == 0x000040, "Member 'UInterpTrackInstAnimControl::LastUpdatePosition' has a wrong offset!");

// Class Engine.SkeletalMeshComponent
// 0x379F10 (0x116655A0 - 0x112EB690)
#pragma pack(push, 0x1)
class alignas(0x116655A0) USkeletalMeshComponent : public USkinnedMeshComponent
{
public:
	uint8                                         Pad_B28[0x8];                                      // 0x0B28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimationMode                                AnimationMode;                                     // 0x0B30(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B31[0x7];                                      // 0x0B31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 AnimBlueprintGeneratedClass;                       // 0x0B38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimClass;                                         // 0x0B40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimScriptInstance;                                // 0x0B48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimInstance*>                  SubInstances;                                      // 0x0B50(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UAnimInstance*                          PostProcessAnimInstance;                           // 0x0B60(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSingleAnimationPlayData               AnimationData;                                     // 0x0B68(0x116655A0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     CachedBoneSpaceTransforms;                         // 0x0BB8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     CachedComponentSpaceTransforms;                    // 0x0BC8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD8[0x20];                                     // 0x0BD8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalAnimRateScale;                               // 0x0BF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicActorScene                            UseAsyncScene;                                     // 0x0BFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BFD[0x3];                                      // 0x0BFD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHasValidBodies : 1;                               // 0x0C00(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C01[0x3];                                      // 0x0C01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EKinematicBonesUpdateToPhysics                KinematicBonesUpdateType;                          // 0x0C04(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicsTransformUpdateMode                   PhysicsTransformUpdateMode;                        // 0x0C05(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C06[0x2];                                      // 0x0C06(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBlendPhysics : 1;                                 // 0x0C08(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePhysicsOnDedicatedServer : 1;               // 0x0C08(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateJointsFromAnimation : 1;                    // 0x0C08(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableClothSimulation : 1;                       // 0x0C08(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableAnimCurves : 1;                            // 0x0C08(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCollideWithEnvironment : 1;                       // 0x0C08(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCollideWithAttachedChildren : 1;                  // 0x0C08(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLocalSpaceSimulation : 1;                         // 0x0C08(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClothMorphTarget : 1;                             // 0x0C09(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetAfterTeleport : 1;                           // 0x0C09(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C0A[0x2];                                      // 0x0C0A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClothBlendWeight;                                  // 0x0C0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C10[0x4];                                      // 0x0C10(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RootBoneTranslation;                               // 0x0C14(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDeferMovementFromSceneQueries : 1;                // 0x0C20(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoSkeletonUpdate : 1;                             // 0x0C20(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqExForceSkeletonUpdate : 1;                      // 0x0C20(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_C20_3 : 5;                                  // 0x0C20(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_C21[0x7];                                      // 0x0C21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bPauseAnims : 1;                                   // 0x0C28(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C29[0x3];                                      // 0x0C29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseRefPoseOnInitAnim;                             // 0x0C2C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2D[0x3];                                      // 0x0C2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnablePerPolyCollision : 1;                       // 0x0C30(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bNoSkeletonUpdateWhenOwnerHidden : 1;         // 0x0C30(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C31[0x7];                                      // 0x0C31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0C38(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnlyAllowAutonomousTickPose : 1;                  // 0x0C40(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAutonomousTickPose : 1;                         // 0x0C40(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceRefpose : 1;                                 // 0x0C40(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOldForceRefPose : 1;                              // 0x0C40(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowPrePhysBones : 1;                             // 0x0C40(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequiredBonesUpToDate : 1;                        // 0x0C40(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAnimTreeInitialised : 1;                          // 0x0C40(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeComponentLocationIntoBounds : 1;           // 0x0C40(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableLineCheckWithBounds : 1;                    // 0x0C41(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C42[0x2];                                      // 0x0C42(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        CachedAnimCurveUidVersion;                         // 0x0C44(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C46[0x2];                                      // 0x0C46(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LineCheckBoundsScale;                              // 0x0C48(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C54[0x4];                                      // 0x0C54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnConstraintBroken;                                // 0x0C58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C68[0xF0];                                     // 0x0C68(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UClothingSimulationFactory> ClothingSimulationFactory;                         // 0x0D58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDistanceThreshold;                         // 0x0D60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TeleportRotationThreshold;                         // 0x0D64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D68[0x130];                                    // 0x0D68(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAnimInitialized;                                 // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA8[0xD8];                                     // 0x0EA8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SequenceToPlay;                                    // 0x0F80(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        AnimToPlay;                                        // 0x0F88(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bDefaultLooping : 1;                               // 0x0F90(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDefaultPlaying : 1;                               // 0x0F90(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_F91[0x3];                                      // 0x0F91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultPosition;                                   // 0x0F94(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultPlayRate;                                   // 0x0F98(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        LastPoseTickFrame;                                 // 0x0F9C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastPoseTickTime;                                  // 0x0FA0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bDisableAutoMaterialInstanceDynamics : 1;        // 0x0FA4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bDisableBonePoseToMaterialParam : 1;             // 0x0FA4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FA5[0x3];                                      // 0x0FA5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       M_MaterialInstanceDynamicsCache;                   // 0x0FA8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB8[0x148];                                    // 0x0FB8(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNeedsQueuedAnimEventsDispatched;                  // 0x1100(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1101[0x7];                                     // 0x1101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_KBD_Component*                    M_ExtraDeformationComponent;                       // 0x1108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1110[0x8];                                     // 0x1110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AccumulateAllBodiesBelowPhysicsBlendWeight(const class FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType);
	void AddForceToAllBodiesBelow(const struct FVector& Force, class FName BoneName, bool bAccelChange, bool bIncludeSelf);
	void AddImpulseToAllBodiesBelow(const struct FVector& Impulse, class FName BoneName, bool bVelChange, bool bIncludeSelf);
	void BindClothToMasterPoseComponent();
	void BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, class FName InBoneName);
	void ClearMorphTargets();
	class FName FindConstraintBoneName(int32 ConstraintIndex);
	void ForceClothNextUpdateTeleport();
	void ForceClothNextUpdateTeleportAndReset();
	float GetClothMaxDistanceScale();
	void GetCurrentJointAngles(class FName InBoneName, float* Swing1Angle, float* TwistAngle, float* Swing2Angle);
	bool IsBodyGravityEnabled(class FName BoneName);
	bool IsClothingSimulationSuspended();
	void OverrideAnimationData(class UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate);
	void Play(bool bLooping);
	void PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping);
	void ResetAllBodiesSimulatePhysics();
	void ResetClothTeleportMode();
	void ResumeClothingSimulation();
	void SetAllBodiesBelowPhysicsBlendWeight(const class FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf);
	void SetAllBodiesBelowSimulatePhysics(const class FName& InBoneName, bool bNewSimulate, bool bIncludeSelf);
	void SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType);
	void SetAllBodiesSimulatePhysics(bool bNewSimulate);
	void SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType);
	void SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
	void SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
	void SetAngularLimits(class FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle);
	void SetAnimation(class UAnimationAsset* NewAnimToPlay);
	void SetAnimationMode(EAnimationMode InAnimationMode);
	void SetAnimInstanceClass(class UClass* NewClass);
	void SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, class FName BoneName);
	void SetClothMaxDistanceScale(float Scale);
	void SetConstraintProfile(class FName JointName, class FName ProfileName, bool bDefaultIfNotFound);
	void SetConstraintProfileForAll(class FName ProfileName, bool bDefaultIfNotFound);
	void SetDisableAnimCurves(bool bInDisableAnimCurves);
	void SetEnableBodyGravity(bool bEnableGravity, class FName BoneName);
	void SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, class FName BoneName, bool bIncludeSelf);
	void SetEnablePhysicsBlending(bool bNewBlendPhysics);
	void SetMorphTarget(class FName MorphTargetName, float Value, bool bRemoveZeroWeight);
	void SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, class FName BoneName, bool bIncludeSelf);
	void SetPhysicsBlendWeight(float PhysicsBlendWeight);
	void SetPlayRate(float Rate);
	void SetPosition(float InPos, bool bFireNotifies);
	void SetTeleportDistanceThreshold(float Threshold);
	void SetTeleportRotationThreshold(float Threshold);
	void SetUpdateAnimationInEditor(const bool NewUpdateState);
	void SnapshotPose(struct FPoseSnapshot& Snapshot);
	void SqEX_SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose, bool bRecreateMaterials);
	void SqExSetForceRefPose(bool bNewForceRefPose);
	void Stop();
	void SuspendClothingSimulation();
	void UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace);

	EAnimationMode GetAnimationMode() const;
	class UAnimInstance* GetAnimInstance() const;
	float GetBoneMass(class FName BoneName, bool bScaleMass) const;
	bool GetDisableAnimCurves() const;
	float GetMorphTarget(class FName MorphTargetName) const;
	float GetPlayRate() const;
	float GetPosition() const;
	class UAnimInstance* GetPostProcessInstance() const;
	struct FVector GetSkeletalCenterOfMass() const;
	float GetTeleportDistanceThreshold() const;
	float GetTeleportRotationThreshold() const;
	bool IsPlaying() const;
	bool K2_GetClosestPointOnPhysicsAsset(const struct FVector& WorldPosition, struct FVector* ClosestWorldPosition, struct FVector* Normal, class FName* BoneName, float* Distance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshComponent">();
	}
	static class USkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USkeletalMeshComponent) == 0x116655A0, "Wrong alignment on USkeletalMeshComponent");
static_assert(sizeof(USkeletalMeshComponent) == 0x116655A0, "Wrong size on USkeletalMeshComponent");
static_assert(offsetof(USkeletalMeshComponent, AnimationMode) == 0x000B30, "Member 'USkeletalMeshComponent::AnimationMode' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, AnimBlueprintGeneratedClass) == 0x000B38, "Member 'USkeletalMeshComponent::AnimBlueprintGeneratedClass' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, AnimClass) == 0x000B40, "Member 'USkeletalMeshComponent::AnimClass' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, AnimScriptInstance) == 0x000B48, "Member 'USkeletalMeshComponent::AnimScriptInstance' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, SubInstances) == 0x000B50, "Member 'USkeletalMeshComponent::SubInstances' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, PostProcessAnimInstance) == 0x000B60, "Member 'USkeletalMeshComponent::PostProcessAnimInstance' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, AnimationData) == 0x000B68, "Member 'USkeletalMeshComponent::AnimationData' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, CachedBoneSpaceTransforms) == 0x000BB8, "Member 'USkeletalMeshComponent::CachedBoneSpaceTransforms' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, CachedComponentSpaceTransforms) == 0x000BC8, "Member 'USkeletalMeshComponent::CachedComponentSpaceTransforms' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, GlobalAnimRateScale) == 0x000BF8, "Member 'USkeletalMeshComponent::GlobalAnimRateScale' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, UseAsyncScene) == 0x000BFC, "Member 'USkeletalMeshComponent::UseAsyncScene' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, KinematicBonesUpdateType) == 0x000C04, "Member 'USkeletalMeshComponent::KinematicBonesUpdateType' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, PhysicsTransformUpdateMode) == 0x000C05, "Member 'USkeletalMeshComponent::PhysicsTransformUpdateMode' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, ClothBlendWeight) == 0x000C0C, "Member 'USkeletalMeshComponent::ClothBlendWeight' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, RootBoneTranslation) == 0x000C14, "Member 'USkeletalMeshComponent::RootBoneTranslation' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, bUseRefPoseOnInitAnim) == 0x000C2C, "Member 'USkeletalMeshComponent::bUseRefPoseOnInitAnim' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, BodySetup) == 0x000C38, "Member 'USkeletalMeshComponent::BodySetup' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, CachedAnimCurveUidVersion) == 0x000C44, "Member 'USkeletalMeshComponent::CachedAnimCurveUidVersion' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, LineCheckBoundsScale) == 0x000C48, "Member 'USkeletalMeshComponent::LineCheckBoundsScale' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, OnConstraintBroken) == 0x000C58, "Member 'USkeletalMeshComponent::OnConstraintBroken' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, ClothingSimulationFactory) == 0x000D58, "Member 'USkeletalMeshComponent::ClothingSimulationFactory' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, TeleportDistanceThreshold) == 0x000D60, "Member 'USkeletalMeshComponent::TeleportDistanceThreshold' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, TeleportRotationThreshold) == 0x000D64, "Member 'USkeletalMeshComponent::TeleportRotationThreshold' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, OnAnimInitialized) == 0x000E98, "Member 'USkeletalMeshComponent::OnAnimInitialized' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, SequenceToPlay) == 0x000F80, "Member 'USkeletalMeshComponent::SequenceToPlay' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, AnimToPlay) == 0x000F88, "Member 'USkeletalMeshComponent::AnimToPlay' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, DefaultPosition) == 0x000F94, "Member 'USkeletalMeshComponent::DefaultPosition' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, DefaultPlayRate) == 0x000F98, "Member 'USkeletalMeshComponent::DefaultPlayRate' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, LastPoseTickFrame) == 0x000F9C, "Member 'USkeletalMeshComponent::LastPoseTickFrame' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, LastPoseTickTime) == 0x000FA0, "Member 'USkeletalMeshComponent::LastPoseTickTime' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, M_MaterialInstanceDynamicsCache) == 0x000FA8, "Member 'USkeletalMeshComponent::M_MaterialInstanceDynamicsCache' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, bNeedsQueuedAnimEventsDispatched) == 0x001100, "Member 'USkeletalMeshComponent::bNeedsQueuedAnimEventsDispatched' has a wrong offset!");
static_assert(offsetof(USkeletalMeshComponent, M_ExtraDeformationComponent) == 0x001108, "Member 'USkeletalMeshComponent::M_ExtraDeformationComponent' has a wrong offset!");

// Class Engine.ScriptViewportClient
// 0x0008 (0x0048 - 0x0040)
class UScriptViewportClient : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptViewportClient">();
	}
	static class UScriptViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptViewportClient>();
	}
};
static_assert(alignof(UScriptViewportClient) == 0x000008, "Wrong alignment on UScriptViewportClient");
static_assert(sizeof(UScriptViewportClient) == 0x000048, "Wrong size on UScriptViewportClient");

// Class Engine.GameViewportClient
// 0x0648 (0x0690 - 0x0048)
class UGameViewportClient : public UScriptViewportClient
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConsole*                               ViewportConsole;                                   // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDebugDisplayProperty>          DebugProperties;                                   // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x30];                                      // 0x0068(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameInstance*                          GameInstance;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x5E8];                                     // 0x00A8(0x05E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetConsoleTarget(int32 PlayerIndex);
	void ShowTitleSafeArea();
	void SSSwapControllers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameViewportClient">();
	}
	static class UGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameViewportClient>();
	}
};
static_assert(alignof(UGameViewportClient) == 0x000008, "Wrong alignment on UGameViewportClient");
static_assert(sizeof(UGameViewportClient) == 0x000690, "Wrong size on UGameViewportClient");
static_assert(offsetof(UGameViewportClient, ViewportConsole) == 0x000050, "Member 'UGameViewportClient::ViewportConsole' has a wrong offset!");
static_assert(offsetof(UGameViewportClient, DebugProperties) == 0x000058, "Member 'UGameViewportClient::DebugProperties' has a wrong offset!");
static_assert(offsetof(UGameViewportClient, World) == 0x000098, "Member 'UGameViewportClient::World' has a wrong offset!");
static_assert(offsetof(UGameViewportClient, GameInstance) == 0x0000A0, "Member 'UGameViewportClient::GameInstance' has a wrong offset!");

// Class Engine.EdGraphNode
// 0x112E8CE0 (0x112E8D20 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UEdGraphNode : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEdGraphPin_Deprecated*>         DeprecatedPins;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NodePosX;                                          // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodePosY;                                          // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeWidth;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NodeHeight;                                        // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENodeAdvancedPins                             AdvancedPinDisplay;                                // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENodeEnabledState                             EnabledState;                                      // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x1];                                       // 0x0072(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUserSetEnabledState : 1;                          // 0x0073(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_73_1 : 1;                                   // 0x0073(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsNodeEnabled : 1;                                // 0x0073(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_73_3 : 1;                                   // 0x0073(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bHasCompilerMessage : 1;                           // 0x0073(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCommentBubblePinned : 1;                          // 0x0073(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCommentBubbleVisible : 1;                         // 0x0073(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCommentBubbleMakeVisible : 1;                     // 0x0073(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NodeComment;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorType;                                         // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMsg;                                          // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  NodeGuid;                                          // 0x00A0(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdGraphNode">();
	}
	static class UEdGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdGraphNode>();
	}
};
#pragma pack(pop)
static_assert(alignof(UEdGraphNode) == 0x112E8D20, "Wrong alignment on UEdGraphNode");
static_assert(sizeof(UEdGraphNode) == 0x112E8D20, "Wrong size on UEdGraphNode");
static_assert(offsetof(UEdGraphNode, DeprecatedPins) == 0x000050, "Member 'UEdGraphNode::DeprecatedPins' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, NodePosX) == 0x000060, "Member 'UEdGraphNode::NodePosX' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, NodePosY) == 0x000064, "Member 'UEdGraphNode::NodePosY' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, NodeWidth) == 0x000068, "Member 'UEdGraphNode::NodeWidth' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, NodeHeight) == 0x00006C, "Member 'UEdGraphNode::NodeHeight' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, AdvancedPinDisplay) == 0x000070, "Member 'UEdGraphNode::AdvancedPinDisplay' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, EnabledState) == 0x000071, "Member 'UEdGraphNode::EnabledState' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, NodeComment) == 0x000078, "Member 'UEdGraphNode::NodeComment' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, ErrorType) == 0x000088, "Member 'UEdGraphNode::ErrorType' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, ErrorMsg) == 0x000090, "Member 'UEdGraphNode::ErrorMsg' has a wrong offset!");
static_assert(offsetof(UEdGraphNode, NodeGuid) == 0x0000A0, "Member 'UEdGraphNode::NodeGuid' has a wrong offset!");

// Class Engine.SaveGame
// 0x0000 (0x0040 - 0x0040)
class USaveGame : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGame">();
	}
	static class USaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGame>();
	}
};
static_assert(alignof(USaveGame) == 0x000008, "Wrong alignment on USaveGame");
static_assert(sizeof(USaveGame) == 0x000040, "Wrong size on USaveGame");

// Class Engine.ParticleModuleAttractorBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleAttractorBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAttractorBase">();
	}
	static class UParticleModuleAttractorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAttractorBase>();
	}
};
static_assert(alignof(UParticleModuleAttractorBase) == 0x000008, "Wrong alignment on UParticleModuleAttractorBase");
static_assert(sizeof(UParticleModuleAttractorBase) == 0x000050, "Wrong size on UParticleModuleAttractorBase");

// Class Engine.ParticleModuleAttractorPointGravity
// 0x0050 (0x00A0 - 0x0050)
class UParticleModuleAttractorPointGravity final : public UParticleModuleAttractorBase
{
public:
	struct FVector                                Position;                                          // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDistributionFloat*                     Strength;                                          // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StrengthRaw;                                       // 0x0068(0x0038)(Edit, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAttractorPointGravity">();
	}
	static class UParticleModuleAttractorPointGravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAttractorPointGravity>();
	}
};
static_assert(alignof(UParticleModuleAttractorPointGravity) == 0x000008, "Wrong alignment on UParticleModuleAttractorPointGravity");
static_assert(sizeof(UParticleModuleAttractorPointGravity) == 0x0000A0, "Wrong size on UParticleModuleAttractorPointGravity");
static_assert(offsetof(UParticleModuleAttractorPointGravity, Position) == 0x000050, "Member 'UParticleModuleAttractorPointGravity::Position' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorPointGravity, Radius) == 0x00005C, "Member 'UParticleModuleAttractorPointGravity::Radius' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorPointGravity, Strength) == 0x000060, "Member 'UParticleModuleAttractorPointGravity::Strength' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorPointGravity, StrengthRaw) == 0x000068, "Member 'UParticleModuleAttractorPointGravity::StrengthRaw' has a wrong offset!");

// Class Engine.AnimInstance
// 0x0358 (0x0398 - 0x0040)
class UAnimInstance : public UObject
{
public:
	float                                         DeltaTime;                                         // 0x0040(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              CurrentSkeleton;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionMode                               RootMotionMode;                                    // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunUpdatesInWorkerThreads;                        // 0x0051(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseParallelUpdateAnimation;                    // 0x0052(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMultiThreadedAnimationUpdate;                  // 0x0053(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnAboutBlueprintUsage;                          // 0x0054(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnMontageBlendingOut;                              // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMontageStarted;                                  // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMontageEnded;                                    // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllMontageInstancesEnded;                        // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x60];                                      // 0x0098(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bQueueMontageEvents;                               // 0x00F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x9F];                                      // 0x00F9(0x009F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimNotifyEvent>               ActiveAnimNotifyState;                             // 0x0198(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x1E8];                                    // 0x01A8(0x01E8)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_NotifyTriggerTiming                     SQEX_NotifyTriggerTiming;                          // 0x0390(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintBeginPlay();
	void BlueprintInitializeAnimation();
	void BlueprintPostEvaluateAnimation();
	void BlueprintUpdateAnimation(float DeltaTimeX);
	float CalculateDirection(const struct FVector& Velocity, const struct FRotator& BaseRotation);
	void ClearMorphTargets();
	class FName GetCurrentStateName(int32 MachineIndex);
	float GetCurveValue(class FName CurveName);
	float GetInstanceAssetPlayerLength(int32 AssetPlayerIndex);
	float GetInstanceAssetPlayerTime(int32 AssetPlayerIndex);
	float GetInstanceAssetPlayerTimeFraction(int32 AssetPlayerIndex);
	float GetInstanceAssetPlayerTimeFromEnd(int32 AssetPlayerIndex);
	float GetInstanceAssetPlayerTimeFromEndFraction(int32 AssetPlayerIndex);
	float GetInstanceCurrentStateElapsedTime(int32 MachineIndex);
	float GetInstanceMachineWeight(int32 MachineIndex);
	float GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex);
	float GetInstanceTransitionCrossfadeDuration(int32 MachineIndex, int32 TransitionIndex);
	float GetInstanceTransitionTimeElapsed(int32 MachineIndex, int32 TransitionIndex);
	float GetInstanceTransitionTimeElapsedFraction(int32 MachineIndex, int32 TransitionIndex);
	float GetRelevantAnimLength(int32 MachineIndex, int32 StateIndex);
	float GetRelevantAnimTime(int32 MachineIndex, int32 StateIndex);
	float GetRelevantAnimTimeFraction(int32 MachineIndex, int32 StateIndex);
	float GetRelevantAnimTimeRemaining(int32 MachineIndex, int32 StateIndex);
	float GetRelevantAnimTimeRemainingFraction(int32 MachineIndex, int32 StateIndex);
	void LockAIResources(bool bLockMovement, bool LockAILogic);
	void Montage_JumpToSection(class FName SectionName, const class UAnimMontage* Montage);
	void Montage_JumpToSectionsEnd(class FName SectionName, const class UAnimMontage* Montage);
	void Montage_Pause(const class UAnimationAsset* Montage);
	float Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt);
	void Montage_Resume(const class UAnimationAsset* Montage);
	void Montage_SetNextSection(class FName SectionNameToChange, class FName NextSection, const class UAnimMontage* Montage);
	void Montage_SetPlayRate(const class UAnimMontage* Montage, float NewPlayRate);
	void Montage_SetPosition(const class UAnimationAsset* Montage, float NewPosition);
	void Montage_Stop(float InBlendOutTime, const class UAnimMontage* Montage);
	float PlaySlotAnimation(class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount);
	class UAnimMontage* PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	void SavePoseSnapshot(class FName SnapshotName);
	void SetMorphTarget(class FName MorphTargetName, float Value);
	void SetRootMotionMode(ERootMotionMode Value);
	void SnapshotPose(struct FPoseSnapshot& Snapshot);
	void StopSlotAnimation(float InBlendOutTime, class FName SlotNodeName);
	void UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic);

	class UAnimationAsset* GetCurrentActiveMontage() const;
	class AActor* GetOwningActor() const;
	class USkeletalMeshComponent* GetOwningComponent() const;
	struct FMarkerSyncAnimPosition GetSyncGroupPosition(class FName InSyncGroupName) const;
	bool GetTimeToClosestMarker(class FName SyncGroup, class FName MarkerName, float* OutMarkerTime) const;
	bool HasMarkerBeenHitThisFrame(class FName SyncGroup, class FName MarkerName) const;
	bool IsAnyMontagePlaying() const;
	bool IsPlayingSlotAnimation(const class UAnimSequenceBase* Asset, class FName SlotNodeName) const;
	bool IsSyncGroupBetweenMarkers(class FName InSyncGroupName, class FName PreviousMarker, class FName NextMarker, bool bRespectMarkerOrder) const;
	float Montage_GetBlendTime(const class UAnimationAsset* Montage) const;
	class FName Montage_GetCurrentSection(const class UAnimMontage* Montage) const;
	bool Montage_GetIsStopped(const class UAnimationAsset* Montage) const;
	float Montage_GetPlayRate(const class UAnimationAsset* Montage) const;
	float Montage_GetPosition(const class UAnimationAsset* Montage) const;
	bool Montage_IsActive(const class UAnimationAsset* Montage) const;
	bool Montage_IsPlaying(const class UAnimMontage* Montage) const;
	class APawn* TryGetPawnOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInstance">();
	}
	static class UAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInstance>();
	}
};
static_assert(alignof(UAnimInstance) == 0x000008, "Wrong alignment on UAnimInstance");
static_assert(sizeof(UAnimInstance) == 0x000398, "Wrong size on UAnimInstance");
static_assert(offsetof(UAnimInstance, DeltaTime) == 0x000040, "Member 'UAnimInstance::DeltaTime' has a wrong offset!");
static_assert(offsetof(UAnimInstance, CurrentSkeleton) == 0x000048, "Member 'UAnimInstance::CurrentSkeleton' has a wrong offset!");
static_assert(offsetof(UAnimInstance, RootMotionMode) == 0x000050, "Member 'UAnimInstance::RootMotionMode' has a wrong offset!");
static_assert(offsetof(UAnimInstance, bRunUpdatesInWorkerThreads) == 0x000051, "Member 'UAnimInstance::bRunUpdatesInWorkerThreads' has a wrong offset!");
static_assert(offsetof(UAnimInstance, bCanUseParallelUpdateAnimation) == 0x000052, "Member 'UAnimInstance::bCanUseParallelUpdateAnimation' has a wrong offset!");
static_assert(offsetof(UAnimInstance, bUseMultiThreadedAnimationUpdate) == 0x000053, "Member 'UAnimInstance::bUseMultiThreadedAnimationUpdate' has a wrong offset!");
static_assert(offsetof(UAnimInstance, bWarnAboutBlueprintUsage) == 0x000054, "Member 'UAnimInstance::bWarnAboutBlueprintUsage' has a wrong offset!");
static_assert(offsetof(UAnimInstance, OnMontageBlendingOut) == 0x000058, "Member 'UAnimInstance::OnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UAnimInstance, OnMontageStarted) == 0x000068, "Member 'UAnimInstance::OnMontageStarted' has a wrong offset!");
static_assert(offsetof(UAnimInstance, OnMontageEnded) == 0x000078, "Member 'UAnimInstance::OnMontageEnded' has a wrong offset!");
static_assert(offsetof(UAnimInstance, OnAllMontageInstancesEnded) == 0x000088, "Member 'UAnimInstance::OnAllMontageInstancesEnded' has a wrong offset!");
static_assert(offsetof(UAnimInstance, bQueueMontageEvents) == 0x0000F8, "Member 'UAnimInstance::bQueueMontageEvents' has a wrong offset!");
static_assert(offsetof(UAnimInstance, ActiveAnimNotifyState) == 0x000198, "Member 'UAnimInstance::ActiveAnimNotifyState' has a wrong offset!");
static_assert(offsetof(UAnimInstance, SQEX_NotifyTriggerTiming) == 0x000390, "Member 'UAnimInstance::SQEX_NotifyTriggerTiming' has a wrong offset!");

// Class Engine.AnimMetaData
// 0x0000 (0x0040 - 0x0040)
class UAnimMetaData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimMetaData">();
	}
	static class UAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimMetaData>();
	}
};
static_assert(alignof(UAnimMetaData) == 0x000008, "Wrong alignment on UAnimMetaData");
static_assert(sizeof(UAnimMetaData) == 0x000040, "Wrong size on UAnimMetaData");

// Class Engine.Brush
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ABrush : public AActor
{
public:
	EBrushType                                    BrushType;                                         // 0x03E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 BrushColor;                                        // 0x03E4(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolyFlags;                                         // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bColored : 1;                                      // 0x03EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSolidWhenSelected : 1;                            // 0x03EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlaceableFromClassBrowser : 1;                    // 0x03EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotForClientOrServer : 1;                         // 0x03EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UModel*                                 Brush;                                             // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrushComponent*                        BrushComponent;                                    // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bInManipulation : 1;                               // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGeomSelection>                 SavedSelections;                                   // 0x0408(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Brush">();
	}
	static class ABrush* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrush>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABrush) == 0x1EF72E00, "Wrong alignment on ABrush");
static_assert(sizeof(ABrush) == 0x1EF72E00, "Wrong size on ABrush");
static_assert(offsetof(ABrush, BrushType) == 0x0003E0, "Member 'ABrush::BrushType' has a wrong offset!");
static_assert(offsetof(ABrush, BrushColor) == 0x0003E4, "Member 'ABrush::BrushColor' has a wrong offset!");
static_assert(offsetof(ABrush, PolyFlags) == 0x0003E8, "Member 'ABrush::PolyFlags' has a wrong offset!");
static_assert(offsetof(ABrush, Brush) == 0x0003F0, "Member 'ABrush::Brush' has a wrong offset!");
static_assert(offsetof(ABrush, BrushComponent) == 0x0003F8, "Member 'ABrush::BrushComponent' has a wrong offset!");
static_assert(offsetof(ABrush, SavedSelections) == 0x000408, "Member 'ABrush::SavedSelections' has a wrong offset!");

// Class Engine.Volume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AVolume : public ABrush
{
public:
	bool                                          M_bSqexDispWarningThroughCheck;                    // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Volume">();
	}
	static class AVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVolume>();
	}
};
#pragma pack(pop)
static_assert(alignof(AVolume) == 0x1EF72E00, "Wrong alignment on AVolume");
static_assert(sizeof(AVolume) == 0x1EF72E00, "Wrong size on AVolume");
static_assert(offsetof(AVolume, M_bSqexDispWarningThroughCheck) == 0x000418, "Member 'AVolume::M_bSqexDispWarningThroughCheck' has a wrong offset!");

// Class Engine.PhysicsVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) APhysicsVolume : public AVolume
{
public:
	float                                         TerminalVelocity;                                  // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidFriction;                                     // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWaterVolume : 1;                                  // 0x042C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bOceanVolume : 1;                             // 0x042C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPhysicsOnContact : 1;                             // 0x042C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsVolume">();
	}
	static class APhysicsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsVolume>();
	}
};
#pragma pack(pop)
static_assert(alignof(APhysicsVolume) == 0x1EF72E00, "Wrong alignment on APhysicsVolume");
static_assert(sizeof(APhysicsVolume) == 0x1EF72E00, "Wrong size on APhysicsVolume");
static_assert(offsetof(APhysicsVolume, TerminalVelocity) == 0x000420, "Member 'APhysicsVolume::TerminalVelocity' has a wrong offset!");
static_assert(offsetof(APhysicsVolume, Priority) == 0x000424, "Member 'APhysicsVolume::Priority' has a wrong offset!");
static_assert(offsetof(APhysicsVolume, FluidFriction) == 0x000428, "Member 'APhysicsVolume::FluidFriction' has a wrong offset!");

// Class Engine.PainCausingVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APainCausingVolume : public APhysicsVolume
{
public:
	uint8                                         bPainCausing : 1;                                  // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamagePerSec;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PainInterval;                                      // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEntryPain : 1;                                    // 0x0444(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BACKUP_bPainCausing : 1;                           // 0x0444(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            DamageInstigator;                                  // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PainCausingVolume">();
	}
	static class APainCausingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APainCausingVolume>();
	}
};
static_assert(alignof(APainCausingVolume) == 0x1EF72E00, "Wrong alignment on APainCausingVolume");
static_assert(sizeof(APainCausingVolume) == 0x1EF72E00, "Wrong size on APainCausingVolume");
static_assert(offsetof(APainCausingVolume, DamagePerSec) == 0x000434, "Member 'APainCausingVolume::DamagePerSec' has a wrong offset!");
static_assert(offsetof(APainCausingVolume, DamageType) == 0x000438, "Member 'APainCausingVolume::DamageType' has a wrong offset!");
static_assert(offsetof(APainCausingVolume, PainInterval) == 0x000440, "Member 'APainCausingVolume::PainInterval' has a wrong offset!");
static_assert(offsetof(APainCausingVolume, DamageInstigator) == 0x000448, "Member 'APainCausingVolume::DamageInstigator' has a wrong offset!");

// Class Engine.InterpTrack
// 0x0050 (0x0090 - 0x0040)
class UInterpTrack : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInterpTrack*>                   SubTracks;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UInterpTrackInst>           TrackInstClass;                                    // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrackActiveCondition                         ActiveCondition;                                   // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TrackTitle;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnePerGroup : 1;                                  // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDirGroupOnly : 1;                                 // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableTrack : 1;                                 // 0x0080(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_TemporaryDisable;                                // 0x0084(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsSelected : 1;                                   // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsAnimControlTrack : 1;                           // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSubTrackOnly : 1;                                 // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisible : 1;                                      // 0x0088(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRecording : 1;                                  // 0x0088(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrack">();
	}
	static class UInterpTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrack>();
	}
};
static_assert(alignof(UInterpTrack) == 0x000008, "Wrong alignment on UInterpTrack");
static_assert(sizeof(UInterpTrack) == 0x000090, "Wrong size on UInterpTrack");
static_assert(offsetof(UInterpTrack, SubTracks) == 0x000050, "Member 'UInterpTrack::SubTracks' has a wrong offset!");
static_assert(offsetof(UInterpTrack, TrackInstClass) == 0x000060, "Member 'UInterpTrack::TrackInstClass' has a wrong offset!");
static_assert(offsetof(UInterpTrack, ActiveCondition) == 0x000068, "Member 'UInterpTrack::ActiveCondition' has a wrong offset!");
static_assert(offsetof(UInterpTrack, TrackTitle) == 0x000070, "Member 'UInterpTrack::TrackTitle' has a wrong offset!");
static_assert(offsetof(UInterpTrack, M_TemporaryDisable) == 0x000084, "Member 'UInterpTrack::M_TemporaryDisable' has a wrong offset!");

// Class Engine.InterpTrackFloatBase
// 0x112EC520 (0x112EC5B0 - 0x0090)
#pragma pack(push, 0x1)
class alignas(0x112EC5B0) UInterpTrackFloatBase : public UInterpTrack
{
public:
	struct FInterpCurveFloat                      FloatTrack;                                        // 0x0090(0x112EC5B0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTension;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackFloatBase">();
	}
	static class UInterpTrackFloatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackFloatBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackFloatBase) == 0x112EC5B0, "Wrong alignment on UInterpTrackFloatBase");
static_assert(sizeof(UInterpTrackFloatBase) == 0x112EC5B0, "Wrong size on UInterpTrackFloatBase");
static_assert(offsetof(UInterpTrackFloatBase, FloatTrack) == 0x000090, "Member 'UInterpTrackFloatBase::FloatTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatBase, CurveTension) == 0x0000A8, "Member 'UInterpTrackFloatBase::CurveTension' has a wrong offset!");

// Class Engine.NavigationPathGenerator
// 0x0000 (0x0040 - 0x0040)
class INavigationPathGenerator final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationPathGenerator">();
	}
	static class INavigationPathGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavigationPathGenerator>();
	}
};
static_assert(alignof(INavigationPathGenerator) == 0x000008, "Wrong alignment on INavigationPathGenerator");
static_assert(sizeof(INavigationPathGenerator) == 0x000040, "Wrong size on INavigationPathGenerator");

// Class Engine.ParticleModuleSizeBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleSizeBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSizeBase">();
	}
	static class UParticleModuleSizeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSizeBase>();
	}
};
static_assert(alignof(UParticleModuleSizeBase) == 0x000008, "Wrong alignment on UParticleModuleSizeBase");
static_assert(sizeof(UParticleModuleSizeBase) == 0x000050, "Wrong size on UParticleModuleSizeBase");

// Class Engine.DataAsset
// 0x0008 (0x0048 - 0x0040)
class UDataAsset : public UObject
{
public:
	TSubclassOf<class UDataAsset>                 NativeClass;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataAsset">();
	}
	static class UDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataAsset>();
	}
};
static_assert(alignof(UDataAsset) == 0x000008, "Wrong alignment on UDataAsset");
static_assert(sizeof(UDataAsset) == 0x000048, "Wrong size on UDataAsset");
static_assert(offsetof(UDataAsset, NativeClass) == 0x000040, "Member 'UDataAsset::NativeClass' has a wrong offset!");

// Class Engine.LightComponentBase
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) ULightComponentBase : public USceneComponent
{
public:
	struct FGuid                                  LightGuid;                                         // 0x0418(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x0428(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 LightColor;                                        // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAffectsWorld : 1;                                 // 0x0434(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CastShadows : 1;                                   // 0x0434(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CastStaticShadows : 1;                             // 0x0434(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CastDynamicShadows : 1;                            // 0x0434(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectTranslucentLighting : 1;                    // 0x0434(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastVolumetricShadow : 1;                         // 0x0434(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IndirectLightingIntensity;                         // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricScatteringIntensity;                     // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IntensityExposureControl;                        // 0x0440(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_IntensityExposure;                               // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_IntensityExposureBase;                           // 0x0448(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCastShadows(bool bNewValue);
	void SetCastVolumetricShadow(bool bNewValue);
	void SQEX_SetExposure(float InExposure);
	void SQEX_SetExposureControl(bool InExposureControl);

	struct FLinearColor GetLightColor() const;
	bool SQEX_IsExposureControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightComponentBase">();
	}
	static class ULightComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightComponentBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ULightComponentBase) == 0x112E9AF0, "Wrong alignment on ULightComponentBase");
static_assert(sizeof(ULightComponentBase) == 0x112E9AF0, "Wrong size on ULightComponentBase");
static_assert(offsetof(ULightComponentBase, LightGuid) == 0x000418, "Member 'ULightComponentBase::LightGuid' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, Brightness) == 0x000428, "Member 'ULightComponentBase::Brightness' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, Intensity) == 0x00042C, "Member 'ULightComponentBase::Intensity' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, LightColor) == 0x000430, "Member 'ULightComponentBase::LightColor' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, IndirectLightingIntensity) == 0x000438, "Member 'ULightComponentBase::IndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, VolumetricScatteringIntensity) == 0x00043C, "Member 'ULightComponentBase::VolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, M_IntensityExposureControl) == 0x000440, "Member 'ULightComponentBase::M_IntensityExposureControl' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, M_IntensityExposure) == 0x000444, "Member 'ULightComponentBase::M_IntensityExposure' has a wrong offset!");
static_assert(offsetof(ULightComponentBase, M_IntensityExposureBase) == 0x000448, "Member 'ULightComponentBase::M_IntensityExposureBase' has a wrong offset!");

// Class Engine.LightComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) ULightComponent : public ULightComponentBase
{
public:
	float                                         Temperature;                                       // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDrawDistance;                                   // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFadeRange;                              // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseTemperature : 1;                               // 0x045C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45D[0x3];                                      // 0x045D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShadowMapChannel;                                  // 0x0460(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRoughness;                                      // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowResolutionScale;                             // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowBias;                                        // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowSharpen;                                     // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactShadowLength;                               // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InverseSquaredFalloff : 1;                         // 0x047C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CastTranslucentShadows : 1;                        // 0x047C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadowsFromCinematicObjectsOnly : 1;          // 0x047C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectDynamicIndirectLighting : 1;                // 0x047C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_47D[0x3];                                      // 0x047D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightingChannels                      LightingChannels;                                  // 0x0480(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_483[0x5];                                      // 0x0483(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LightFunctionMaterial;                             // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LightFunctionScale;                                // 0x0490(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureLightProfile*                   IESTexture;                                        // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseIESBrightness : 1;                             // 0x04A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A9[0x3];                                      // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IESBrightnessScale;                                // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightFunctionFadeDistance;                         // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisabledBrightness;                                // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableLightShaftBloom : 1;                        // 0x04B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BloomScale;                                        // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomThreshold;                                    // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BloomTint;                                         // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SqexMaxShadowResolution;                           // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRayTracedDistanceFieldShadows;                 // 0x04CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RayStartOffsetDepthScale;                          // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0x8C];                                     // 0x04D4(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAffectDynamicIndirectLighting(bool bNewValue);
	void SetAffectTranslucentLighting(bool bNewValue);
	void SetBloomScale(float NewValue);
	void SetBloomThreshold(float NewValue);
	void SetBloomTint(const struct FColor& NewValue);
	void SetEnableLightShaftBloom(bool bNewValue);
	void SetIESTexture(class UTextureLightProfile* NewValue);
	void SetIndirectLightingIntensity(float NewIntensity);
	void SetIntensity(float NewIntensity);
	void SetLightColor(const struct FLinearColor& NewLightColor, bool bSRGB);
	void SetLightFunctionDisabledBrightness(float NewValue);
	void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
	void SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial);
	void SetLightFunctionScale(const struct FVector& NewLightFunctionScale);
	void SetShadowBias(float NewValue);
	void SetTemperature(float NewTemperature);
	void SetVolumetricScatteringIntensity(float NewIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightComponent">();
	}
	static class ULightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(ULightComponent) == 0x112E9AF0, "Wrong alignment on ULightComponent");
static_assert(sizeof(ULightComponent) == 0x112E9AF0, "Wrong size on ULightComponent");
static_assert(offsetof(ULightComponent, Temperature) == 0x000450, "Member 'ULightComponent::Temperature' has a wrong offset!");
static_assert(offsetof(ULightComponent, MaxDrawDistance) == 0x000454, "Member 'ULightComponent::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(ULightComponent, MaxDistanceFadeRange) == 0x000458, "Member 'ULightComponent::MaxDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(ULightComponent, ShadowMapChannel) == 0x000460, "Member 'ULightComponent::ShadowMapChannel' has a wrong offset!");
static_assert(offsetof(ULightComponent, MinRoughness) == 0x000468, "Member 'ULightComponent::MinRoughness' has a wrong offset!");
static_assert(offsetof(ULightComponent, ShadowResolutionScale) == 0x00046C, "Member 'ULightComponent::ShadowResolutionScale' has a wrong offset!");
static_assert(offsetof(ULightComponent, ShadowBias) == 0x000470, "Member 'ULightComponent::ShadowBias' has a wrong offset!");
static_assert(offsetof(ULightComponent, ShadowSharpen) == 0x000474, "Member 'ULightComponent::ShadowSharpen' has a wrong offset!");
static_assert(offsetof(ULightComponent, ContactShadowLength) == 0x000478, "Member 'ULightComponent::ContactShadowLength' has a wrong offset!");
static_assert(offsetof(ULightComponent, LightingChannels) == 0x000480, "Member 'ULightComponent::LightingChannels' has a wrong offset!");
static_assert(offsetof(ULightComponent, LightFunctionMaterial) == 0x000488, "Member 'ULightComponent::LightFunctionMaterial' has a wrong offset!");
static_assert(offsetof(ULightComponent, LightFunctionScale) == 0x000490, "Member 'ULightComponent::LightFunctionScale' has a wrong offset!");
static_assert(offsetof(ULightComponent, IESTexture) == 0x0004A0, "Member 'ULightComponent::IESTexture' has a wrong offset!");
static_assert(offsetof(ULightComponent, IESBrightnessScale) == 0x0004AC, "Member 'ULightComponent::IESBrightnessScale' has a wrong offset!");
static_assert(offsetof(ULightComponent, LightFunctionFadeDistance) == 0x0004B0, "Member 'ULightComponent::LightFunctionFadeDistance' has a wrong offset!");
static_assert(offsetof(ULightComponent, DisabledBrightness) == 0x0004B4, "Member 'ULightComponent::DisabledBrightness' has a wrong offset!");
static_assert(offsetof(ULightComponent, BloomScale) == 0x0004BC, "Member 'ULightComponent::BloomScale' has a wrong offset!");
static_assert(offsetof(ULightComponent, BloomThreshold) == 0x0004C0, "Member 'ULightComponent::BloomThreshold' has a wrong offset!");
static_assert(offsetof(ULightComponent, BloomTint) == 0x0004C4, "Member 'ULightComponent::BloomTint' has a wrong offset!");
static_assert(offsetof(ULightComponent, SqexMaxShadowResolution) == 0x0004C8, "Member 'ULightComponent::SqexMaxShadowResolution' has a wrong offset!");
static_assert(offsetof(ULightComponent, bUseRayTracedDistanceFieldShadows) == 0x0004CC, "Member 'ULightComponent::bUseRayTracedDistanceFieldShadows' has a wrong offset!");
static_assert(offsetof(ULightComponent, RayStartOffsetDepthScale) == 0x0004D0, "Member 'ULightComponent::RayStartOffsetDepthScale' has a wrong offset!");

// Class Engine.DirectionalLightComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UDirectionalLightComponent final : public ULightComponent
{
public:
	uint8                                         bEnableLightShaftOcclusion : 1;                    // 0x0560(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OcclusionMaskDarkness;                             // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionDepthRange;                               // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LightShaftOverrideDirection;                       // 0x056C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WholeSceneDynamicShadowRadius;                     // 0x0578(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistanceMovableLight;                 // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicShadowDistanceStationaryLight;              // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_SetDynamicShadowDistanceByMatinee;               // 0x0584(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_585[0x3];                                      // 0x0585(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DynamicShadowCascades;                             // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeDistributionExponent;                       // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CascadeTransitionFraction;                         // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDistanceFadeoutFraction;                     // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseInsetShadowsForMovableObjects : 1;             // 0x0598(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FarShadowCascadeCount;                             // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarShadowDistance;                                 // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldShadowDistance;                       // 0x05A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightSourceAngle;                                  // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightmassDirectionalLightSettings     LightmassSettings;                                 // 0x05B0(0x1292E)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bCastModulatedShadows : 1;                         // 0x05C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ModulatedShadowColor;                              // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsedAsAtmosphereSunLight : 1;                     // 0x05C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCascadeDistributionExponent(float NewValue);
	void SetCascadeTransitionFraction(float NewValue);
	void SetDynamicShadowCascades(int32 NewValue);
	void SetDynamicShadowDistanceMovableLight(float NewValue);
	void SetDynamicShadowDistanceStationaryLight(float NewValue);
	void SetEnableLightShaftOcclusion(bool bNewValue);
	void SetLightShaftOverrideDirection(const struct FVector& NewValue);
	void SetOcclusionMaskDarkness(float NewValue);
	void SetShadowDistanceFadeoutFraction(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalLightComponent">();
	}
	static class UDirectionalLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalLightComponent>();
	}
};
static_assert(alignof(UDirectionalLightComponent) == 0x112E9AF0, "Wrong alignment on UDirectionalLightComponent");
static_assert(sizeof(UDirectionalLightComponent) == 0x112E9AF0, "Wrong size on UDirectionalLightComponent");
static_assert(offsetof(UDirectionalLightComponent, OcclusionMaskDarkness) == 0x000564, "Member 'UDirectionalLightComponent::OcclusionMaskDarkness' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, OcclusionDepthRange) == 0x000568, "Member 'UDirectionalLightComponent::OcclusionDepthRange' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, LightShaftOverrideDirection) == 0x00056C, "Member 'UDirectionalLightComponent::LightShaftOverrideDirection' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, WholeSceneDynamicShadowRadius) == 0x000578, "Member 'UDirectionalLightComponent::WholeSceneDynamicShadowRadius' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, DynamicShadowDistanceMovableLight) == 0x00057C, "Member 'UDirectionalLightComponent::DynamicShadowDistanceMovableLight' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, DynamicShadowDistanceStationaryLight) == 0x000580, "Member 'UDirectionalLightComponent::DynamicShadowDistanceStationaryLight' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, M_SetDynamicShadowDistanceByMatinee) == 0x000584, "Member 'UDirectionalLightComponent::M_SetDynamicShadowDistanceByMatinee' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, DynamicShadowCascades) == 0x000588, "Member 'UDirectionalLightComponent::DynamicShadowCascades' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, CascadeDistributionExponent) == 0x00058C, "Member 'UDirectionalLightComponent::CascadeDistributionExponent' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, CascadeTransitionFraction) == 0x000590, "Member 'UDirectionalLightComponent::CascadeTransitionFraction' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, ShadowDistanceFadeoutFraction) == 0x000594, "Member 'UDirectionalLightComponent::ShadowDistanceFadeoutFraction' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, FarShadowCascadeCount) == 0x00059C, "Member 'UDirectionalLightComponent::FarShadowCascadeCount' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, FarShadowDistance) == 0x0005A0, "Member 'UDirectionalLightComponent::FarShadowDistance' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, DistanceFieldShadowDistance) == 0x0005A4, "Member 'UDirectionalLightComponent::DistanceFieldShadowDistance' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, LightSourceAngle) == 0x0005A8, "Member 'UDirectionalLightComponent::LightSourceAngle' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, TraceDistance) == 0x0005AC, "Member 'UDirectionalLightComponent::TraceDistance' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, LightmassSettings) == 0x0005B0, "Member 'UDirectionalLightComponent::LightmassSettings' has a wrong offset!");
static_assert(offsetof(UDirectionalLightComponent, ModulatedShadowColor) == 0x0005C4, "Member 'UDirectionalLightComponent::ModulatedShadowColor' has a wrong offset!");

// Class Engine.SQEX_SplineActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ASQEX_SplineActor : public AActor
{
public:
	class USQEX_SplineRootComponent*              SceneComponent;                                    // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSQEX_SplineConnection>         Connections;                                       // 0x03E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                SplineActorTangent;                                // 0x03F8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableDestination : 1;                           // 0x0404(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASQEX_SplineActor*>              LinksFrom;                                         // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	int32                                         M_Id;                                              // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineBaseRoll;                                    // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFixedNextConnect : 1;                             // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NFixedNextConnectIndex;                            // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFixedPrevConnect : 1;                             // 0x0428(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NFixedPrevConnectIndex;                            // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSetTangentEverySpline : 1;                        // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bActive : 1;                                     // 0x0430(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeSplineBranchNext(class ASQEX_SplineActor* InNextActor);
	bool ChangeSplineBranchNextByIndex(int32 InIndex);
	bool ChangeSplineBranchPrev(class ASQEX_SplineActor* InPrevActor);
	bool ChangeSplineBranchPrevByIndex(int32 InIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_SplineActor">();
	}
	static class ASQEX_SplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASQEX_SplineActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ASQEX_SplineActor) == 0x1EF72E00, "Wrong alignment on ASQEX_SplineActor");
static_assert(sizeof(ASQEX_SplineActor) == 0x1EF72E00, "Wrong size on ASQEX_SplineActor");
static_assert(offsetof(ASQEX_SplineActor, SceneComponent) == 0x0003E0, "Member 'ASQEX_SplineActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, Connections) == 0x0003E8, "Member 'ASQEX_SplineActor::Connections' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, SplineActorTangent) == 0x0003F8, "Member 'ASQEX_SplineActor::SplineActorTangent' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, LinksFrom) == 0x000408, "Member 'ASQEX_SplineActor::LinksFrom' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, M_Id) == 0x000418, "Member 'ASQEX_SplineActor::M_Id' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, SplineBaseRoll) == 0x00041C, "Member 'ASQEX_SplineActor::SplineBaseRoll' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, NFixedNextConnectIndex) == 0x000424, "Member 'ASQEX_SplineActor::NFixedNextConnectIndex' has a wrong offset!");
static_assert(offsetof(ASQEX_SplineActor, NFixedPrevConnectIndex) == 0x00042C, "Member 'ASQEX_SplineActor::NFixedPrevConnectIndex' has a wrong offset!");

// Class Engine.MaterialExpressionDeriveNormalZ
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDeriveNormalZ final : public UMaterialExpression
{
public:
	struct FExpressionInput                       InXY;                                              // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDeriveNormalZ">();
	}
	static class UMaterialExpressionDeriveNormalZ* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDeriveNormalZ>();
	}
};
static_assert(alignof(UMaterialExpressionDeriveNormalZ) == 0x112F2730, "Wrong alignment on UMaterialExpressionDeriveNormalZ");
static_assert(sizeof(UMaterialExpressionDeriveNormalZ) == 0x112F2730, "Wrong size on UMaterialExpressionDeriveNormalZ");
static_assert(offsetof(UMaterialExpressionDeriveNormalZ, InXY) == 0x000078, "Member 'UMaterialExpressionDeriveNormalZ::InXY' has a wrong offset!");

// Class Engine.InterpTrackAnimControl
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
class UInterpTrackAnimControl final : public UInterpTrackFloatBase
{
public:
	class FName                                   SlotName;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimControlTrackKey>           AnimSeqs;                                          // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSkipAnimNotifiers : 1;                            // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackAnimControl">();
	}
	static class UInterpTrackAnimControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackAnimControl>();
	}
};
static_assert(alignof(UInterpTrackAnimControl) == 0x112EC5B0, "Wrong alignment on UInterpTrackAnimControl");
static_assert(sizeof(UInterpTrackAnimControl) == 0x112EC5B0, "Wrong size on UInterpTrackAnimControl");
static_assert(offsetof(UInterpTrackAnimControl, SlotName) == 0x0000B0, "Member 'UInterpTrackAnimControl::SlotName' has a wrong offset!");
static_assert(offsetof(UInterpTrackAnimControl, AnimSeqs) == 0x0000B8, "Member 'UInterpTrackAnimControl::AnimSeqs' has a wrong offset!");

// Class Engine.StaticMeshSocket
// 0x112E9AB0 (0x112E9AF0 - 0x0040)
class UStaticMeshSocket final : public UObject
{
public:
	class FName                                   SocketName;                                        // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0048(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0054(0x112E9AF0)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0060(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshSocket">();
	}
	static class UStaticMeshSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshSocket>();
	}
};
static_assert(alignof(UStaticMeshSocket) == 0x112E9AF0, "Wrong alignment on UStaticMeshSocket");
static_assert(sizeof(UStaticMeshSocket) == 0x112E9AF0, "Wrong size on UStaticMeshSocket");
static_assert(offsetof(UStaticMeshSocket, SocketName) == 0x000040, "Member 'UStaticMeshSocket::SocketName' has a wrong offset!");
static_assert(offsetof(UStaticMeshSocket, RelativeLocation) == 0x000048, "Member 'UStaticMeshSocket::RelativeLocation' has a wrong offset!");
static_assert(offsetof(UStaticMeshSocket, RelativeRotation) == 0x000054, "Member 'UStaticMeshSocket::RelativeRotation' has a wrong offset!");
static_assert(offsetof(UStaticMeshSocket, RelativeScale) == 0x000060, "Member 'UStaticMeshSocket::RelativeScale' has a wrong offset!");
static_assert(offsetof(UStaticMeshSocket, Tag) == 0x000070, "Member 'UStaticMeshSocket::Tag' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Base
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleSQEX_Base : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Base">();
	}
	static class UParticleModuleSQEX_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Base>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Base) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Base");
static_assert(sizeof(UParticleModuleSQEX_Base) == 0x000050, "Wrong size on UParticleModuleSQEX_Base");

// Class Engine.ParticleModuleSQEX_ChangeSceneColor
// 0x01E8 (0x0238 - 0x0050)
class UParticleModuleSQEX_ChangeSceneColor final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         Pad_50[0xC];                                       // 0x0050(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ETresScreenEffectPriority                     EffectPriority;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseGetaPlus : 1;                                  // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  LightIntensity;                                    // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bSceneTintColor : 1;                               // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 SceneTintColor;                                    // 0x00B0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SceneTintAlpha;                                    // 0x0100(0x0038)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLightIntensity : 1;                               // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  LightIntensityCoefficient;                         // 0x0140(0x0038)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bInDirectIntensity : 1;                            // 0x0178(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  InDirectIntensityCoefficient;                      // 0x0180(0x0038)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAmbientIntensity : 1;                             // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  AmbientIntensityCoefficient;                       // 0x01C0(0x0038)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bKHShaderSceneEmissive : 1;                        // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  KHShaderSceneEmissiveCoefficient;                  // 0x0200(0x0038)(ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ChangeSceneColor">();
	}
	static class UParticleModuleSQEX_ChangeSceneColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ChangeSceneColor>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ChangeSceneColor) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ChangeSceneColor");
static_assert(sizeof(UParticleModuleSQEX_ChangeSceneColor) == 0x000238, "Wrong size on UParticleModuleSQEX_ChangeSceneColor");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, EffectPriority) == 0x00005C, "Member 'UParticleModuleSQEX_ChangeSceneColor::EffectPriority' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, LightIntensity) == 0x000070, "Member 'UParticleModuleSQEX_ChangeSceneColor::LightIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, SceneTintColor) == 0x0000B0, "Member 'UParticleModuleSQEX_ChangeSceneColor::SceneTintColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, SceneTintAlpha) == 0x000100, "Member 'UParticleModuleSQEX_ChangeSceneColor::SceneTintAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, LightIntensityCoefficient) == 0x000140, "Member 'UParticleModuleSQEX_ChangeSceneColor::LightIntensityCoefficient' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, InDirectIntensityCoefficient) == 0x000180, "Member 'UParticleModuleSQEX_ChangeSceneColor::InDirectIntensityCoefficient' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, AmbientIntensityCoefficient) == 0x0001C0, "Member 'UParticleModuleSQEX_ChangeSceneColor::AmbientIntensityCoefficient' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ChangeSceneColor, KHShaderSceneEmissiveCoefficient) == 0x000200, "Member 'UParticleModuleSQEX_ChangeSceneColor::KHShaderSceneEmissiveCoefficient' has a wrong offset!");

// Class Engine.Character
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ACharacter : public APawn
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBasedMovementInfo                     BasedMovement;                                     // 0x0458(0x112E9AF0)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBasedMovementInfo                     ReplicatedBasedMovement;                           // 0x0488(0x112E9AF0)(Net, RepNotify, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         AnimRootMotionTranslationScale;                    // 0x04B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BaseTranslationOffset;                             // 0x04BC(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  BaseRotationOffset;                                // 0x04D0(0x112E9D50)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ReplicatedServerLastTransformUpdateTimeStamp;      // 0x04E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReplicatedMovementMode;                            // 0x04E4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInBaseReplication;                                // 0x04E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E6[0x2];                                      // 0x04E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchedEyeHeight;                                 // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsCrouched : 1;                                   // 0x04EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPressedJump : 1;                                  // 0x04EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientUpdating : 1;                               // 0x04EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientWasFalling : 1;                             // 0x04EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientResimulateRootMotion : 1;                   // 0x04EC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientResimulateRootMotionSources : 1;            // 0x04EC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSimGravityDisabled : 1;                           // 0x04EC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientCheckEncroachmentOnNetUpdate : 1;           // 0x04EC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bServerMoveIgnoreRootMotion : 1;                   // 0x04ED(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4EE[0x2];                                      // 0x04EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpKeyHoldTime;                                   // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpMaxHoldTime;                                   // 0x04F4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpMaxCount;                                      // 0x04F8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpCurrentCount;                                  // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPad_500_0 : 1;                                  // 0x0500(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bWasJumping : 1;                                   // 0x0500(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnReachedJumpApex;                                 // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x10];                                     // 0x0518(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   MovementModeChangedDelegate;                       // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCharacterMovementUpdated;                        // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRootMotionSourceGroup                 SavedRootMotion;                                   // 0x0548(0x0100)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionMovementParams              ClientRootMotionParams;                            // 0x0650(0x115F7730)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSimulatedRootMotionReplicatedMove> RootMotionRepMoves;                                // 0x06A0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRepRootMotionMontage                  RepRootMotion;                                     // 0x06B0(0x112E9AF0)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void CacheInitialMeshOffset(const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation);
	void ClientCheatFly();
	void ClientCheatGhost();
	void ClientCheatWalk();
	void Crouch(bool bClientSimulation);
	class UAnimMontage* GetCurrentMontage();
	void Jump();
	void K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void K2_OnMovementModeChanged(EMovementMode PrevMovementMode, EMovementMode NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode);
	void K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void K2_UpdateCustomMovement(float DeltaTime);
	void LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride);
	void OnJumped();
	void OnLanded(const struct FHitResult& Hit);
	void OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride);
	void OnRep_IsCrouched();
	void OnRep_ReplicatedBasedMovement();
	void OnRep_RootMotion();
	void OnWalkingOffLedge(const struct FVector& PreviousFloorImpactNormal, const struct FVector& PreviousFloorContactNormal, const struct FVector& PreviousLocation, float TimeDelta);
	float PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, class FName StartSectionName);
	void RootMotionDebugClientPrintOnScreen(const class FString& InString);
	void SetReplicateMovement(bool bInReplicateMovement);
	void StopAnimMontage(class UAnimMontage* AnimMontage);
	void StopJumping();
	void UnCrouch(bool bClientSimulation);

	bool CanJump() const;
	bool CanJumpInternal() const;
	float GetAnimRootMotionTranslationScale() const;
	struct FRotator GetBaseRotationOffsetRotator() const;
	struct FVector GetBaseTranslationOffset() const;
	bool IsJumpProvidingForce() const;
	bool IsPlayingNetworkedRootMotionMontage() const;
	bool IsPlayingRootMotion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Character">();
	}
	static class ACharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACharacter) == 0x1EF72E00, "Wrong alignment on ACharacter");
static_assert(sizeof(ACharacter) == 0x1EF72E00, "Wrong size on ACharacter");
static_assert(offsetof(ACharacter, Mesh) == 0x000440, "Member 'ACharacter::Mesh' has a wrong offset!");
static_assert(offsetof(ACharacter, CharacterMovement) == 0x000448, "Member 'ACharacter::CharacterMovement' has a wrong offset!");
static_assert(offsetof(ACharacter, CapsuleComponent) == 0x000450, "Member 'ACharacter::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ACharacter, BasedMovement) == 0x000458, "Member 'ACharacter::BasedMovement' has a wrong offset!");
static_assert(offsetof(ACharacter, ReplicatedBasedMovement) == 0x000488, "Member 'ACharacter::ReplicatedBasedMovement' has a wrong offset!");
static_assert(offsetof(ACharacter, AnimRootMotionTranslationScale) == 0x0004B8, "Member 'ACharacter::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(ACharacter, BaseTranslationOffset) == 0x0004BC, "Member 'ACharacter::BaseTranslationOffset' has a wrong offset!");
static_assert(offsetof(ACharacter, BaseRotationOffset) == 0x0004D0, "Member 'ACharacter::BaseRotationOffset' has a wrong offset!");
static_assert(offsetof(ACharacter, ReplicatedServerLastTransformUpdateTimeStamp) == 0x0004E0, "Member 'ACharacter::ReplicatedServerLastTransformUpdateTimeStamp' has a wrong offset!");
static_assert(offsetof(ACharacter, ReplicatedMovementMode) == 0x0004E4, "Member 'ACharacter::ReplicatedMovementMode' has a wrong offset!");
static_assert(offsetof(ACharacter, bInBaseReplication) == 0x0004E5, "Member 'ACharacter::bInBaseReplication' has a wrong offset!");
static_assert(offsetof(ACharacter, CrouchedEyeHeight) == 0x0004E8, "Member 'ACharacter::CrouchedEyeHeight' has a wrong offset!");
static_assert(offsetof(ACharacter, JumpKeyHoldTime) == 0x0004F0, "Member 'ACharacter::JumpKeyHoldTime' has a wrong offset!");
static_assert(offsetof(ACharacter, JumpMaxHoldTime) == 0x0004F4, "Member 'ACharacter::JumpMaxHoldTime' has a wrong offset!");
static_assert(offsetof(ACharacter, JumpMaxCount) == 0x0004F8, "Member 'ACharacter::JumpMaxCount' has a wrong offset!");
static_assert(offsetof(ACharacter, JumpCurrentCount) == 0x0004FC, "Member 'ACharacter::JumpCurrentCount' has a wrong offset!");
static_assert(offsetof(ACharacter, OnReachedJumpApex) == 0x000508, "Member 'ACharacter::OnReachedJumpApex' has a wrong offset!");
static_assert(offsetof(ACharacter, MovementModeChangedDelegate) == 0x000528, "Member 'ACharacter::MovementModeChangedDelegate' has a wrong offset!");
static_assert(offsetof(ACharacter, OnCharacterMovementUpdated) == 0x000538, "Member 'ACharacter::OnCharacterMovementUpdated' has a wrong offset!");
static_assert(offsetof(ACharacter, SavedRootMotion) == 0x000548, "Member 'ACharacter::SavedRootMotion' has a wrong offset!");
static_assert(offsetof(ACharacter, ClientRootMotionParams) == 0x000650, "Member 'ACharacter::ClientRootMotionParams' has a wrong offset!");
static_assert(offsetof(ACharacter, RootMotionRepMoves) == 0x0006A0, "Member 'ACharacter::RootMotionRepMoves' has a wrong offset!");
static_assert(offsetof(ACharacter, RepRootMotion) == 0x0006B0, "Member 'ACharacter::RepRootMotion' has a wrong offset!");

// Class Engine.ParticleModuleLocationBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleLocationBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationBase">();
	}
	static class UParticleModuleLocationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationBase>();
	}
};
static_assert(alignof(UParticleModuleLocationBase) == 0x000008, "Wrong alignment on UParticleModuleLocationBase");
static_assert(sizeof(UParticleModuleLocationBase) == 0x000050, "Wrong size on UParticleModuleLocationBase");

// Class Engine.ParticleModuleLocation
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleLocation : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                 StartLocation;                                     // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DistributeOverNPoints;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistributeThreshold;                               // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocation">();
	}
	static class UParticleModuleLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocation>();
	}
};
static_assert(alignof(UParticleModuleLocation) == 0x000008, "Wrong alignment on UParticleModuleLocation");
static_assert(sizeof(UParticleModuleLocation) == 0x0000A8, "Wrong size on UParticleModuleLocation");
static_assert(offsetof(UParticleModuleLocation, StartLocation) == 0x000050, "Member 'UParticleModuleLocation::StartLocation' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocation, DistributeOverNPoints) == 0x0000A0, "Member 'UParticleModuleLocation::DistributeOverNPoints' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocation, DistributeThreshold) == 0x0000A4, "Member 'UParticleModuleLocation::DistributeThreshold' has a wrong offset!");

// Class Engine.ParticleModuleLocation_Seeded
// 0x0020 (0x00C8 - 0x00A8)
class UParticleModuleLocation_Seeded final : public UParticleModuleLocation
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00A8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocation_Seeded">();
	}
	static class UParticleModuleLocation_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocation_Seeded>();
	}
};
static_assert(alignof(UParticleModuleLocation_Seeded) == 0x000008, "Wrong alignment on UParticleModuleLocation_Seeded");
static_assert(sizeof(UParticleModuleLocation_Seeded) == 0x0000C8, "Wrong size on UParticleModuleLocation_Seeded");
static_assert(offsetof(UParticleModuleLocation_Seeded, RandomSeedInfo) == 0x0000A8, "Member 'UParticleModuleLocation_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.SoundBase
// 0x1166C970 (0x1166C9B0 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x1166C9B0) USoundBase : public UObject
{
public:
	class USoundClass*                            SoundClassObject;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebug : 1;                                        // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideConcurrency : 1;                          // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreFocus : 1;                                  // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      SoundConcurrencySettings;                          // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundConcurrencySettings              ConcurrencyOverrides;                              // 0x0058(0x1166C9B0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EMaxConcurrentResolutionRule                  MaxConcurrentResolutionRule;                       // 0x0068(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxConcurrentPlayCount;                            // 0x006C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSubmix*                           SoundSubmixObject;                                 // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoundSubmixSendInfo>           SoundSubmixSends;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultMasterReverbSendAmount;                     // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundEffectSourcePresetChain*          SourceEffectChain;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundBase">();
	}
	static class USoundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(USoundBase) == 0x1166C9B0, "Wrong alignment on USoundBase");
static_assert(sizeof(USoundBase) == 0x1166C9B0, "Wrong size on USoundBase");
static_assert(offsetof(USoundBase, SoundClassObject) == 0x000040, "Member 'USoundBase::SoundClassObject' has a wrong offset!");
static_assert(offsetof(USoundBase, SoundConcurrencySettings) == 0x000050, "Member 'USoundBase::SoundConcurrencySettings' has a wrong offset!");
static_assert(offsetof(USoundBase, ConcurrencyOverrides) == 0x000058, "Member 'USoundBase::ConcurrencyOverrides' has a wrong offset!");
static_assert(offsetof(USoundBase, MaxConcurrentResolutionRule) == 0x000068, "Member 'USoundBase::MaxConcurrentResolutionRule' has a wrong offset!");
static_assert(offsetof(USoundBase, MaxConcurrentPlayCount) == 0x00006C, "Member 'USoundBase::MaxConcurrentPlayCount' has a wrong offset!");
static_assert(offsetof(USoundBase, Duration) == 0x000070, "Member 'USoundBase::Duration' has a wrong offset!");
static_assert(offsetof(USoundBase, AttenuationSettings) == 0x000078, "Member 'USoundBase::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(USoundBase, Priority) == 0x000080, "Member 'USoundBase::Priority' has a wrong offset!");
static_assert(offsetof(USoundBase, SoundSubmixObject) == 0x000088, "Member 'USoundBase::SoundSubmixObject' has a wrong offset!");
static_assert(offsetof(USoundBase, SoundSubmixSends) == 0x000090, "Member 'USoundBase::SoundSubmixSends' has a wrong offset!");
static_assert(offsetof(USoundBase, DefaultMasterReverbSendAmount) == 0x0000A0, "Member 'USoundBase::DefaultMasterReverbSendAmount' has a wrong offset!");
static_assert(offsetof(USoundBase, SourceEffectChain) == 0x0000A8, "Member 'USoundBase::SourceEffectChain' has a wrong offset!");

// Class Engine.SoundWave
// 0x0000 (0x1166C9B0 - 0x1166C9B0)
#pragma pack(push, 0x1)
class alignas(0x1166C9B0) USoundWave : public USoundBase
{
public:
	int32                                         CompressionQuality;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStreaming : 1;                                    // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StreamingPriority;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPad_C4_0 : 3;                                   // 0x00C4(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bMature : 1;                                       // 0x00C4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bManualWordWrap : 1;                               // 0x00C4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSingleLine : 1;                                   // 0x00C4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVirtualizeWhenSilent : 1;                         // 0x00C4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESoundGroup                                   SoundGroup;                                        // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpokenText;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitlePriority;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChannels;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SampleRate;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RawPCMDataSize;                                    // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSubtitleCue>                   Subtitles;                                         // 0x00F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLocalizedSubtitle>             LocalizedSubtitles;                                // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveTable*                            Curves;                                            // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            InternalCurves;                                    // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x168];                                    // 0x0128(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundWave">();
	}
	static class USoundWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundWave>();
	}
};
#pragma pack(pop)
static_assert(alignof(USoundWave) == 0x1166C9B0, "Wrong alignment on USoundWave");
static_assert(sizeof(USoundWave) == 0x1166C9B0, "Wrong size on USoundWave");
static_assert(offsetof(USoundWave, CompressionQuality) == 0x0000B8, "Member 'USoundWave::CompressionQuality' has a wrong offset!");
static_assert(offsetof(USoundWave, StreamingPriority) == 0x0000C0, "Member 'USoundWave::StreamingPriority' has a wrong offset!");
static_assert(offsetof(USoundWave, SoundGroup) == 0x0000C8, "Member 'USoundWave::SoundGroup' has a wrong offset!");
static_assert(offsetof(USoundWave, SpokenText) == 0x0000D0, "Member 'USoundWave::SpokenText' has a wrong offset!");
static_assert(offsetof(USoundWave, SubtitlePriority) == 0x0000E0, "Member 'USoundWave::SubtitlePriority' has a wrong offset!");
static_assert(offsetof(USoundWave, Volume) == 0x0000E4, "Member 'USoundWave::Volume' has a wrong offset!");
static_assert(offsetof(USoundWave, Pitch) == 0x0000E8, "Member 'USoundWave::Pitch' has a wrong offset!");
static_assert(offsetof(USoundWave, NumChannels) == 0x0000EC, "Member 'USoundWave::NumChannels' has a wrong offset!");
static_assert(offsetof(USoundWave, SampleRate) == 0x0000F0, "Member 'USoundWave::SampleRate' has a wrong offset!");
static_assert(offsetof(USoundWave, RawPCMDataSize) == 0x0000F4, "Member 'USoundWave::RawPCMDataSize' has a wrong offset!");
static_assert(offsetof(USoundWave, Subtitles) == 0x0000F8, "Member 'USoundWave::Subtitles' has a wrong offset!");
static_assert(offsetof(USoundWave, LocalizedSubtitles) == 0x000108, "Member 'USoundWave::LocalizedSubtitles' has a wrong offset!");
static_assert(offsetof(USoundWave, Curves) == 0x000118, "Member 'USoundWave::Curves' has a wrong offset!");
static_assert(offsetof(USoundWave, InternalCurves) == 0x000120, "Member 'USoundWave::InternalCurves' has a wrong offset!");

// Class Engine.SoundWaveProcedural
// 0x0000 (0x1166C9B0 - 0x1166C9B0)
class USoundWaveProcedural : public USoundWave
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundWaveProcedural">();
	}
	static class USoundWaveProcedural* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundWaveProcedural>();
	}
};
static_assert(alignof(USoundWaveProcedural) == 0x1166C9B0, "Wrong alignment on USoundWaveProcedural");
static_assert(sizeof(USoundWaveProcedural) == 0x1166C9B0, "Wrong size on USoundWaveProcedural");

// Class Engine.AnimNotifyState
// 0x0008 (0x0048 - 0x0040)
class UAnimNotifyState : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetNotifyName() const;
	bool Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration) const;
	bool Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;
	bool Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState">();
	}
	static class UAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState>();
	}
};
static_assert(alignof(UAnimNotifyState) == 0x000008, "Wrong alignment on UAnimNotifyState");
static_assert(sizeof(UAnimNotifyState) == 0x000048, "Wrong size on UAnimNotifyState");

// Class Engine.InterpTrackInstFade
// 0x0000 (0x0040 - 0x0040)
class UInterpTrackInstFade final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstFade">();
	}
	static class UInterpTrackInstFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstFade>();
	}
};
static_assert(alignof(UInterpTrackInstFade) == 0x000008, "Wrong alignment on UInterpTrackInstFade");
static_assert(sizeof(UInterpTrackInstFade) == 0x000040, "Wrong size on UInterpTrackInstFade");

// Class Engine.RigidBodyBase
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ARigidBodyBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RigidBodyBase">();
	}
	static class ARigidBodyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARigidBodyBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ARigidBodyBase) == 0x1EF72E00, "Wrong alignment on ARigidBodyBase");
static_assert(sizeof(ARigidBodyBase) == 0x1EF72E00, "Wrong size on ARigidBodyBase");

// Class Engine.RadialForceActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ARadialForceActor final : public ARigidBodyBase
{
public:
	class URadialForceComponent*                  ForceComponent;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisableForce();
	void EnableForce();
	void FireImpulse();
	void ToggleForce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialForceActor">();
	}
	static class ARadialForceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadialForceActor>();
	}
};
static_assert(alignof(ARadialForceActor) == 0x1EF72E00, "Wrong alignment on ARadialForceActor");
static_assert(sizeof(ARadialForceActor) == 0x1EF72E00, "Wrong size on ARadialForceActor");
static_assert(offsetof(ARadialForceActor, ForceComponent) == 0x0003E0, "Member 'ARadialForceActor::ForceComponent' has a wrong offset!");

// Class Engine.Controller
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AController : public AActor
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Pawn;                                              // 0x03E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             Character;                                         // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerState*                           PlayerState;                                       // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TransformComponent;                                // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               ControlRotation;                                   // 0x0410(0x112E9AF0)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAttachToPawn : 1;                                 // 0x041C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPlayerController : 1;                           // 0x041C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41D[0x13];                                     // 0x041D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateName;                                         // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInstigatedAnyDamage;                             // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	class APlayerController* CastToPlayerController();
	void ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera);
	void OnRep_Pawn();
	void OnRep_PlayerState();
	void Possess(class APawn* InPawn);
	void ReceiveInstigatedAnyDamage(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser);
	void ResetIgnoreInputFlags();
	void ResetIgnoreLookInput();
	void ResetIgnoreMoveInput();
	void SetControlRotation(const struct FRotator& NewRotation);
	void SetIgnoreLookInput(bool bNewLookInput);
	void SetIgnoreMoveInput(bool bNewMoveInput);
	void SetInitialLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void StopMovement();
	void UnPossess();

	struct FRotator GetControlRotation() const;
	struct FRotator GetDesiredRotation() const;
	class AActor* GetViewTarget() const;
	bool IsLocalController() const;
	bool IsLocalPlayerController() const;
	bool IsLookInputIgnored() const;
	bool IsMoveInputIgnored() const;
	bool IsPlayerController() const;
	class APawn* K2_GetPawn() const;
	bool LineOfSightTo(const class AActor* Other, const struct FVector& ViewPoint, bool bAlternateChecks) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Controller">();
	}
	static class AController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AController) == 0x1EF72E00, "Wrong alignment on AController");
static_assert(sizeof(AController) == 0x1EF72E00, "Wrong size on AController");
static_assert(offsetof(AController, Pawn) == 0x0003E8, "Member 'AController::Pawn' has a wrong offset!");
static_assert(offsetof(AController, Character) == 0x0003F8, "Member 'AController::Character' has a wrong offset!");
static_assert(offsetof(AController, PlayerState) == 0x000400, "Member 'AController::PlayerState' has a wrong offset!");
static_assert(offsetof(AController, TransformComponent) == 0x000408, "Member 'AController::TransformComponent' has a wrong offset!");
static_assert(offsetof(AController, ControlRotation) == 0x000410, "Member 'AController::ControlRotation' has a wrong offset!");
static_assert(offsetof(AController, StateName) == 0x000430, "Member 'AController::StateName' has a wrong offset!");
static_assert(offsetof(AController, OnInstigatedAnyDamage) == 0x000438, "Member 'AController::OnInstigatedAnyDamage' has a wrong offset!");

// Class Engine.StaticMeshActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AStaticMeshActor : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStaticMeshReplicateMovement;                      // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavDataGatheringMode                         NavigationGeometryGatheringMode;                   // 0x03E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EA[0x6];                                      // 0x03EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshActor">();
	}
	static class AStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AStaticMeshActor) == 0x1EF72E00, "Wrong alignment on AStaticMeshActor");
static_assert(sizeof(AStaticMeshActor) == 0x1EF72E00, "Wrong size on AStaticMeshActor");
static_assert(offsetof(AStaticMeshActor, StaticMeshComponent) == 0x0003E0, "Member 'AStaticMeshActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AStaticMeshActor, bStaticMeshReplicateMovement) == 0x0003E8, "Member 'AStaticMeshActor::bStaticMeshReplicateMovement' has a wrong offset!");
static_assert(offsetof(AStaticMeshActor, NavigationGeometryGatheringMode) == 0x0003E9, "Member 'AStaticMeshActor::NavigationGeometryGatheringMode' has a wrong offset!");

// Class Engine.MaterialExpressionArccosine
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArccosine final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArccosine">();
	}
	static class UMaterialExpressionArccosine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArccosine>();
	}
};
static_assert(alignof(UMaterialExpressionArccosine) == 0x112F2730, "Wrong alignment on UMaterialExpressionArccosine");
static_assert(sizeof(UMaterialExpressionArccosine) == 0x112F2730, "Wrong size on UMaterialExpressionArccosine");
static_assert(offsetof(UMaterialExpressionArccosine, Input) == 0x000078, "Member 'UMaterialExpressionArccosine::Input' has a wrong offset!");

// Class Engine.SQEX_VFXManager
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASQEX_VFXManager : public AActor
{
public:
	uint8                                         Pad_3E0[0xB0];                                     // 0x03E0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnGPUParticleReaction;                             // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UAnimationAsset* GetAnimAssetAndTime(class USkeletalMeshComponent* In_Mesh, float* Out_Time);
	float GetAreaTime();
	class USkeletalMeshComponent* GetPlayerWepSkeletalMesh();
	bool IsSepiaMode();
	void SetAreaTime(float In_NewTime);
	void SetCinematographyMode(bool In_NewMode);
	void SetEffectScore(int32 In_MaxScore, int32 In_CurrentScore);
	void SpawnEffectEmitterPoolOwner(class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, int32 In_GroupID, bool bAutoDestroy, float In_WarmupTime);
	void TresVFXManager_AllEffectDestroy();
	void TresVFXManager_EffectCleanup();
	void TresVFXManager_EffectDestroy(const class FString& In_Tag);
	void TresVFXManager_LoadAndSummonActor(class FName In_Path);
	void TresVFXManager_ResetBlur();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VFXManager">();
	}
	static class ASQEX_VFXManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASQEX_VFXManager>();
	}
};
static_assert(alignof(ASQEX_VFXManager) == 0x1EF72E00, "Wrong alignment on ASQEX_VFXManager");
static_assert(sizeof(ASQEX_VFXManager) == 0x1EF72E00, "Wrong size on ASQEX_VFXManager");
static_assert(offsetof(ASQEX_VFXManager, OnGPUParticleReaction) == 0x000490, "Member 'ASQEX_VFXManager::OnGPUParticleReaction' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_PostprocessGlare
// 0x00C0 (0x0110 - 0x0050)
class UParticleModuleSQEX_PostprocessGlare final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionFloat                  Size;                                              // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 Color;                                             // 0x0088(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Alpha;                                             // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_PostprocessGlare">();
	}
	static class UParticleModuleSQEX_PostprocessGlare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_PostprocessGlare>();
	}
};
static_assert(alignof(UParticleModuleSQEX_PostprocessGlare) == 0x000008, "Wrong alignment on UParticleModuleSQEX_PostprocessGlare");
static_assert(sizeof(UParticleModuleSQEX_PostprocessGlare) == 0x000110, "Wrong size on UParticleModuleSQEX_PostprocessGlare");
static_assert(offsetof(UParticleModuleSQEX_PostprocessGlare, Size) == 0x000050, "Member 'UParticleModuleSQEX_PostprocessGlare::Size' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_PostprocessGlare, Color) == 0x000088, "Member 'UParticleModuleSQEX_PostprocessGlare::Color' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_PostprocessGlare, Alpha) == 0x0000D8, "Member 'UParticleModuleSQEX_PostprocessGlare::Alpha' has a wrong offset!");

// Class Engine.DeveloperSettings
// 0x0010 (0x0050 - 0x0040)
class UDeveloperSettings : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeveloperSettings">();
	}
	static class UDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeveloperSettings>();
	}
};
static_assert(alignof(UDeveloperSettings) == 0x000008, "Wrong alignment on UDeveloperSettings");
static_assert(sizeof(UDeveloperSettings) == 0x000050, "Wrong size on UDeveloperSettings");

// Class Engine.RendererOverrideSettings
// 0x0008 (0x0058 - 0x0050)
class URendererOverrideSettings final : public UDeveloperSettings
{
public:
	uint8                                         bSupportAllShaderPermutations : 1;                 // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceRecomputeTangents : 1;                       // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RendererOverrideSettings">();
	}
	static class URendererOverrideSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URendererOverrideSettings>();
	}
};
static_assert(alignof(URendererOverrideSettings) == 0x000008, "Wrong alignment on URendererOverrideSettings");
static_assert(sizeof(URendererOverrideSettings) == 0x000058, "Wrong size on URendererOverrideSettings");

// Class Engine.BlueprintFunctionLibrary
// 0x0000 (0x0040 - 0x0040)
class UBlueprintFunctionLibrary : public UObject
{
public:
	static struct FStringAssetReference MakeStringAssetReference(const class FString& AssetLongPathname);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintFunctionLibrary">();
	}
	static class UBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UBlueprintFunctionLibrary");
static_assert(sizeof(UBlueprintFunctionLibrary) == 0x000040, "Wrong size on UBlueprintFunctionLibrary");

// Class Engine.KismetSystemLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetSystemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FDebugFloatHistory AddFloatHistorySample(float Value, const struct FDebugFloatHistory& FloatHistory);
	static class FString AssetClassIDToString(const TSoftClassPtr<class UClass>& Asset);
	static class FString AssetIDToString(const TSoftObjectPtr<class UObject>& Asset);
	static bool BoxOverlapActors(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool BoxOverlapComponents(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool BoxTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool BoxTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool BoxTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool BoxTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool BoxTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool BoxTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CanLaunchURL(const class FString& URL);
	static bool CapsuleOverlapActors(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool CapsuleOverlapComponents(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool CapsuleTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CapsuleTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CapsuleTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void CollectGarbage();
	static bool ComponentOverlapActors(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool ComponentOverlapComponents(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static void ControlScreensaver(bool bAllowScreenSaver);
	static TSoftClassPtr<class UClass> Conv_ClassToSoftClassReference(const TSubclassOf<class UObject>& Class_0);
	static class UObject* Conv_InterfaceToObject(const TScriptInterface<class IInterface>& Interface);
	static TSoftObjectPtr<class UObject> Conv_ObjectToSoftObjectReference(class UObject* Object);
	static TSubclassOf<class UObject> Conv_SoftClassReferenceToClass(const TSoftClassPtr<class UClass>& AssetClass);
	static class UObject* Conv_SoftObjectReferenceToObject(const TSoftObjectPtr<class UObject>& Asset);
	static void CreateCopyForUndoBuffer(class UObject* ObjectToModify);
	static void Delay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo);
	static bool DoesImplementInterface(class UObject* TestObject, TSubclassOf<class IInterface> Interface);
	static void DrawDebugArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugBox(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, float Thickness);
	static void DrawDebugCamera(const class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration);
	static void DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugCircle(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis);
	static void DrawDebugCone(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugConeInDegrees(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugCoordinateSystem(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration, float Thickness);
	static void DrawDebugCylinder(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugFloatHistoryLocation(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration);
	static void DrawDebugFloatHistoryTransform(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration);
	static void DrawDebugFrustum(class UObject* WorldContextObject, const struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration, float Thickness);
	static void DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugPlane(class UObject* WorldContextObject, const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration);
	static void DrawDebugPoint(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration);
	static void DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness);
	static void DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration);
	static bool EqualEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B);
	static bool EqualEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B);
	static bool EqualEqual_SoftClassReference(const TSoftClassPtr<class UClass>& A, const TSoftClassPtr<class UClass>& B);
	static bool EqualEqual_SoftObjectReference(const TSoftObjectPtr<class UObject>& A, const TSoftObjectPtr<class UObject>& B);
	static void ExecuteConsoleCommand(class UObject* WorldContextObject, const class FString& Command, class APlayerController* SpecificPlayer);
	static void FlushDebugStrings(class UObject* WorldContextObject);
	static void FlushPersistentDebugLines(class UObject* WorldContextObject);
	static void ForceCloseAdBanner();
	static void GetActorBounds(const class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent);
	static void GetActorListFromComponentList(const TArray<class UPrimitiveComponent*>& ComponentList, class UClass* ActorClassFilter, TArray<class AActor*>* OutActorList);
	static int32 GetAdIDCount();
	static class FString GetClassDisplayName(class UClass* Class_0);
	static TSubclassOf<class UObject> GetClassFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId);
	static class FString GetCommandLine();
	static void GetComponentBounds(const class USceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius);
	static bool GetConvenientWindowedResolutions(TArray<struct FIntPoint>* Resolutions);
	static bool GetCurrentBundleState(const struct FPrimaryAssetId& PrimaryAssetId, bool bForceCurrentState, TArray<class FName>* OutBundles);
	static class FString GetDefaultLanguage();
	static class FString GetDefaultLocale();
	static class FString GetDeviceId();
	static class FString GetDisplayName(const class UObject* Object);
	static class FString GetEngineVersion();
	static class FString GetGameBundleId();
	static class FString GetGameName();
	static float GetGameTimeInSeconds(class UObject* WorldContextObject);
	static float GetGraphicsTexturUseMemory();
	static float GetGraphicsUseIndexBufferMemory();
	static float GetGraphicsUseRenderTargetMemory();
	static float GetGraphicsUseTexturMemory();
	static float GetGraphicsUseUniformBufferMemory();
	static float GetGraphicsUseUnknowMemory();
	static float GetGraphicsUseVertexMemory();
	static class FString GetLocalCurrencyCode();
	static class FString GetLocalCurrencySymbol();
	static float GetMainUseTotalMemory();
	static int32 GetMinYResolutionFor3DView();
	static int32 GetMinYResolutionForUI();
	static class UObject* GetObjectFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId);
	static class FString GetObjectName(const class UObject* Object);
	static class FString GetPathName(const class UObject* Object);
	static class FString GetPlatformUserName();
	static TArray<class FString> GetPreferredLanguages();
	static struct FPrimaryAssetId GetPrimaryAssetIdFromClass(TSubclassOf<class UObject> Class_0);
	static struct FPrimaryAssetId GetPrimaryAssetIdFromObject(class UObject* Object);
	static struct FPrimaryAssetId GetPrimaryAssetIdFromSoftClassReference(TSoftClassPtr<class UClass> SoftClassReference);
	static struct FPrimaryAssetId GetPrimaryAssetIdFromSoftObjectReference(TSoftObjectPtr<class UObject> SoftObjectReference);
	static void GetPrimaryAssetIdList(const struct FPrimaryAssetType& PrimaryAssetType, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList);
	static void GetPrimaryAssetsWithBundleState(const TArray<class FName>& RequiredBundles, const TArray<class FName>& ExcludedBundles, const TArray<struct FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList);
	static int32 GetRenderingDetailMode();
	static int32 GetRenderingMaterialQualityLevel();
	static TSoftClassPtr<class UClass> GetSoftClassReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId);
	static TSoftObjectPtr<class UObject> GetSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId);
	static float GetStatUnitDraw(class UObject* WorldContextObject);
	static float GetStatUnitGame(class UObject* WorldContextObject);
	static float GetStatUnitGPU(class UObject* WorldContextObject);
	static bool GetSupportedFullscreenResolutions(TArray<struct FIntPoint>* Resolutions);
	static class FString GetUniqueDeviceId();
	static bool GetVolumeButtonsHandledBySystem();
	static void HideAdBanner();
	static bool IsControllerAssignedToGamepad(int32 ControllerId);
	static bool IsDedicatedServer(class UObject* WorldContextObject);
	static bool IsInterstitialAdAvailable();
	static bool IsInterstitialAdRequested();
	static bool IsLoggedIn(class APlayerController* SpecificPlayer);
	static bool IsPackagedForDistribution();
	static bool IsServer(class UObject* WorldContextObject);
	static bool IsStandalone(class UObject* WorldContextObject);
	static bool IsValid(const class UObject* Object);
	static bool IsValidClass(class UClass* Class_0);
	static bool IsValidPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId);
	static bool IsValidPrimaryAssetType(const struct FPrimaryAssetType& PrimaryAssetType);
	static bool IsValidSoftClassReference(const TSoftClassPtr<class UClass>& SoftClassReference);
	static bool IsValidSoftObjectReference(const TSoftObjectPtr<class UObject>& SoftObjectReference);
	static void K2_ClearAndInvalidateTimerHandle(class UObject* WorldContextObject, struct FTimerHandle& Handle);
	static void K2_ClearTimer(class UObject* Object, const class FString& FunctionName);
	static void K2_ClearTimerDelegate(TDelegate<void()> Delegate);
	static void K2_ClearTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static float K2_GetTimerElapsedTime(class UObject* Object, const class FString& FunctionName);
	static float K2_GetTimerElapsedTimeDelegate(TDelegate<void()> Delegate);
	static float K2_GetTimerElapsedTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static float K2_GetTimerRemainingTime(class UObject* Object, const class FString& FunctionName);
	static float K2_GetTimerRemainingTimeDelegate(TDelegate<void()> Delegate);
	static float K2_GetTimerRemainingTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static struct FTimerHandle K2_InvalidateTimerHandle(struct FTimerHandle& Handle);
	static bool K2_IsTimerActive(class UObject* Object, const class FString& FunctionName);
	static bool K2_IsTimerActiveDelegate(TDelegate<void()> Delegate);
	static bool K2_IsTimerActiveHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static bool K2_IsTimerPaused(class UObject* Object, const class FString& FunctionName);
	static bool K2_IsTimerPausedDelegate(TDelegate<void()> Delegate);
	static bool K2_IsTimerPausedHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static bool K2_IsValidTimerHandle(const struct FTimerHandle& Handle);
	static void K2_PauseTimer(class UObject* Object, const class FString& FunctionName);
	static void K2_PauseTimerDelegate(TDelegate<void()> Delegate);
	static void K2_PauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static struct FTimerHandle K2_SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping);
	static struct FTimerHandle K2_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping);
	static bool K2_TimerExists(class UObject* Object, const class FString& FunctionName);
	static bool K2_TimerExistsDelegate(TDelegate<void()> Delegate);
	static bool K2_TimerExistsHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static void K2_UnPauseTimer(class UObject* Object, const class FString& FunctionName);
	static void K2_UnPauseTimerDelegate(TDelegate<void()> Delegate);
	static void K2_UnPauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle);
	static void LaunchURL(const class FString& URL);
	static bool LineTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool LineTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool LineTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool LineTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool LineTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void LoadAsset(class UObject* WorldContextObject, TSoftObjectPtr<class UObject> Asset, TDelegate<void(class UObject* Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo);
	static void LoadAssetClass(class UObject* WorldContextObject, TSoftClassPtr<class UClass> AssetClass, TDelegate<void(TSubclassOf<class UObject> Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo);
	static void LoadInterstitialAd(int32 AdIdIndex);
	static bool MakeLiteralBool(bool Value);
	static uint8 MakeLiteralByte(uint8 Value);
	static float MakeLiteralFloat(float Value);
	static int32 MakeLiteralInt(int32 Value);
	static class FName MakeLiteralName(class FName Value);
	static class FString MakeLiteralString(const class FString& Value);
	static class FText MakeLiteralText(const class FText& Value);
	static void MoveComponentTo(class USceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, EMoveComponentAction MoveAction, const struct FLatentActionInfo& LatentInfo);
	static bool NotEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B);
	static bool NotEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B);
	static bool NotEqual_SoftClassReference(const TSoftClassPtr<class UClass>& A, const TSoftClassPtr<class UClass>& B);
	static bool NotEqual_SoftObjectReference(const TSoftObjectPtr<class UObject>& A, const TSoftObjectPtr<class UObject>& B);
	static void PrintString(class UObject* WorldContextObject, const class FString& InString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration);
	static void PrintText(class UObject* WorldContextObject, const class FText& InText, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration);
	static void PrintWarning(const class FString& InString);
	static void QuitGame(class UObject* WorldContextObject, class APlayerController* SpecificPlayer, EQuitPreference QuitPreference);
	static void RegisterForRemoteNotifications();
	static void ResetGamepadAssignments();
	static void ResetGamepadAssignmentToController(int32 ControllerId);
	static void RetriggerableDelay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo);
	static void SetAssetClassPropertyByName(class UObject* Object, class FName PropertyName, const TSoftClassPtr<class UClass>& Value);
	static void SetAssetPropertyByName(class UObject* Object, class FName PropertyName, const TSoftObjectPtr<class UObject>& Value);
	static void SetBoolPropertyByName(class UObject* Object, class FName PropertyName, bool Value);
	static void SetBytePropertyByName(class UObject* Object, class FName PropertyName, uint8 Value);
	static void SetClassPropertyByName(class UObject* Object, class FName PropertyName, TSubclassOf<class UObject> Value);
	static void SetCollisionProfileNameProperty(class UObject* Object, class FName PropertyName, const struct FCollisionProfileName& Value);
	static void SetFloatPropertyByName(class UObject* Object, class FName PropertyName, float Value);
	static void SetInterfacePropertyByName(class UObject* Object, class FName PropertyName, const TScriptInterface<class IInterface>& Value);
	static void SetIntPropertyByName(class UObject* Object, class FName PropertyName, int32 Value);
	static void SetLinearColorPropertyByName(class UObject* Object, class FName PropertyName, const struct FLinearColor& Value);
	static void SetNamePropertyByName(class UObject* Object, class FName PropertyName, const class FName& Value);
	static void SetObjectPropertyByName(class UObject* Object, class FName PropertyName, class UObject* Value);
	static void SetRotatorPropertyByName(class UObject* Object, class FName PropertyName, const struct FRotator& Value);
	static void SetStringPropertyByName(class UObject* Object, class FName PropertyName, const class FString& Value);
	static void SetStructurePropertyByName(class UObject* Object, class FName PropertyName, const struct FGenericStruct& Value);
	static void SetSuppressViewportTransitionMessage(class UObject* WorldContextObject, bool bState);
	static void SetTextPropertyByName(class UObject* Object, class FName PropertyName, const class FText& Value);
	static void SetTransformPropertyByName(class UObject* Object, class FName PropertyName, const struct FTransform& Value);
	static void SetUserActivity(const struct FUserActivity& UserActivity);
	static void SetVectorPropertyByName(class UObject* Object, class FName PropertyName, const struct FVector& Value);
	static void SetVolumeButtonsHandledBySystem(bool bEnabled);
	static void SetWindowTitle(const class FText& Title);
	static void ShowAdBanner(int32 AdIdIndex, bool bShowOnBottomOfScreen);
	static void ShowInterstitialAd();
	static void ShowPlatformSpecificAchievementsScreen(class APlayerController* SpecificPlayer);
	static void ShowPlatformSpecificLeaderboardScreen(const class FString& CategoryName);
	static bool SphereOverlapActors(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool SphereOverlapComponents(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool SphereTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool SphereTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool SphereTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool SphereTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool SphereTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool SphereTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void SQEX_ExecuteEngineCommand(const class FString& Command);
	static void StackTrace();
	static void UnloadPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId);
	static void UnloadPrimaryAssetList(const TArray<struct FPrimaryAssetId>& PrimaryAssetIdList);
	static void UnregisterForRemoteNotifications();
	static void WaitStreamAllResource(float Duration);

	void OnAssetLoaded__DelegateSignature(class UObject* Loaded);
	void OnAssetClassLoaded__DelegateSignature(TSubclassOf<class UObject> Loaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetSystemLibrary">();
	}
	static class UKismetSystemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetSystemLibrary>();
	}
};
static_assert(alignof(UKismetSystemLibrary) == 0x000008, "Wrong alignment on UKismetSystemLibrary");
static_assert(sizeof(UKismetSystemLibrary) == 0x000040, "Wrong size on UKismetSystemLibrary");

// Class Engine.Note
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ANote : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Note">();
	}
	static class ANote* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANote>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANote) == 0x1EF72E00, "Wrong alignment on ANote");
static_assert(sizeof(ANote) == 0x1EF72E00, "Wrong size on ANote");

// Class Engine.ParticleModuleColorBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleColorBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleColorBase">();
	}
	static class UParticleModuleColorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleColorBase>();
	}
};
static_assert(alignof(UParticleModuleColorBase) == 0x000008, "Wrong alignment on UParticleModuleColorBase");
static_assert(sizeof(UParticleModuleColorBase) == 0x000050, "Wrong size on UParticleModuleColorBase");

// Class Engine.ParticleModuleColor
// 0x0090 (0x00E0 - 0x0050)
class UParticleModuleColor : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                 StartColor;                                        // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StartAlpha;                                        // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bClampAlpha : 1;                                   // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleColor">();
	}
	static class UParticleModuleColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleColor>();
	}
};
static_assert(alignof(UParticleModuleColor) == 0x000008, "Wrong alignment on UParticleModuleColor");
static_assert(sizeof(UParticleModuleColor) == 0x0000E0, "Wrong size on UParticleModuleColor");
static_assert(offsetof(UParticleModuleColor, StartColor) == 0x000050, "Member 'UParticleModuleColor::StartColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleColor, StartAlpha) == 0x0000A0, "Member 'UParticleModuleColor::StartAlpha' has a wrong offset!");

// Class Engine.GameModeBase
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AGameModeBase : public AInfo
{
public:
	class FString                                 OptionsString;                                     // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGameSession>               GameSessionClass;                                  // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGameStateBase>             GameStateClass;                                    // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerController>          PlayerControllerClass;                             // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerState>               PlayerStateClass;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHUD>                       HUDClass;                                          // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      DefaultPawnClass;                                  // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatorPawn>             SpectatorClass;                                    // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerController>          ReplaySpectatorPlayerControllerClass;              // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameSession*                           GameSession;                                       // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameStateBase*                         GameState;                                         // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DefaultPlayerName;                                 // 0x0440(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bUseSeamlessTravel : 1;                            // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartPlayersAsSpectators : 1;                     // 0x0458(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPauseable : 1;                                    // 0x0458(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_459[0x17];                                     // 0x0459(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget);
	void ChangeName(class AController* Controller, const class FString& NewName, bool bNameChange);
	class AActor* ChoosePlayerStart(class AController* Player);
	class AActor* FindPlayerStart(class AController* Player, const class FString& IncomingName);
	class UClass* GetDefaultPawnClassForController(class AController* InController);
	int32 GetNumPlayers();
	int32 GetNumSpectators();
	void HandleStartingNewPlayer(class APlayerController* NewPlayer);
	void InitializeHUDForPlayer(class APlayerController* NewPlayer);
	void InitStartSpot(class AActor* StartSpot, class AController* NewPlayer);
	class AActor* K2_FindPlayerStart(class AController* Player, const class FString& IncomingName);
	void K2_OnChangeName(class AController* Other, const class FString& NewName, bool bNameChange);
	void K2_OnLogout(class AController* ExitingController);
	void K2_OnRestartPlayer(class AController* NewPlayer);
	void K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC);
	void K2_PostLogin(class APlayerController* NewPlayer);
	bool PlayerCanRestart(class APlayerController* Player);
	void ResetLevel();
	void RestartPlayer(class AController* NewPlayer);
	void RestartPlayerAtPlayerStart(class AController* NewPlayer, class AActor* StartSpot);
	void RestartPlayerAtTransform(class AController* NewPlayer, const struct FTransform& SpawnTransform);
	void ReturnToMainMenuHost();
	bool ShouldReset(class AActor* ActorToReset);
	class APawn* SpawnDefaultPawnAtTransform(class AController* NewPlayer, const struct FTransform& SpawnTransform);
	class APawn* SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot);
	void StartPlay();

	bool HasMatchStarted() const;
	bool MustSpectate(class APlayerController* NewPlayerController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeBase">();
	}
	static class AGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGameModeBase) == 0x1EF72E00, "Wrong alignment on AGameModeBase");
static_assert(sizeof(AGameModeBase) == 0x1EF72E00, "Wrong size on AGameModeBase");
static_assert(offsetof(AGameModeBase, OptionsString) == 0x0003E0, "Member 'AGameModeBase::OptionsString' has a wrong offset!");
static_assert(offsetof(AGameModeBase, GameSessionClass) == 0x0003F0, "Member 'AGameModeBase::GameSessionClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, GameStateClass) == 0x0003F8, "Member 'AGameModeBase::GameStateClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, PlayerControllerClass) == 0x000400, "Member 'AGameModeBase::PlayerControllerClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, PlayerStateClass) == 0x000408, "Member 'AGameModeBase::PlayerStateClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, HUDClass) == 0x000410, "Member 'AGameModeBase::HUDClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, DefaultPawnClass) == 0x000418, "Member 'AGameModeBase::DefaultPawnClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, SpectatorClass) == 0x000420, "Member 'AGameModeBase::SpectatorClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, ReplaySpectatorPlayerControllerClass) == 0x000428, "Member 'AGameModeBase::ReplaySpectatorPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(AGameModeBase, GameSession) == 0x000430, "Member 'AGameModeBase::GameSession' has a wrong offset!");
static_assert(offsetof(AGameModeBase, GameState) == 0x000438, "Member 'AGameModeBase::GameState' has a wrong offset!");
static_assert(offsetof(AGameModeBase, DefaultPlayerName) == 0x000440, "Member 'AGameModeBase::DefaultPlayerName' has a wrong offset!");

// Class Engine.ParticleModuleSpawnBase
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSpawnBase : public UParticleModule
{
public:
	uint8                                         bProcessSpawnRate : 1;                             // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bProcessBurstList : 1;                             // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSpawnBase">();
	}
	static class UParticleModuleSpawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSpawnBase>();
	}
};
static_assert(alignof(UParticleModuleSpawnBase) == 0x000008, "Wrong alignment on UParticleModuleSpawnBase");
static_assert(sizeof(UParticleModuleSpawnBase) == 0x000058, "Wrong size on UParticleModuleSpawnBase");

// Class Engine.ParticleModuleSQEX_LocationBase
// 0x112E9A98 (0x112E9AF0 - 0x0058)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleSQEX_LocationBase : public UParticleModuleSpawnBase
{
public:
	uint8                                         bUseParentLockSpawnList : 1;                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LockSpawnPointInLoop;                              // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Direction;                                         // 0x0060(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NormalDirection;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARTICLE_DIR_TYPE                            DirectionType;                                     // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Speed;                                             // 0x0078(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bApplyOwnerScale : 1;                              // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplySpawnLocationOwnerScale : 1;                 // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoMeshRotation : 1;                               // 0x00B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_SPAWN_ROT_CALC_MODE                     SpawnRotCalcMode;                                  // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NormalAxis;                                        // 0x00B8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalUpAxis;                                      // 0x00C4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceTopAxis;                                 // 0x00D0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceUpAxis;                                  // 0x00DC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceFacingAxis;                              // 0x00E8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_LocationBase">();
	}
	static class UParticleModuleSQEX_LocationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_LocationBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleSQEX_LocationBase) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_LocationBase");
static_assert(sizeof(UParticleModuleSQEX_LocationBase) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_LocationBase");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, LockSpawnPointInLoop) == 0x00005C, "Member 'UParticleModuleSQEX_LocationBase::LockSpawnPointInLoop' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, Direction) == 0x000060, "Member 'UParticleModuleSQEX_LocationBase::Direction' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, NormalDirection) == 0x00006C, "Member 'UParticleModuleSQEX_LocationBase::NormalDirection' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, DirectionType) == 0x000070, "Member 'UParticleModuleSQEX_LocationBase::DirectionType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, Speed) == 0x000078, "Member 'UParticleModuleSQEX_LocationBase::Speed' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, SpawnRotCalcMode) == 0x0000B4, "Member 'UParticleModuleSQEX_LocationBase::SpawnRotCalcMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, NormalAxis) == 0x0000B8, "Member 'UParticleModuleSQEX_LocationBase::NormalAxis' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, NormalUpAxis) == 0x0000C4, "Member 'UParticleModuleSQEX_LocationBase::NormalUpAxis' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, LocalSpaceTopAxis) == 0x0000D0, "Member 'UParticleModuleSQEX_LocationBase::LocalSpaceTopAxis' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, LocalSpaceUpAxis) == 0x0000DC, "Member 'UParticleModuleSQEX_LocationBase::LocalSpaceUpAxis' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_LocationBase, LocalSpaceFacingAxis) == 0x0000E8, "Member 'UParticleModuleSQEX_LocationBase::LocalSpaceFacingAxis' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Quadrangle
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleSQEX_Quadrangle : public UParticleModuleSQEX_LocationBase
{
public:
	struct FVector                                QuadrangleSize;                                    // 0x00F8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 QuadrangleScale;                                   // 0x0108(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Deviation;                                         // 0x0158(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x38];                                     // 0x0190(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Quadrangle">();
	}
	static class UParticleModuleSQEX_Quadrangle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Quadrangle>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleSQEX_Quadrangle) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Quadrangle");
static_assert(sizeof(UParticleModuleSQEX_Quadrangle) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Quadrangle");
static_assert(offsetof(UParticleModuleSQEX_Quadrangle, QuadrangleSize) == 0x0000F8, "Member 'UParticleModuleSQEX_Quadrangle::QuadrangleSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Quadrangle, QuadrangleScale) == 0x000108, "Member 'UParticleModuleSQEX_Quadrangle::QuadrangleScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Quadrangle, Deviation) == 0x000158, "Member 'UParticleModuleSQEX_Quadrangle::Deviation' has a wrong offset!");

// Class Engine.Scene
// 0x0000 (0x0040 - 0x0040)
class UScene final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scene">();
	}
	static class UScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScene>();
	}
};
static_assert(alignof(UScene) == 0x000008, "Wrong alignment on UScene");
static_assert(sizeof(UScene) == 0x000040, "Wrong size on UScene");

// Class Engine.AISystemBase
// 0x0034 (0x0074 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x3A) UAISystemBase : public UObject
{
public:
	struct FStringClassReference                  AISystemClassName;                                 // 0x0040(0x003A)(Config, GlobalConfig, NoClear, NativeAccessSpecifierPrivate)
	class FName                                   AISystemModuleName;                                // 0x0050(0x0008)(ZeroConstructor, Config, GlobalConfig, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInstantiateAISystemOnClient;                      // 0x0058(0x0001)(ZeroConstructor, Config, GlobalConfig, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISystemBase">();
	}
	static class UAISystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISystemBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UAISystemBase) == 0x00003A, "Wrong alignment on UAISystemBase");
static_assert(sizeof(UAISystemBase) == 0x000074, "Wrong size on UAISystemBase");
static_assert(offsetof(UAISystemBase, AISystemClassName) == 0x000040, "Member 'UAISystemBase::AISystemClassName' has a wrong offset!");
static_assert(offsetof(UAISystemBase, AISystemModuleName) == 0x000050, "Member 'UAISystemBase::AISystemModuleName' has a wrong offset!");
static_assert(offsetof(UAISystemBase, bInstantiateAISystemOnClient) == 0x000058, "Member 'UAISystemBase::bInstantiateAISystemOnClient' has a wrong offset!");

// Class Engine.ParticleModuleParameterBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleParameterBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleParameterBase">();
	}
	static class UParticleModuleParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleParameterBase>();
	}
};
static_assert(alignof(UParticleModuleParameterBase) == 0x000008, "Wrong alignment on UParticleModuleParameterBase");
static_assert(sizeof(UParticleModuleParameterBase) == 0x000050, "Wrong size on UParticleModuleParameterBase");

// Class Engine.ParticleModuleParameterDynamic
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
public:
	TArray<struct FEmitterDynamicParameter>       DynamicParams;                                     // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         UpdateFlags;                                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsesVelocity : 1;                                 // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleParameterDynamic">();
	}
	static class UParticleModuleParameterDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleParameterDynamic>();
	}
};
static_assert(alignof(UParticleModuleParameterDynamic) == 0x000008, "Wrong alignment on UParticleModuleParameterDynamic");
static_assert(sizeof(UParticleModuleParameterDynamic) == 0x000068, "Wrong size on UParticleModuleParameterDynamic");
static_assert(offsetof(UParticleModuleParameterDynamic, DynamicParams) == 0x000050, "Member 'UParticleModuleParameterDynamic::DynamicParams' has a wrong offset!");
static_assert(offsetof(UParticleModuleParameterDynamic, UpdateFlags) == 0x000060, "Member 'UParticleModuleParameterDynamic::UpdateFlags' has a wrong offset!");

// Class Engine.LevelStreaming
// 0x112EAE40 (0x112EAE80 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x112EAE80) ULevelStreaming : public UObject
{
public:
	class FName                                   PackageName;                                       // 0x0040(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  WorldAsset;                                        // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PackageNameToLoad;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LODPackageNames;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LevelTransform;                                    // 0x0090(0x112E9D50)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         BitPad_C0_0 : 3;                                   // 0x00C0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bShouldBeVisibleInEditor : 1;                      // 0x00C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLocked : 1;                                       // 0x00C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBeLoaded : 1;                               // 0x00C0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBeVisible : 1;                              // 0x00C0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsStatic : 1;                                     // 0x00C0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBlockOnLoad : 1;                            // 0x00C1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelLODIndex;                                     // 0x00C4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableDistanceStreaming : 1;                     // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_C8_1 : 1;                                   // 0x00C8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bDrawOnLevelStatusMap : 1;                         // 0x00C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexIsLightingScenario : 1;                       // 0x00C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 DrawColor;                                         // 0x00CC(0x0004)(Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LevelColor;                                        // 0x00D0(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ALevelStreamingVolume*>          EditorStreamingVolumes;                            // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenVolumeUnloadRequests;                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Keywords;                                          // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLevelLoaded;                                     // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLevelUnloaded;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLevelShown;                                      // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLevelHidden;                                     // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULevel*                                 LoadedLevel;                                       // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevel*                                 PendingUnloadLevel;                                // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x10];                                     // 0x0158(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULevelStreaming* CreateInstance(const class FString& UniqueInstanceName);
	class ALevelScriptActor* GetLevelScriptActor();

	class FName GetWorldAssetPackageFName() const;
	bool IsLevelLoaded() const;
	bool IsLevelVisible() const;
	bool IsStreamingStatePending() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreaming">();
	}
	static class ULevelStreaming* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreaming>();
	}
};
#pragma pack(pop)
static_assert(alignof(ULevelStreaming) == 0x112EAE80, "Wrong alignment on ULevelStreaming");
static_assert(sizeof(ULevelStreaming) == 0x112EAE80, "Wrong size on ULevelStreaming");
static_assert(offsetof(ULevelStreaming, PackageName) == 0x000040, "Member 'ULevelStreaming::PackageName' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, WorldAsset) == 0x000048, "Member 'ULevelStreaming::WorldAsset' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, PackageNameToLoad) == 0x000068, "Member 'ULevelStreaming::PackageNameToLoad' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, LODPackageNames) == 0x000070, "Member 'ULevelStreaming::LODPackageNames' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, LevelTransform) == 0x000090, "Member 'ULevelStreaming::LevelTransform' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, LevelLODIndex) == 0x0000C4, "Member 'ULevelStreaming::LevelLODIndex' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, DrawColor) == 0x0000CC, "Member 'ULevelStreaming::DrawColor' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, LevelColor) == 0x0000D0, "Member 'ULevelStreaming::LevelColor' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, EditorStreamingVolumes) == 0x0000E0, "Member 'ULevelStreaming::EditorStreamingVolumes' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, MinTimeBetweenVolumeUnloadRequests) == 0x0000F0, "Member 'ULevelStreaming::MinTimeBetweenVolumeUnloadRequests' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, Keywords) == 0x0000F8, "Member 'ULevelStreaming::Keywords' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, OnLevelLoaded) == 0x000108, "Member 'ULevelStreaming::OnLevelLoaded' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, OnLevelUnloaded) == 0x000118, "Member 'ULevelStreaming::OnLevelUnloaded' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, OnLevelShown) == 0x000128, "Member 'ULevelStreaming::OnLevelShown' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, OnLevelHidden) == 0x000138, "Member 'ULevelStreaming::OnLevelHidden' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, LoadedLevel) == 0x000148, "Member 'ULevelStreaming::LoadedLevel' has a wrong offset!");
static_assert(offsetof(ULevelStreaming, PendingUnloadLevel) == 0x000150, "Member 'ULevelStreaming::PendingUnloadLevel' has a wrong offset!");

// Class Engine.DPICustomScalingRule
// 0x0000 (0x0040 - 0x0040)
class UDPICustomScalingRule : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DPICustomScalingRule">();
	}
	static class UDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDPICustomScalingRule>();
	}
};
static_assert(alignof(UDPICustomScalingRule) == 0x000008, "Wrong alignment on UDPICustomScalingRule");
static_assert(sizeof(UDPICustomScalingRule) == 0x000040, "Wrong size on UDPICustomScalingRule");

// Class Engine.MaterialExpressionRound
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionRound final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRound">();
	}
	static class UMaterialExpressionRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRound>();
	}
};
static_assert(alignof(UMaterialExpressionRound) == 0x112F2730, "Wrong alignment on UMaterialExpressionRound");
static_assert(sizeof(UMaterialExpressionRound) == 0x112F2730, "Wrong size on UMaterialExpressionRound");
static_assert(offsetof(UMaterialExpressionRound, Input) == 0x000078, "Member 'UMaterialExpressionRound::Input' has a wrong offset!");

// Class Engine.NavigationQueryFilter
// 0x0020 (0x0060 - 0x0040)
class UNavigationQueryFilter : public UObject
{
public:
	TArray<struct FNavigationFilterArea>          Areas;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FNavigationFilterFlags                 IncludeFlags;                                      // 0x0050(0x0004)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FNavigationFilterFlags                 ExcludeFlags;                                      // 0x0054(0x0004)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter">();
	}
	static class UNavigationQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter>();
	}
};
static_assert(alignof(UNavigationQueryFilter) == 0x000008, "Wrong alignment on UNavigationQueryFilter");
static_assert(sizeof(UNavigationQueryFilter) == 0x000060, "Wrong size on UNavigationQueryFilter");
static_assert(offsetof(UNavigationQueryFilter, Areas) == 0x000040, "Member 'UNavigationQueryFilter::Areas' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter, IncludeFlags) == 0x000050, "Member 'UNavigationQueryFilter::IncludeFlags' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter, ExcludeFlags) == 0x000054, "Member 'UNavigationQueryFilter::ExcludeFlags' has a wrong offset!");

// Class Engine.InterpTrackInstProperty
// 0x0010 (0x0050 - 0x0040)
class UInterpTrackInstProperty : public UInterpTrackInst
{
public:
	class UProperty*                              InterpProperty;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                PropertyOuterObjectInst;                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstProperty">();
	}
	static class UInterpTrackInstProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstProperty>();
	}
};
static_assert(alignof(UInterpTrackInstProperty) == 0x000008, "Wrong alignment on UInterpTrackInstProperty");
static_assert(sizeof(UInterpTrackInstProperty) == 0x000050, "Wrong size on UInterpTrackInstProperty");
static_assert(offsetof(UInterpTrackInstProperty, InterpProperty) == 0x000040, "Member 'UInterpTrackInstProperty::InterpProperty' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstProperty, PropertyOuterObjectInst) == 0x000048, "Member 'UInterpTrackInstProperty::PropertyOuterObjectInst' has a wrong offset!");

// Class Engine.SQEX_InterpTrackInstVector4Prop
// 0x112E92B0 (0x112E9300 - 0x0050)
class USQEX_InterpTrackInstVector4Prop : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               ResetValue;                                        // 0x0060(0x112E9300)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_InterpTrackInstVector4Prop">();
	}
	static class USQEX_InterpTrackInstVector4Prop* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_InterpTrackInstVector4Prop>();
	}
};
static_assert(alignof(USQEX_InterpTrackInstVector4Prop) == 0x112E9300, "Wrong alignment on USQEX_InterpTrackInstVector4Prop");
static_assert(sizeof(USQEX_InterpTrackInstVector4Prop) == 0x112E9300, "Wrong size on USQEX_InterpTrackInstVector4Prop");
static_assert(offsetof(USQEX_InterpTrackInstVector4Prop, ResetValue) == 0x000060, "Member 'USQEX_InterpTrackInstVector4Prop::ResetValue' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Vertex
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleSQEX_Vertex : public UParticleModuleSQEX_LocationBase
{
public:
	class UStaticMesh*                            GenerateMesh;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            VertexColorStaticMesh;                             // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          GenerateSkeletalMesh;                              // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          VertexColorSkeletalMesh;                           // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSameVertex : 1;                                // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoopWhenClearVertexHistory : 1;                   // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EVARTEX_ODER_TYPE                             VartexGenerateType;                                // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bResetVertexNumberList : 1;                        // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 VertexNumberList;                                  // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ESQEX_SPAWN_SOURCE_TYPE                       SourceType;                                        // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bVertexColor : 1;                                  // 0x013C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsParticleAttach : 1;                             // 0x013C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PolygonAreaBlockNumber;                            // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 MeshOffsetPosition;                                // 0x0148(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 MeshOffsetRotation;                                // 0x0198(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 MeshOffsetScale;                                   // 0x01E8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  MorphWeight0;                                      // 0x0238(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  MorphWeight1;                                      // 0x0270(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  MorphWeight2;                                      // 0x02A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x1C];                                     // 0x02E0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalCheckTolerance;                              // 0x02FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawWireframe : 1;                                // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Vertex">();
	}
	static class UParticleModuleSQEX_Vertex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Vertex>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleSQEX_Vertex) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Vertex");
static_assert(sizeof(UParticleModuleSQEX_Vertex) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Vertex");
static_assert(offsetof(UParticleModuleSQEX_Vertex, GenerateMesh) == 0x0000F8, "Member 'UParticleModuleSQEX_Vertex::GenerateMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, VertexColorStaticMesh) == 0x000100, "Member 'UParticleModuleSQEX_Vertex::VertexColorStaticMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, GenerateSkeletalMesh) == 0x000108, "Member 'UParticleModuleSQEX_Vertex::GenerateSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, VertexColorSkeletalMesh) == 0x000110, "Member 'UParticleModuleSQEX_Vertex::VertexColorSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, VartexGenerateType) == 0x00011C, "Member 'UParticleModuleSQEX_Vertex::VartexGenerateType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, VertexNumberList) == 0x000128, "Member 'UParticleModuleSQEX_Vertex::VertexNumberList' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, SourceType) == 0x000138, "Member 'UParticleModuleSQEX_Vertex::SourceType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, PolygonAreaBlockNumber) == 0x000140, "Member 'UParticleModuleSQEX_Vertex::PolygonAreaBlockNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, MeshOffsetPosition) == 0x000148, "Member 'UParticleModuleSQEX_Vertex::MeshOffsetPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, MeshOffsetRotation) == 0x000198, "Member 'UParticleModuleSQEX_Vertex::MeshOffsetRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, MeshOffsetScale) == 0x0001E8, "Member 'UParticleModuleSQEX_Vertex::MeshOffsetScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, MorphWeight0) == 0x000238, "Member 'UParticleModuleSQEX_Vertex::MorphWeight0' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, MorphWeight1) == 0x000270, "Member 'UParticleModuleSQEX_Vertex::MorphWeight1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, MorphWeight2) == 0x0002A8, "Member 'UParticleModuleSQEX_Vertex::MorphWeight2' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Vertex, NormalCheckTolerance) == 0x0002FC, "Member 'UParticleModuleSQEX_Vertex::NormalCheckTolerance' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_VertexLinear
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_VertexLinear final : public UParticleModuleSQEX_Vertex
{
public:
	uint8                                         bIsVertexReverse : 1;                              // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsCirculationMesh : 1;                            // 0x0308(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Interval;                                          // 0x0310(0x0038)(Edit, ExportObject, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_VertexLinear">();
	}
	static class UParticleModuleSQEX_VertexLinear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_VertexLinear>();
	}
};
static_assert(alignof(UParticleModuleSQEX_VertexLinear) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_VertexLinear");
static_assert(sizeof(UParticleModuleSQEX_VertexLinear) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_VertexLinear");
static_assert(offsetof(UParticleModuleSQEX_VertexLinear, Interval) == 0x000310, "Member 'UParticleModuleSQEX_VertexLinear::Interval' has a wrong offset!");

// Class Engine.SoundCue
// 0x0000 (0x1166C9B0 - 0x1166C9B0)
class USoundCue final : public USoundBase
{
public:
	uint8                                         bOverrideAttenuation : 1;                          // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundNode*                             FirstNode;                                         // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundAttenuationSettings              AttenuationOverrides;                              // 0x00D0(0x11487DA0)(Edit, NativeAccessSpecifierPublic)
	float                                         SubtitlePriority;                                  // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0xC];                                      // 0x0204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundCue">();
	}
	static class USoundCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundCue>();
	}
};
static_assert(alignof(USoundCue) == 0x1166C9B0, "Wrong alignment on USoundCue");
static_assert(sizeof(USoundCue) == 0x1166C9B0, "Wrong size on USoundCue");
static_assert(offsetof(USoundCue, FirstNode) == 0x0000C0, "Member 'USoundCue::FirstNode' has a wrong offset!");
static_assert(offsetof(USoundCue, VolumeMultiplier) == 0x0000C8, "Member 'USoundCue::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(USoundCue, PitchMultiplier) == 0x0000CC, "Member 'USoundCue::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(USoundCue, AttenuationOverrides) == 0x0000D0, "Member 'USoundCue::AttenuationOverrides' has a wrong offset!");
static_assert(offsetof(USoundCue, SubtitlePriority) == 0x000200, "Member 'USoundCue::SubtitlePriority' has a wrong offset!");

// Class Engine.SceneCaptureComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) USceneCaptureComponent : public USceneComponent
{
public:
	ESceneCapturePrimitiveRenderMode              PrimitiveRenderMode;                               // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> HiddenComponents;                                  // 0x0420(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         HiddenActors;                                      // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> ShowOnlyComponents;                                // 0x0440(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ShowOnlyActors;                                    // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCaptureEveryFrame;                                // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureOnMovement;                                // 0x0461(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysPersistRenderingState;                      // 0x0462(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_463[0x1];                                      // 0x0463(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LODDistanceFactor;                                 // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxViewDistanceOverride;                           // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureSortPriority;                               // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEngineShowFlagsSetting>        ShowFlagSettings;                                  // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, NativeAccessSpecifierPublic)
	float                                         SqexMinViewDistanceOverride;                       // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSQEXCampRenderMode;                               // 0x0484(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_485[0x13];                                     // 0x0485(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   SqexUpdateAfterCapture;                            // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearHiddenComponents();
	void ClearShowOnlyComponents(class UPrimitiveComponent* InComponent);
	void HideActorComponents(class AActor* InActor);
	void HideComponent(class UPrimitiveComponent* InComponent);
	void RemoveShowOnlyActorComponents(class AActor* InActor);
	void RemoveShowOnlyComponent(class UPrimitiveComponent* InComponent);
	void SetCaptureSortPriority(int32 NewCaptureSortPriority);
	void ShowOnlyActorComponents(class AActor* InActor);
	void ShowOnlyComponent(class UPrimitiveComponent* InComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureComponent">();
	}
	static class USceneCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCaptureComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USceneCaptureComponent) == 0x112E9AF0, "Wrong alignment on USceneCaptureComponent");
static_assert(sizeof(USceneCaptureComponent) == 0x112E9AF0, "Wrong size on USceneCaptureComponent");
static_assert(offsetof(USceneCaptureComponent, PrimitiveRenderMode) == 0x000418, "Member 'USceneCaptureComponent::PrimitiveRenderMode' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, HiddenComponents) == 0x000420, "Member 'USceneCaptureComponent::HiddenComponents' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, HiddenActors) == 0x000430, "Member 'USceneCaptureComponent::HiddenActors' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, ShowOnlyComponents) == 0x000440, "Member 'USceneCaptureComponent::ShowOnlyComponents' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, ShowOnlyActors) == 0x000450, "Member 'USceneCaptureComponent::ShowOnlyActors' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, bCaptureEveryFrame) == 0x000460, "Member 'USceneCaptureComponent::bCaptureEveryFrame' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, bCaptureOnMovement) == 0x000461, "Member 'USceneCaptureComponent::bCaptureOnMovement' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, bAlwaysPersistRenderingState) == 0x000462, "Member 'USceneCaptureComponent::bAlwaysPersistRenderingState' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, LODDistanceFactor) == 0x000464, "Member 'USceneCaptureComponent::LODDistanceFactor' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, MaxViewDistanceOverride) == 0x000468, "Member 'USceneCaptureComponent::MaxViewDistanceOverride' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, CaptureSortPriority) == 0x00046C, "Member 'USceneCaptureComponent::CaptureSortPriority' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, ShowFlagSettings) == 0x000470, "Member 'USceneCaptureComponent::ShowFlagSettings' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, SqexMinViewDistanceOverride) == 0x000480, "Member 'USceneCaptureComponent::SqexMinViewDistanceOverride' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, bSQEXCampRenderMode) == 0x000484, "Member 'USceneCaptureComponent::bSQEXCampRenderMode' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent, SqexUpdateAfterCapture) == 0x000498, "Member 'USceneCaptureComponent::SqexUpdateAfterCapture' has a wrong offset!");

// Class Engine.SceneCaptureComponent2D
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USceneCaptureComponent2D final : public USceneCaptureComponent
{
public:
	ECameraProjectionMode                         ProjectionType;                                    // 0x04B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVAngle;                                          // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoWidth;                                        // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoLODCheck : 1;                                   // 0x04C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4C5[0x3];                                      // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 TextureTarget;                                     // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneCaptureSource                           CaptureSource;                                     // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneCaptureCompositeMode                    CompositeMode;                                     // 0x04D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D2[0xE];                                      // 0x04D2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x04E0(0x112EAE80)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	float                                         PostProcessBlendWeight;                            // 0x0C20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomProjectionMatrix;                        // 0x0C24(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C25[0xB];                                      // 0x0C25(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                CustomProjectionMatrix;                            // 0x0C30(0x0040)(BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bEnableClipPlane;                                  // 0x0C70(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C71[0x3];                                      // 0x0C71(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClipPlaneBase;                                     // 0x0C74(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClipPlaneNormal;                                   // 0x0C80(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCameraCutThisFrame : 1;                           // 0x0C8C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C8D[0x3];                                      // 0x0C8D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	void CaptureScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureComponent2D">();
	}
	static class USceneCaptureComponent2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCaptureComponent2D>();
	}
};
static_assert(alignof(USceneCaptureComponent2D) == 0x112E9AF0, "Wrong alignment on USceneCaptureComponent2D");
static_assert(sizeof(USceneCaptureComponent2D) == 0x112E9AF0, "Wrong size on USceneCaptureComponent2D");
static_assert(offsetof(USceneCaptureComponent2D, ProjectionType) == 0x0004B8, "Member 'USceneCaptureComponent2D::ProjectionType' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, FOVAngle) == 0x0004BC, "Member 'USceneCaptureComponent2D::FOVAngle' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, OrthoWidth) == 0x0004C0, "Member 'USceneCaptureComponent2D::OrthoWidth' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, TextureTarget) == 0x0004C8, "Member 'USceneCaptureComponent2D::TextureTarget' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, CaptureSource) == 0x0004D0, "Member 'USceneCaptureComponent2D::CaptureSource' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, CompositeMode) == 0x0004D1, "Member 'USceneCaptureComponent2D::CompositeMode' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, PostProcessSettings) == 0x0004E0, "Member 'USceneCaptureComponent2D::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, PostProcessBlendWeight) == 0x000C20, "Member 'USceneCaptureComponent2D::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, bUseCustomProjectionMatrix) == 0x000C24, "Member 'USceneCaptureComponent2D::bUseCustomProjectionMatrix' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, CustomProjectionMatrix) == 0x000C30, "Member 'USceneCaptureComponent2D::CustomProjectionMatrix' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, bEnableClipPlane) == 0x000C70, "Member 'USceneCaptureComponent2D::bEnableClipPlane' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, ClipPlaneBase) == 0x000C74, "Member 'USceneCaptureComponent2D::ClipPlaneBase' has a wrong offset!");
static_assert(offsetof(USceneCaptureComponent2D, ClipPlaneNormal) == 0x000C80, "Member 'USceneCaptureComponent2D::ClipPlaneNormal' has a wrong offset!");

// Class Engine.GameMode
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AGameMode : public AGameModeBase
{
public:
	class FName                                   MatchState;                                        // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDelayedStart : 1;                                 // 0x0478(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSpectators;                                     // 0x047C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayers;                                        // 0x0480(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBots;                                           // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRespawnDelay;                                   // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTravellingPlayers;                              // 0x048C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULocalMessage>              EngineMessageClass;                                // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APlayerState*>                   InactivePlayerArray;                               // 0x0498(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InactivePlayerStateLifeSpan;                       // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHandleDedicatedServerReplays;                     // 0x04AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AD[0x3];                                      // 0x04AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortMatch();
	void EndMatch();
	void K2_OnSetMatchState(class FName NewState);
	bool ReadyToEndMatch();
	bool ReadyToStartMatch();
	void RestartGame();
	void Say(const class FString& Msg);
	void SetBandwidthLimit(float AsyncIOBandwidthLimit);
	void StartMatch();

	class FName GetMatchState() const;
	bool HasMatchEnded() const;
	bool IsMatchInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMode">();
	}
	static class AGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameMode>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGameMode) == 0x1EF72E00, "Wrong alignment on AGameMode");
static_assert(sizeof(AGameMode) == 0x1EF72E00, "Wrong size on AGameMode");
static_assert(offsetof(AGameMode, MatchState) == 0x000470, "Member 'AGameMode::MatchState' has a wrong offset!");
static_assert(offsetof(AGameMode, NumSpectators) == 0x00047C, "Member 'AGameMode::NumSpectators' has a wrong offset!");
static_assert(offsetof(AGameMode, NumPlayers) == 0x000480, "Member 'AGameMode::NumPlayers' has a wrong offset!");
static_assert(offsetof(AGameMode, NumBots) == 0x000484, "Member 'AGameMode::NumBots' has a wrong offset!");
static_assert(offsetof(AGameMode, MinRespawnDelay) == 0x000488, "Member 'AGameMode::MinRespawnDelay' has a wrong offset!");
static_assert(offsetof(AGameMode, NumTravellingPlayers) == 0x00048C, "Member 'AGameMode::NumTravellingPlayers' has a wrong offset!");
static_assert(offsetof(AGameMode, EngineMessageClass) == 0x000490, "Member 'AGameMode::EngineMessageClass' has a wrong offset!");
static_assert(offsetof(AGameMode, InactivePlayerArray) == 0x000498, "Member 'AGameMode::InactivePlayerArray' has a wrong offset!");
static_assert(offsetof(AGameMode, InactivePlayerStateLifeSpan) == 0x0004A8, "Member 'AGameMode::InactivePlayerStateLifeSpan' has a wrong offset!");
static_assert(offsetof(AGameMode, bHandleDedicatedServerReplays) == 0x0004AC, "Member 'AGameMode::bHandleDedicatedServerReplays' has a wrong offset!");

// Class Engine.Emitter
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AEmitter : public AActor
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bDestroyOnSystemFinish : 1;                        // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPostUpdateTickGroup : 1;                          // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCurrentlyActive : 1;                              // 0x03E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnParticleSpawn;                                   // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleBurst;                                   // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleDeath;                                   // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleCollide;                                 // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Activate();
	void Deactivate();
	void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
	void OnRep_bCurrentlyActive();
	void SetActorParameter(class FName ParameterName, class AActor* Param);
	void SetColorParameter(class FName ParameterName, const struct FLinearColor& Param);
	void SetFloatParameter(class FName ParameterName, float Param);
	void SetMaterialParameter(class FName ParameterName, class UMaterialInterface* Param);
	void SetTemplate(class UParticleSystem* NewTemplate);
	void SetVectorParameter(class FName ParameterName, const struct FVector& Param);
	void ToggleActive();

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Emitter">();
	}
	static class AEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEmitter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEmitter) == 0x1EF72E00, "Wrong alignment on AEmitter");
static_assert(sizeof(AEmitter) == 0x1EF72E00, "Wrong size on AEmitter");
static_assert(offsetof(AEmitter, ParticleSystemComponent) == 0x0003E0, "Member 'AEmitter::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(AEmitter, OnParticleSpawn) == 0x0003F0, "Member 'AEmitter::OnParticleSpawn' has a wrong offset!");
static_assert(offsetof(AEmitter, OnParticleBurst) == 0x000400, "Member 'AEmitter::OnParticleBurst' has a wrong offset!");
static_assert(offsetof(AEmitter, OnParticleDeath) == 0x000410, "Member 'AEmitter::OnParticleDeath' has a wrong offset!");
static_assert(offsetof(AEmitter, OnParticleCollide) == 0x000420, "Member 'AEmitter::OnParticleCollide' has a wrong offset!");

// Class Engine.EmitterCameraLensEffectBase
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AEmitterCameraLensEffectBase : public AEmitter
{
public:
	class UParticleSystem*                        PS_CameraEffect;                                   // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PS_CameraEffectNonExtremeContent;                  // 0x0438(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCameraManager*                   BaseCamera;                                        // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0450(0x112E9D50)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BaseFOV;                                           // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowMultipleInstances : 1;                       // 0x0484(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetWhenRetriggered : 1;                         // 0x0484(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_485[0x3];                                      // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AEmitterCameraLensEffectBase>> EmittersToTreatAsSame;                             // 0x0488(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DistFromCamera;                                    // 0x0498(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmitterCameraLensEffectBase">();
	}
	static class AEmitterCameraLensEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEmitterCameraLensEffectBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AEmitterCameraLensEffectBase) == 0x1EF72E00, "Wrong alignment on AEmitterCameraLensEffectBase");
static_assert(sizeof(AEmitterCameraLensEffectBase) == 0x1EF72E00, "Wrong size on AEmitterCameraLensEffectBase");
static_assert(offsetof(AEmitterCameraLensEffectBase, PS_CameraEffect) == 0x000430, "Member 'AEmitterCameraLensEffectBase::PS_CameraEffect' has a wrong offset!");
static_assert(offsetof(AEmitterCameraLensEffectBase, PS_CameraEffectNonExtremeContent) == 0x000438, "Member 'AEmitterCameraLensEffectBase::PS_CameraEffectNonExtremeContent' has a wrong offset!");
static_assert(offsetof(AEmitterCameraLensEffectBase, BaseCamera) == 0x000440, "Member 'AEmitterCameraLensEffectBase::BaseCamera' has a wrong offset!");
static_assert(offsetof(AEmitterCameraLensEffectBase, RelativeTransform) == 0x000450, "Member 'AEmitterCameraLensEffectBase::RelativeTransform' has a wrong offset!");
static_assert(offsetof(AEmitterCameraLensEffectBase, BaseFOV) == 0x000480, "Member 'AEmitterCameraLensEffectBase::BaseFOV' has a wrong offset!");
static_assert(offsetof(AEmitterCameraLensEffectBase, EmittersToTreatAsSame) == 0x000488, "Member 'AEmitterCameraLensEffectBase::EmittersToTreatAsSame' has a wrong offset!");
static_assert(offsetof(AEmitterCameraLensEffectBase, DistFromCamera) == 0x000498, "Member 'AEmitterCameraLensEffectBase::DistFromCamera' has a wrong offset!");

// Class Engine.DebugDrawService
// 0x0000 (0x0040 - 0x0040)
class UDebugDrawService final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugDrawService">();
	}
	static class UDebugDrawService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugDrawService>();
	}
};
static_assert(alignof(UDebugDrawService) == 0x000008, "Wrong alignment on UDebugDrawService");
static_assert(sizeof(UDebugDrawService) == 0x000040, "Wrong size on UDebugDrawService");

// Class Engine.NavigationGraphNodeComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UNavigationGraphNodeComponent final : public USceneComponent
{
public:
	struct FNavGraphNode                          Node;                                              // 0x0418(0x0018)(NativeAccessSpecifierPublic)
	class UNavigationGraphNodeComponent*          NextNodeComponent;                                 // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationGraphNodeComponent*          PrevNodeComponent;                                 // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationGraphNodeComponent">();
	}
	static class UNavigationGraphNodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationGraphNodeComponent>();
	}
};
static_assert(alignof(UNavigationGraphNodeComponent) == 0x112E9AF0, "Wrong alignment on UNavigationGraphNodeComponent");
static_assert(sizeof(UNavigationGraphNodeComponent) == 0x112E9AF0, "Wrong size on UNavigationGraphNodeComponent");
static_assert(offsetof(UNavigationGraphNodeComponent, Node) == 0x000418, "Member 'UNavigationGraphNodeComponent::Node' has a wrong offset!");
static_assert(offsetof(UNavigationGraphNodeComponent, NextNodeComponent) == 0x000430, "Member 'UNavigationGraphNodeComponent::NextNodeComponent' has a wrong offset!");
static_assert(offsetof(UNavigationGraphNodeComponent, PrevNodeComponent) == 0x000438, "Member 'UNavigationGraphNodeComponent::PrevNodeComponent' has a wrong offset!");

// Class Engine.TriggerBase
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ATriggerBase : public AActor
{
public:
	class UShapeComponent*                        CollisionComponent;                                // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_bSqexDispWarningThroughCheck;                    // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerBase">();
	}
	static class ATriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATriggerBase) == 0x1EF72E00, "Wrong alignment on ATriggerBase");
static_assert(sizeof(ATriggerBase) == 0x1EF72E00, "Wrong size on ATriggerBase");
static_assert(offsetof(ATriggerBase, CollisionComponent) == 0x0003E0, "Member 'ATriggerBase::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ATriggerBase, M_bSqexDispWarningThroughCheck) == 0x0003E8, "Member 'ATriggerBase::M_bSqexDispWarningThroughCheck' has a wrong offset!");

// Class Engine.TriggerBox
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ATriggerBox : public ATriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerBox">();
	}
	static class ATriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerBox>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATriggerBox) == 0x1EF72E00, "Wrong alignment on ATriggerBox");
static_assert(sizeof(ATriggerBox) == 0x1EF72E00, "Wrong size on ATriggerBox");

// Class Engine.TriggerCapsule
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ATriggerCapsule : public ATriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerCapsule">();
	}
	static class ATriggerCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerCapsule>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATriggerCapsule) == 0x1EF72E00, "Wrong alignment on ATriggerCapsule");
static_assert(sizeof(ATriggerCapsule) == 0x1EF72E00, "Wrong size on ATriggerCapsule");

// Class Engine.PlayerCameraManager
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) APlayerCameraManager : public AActor
{
public:
	class APlayerController*                      PCOwner;                                           // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TransformComponent;                                // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultFOV;                                        // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultOrthoWidth;                                 // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultAspectRatio;                                // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x40];                                     // 0x040C(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SQEXOverride_SceneColorTint;                       // 0x044C(0x112EAE80)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SQEXOverride_SceneColorTintFinalPostColor;         // 0x045C(0x112EAE80)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SQEXOverride_SceneColorTintPostColor;              // 0x046C(0x112EAE80)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_FringeIntensity;                      // 0x047C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_FringeIntensityFinalPostIntensity;    // 0x0480(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_FringeIntensityPostIntensity;         // 0x0484(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_AmbientCubemapIntensity;              // 0x0488(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_AmbientCubemapIntensityFinalPostIntensity; // 0x048C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_AmbientCubemapIntensityPostIntensity; // 0x0490(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_IndirectLightingIntensity;            // 0x0494(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_IndirectLightingIntensityFinalPostIntensity; // 0x0498(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXOverride_IndirectLightingIntensityPostIntensity; // 0x049C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqexMasterLightCoefficient;                        // 0x04A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqexMasterLightBias;                               // 0x04A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexDisableOcclusionCullingWithOneShot;           // 0x04A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexTrgSceneCapture;                              // 0x04A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexCampBackgroundCapture;                        // 0x04AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexSceneCaptureEnableInvGamma;                   // 0x04AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexSmartPhoneCameraCapture;                      // 0x04AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AD[0x303];                                    // 0x04AD(0x0303)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraCacheEntry                      CameraCache;                                       // 0x07B0(0x07B0)(Transient, NativeAccessSpecifierPublic)
	struct FCameraCacheEntry                      LastFrameCameraCache;                              // 0x0F60(0x07B0)(Transient, NativeAccessSpecifierPublic)
	struct FTViewTarget                           ViewTarget;                                        // 0x1710(0x07C0)(Transient, NativeAccessSpecifierPublic)
	struct FTViewTarget                           PendingViewTarget;                                 // 0x1ED0(0x07C0)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2690[0x78];                                    // 0x2690(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCameraModifier*>                ModifierList;                                      // 0x2708(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UCameraModifier>>    DefaultModifiers;                                  // 0x2718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         FreeCamDistance;                                   // 0x2728(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FreeCamOffset;                                     // 0x272C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewTargetOffset;                                  // 0x2738(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2744[0x14];                                    // 0x2744(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEmitterCameraLensEffectBase*>   CameraLensEffects;                                 // 0x2758(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCameraModifier_CameraShake*            CachedCameraShakeMod;                              // 0x2768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraAnimInst*                        AnimInstPool[0x8];                                 // 0x2770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPostProcessSettings>           PostProcessBlendCache;                             // 0x27B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C0[0x10];                                    // 0x27C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCameraAnimInst*>                ActiveAnims;                                       // 0x27D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UCameraAnimInst*>                FreeAnims;                                         // 0x27E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ACameraActor*                           AnimCameraActor;                                   // 0x27F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASQEX_CameraInterest*                   M_CameraInterest;                                  // 0x27F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASQEX_CameraUpVector*                   M_CameraUpVector;                                  // 0x2800(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsOrthographic : 1;                               // 0x2808(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultConstrainAspectRatio : 1;                  // 0x2808(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2808_2 : 3;                                 // 0x2808(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSQEXOverride_SceneColorTint : 1;                  // 0x2808(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXOverride_FringeIntensity : 1;                 // 0x2808(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexDisableMasterLightCoefficient : 1;            // 0x2808(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXOverride_ScreenBlur : 1;                      // 0x2809(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXOverride_MasterLight : 1;                     // 0x2809(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXOverride_RadialBlur : 1;                      // 0x2809(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXOverride_BloomRadialBlur : 1;                 // 0x2809(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXOverride_VFXBlur : 1;                         // 0x2809(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2809_5 : 2;                                 // 0x2809(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUseClientSideCameraUpdates : 1;                   // 0x2809(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_280A_0 : 2;                                 // 0x280A(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bGameCameraCutThisFrame : 1;                       // 0x280A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_280B[0x1];                                     // 0x280B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewPitchMin;                                      // 0x280C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x2810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYawMin;                                        // 0x2814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYawMax;                                        // 0x2818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewRollMin;                                       // 0x281C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewRollMax;                                       // 0x2820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2824[0xC];                                     // 0x2824(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AEmitterCameraLensEffectBase* AddCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass, bool In_OverrideAllowMultipleInstances);
	class UCameraModifier* AddNewCameraModifier(TSubclassOf<class UCameraModifier> ModifierClass);
	bool BlueprintUpdateCamera(class AActor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV);
	void ClearCameraLensEffects();
	class UCameraModifier* FindCameraModifierByClass(TSubclassOf<class UCameraModifier> ModifierClass);
	void OnPhotographyMultiPartCaptureEnd();
	void OnPhotographyMultiPartCaptureStart();
	void OnPhotographySessionEnd();
	void OnPhotographySessionStart();
	void PhotographyCameraModify(const struct FVector& NewCameraLocation, const struct FVector& PreviousCameraLocation, const struct FVector& OriginalCameraLocation, struct FVector* ResultCameraLocation);
	class UCameraAnimInst* PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot);
	class UCameraShake* PlayCameraShake(TSubclassOf<class UCameraShake> ShakeClass, float Scale, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot, float In_OscillationDuration);
	void RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter);
	bool RemoveCameraModifier(class UCameraModifier* ModifierToRemove);
	void SetManualCameraFade(float InFadeAmount, const struct FLinearColor& Color, bool bInFadeAudio);
	void StartCameraFade(float FromAlpha, float ToAlpha, float Duration, const struct FLinearColor& Color, bool bShouldFadeAudio, bool bHoldWhenFinished);
	void StopAllCameraAnims(bool bImmediate);
	void StopAllCameraShakes(bool bImmediately, float ShakeFadeTime);
	void StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate);
	void StopAllInstancesOfCameraShake(TSubclassOf<class UCameraShake> Shake, bool bImmediately);
	void StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate);
	void StopCameraFade();
	void StopCameraShake(class UCameraShake* ShakeInstance, bool bImmediately);

	struct FVector GetCameraLocation() const;
	struct FRotator GetCameraRotation() const;
	float GetFOVAngle() const;
	class APlayerController* GetOwningPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraManager">();
	}
	static class APlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCameraManager>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerCameraManager) == 0x1EF72E00, "Wrong alignment on APlayerCameraManager");
static_assert(sizeof(APlayerCameraManager) == 0x1EF72E00, "Wrong size on APlayerCameraManager");
static_assert(offsetof(APlayerCameraManager, PCOwner) == 0x0003E0, "Member 'APlayerCameraManager::PCOwner' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, TransformComponent) == 0x0003E8, "Member 'APlayerCameraManager::TransformComponent' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, DefaultFOV) == 0x0003F8, "Member 'APlayerCameraManager::DefaultFOV' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, DefaultOrthoWidth) == 0x000400, "Member 'APlayerCameraManager::DefaultOrthoWidth' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, DefaultAspectRatio) == 0x000408, "Member 'APlayerCameraManager::DefaultAspectRatio' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_SceneColorTint) == 0x00044C, "Member 'APlayerCameraManager::SQEXOverride_SceneColorTint' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_SceneColorTintFinalPostColor) == 0x00045C, "Member 'APlayerCameraManager::SQEXOverride_SceneColorTintFinalPostColor' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_SceneColorTintPostColor) == 0x00046C, "Member 'APlayerCameraManager::SQEXOverride_SceneColorTintPostColor' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_FringeIntensity) == 0x00047C, "Member 'APlayerCameraManager::SQEXOverride_FringeIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_FringeIntensityFinalPostIntensity) == 0x000480, "Member 'APlayerCameraManager::SQEXOverride_FringeIntensityFinalPostIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_FringeIntensityPostIntensity) == 0x000484, "Member 'APlayerCameraManager::SQEXOverride_FringeIntensityPostIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_AmbientCubemapIntensity) == 0x000488, "Member 'APlayerCameraManager::SQEXOverride_AmbientCubemapIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_AmbientCubemapIntensityFinalPostIntensity) == 0x00048C, "Member 'APlayerCameraManager::SQEXOverride_AmbientCubemapIntensityFinalPostIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_AmbientCubemapIntensityPostIntensity) == 0x000490, "Member 'APlayerCameraManager::SQEXOverride_AmbientCubemapIntensityPostIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_IndirectLightingIntensity) == 0x000494, "Member 'APlayerCameraManager::SQEXOverride_IndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_IndirectLightingIntensityFinalPostIntensity) == 0x000498, "Member 'APlayerCameraManager::SQEXOverride_IndirectLightingIntensityFinalPostIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SQEXOverride_IndirectLightingIntensityPostIntensity) == 0x00049C, "Member 'APlayerCameraManager::SQEXOverride_IndirectLightingIntensityPostIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SqexMasterLightCoefficient) == 0x0004A0, "Member 'APlayerCameraManager::SqexMasterLightCoefficient' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, SqexMasterLightBias) == 0x0004A4, "Member 'APlayerCameraManager::SqexMasterLightBias' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, bSqexDisableOcclusionCullingWithOneShot) == 0x0004A8, "Member 'APlayerCameraManager::bSqexDisableOcclusionCullingWithOneShot' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, bSqexTrgSceneCapture) == 0x0004A9, "Member 'APlayerCameraManager::bSqexTrgSceneCapture' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, bSqexCampBackgroundCapture) == 0x0004AA, "Member 'APlayerCameraManager::bSqexCampBackgroundCapture' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, bSqexSceneCaptureEnableInvGamma) == 0x0004AB, "Member 'APlayerCameraManager::bSqexSceneCaptureEnableInvGamma' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, bSqexSmartPhoneCameraCapture) == 0x0004AC, "Member 'APlayerCameraManager::bSqexSmartPhoneCameraCapture' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, CameraCache) == 0x0007B0, "Member 'APlayerCameraManager::CameraCache' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, LastFrameCameraCache) == 0x000F60, "Member 'APlayerCameraManager::LastFrameCameraCache' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewTarget) == 0x001710, "Member 'APlayerCameraManager::ViewTarget' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, PendingViewTarget) == 0x001ED0, "Member 'APlayerCameraManager::PendingViewTarget' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ModifierList) == 0x002708, "Member 'APlayerCameraManager::ModifierList' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, DefaultModifiers) == 0x002718, "Member 'APlayerCameraManager::DefaultModifiers' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, FreeCamDistance) == 0x002728, "Member 'APlayerCameraManager::FreeCamDistance' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, FreeCamOffset) == 0x00272C, "Member 'APlayerCameraManager::FreeCamOffset' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewTargetOffset) == 0x002738, "Member 'APlayerCameraManager::ViewTargetOffset' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, CameraLensEffects) == 0x002758, "Member 'APlayerCameraManager::CameraLensEffects' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, CachedCameraShakeMod) == 0x002768, "Member 'APlayerCameraManager::CachedCameraShakeMod' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, AnimInstPool) == 0x002770, "Member 'APlayerCameraManager::AnimInstPool' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, PostProcessBlendCache) == 0x0027B0, "Member 'APlayerCameraManager::PostProcessBlendCache' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ActiveAnims) == 0x0027D0, "Member 'APlayerCameraManager::ActiveAnims' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, FreeAnims) == 0x0027E0, "Member 'APlayerCameraManager::FreeAnims' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, AnimCameraActor) == 0x0027F0, "Member 'APlayerCameraManager::AnimCameraActor' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, M_CameraInterest) == 0x0027F8, "Member 'APlayerCameraManager::M_CameraInterest' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, M_CameraUpVector) == 0x002800, "Member 'APlayerCameraManager::M_CameraUpVector' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewPitchMin) == 0x00280C, "Member 'APlayerCameraManager::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewPitchMax) == 0x002810, "Member 'APlayerCameraManager::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewYawMin) == 0x002814, "Member 'APlayerCameraManager::ViewYawMin' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewYawMax) == 0x002818, "Member 'APlayerCameraManager::ViewYawMax' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewRollMin) == 0x00281C, "Member 'APlayerCameraManager::ViewRollMin' has a wrong offset!");
static_assert(offsetof(APlayerCameraManager, ViewRollMax) == 0x002820, "Member 'APlayerCameraManager::ViewRollMax' has a wrong offset!");

// Class Engine.TriggerSphere
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ATriggerSphere : public ATriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerSphere">();
	}
	static class ATriggerSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerSphere>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATriggerSphere) == 0x1EF72E00, "Wrong alignment on ATriggerSphere");
static_assert(sizeof(ATriggerSphere) == 0x1EF72E00, "Wrong size on ATriggerSphere");

// Class Engine.ReporterBase
// 0x0008 (0x0048 - 0x0040)
class UReporterBase : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReporterBase">();
	}
	static class UReporterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReporterBase>();
	}
};
static_assert(alignof(UReporterBase) == 0x000008, "Wrong alignment on UReporterBase");
static_assert(sizeof(UReporterBase) == 0x000048, "Wrong size on UReporterBase");

// Class Engine.BlueprintPlatformLibrary
// 0x0000 (0x0040 - 0x0040)
class UBlueprintPlatformLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelLocalNotification(const class FString& ActivationEvent);
	static void ClearAllLocalNotifications();
	static void GetLaunchNotification(bool* NotificationLaunchedApp, class FString* ActivationEvent, int32* FireDate);
	static void ScheduleLocalNotificationAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const class FText& Title, const class FText& Body, const class FText& Action, const class FString& ActivationEvent);
	static void ScheduleLocalNotificationBadgeAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const class FString& ActivationEvent);
	static void ScheduleLocalNotificationBadgeFromNow(int32 InSecondsFromNow, const class FString& ActivationEvent);
	static void ScheduleLocalNotificationFromNow(int32 InSecondsFromNow, const class FText& Title, const class FText& Body, const class FText& Action, const class FString& ActivationEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintPlatformLibrary">();
	}
	static class UBlueprintPlatformLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintPlatformLibrary>();
	}
};
static_assert(alignof(UBlueprintPlatformLibrary) == 0x000008, "Wrong alignment on UBlueprintPlatformLibrary");
static_assert(sizeof(UBlueprintPlatformLibrary) == 0x000040, "Wrong size on UBlueprintPlatformLibrary");

// Class Engine.Engine
// 0x11637710 (0x11637750 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x11637750) UEngine : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  TinyFont;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  TinyFontName;                                      // 0x0050(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  SmallFont;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  SmallFontName;                                     // 0x0068(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  MediumFont;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  MediumFontName;                                    // 0x0080(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  LargeFont;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  LargeFontName;                                     // 0x0098(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  SubtitleFont;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  SubtitleFontName;                                  // 0x00B0(0x0010)(Edit, Config, GlobalConfig, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFont*>                          AdditionalFonts;                                   // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFont*                                  DebugMessageFont;                                  // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  DebugMessageFontName;                              // 0x00D8(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  TinyFontM;                                         // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  TinyFontMName;                                     // 0x00F0(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AdditionalFontNames;                               // 0x0110(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UConsole>                   ConsoleClass;                                      // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  ConsoleClassName;                                  // 0x0128(0x003A)(Edit, Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameViewportClient>        GameViewportClientClass;                           // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  GameViewportClientClassName;                       // 0x0140(0x003A)(Edit, Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	TSubclassOf<class ULocalPlayer>               LocalPlayerClass;                                  // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  LocalPlayerClassName;                              // 0x0158(0x003A)(Edit, Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	TSubclassOf<class AWorldSettings>             WorldSettingsClass;                                // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  WorldSettingsClassName;                            // 0x0170(0x003A)(Edit, Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	struct FStringClassReference                  NavigationSystemClassName;                         // 0x0180(0x003A)(Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationSystem>          NavigationSystemClass;                             // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  AvoidanceManagerClassName;                         // 0x0198(0x003A)(Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	TSubclassOf<class UAvoidanceManager>          AvoidanceManagerClass;                             // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPhysicsCollisionHandler>   PhysicsCollisionHandlerClass;                      // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  PhysicsCollisionHandlerClassName;                  // 0x01B8(0x003A)(Edit, Config, GlobalConfig, NoClear, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FStringClassReference                  GameUserSettingsClassName;                         // 0x01C8(0x003A)(Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameUserSettings>          GameUserSettingsClass;                             // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  AIControllerClassName;                             // 0x01E0(0x003A)(Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	class UGameUserSettings*                      GameUserSettings;                                  // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALevelScriptActor>          LevelScriptActorClass;                             // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  LevelScriptActorClassName;                         // 0x0200(0x003A)(Edit, Config, GlobalConfig, NoClear, NativeAccessSpecifierPublic)
	struct FStringClassReference                  DefaultBlueprintBaseClassName;                     // 0x0210(0x003A)(Edit, Config, GlobalConfig, NoClear, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FStringClassReference                  GameSingletonClassName;                            // 0x0220(0x003A)(Edit, Config, GlobalConfig, NoClear, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UObject*                                GameSingleton;                                     // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  AssetManagerClassName;                             // 0x0238(0x003A)(Edit, Config, GlobalConfig, NoClear, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UAssetManager*                          AssetManager;                                      // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayOnConsoleSaveDir;                              // 0x0250(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultTexture;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultTextureName;                                // 0x0268(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               DefaultDiffuseTexture;                             // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultDiffuseTextureName;                         // 0x0280(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultBSPVertexTexture;                           // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultBSPVertexTextureName;                       // 0x0298(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HighFrequencyNoiseTexture;                         // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  HighFrequencyNoiseTextureName;                     // 0x02B0(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultBokehTexture;                               // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultBokehTextureName;                           // 0x02C8(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultBloomKernelTexture;                         // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  SqexDefaultHDRLutTextureName;                      // 0x02E0(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SqexDefaultHDRLutTexture;                          // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultBloomKernelTextureName;                     // 0x02F8(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 SqexSceneCaptureRenderTargetTexture;               // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  SqexSceneCaptureRenderTargetTextureName;           // 0x0310(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x28];                                     // 0x0320(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 SqexTempTexture;                                   // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  SqexTempTextureName;                               // 0x0350(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              WireframeMaterial;                                 // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WireframeMaterialName;                             // 0x0368(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              DebugMeshMaterial;                                 // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DebugMeshMaterialName;                             // 0x0380(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              LevelColorationLitMaterial;                        // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelColorationLitMaterialName;                    // 0x0398(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              LevelColorationUnlitMaterial;                      // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelColorationUnlitMaterialName;                  // 0x03B0(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              LightingTexelDensityMaterial;                      // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LightingTexelDensityName;                          // 0x03C8(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ShadedLevelColorationLitMaterial;                  // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShadedLevelColorationLitMaterialName;              // 0x03E0(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ShadedLevelColorationUnlitMaterial;                // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              SqexCollisionErrCheckMaterial;                     // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              SqexSurfaceTypeMaterial;                           // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              SqexAttributeMaterial;                             // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              SqexVolumeDrawMaterial;                            // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShadedLevelColorationUnlitMaterialName;            // 0x0418(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SqexCollisionErrMaterialName;                      // 0x0428(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SqexSurfaceTypeMaterialName;                       // 0x0438(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SqexAttributeMaterialName;                         // 0x0448(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SqexVolumeDrawMaterialName;                        // 0x0458(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              RemoveSurfaceMaterial;                             // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  RemoveSurfaceMaterialName;                         // 0x0470(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              VertexColorMaterial;                               // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VertexColorMaterialName;                           // 0x0488(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              VertexColorViewModeMaterial_ColorOnly;             // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VertexColorViewModeMaterialName_ColorOnly;         // 0x04A0(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              VertexColorViewModeMaterial_AlphaAsColor;          // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VertexColorViewModeMaterialName_AlphaAsColor;      // 0x04B8(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              VertexColorViewModeMaterial_RedOnly;               // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VertexColorViewModeMaterialName_RedOnly;           // 0x04D0(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              VertexColorViewModeMaterial_GreenOnly;             // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VertexColorViewModeMaterialName_GreenOnly;         // 0x04E8(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              VertexColorViewModeMaterial_BlueOnly;              // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VertexColorViewModeMaterialName_BlueOnly;          // 0x0500(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DebugEditorMaterialName;                           // 0x0510(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ConstraintLimitMaterial;                           // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialX;                          // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialXAxis;                      // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialY;                          // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialYAxis;                      // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialZ;                          // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialZAxis;                      // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ConstraintLimitMaterialPrismatic;                  // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              InvalidLightmapSettingsMaterial;                   // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  InvalidLightmapSettingsMaterialName;               // 0x0568(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              PreviewShadowsIndicatorMaterial;                   // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  PreviewShadowsIndicatorMaterialName;               // 0x0580(0x0010)(Edit, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ArrowMaterial;                                     // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  ArrowMaterialName;                                 // 0x0598(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightingOnlyBrightness;                            // 0x05A8(0x112EAE80)(Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   ShaderComplexityColors;                            // 0x05B8(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   QuadComplexityColors;                              // 0x05C8(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   LightComplexityColors;                             // 0x05D8(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   StationaryLightOverlapColors;                      // 0x05E8(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   LODColorationColors;                               // 0x05F8(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   HLODColorationColors;                              // 0x0608(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   StreamingAccuracyColors;                           // 0x0618(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	float                                         MaxPixelShaderAdditiveComplexityCount;             // 0x0628(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxES2PixelShaderAdditiveComplexityCount;          // 0x062C(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLightMapDensity;                                // 0x0630(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealLightMapDensity;                              // 0x0634(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLightMapDensity;                                // 0x0638(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRenderLightMapDensityGrayscale : 1;               // 0x063C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RenderLightMapDensityGrayscaleScale;               // 0x0640(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RenderLightMapDensityColorScale;                   // 0x0644(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightMapDensityVertexMappedColor;                  // 0x0648(0x112EAE80)(Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightMapDensitySelectedColor;                      // 0x0658(0x112EAE80)(Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStatColorMapping>              StatColorMappings;                                 // 0x0668(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      DefaultPhysMaterial;                               // 0x0678(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultPhysMaterialName;                           // 0x0680(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      SQEX_DefaultOceanPhysMaterial;                     // 0x0690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  SQEX_DefaultOceanPhysMaterialName;                 // 0x0698(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      SQEX_OverridePhysMaterialWallClimb;                // 0x06A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  SQEX_OverridePhysMaterialWallClimbName;            // 0x06B0(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameNameRedirect>              ActiveGameNameRedirects;                           // 0x06C0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FClassRedirect>                 ActiveClassRedirects;                              // 0x06D0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FPluginRedirect>                ActivePluginRedirects;                             // 0x06E0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FStructRedirect>                ActiveStructRedirects;                             // 0x06F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class UTexture2D*                             PreIntegratedSkinBRDFTexture;                      // 0x0700(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  PreIntegratedSkinBRDFTextureName;                  // 0x0708(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MiniFontTexture;                                   // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  MiniFontTextureName;                               // 0x0720(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               WeightMapPlaceholderTexture;                       // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  WeightMapPlaceholderTextureName;                   // 0x0738(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LightMapDensityTexture;                            // 0x0748(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  LightMapDensityTextureName;                        // 0x0750(0x0010)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_760[0x8];                                      // 0x0760(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameViewportClient*                    GameViewport;                                      // 0x0768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         DeferredCommands;                                  // 0x0770(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TickCycles;                                        // 0x0780(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameCycles;                                        // 0x0784(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClientCycles;                                      // 0x0788(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearClipPlane;                                     // 0x078C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHardwareSurveyEnabled : 1;                        // 0x0790(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSubtitlesEnabled : 1;                             // 0x0790(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSubtitlesForcedOff : 1;                           // 0x0790(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_791[0x3];                                      // 0x0791(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaximumLoopIterationCount;                         // 0x0794(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanBlueprintsTickByDefault : 1;                   // 0x0798(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOptimizeAnimBlueprintMemberVariableAccess : 1;    // 0x0798(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowMultiThreadedAnimationUpdate : 1;            // 0x0798(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableEditorPSysRealtimeLOD : 1;                  // 0x0798(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_798_4 : 1;                                  // 0x0798(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSmoothFrameRate : 1;                              // 0x0798(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFixedFrameRate : 1;                            // 0x0798(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_799[0x3];                                      // 0x0799(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedFrameRate;                                    // 0x079C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            SmoothedFrameRateRange;                            // 0x07A0(0x112EFEC0)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCheckForMultiplePawnsSpawnedInAFrame : 1;         // 0x07B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7B1[0x3];                                      // 0x07B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPawnsAllowedToBeSpawnedInAFrame;                // 0x07B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShouldGenerateLowQualityLightmaps : 1;            // 0x07B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, GlobalConfig, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7B9[0x3];                                      // 0x07B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 C_WorldBox;                                        // 0x07BC(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_BrushWire;                                       // 0x07C0(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_AddWire;                                         // 0x07C4(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_SubtractWire;                                    // 0x07C8(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_SemiSolidWire;                                   // 0x07CC(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_NonSolidWire;                                    // 0x07D0(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_WireBackground;                                  // 0x07D4(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_ScaleBoxHi;                                      // 0x07D8(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_VolumeCollision;                                 // 0x07DC(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_BSPCollision;                                    // 0x07E0(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_OrthoBackground;                                 // 0x07E4(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_Volume;                                          // 0x07E8(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 C_BrushShape;                                      // 0x07EC(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StreamingDistanceFactor;                           // 0x07F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectoryPath                         GameScreenshotSaveDirectory;                       // 0x07F8(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	ETransitionType                               TransitionType;                                    // 0x0808(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_809[0x7];                                      // 0x0809(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TransitionDescription;                             // 0x0810(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransitionGameMode;                                // 0x0820(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshLODRange;                                      // 0x0830(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowMatureLanguage : 1;                          // 0x0834(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_835[0x3];                                      // 0x0835(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraRotationThreshold;                           // 0x0838(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraTranslationThreshold;                        // 0x083C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimitiveProbablyVisibleTime;                      // 0x0840(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOcclusionPixelsFraction;                        // 0x0844(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPauseOnLossOfFocus : 1;                           // 0x0848(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_849[0x3];                                      // 0x0849(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxParticleResize;                                 // 0x084C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxParticleResizeWarn;                             // 0x0850(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_854[0x4];                                      // 0x0854(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDropNoteInfo>                  PendingDroppedNotes;                               // 0x0858(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FRigidBodyErrorCorrection              PhysicErrorCorrection;                             // 0x0868(0x11637750)(Config, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NetClientTicksPerSecond;                           // 0x0884(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayGamma;                                      // 0x0888(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredFrameRate;                               // 0x088C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEX_bIsForceDisableCutSceneFPS : 1;               // 0x0890(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_891[0x3];                                      // 0x0891(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SQEX_EventCutSceneMaxFPS;                          // 0x0894(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0x4];                                      // 0x0898(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultSelectedMaterialColor;                      // 0x089C(0x112EAE80)(Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SelectedMaterialColor;                             // 0x08AC(0x112EAE80)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SelectionOutlineColor;                             // 0x08BC(0x112EAE80)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SubduedSelectionOutlineColor;                      // 0x08CC(0x112EAE80)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SelectedMaterialColorOverride;                     // 0x08DC(0x112EAE80)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOverridingSelectedColor;                        // 0x08EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8ED[0x3];                                      // 0x08ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableOnScreenDebugMessages : 1;                  // 0x08F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableOnScreenDebugMessagesDisplay : 1;           // 0x08F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuppressMapWarnings : 1;                          // 0x08F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableAILogging : 1;                             // 0x08F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8F1[0x3];                                      // 0x08F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        bEnableVisualLogRecordingOnStart;                  // 0x08F4(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F8[0x4];                                      // 0x08F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenSaverInhibitorSemaphore;                     // 0x08FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bLockReadOnlyLevels : 1;                           // 0x0900(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_901[0x7];                                      // 0x0901(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ParticleEventManagerClassPath;                     // 0x0908(0x0010)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_918[0x10];                                     // 0x0918(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelectionHighlightIntensity;                       // 0x0928(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionMeshSectionHighlightIntensity;            // 0x092C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BSPSelectionHighlightIntensity;                    // 0x0930(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverHighlightIntensity;                           // 0x0934(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionHighlightIntensityBillboards;             // 0x0938(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93C[0x3D4];                                    // 0x093C(0x03D4)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNetDriverDefinition>           NetDriverDefinitions;                              // 0x0D10(0x0010)(ZeroConstructor, Transient, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         ServerActors;                                      // 0x0D20(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         RuntimeServerActors;                               // 0x0D30(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bStartedLoadMapMovie : 1;                          // 0x0D40(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D41[0x17];                                     // 0x0D41(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NextWorldContextHandle;                            // 0x0D58(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5C[0xCC];                                     // 0x0D5C(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEngine* GetEngine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Engine">();
	}
	static class UEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngine>();
	}
};
#pragma pack(pop)
static_assert(alignof(UEngine) == 0x11637750, "Wrong alignment on UEngine");
static_assert(sizeof(UEngine) == 0x11637750, "Wrong size on UEngine");
static_assert(offsetof(UEngine, TinyFont) == 0x000048, "Member 'UEngine::TinyFont' has a wrong offset!");
static_assert(offsetof(UEngine, TinyFontName) == 0x000050, "Member 'UEngine::TinyFontName' has a wrong offset!");
static_assert(offsetof(UEngine, SmallFont) == 0x000060, "Member 'UEngine::SmallFont' has a wrong offset!");
static_assert(offsetof(UEngine, SmallFontName) == 0x000068, "Member 'UEngine::SmallFontName' has a wrong offset!");
static_assert(offsetof(UEngine, MediumFont) == 0x000078, "Member 'UEngine::MediumFont' has a wrong offset!");
static_assert(offsetof(UEngine, MediumFontName) == 0x000080, "Member 'UEngine::MediumFontName' has a wrong offset!");
static_assert(offsetof(UEngine, LargeFont) == 0x000090, "Member 'UEngine::LargeFont' has a wrong offset!");
static_assert(offsetof(UEngine, LargeFontName) == 0x000098, "Member 'UEngine::LargeFontName' has a wrong offset!");
static_assert(offsetof(UEngine, SubtitleFont) == 0x0000A8, "Member 'UEngine::SubtitleFont' has a wrong offset!");
static_assert(offsetof(UEngine, SubtitleFontName) == 0x0000B0, "Member 'UEngine::SubtitleFontName' has a wrong offset!");
static_assert(offsetof(UEngine, AdditionalFonts) == 0x0000C0, "Member 'UEngine::AdditionalFonts' has a wrong offset!");
static_assert(offsetof(UEngine, DebugMessageFont) == 0x0000D0, "Member 'UEngine::DebugMessageFont' has a wrong offset!");
static_assert(offsetof(UEngine, DebugMessageFontName) == 0x0000D8, "Member 'UEngine::DebugMessageFontName' has a wrong offset!");
static_assert(offsetof(UEngine, TinyFontM) == 0x0000E8, "Member 'UEngine::TinyFontM' has a wrong offset!");
static_assert(offsetof(UEngine, TinyFontMName) == 0x0000F0, "Member 'UEngine::TinyFontMName' has a wrong offset!");
static_assert(offsetof(UEngine, AdditionalFontNames) == 0x000110, "Member 'UEngine::AdditionalFontNames' has a wrong offset!");
static_assert(offsetof(UEngine, ConsoleClass) == 0x000120, "Member 'UEngine::ConsoleClass' has a wrong offset!");
static_assert(offsetof(UEngine, ConsoleClassName) == 0x000128, "Member 'UEngine::ConsoleClassName' has a wrong offset!");
static_assert(offsetof(UEngine, GameViewportClientClass) == 0x000138, "Member 'UEngine::GameViewportClientClass' has a wrong offset!");
static_assert(offsetof(UEngine, GameViewportClientClassName) == 0x000140, "Member 'UEngine::GameViewportClientClassName' has a wrong offset!");
static_assert(offsetof(UEngine, LocalPlayerClass) == 0x000150, "Member 'UEngine::LocalPlayerClass' has a wrong offset!");
static_assert(offsetof(UEngine, LocalPlayerClassName) == 0x000158, "Member 'UEngine::LocalPlayerClassName' has a wrong offset!");
static_assert(offsetof(UEngine, WorldSettingsClass) == 0x000168, "Member 'UEngine::WorldSettingsClass' has a wrong offset!");
static_assert(offsetof(UEngine, WorldSettingsClassName) == 0x000170, "Member 'UEngine::WorldSettingsClassName' has a wrong offset!");
static_assert(offsetof(UEngine, NavigationSystemClassName) == 0x000180, "Member 'UEngine::NavigationSystemClassName' has a wrong offset!");
static_assert(offsetof(UEngine, NavigationSystemClass) == 0x000190, "Member 'UEngine::NavigationSystemClass' has a wrong offset!");
static_assert(offsetof(UEngine, AvoidanceManagerClassName) == 0x000198, "Member 'UEngine::AvoidanceManagerClassName' has a wrong offset!");
static_assert(offsetof(UEngine, AvoidanceManagerClass) == 0x0001A8, "Member 'UEngine::AvoidanceManagerClass' has a wrong offset!");
static_assert(offsetof(UEngine, PhysicsCollisionHandlerClass) == 0x0001B0, "Member 'UEngine::PhysicsCollisionHandlerClass' has a wrong offset!");
static_assert(offsetof(UEngine, PhysicsCollisionHandlerClassName) == 0x0001B8, "Member 'UEngine::PhysicsCollisionHandlerClassName' has a wrong offset!");
static_assert(offsetof(UEngine, GameUserSettingsClassName) == 0x0001C8, "Member 'UEngine::GameUserSettingsClassName' has a wrong offset!");
static_assert(offsetof(UEngine, GameUserSettingsClass) == 0x0001D8, "Member 'UEngine::GameUserSettingsClass' has a wrong offset!");
static_assert(offsetof(UEngine, AIControllerClassName) == 0x0001E0, "Member 'UEngine::AIControllerClassName' has a wrong offset!");
static_assert(offsetof(UEngine, GameUserSettings) == 0x0001F0, "Member 'UEngine::GameUserSettings' has a wrong offset!");
static_assert(offsetof(UEngine, LevelScriptActorClass) == 0x0001F8, "Member 'UEngine::LevelScriptActorClass' has a wrong offset!");
static_assert(offsetof(UEngine, LevelScriptActorClassName) == 0x000200, "Member 'UEngine::LevelScriptActorClassName' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBlueprintBaseClassName) == 0x000210, "Member 'UEngine::DefaultBlueprintBaseClassName' has a wrong offset!");
static_assert(offsetof(UEngine, GameSingletonClassName) == 0x000220, "Member 'UEngine::GameSingletonClassName' has a wrong offset!");
static_assert(offsetof(UEngine, GameSingleton) == 0x000230, "Member 'UEngine::GameSingleton' has a wrong offset!");
static_assert(offsetof(UEngine, AssetManagerClassName) == 0x000238, "Member 'UEngine::AssetManagerClassName' has a wrong offset!");
static_assert(offsetof(UEngine, AssetManager) == 0x000248, "Member 'UEngine::AssetManager' has a wrong offset!");
static_assert(offsetof(UEngine, PlayOnConsoleSaveDir) == 0x000250, "Member 'UEngine::PlayOnConsoleSaveDir' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultTexture) == 0x000260, "Member 'UEngine::DefaultTexture' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultTextureName) == 0x000268, "Member 'UEngine::DefaultTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultDiffuseTexture) == 0x000278, "Member 'UEngine::DefaultDiffuseTexture' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultDiffuseTextureName) == 0x000280, "Member 'UEngine::DefaultDiffuseTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBSPVertexTexture) == 0x000290, "Member 'UEngine::DefaultBSPVertexTexture' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBSPVertexTextureName) == 0x000298, "Member 'UEngine::DefaultBSPVertexTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, HighFrequencyNoiseTexture) == 0x0002A8, "Member 'UEngine::HighFrequencyNoiseTexture' has a wrong offset!");
static_assert(offsetof(UEngine, HighFrequencyNoiseTextureName) == 0x0002B0, "Member 'UEngine::HighFrequencyNoiseTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBokehTexture) == 0x0002C0, "Member 'UEngine::DefaultBokehTexture' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBokehTextureName) == 0x0002C8, "Member 'UEngine::DefaultBokehTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBloomKernelTexture) == 0x0002D8, "Member 'UEngine::DefaultBloomKernelTexture' has a wrong offset!");
static_assert(offsetof(UEngine, SqexDefaultHDRLutTextureName) == 0x0002E0, "Member 'UEngine::SqexDefaultHDRLutTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexDefaultHDRLutTexture) == 0x0002F0, "Member 'UEngine::SqexDefaultHDRLutTexture' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultBloomKernelTextureName) == 0x0002F8, "Member 'UEngine::DefaultBloomKernelTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexSceneCaptureRenderTargetTexture) == 0x000308, "Member 'UEngine::SqexSceneCaptureRenderTargetTexture' has a wrong offset!");
static_assert(offsetof(UEngine, SqexSceneCaptureRenderTargetTextureName) == 0x000310, "Member 'UEngine::SqexSceneCaptureRenderTargetTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexTempTexture) == 0x000348, "Member 'UEngine::SqexTempTexture' has a wrong offset!");
static_assert(offsetof(UEngine, SqexTempTextureName) == 0x000350, "Member 'UEngine::SqexTempTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, WireframeMaterial) == 0x000360, "Member 'UEngine::WireframeMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, WireframeMaterialName) == 0x000368, "Member 'UEngine::WireframeMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, DebugMeshMaterial) == 0x000378, "Member 'UEngine::DebugMeshMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, DebugMeshMaterialName) == 0x000380, "Member 'UEngine::DebugMeshMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, LevelColorationLitMaterial) == 0x000390, "Member 'UEngine::LevelColorationLitMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, LevelColorationLitMaterialName) == 0x000398, "Member 'UEngine::LevelColorationLitMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, LevelColorationUnlitMaterial) == 0x0003A8, "Member 'UEngine::LevelColorationUnlitMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, LevelColorationUnlitMaterialName) == 0x0003B0, "Member 'UEngine::LevelColorationUnlitMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, LightingTexelDensityMaterial) == 0x0003C0, "Member 'UEngine::LightingTexelDensityMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, LightingTexelDensityName) == 0x0003C8, "Member 'UEngine::LightingTexelDensityName' has a wrong offset!");
static_assert(offsetof(UEngine, ShadedLevelColorationLitMaterial) == 0x0003D8, "Member 'UEngine::ShadedLevelColorationLitMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, ShadedLevelColorationLitMaterialName) == 0x0003E0, "Member 'UEngine::ShadedLevelColorationLitMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, ShadedLevelColorationUnlitMaterial) == 0x0003F0, "Member 'UEngine::ShadedLevelColorationUnlitMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, SqexCollisionErrCheckMaterial) == 0x0003F8, "Member 'UEngine::SqexCollisionErrCheckMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, SqexSurfaceTypeMaterial) == 0x000400, "Member 'UEngine::SqexSurfaceTypeMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, SqexAttributeMaterial) == 0x000408, "Member 'UEngine::SqexAttributeMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, SqexVolumeDrawMaterial) == 0x000410, "Member 'UEngine::SqexVolumeDrawMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, ShadedLevelColorationUnlitMaterialName) == 0x000418, "Member 'UEngine::ShadedLevelColorationUnlitMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexCollisionErrMaterialName) == 0x000428, "Member 'UEngine::SqexCollisionErrMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexSurfaceTypeMaterialName) == 0x000438, "Member 'UEngine::SqexSurfaceTypeMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexAttributeMaterialName) == 0x000448, "Member 'UEngine::SqexAttributeMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, SqexVolumeDrawMaterialName) == 0x000458, "Member 'UEngine::SqexVolumeDrawMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, RemoveSurfaceMaterial) == 0x000468, "Member 'UEngine::RemoveSurfaceMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, RemoveSurfaceMaterialName) == 0x000470, "Member 'UEngine::RemoveSurfaceMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorMaterial) == 0x000480, "Member 'UEngine::VertexColorMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorMaterialName) == 0x000488, "Member 'UEngine::VertexColorMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterial_ColorOnly) == 0x000498, "Member 'UEngine::VertexColorViewModeMaterial_ColorOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterialName_ColorOnly) == 0x0004A0, "Member 'UEngine::VertexColorViewModeMaterialName_ColorOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterial_AlphaAsColor) == 0x0004B0, "Member 'UEngine::VertexColorViewModeMaterial_AlphaAsColor' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterialName_AlphaAsColor) == 0x0004B8, "Member 'UEngine::VertexColorViewModeMaterialName_AlphaAsColor' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterial_RedOnly) == 0x0004C8, "Member 'UEngine::VertexColorViewModeMaterial_RedOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterialName_RedOnly) == 0x0004D0, "Member 'UEngine::VertexColorViewModeMaterialName_RedOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterial_GreenOnly) == 0x0004E0, "Member 'UEngine::VertexColorViewModeMaterial_GreenOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterialName_GreenOnly) == 0x0004E8, "Member 'UEngine::VertexColorViewModeMaterialName_GreenOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterial_BlueOnly) == 0x0004F8, "Member 'UEngine::VertexColorViewModeMaterial_BlueOnly' has a wrong offset!");
static_assert(offsetof(UEngine, VertexColorViewModeMaterialName_BlueOnly) == 0x000500, "Member 'UEngine::VertexColorViewModeMaterialName_BlueOnly' has a wrong offset!");
static_assert(offsetof(UEngine, DebugEditorMaterialName) == 0x000510, "Member 'UEngine::DebugEditorMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterial) == 0x000520, "Member 'UEngine::ConstraintLimitMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialX) == 0x000528, "Member 'UEngine::ConstraintLimitMaterialX' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialXAxis) == 0x000530, "Member 'UEngine::ConstraintLimitMaterialXAxis' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialY) == 0x000538, "Member 'UEngine::ConstraintLimitMaterialY' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialYAxis) == 0x000540, "Member 'UEngine::ConstraintLimitMaterialYAxis' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialZ) == 0x000548, "Member 'UEngine::ConstraintLimitMaterialZ' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialZAxis) == 0x000550, "Member 'UEngine::ConstraintLimitMaterialZAxis' has a wrong offset!");
static_assert(offsetof(UEngine, ConstraintLimitMaterialPrismatic) == 0x000558, "Member 'UEngine::ConstraintLimitMaterialPrismatic' has a wrong offset!");
static_assert(offsetof(UEngine, InvalidLightmapSettingsMaterial) == 0x000560, "Member 'UEngine::InvalidLightmapSettingsMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, InvalidLightmapSettingsMaterialName) == 0x000568, "Member 'UEngine::InvalidLightmapSettingsMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, PreviewShadowsIndicatorMaterial) == 0x000578, "Member 'UEngine::PreviewShadowsIndicatorMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, PreviewShadowsIndicatorMaterialName) == 0x000580, "Member 'UEngine::PreviewShadowsIndicatorMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, ArrowMaterial) == 0x000590, "Member 'UEngine::ArrowMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, ArrowMaterialName) == 0x000598, "Member 'UEngine::ArrowMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, LightingOnlyBrightness) == 0x0005A8, "Member 'UEngine::LightingOnlyBrightness' has a wrong offset!");
static_assert(offsetof(UEngine, ShaderComplexityColors) == 0x0005B8, "Member 'UEngine::ShaderComplexityColors' has a wrong offset!");
static_assert(offsetof(UEngine, QuadComplexityColors) == 0x0005C8, "Member 'UEngine::QuadComplexityColors' has a wrong offset!");
static_assert(offsetof(UEngine, LightComplexityColors) == 0x0005D8, "Member 'UEngine::LightComplexityColors' has a wrong offset!");
static_assert(offsetof(UEngine, StationaryLightOverlapColors) == 0x0005E8, "Member 'UEngine::StationaryLightOverlapColors' has a wrong offset!");
static_assert(offsetof(UEngine, LODColorationColors) == 0x0005F8, "Member 'UEngine::LODColorationColors' has a wrong offset!");
static_assert(offsetof(UEngine, HLODColorationColors) == 0x000608, "Member 'UEngine::HLODColorationColors' has a wrong offset!");
static_assert(offsetof(UEngine, StreamingAccuracyColors) == 0x000618, "Member 'UEngine::StreamingAccuracyColors' has a wrong offset!");
static_assert(offsetof(UEngine, MaxPixelShaderAdditiveComplexityCount) == 0x000628, "Member 'UEngine::MaxPixelShaderAdditiveComplexityCount' has a wrong offset!");
static_assert(offsetof(UEngine, MaxES2PixelShaderAdditiveComplexityCount) == 0x00062C, "Member 'UEngine::MaxES2PixelShaderAdditiveComplexityCount' has a wrong offset!");
static_assert(offsetof(UEngine, MinLightMapDensity) == 0x000630, "Member 'UEngine::MinLightMapDensity' has a wrong offset!");
static_assert(offsetof(UEngine, IdealLightMapDensity) == 0x000634, "Member 'UEngine::IdealLightMapDensity' has a wrong offset!");
static_assert(offsetof(UEngine, MaxLightMapDensity) == 0x000638, "Member 'UEngine::MaxLightMapDensity' has a wrong offset!");
static_assert(offsetof(UEngine, RenderLightMapDensityGrayscaleScale) == 0x000640, "Member 'UEngine::RenderLightMapDensityGrayscaleScale' has a wrong offset!");
static_assert(offsetof(UEngine, RenderLightMapDensityColorScale) == 0x000644, "Member 'UEngine::RenderLightMapDensityColorScale' has a wrong offset!");
static_assert(offsetof(UEngine, LightMapDensityVertexMappedColor) == 0x000648, "Member 'UEngine::LightMapDensityVertexMappedColor' has a wrong offset!");
static_assert(offsetof(UEngine, LightMapDensitySelectedColor) == 0x000658, "Member 'UEngine::LightMapDensitySelectedColor' has a wrong offset!");
static_assert(offsetof(UEngine, StatColorMappings) == 0x000668, "Member 'UEngine::StatColorMappings' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultPhysMaterial) == 0x000678, "Member 'UEngine::DefaultPhysMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultPhysMaterialName) == 0x000680, "Member 'UEngine::DefaultPhysMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, SQEX_DefaultOceanPhysMaterial) == 0x000690, "Member 'UEngine::SQEX_DefaultOceanPhysMaterial' has a wrong offset!");
static_assert(offsetof(UEngine, SQEX_DefaultOceanPhysMaterialName) == 0x000698, "Member 'UEngine::SQEX_DefaultOceanPhysMaterialName' has a wrong offset!");
static_assert(offsetof(UEngine, SQEX_OverridePhysMaterialWallClimb) == 0x0006A8, "Member 'UEngine::SQEX_OverridePhysMaterialWallClimb' has a wrong offset!");
static_assert(offsetof(UEngine, SQEX_OverridePhysMaterialWallClimbName) == 0x0006B0, "Member 'UEngine::SQEX_OverridePhysMaterialWallClimbName' has a wrong offset!");
static_assert(offsetof(UEngine, ActiveGameNameRedirects) == 0x0006C0, "Member 'UEngine::ActiveGameNameRedirects' has a wrong offset!");
static_assert(offsetof(UEngine, ActiveClassRedirects) == 0x0006D0, "Member 'UEngine::ActiveClassRedirects' has a wrong offset!");
static_assert(offsetof(UEngine, ActivePluginRedirects) == 0x0006E0, "Member 'UEngine::ActivePluginRedirects' has a wrong offset!");
static_assert(offsetof(UEngine, ActiveStructRedirects) == 0x0006F0, "Member 'UEngine::ActiveStructRedirects' has a wrong offset!");
static_assert(offsetof(UEngine, PreIntegratedSkinBRDFTexture) == 0x000700, "Member 'UEngine::PreIntegratedSkinBRDFTexture' has a wrong offset!");
static_assert(offsetof(UEngine, PreIntegratedSkinBRDFTextureName) == 0x000708, "Member 'UEngine::PreIntegratedSkinBRDFTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, MiniFontTexture) == 0x000718, "Member 'UEngine::MiniFontTexture' has a wrong offset!");
static_assert(offsetof(UEngine, MiniFontTextureName) == 0x000720, "Member 'UEngine::MiniFontTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, WeightMapPlaceholderTexture) == 0x000730, "Member 'UEngine::WeightMapPlaceholderTexture' has a wrong offset!");
static_assert(offsetof(UEngine, WeightMapPlaceholderTextureName) == 0x000738, "Member 'UEngine::WeightMapPlaceholderTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, LightMapDensityTexture) == 0x000748, "Member 'UEngine::LightMapDensityTexture' has a wrong offset!");
static_assert(offsetof(UEngine, LightMapDensityTextureName) == 0x000750, "Member 'UEngine::LightMapDensityTextureName' has a wrong offset!");
static_assert(offsetof(UEngine, GameViewport) == 0x000768, "Member 'UEngine::GameViewport' has a wrong offset!");
static_assert(offsetof(UEngine, DeferredCommands) == 0x000770, "Member 'UEngine::DeferredCommands' has a wrong offset!");
static_assert(offsetof(UEngine, TickCycles) == 0x000780, "Member 'UEngine::TickCycles' has a wrong offset!");
static_assert(offsetof(UEngine, GameCycles) == 0x000784, "Member 'UEngine::GameCycles' has a wrong offset!");
static_assert(offsetof(UEngine, ClientCycles) == 0x000788, "Member 'UEngine::ClientCycles' has a wrong offset!");
static_assert(offsetof(UEngine, NearClipPlane) == 0x00078C, "Member 'UEngine::NearClipPlane' has a wrong offset!");
static_assert(offsetof(UEngine, MaximumLoopIterationCount) == 0x000794, "Member 'UEngine::MaximumLoopIterationCount' has a wrong offset!");
static_assert(offsetof(UEngine, FixedFrameRate) == 0x00079C, "Member 'UEngine::FixedFrameRate' has a wrong offset!");
static_assert(offsetof(UEngine, SmoothedFrameRateRange) == 0x0007A0, "Member 'UEngine::SmoothedFrameRateRange' has a wrong offset!");
static_assert(offsetof(UEngine, NumPawnsAllowedToBeSpawnedInAFrame) == 0x0007B4, "Member 'UEngine::NumPawnsAllowedToBeSpawnedInAFrame' has a wrong offset!");
static_assert(offsetof(UEngine, C_WorldBox) == 0x0007BC, "Member 'UEngine::C_WorldBox' has a wrong offset!");
static_assert(offsetof(UEngine, C_BrushWire) == 0x0007C0, "Member 'UEngine::C_BrushWire' has a wrong offset!");
static_assert(offsetof(UEngine, C_AddWire) == 0x0007C4, "Member 'UEngine::C_AddWire' has a wrong offset!");
static_assert(offsetof(UEngine, C_SubtractWire) == 0x0007C8, "Member 'UEngine::C_SubtractWire' has a wrong offset!");
static_assert(offsetof(UEngine, C_SemiSolidWire) == 0x0007CC, "Member 'UEngine::C_SemiSolidWire' has a wrong offset!");
static_assert(offsetof(UEngine, C_NonSolidWire) == 0x0007D0, "Member 'UEngine::C_NonSolidWire' has a wrong offset!");
static_assert(offsetof(UEngine, C_WireBackground) == 0x0007D4, "Member 'UEngine::C_WireBackground' has a wrong offset!");
static_assert(offsetof(UEngine, C_ScaleBoxHi) == 0x0007D8, "Member 'UEngine::C_ScaleBoxHi' has a wrong offset!");
static_assert(offsetof(UEngine, C_VolumeCollision) == 0x0007DC, "Member 'UEngine::C_VolumeCollision' has a wrong offset!");
static_assert(offsetof(UEngine, C_BSPCollision) == 0x0007E0, "Member 'UEngine::C_BSPCollision' has a wrong offset!");
static_assert(offsetof(UEngine, C_OrthoBackground) == 0x0007E4, "Member 'UEngine::C_OrthoBackground' has a wrong offset!");
static_assert(offsetof(UEngine, C_Volume) == 0x0007E8, "Member 'UEngine::C_Volume' has a wrong offset!");
static_assert(offsetof(UEngine, C_BrushShape) == 0x0007EC, "Member 'UEngine::C_BrushShape' has a wrong offset!");
static_assert(offsetof(UEngine, StreamingDistanceFactor) == 0x0007F0, "Member 'UEngine::StreamingDistanceFactor' has a wrong offset!");
static_assert(offsetof(UEngine, GameScreenshotSaveDirectory) == 0x0007F8, "Member 'UEngine::GameScreenshotSaveDirectory' has a wrong offset!");
static_assert(offsetof(UEngine, TransitionType) == 0x000808, "Member 'UEngine::TransitionType' has a wrong offset!");
static_assert(offsetof(UEngine, TransitionDescription) == 0x000810, "Member 'UEngine::TransitionDescription' has a wrong offset!");
static_assert(offsetof(UEngine, TransitionGameMode) == 0x000820, "Member 'UEngine::TransitionGameMode' has a wrong offset!");
static_assert(offsetof(UEngine, MeshLODRange) == 0x000830, "Member 'UEngine::MeshLODRange' has a wrong offset!");
static_assert(offsetof(UEngine, CameraRotationThreshold) == 0x000838, "Member 'UEngine::CameraRotationThreshold' has a wrong offset!");
static_assert(offsetof(UEngine, CameraTranslationThreshold) == 0x00083C, "Member 'UEngine::CameraTranslationThreshold' has a wrong offset!");
static_assert(offsetof(UEngine, PrimitiveProbablyVisibleTime) == 0x000840, "Member 'UEngine::PrimitiveProbablyVisibleTime' has a wrong offset!");
static_assert(offsetof(UEngine, MaxOcclusionPixelsFraction) == 0x000844, "Member 'UEngine::MaxOcclusionPixelsFraction' has a wrong offset!");
static_assert(offsetof(UEngine, MaxParticleResize) == 0x00084C, "Member 'UEngine::MaxParticleResize' has a wrong offset!");
static_assert(offsetof(UEngine, MaxParticleResizeWarn) == 0x000850, "Member 'UEngine::MaxParticleResizeWarn' has a wrong offset!");
static_assert(offsetof(UEngine, PendingDroppedNotes) == 0x000858, "Member 'UEngine::PendingDroppedNotes' has a wrong offset!");
static_assert(offsetof(UEngine, PhysicErrorCorrection) == 0x000868, "Member 'UEngine::PhysicErrorCorrection' has a wrong offset!");
static_assert(offsetof(UEngine, NetClientTicksPerSecond) == 0x000884, "Member 'UEngine::NetClientTicksPerSecond' has a wrong offset!");
static_assert(offsetof(UEngine, DisplayGamma) == 0x000888, "Member 'UEngine::DisplayGamma' has a wrong offset!");
static_assert(offsetof(UEngine, MinDesiredFrameRate) == 0x00088C, "Member 'UEngine::MinDesiredFrameRate' has a wrong offset!");
static_assert(offsetof(UEngine, SQEX_EventCutSceneMaxFPS) == 0x000894, "Member 'UEngine::SQEX_EventCutSceneMaxFPS' has a wrong offset!");
static_assert(offsetof(UEngine, DefaultSelectedMaterialColor) == 0x00089C, "Member 'UEngine::DefaultSelectedMaterialColor' has a wrong offset!");
static_assert(offsetof(UEngine, SelectedMaterialColor) == 0x0008AC, "Member 'UEngine::SelectedMaterialColor' has a wrong offset!");
static_assert(offsetof(UEngine, SelectionOutlineColor) == 0x0008BC, "Member 'UEngine::SelectionOutlineColor' has a wrong offset!");
static_assert(offsetof(UEngine, SubduedSelectionOutlineColor) == 0x0008CC, "Member 'UEngine::SubduedSelectionOutlineColor' has a wrong offset!");
static_assert(offsetof(UEngine, SelectedMaterialColorOverride) == 0x0008DC, "Member 'UEngine::SelectedMaterialColorOverride' has a wrong offset!");
static_assert(offsetof(UEngine, bIsOverridingSelectedColor) == 0x0008EC, "Member 'UEngine::bIsOverridingSelectedColor' has a wrong offset!");
static_assert(offsetof(UEngine, bEnableVisualLogRecordingOnStart) == 0x0008F4, "Member 'UEngine::bEnableVisualLogRecordingOnStart' has a wrong offset!");
static_assert(offsetof(UEngine, ScreenSaverInhibitorSemaphore) == 0x0008FC, "Member 'UEngine::ScreenSaverInhibitorSemaphore' has a wrong offset!");
static_assert(offsetof(UEngine, ParticleEventManagerClassPath) == 0x000908, "Member 'UEngine::ParticleEventManagerClassPath' has a wrong offset!");
static_assert(offsetof(UEngine, SelectionHighlightIntensity) == 0x000928, "Member 'UEngine::SelectionHighlightIntensity' has a wrong offset!");
static_assert(offsetof(UEngine, SelectionMeshSectionHighlightIntensity) == 0x00092C, "Member 'UEngine::SelectionMeshSectionHighlightIntensity' has a wrong offset!");
static_assert(offsetof(UEngine, BSPSelectionHighlightIntensity) == 0x000930, "Member 'UEngine::BSPSelectionHighlightIntensity' has a wrong offset!");
static_assert(offsetof(UEngine, HoverHighlightIntensity) == 0x000934, "Member 'UEngine::HoverHighlightIntensity' has a wrong offset!");
static_assert(offsetof(UEngine, SelectionHighlightIntensityBillboards) == 0x000938, "Member 'UEngine::SelectionHighlightIntensityBillboards' has a wrong offset!");
static_assert(offsetof(UEngine, NetDriverDefinitions) == 0x000D10, "Member 'UEngine::NetDriverDefinitions' has a wrong offset!");
static_assert(offsetof(UEngine, ServerActors) == 0x000D20, "Member 'UEngine::ServerActors' has a wrong offset!");
static_assert(offsetof(UEngine, RuntimeServerActors) == 0x000D30, "Member 'UEngine::RuntimeServerActors' has a wrong offset!");
static_assert(offsetof(UEngine, NextWorldContextHandle) == 0x000D58, "Member 'UEngine::NextWorldContextHandle' has a wrong offset!");

// Class Engine.SplineComponent
// 0x4000 (0x112EDAF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112EDAF0) USplineComponent : public UPrimitiveComponent
{
public:
	struct FSplineCurves                          SplineCurves;                                      // 0x0868(0x112EDAF0)(Edit, NativeAccessSpecifierPublic)
	struct FInterpCurveVector                     SplineInfo;                                        // 0x08C8(0x112ED410)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveQuat                       SplineRotInfo;                                     // 0x08E0(0x112EDAF0)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveVector                     SplineScaleInfo;                                   // 0x08F8(0x112ED410)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      SplineReparamTable;                                // 0x0910(0x112EC5B0)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSplineEditingPerInstance;                    // 0x0928(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_929[0x3];                                      // 0x0929(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReparamStepsPerSegment;                            // 0x092C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0930(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStationaryEndpoints;                              // 0x0934(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplineHasBeenEdited;                              // 0x0935(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifiedByConstructionScript;                     // 0x0936(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputSplinePointsToConstructionScript;            // 0x0937(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0938(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosedLoop;                                       // 0x0939(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLoopPositionOverride;                             // 0x093A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_93B[0x1];                                      // 0x093B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopPosition;                                      // 0x093C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DefaultUpVector;                                   // 0x0940(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94C[0x4];                                      // 0x094C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPoint(const struct FSplinePoint& Point, bool bUpdateSpline);
	void AddPoints(const TArray<struct FSplinePoint>& Points, bool bUpdateSpline);
	void AddSplineLocalPoint(const struct FVector& Position);
	void AddSplinePoint(const struct FVector& Position, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void AddSplinePointAtIndex(const struct FVector& Position, int32 Index_0, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void AddSplineWorldPoint(const struct FVector& Position);
	void ClearSplinePoints(bool bUpdateSpline);
	void RemoveSplinePoint(int32 Index_0, bool bUpdateSpline);
	void SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline);
	void SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline);
	void SetDefaultUpVector(const struct FVector& UpVector, ESplineCoordinateSpace CoordinateSpace);
	void SetDrawDebug(bool bShow);
	void SetLocationAtSplinePoint(int32 PointIndex, const struct FVector& InLocation, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void SetSelectedSplineSegmentColor(const struct FLinearColor& SegmentColor);
	void SetSplineLocalPoints(const TArray<struct FVector>& Points);
	void SetSplinePoints(const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void SetSplinePointType(int32 PointIndex, ESplinePointType Type, bool bUpdateSpline);
	void SetSplineWorldPoints(const TArray<struct FVector>& Points);
	void SetTangentAtSplinePoint(int32 PointIndex, const struct FVector& InTangent, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void SetTangentsAtSplinePoint(int32 PointIndex, const struct FVector& InArriveTangent, const struct FVector& InLeaveTangent, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void SetUnselectedSplineSegmentColor(const struct FLinearColor& SegmentColor);
	void SetUpVectorAtSplinePoint(int32 PointIndex, const struct FVector& InUpVector, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	void SetWorldLocationAtSplinePoint(int32 PointIndex, const struct FVector& InLocation);
	void UpdateSpline();

	struct FVector FindDirectionClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	float FindInputKeyClosestToWorldLocation(const struct FVector& WorldLocation) const;
	struct FVector FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector FindRightVectorClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	float FindRollClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	struct FRotator FindRotationClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector FindScaleClosestToWorldLocation(const struct FVector& WorldLocation) const;
	struct FVector FindTangentClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	struct FTransform FindTransformClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const;
	struct FVector FindUpVectorClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetArriveTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetDefaultUpVector(ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetDirectionAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetDirectionAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetDirectionAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	float GetDistanceAlongSplineAtSplinePoint(int32 PointIndex) const;
	float GetInputKeyAtDistanceAlongSpline(float Distance) const;
	struct FVector GetLeaveTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	void GetLocalLocationAndTangentAtSplinePoint(int32 PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent) const;
	void GetLocationAndTangentAtSplinePoint(int32 PointIndex, struct FVector* Location, struct FVector* Tangent, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetLocationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetLocationAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetLocationAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	int32 GetNumberOfSplinePoints() const;
	struct FVector GetRightVectorAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetRightVectorAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetRightVectorAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	float GetRollAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	float GetRollAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	float GetRollAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	struct FRotator GetRotationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FRotator GetRotationAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FRotator GetRotationAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	struct FVector GetScaleAtDistanceAlongSpline(float Distance) const;
	struct FVector GetScaleAtSplinePoint(int32 PointIndex) const;
	struct FVector GetScaleAtTime(float Time, bool bUseConstantVelocity) const;
	float GetSplineLength() const;
	ESplinePointType GetSplinePointType(int32 PointIndex) const;
	struct FVector GetTangentAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetTangentAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	struct FTransform GetTransformAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const;
	struct FTransform GetTransformAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const;
	struct FTransform GetTransformAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity, bool bUseScale) const;
	struct FVector GetUpVectorAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetUpVectorAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const;
	struct FVector GetUpVectorAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const;
	struct FVector GetWorldDirectionAtDistanceAlongSpline(float Distance) const;
	struct FVector GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity) const;
	struct FVector GetWorldLocationAtDistanceAlongSpline(float Distance) const;
	struct FVector GetWorldLocationAtSplinePoint(int32 PointIndex) const;
	struct FVector GetWorldLocationAtTime(float Time, bool bUseConstantVelocity) const;
	struct FRotator GetWorldRotationAtDistanceAlongSpline(float Distance) const;
	struct FRotator GetWorldRotationAtTime(float Time, bool bUseConstantVelocity) const;
	struct FVector GetWorldTangentAtDistanceAlongSpline(float Distance) const;
	bool IsClosedLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineComponent">();
	}
	static class USplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplineComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USplineComponent) == 0x112EDAF0, "Wrong alignment on USplineComponent");
static_assert(sizeof(USplineComponent) == 0x112EDAF0, "Wrong size on USplineComponent");
static_assert(offsetof(USplineComponent, SplineCurves) == 0x000868, "Member 'USplineComponent::SplineCurves' has a wrong offset!");
static_assert(offsetof(USplineComponent, SplineInfo) == 0x0008C8, "Member 'USplineComponent::SplineInfo' has a wrong offset!");
static_assert(offsetof(USplineComponent, SplineRotInfo) == 0x0008E0, "Member 'USplineComponent::SplineRotInfo' has a wrong offset!");
static_assert(offsetof(USplineComponent, SplineScaleInfo) == 0x0008F8, "Member 'USplineComponent::SplineScaleInfo' has a wrong offset!");
static_assert(offsetof(USplineComponent, SplineReparamTable) == 0x000910, "Member 'USplineComponent::SplineReparamTable' has a wrong offset!");
static_assert(offsetof(USplineComponent, bAllowSplineEditingPerInstance) == 0x000928, "Member 'USplineComponent::bAllowSplineEditingPerInstance' has a wrong offset!");
static_assert(offsetof(USplineComponent, ReparamStepsPerSegment) == 0x00092C, "Member 'USplineComponent::ReparamStepsPerSegment' has a wrong offset!");
static_assert(offsetof(USplineComponent, Duration) == 0x000930, "Member 'USplineComponent::Duration' has a wrong offset!");
static_assert(offsetof(USplineComponent, bStationaryEndpoints) == 0x000934, "Member 'USplineComponent::bStationaryEndpoints' has a wrong offset!");
static_assert(offsetof(USplineComponent, bSplineHasBeenEdited) == 0x000935, "Member 'USplineComponent::bSplineHasBeenEdited' has a wrong offset!");
static_assert(offsetof(USplineComponent, bModifiedByConstructionScript) == 0x000936, "Member 'USplineComponent::bModifiedByConstructionScript' has a wrong offset!");
static_assert(offsetof(USplineComponent, bInputSplinePointsToConstructionScript) == 0x000937, "Member 'USplineComponent::bInputSplinePointsToConstructionScript' has a wrong offset!");
static_assert(offsetof(USplineComponent, bDrawDebug) == 0x000938, "Member 'USplineComponent::bDrawDebug' has a wrong offset!");
static_assert(offsetof(USplineComponent, bClosedLoop) == 0x000939, "Member 'USplineComponent::bClosedLoop' has a wrong offset!");
static_assert(offsetof(USplineComponent, bLoopPositionOverride) == 0x00093A, "Member 'USplineComponent::bLoopPositionOverride' has a wrong offset!");
static_assert(offsetof(USplineComponent, LoopPosition) == 0x00093C, "Member 'USplineComponent::LoopPosition' has a wrong offset!");
static_assert(offsetof(USplineComponent, DefaultUpVector) == 0x000940, "Member 'USplineComponent::DefaultUpVector' has a wrong offset!");

// Class Engine.AnimCompress
// 0x0020 (0x0060 - 0x0040)
class UAnimCompress : public UObject
{
public:
	class FString                                 Description;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedsSkeleton : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimationCompressionFormat                   TranslationCompressionFormat;                      // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationCompressionFormat                   RotationCompressionFormat;                         // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationCompressionFormat                   ScaleCompressionFormat;                            // 0x0056(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCurveError;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress">();
	}
	static class UAnimCompress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress>();
	}
};
static_assert(alignof(UAnimCompress) == 0x000008, "Wrong alignment on UAnimCompress");
static_assert(sizeof(UAnimCompress) == 0x000060, "Wrong size on UAnimCompress");
static_assert(offsetof(UAnimCompress, Description) == 0x000040, "Member 'UAnimCompress::Description' has a wrong offset!");
static_assert(offsetof(UAnimCompress, TranslationCompressionFormat) == 0x000054, "Member 'UAnimCompress::TranslationCompressionFormat' has a wrong offset!");
static_assert(offsetof(UAnimCompress, RotationCompressionFormat) == 0x000055, "Member 'UAnimCompress::RotationCompressionFormat' has a wrong offset!");
static_assert(offsetof(UAnimCompress, ScaleCompressionFormat) == 0x000056, "Member 'UAnimCompress::ScaleCompressionFormat' has a wrong offset!");
static_assert(offsetof(UAnimCompress, MaxCurveError) == 0x000058, "Member 'UAnimCompress::MaxCurveError' has a wrong offset!");

// Class Engine.AnimCompress_BitwiseCompressOnly
// 0x0000 (0x0060 - 0x0060)
class UAnimCompress_BitwiseCompressOnly final : public UAnimCompress
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_BitwiseCompressOnly">();
	}
	static class UAnimCompress_BitwiseCompressOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_BitwiseCompressOnly>();
	}
};
static_assert(alignof(UAnimCompress_BitwiseCompressOnly) == 0x000008, "Wrong alignment on UAnimCompress_BitwiseCompressOnly");
static_assert(sizeof(UAnimCompress_BitwiseCompressOnly) == 0x000060, "Wrong size on UAnimCompress_BitwiseCompressOnly");

// Class Engine.ShapeComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UShapeComponent : public UPrimitiveComponent
{
public:
	struct FColor                                 ShapeColor;                                        // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86C[0x4];                                      // 0x086C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             ShapeBodySetup;                                    // 0x0870(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawOnlyIfSelected : 1;                           // 0x0878(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldCollideWhenPlacing : 1;                     // 0x0878(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDynamicObstacle : 1;                              // 0x0878(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_879[0x7];                                      // 0x0879(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0880(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShapeComponent">();
	}
	static class UShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShapeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UShapeComponent) == 0x112E9AF0, "Wrong alignment on UShapeComponent");
static_assert(sizeof(UShapeComponent) == 0x112E9AF0, "Wrong size on UShapeComponent");
static_assert(offsetof(UShapeComponent, ShapeColor) == 0x000868, "Member 'UShapeComponent::ShapeColor' has a wrong offset!");
static_assert(offsetof(UShapeComponent, ShapeBodySetup) == 0x000870, "Member 'UShapeComponent::ShapeBodySetup' has a wrong offset!");
static_assert(offsetof(UShapeComponent, AreaClass) == 0x000880, "Member 'UShapeComponent::AreaClass' has a wrong offset!");

// Class Engine.BoxComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UBoxComponent : public UShapeComponent
{
public:
	struct FVector                                BoxExtent;                                         // 0x0888(0x000C)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_894[0xC];                                      // 0x0894(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps);

	struct FVector GetScaledBoxExtent() const;
	struct FVector GetUnscaledBoxExtent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxComponent">();
	}
	static class UBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxComponent>();
	}
};
static_assert(alignof(UBoxComponent) == 0x112E9AF0, "Wrong alignment on UBoxComponent");
static_assert(sizeof(UBoxComponent) == 0x112E9AF0, "Wrong size on UBoxComponent");
static_assert(offsetof(UBoxComponent, BoxExtent) == 0x000888, "Member 'UBoxComponent::BoxExtent' has a wrong offset!");

// Class Engine.SQEX_VoxelMeshBoneDataBase
// 0x0000 (0x0040 - 0x0040)
class USQEX_VoxelMeshBoneDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VoxelMeshBoneDataBase">();
	}
	static class USQEX_VoxelMeshBoneDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_VoxelMeshBoneDataBase>();
	}
};
static_assert(alignof(USQEX_VoxelMeshBoneDataBase) == 0x000008, "Wrong alignment on USQEX_VoxelMeshBoneDataBase");
static_assert(sizeof(USQEX_VoxelMeshBoneDataBase) == 0x000040, "Wrong size on USQEX_VoxelMeshBoneDataBase");

// Class Engine.SkeletalMeshActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ASkeletalMeshActor : public AActor
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bShouldDoAnimNotifies : 1;                         // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWakeOnLevelStart : 1;                             // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          ReplicatedMesh;                                    // 0x03F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          ReplicatedPhysAsset;                               // 0x0400(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReplicatedMaterial0;                               // 0x0408(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReplicatedMaterial1;                               // 0x0410(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x50];                                     // 0x0418(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ReplicatedMaterial0();
	void OnRep_ReplicatedMaterial1();
	void OnRep_ReplicatedMesh();
	void OnRep_ReplicatedPhysAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshActor">();
	}
	static class ASkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletalMeshActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ASkeletalMeshActor) == 0x1EF72E00, "Wrong alignment on ASkeletalMeshActor");
static_assert(sizeof(ASkeletalMeshActor) == 0x1EF72E00, "Wrong size on ASkeletalMeshActor");
static_assert(offsetof(ASkeletalMeshActor, SkeletalMeshComponent) == 0x0003F0, "Member 'ASkeletalMeshActor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshActor, ReplicatedMesh) == 0x0003F8, "Member 'ASkeletalMeshActor::ReplicatedMesh' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshActor, ReplicatedPhysAsset) == 0x000400, "Member 'ASkeletalMeshActor::ReplicatedPhysAsset' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshActor, ReplicatedMaterial0) == 0x000408, "Member 'ASkeletalMeshActor::ReplicatedMaterial0' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshActor, ReplicatedMaterial1) == 0x000410, "Member 'ASkeletalMeshActor::ReplicatedMaterial1' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXParameter
// 0x0018 (0x0090 - 0x0078)
class UMaterialExpressionParticleSQEXParameter final : public UMaterialExpression
{
public:
	TArray<class FString>                         ParamNames;                                        // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EParticleSQEXParameterType                    ParameterType;                                     // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOnColorFllPins : 1;                               // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXParameter">();
	}
	static class UMaterialExpressionParticleSQEXParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXParameter>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXParameter) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXParameter");
static_assert(sizeof(UMaterialExpressionParticleSQEXParameter) == 0x000090, "Wrong size on UMaterialExpressionParticleSQEXParameter");
static_assert(offsetof(UMaterialExpressionParticleSQEXParameter, ParamNames) == 0x000078, "Member 'UMaterialExpressionParticleSQEXParameter::ParamNames' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXParameter, ParameterType) == 0x000088, "Member 'UMaterialExpressionParticleSQEXParameter::ParameterType' has a wrong offset!");

// Class Engine.InterpTrackLinearColorBase
// 0x112EE820 (0x112EE8B0 - 0x0090)
#pragma pack(push, 0x1)
class alignas(0x112EE8B0) UInterpTrackLinearColorBase : public UInterpTrack
{
public:
	struct FInterpCurveLinearColor                LinearColorTrack;                                  // 0x0090(0x112EE8B0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTension;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackLinearColorBase">();
	}
	static class UInterpTrackLinearColorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackLinearColorBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackLinearColorBase) == 0x112EE8B0, "Wrong alignment on UInterpTrackLinearColorBase");
static_assert(sizeof(UInterpTrackLinearColorBase) == 0x112EE8B0, "Wrong size on UInterpTrackLinearColorBase");
static_assert(offsetof(UInterpTrackLinearColorBase, LinearColorTrack) == 0x000090, "Member 'UInterpTrackLinearColorBase::LinearColorTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackLinearColorBase, CurveTension) == 0x0000A8, "Member 'UInterpTrackLinearColorBase::CurveTension' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TailShape_Base
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleSQEX_TailShape_Base : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TailShape_Base">();
	}
	static class UParticleModuleSQEX_TailShape_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TailShape_Base>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TailShape_Base) == 0x000008, "Wrong alignment on UParticleModuleSQEX_TailShape_Base");
static_assert(sizeof(UParticleModuleSQEX_TailShape_Base) == 0x000050, "Wrong size on UParticleModuleSQEX_TailShape_Base");

// Class Engine.ParticleModuleSQEX_TailNoise
// 0x0068 (0x00B8 - 0x0050)
class UParticleModuleSQEX_TailNoise final : public UParticleModuleSQEX_TailShape_Base
{
public:
	class FName                                   ShareNoiseDataEmitterName;                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseNoiseTypeSize : 1;                             // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSize;                                           // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseNoiseTypeAlpha : 1;                            // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  NoiseIntensity;                                    // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         NoiseMin;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoiseMax;                                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseIntensityRandomMin;                           // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseIntensityRandomMax;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoopResetNoiseData : 1;                           // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TailNoise">();
	}
	static class UParticleModuleSQEX_TailNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TailNoise>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TailNoise) == 0x000008, "Wrong alignment on UParticleModuleSQEX_TailNoise");
static_assert(sizeof(UParticleModuleSQEX_TailNoise) == 0x0000B8, "Wrong size on UParticleModuleSQEX_TailNoise");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, ShareNoiseDataEmitterName) == 0x000050, "Member 'UParticleModuleSQEX_TailNoise::ShareNoiseDataEmitterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, MinSize) == 0x00005C, "Member 'UParticleModuleSQEX_TailNoise::MinSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, NoiseIntensity) == 0x000068, "Member 'UParticleModuleSQEX_TailNoise::NoiseIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, NoiseMin) == 0x0000A0, "Member 'UParticleModuleSQEX_TailNoise::NoiseMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, NoiseMax) == 0x0000A4, "Member 'UParticleModuleSQEX_TailNoise::NoiseMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, NoiseIntensityRandomMin) == 0x0000A8, "Member 'UParticleModuleSQEX_TailNoise::NoiseIntensityRandomMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailNoise, NoiseIntensityRandomMax) == 0x0000AC, "Member 'UParticleModuleSQEX_TailNoise::NoiseIntensityRandomMax' has a wrong offset!");

// Class Engine.SoundEffectPreset
// 0x0018 (0x0058 - 0x0040)
class USoundEffectPreset : public UObject
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundEffectPreset">();
	}
	static class USoundEffectPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundEffectPreset>();
	}
};
static_assert(alignof(USoundEffectPreset) == 0x000008, "Wrong alignment on USoundEffectPreset");
static_assert(sizeof(USoundEffectPreset) == 0x000058, "Wrong size on USoundEffectPreset");

// Class Engine.SoundEffectSourcePreset
// 0x0000 (0x0058 - 0x0058)
class USoundEffectSourcePreset final : public USoundEffectPreset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundEffectSourcePreset">();
	}
	static class USoundEffectSourcePreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundEffectSourcePreset>();
	}
};
static_assert(alignof(USoundEffectSourcePreset) == 0x000008, "Wrong alignment on USoundEffectSourcePreset");
static_assert(sizeof(USoundEffectSourcePreset) == 0x000058, "Wrong size on USoundEffectSourcePreset");

// Class Engine.CameraShake
// 0x1160DEE0 (0x1160DF20 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x1160DF20) UCameraShake : public UObject
{
public:
	uint8                                         bSingleInstance : 1;                               // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OscillationDuration;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendInTime;                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillationBlendOutTime;                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FROscillator                           RotOscillation;                                    // 0x0050(0x1160DF20)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVOscillator                           LocOscillation;                                    // 0x00A4(0x1160DF20)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFOscillator                           FOVOscillation;                                    // 0x00F8(0x1160DF20)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AnimPlayRate;                                      // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimScale;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendInTime;                                   // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendOutTime;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomAnimSegmentDuration;                         // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            Anim;                                              // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRandomAnimSegment : 1;                            // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bAnimLoop : 1;                                   // 0x0130(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bNoRemoveAll : 1;                                // 0x0130(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0xF];                                      // 0x0131(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   CameraOwner;                                       // 0x0140(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x88];                                     // 0x0148(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeScale;                                        // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OscillatorTimeRemaining;                           // 0x01D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnimInst*                        AnimInst;                                          // 0x01D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BlueprintUpdateCameraShake(float DeltaTime, float Alpha, const struct FMinimalViewInfo& POV, struct FMinimalViewInfo* ModifiedPOV);
	void ReceivePlayShake(float Scale);
	void ReceiveStopShake(bool bImmediately);

	bool ReceiveIsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraShake">();
	}
	static class UCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraShake>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCameraShake) == 0x1160DF20, "Wrong alignment on UCameraShake");
static_assert(sizeof(UCameraShake) == 0x1160DF20, "Wrong size on UCameraShake");
static_assert(offsetof(UCameraShake, OscillationDuration) == 0x000044, "Member 'UCameraShake::OscillationDuration' has a wrong offset!");
static_assert(offsetof(UCameraShake, OscillationBlendInTime) == 0x000048, "Member 'UCameraShake::OscillationBlendInTime' has a wrong offset!");
static_assert(offsetof(UCameraShake, OscillationBlendOutTime) == 0x00004C, "Member 'UCameraShake::OscillationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UCameraShake, RotOscillation) == 0x000050, "Member 'UCameraShake::RotOscillation' has a wrong offset!");
static_assert(offsetof(UCameraShake, LocOscillation) == 0x0000A4, "Member 'UCameraShake::LocOscillation' has a wrong offset!");
static_assert(offsetof(UCameraShake, FOVOscillation) == 0x0000F8, "Member 'UCameraShake::FOVOscillation' has a wrong offset!");
static_assert(offsetof(UCameraShake, AnimPlayRate) == 0x000114, "Member 'UCameraShake::AnimPlayRate' has a wrong offset!");
static_assert(offsetof(UCameraShake, AnimScale) == 0x000118, "Member 'UCameraShake::AnimScale' has a wrong offset!");
static_assert(offsetof(UCameraShake, AnimBlendInTime) == 0x00011C, "Member 'UCameraShake::AnimBlendInTime' has a wrong offset!");
static_assert(offsetof(UCameraShake, AnimBlendOutTime) == 0x000120, "Member 'UCameraShake::AnimBlendOutTime' has a wrong offset!");
static_assert(offsetof(UCameraShake, RandomAnimSegmentDuration) == 0x000124, "Member 'UCameraShake::RandomAnimSegmentDuration' has a wrong offset!");
static_assert(offsetof(UCameraShake, Anim) == 0x000128, "Member 'UCameraShake::Anim' has a wrong offset!");
static_assert(offsetof(UCameraShake, CameraOwner) == 0x000140, "Member 'UCameraShake::CameraOwner' has a wrong offset!");
static_assert(offsetof(UCameraShake, ShakeScale) == 0x0001D0, "Member 'UCameraShake::ShakeScale' has a wrong offset!");
static_assert(offsetof(UCameraShake, OscillatorTimeRemaining) == 0x0001D4, "Member 'UCameraShake::OscillatorTimeRemaining' has a wrong offset!");
static_assert(offsetof(UCameraShake, AnimInst) == 0x0001D8, "Member 'UCameraShake::AnimInst' has a wrong offset!");

// Class Engine.LightmassCharacterIndirectDetailVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ALightmassCharacterIndirectDetailVolume final : public AVolume
{
public:
	bool                                          M_IsUseDefaultLightmassParam;                      // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_DetailVolumeSampleSpacing;                       // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightmassCharacterIndirectDetailVolume">();
	}
	static class ALightmassCharacterIndirectDetailVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightmassCharacterIndirectDetailVolume>();
	}
};
static_assert(alignof(ALightmassCharacterIndirectDetailVolume) == 0x1EF72E00, "Wrong alignment on ALightmassCharacterIndirectDetailVolume");
static_assert(sizeof(ALightmassCharacterIndirectDetailVolume) == 0x1EF72E00, "Wrong size on ALightmassCharacterIndirectDetailVolume");
static_assert(offsetof(ALightmassCharacterIndirectDetailVolume, M_IsUseDefaultLightmassParam) == 0x000420, "Member 'ALightmassCharacterIndirectDetailVolume::M_IsUseDefaultLightmassParam' has a wrong offset!");
static_assert(offsetof(ALightmassCharacterIndirectDetailVolume, M_DetailVolumeSampleSpacing) == 0x000424, "Member 'ALightmassCharacterIndirectDetailVolume::M_DetailVolumeSampleSpacing' has a wrong offset!");

// Class Engine.ChildActorComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UChildActorComponent : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     ChildActorClass;                                   // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_InheritTransientFlag;                            // 0x0420(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ChildActor;                                        // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, TextExportTransient, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 ChildActorTemplate;                                // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChildActorClass(TSubclassOf<class AActor> InClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChildActorComponent">();
	}
	static class UChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChildActorComponent>();
	}
};
static_assert(alignof(UChildActorComponent) == 0x112E9AF0, "Wrong alignment on UChildActorComponent");
static_assert(sizeof(UChildActorComponent) == 0x112E9AF0, "Wrong size on UChildActorComponent");
static_assert(offsetof(UChildActorComponent, ChildActorClass) == 0x000418, "Member 'UChildActorComponent::ChildActorClass' has a wrong offset!");
static_assert(offsetof(UChildActorComponent, M_InheritTransientFlag) == 0x000420, "Member 'UChildActorComponent::M_InheritTransientFlag' has a wrong offset!");
static_assert(offsetof(UChildActorComponent, ChildActor) == 0x000428, "Member 'UChildActorComponent::ChildActor' has a wrong offset!");
static_assert(offsetof(UChildActorComponent, ChildActorTemplate) == 0x000430, "Member 'UChildActorComponent::ChildActorTemplate' has a wrong offset!");

// Class Engine.MaterialExpressionCustomOutput
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionCustomOutput : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCustomOutput">();
	}
	static class UMaterialExpressionCustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCustomOutput>();
	}
};
static_assert(alignof(UMaterialExpressionCustomOutput) == 0x000008, "Wrong alignment on UMaterialExpressionCustomOutput");
static_assert(sizeof(UMaterialExpressionCustomOutput) == 0x000078, "Wrong size on UMaterialExpressionCustomOutput");

// Class Engine.MaterialExpressionVertexInterpolator
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionVertexInterpolator final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVertexInterpolator">();
	}
	static class UMaterialExpressionVertexInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVertexInterpolator>();
	}
};
static_assert(alignof(UMaterialExpressionVertexInterpolator) == 0x112F2730, "Wrong alignment on UMaterialExpressionVertexInterpolator");
static_assert(sizeof(UMaterialExpressionVertexInterpolator) == 0x112F2730, "Wrong size on UMaterialExpressionVertexInterpolator");
static_assert(offsetof(UMaterialExpressionVertexInterpolator, Input) == 0x000078, "Member 'UMaterialExpressionVertexInterpolator::Input' has a wrong offset!");

// Class Engine.DamageType
// 0x0018 (0x0058 - 0x0040)
class UDamageType : public UObject
{
public:
	uint8                                         bCausedByWorld : 1;                                // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleMomentumByMass : 1;                          // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRadialDamageVelChange : 1;                        // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageImpulse;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructibleImpulse;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructibleDamageSpreadScale;                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType">();
	}
	static class UDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType>();
	}
};
static_assert(alignof(UDamageType) == 0x000008, "Wrong alignment on UDamageType");
static_assert(sizeof(UDamageType) == 0x000058, "Wrong size on UDamageType");
static_assert(offsetof(UDamageType, DamageImpulse) == 0x000044, "Member 'UDamageType::DamageImpulse' has a wrong offset!");
static_assert(offsetof(UDamageType, DestructibleImpulse) == 0x000048, "Member 'UDamageType::DestructibleImpulse' has a wrong offset!");
static_assert(offsetof(UDamageType, DestructibleDamageSpreadScale) == 0x00004C, "Member 'UDamageType::DestructibleDamageSpreadScale' has a wrong offset!");
static_assert(offsetof(UDamageType, DamageFalloff) == 0x000050, "Member 'UDamageType::DamageFalloff' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXTextureSample
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionParticleSQEXTextureSample final : public UMaterialExpression
{
public:
	uint32                                        ConstCoordinate;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSQEXTextureSampleType                TextureType;                                       // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Coordinates;                                       // 0x0080(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXTextureSample">();
	}
	static class UMaterialExpressionParticleSQEXTextureSample* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXTextureSample>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXTextureSample) == 0x112F2730, "Wrong alignment on UMaterialExpressionParticleSQEXTextureSample");
static_assert(sizeof(UMaterialExpressionParticleSQEXTextureSample) == 0x112F2730, "Wrong size on UMaterialExpressionParticleSQEXTextureSample");
static_assert(offsetof(UMaterialExpressionParticleSQEXTextureSample, ConstCoordinate) == 0x000078, "Member 'UMaterialExpressionParticleSQEXTextureSample::ConstCoordinate' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXTextureSample, TextureType) == 0x00007C, "Member 'UMaterialExpressionParticleSQEXTextureSample::TextureType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXTextureSample, Coordinates) == 0x000080, "Member 'UMaterialExpressionParticleSQEXTextureSample::Coordinates' has a wrong offset!");

// Class Engine.MaterialExpressionTextureBase
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionTextureBase : public UMaterialExpression
{
public:
	class UTexture*                               Texture;                                           // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialSamplerType                          SamplerType;                                       // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         IsDefaultMeshpaintTexture : 1;                     // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureBase">();
	}
	static class UMaterialExpressionTextureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureBase>();
	}
};
static_assert(alignof(UMaterialExpressionTextureBase) == 0x000008, "Wrong alignment on UMaterialExpressionTextureBase");
static_assert(sizeof(UMaterialExpressionTextureBase) == 0x000088, "Wrong size on UMaterialExpressionTextureBase");
static_assert(offsetof(UMaterialExpressionTextureBase, Texture) == 0x000078, "Member 'UMaterialExpressionTextureBase::Texture' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureBase, SamplerType) == 0x000080, "Member 'UMaterialExpressionTextureBase::SamplerType' has a wrong offset!");

// Class Engine.MaterialExpressionTextureSample
// 0x112F26A8 (0x112F2730 - 0x0088)
#pragma pack(push, 0x1)
class alignas(0x112F2730) UMaterialExpressionTextureSample : public UMaterialExpressionTextureBase
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x0088(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       TextureObject;                                     // 0x00C0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       MipValue;                                          // 0x00F8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       CoordinatesDX;                                     // 0x0130(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       CoordinatesDY;                                     // 0x0168(0x112F2730)(NativeAccessSpecifierPublic)
	ETextureMipValueMode                          MipValueMode;                                      // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESamplerSourceMode                            SamplerSource;                                     // 0x01A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2[0x2];                                      // 0x01A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ConstCoordinate;                                   // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConstMipValue;                                     // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureSample">();
	}
	static class UMaterialExpressionTextureSample* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureSample>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaterialExpressionTextureSample) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureSample");
static_assert(sizeof(UMaterialExpressionTextureSample) == 0x112F2730, "Wrong size on UMaterialExpressionTextureSample");
static_assert(offsetof(UMaterialExpressionTextureSample, Coordinates) == 0x000088, "Member 'UMaterialExpressionTextureSample::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, TextureObject) == 0x0000C0, "Member 'UMaterialExpressionTextureSample::TextureObject' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, MipValue) == 0x0000F8, "Member 'UMaterialExpressionTextureSample::MipValue' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, CoordinatesDX) == 0x000130, "Member 'UMaterialExpressionTextureSample::CoordinatesDX' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, CoordinatesDY) == 0x000168, "Member 'UMaterialExpressionTextureSample::CoordinatesDY' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, MipValueMode) == 0x0001A0, "Member 'UMaterialExpressionTextureSample::MipValueMode' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, SamplerSource) == 0x0001A1, "Member 'UMaterialExpressionTextureSample::SamplerSource' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, ConstCoordinate) == 0x0001A4, "Member 'UMaterialExpressionTextureSample::ConstCoordinate' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSample, ConstMipValue) == 0x0001A8, "Member 'UMaterialExpressionTextureSample::ConstMipValue' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSubUV
// 0x0000 (0x112F2730 - 0x112F2730)
class UMaterialExpressionParticleSubUV final : public UMaterialExpressionTextureSample
{
public:
	uint8                                         bBlend : 1;                                        // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSubUV">();
	}
	static class UMaterialExpressionParticleSubUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSubUV>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSubUV) == 0x112F2730, "Wrong alignment on UMaterialExpressionParticleSubUV");
static_assert(sizeof(UMaterialExpressionParticleSubUV) == 0x112F2730, "Wrong size on UMaterialExpressionParticleSubUV");

// Class Engine.ArrowComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UArrowComponent : public UPrimitiveComponent
{
public:
	struct FColor                                 ArrowColor;                                        // 0x0868(0x0004)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowSize;                                         // 0x086C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScreenSizeScaled;                               // 0x0870(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_871[0x3];                                      // 0x0871(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenSize;                                        // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTreatAsASprite : 1;                               // 0x0878(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_879[0x7];                                      // 0x0879(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetArrowColor(const struct FLinearColor& NewColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrowComponent">();
	}
	static class UArrowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrowComponent>();
	}
};
static_assert(alignof(UArrowComponent) == 0x112E9AF0, "Wrong alignment on UArrowComponent");
static_assert(sizeof(UArrowComponent) == 0x112E9AF0, "Wrong size on UArrowComponent");
static_assert(offsetof(UArrowComponent, ArrowColor) == 0x000868, "Member 'UArrowComponent::ArrowColor' has a wrong offset!");
static_assert(offsetof(UArrowComponent, ArrowSize) == 0x00086C, "Member 'UArrowComponent::ArrowSize' has a wrong offset!");
static_assert(offsetof(UArrowComponent, bIsScreenSizeScaled) == 0x000870, "Member 'UArrowComponent::bIsScreenSizeScaled' has a wrong offset!");
static_assert(offsetof(UArrowComponent, ScreenSize) == 0x000874, "Member 'UArrowComponent::ScreenSize' has a wrong offset!");

// Class Engine.AnimClassData
// 0x0070 (0x00B0 - 0x0040)
class UAnimClassData final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBakedAnimationStateMachine>    BakedStateMachines;                                // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class USkeleton*                              TargetSkeleton;                                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               AnimNotifies;                                      // 0x0060(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         RootAnimNodeIndex;                                 // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OrderedSavedPoseIndices;                           // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UStructProperty*                        RootAnimNodeProperty;                              // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStructProperty*>                AnimNodeProperties;                                // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SyncGroupNames;                                    // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimClassData">();
	}
	static class UAnimClassData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimClassData>();
	}
};
static_assert(alignof(UAnimClassData) == 0x000008, "Wrong alignment on UAnimClassData");
static_assert(sizeof(UAnimClassData) == 0x0000B0, "Wrong size on UAnimClassData");
static_assert(offsetof(UAnimClassData, BakedStateMachines) == 0x000048, "Member 'UAnimClassData::BakedStateMachines' has a wrong offset!");
static_assert(offsetof(UAnimClassData, TargetSkeleton) == 0x000058, "Member 'UAnimClassData::TargetSkeleton' has a wrong offset!");
static_assert(offsetof(UAnimClassData, AnimNotifies) == 0x000060, "Member 'UAnimClassData::AnimNotifies' has a wrong offset!");
static_assert(offsetof(UAnimClassData, RootAnimNodeIndex) == 0x000070, "Member 'UAnimClassData::RootAnimNodeIndex' has a wrong offset!");
static_assert(offsetof(UAnimClassData, OrderedSavedPoseIndices) == 0x000078, "Member 'UAnimClassData::OrderedSavedPoseIndices' has a wrong offset!");
static_assert(offsetof(UAnimClassData, RootAnimNodeProperty) == 0x000088, "Member 'UAnimClassData::RootAnimNodeProperty' has a wrong offset!");
static_assert(offsetof(UAnimClassData, AnimNodeProperties) == 0x000090, "Member 'UAnimClassData::AnimNodeProperties' has a wrong offset!");
static_assert(offsetof(UAnimClassData, SyncGroupNames) == 0x0000A0, "Member 'UAnimClassData::SyncGroupNames' has a wrong offset!");

// Class Engine.TextRenderComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UTextRenderComponent : public UPrimitiveComponent
{
public:
	class FText                                   Text;                                              // 0x0868(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TextMaterial;                                      // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizTextAligment                            HorizontalAlignment;                               // 0x0890(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalTextAligment                         VerticalAlignment;                                 // 0x0891(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_892[0x2];                                      // 0x0892(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 TextRenderColor;                                   // 0x0894(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XScale;                                            // 0x0898(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YScale;                                            // 0x089C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSize;                                         // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvDefaultSize;                                    // 0x08A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizSpacingAdjust;                                // 0x08A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertSpacingAdjust;                                 // 0x08AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysRenderAsText : 1;                           // 0x08B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8B1[0x7];                                      // 0x08B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetText(const class FText& Value);
	void SetFont(class UFont* Value);
	void SetHorizontalAlignment(EHorizTextAligment Value);
	void SetHorizSpacingAdjust(float Value);
	void SetText(const class FString& Value);
	void SetTextMaterial(class UMaterialInterface* Material);
	void SetTextRenderColor(const struct FColor& Value);
	void SetVerticalAlignment(EVerticalTextAligment Value);
	void SetVertSpacingAdjust(float Value);
	void SetWorldSize(float Value);
	void SetXScale(float Value);
	void SetYScale(float Value);

	struct FVector GetTextLocalSize() const;
	struct FVector GetTextWorldSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextRenderComponent">();
	}
	static class UTextRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextRenderComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTextRenderComponent) == 0x112E9AF0, "Wrong alignment on UTextRenderComponent");
static_assert(sizeof(UTextRenderComponent) == 0x112E9AF0, "Wrong size on UTextRenderComponent");
static_assert(offsetof(UTextRenderComponent, Text) == 0x000868, "Member 'UTextRenderComponent::Text' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, TextMaterial) == 0x000880, "Member 'UTextRenderComponent::TextMaterial' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, Font) == 0x000888, "Member 'UTextRenderComponent::Font' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, HorizontalAlignment) == 0x000890, "Member 'UTextRenderComponent::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, VerticalAlignment) == 0x000891, "Member 'UTextRenderComponent::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, TextRenderColor) == 0x000894, "Member 'UTextRenderComponent::TextRenderColor' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, XScale) == 0x000898, "Member 'UTextRenderComponent::XScale' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, YScale) == 0x00089C, "Member 'UTextRenderComponent::YScale' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, WorldSize) == 0x0008A0, "Member 'UTextRenderComponent::WorldSize' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, InvDefaultSize) == 0x0008A4, "Member 'UTextRenderComponent::InvDefaultSize' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, HorizSpacingAdjust) == 0x0008A8, "Member 'UTextRenderComponent::HorizSpacingAdjust' has a wrong offset!");
static_assert(offsetof(UTextRenderComponent, VertSpacingAdjust) == 0x0008AC, "Member 'UTextRenderComponent::VertSpacingAdjust' has a wrong offset!");

// Class Engine.NavTestRenderingComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UNavTestRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavTestRenderingComponent">();
	}
	static class UNavTestRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavTestRenderingComponent>();
	}
};
static_assert(alignof(UNavTestRenderingComponent) == 0x112E9AF0, "Wrong alignment on UNavTestRenderingComponent");
static_assert(sizeof(UNavTestRenderingComponent) == 0x112E9AF0, "Wrong size on UNavTestRenderingComponent");

// Class Engine.DecalComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UDecalComponent : public USceneComponent
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeStartDelay;                                    // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDestroyOwnerAfterFade : 1;                        // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DecalSize;                                         // 0x0434(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SqexEnableForceRecive;                             // 0x0440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x1F];                                     // 0x0441(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
	void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);
	void SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade);
	void SetFadeScreenSize(float NewFadeScreenSize);
	void SetSortOrder(int32 Value);

	class UMaterialInterface* GetDecalMaterial() const;
	float GetFadeDuration() const;
	float GetFadeStartDelay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalComponent">();
	}
	static class UDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDecalComponent) == 0x112E9AF0, "Wrong alignment on UDecalComponent");
static_assert(sizeof(UDecalComponent) == 0x112E9AF0, "Wrong size on UDecalComponent");
static_assert(offsetof(UDecalComponent, DecalMaterial) == 0x000418, "Member 'UDecalComponent::DecalMaterial' has a wrong offset!");
static_assert(offsetof(UDecalComponent, SortOrder) == 0x000420, "Member 'UDecalComponent::SortOrder' has a wrong offset!");
static_assert(offsetof(UDecalComponent, FadeScreenSize) == 0x000424, "Member 'UDecalComponent::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(UDecalComponent, FadeStartDelay) == 0x000428, "Member 'UDecalComponent::FadeStartDelay' has a wrong offset!");
static_assert(offsetof(UDecalComponent, FadeDuration) == 0x00042C, "Member 'UDecalComponent::FadeDuration' has a wrong offset!");
static_assert(offsetof(UDecalComponent, DecalSize) == 0x000434, "Member 'UDecalComponent::DecalSize' has a wrong offset!");
static_assert(offsetof(UDecalComponent, SqexEnableForceRecive) == 0x000440, "Member 'UDecalComponent::SqexEnableForceRecive' has a wrong offset!");

// Class Engine.NetworkSettings
// 0x0010 (0x0060 - 0x0050)
class UNetworkSettings final : public UDeveloperSettings
{
public:
	uint8                                         bVerifyPeer : 1;                                   // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMultiplayerWorldOriginRebasing : 1;         // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRepArraySize;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRepArrayMemory;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkSettings">();
	}
	static class UNetworkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkSettings>();
	}
};
static_assert(alignof(UNetworkSettings) == 0x000008, "Wrong alignment on UNetworkSettings");
static_assert(sizeof(UNetworkSettings) == 0x000060, "Wrong size on UNetworkSettings");
static_assert(offsetof(UNetworkSettings, MaxRepArraySize) == 0x000054, "Member 'UNetworkSettings::MaxRepArraySize' has a wrong offset!");
static_assert(offsetof(UNetworkSettings, MaxRepArrayMemory) == 0x000058, "Member 'UNetworkSettings::MaxRepArrayMemory' has a wrong offset!");

// Class Engine.SphereComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USphereComponent : public UShapeComponent
{
public:
	float                                         SphereRadius;                                      // 0x0888(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88C[0x4];                                      // 0x088C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps);

	float GetScaledSphereRadius() const;
	float GetShapeScale() const;
	float GetUnscaledSphereRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereComponent">();
	}
	static class USphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USphereComponent>();
	}
};
static_assert(alignof(USphereComponent) == 0x112E9AF0, "Wrong alignment on USphereComponent");
static_assert(sizeof(USphereComponent) == 0x112E9AF0, "Wrong size on USphereComponent");
static_assert(offsetof(USphereComponent, SphereRadius) == 0x000888, "Member 'USphereComponent::SphereRadius' has a wrong offset!");

// Class Engine.ParticleModuleSpawnPerUnit
// 0x0050 (0x00A8 - 0x0058)
class UParticleModuleSpawnPerUnit final : public UParticleModuleSpawnBase
{
public:
	float                                         UnitScalar;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SpawnPerUnit;                                      // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreSpawnRateWhenMoving : 1;                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementTolerance;                                 // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFrameDistance;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreMovementAlongX : 1;                         // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreMovementAlongY : 1;                         // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreMovementAlongZ : 1;                         // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSpawnPerUnit">();
	}
	static class UParticleModuleSpawnPerUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSpawnPerUnit>();
	}
};
static_assert(alignof(UParticleModuleSpawnPerUnit) == 0x000008, "Wrong alignment on UParticleModuleSpawnPerUnit");
static_assert(sizeof(UParticleModuleSpawnPerUnit) == 0x0000A8, "Wrong size on UParticleModuleSpawnPerUnit");
static_assert(offsetof(UParticleModuleSpawnPerUnit, UnitScalar) == 0x000058, "Member 'UParticleModuleSpawnPerUnit::UnitScalar' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawnPerUnit, SpawnPerUnit) == 0x000060, "Member 'UParticleModuleSpawnPerUnit::SpawnPerUnit' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawnPerUnit, MovementTolerance) == 0x00009C, "Member 'UParticleModuleSpawnPerUnit::MovementTolerance' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawnPerUnit, MaxFrameDistance) == 0x0000A0, "Member 'UParticleModuleSpawnPerUnit::MaxFrameDistance' has a wrong offset!");

// Class Engine.MaterialExpressionTextureSampleParameter
// 0x0000 (0x112F2730 - 0x112F2730)
#pragma pack(push, 0x1)
class alignas(0x112F2730) UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
public:
	class FName                                   ParameterName;                                     // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x01B8(0x112E8D20)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Group;                                             // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureSampleParameter">();
	}
	static class UMaterialExpressionTextureSampleParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureSampleParameter>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaterialExpressionTextureSampleParameter) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureSampleParameter");
static_assert(sizeof(UMaterialExpressionTextureSampleParameter) == 0x112F2730, "Wrong size on UMaterialExpressionTextureSampleParameter");
static_assert(offsetof(UMaterialExpressionTextureSampleParameter, ParameterName) == 0x0001B0, "Member 'UMaterialExpressionTextureSampleParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSampleParameter, ExpressionGUID) == 0x0001B8, "Member 'UMaterialExpressionTextureSampleParameter::ExpressionGUID' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureSampleParameter, Group) == 0x0001C8, "Member 'UMaterialExpressionTextureSampleParameter::Group' has a wrong offset!");

// Class Engine.MaterialExpressionTextureSampleParameter2D
// 0x0000 (0x112F2730 - 0x112F2730)
#pragma pack(push, 0x1)
class alignas(0x112F2730) UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureSampleParameter2D">();
	}
	static class UMaterialExpressionTextureSampleParameter2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureSampleParameter2D>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaterialExpressionTextureSampleParameter2D) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureSampleParameter2D");
static_assert(sizeof(UMaterialExpressionTextureSampleParameter2D) == 0x112F2730, "Wrong size on UMaterialExpressionTextureSampleParameter2D");

// Class Engine.MaterialExpressionAntialiasedTextureMask
// 0x0000 (0x112F2730 - 0x112F2730)
class UMaterialExpressionAntialiasedTextureMask final : public UMaterialExpressionTextureSampleParameter2D
{
public:
	float                                         Threshold;                                         // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureColorChannel                          Channel;                                           // 0x01D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAntialiasedTextureMask">();
	}
	static class UMaterialExpressionAntialiasedTextureMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAntialiasedTextureMask>();
	}
};
static_assert(alignof(UMaterialExpressionAntialiasedTextureMask) == 0x112F2730, "Wrong alignment on UMaterialExpressionAntialiasedTextureMask");
static_assert(sizeof(UMaterialExpressionAntialiasedTextureMask) == 0x112F2730, "Wrong size on UMaterialExpressionAntialiasedTextureMask");
static_assert(offsetof(UMaterialExpressionAntialiasedTextureMask, Threshold) == 0x0001D0, "Member 'UMaterialExpressionAntialiasedTextureMask::Threshold' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAntialiasedTextureMask, Channel) == 0x0001D4, "Member 'UMaterialExpressionAntialiasedTextureMask::Channel' has a wrong offset!");

// Class Engine.SQEX_DecalComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) USQEX_DecalComponent : public UDecalComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_DecalComponent">();
	}
	static class USQEX_DecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_DecalComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USQEX_DecalComponent) == 0x112E9AF0, "Wrong alignment on USQEX_DecalComponent");
static_assert(sizeof(USQEX_DecalComponent) == 0x112E9AF0, "Wrong size on USQEX_DecalComponent");

// Class Engine.MaterialExpressionArccosineFast
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArccosineFast final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArccosineFast">();
	}
	static class UMaterialExpressionArccosineFast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArccosineFast>();
	}
};
static_assert(alignof(UMaterialExpressionArccosineFast) == 0x112F2730, "Wrong alignment on UMaterialExpressionArccosineFast");
static_assert(sizeof(UMaterialExpressionArccosineFast) == 0x112F2730, "Wrong size on UMaterialExpressionArccosineFast");
static_assert(offsetof(UMaterialExpressionArccosineFast, Input) == 0x000078, "Member 'UMaterialExpressionArccosineFast::Input' has a wrong offset!");

// Class Engine.Distribution
// 0x0008 (0x0048 - 0x0040)
class UDistribution : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Distribution">();
	}
	static class UDistribution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistribution>();
	}
};
static_assert(alignof(UDistribution) == 0x000008, "Wrong alignment on UDistribution");
static_assert(sizeof(UDistribution) == 0x000048, "Wrong size on UDistribution");

// Class Engine.DistributionVector
// 0x0008 (0x0050 - 0x0048)
class UDistributionVector : public UDistribution
{
public:
	uint8                                         bCanBeBaked : 1;                                   // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDirty : 1;                                      // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBakedDataSuccesfully : 1;                         // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVector">();
	}
	static class UDistributionVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVector>();
	}
};
static_assert(alignof(UDistributionVector) == 0x000008, "Wrong alignment on UDistributionVector");
static_assert(sizeof(UDistributionVector) == 0x000050, "Wrong size on UDistributionVector");

// Class Engine.DistributionVectorUniform
// 0x0028 (0x0078 - 0x0050)
class UDistributionVectorUniform final : public UDistributionVector
{
public:
	struct FVector                                Max;                                               // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockAxes : 1;                                     // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDistributionVectorLockFlags                  LockedAxes;                                        // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistributionVectorMirrorFlags                MirrorFlags[0x3];                                  // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseExtremes : 1;                                  // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorUniform">();
	}
	static class UDistributionVectorUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorUniform>();
	}
};
static_assert(alignof(UDistributionVectorUniform) == 0x000008, "Wrong alignment on UDistributionVectorUniform");
static_assert(sizeof(UDistributionVectorUniform) == 0x000078, "Wrong size on UDistributionVectorUniform");
static_assert(offsetof(UDistributionVectorUniform, Max) == 0x000050, "Member 'UDistributionVectorUniform::Max' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniform, Min) == 0x00005C, "Member 'UDistributionVectorUniform::Min' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniform, LockedAxes) == 0x00006C, "Member 'UDistributionVectorUniform::LockedAxes' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniform, MirrorFlags) == 0x00006D, "Member 'UDistributionVectorUniform::MirrorFlags' has a wrong offset!");

// Class Engine.LineBatchComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class ULineBatchComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LineBatchComponent">();
	}
	static class ULineBatchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULineBatchComponent>();
	}
};
static_assert(alignof(ULineBatchComponent) == 0x112E9AF0, "Wrong alignment on ULineBatchComponent");
static_assert(sizeof(ULineBatchComponent) == 0x112E9AF0, "Wrong size on ULineBatchComponent");

// Class Engine.SoundNode
// 0x0010 (0x0050 - 0x0040)
class USoundNode : public UObject
{
public:
	TArray<class USoundNode*>                     ChildNodes;                                        // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNode">();
	}
	static class USoundNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNode>();
	}
};
static_assert(alignof(USoundNode) == 0x000008, "Wrong alignment on USoundNode");
static_assert(sizeof(USoundNode) == 0x000050, "Wrong size on USoundNode");
static_assert(offsetof(USoundNode, ChildNodes) == 0x000040, "Member 'USoundNode::ChildNodes' has a wrong offset!");

// Class Engine.SoundNodeMature
// 0x0000 (0x0050 - 0x0050)
class USoundNodeMature final : public USoundNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeMature">();
	}
	static class USoundNodeMature* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeMature>();
	}
};
static_assert(alignof(USoundNodeMature) == 0x000008, "Wrong alignment on USoundNodeMature");
static_assert(sizeof(USoundNodeMature) == 0x000050, "Wrong size on USoundNodeMature");

// Class Engine.PlayerController
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) APlayerController : public AController
{
public:
	class UPlayer*                                Player;                                            // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  AcknowledgedPawn;                                  // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrackInstDirector*               ControllingDirTrackInst;                           // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHUD*                                   MyHUD;                                             // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCameraManager*                   PlayerCameraManager;                               // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerCameraManager>       PlayerCameraManagerClass;                          // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoManageActiveCameraTarget;                     // 0x0488(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetViewRotation;                                // 0x048C(0x112E9AF0)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SmoothTargetViewRotationSpeed;                     // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         HiddenActors;                                      // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> HiddenPrimitiveComponents;                         // 0x04B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x4];                                      // 0x04C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSpectatorStateSynchTime;                       // 0x04CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSpectatorSyncLocation;                         // 0x04D0(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastSpectatorSyncRotation;                         // 0x04DC(0x112E9AF0)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ClientCap;                                         // 0x04E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheatManager*                          CheatManager;                                      // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCheatManager>              CheatClass;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerInput*                           PlayerInput;                                       // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveForceFeedbackEffect>     ActiveForceFeedbackEffects;                        // 0x0508(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x90];                                     // 0x0518(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_5A8_0 : 3;                                  // 0x05A8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bPlayerIsWaiting : 1;                              // 0x05A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         NetPlayerIndex;                                    // 0x05AC(0x0001)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AD[0x3B];                                     // 0x05AD(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetConnection*                         PendingSwapConnection;                             // 0x05E8(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetConnection*                         NetConnection;                                     // 0x05F0(0x0008)(ZeroConstructor, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0xC];                                      // 0x05F8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputYawScale;                                     // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputPitchScale;                                   // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputRollScale;                                    // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowMouseCursor : 1;                              // 0x0610(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableClickEvents : 1;                            // 0x0610(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableTouchEvents : 1;                            // 0x0610(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMouseOverEvents : 1;                        // 0x0610(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableTouchOverEvents : 1;                        // 0x0610(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceFeedbackEnabled : 1;                         // 0x0610(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceFeedbackScale;                                // 0x0614(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           ClickEventKeys;                                    // 0x0618(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EMouseCursor                                  DefaultMouseCursor;                                // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseCursor                                  CurrentMouseCursor;                                // 0x0629(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DefaultClickTraceChannel;                          // 0x062A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CurrentClickTraceChannel;                          // 0x062B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitResultTraceDistance;                            // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x170];                                    // 0x0630(0x0170)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InactiveStateInputComponent;                       // 0x07A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BitPad_7A8_0 : 3;                                  // 0x07A8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bShouldPerformFullTickWhenPaused : 1;              // 0x07A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7A9[0x17];                                     // 0x07A9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UTouchInterface*                        CurrentTouchInterface;                             // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0x40];                                     // 0x07C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpectatorPawn*                         SpectatorPawn;                                     // 0x0808(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                SpawnLocation;                                     // 0x0810(0x000C)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81C[0x4];                                      // 0x081C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLocalPlayerController;                          // 0x0820(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_821[0x1];                                      // 0x0821(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        SeamlessTravelCount;                               // 0x0822(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        LastCompletedSeamlessTravelCount;                  // 0x0824(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_826[0x2];                                      // 0x0826(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateTouchInterface(class UTouchInterface* NewTouchInterface);
	void AddPitchInput(float Val);
	void AddRollInput(float Val);
	void AddYawInput(float Val);
	void Camera(class FName NewMode);
	void ClearAudioListenerOverride();
	void ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation);
	void ClientCancelPendingMapChange();
	void ClientCapBandwidth(int32 Cap);
	void ClientClearCameraLensEffects();
	void ClientCommitMapChange();
	void ClientEnableNetworkVoice(bool bEnable);
	void ClientEndOnlineSession();
	void ClientFlushLevelStreaming();
	void ClientForceGarbageCollection();
	void ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner);
	void ClientGotoState(class FName NewState);
	void ClientIgnoreLookInput(bool bIgnore);
	void ClientIgnoreMoveInput(bool bIgnore);
	void ClientMessage(const class FString& S, class FName Type, float MsgLifeTime);
	void ClientMutePlayer(const struct FUniqueNetIdRepl& PlayerId);
	void ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, ECameraAnimPlaySpace Space, const struct FRotator& CustomPlaySpace);
	void ClientPlayCameraShake(TSubclassOf<class UCameraShake> Shake, float Scale, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot, class AActor* OwnerActor, float In_OscillationDuration);
	void ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, class FName Tag);
	void ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
	void ClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier);
	void ClientPrepareMapChange(class FName LevelName, bool bFirst, bool bLast);
	void ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32 CinematicTextureGroups);
	void ClientReceiveLocalizedMessage(TSubclassOf<class ULocalMessage> Message, int32 Switch, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject);
	void ClientRepObjRef(class UObject* Object);
	void ClientReset();
	void ClientRestart(class APawn* NewPawn);
	void ClientRetryClientRestart(class APawn* NewPawn);
	void ClientReturnToMainMenu(const class FString& ReturnReason);
	void ClientSetBlockOnAsyncLoading();
	void ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio);
	void ClientSetCameraMode(class FName NewCamMode);
	void ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
	void ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int32 CinematicTextureGroups);
	void ClientSetHUD(TSubclassOf<class AHUD> NewHUDClass);
	void ClientSetSpectatorWaiting(bool bWaiting);
	void ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams);
	void ClientSpawnCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
	void ClientStartOnlineSession();
	void ClientStopCameraAnim(class UCameraAnim* AnimToStop);
	void ClientStopCameraShake(TSubclassOf<class UCameraShake> Shake, bool bImmediately);
	void ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	void ClientTeamMessage(class APlayerState* SenderPlayerState, const class FString& S, class FName Type, float MsgLifeTime);
	void ClientTravel(const class FString& URL, ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid);
	void ClientTravelInternal(const class FString& URL, ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid);
	void ClientUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId);
	void ClientUpdateLevelStreamingStatus(class FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32 LODIndex);
	void ClientVoiceHandshakeComplete();
	void ClientWasKicked(const class FText& KickReason);
	void ConsoleKey(const struct FKey& Key);
	void EnableCheats();
	void FOV(float NewFOV);
	void LocalTravel(const class FString& URL);
	void OnServerStartedVisualLogger(bool bIsLogging);
	void Pause();
	void PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, EDynamicForceFeedbackAction Action, const struct FLatentActionInfo& LatentInfo);
	void PlayHapticEffect(class UHapticFeedbackEffect_Base* HapticEffect, EControllerHand Hand, float Scale, bool bLoop);
	void RestartLevel();
	void SendToConsole(const class FString& Command);
	void ServerAcknowledgePossession(class APawn* P);
	void ServerCamera(class FName NewMode);
	void ServerChangeName(const class FString& S);
	void ServerCheckClientPossession();
	void ServerCheckClientPossessionReliable();
	void ServerMutePlayer(const struct FUniqueNetIdRepl& PlayerId);
	void ServerNotifyLoadedWorld(class FName WorldPackageName);
	void ServerPause();
	void ServerRestartPlayer();
	void ServerSetSpectatorLocation(const struct FVector& NewLoc, const struct FRotator& NewRot);
	void ServerSetSpectatorWaiting(bool bWaiting);
	void ServerShortTimeout();
	void ServerToggleAILogging();
	void ServerUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId);
	void ServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int32 CamPitchAndYaw);
	void ServerUpdateLevelVisibility(class FName PackageName, bool bIsVisible);
	void ServerVerifyViewTarget();
	void ServerViewNextPlayer();
	void ServerViewPrevPlayer();
	void ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams);
	void SetAudioListenerOverride(class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation);
	void SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
	void SetControllerLightColor(const struct FColor& Color);
	void SetHapticsByValue(const float Frequency, const float Amplitude, EControllerHand Hand);
	void SetMouseCursorWidget(EMouseCursor Cursor, class UUserWidget* CursorWidget);
	void SetMouseLocation(const int32 X, const int32 Y);
	void SetName(const class FString& S);
	void SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing);
	void SetVirtualJoystickVisibility(bool bVisible);
	void StartFire(uint8 FireModeNum);
	void StopHapticEffect(EControllerHand Hand);
	void SwitchLevel(const class FString& URL);
	void ToggleSpeaking(bool bInSpeaking);

	bool DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection) const;
	bool DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection) const;
	struct FVector GetFocalLocation() const;
	bool GetHitResultUnderCursor(ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const;
	bool GetHitResultUnderCursorByChannel(ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const;
	bool GetHitResultUnderCursorForObjects(const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult) const;
	bool GetHitResultUnderFinger(ETouchIndex FingerIndex, ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const;
	bool GetHitResultUnderFingerByChannel(ETouchIndex FingerIndex, ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const;
	bool GetHitResultUnderFingerForObjects(ETouchIndex FingerIndex, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult) const;
	class AHUD* GetHUD() const;
	float GetInputAnalogKeyState(const struct FKey& Key) const;
	void GetInputAnalogStickState(EControllerAnalogStick WhichStick, float* StickX, float* StickY) const;
	float GetInputKeyTimeDown(const struct FKey& Key) const;
	void GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration) const;
	void GetInputMouseDelta(float* DeltaX, float* DeltaY) const;
	void GetInputTouchState(ETouchIndex FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed) const;
	struct FVector GetInputVectorKeyState(const struct FKey& Key) const;
	bool GetMousePosition(float* LocationX, float* LocationY) const;
	class ASpectatorPawn* GetSpectatorPawn() const;
	void GetViewportSize(int32* SizeX, int32* SizeY) const;
	bool IsInputKeyDown(const struct FKey& Key) const;
	bool ProjectWorldLocationToScreen(const struct FVector& WorldLocation, struct FVector2D* ScreenLocation, bool bPlayerViewportRelative) const;
	ESqEX_LastInputDeviceType SqEX_GetLastAnalogStickInputDeviceType(EControllerAnalogStick WhichStick) const;
	ESqEX_LastInputDeviceType SqEX_GetLastInputKeyDeviceType(const struct FKey& Key) const;
	bool WasInputKeyJustPressed(const struct FKey& Key) const;
	bool WasInputKeyJustReleased(const struct FKey& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerController">();
	}
	static class APlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerController>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerController) == 0x1EF72E00, "Wrong alignment on APlayerController");
static_assert(sizeof(APlayerController) == 0x1EF72E00, "Wrong size on APlayerController");
static_assert(offsetof(APlayerController, Player) == 0x000448, "Member 'APlayerController::Player' has a wrong offset!");
static_assert(offsetof(APlayerController, AcknowledgedPawn) == 0x000458, "Member 'APlayerController::AcknowledgedPawn' has a wrong offset!");
static_assert(offsetof(APlayerController, ControllingDirTrackInst) == 0x000460, "Member 'APlayerController::ControllingDirTrackInst' has a wrong offset!");
static_assert(offsetof(APlayerController, MyHUD) == 0x000470, "Member 'APlayerController::MyHUD' has a wrong offset!");
static_assert(offsetof(APlayerController, PlayerCameraManager) == 0x000478, "Member 'APlayerController::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(APlayerController, PlayerCameraManagerClass) == 0x000480, "Member 'APlayerController::PlayerCameraManagerClass' has a wrong offset!");
static_assert(offsetof(APlayerController, bAutoManageActiveCameraTarget) == 0x000488, "Member 'APlayerController::bAutoManageActiveCameraTarget' has a wrong offset!");
static_assert(offsetof(APlayerController, TargetViewRotation) == 0x00048C, "Member 'APlayerController::TargetViewRotation' has a wrong offset!");
static_assert(offsetof(APlayerController, SmoothTargetViewRotationSpeed) == 0x0004A4, "Member 'APlayerController::SmoothTargetViewRotationSpeed' has a wrong offset!");
static_assert(offsetof(APlayerController, HiddenActors) == 0x0004A8, "Member 'APlayerController::HiddenActors' has a wrong offset!");
static_assert(offsetof(APlayerController, HiddenPrimitiveComponents) == 0x0004B8, "Member 'APlayerController::HiddenPrimitiveComponents' has a wrong offset!");
static_assert(offsetof(APlayerController, LastSpectatorStateSynchTime) == 0x0004CC, "Member 'APlayerController::LastSpectatorStateSynchTime' has a wrong offset!");
static_assert(offsetof(APlayerController, LastSpectatorSyncLocation) == 0x0004D0, "Member 'APlayerController::LastSpectatorSyncLocation' has a wrong offset!");
static_assert(offsetof(APlayerController, LastSpectatorSyncRotation) == 0x0004DC, "Member 'APlayerController::LastSpectatorSyncRotation' has a wrong offset!");
static_assert(offsetof(APlayerController, ClientCap) == 0x0004E8, "Member 'APlayerController::ClientCap' has a wrong offset!");
static_assert(offsetof(APlayerController, CheatManager) == 0x0004F0, "Member 'APlayerController::CheatManager' has a wrong offset!");
static_assert(offsetof(APlayerController, CheatClass) == 0x0004F8, "Member 'APlayerController::CheatClass' has a wrong offset!");
static_assert(offsetof(APlayerController, PlayerInput) == 0x000500, "Member 'APlayerController::PlayerInput' has a wrong offset!");
static_assert(offsetof(APlayerController, ActiveForceFeedbackEffects) == 0x000508, "Member 'APlayerController::ActiveForceFeedbackEffects' has a wrong offset!");
static_assert(offsetof(APlayerController, NetPlayerIndex) == 0x0005AC, "Member 'APlayerController::NetPlayerIndex' has a wrong offset!");
static_assert(offsetof(APlayerController, PendingSwapConnection) == 0x0005E8, "Member 'APlayerController::PendingSwapConnection' has a wrong offset!");
static_assert(offsetof(APlayerController, NetConnection) == 0x0005F0, "Member 'APlayerController::NetConnection' has a wrong offset!");
static_assert(offsetof(APlayerController, InputYawScale) == 0x000604, "Member 'APlayerController::InputYawScale' has a wrong offset!");
static_assert(offsetof(APlayerController, InputPitchScale) == 0x000608, "Member 'APlayerController::InputPitchScale' has a wrong offset!");
static_assert(offsetof(APlayerController, InputRollScale) == 0x00060C, "Member 'APlayerController::InputRollScale' has a wrong offset!");
static_assert(offsetof(APlayerController, ForceFeedbackScale) == 0x000614, "Member 'APlayerController::ForceFeedbackScale' has a wrong offset!");
static_assert(offsetof(APlayerController, ClickEventKeys) == 0x000618, "Member 'APlayerController::ClickEventKeys' has a wrong offset!");
static_assert(offsetof(APlayerController, DefaultMouseCursor) == 0x000628, "Member 'APlayerController::DefaultMouseCursor' has a wrong offset!");
static_assert(offsetof(APlayerController, CurrentMouseCursor) == 0x000629, "Member 'APlayerController::CurrentMouseCursor' has a wrong offset!");
static_assert(offsetof(APlayerController, DefaultClickTraceChannel) == 0x00062A, "Member 'APlayerController::DefaultClickTraceChannel' has a wrong offset!");
static_assert(offsetof(APlayerController, CurrentClickTraceChannel) == 0x00062B, "Member 'APlayerController::CurrentClickTraceChannel' has a wrong offset!");
static_assert(offsetof(APlayerController, HitResultTraceDistance) == 0x00062C, "Member 'APlayerController::HitResultTraceDistance' has a wrong offset!");
static_assert(offsetof(APlayerController, InactiveStateInputComponent) == 0x0007A0, "Member 'APlayerController::InactiveStateInputComponent' has a wrong offset!");
static_assert(offsetof(APlayerController, CurrentTouchInterface) == 0x0007C0, "Member 'APlayerController::CurrentTouchInterface' has a wrong offset!");
static_assert(offsetof(APlayerController, SpectatorPawn) == 0x000808, "Member 'APlayerController::SpectatorPawn' has a wrong offset!");
static_assert(offsetof(APlayerController, SpawnLocation) == 0x000810, "Member 'APlayerController::SpawnLocation' has a wrong offset!");
static_assert(offsetof(APlayerController, bIsLocalPlayerController) == 0x000820, "Member 'APlayerController::bIsLocalPlayerController' has a wrong offset!");
static_assert(offsetof(APlayerController, SeamlessTravelCount) == 0x000822, "Member 'APlayerController::SeamlessTravelCount' has a wrong offset!");
static_assert(offsetof(APlayerController, LastCompletedSeamlessTravelCount) == 0x000824, "Member 'APlayerController::LastCompletedSeamlessTravelCount' has a wrong offset!");

// Class Engine.FloatingPawnMovement
// 0x0000 (0x12A61 - 0x12A61)
#pragma pack(push, 0x1)
class alignas(0x12A61) UFloatingPawnMovement : public UPawnMovementComponent
{
public:
	float                                         MaxSpeed;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningBoost;                                      // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPositionCorrected : 1;                            // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatingPawnMovement">();
	}
	static class UFloatingPawnMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatingPawnMovement>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFloatingPawnMovement) == 0x012A61, "Wrong alignment on UFloatingPawnMovement");
static_assert(sizeof(UFloatingPawnMovement) == 0x012A61, "Wrong size on UFloatingPawnMovement");
static_assert(offsetof(UFloatingPawnMovement, MaxSpeed) == 0x000288, "Member 'UFloatingPawnMovement::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UFloatingPawnMovement, Acceleration) == 0x00028C, "Member 'UFloatingPawnMovement::Acceleration' has a wrong offset!");
static_assert(offsetof(UFloatingPawnMovement, Deceleration) == 0x000290, "Member 'UFloatingPawnMovement::Deceleration' has a wrong offset!");
static_assert(offsetof(UFloatingPawnMovement, TurningBoost) == 0x000294, "Member 'UFloatingPawnMovement::TurningBoost' has a wrong offset!");

// Class Engine.NodeMappingContainer
// 0x0070 (0x00B0 - 0x0040)
class UNodeMappingContainer final : public UObject
{
public:
	TMap<class FName, struct FNodeMap>            NodeMapping;                                       // 0x0040(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UBlueprint>              SourceAsset;                                       // 0x0090(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodeMappingContainer">();
	}
	static class UNodeMappingContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNodeMappingContainer>();
	}
};
static_assert(alignof(UNodeMappingContainer) == 0x000008, "Wrong alignment on UNodeMappingContainer");
static_assert(sizeof(UNodeMappingContainer) == 0x0000B0, "Wrong size on UNodeMappingContainer");
static_assert(offsetof(UNodeMappingContainer, NodeMapping) == 0x000040, "Member 'UNodeMappingContainer::NodeMapping' has a wrong offset!");
static_assert(offsetof(UNodeMappingContainer, SourceAsset) == 0x000090, "Member 'UNodeMappingContainer::SourceAsset' has a wrong offset!");

// Class Engine.GameplayStatics
// 0x0000 (0x0040 - 0x0040)
class UGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateReverbEffect(const class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, class FName TagName, float Priority, float Volume, float FadeTime);
	static float ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	static float ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	static bool ApplyRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel);
	static bool ApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel);
	static bool AreAnyListenersWithinRange(const class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange);
	static bool AreSubtitlesEnabled();
	static class AActor* BeginDeferredActorSpawnFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner);
	static class AActor* BeginSpawningActorFromBlueprint(const class UObject* WorldContextObject, const class UBlueprint* Blueprint, const struct FTransform& SpawnTransform, bool bNoCollisionFail);
	static class AActor* BeginSpawningActorFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, bool bNoCollisionFail, class AActor* Owner);
	static bool Blueprint_PredictProjectilePath_Advanced(const class UObject* WorldContextObject, const struct FPredictProjectilePathParams& PredictParams, struct FPredictProjectilePathResult* PredictResult);
	static bool Blueprint_PredictProjectilePath_ByObjectType(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
	static bool Blueprint_PredictProjectilePath_ByTraceChannel(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
	static bool BlueprintSuggestProjectileVelocity(const class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug);
	static void BreakHitResult(const struct FHitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, class FName* HitBoneName, int32* HitItem, int32* FaceIndex, struct FVector* TraceStart, struct FVector* TraceEnd);
	static void CancelAsyncLoading();
	static void ClearSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float FadeOutTime);
	static void ClearSoundMixModifiers(const class UObject* WorldContextObject);
	static class APlayerController* CreatePlayer(const class UObject* WorldContextObject, int32 ControllerId, bool bSpawnPawn);
	static class USaveGame* CreateSaveGameObject(TSubclassOf<class USaveGame> SaveGameClass);
	static class USaveGame* CreateSaveGameObjectFromBlueprint(class UBlueprint* SaveGameBlueprint);
	static class UAudioComponent* CreateSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy, bool SQEX_bWantsRecycle);
	static void DeactivateReverbEffect(const class UObject* WorldContextObject, class FName TagName);
	static bool DeleteGameInSlot(const class FString& SlotName, const int32 UserIndex);
	static bool DeprojectScreenToWorld(class APlayerController* Player, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection);
	static bool DoesSaveGameExist(const class FString& SlotName, const int32 UserIndex);
	static void EnableLiveStreaming(bool Enable);
	static bool FindCollisionUV(const struct FHitResult& Hit, int32 UVChannel, struct FVector2D* UV);
	static class AActor* FinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform);
	static void FlushLevelStreaming(const class UObject* WorldContextObject);
	static void GetAccurateRealTime(const class UObject* WorldContextObject, int32* Seconds, float* PartialSeconds);
	static struct FVector GetActorArrayAverageLocation(const TArray<class AActor*>& Actors);
	static void GetActorArrayBounds(const TArray<class AActor*>& Actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent);
	static void GetAllActorsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);
	static void GetAllActorsWithInterface(const class UObject* WorldContextObject, TSubclassOf<class IInterface> Interface, TArray<class AActor*>* OutActors);
	static void GetAllActorsWithTag(const class UObject* WorldContextObject, class FName Tag, TArray<class AActor*>* OutActors);
	static float GetAudioTimeSeconds(const class UObject* WorldContextObject);
	static class FString GetCurrentLevelName(const class UObject* WorldContextObject, bool bRemovePrefixString);
	static class UReverbEffect* GetCurrentReverbEffect(const class UObject* WorldContextObject);
	static class UGameInstance* GetGameInstance(const class UObject* WorldContextObject);
	static class AGameModeBase* GetGameMode(const class UObject* WorldContextObject);
	static class AGameStateBase* GetGameState(const class UObject* WorldContextObject);
	static float GetGlobalTimeDilation(const class UObject* WorldContextObject);
	static int32 GetIntOption(const class FString& Options, const class FString& Key, int32 DefaultValue);
	static void GetKeyValue(const class FString& Pair, class FString* Key, class FString* Value);
	static class UClass* GetObjectClass(const class UObject* Object);
	static class FString GetPlatformName();
	static class APlayerCameraManager* GetPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ACharacter* GetPlayerCharacter(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class APlayerController* GetPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
	static int32 GetPlayerControllerID(class APlayerController* Player);
	static class APawn* GetPlayerPawn(const class UObject* WorldContextObject, int32 PlayerIndex);
	static float GetRealTimeSeconds(const class UObject* WorldContextObject);
	static class ULevelStreaming* GetStreamingLevel(const class UObject* WorldContextObject, class FName PackageName);
	static EPhysicalSurface GetSurfaceType(const struct FHitResult& Hit);
	static float GetTimeSeconds(const class UObject* WorldContextObject);
	static float GetUnpausedTimeSeconds(const class UObject* WorldContextObject);
	static float GetWorldDeltaSeconds(const class UObject* WorldContextObject);
	static struct FIntVector GetWorldOriginLocation(const class UObject* WorldContextObject);
	static int32 GrassOverlappingSphereCount(const class UObject* WorldContextObject, const class UStaticMesh* StaticMesh, const struct FVector& CenterPosition, float Radius);
	static bool HasLaunchOption(const class FString& OptionToCheck);
	static bool HasOption(const class FString& Options, const class FString& InKey);
	static bool IsGamePaused(const class UObject* WorldContextObject);
	static class USaveGame* LoadGameFromSlot(const class FString& SlotName, const int32 UserIndex);
	static void LoadStreamLevel(const class UObject* WorldContextObject, class FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo);
	static struct FHitResult MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, const struct FVector& Location, const struct FVector& ImpactPoint, const struct FVector& Normal, const struct FVector& ImpactNormal, class UPhysicalMaterial* PhysMat, class AActor* HitActor, class UPrimitiveComponent* HitComponent, class FName HitBoneName, int32 HitItem, int32 FaceIndex, const struct FVector& TraceStart, const struct FVector& TraceEnd);
	static void OpenLevel(const class UObject* WorldContextObject, class FName LevelName, bool bAbsolute, const class FString& Options);
	static class FString ParseOption(const class FString& Options, const class FString& Key);
	static void PlayDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime);
	static void PlayDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings);
	static void PlaySound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings);
	static void PlaySoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings);
	static void PlayWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShake> Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter);
	static void PopSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier);
	static bool ProjectWorldToScreen(class APlayerController* Player, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition, bool bPlayerViewportRelative);
	static void PushSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier);
	static struct FVector RebaseLocalOriginOntoZero(class UObject* WorldContextObject, const struct FVector& WorldLocation);
	static struct FVector RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, const struct FVector& WorldLocation);
	static void RemovePlayer(class APlayerController* Player, bool bDestroyPawn);
	static bool SaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex);
	static void SetBaseSoundMix(const class UObject* WorldContextObject, class USoundMix* InSoundMix);
	static bool SetGamePaused(const class UObject* WorldContextObject, bool bPaused);
	static void SetGlobalListenerFocusParameters(const class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale);
	static void SetGlobalPitchModulation(const class UObject* WorldContextObject, float PitchModulation, float TimeSec);
	static void SetGlobalTimeDilation(const class UObject* WorldContextObject, float TimeDilation);
	static void SetPlayerControllerID(class APlayerController* Player, int32 ControllerId);
	static void SetSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren);
	static void SetSubtitlesEnabled(bool bEnabled);
	static void SetWorldOriginLocation(const class UObject* WorldContextObject, const struct FIntVector& NewLocation);
	static class UDecalComponent* SpawnDecalAtLocation(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan);
	static class UDecalComponent* SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan);
	static class UAudioComponent* SpawnDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy);
	static class UAudioComponent* SpawnDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class UAudioComponent* SpawnDialogueAttached(class UDialogueWave* Dialogue, const struct FDialogueContext& Context, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class UParticleSystemComponent* SpawnEmitterAtLocation(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, bool bAutoDestroy);
	static class UParticleSystemComponent* SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime, class AActor* In_Owner);
	static class UForceFeedbackComponent* SpawnForceFeedbackAtLocation(const class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class UForceFeedbackComponent* SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class UObject* SpawnObject(TSubclassOf<class UObject> ObjectClass, class UObject* Outer_0);
	static class UAudioComponent* SpawnSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy, bool SQEX_bWantsRecycle);
	static class UAudioComponent* SpawnSoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool SQEX_bWantsRecycle);
	static class UAudioComponent* SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool SQEX_bWantsRecycle);
	static void SQEX_SetLevelVisibility(class UObject* WorldContextObject, class FName PackageName, bool bVisibility, bool FlushAtOnce);
	static class UParticleSystemComponent* SqExSpawnEmitterAtLocation(class AActor* In_Outer, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAtLocationCleanupTarget(class AActor* In_Outer, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAtLocationKeywordSpawn(class AActor* In_Owner, const class FString& In_SpawnKeyword, int32 In_GroupID, const struct FVector& Location, const struct FRotator& Rotation, bool bAutoDestroy);
	static class UParticleSystemComponent* SqExSpawnEmitterAtLocationSetTag(const class FString& In_Tag, class AActor* In_Outer, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttachedCleanupTarget(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttachedSetAbsolute(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, bool bAbsoluteLocation, bool bAbsoluteRotation, bool bAbsoluteScale, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttachedSetAbsoluteCleanupTarget(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, bool bAbsoluteLocation, bool bAbsoluteRotation, bool bAbsoluteScale, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttachedSetOwner(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class AActor* In_Owner, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttachedSetOwnerCleanupTarget(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class AActor* In_Owner, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static class UParticleSystemComponent* SqExSpawnEmitterAttachedSetTag(const class FString& In_Tag, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, int32 In_GroupID, EAttachLocation LocationType, bool bAutoDestroy, float In_WarmupTime);
	static bool SuggestProjectileVelocity_CustomArc(const class UObject* WorldContextObject, struct FVector* OutLaunchVelocity, const struct FVector& StartPos, const struct FVector& EndPos, float OverrideGravityZ, float ArcParam);
	static void UnloadStreamLevel(const class UObject* WorldContextObject, class FName LevelName, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayStatics">();
	}
	static class UGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayStatics>();
	}
};
static_assert(alignof(UGameplayStatics) == 0x000008, "Wrong alignment on UGameplayStatics");
static_assert(sizeof(UGameplayStatics) == 0x000040, "Wrong size on UGameplayStatics");

// Class Engine.InterpTrackFloatAnimBPParam
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
#pragma pack(push, 0x1)
class alignas(0x112EC5B0) UInterpTrackFloatAnimBPParam : public UInterpTrackFloatBase
{
public:
	class UClass*                                 AnimBlueprintClass;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimClass;                                         // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackFloatAnimBPParam">();
	}
	static class UInterpTrackFloatAnimBPParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackFloatAnimBPParam>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackFloatAnimBPParam) == 0x112EC5B0, "Wrong alignment on UInterpTrackFloatAnimBPParam");
static_assert(sizeof(UInterpTrackFloatAnimBPParam) == 0x112EC5B0, "Wrong size on UInterpTrackFloatAnimBPParam");
static_assert(offsetof(UInterpTrackFloatAnimBPParam, AnimBlueprintClass) == 0x0000B0, "Member 'UInterpTrackFloatAnimBPParam::AnimBlueprintClass' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatAnimBPParam, AnimClass) == 0x0000B8, "Member 'UInterpTrackFloatAnimBPParam::AnimClass' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatAnimBPParam, ParamName) == 0x0000C0, "Member 'UInterpTrackFloatAnimBPParam::ParamName' has a wrong offset!");

// Class Engine.GameEngine
// 0x0000 (0x11637750 - 0x11637750)
class UGameEngine : public UEngine
{
public:
	float                                         MaxDeltaTime;                                      // 0x0E28(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerFlushLogInterval;                            // 0x0E2C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameInstance*                          GameInstance;                                      // 0x0E30(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E38[0x48];                                     // 0x0E38(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameEngine* GetEngine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEngine">();
	}
	static class UGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEngine>();
	}
};
static_assert(alignof(UGameEngine) == 0x11637750, "Wrong alignment on UGameEngine");
static_assert(sizeof(UGameEngine) == 0x11637750, "Wrong size on UGameEngine");
static_assert(offsetof(UGameEngine, MaxDeltaTime) == 0x000E28, "Member 'UGameEngine::MaxDeltaTime' has a wrong offset!");
static_assert(offsetof(UGameEngine, ServerFlushLogInterval) == 0x000E2C, "Member 'UGameEngine::ServerFlushLogInterval' has a wrong offset!");
static_assert(offsetof(UGameEngine, GameInstance) == 0x000E30, "Member 'UGameEngine::GameInstance' has a wrong offset!");

// Class Engine.InterpTrackInstColorProp
// 0x0010 (0x0060 - 0x0050)
class UInterpTrackInstColorProp : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ResetColor;                                        // 0x0058(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstColorProp">();
	}
	static class UInterpTrackInstColorProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstColorProp>();
	}
};
static_assert(alignof(UInterpTrackInstColorProp) == 0x000008, "Wrong alignment on UInterpTrackInstColorProp");
static_assert(sizeof(UInterpTrackInstColorProp) == 0x000060, "Wrong size on UInterpTrackInstColorProp");
static_assert(offsetof(UInterpTrackInstColorProp, ResetColor) == 0x000058, "Member 'UInterpTrackInstColorProp::ResetColor' has a wrong offset!");

// Class Engine.MaterialExpressionViewSize
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionViewSize final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionViewSize">();
	}
	static class UMaterialExpressionViewSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionViewSize>();
	}
};
static_assert(alignof(UMaterialExpressionViewSize) == 0x000008, "Wrong alignment on UMaterialExpressionViewSize");
static_assert(sizeof(UMaterialExpressionViewSize) == 0x000078, "Wrong size on UMaterialExpressionViewSize");

// Class Engine.ParticleModuleLocationPrimitiveBase
// 0x0090 (0x00E0 - 0x0050)
class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
public:
	uint8                                         Positive_X : 1;                                    // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Positive_Y : 1;                                    // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Positive_Z : 1;                                    // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Negative_X : 1;                                    // 0x0050(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Negative_Y : 1;                                    // 0x0050(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Negative_Z : 1;                                    // 0x0050(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SurfaceOnly : 1;                                   // 0x0050(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Velocity : 1;                                      // 0x0050(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  VelocityScale;                                     // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 StartLocation;                                     // 0x0090(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationPrimitiveBase">();
	}
	static class UParticleModuleLocationPrimitiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationPrimitiveBase>();
	}
};
static_assert(alignof(UParticleModuleLocationPrimitiveBase) == 0x000008, "Wrong alignment on UParticleModuleLocationPrimitiveBase");
static_assert(sizeof(UParticleModuleLocationPrimitiveBase) == 0x0000E0, "Wrong size on UParticleModuleLocationPrimitiveBase");
static_assert(offsetof(UParticleModuleLocationPrimitiveBase, VelocityScale) == 0x000058, "Member 'UParticleModuleLocationPrimitiveBase::VelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationPrimitiveBase, StartLocation) == 0x000090, "Member 'UParticleModuleLocationPrimitiveBase::StartLocation' has a wrong offset!");

// Class Engine.ParticleModuleLocationPrimitiveCylinder
// 0x0080 (0x0160 - 0x00E0)
class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
public:
	uint8                                         RadialVelocity : 1;                                // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  StartRadius;                                       // 0x00E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StartHeight;                                       // 0x0120(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECylinderHeightAxis                           HeightAxis;                                        // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationPrimitiveCylinder">();
	}
	static class UParticleModuleLocationPrimitiveCylinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationPrimitiveCylinder>();
	}
};
static_assert(alignof(UParticleModuleLocationPrimitiveCylinder) == 0x000008, "Wrong alignment on UParticleModuleLocationPrimitiveCylinder");
static_assert(sizeof(UParticleModuleLocationPrimitiveCylinder) == 0x000160, "Wrong size on UParticleModuleLocationPrimitiveCylinder");
static_assert(offsetof(UParticleModuleLocationPrimitiveCylinder, StartRadius) == 0x0000E8, "Member 'UParticleModuleLocationPrimitiveCylinder::StartRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationPrimitiveCylinder, StartHeight) == 0x000120, "Member 'UParticleModuleLocationPrimitiveCylinder::StartHeight' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationPrimitiveCylinder, HeightAxis) == 0x000158, "Member 'UParticleModuleLocationPrimitiveCylinder::HeightAxis' has a wrong offset!");

// Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded
// 0x0020 (0x0180 - 0x0160)
class UParticleModuleLocationPrimitiveCylinder_Seeded final : public UParticleModuleLocationPrimitiveCylinder
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0160(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationPrimitiveCylinder_Seeded">();
	}
	static class UParticleModuleLocationPrimitiveCylinder_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationPrimitiveCylinder_Seeded>();
	}
};
static_assert(alignof(UParticleModuleLocationPrimitiveCylinder_Seeded) == 0x000008, "Wrong alignment on UParticleModuleLocationPrimitiveCylinder_Seeded");
static_assert(sizeof(UParticleModuleLocationPrimitiveCylinder_Seeded) == 0x000180, "Wrong size on UParticleModuleLocationPrimitiveCylinder_Seeded");
static_assert(offsetof(UParticleModuleLocationPrimitiveCylinder_Seeded, RandomSeedInfo) == 0x000160, "Member 'UParticleModuleLocationPrimitiveCylinder_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.CameraComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UCameraComponent : public USceneComponent
{
public:
	float                                         FieldOfView;                                       // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoWidth;                                        // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoNearClipPlane;                                // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoFarClipPlane;                                 // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_NearClipPlane;                                   // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FarClipPlane;                                    // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_FarCullingPlane;                                 // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bConstrainAspectRatio : 1;                         // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFieldOfViewForLOD : 1;                         // 0x0438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockToHmd : 1;                                    // 0x0438(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePawnControlRotation : 1;                       // 0x0438(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraProjectionMode                         ProjectionMode;                                    // 0x043C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PostProcessBlendWeight;                            // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0xC];                                      // 0x0444(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0450(0x112EAE80)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	uint8                                         bUseControllerViewRotation : 1;                    // 0x0BE8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BE9[0x7];                                      // 0x0BE9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	void GetCameraView(float DeltaTime, struct FMinimalViewInfo* DesiredView);
	void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
	void SetAspectRatio(float InAspectRatio);
	void SetConstraintAspectRatio(bool bInConstrainAspectRatio);
	void SetFieldOfView(float InFieldOfView);
	void SetOrthoFarClipPlane(float InOrthoFarClipPlane);
	void SetOrthoNearClipPlane(float InOrthoNearClipPlane);
	void SetOrthoWidth(float InOrthoWidth);
	void SetPostProcessBlendWeight(float InPostProcessBlendWeight);
	void SetProjectionMode(ECameraProjectionMode InProjectionMode);
	void SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraComponent">();
	}
	static class UCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCameraComponent) == 0x112E9AF0, "Wrong alignment on UCameraComponent");
static_assert(sizeof(UCameraComponent) == 0x112E9AF0, "Wrong size on UCameraComponent");
static_assert(offsetof(UCameraComponent, FieldOfView) == 0x000418, "Member 'UCameraComponent::FieldOfView' has a wrong offset!");
static_assert(offsetof(UCameraComponent, OrthoWidth) == 0x00041C, "Member 'UCameraComponent::OrthoWidth' has a wrong offset!");
static_assert(offsetof(UCameraComponent, OrthoNearClipPlane) == 0x000420, "Member 'UCameraComponent::OrthoNearClipPlane' has a wrong offset!");
static_assert(offsetof(UCameraComponent, OrthoFarClipPlane) == 0x000424, "Member 'UCameraComponent::OrthoFarClipPlane' has a wrong offset!");
static_assert(offsetof(UCameraComponent, AspectRatio) == 0x000428, "Member 'UCameraComponent::AspectRatio' has a wrong offset!");
static_assert(offsetof(UCameraComponent, M_NearClipPlane) == 0x00042C, "Member 'UCameraComponent::M_NearClipPlane' has a wrong offset!");
static_assert(offsetof(UCameraComponent, M_FarClipPlane) == 0x000430, "Member 'UCameraComponent::M_FarClipPlane' has a wrong offset!");
static_assert(offsetof(UCameraComponent, M_FarCullingPlane) == 0x000434, "Member 'UCameraComponent::M_FarCullingPlane' has a wrong offset!");
static_assert(offsetof(UCameraComponent, ProjectionMode) == 0x00043C, "Member 'UCameraComponent::ProjectionMode' has a wrong offset!");
static_assert(offsetof(UCameraComponent, PostProcessBlendWeight) == 0x000440, "Member 'UCameraComponent::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(UCameraComponent, PostProcessSettings) == 0x000450, "Member 'UCameraComponent::PostProcessSettings' has a wrong offset!");

// Class Engine.MaterialExpressionDistanceFieldGradient
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDistanceFieldGradient final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Position;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDistanceFieldGradient">();
	}
	static class UMaterialExpressionDistanceFieldGradient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDistanceFieldGradient>();
	}
};
static_assert(alignof(UMaterialExpressionDistanceFieldGradient) == 0x112F2730, "Wrong alignment on UMaterialExpressionDistanceFieldGradient");
static_assert(sizeof(UMaterialExpressionDistanceFieldGradient) == 0x112F2730, "Wrong size on UMaterialExpressionDistanceFieldGradient");
static_assert(offsetof(UMaterialExpressionDistanceFieldGradient, Position) == 0x000078, "Member 'UMaterialExpressionDistanceFieldGradient::Position' has a wrong offset!");

// Class Engine.SpotLight
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASpotLight : public ALight
{
public:
	class USpotLightComponent*                    SpotLightComponent;                                // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetInnerConeAngle(float NewInnerConeAngle);
	void SetOuterConeAngle(float NewOuterConeAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotLight">();
	}
	static class ASpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpotLight>();
	}
};
static_assert(alignof(ASpotLight) == 0x1EF72E00, "Wrong alignment on ASpotLight");
static_assert(sizeof(ASpotLight) == 0x1EF72E00, "Wrong size on ASpotLight");
static_assert(offsetof(ASpotLight, SpotLightComponent) == 0x0003F0, "Member 'ASpotLight::SpotLightComponent' has a wrong offset!");

// Class Engine.GameInstance
// 0x0100 (0x0140 - 0x0040)
class UGameInstance : public UObject
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULocalPlayer*>                   LocalPlayers;                                      // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UOnlineSession*                         OnlineSession;                                     // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0xD8];                                      // 0x0068(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugCreatePlayer(int32 ControllerId);
	void DebugRemovePlayer(int32 ControllerId);
	void HandleNetworkError(ENetworkFailure FailureType, bool bIsServer);
	void HandleTravelError(ETravelFailure FailureType);
	void ReceiveInit();
	void ReceiveShutdown();
	void SqEX_ReceiveStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInstance">();
	}
	static class UGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInstance>();
	}
};
static_assert(alignof(UGameInstance) == 0x000008, "Wrong alignment on UGameInstance");
static_assert(sizeof(UGameInstance) == 0x000140, "Wrong size on UGameInstance");
static_assert(offsetof(UGameInstance, LocalPlayers) == 0x000050, "Member 'UGameInstance::LocalPlayers' has a wrong offset!");
static_assert(offsetof(UGameInstance, OnlineSession) == 0x000060, "Member 'UGameInstance::OnlineSession' has a wrong offset!");

// Class Engine.SoundConcurrency
// 0x1166C970 (0x1166C9B0 - 0x0040)
class USoundConcurrency final : public UObject
{
public:
	struct FSoundConcurrencySettings              Concurrency;                                       // 0x0040(0x1166C9B0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundConcurrency">();
	}
	static class USoundConcurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundConcurrency>();
	}
};
static_assert(alignof(USoundConcurrency) == 0x1166C9B0, "Wrong alignment on USoundConcurrency");
static_assert(sizeof(USoundConcurrency) == 0x1166C9B0, "Wrong size on USoundConcurrency");
static_assert(offsetof(USoundConcurrency, Concurrency) == 0x000040, "Member 'USoundConcurrency::Concurrency' has a wrong offset!");

// Class Engine.DeviceProfileManager
// 0x00E0 (0x0120 - 0x0040)
class UDeviceProfileManager final : public UObject
{
public:
	TArray<class UObject*>                        Profiles;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0xD0];                                      // 0x0050(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeviceProfileManager">();
	}
	static class UDeviceProfileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeviceProfileManager>();
	}
};
static_assert(alignof(UDeviceProfileManager) == 0x000008, "Wrong alignment on UDeviceProfileManager");
static_assert(sizeof(UDeviceProfileManager) == 0x000120, "Wrong size on UDeviceProfileManager");
static_assert(offsetof(UDeviceProfileManager, Profiles) == 0x000040, "Member 'UDeviceProfileManager::Profiles' has a wrong offset!");

// Class Engine.GameUserSettings
// 0x00E0 (0x0120 - 0x0040)
class UGameUserSettings : public UObject
{
public:
	bool                                          bUseVSync;                                         // 0x0040(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x4F];                                      // 0x0041(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ResolutionSizeX;                                   // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        ResolutionSizeY;                                   // 0x0094(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        LastUserConfirmedResolutionSizeX;                  // 0x0098(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        LastUserConfirmedResolutionSizeY;                  // 0x009C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WindowPosX;                                        // 0x00A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WindowPosY;                                        // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FullscreenMode;                                    // 0x00A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastConfirmedFullscreenMode;                       // 0x00AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreferredFullscreenMode;                           // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        Version;                                           // 0x00B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AudioQualityLevel;                                 // 0x00B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrameRateLimit;                                    // 0x00BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredScreenWidth;                                // 0x00C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDesiredScreenHeight;                           // 0x00C8(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredScreenHeight;                               // 0x00CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastRecommendedScreenWidth;                        // 0x00D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastRecommendedScreenHeight;                       // 0x00D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastCPUBenchmarkResult;                            // 0x00D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastGPUBenchmarkResult;                            // 0x00DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 LastCPUBenchmarkSteps;                             // 0x00E0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 LastGPUBenchmarkSteps;                             // 0x00F0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         LastGPUBenchmarkMultiplier;                        // 0x0100(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseHDRDisplayOutput;                              // 0x0104(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HDRDisplayOutputNits;                              // 0x0108(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnGameUserSettingsUINeedsUpdate;                   // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static struct FIntPoint GetDefaultResolution();
	static EWindowMode GetDefaultWindowMode();
	static struct FIntPoint GetDefaultWindowPosition();
	static class UGameUserSettings* GetGameUserSettings();

	void ApplyHardwareBenchmarkResults();
	void ApplyNonResolutionSettings();
	void ApplyResolutionSettings(bool bCheckForCommandLineOverrides);
	void ApplySettings(bool bCheckForCommandLineOverrides);
	void ConfirmVideoMode();
	void EnableHDRDisplayOutput(bool bEnable, int32 DisplayNits);
	float GetDefaultResolutionScale();
	float GetRecommendedResolutionScale();
	void LoadSettings(bool bForceReload);
	void ResetToCurrentSettings();
	void RevertVideoMode();
	void RunHardwareBenchmark(int32 WorkScale, float CPUMultiplier, float GPUMultiplier);
	void SaveSettings();
	void SetAntiAliasingQuality(int32 Value);
	void SetAudioQualityLevel(int32 QualityLevel);
	void SetBenchmarkFallbackValues();
	void SetFoliageQuality(int32 Value);
	void SetFrameRateLimit(float NewLimit);
	void SetFullscreenMode(EWindowMode InFullscreenMode);
	void SetOverallScalabilityLevel(int32 Value);
	void SetPostProcessingQuality(int32 Value);
	void SetResolutionScaleNormalized(float NewScaleNormalized);
	void SetResolutionScaleValue(int32 NewScaleValue);
	void SetResolutionScaleValueEx(float NewScaleValue);
	void SetScreenResolution(const struct FIntPoint& Resolution);
	void SetShadowQuality(int32 Value);
	void SetTextureQuality(int32 Value);
	void SetToDefaults();
	void SetViewDistanceQuality(int32 Value);
	void SetVisualEffectQuality(int32 Value);
	void SetVSyncEnabled(bool bEnable);
	void ValidateSettings();

	int32 GetAntiAliasingQuality() const;
	int32 GetAudioQualityLevel() const;
	int32 GetCurrentHDRDisplayNits() const;
	struct FIntPoint GetDesktopResolution() const;
	int32 GetFoliageQuality() const;
	float GetFrameRateLimit() const;
	EWindowMode GetFullscreenMode() const;
	EWindowMode GetLastConfirmedFullscreenMode() const;
	struct FIntPoint GetLastConfirmedScreenResolution() const;
	int32 GetOverallScalabilityLevel() const;
	int32 GetPostProcessingQuality() const;
	EWindowMode GetPreferredFullscreenMode() const;
	void GetResolutionScaleInformation(float* CurrentScaleNormalized, int32* CurrentScaleValue, int32* MinScaleValue, int32* MaxScaleValue) const;
	void GetResolutionScaleInformationEx(float* CurrentScaleNormalized, float* CurrentScaleValue, float* MinScaleValue, float* MaxScaleValue) const;
	struct FIntPoint GetScreenResolution() const;
	int32 GetShadowQuality() const;
	int32 GetTextureQuality() const;
	int32 GetViewDistanceQuality() const;
	int32 GetVisualEffectQuality() const;
	bool IsDirty() const;
	bool IsFullscreenModeDirty() const;
	bool IsHDREnabled() const;
	bool IsScreenResolutionDirty() const;
	bool IsVSyncDirty() const;
	bool IsVSyncEnabled() const;
	bool SupportsHDRDisplayOutput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameUserSettings">();
	}
	static class UGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameUserSettings>();
	}
};
static_assert(alignof(UGameUserSettings) == 0x000008, "Wrong alignment on UGameUserSettings");
static_assert(sizeof(UGameUserSettings) == 0x000120, "Wrong size on UGameUserSettings");
static_assert(offsetof(UGameUserSettings, bUseVSync) == 0x000040, "Member 'UGameUserSettings::bUseVSync' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, ResolutionSizeX) == 0x000090, "Member 'UGameUserSettings::ResolutionSizeX' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, ResolutionSizeY) == 0x000094, "Member 'UGameUserSettings::ResolutionSizeY' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastUserConfirmedResolutionSizeX) == 0x000098, "Member 'UGameUserSettings::LastUserConfirmedResolutionSizeX' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastUserConfirmedResolutionSizeY) == 0x00009C, "Member 'UGameUserSettings::LastUserConfirmedResolutionSizeY' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, WindowPosX) == 0x0000A0, "Member 'UGameUserSettings::WindowPosX' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, WindowPosY) == 0x0000A4, "Member 'UGameUserSettings::WindowPosY' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, FullscreenMode) == 0x0000A8, "Member 'UGameUserSettings::FullscreenMode' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastConfirmedFullscreenMode) == 0x0000AC, "Member 'UGameUserSettings::LastConfirmedFullscreenMode' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, PreferredFullscreenMode) == 0x0000B0, "Member 'UGameUserSettings::PreferredFullscreenMode' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, Version) == 0x0000B4, "Member 'UGameUserSettings::Version' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, AudioQualityLevel) == 0x0000B8, "Member 'UGameUserSettings::AudioQualityLevel' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, FrameRateLimit) == 0x0000BC, "Member 'UGameUserSettings::FrameRateLimit' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, DesiredScreenWidth) == 0x0000C4, "Member 'UGameUserSettings::DesiredScreenWidth' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, bUseDesiredScreenHeight) == 0x0000C8, "Member 'UGameUserSettings::bUseDesiredScreenHeight' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, DesiredScreenHeight) == 0x0000CC, "Member 'UGameUserSettings::DesiredScreenHeight' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastRecommendedScreenWidth) == 0x0000D0, "Member 'UGameUserSettings::LastRecommendedScreenWidth' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastRecommendedScreenHeight) == 0x0000D4, "Member 'UGameUserSettings::LastRecommendedScreenHeight' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastCPUBenchmarkResult) == 0x0000D8, "Member 'UGameUserSettings::LastCPUBenchmarkResult' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastGPUBenchmarkResult) == 0x0000DC, "Member 'UGameUserSettings::LastGPUBenchmarkResult' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastCPUBenchmarkSteps) == 0x0000E0, "Member 'UGameUserSettings::LastCPUBenchmarkSteps' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastGPUBenchmarkSteps) == 0x0000F0, "Member 'UGameUserSettings::LastGPUBenchmarkSteps' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, LastGPUBenchmarkMultiplier) == 0x000100, "Member 'UGameUserSettings::LastGPUBenchmarkMultiplier' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, bUseHDRDisplayOutput) == 0x000104, "Member 'UGameUserSettings::bUseHDRDisplayOutput' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, HDRDisplayOutputNits) == 0x000108, "Member 'UGameUserSettings::HDRDisplayOutputNits' has a wrong offset!");
static_assert(offsetof(UGameUserSettings, OnGameUserSettingsUINeedsUpdate) == 0x000110, "Member 'UGameUserSettings::OnGameUserSettingsUINeedsUpdate' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_EmitterParentTailHistoryPos
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleSQEX_EmitterParentTailHistoryPos final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bIsCurrentLength : 1;                              // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  EmitterPosToTailHistoryRate;                       // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_EmitterParentTailHistoryPos">();
	}
	static class UParticleModuleSQEX_EmitterParentTailHistoryPos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_EmitterParentTailHistoryPos>();
	}
};
static_assert(alignof(UParticleModuleSQEX_EmitterParentTailHistoryPos) == 0x000008, "Wrong alignment on UParticleModuleSQEX_EmitterParentTailHistoryPos");
static_assert(sizeof(UParticleModuleSQEX_EmitterParentTailHistoryPos) == 0x000090, "Wrong size on UParticleModuleSQEX_EmitterParentTailHistoryPos");
static_assert(offsetof(UParticleModuleSQEX_EmitterParentTailHistoryPos, EmitterPosToTailHistoryRate) == 0x000058, "Member 'UParticleModuleSQEX_EmitterParentTailHistoryPos::EmitterPosToTailHistoryRate' has a wrong offset!");

// Class Engine.TargetPoint
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ATargetPoint : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetPoint">();
	}
	static class ATargetPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetPoint>();
	}
};
static_assert(alignof(ATargetPoint) == 0x1EF72E00, "Wrong alignment on ATargetPoint");
static_assert(sizeof(ATargetPoint) == 0x1EF72E00, "Wrong size on ATargetPoint");

// Class Engine.HUD
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AHUD : public AActor
{
public:
	class APlayerController*                      PlayerOwner;                                       // 0x03E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLostFocusPaused : 1;                              // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowHUD : 1;                                      // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowDebugInfo : 1;                                // 0x03E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowHitBoxDebugInfo : 1;                          // 0x03E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowOverlays : 1;                                 // 0x03E8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDebugTextShadow : 1;                        // 0x03E8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         PostRenderedActors;                                // 0x03F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DebugDisplay;                                      // 0x0408(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TArray<class FName>                           ToggledDebugCategories;                            // 0x0418(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	class UCanvas*                                Canvas;                                            // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvas*                                DebugCanvas;                                       // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDebugTextInfo>                 DebugTextList;                                     // 0x0438(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     ShowDebugTargetDesiredClass;                       // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 ShowDebugTargetActor;                              // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x70];                                     // 0x0458(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDebugText(const class FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow);
	void AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, class FName InName, bool bConsumesInput, int32 Priority);
	void DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor, float LineThickness);
	void DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot);
	void DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition);
	void DrawMaterialTriangle(class UMaterialInterface* Material, const struct FVector2D& V0_Pos, const struct FVector2D& V1_Pos, const struct FVector2D& V2_Pos, const struct FVector2D& V0_UV, const struct FVector2D& V1_UV, const struct FVector2D& V2_UV, const struct FLinearColor& V0_Color, const struct FLinearColor& V1_Color, const struct FLinearColor& V2_Color);
	void DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH);
	void DrawText(const class FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition);
	void DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, EBlendMode BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot);
	void DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition);
	void GetActorsInSelectionRectangle(TSubclassOf<class AActor> ClassFilter, const struct FVector2D& FirstPoint, const struct FVector2D& SecondPoint, TArray<class AActor*>* OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed);
	void ReceiveDrawHUD(int32 SizeX, int32 SizeY);
	void ReceiveHitBoxBeginCursorOver(const class FName BoxName);
	void ReceiveHitBoxClick(const class FName BoxName);
	void ReceiveHitBoxEndCursorOver(const class FName BoxName);
	void ReceiveHitBoxRelease(const class FName BoxName);
	void RemoveAllDebugStrings();
	void RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText);
	void ShowDebug(class FName DebugType);
	void ShowDebugForReticleTargetToggle(TSubclassOf<class AActor> DesiredClass);
	void ShowDebugToggleSubCategory(class FName Category);
	void ShowHUD();

	void Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection) const;
	class APawn* GetOwningPawn() const;
	class APlayerController* GetOwningPlayerController() const;
	void GetTextSize(const class FString& Text, float* OutWidth, float* OutHeight, class UFont* Font, float Scale) const;
	struct FVector Project(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD">();
	}
	static class AHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHUD>();
	}
};
#pragma pack(pop)
static_assert(alignof(AHUD) == 0x1EF72E00, "Wrong alignment on AHUD");
static_assert(sizeof(AHUD) == 0x1EF72E00, "Wrong size on AHUD");
static_assert(offsetof(AHUD, PlayerOwner) == 0x0003E0, "Member 'AHUD::PlayerOwner' has a wrong offset!");
static_assert(offsetof(AHUD, PostRenderedActors) == 0x0003F0, "Member 'AHUD::PostRenderedActors' has a wrong offset!");
static_assert(offsetof(AHUD, DebugDisplay) == 0x000408, "Member 'AHUD::DebugDisplay' has a wrong offset!");
static_assert(offsetof(AHUD, ToggledDebugCategories) == 0x000418, "Member 'AHUD::ToggledDebugCategories' has a wrong offset!");
static_assert(offsetof(AHUD, Canvas) == 0x000428, "Member 'AHUD::Canvas' has a wrong offset!");
static_assert(offsetof(AHUD, DebugCanvas) == 0x000430, "Member 'AHUD::DebugCanvas' has a wrong offset!");
static_assert(offsetof(AHUD, DebugTextList) == 0x000438, "Member 'AHUD::DebugTextList' has a wrong offset!");
static_assert(offsetof(AHUD, ShowDebugTargetDesiredClass) == 0x000448, "Member 'AHUD::ShowDebugTargetDesiredClass' has a wrong offset!");
static_assert(offsetof(AHUD, ShowDebugTargetActor) == 0x000450, "Member 'AHUD::ShowDebugTargetActor' has a wrong offset!");

// Class Engine.NavigationObjectBase
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ANavigationObjectBase : public AActor
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    GoodSprite;                                        // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BadSprite;                                         // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsPIEPlayerStart : 1;                             // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationObjectBase">();
	}
	static class ANavigationObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationObjectBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANavigationObjectBase) == 0x1EF72E00, "Wrong alignment on ANavigationObjectBase");
static_assert(sizeof(ANavigationObjectBase) == 0x1EF72E00, "Wrong size on ANavigationObjectBase");
static_assert(offsetof(ANavigationObjectBase, CapsuleComponent) == 0x0003E8, "Member 'ANavigationObjectBase::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANavigationObjectBase, GoodSprite) == 0x0003F0, "Member 'ANavigationObjectBase::GoodSprite' has a wrong offset!");
static_assert(offsetof(ANavigationObjectBase, BadSprite) == 0x0003F8, "Member 'ANavigationObjectBase::BadSprite' has a wrong offset!");

// Class Engine.ParticleModuleLocationWorldOffset
// 0x0000 (0x00A8 - 0x00A8)
class UParticleModuleLocationWorldOffset : public UParticleModuleLocation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationWorldOffset">();
	}
	static class UParticleModuleLocationWorldOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationWorldOffset>();
	}
};
static_assert(alignof(UParticleModuleLocationWorldOffset) == 0x000008, "Wrong alignment on UParticleModuleLocationWorldOffset");
static_assert(sizeof(UParticleModuleLocationWorldOffset) == 0x0000A8, "Wrong size on UParticleModuleLocationWorldOffset");

// Class Engine.ParticleModuleLocationWorldOffset_Seeded
// 0x0020 (0x00C8 - 0x00A8)
class UParticleModuleLocationWorldOffset_Seeded final : public UParticleModuleLocationWorldOffset
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00A8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationWorldOffset_Seeded">();
	}
	static class UParticleModuleLocationWorldOffset_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationWorldOffset_Seeded>();
	}
};
static_assert(alignof(UParticleModuleLocationWorldOffset_Seeded) == 0x000008, "Wrong alignment on UParticleModuleLocationWorldOffset_Seeded");
static_assert(sizeof(UParticleModuleLocationWorldOffset_Seeded) == 0x0000C8, "Wrong size on UParticleModuleLocationWorldOffset_Seeded");
static_assert(offsetof(UParticleModuleLocationWorldOffset_Seeded, RandomSeedInfo) == 0x0000A8, "Member 'UParticleModuleLocationWorldOffset_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.KismetGuidLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetGuidLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_GuidToString(const struct FGuid& InGuid);
	static bool EqualEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B);
	static void Invalidate_Guid(struct FGuid& InGuid);
	static bool IsValid_Guid(const struct FGuid& InGuid);
	static struct FGuid NewGuid();
	static bool NotEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B);
	static void Parse_StringToGuid(const class FString& GuidString, struct FGuid* OutGuid, bool* Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetGuidLibrary">();
	}
	static class UKismetGuidLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetGuidLibrary>();
	}
};
static_assert(alignof(UKismetGuidLibrary) == 0x000008, "Wrong alignment on UKismetGuidLibrary");
static_assert(sizeof(UKismetGuidLibrary) == 0x000040, "Wrong size on UKismetGuidLibrary");

// Class Engine.MaterialExpressionVertexNormalWS
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionVertexNormalWS final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVertexNormalWS">();
	}
	static class UMaterialExpressionVertexNormalWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVertexNormalWS>();
	}
};
static_assert(alignof(UMaterialExpressionVertexNormalWS) == 0x000008, "Wrong alignment on UMaterialExpressionVertexNormalWS");
static_assert(sizeof(UMaterialExpressionVertexNormalWS) == 0x000078, "Wrong size on UMaterialExpressionVertexNormalWS");

// Class Engine.PlayerStart
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) APlayerStart : public ANavigationObjectBase
{
public:
	class FName                                   PlayerStartTag;                                    // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStart">();
	}
	static class APlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStart>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerStart) == 0x1EF72E00, "Wrong alignment on APlayerStart");
static_assert(sizeof(APlayerStart) == 0x1EF72E00, "Wrong size on APlayerStart");
static_assert(offsetof(APlayerStart, PlayerStartTag) == 0x000408, "Member 'APlayerStart::PlayerStartTag' has a wrong offset!");

// Class Engine.NavRelevantComponent
// 0x0000 (0xD38D - 0xD38D)
#pragma pack(push, 0x1)
class alignas(0xD38D) UNavRelevantComponent : public UActorComponent
{
public:
	uint8                                         Pad_200[0x24];                                     // 0x0200(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAttachToOwnersRoot : 1;                           // 0x0224(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CachedNavParent;                                   // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetNavigationRelevancy(bool bRelevant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavRelevantComponent">();
	}
	static class UNavRelevantComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavRelevantComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNavRelevantComponent) == 0x00D38D, "Wrong alignment on UNavRelevantComponent");
static_assert(sizeof(UNavRelevantComponent) == 0x00D38D, "Wrong size on UNavRelevantComponent");
static_assert(offsetof(UNavRelevantComponent, CachedNavParent) == 0x000228, "Member 'UNavRelevantComponent::CachedNavParent' has a wrong offset!");

// Class Engine.NavLinkCustomComponent
// 0x0000 (0xD38D - 0xD38D)
class UNavLinkCustomComponent final : public UNavRelevantComponent
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        NavLinkUserId;                                     // 0x0238(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   EnabledAreaClass;                                  // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavArea>                   DisabledAreaClass;                                 // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LinkRelativeStart;                                 // 0x0250(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LinkRelativeEnd;                                   // 0x025C(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENavLinkDirection                             LinkDirection;                                     // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bLinkEnabled : 1;                                  // 0x026C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNotifyWhenEnabled : 1;                            // 0x026C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNotifyWhenDisabled : 1;                           // 0x026C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCreateBoxObstacle : 1;                            // 0x026C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ObstacleOffset;                                    // 0x0270(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ObstacleExtent;                                    // 0x027C(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavArea>                   ObstacleAreaClass;                                 // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BroadcastRadius;                                   // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BroadcastInterval;                                 // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             BroadcastChannel;                                  // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0xA7];                                     // 0x0299(0x00A7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkCustomComponent">();
	}
	static class UNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkCustomComponent>();
	}
};
static_assert(alignof(UNavLinkCustomComponent) == 0x00D38D, "Wrong alignment on UNavLinkCustomComponent");
static_assert(sizeof(UNavLinkCustomComponent) == 0x00D38D, "Wrong size on UNavLinkCustomComponent");
static_assert(offsetof(UNavLinkCustomComponent, NavLinkUserId) == 0x000238, "Member 'UNavLinkCustomComponent::NavLinkUserId' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, EnabledAreaClass) == 0x000240, "Member 'UNavLinkCustomComponent::EnabledAreaClass' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, DisabledAreaClass) == 0x000248, "Member 'UNavLinkCustomComponent::DisabledAreaClass' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, LinkRelativeStart) == 0x000250, "Member 'UNavLinkCustomComponent::LinkRelativeStart' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, LinkRelativeEnd) == 0x00025C, "Member 'UNavLinkCustomComponent::LinkRelativeEnd' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, LinkDirection) == 0x000268, "Member 'UNavLinkCustomComponent::LinkDirection' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, ObstacleOffset) == 0x000270, "Member 'UNavLinkCustomComponent::ObstacleOffset' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, ObstacleExtent) == 0x00027C, "Member 'UNavLinkCustomComponent::ObstacleExtent' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, ObstacleAreaClass) == 0x000288, "Member 'UNavLinkCustomComponent::ObstacleAreaClass' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, BroadcastRadius) == 0x000290, "Member 'UNavLinkCustomComponent::BroadcastRadius' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, BroadcastInterval) == 0x000294, "Member 'UNavLinkCustomComponent::BroadcastInterval' has a wrong offset!");
static_assert(offsetof(UNavLinkCustomComponent, BroadcastChannel) == 0x000298, "Member 'UNavLinkCustomComponent::BroadcastChannel' has a wrong offset!");

// Class Engine.InterpTrackMove
// 0x112ED380 (0x112ED410 - 0x0090)
#pragma pack(push, 0x1)
class alignas(0x112ED410) UInterpTrackMove : public UInterpTrack
{
public:
	struct FInterpCurveVector                     PosTrack;                                          // 0x0090(0x112ED410)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveVector                     EulerTrack;                                        // 0x00A8(0x112ED410)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpLookupTrack                     LookupTrack;                                       // 0x00C0(0x0010)(NativeAccessSpecifierPublic)
	class FName                                   LookAtGroupName;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_UpVectorGroupName;                               // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseRotXAsRoll;                                   // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinCurveTension;                                   // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngCurveTension;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseQuatInterpolation : 1;                         // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowArrowAtKeys : 1;                              // 0x00EC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMovement : 1;                              // 0x00EC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowTranslationOnCurveEd : 1;                     // 0x00EC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowRotationOnCurveEd : 1;                        // 0x00EC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHide3DTrack : 1;                                  // 0x00EC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EInterpTrackMoveRotMode                       RotMode;                                           // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_SnapToFloor;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             M_CollisionChannelForSnapToFloor;                  // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseSweepMulti;                                   // 0x00F3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SnapToFloorUpLength;                             // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_SnapToFloorDownLength;                           // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_AllowEmptyKey;                                   // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackMove">();
	}
	static class UInterpTrackMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackMove>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackMove) == 0x112ED410, "Wrong alignment on UInterpTrackMove");
static_assert(sizeof(UInterpTrackMove) == 0x112ED410, "Wrong size on UInterpTrackMove");
static_assert(offsetof(UInterpTrackMove, PosTrack) == 0x000090, "Member 'UInterpTrackMove::PosTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, EulerTrack) == 0x0000A8, "Member 'UInterpTrackMove::EulerTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, LookupTrack) == 0x0000C0, "Member 'UInterpTrackMove::LookupTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, LookAtGroupName) == 0x0000D0, "Member 'UInterpTrackMove::LookAtGroupName' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_UpVectorGroupName) == 0x0000D8, "Member 'UInterpTrackMove::M_UpVectorGroupName' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_UseRotXAsRoll) == 0x0000E0, "Member 'UInterpTrackMove::M_UseRotXAsRoll' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, LinCurveTension) == 0x0000E4, "Member 'UInterpTrackMove::LinCurveTension' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, AngCurveTension) == 0x0000E8, "Member 'UInterpTrackMove::AngCurveTension' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, RotMode) == 0x0000F0, "Member 'UInterpTrackMove::RotMode' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_SnapToFloor) == 0x0000F1, "Member 'UInterpTrackMove::M_SnapToFloor' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_CollisionChannelForSnapToFloor) == 0x0000F2, "Member 'UInterpTrackMove::M_CollisionChannelForSnapToFloor' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_UseSweepMulti) == 0x0000F3, "Member 'UInterpTrackMove::M_UseSweepMulti' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_SnapToFloorUpLength) == 0x0000F4, "Member 'UInterpTrackMove::M_SnapToFloorUpLength' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_SnapToFloorDownLength) == 0x0000F8, "Member 'UInterpTrackMove::M_SnapToFloorDownLength' has a wrong offset!");
static_assert(offsetof(UInterpTrackMove, M_AllowEmptyKey) == 0x0000FC, "Member 'UInterpTrackMove::M_AllowEmptyKey' has a wrong offset!");

// Class Engine.SpringArmComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USpringArmComponent : public USceneComponent
{
public:
	float                                         TargetArmLength;                                   // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x041C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0428(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbeSize;                                         // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ProbeChannel;                                      // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDoCollisionTest : 1;                              // 0x043C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePawnControlRotation : 1;                       // 0x043C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritPitch : 1;                                 // 0x043C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritYaw : 1;                                   // 0x043C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritRoll : 1;                                  // 0x043C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableCameraLag : 1;                              // 0x043C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableCameraRotationLag : 1;                      // 0x043C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCameraLagSubstepping : 1;                      // 0x043C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebugLagMarkers : 1;                          // 0x043D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_43E[0x2];                                      // 0x043E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagSpeed;                                    // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxTimeStep;                              // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistance;                              // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x50];                                     // 0x0450(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringArmComponent">();
	}
	static class USpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringArmComponent>();
	}
};
static_assert(alignof(USpringArmComponent) == 0x112E9AF0, "Wrong alignment on USpringArmComponent");
static_assert(sizeof(USpringArmComponent) == 0x112E9AF0, "Wrong size on USpringArmComponent");
static_assert(offsetof(USpringArmComponent, TargetArmLength) == 0x000418, "Member 'USpringArmComponent::TargetArmLength' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, SocketOffset) == 0x00041C, "Member 'USpringArmComponent::SocketOffset' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, TargetOffset) == 0x000428, "Member 'USpringArmComponent::TargetOffset' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, ProbeSize) == 0x000434, "Member 'USpringArmComponent::ProbeSize' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, ProbeChannel) == 0x000438, "Member 'USpringArmComponent::ProbeChannel' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, CameraLagSpeed) == 0x000440, "Member 'USpringArmComponent::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, CameraRotationLagSpeed) == 0x000444, "Member 'USpringArmComponent::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, CameraLagMaxTimeStep) == 0x000448, "Member 'USpringArmComponent::CameraLagMaxTimeStep' has a wrong offset!");
static_assert(offsetof(USpringArmComponent, CameraLagMaxDistance) == 0x00044C, "Member 'USpringArmComponent::CameraLagMaxDistance' has a wrong offset!");

// Class Engine.StaticMeshComponent
// 0x34C0F0 (0x11635BE0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x11635BE0) UStaticMeshComponent : public UMeshComponent
{
public:
	int32                                         ForcedLodModel;                                    // 0x0980(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousLODLevel;                                  // 0x0984(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMinLOD;                                   // 0x0988(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_989[0x3];                                      // 0x0989(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLOD;                                            // 0x098C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0990(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideWireframeColor;                           // 0x0998(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_999[0x3];                                      // 0x0999(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 WireframeColorOverride;                            // 0x099C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideNavigationExport : 1;                     // 0x09A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceNavigationObstacle : 1;                      // 0x09A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisallowMeshPaintPerInstance : 1;                 // 0x09A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreInstanceForTextureStreaming : 1;            // 0x09A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLightMapRes : 1;                          // 0x09A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9A1[0x3];                                      // 0x09A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverriddenLightMapRes;                             // 0x09A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCastDistanceFieldIndirectShadow : 1;              // 0x09A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexCastCapsuleIndirectShadowSelf : 1;            // 0x09A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9A9[0x3];                                      // 0x09A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceFieldIndirectShadowMinVisibility;          // 0x09AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDistanceFieldSelfShadowBias;              // 0x09B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B1[0x3];                                      // 0x09B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceFieldSelfShadowBias;                       // 0x09B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StreamingDistanceMultiplier;                       // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubDivisionStepSize;                               // 0x09BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSubDivisions : 1;                              // 0x09C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9C1[0x7];                                      // 0x09C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          IrrelevantLights;                                  // 0x09C8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FStaticMeshComponentLODInfo>    LODData;                                           // 0x09D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FStreamingTextureBuildInfo>     StreamingTextureData;                              // 0x09E8(0x0010)(ZeroConstructor, NonTransactional, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultCollision;                              // 0x09F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F9[0x3];                                      // 0x09F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightmassPrimitiveSettings            LightmassSettings;                                 // 0x09FC(0x11635BE0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bNoOverrideAssetTranslucencySortPriority : 1;      // 0x0A14(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bCastCapsuleIndirectShadow : 1;               // 0x0A14(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_A14_2 : 6;                                  // 0x0A14(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_A15[0x3];                                      // 0x0A15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         SQEX_bForceCastCapsuleIndirectShadow : 1;          // 0x0A18(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A19[0x7];                                      // 0x0A19(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_StaticMesh(class UStaticMesh* OldStaticMesh);
	void SetDistanceFieldSelfShadowBias(float NewValue);
	void SetForcedLodModel(int32 NewForcedLodModel);
	bool SetStaticMesh(class UStaticMesh* NewMesh);

	void GetLocalBounds(struct FVector* Min, struct FVector* Max) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshComponent">();
	}
	static class UStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UStaticMeshComponent) == 0x11635BE0, "Wrong alignment on UStaticMeshComponent");
static_assert(sizeof(UStaticMeshComponent) == 0x11635BE0, "Wrong size on UStaticMeshComponent");
static_assert(offsetof(UStaticMeshComponent, ForcedLodModel) == 0x000980, "Member 'UStaticMeshComponent::ForcedLodModel' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, PreviousLODLevel) == 0x000984, "Member 'UStaticMeshComponent::PreviousLODLevel' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, bOverrideMinLOD) == 0x000988, "Member 'UStaticMeshComponent::bOverrideMinLOD' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, MinLOD) == 0x00098C, "Member 'UStaticMeshComponent::MinLOD' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, StaticMesh) == 0x000990, "Member 'UStaticMeshComponent::StaticMesh' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, bOverrideWireframeColor) == 0x000998, "Member 'UStaticMeshComponent::bOverrideWireframeColor' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, WireframeColorOverride) == 0x00099C, "Member 'UStaticMeshComponent::WireframeColorOverride' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, OverriddenLightMapRes) == 0x0009A4, "Member 'UStaticMeshComponent::OverriddenLightMapRes' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, DistanceFieldIndirectShadowMinVisibility) == 0x0009AC, "Member 'UStaticMeshComponent::DistanceFieldIndirectShadowMinVisibility' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, bOverrideDistanceFieldSelfShadowBias) == 0x0009B0, "Member 'UStaticMeshComponent::bOverrideDistanceFieldSelfShadowBias' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, DistanceFieldSelfShadowBias) == 0x0009B4, "Member 'UStaticMeshComponent::DistanceFieldSelfShadowBias' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, StreamingDistanceMultiplier) == 0x0009B8, "Member 'UStaticMeshComponent::StreamingDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, SubDivisionStepSize) == 0x0009BC, "Member 'UStaticMeshComponent::SubDivisionStepSize' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, IrrelevantLights) == 0x0009C8, "Member 'UStaticMeshComponent::IrrelevantLights' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, LODData) == 0x0009D8, "Member 'UStaticMeshComponent::LODData' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, StreamingTextureData) == 0x0009E8, "Member 'UStaticMeshComponent::StreamingTextureData' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, bUseDefaultCollision) == 0x0009F8, "Member 'UStaticMeshComponent::bUseDefaultCollision' has a wrong offset!");
static_assert(offsetof(UStaticMeshComponent, LightmassSettings) == 0x0009FC, "Member 'UStaticMeshComponent::LightmassSettings' has a wrong offset!");

// Class Engine.MaterialExpressionCrossProduct
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionCrossProduct final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCrossProduct">();
	}
	static class UMaterialExpressionCrossProduct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCrossProduct>();
	}
};
static_assert(alignof(UMaterialExpressionCrossProduct) == 0x112F2730, "Wrong alignment on UMaterialExpressionCrossProduct");
static_assert(sizeof(UMaterialExpressionCrossProduct) == 0x112F2730, "Wrong size on UMaterialExpressionCrossProduct");
static_assert(offsetof(UMaterialExpressionCrossProduct, A) == 0x000078, "Member 'UMaterialExpressionCrossProduct::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCrossProduct, B) == 0x0000B0, "Member 'UMaterialExpressionCrossProduct::B' has a wrong offset!");

// Class Engine.InterpTrackInstVectorProp
// 0x0018 (0x0068 - 0x0050)
class UInterpTrackInstVectorProp : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ResetVector;                                       // 0x0058(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstVectorProp">();
	}
	static class UInterpTrackInstVectorProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstVectorProp>();
	}
};
static_assert(alignof(UInterpTrackInstVectorProp) == 0x000008, "Wrong alignment on UInterpTrackInstVectorProp");
static_assert(sizeof(UInterpTrackInstVectorProp) == 0x000068, "Wrong size on UInterpTrackInstVectorProp");
static_assert(offsetof(UInterpTrackInstVectorProp, ResetVector) == 0x000058, "Member 'UInterpTrackInstVectorProp::ResetVector' has a wrong offset!");

// Class Engine.ParticleModuleTrailBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleTrailBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTrailBase">();
	}
	static class UParticleModuleTrailBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTrailBase>();
	}
};
static_assert(alignof(UParticleModuleTrailBase) == 0x000008, "Wrong alignment on UParticleModuleTrailBase");
static_assert(sizeof(UParticleModuleTrailBase) == 0x000050, "Wrong size on UParticleModuleTrailBase");

// Class Engine.SoundNodeAssetReferencer
// 0x0000 (0x0050 - 0x0050)
class USoundNodeAssetReferencer : public USoundNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeAssetReferencer">();
	}
	static class USoundNodeAssetReferencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeAssetReferencer>();
	}
};
static_assert(alignof(USoundNodeAssetReferencer) == 0x000008, "Wrong alignment on USoundNodeAssetReferencer");
static_assert(sizeof(USoundNodeAssetReferencer) == 0x000050, "Wrong size on USoundNodeAssetReferencer");

// Class Engine.InstancedStaticMeshComponent
// 0x0000 (0x11635BE0 - 0x11635BE0)
#pragma pack(push, 0x1)
class alignas(0x11635BE0) UInstancedStaticMeshComponent : public UStaticMeshComponent
{
public:
	TArray<struct FInstancedStaticMeshInstanceData> PerInstanceSMData;                                 // 0x0A20(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         InstancingRandomSeed;                              // 0x0A30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceStartCullDistance;                         // 0x0A34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceEndCullDistance;                           // 0x0A38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqexLODDistanceScale;                              // 0x0A3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqexMinimumScreenSize;                             // 0x0A40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SqexMinVertsToSplitNode;                           // 0x0A44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SqexOcclusionCullLayerNum;                         // 0x0A48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSqexEnableFixRandom;                            // 0x0A4C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4D[0xB];                                      // 0x0A4D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 InstanceReorderTable;                              // 0x0A58(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemovedInstances;                                  // 0x0A68(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseDynamicInstanceBuffer;                          // 0x0A78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A79[0xA7];                                     // 0x0A79(0x00A7)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsSerializer*                     PhysicsSerializer;                                 // 0x0B20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPendingLightmaps;                               // 0x0B28(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, TextExportTransient, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B2C[0x4];                                      // 0x0B2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInstancedStaticMeshMappingInfo> CachedMappings;                                    // 0x0B30(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, TextExportTransient, NativeAccessSpecifierProtected)

public:
	int32 AddInstance(const struct FTransform& InstanceTransform);
	int32 AddInstanceWorldSpace(const struct FTransform& WorldTransform);
	void ClearInstances();
	bool GetInstanceRandomValue(int32 In_InstanceIndex, float* Out_RandomValue);
	bool RemoveInstance(int32 InstanceIndex);
	void SetCullDistances(int32 StartCullDistance, int32 EndCullDistance);
	bool UpdateInstanceTransform(int32 InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);

	int32 GetInstanceCount() const;
	TArray<int32> GetInstancesOverlappingBox(const struct FBox& Box, bool bBoxInWorldSpace) const;
	TArray<int32> GetInstancesOverlappingSphere(const struct FVector& Center, float Radius, bool bSphereInWorldSpace) const;
	bool GetInstanceTransform(int32 InstanceIndex, struct FTransform* OutInstanceTransform, bool bWorldSpace) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InstancedStaticMeshComponent">();
	}
	static class UInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInstancedStaticMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInstancedStaticMeshComponent) == 0x11635BE0, "Wrong alignment on UInstancedStaticMeshComponent");
static_assert(sizeof(UInstancedStaticMeshComponent) == 0x11635BE0, "Wrong size on UInstancedStaticMeshComponent");
static_assert(offsetof(UInstancedStaticMeshComponent, PerInstanceSMData) == 0x000A20, "Member 'UInstancedStaticMeshComponent::PerInstanceSMData' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, InstancingRandomSeed) == 0x000A30, "Member 'UInstancedStaticMeshComponent::InstancingRandomSeed' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, InstanceStartCullDistance) == 0x000A34, "Member 'UInstancedStaticMeshComponent::InstanceStartCullDistance' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, InstanceEndCullDistance) == 0x000A38, "Member 'UInstancedStaticMeshComponent::InstanceEndCullDistance' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, SqexLODDistanceScale) == 0x000A3C, "Member 'UInstancedStaticMeshComponent::SqexLODDistanceScale' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, SqexMinimumScreenSize) == 0x000A40, "Member 'UInstancedStaticMeshComponent::SqexMinimumScreenSize' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, SqexMinVertsToSplitNode) == 0x000A44, "Member 'UInstancedStaticMeshComponent::SqexMinVertsToSplitNode' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, SqexOcclusionCullLayerNum) == 0x000A48, "Member 'UInstancedStaticMeshComponent::SqexOcclusionCullLayerNum' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, M_bSqexEnableFixRandom) == 0x000A4C, "Member 'UInstancedStaticMeshComponent::M_bSqexEnableFixRandom' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, InstanceReorderTable) == 0x000A58, "Member 'UInstancedStaticMeshComponent::InstanceReorderTable' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, RemovedInstances) == 0x000A68, "Member 'UInstancedStaticMeshComponent::RemovedInstances' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, UseDynamicInstanceBuffer) == 0x000A78, "Member 'UInstancedStaticMeshComponent::UseDynamicInstanceBuffer' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, PhysicsSerializer) == 0x000B20, "Member 'UInstancedStaticMeshComponent::PhysicsSerializer' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, NumPendingLightmaps) == 0x000B28, "Member 'UInstancedStaticMeshComponent::NumPendingLightmaps' has a wrong offset!");
static_assert(offsetof(UInstancedStaticMeshComponent, CachedMappings) == 0x000B30, "Member 'UInstancedStaticMeshComponent::CachedMappings' has a wrong offset!");

// Class Engine.MaterialExpressionConstant3Vector
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionConstant3Vector final : public UMaterialExpression
{
public:
	struct FLinearColor                           Constant;                                          // 0x0078(0x112EAE80)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionConstant3Vector">();
	}
	static class UMaterialExpressionConstant3Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionConstant3Vector>();
	}
};
static_assert(alignof(UMaterialExpressionConstant3Vector) == 0x112EAE80, "Wrong alignment on UMaterialExpressionConstant3Vector");
static_assert(sizeof(UMaterialExpressionConstant3Vector) == 0x112EAE80, "Wrong size on UMaterialExpressionConstant3Vector");
static_assert(offsetof(UMaterialExpressionConstant3Vector, Constant) == 0x000078, "Member 'UMaterialExpressionConstant3Vector::Constant' has a wrong offset!");

// Class Engine.InterpGroup
// 0x0030 (0x0070 - 0x0040)
class UInterpGroup : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInterpTrack*>                   InterpTracks;                                      // 0x0048(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   GroupName;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 GroupColor;                                        // 0x0060(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCollapsed : 1;                                    // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisible : 1;                                      // 0x0064(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFolder : 1;                                     // 0x0064(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsParented : 1;                                   // 0x0064(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSelected : 1;                                   // 0x0064(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_EnsureGroupActor;                                // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpGroup">();
	}
	static class UInterpGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpGroup>();
	}
};
static_assert(alignof(UInterpGroup) == 0x000008, "Wrong alignment on UInterpGroup");
static_assert(sizeof(UInterpGroup) == 0x000070, "Wrong size on UInterpGroup");
static_assert(offsetof(UInterpGroup, InterpTracks) == 0x000048, "Member 'UInterpGroup::InterpTracks' has a wrong offset!");
static_assert(offsetof(UInterpGroup, GroupName) == 0x000058, "Member 'UInterpGroup::GroupName' has a wrong offset!");
static_assert(offsetof(UInterpGroup, GroupColor) == 0x000060, "Member 'UInterpGroup::GroupColor' has a wrong offset!");
static_assert(offsetof(UInterpGroup, M_EnsureGroupActor) == 0x000068, "Member 'UInterpGroup::M_EnsureGroupActor' has a wrong offset!");

// Class Engine.InterpGroupInst
// 0x0028 (0x0068 - 0x0040)
class UInterpGroupInst : public UObject
{
public:
	class UInterpGroup*                           Group;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GroupActor;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInterpTrackInst*>               TrackInst;                                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpGroupInst">();
	}
	static class UInterpGroupInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpGroupInst>();
	}
};
static_assert(alignof(UInterpGroupInst) == 0x000008, "Wrong alignment on UInterpGroupInst");
static_assert(sizeof(UInterpGroupInst) == 0x000068, "Wrong size on UInterpGroupInst");
static_assert(offsetof(UInterpGroupInst, Group) == 0x000040, "Member 'UInterpGroupInst::Group' has a wrong offset!");
static_assert(offsetof(UInterpGroupInst, GroupActor) == 0x000048, "Member 'UInterpGroupInst::GroupActor' has a wrong offset!");
static_assert(offsetof(UInterpGroupInst, TrackInst) == 0x000050, "Member 'UInterpGroupInst::TrackInst' has a wrong offset!");

// Class Engine.MaterialExpressionDecalDerivative
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionDecalDerivative final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDecalDerivative">();
	}
	static class UMaterialExpressionDecalDerivative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDecalDerivative>();
	}
};
static_assert(alignof(UMaterialExpressionDecalDerivative) == 0x000008, "Wrong alignment on UMaterialExpressionDecalDerivative");
static_assert(sizeof(UMaterialExpressionDecalDerivative) == 0x000078, "Wrong size on UMaterialExpressionDecalDerivative");

// Class Engine.InterpTrackVectorBase
// 0x112ED380 (0x112ED410 - 0x0090)
#pragma pack(push, 0x1)
class alignas(0x112ED410) UInterpTrackVectorBase : public UInterpTrack
{
public:
	struct FInterpCurveVector                     VectorTrack;                                       // 0x0090(0x112ED410)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTension;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackVectorBase">();
	}
	static class UInterpTrackVectorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackVectorBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackVectorBase) == 0x112ED410, "Wrong alignment on UInterpTrackVectorBase");
static_assert(sizeof(UInterpTrackVectorBase) == 0x112ED410, "Wrong size on UInterpTrackVectorBase");
static_assert(offsetof(UInterpTrackVectorBase, VectorTrack) == 0x000090, "Member 'UInterpTrackVectorBase::VectorTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackVectorBase, CurveTension) == 0x0000A8, "Member 'UInterpTrackVectorBase::CurveTension' has a wrong offset!");

// Class Engine.NavCollision
// 0x00E8 (0x0128 - 0x0040)
class UNavCollision final : public UObject
{
public:
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavCollisionCylinder>          CylinderCollision;                                 // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavCollisionBox>               BoxCollision;                                      // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsDynamicObstacle : 1;                            // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGatherConvexGeometry : 1;                         // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x6F];                                      // 0x00B9(0x006F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavCollision">();
	}
	static class UNavCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavCollision>();
	}
};
static_assert(alignof(UNavCollision) == 0x000008, "Wrong alignment on UNavCollision");
static_assert(sizeof(UNavCollision) == 0x000128, "Wrong size on UNavCollision");
static_assert(offsetof(UNavCollision, CylinderCollision) == 0x000090, "Member 'UNavCollision::CylinderCollision' has a wrong offset!");
static_assert(offsetof(UNavCollision, BoxCollision) == 0x0000A0, "Member 'UNavCollision::BoxCollision' has a wrong offset!");
static_assert(offsetof(UNavCollision, AreaClass) == 0x0000B0, "Member 'UNavCollision::AreaClass' has a wrong offset!");

// Class Engine.AssetManager
// 0x0380 (0x03C0 - 0x0040)
class UAssetManager final : public UObject
{
public:
	uint8                                         Pad_40[0x210];                                     // 0x0040(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ObjectReferenceList;                               // 0x0250(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsGlobalAsyncScanEnvironment;                     // 0x0260(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldGuessTypeAndName;                           // 0x0261(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUseSynchronousLoad;                         // 0x0262(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBulkScanning;                                   // 0x0263(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsManagementDatabaseCurrent;                      // 0x0264(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateManagementDatabaseAfterScan;                // 0x0265(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266[0x2];                                      // 0x0266(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfSpawnedNotifications;                      // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x154];                                    // 0x026C(0x0154)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetManager">();
	}
	static class UAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetManager>();
	}
};
static_assert(alignof(UAssetManager) == 0x000008, "Wrong alignment on UAssetManager");
static_assert(sizeof(UAssetManager) == 0x0003C0, "Wrong size on UAssetManager");
static_assert(offsetof(UAssetManager, ObjectReferenceList) == 0x000250, "Member 'UAssetManager::ObjectReferenceList' has a wrong offset!");
static_assert(offsetof(UAssetManager, bIsGlobalAsyncScanEnvironment) == 0x000260, "Member 'UAssetManager::bIsGlobalAsyncScanEnvironment' has a wrong offset!");
static_assert(offsetof(UAssetManager, bShouldGuessTypeAndName) == 0x000261, "Member 'UAssetManager::bShouldGuessTypeAndName' has a wrong offset!");
static_assert(offsetof(UAssetManager, bShouldUseSynchronousLoad) == 0x000262, "Member 'UAssetManager::bShouldUseSynchronousLoad' has a wrong offset!");
static_assert(offsetof(UAssetManager, bIsBulkScanning) == 0x000263, "Member 'UAssetManager::bIsBulkScanning' has a wrong offset!");
static_assert(offsetof(UAssetManager, bIsManagementDatabaseCurrent) == 0x000264, "Member 'UAssetManager::bIsManagementDatabaseCurrent' has a wrong offset!");
static_assert(offsetof(UAssetManager, bUpdateManagementDatabaseAfterScan) == 0x000265, "Member 'UAssetManager::bUpdateManagementDatabaseAfterScan' has a wrong offset!");
static_assert(offsetof(UAssetManager, NumberOfSpawnedNotifications) == 0x000268, "Member 'UAssetManager::NumberOfSpawnedNotifications' has a wrong offset!");

// Class Engine.InterpTrackSound
// 0x0000 (0x112ED410 - 0x112ED410)
#pragma pack(push, 0x1)
class alignas(0x112ED410) UInterpTrackSound : public UInterpTrackVectorBase
{
public:
	TArray<struct FSoundTrackKey>                 Sounds;                                            // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnReverse : 1;                                // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bContinueSoundOnMatineeEnd : 1;                    // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuppressSubtitles : 1;                            // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTreatAsDialogue : 1;                              // 0x00C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttach : 1;                                       // 0x00C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackSound">();
	}
	static class UInterpTrackSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackSound>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackSound) == 0x112ED410, "Wrong alignment on UInterpTrackSound");
static_assert(sizeof(UInterpTrackSound) == 0x112ED410, "Wrong size on UInterpTrackSound");
static_assert(offsetof(UInterpTrackSound, Sounds) == 0x0000B0, "Member 'UInterpTrackSound::Sounds' has a wrong offset!");

// Class Engine.MaterialExpressionObjectRadius
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionObjectRadius final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionObjectRadius">();
	}
	static class UMaterialExpressionObjectRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionObjectRadius>();
	}
};
static_assert(alignof(UMaterialExpressionObjectRadius) == 0x000008, "Wrong alignment on UMaterialExpressionObjectRadius");
static_assert(sizeof(UMaterialExpressionObjectRadius) == 0x000078, "Wrong size on UMaterialExpressionObjectRadius");

// Class Engine.InterpTrackBoolProp
// 0x0020 (0x00B0 - 0x0090)
class UInterpTrackBoolProp : public UInterpTrack
{
public:
	TArray<struct FBoolTrackKey>                  BoolTrack;                                         // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseInterpolation;                                // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackBoolProp">();
	}
	static class UInterpTrackBoolProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackBoolProp>();
	}
};
static_assert(alignof(UInterpTrackBoolProp) == 0x000008, "Wrong alignment on UInterpTrackBoolProp");
static_assert(sizeof(UInterpTrackBoolProp) == 0x0000B0, "Wrong size on UInterpTrackBoolProp");
static_assert(offsetof(UInterpTrackBoolProp, BoolTrack) == 0x000090, "Member 'UInterpTrackBoolProp::BoolTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackBoolProp, PropertyName) == 0x0000A0, "Member 'UInterpTrackBoolProp::PropertyName' has a wrong offset!");
static_assert(offsetof(UInterpTrackBoolProp, M_UseInterpolation) == 0x0000A8, "Member 'UInterpTrackBoolProp::M_UseInterpolation' has a wrong offset!");

// Class Engine.SoundNodeDelay
// 0x0008 (0x0058 - 0x0050)
class USoundNodeDelay final : public USoundNode
{
public:
	float                                         DelayMin;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayMax;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeDelay">();
	}
	static class USoundNodeDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeDelay>();
	}
};
static_assert(alignof(USoundNodeDelay) == 0x000008, "Wrong alignment on USoundNodeDelay");
static_assert(sizeof(USoundNodeDelay) == 0x000058, "Wrong size on USoundNodeDelay");
static_assert(offsetof(USoundNodeDelay, DelayMin) == 0x000050, "Member 'USoundNodeDelay::DelayMin' has a wrong offset!");
static_assert(offsetof(USoundNodeDelay, DelayMax) == 0x000054, "Member 'USoundNodeDelay::DelayMax' has a wrong offset!");

// Class Engine.DistributionFloat
// 0x0008 (0x0050 - 0x0048)
class UDistributionFloat : public UDistribution
{
public:
	uint8                                         bCanBeBaked : 1;                                   // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_48_1 : 1;                                   // 0x0048(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bBakedDataSuccesfully : 1;                         // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloat">();
	}
	static class UDistributionFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloat>();
	}
};
static_assert(alignof(UDistributionFloat) == 0x000008, "Wrong alignment on UDistributionFloat");
static_assert(sizeof(UDistributionFloat) == 0x000050, "Wrong size on UDistributionFloat");

// Class Engine.DistributionFloatConstantCurve
// 0x112EC560 (0x112EC5B0 - 0x0050)
class UDistributionFloatConstantCurve final : public UDistributionFloat
{
public:
	struct FInterpCurveFloat                      ConstantCurve;                                     // 0x0050(0x112EC5B0)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatConstantCurve">();
	}
	static class UDistributionFloatConstantCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatConstantCurve>();
	}
};
static_assert(alignof(UDistributionFloatConstantCurve) == 0x112EC5B0, "Wrong alignment on UDistributionFloatConstantCurve");
static_assert(sizeof(UDistributionFloatConstantCurve) == 0x112EC5B0, "Wrong size on UDistributionFloatConstantCurve");
static_assert(offsetof(UDistributionFloatConstantCurve, ConstantCurve) == 0x000050, "Member 'UDistributionFloatConstantCurve::ConstantCurve' has a wrong offset!");

// Class Engine.InterpTrackColorProp
// 0x0000 (0x112ED410 - 0x112ED410)
#pragma pack(push, 0x1)
class alignas(0x112ED410) UInterpTrackColorProp : public UInterpTrackVectorBase
{
public:
	class FName                                   PropertyName;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseInterpolation;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_StartInterpType;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_EndInterpType;                                   // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackColorProp">();
	}
	static class UInterpTrackColorProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackColorProp>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackColorProp) == 0x112ED410, "Wrong alignment on UInterpTrackColorProp");
static_assert(sizeof(UInterpTrackColorProp) == 0x112ED410, "Wrong size on UInterpTrackColorProp");
static_assert(offsetof(UInterpTrackColorProp, PropertyName) == 0x0000B0, "Member 'UInterpTrackColorProp::PropertyName' has a wrong offset!");
static_assert(offsetof(UInterpTrackColorProp, M_UseInterpolation) == 0x0000B8, "Member 'UInterpTrackColorProp::M_UseInterpolation' has a wrong offset!");
static_assert(offsetof(UInterpTrackColorProp, M_StartInterpType) == 0x0000B9, "Member 'UInterpTrackColorProp::M_StartInterpType' has a wrong offset!");
static_assert(offsetof(UInterpTrackColorProp, M_EndInterpType) == 0x0000BA, "Member 'UInterpTrackColorProp::M_EndInterpType' has a wrong offset!");

// Class Engine.InterpTrackEvent
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackEvent : public UInterpTrack
{
public:
	TArray<struct FEventTrackKey>                 EventTrack;                                        // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenJumpingForwards : 1;                // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCustomEventName : 1;                           // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackEvent">();
	}
	static class UInterpTrackEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackEvent>();
	}
};
static_assert(alignof(UInterpTrackEvent) == 0x000008, "Wrong alignment on UInterpTrackEvent");
static_assert(sizeof(UInterpTrackEvent) == 0x0000A8, "Wrong size on UInterpTrackEvent");
static_assert(offsetof(UInterpTrackEvent, EventTrack) == 0x000090, "Member 'UInterpTrackEvent::EventTrack' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXDecalZFadeSegmentOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXDecalZFadeSegmentOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input0;                                            // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXDecalZFadeSegmentOutput">();
	}
	static class UMaterialExpressionSQEXDecalZFadeSegmentOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXDecalZFadeSegmentOutput>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXDecalZFadeSegmentOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXDecalZFadeSegmentOutput");
static_assert(sizeof(UMaterialExpressionSQEXDecalZFadeSegmentOutput) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXDecalZFadeSegmentOutput");
static_assert(offsetof(UMaterialExpressionSQEXDecalZFadeSegmentOutput, Input0) == 0x000078, "Member 'UMaterialExpressionSQEXDecalZFadeSegmentOutput::Input0' has a wrong offset!");

// Class Engine.InterpTrackFade
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
#pragma pack(push, 0x1)
class alignas(0x112EC5B0) UInterpTrackFade : public UInterpTrackFloatBase
{
public:
	uint8                                         bPersistFade : 1;                                  // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFadeAudio : 1;                                    // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           FadeColor;                                         // 0x00B4(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackFade">();
	}
	static class UInterpTrackFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackFade>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackFade) == 0x112EC5B0, "Wrong alignment on UInterpTrackFade");
static_assert(sizeof(UInterpTrackFade) == 0x112EC5B0, "Wrong size on UInterpTrackFade");
static_assert(offsetof(UInterpTrackFade, FadeColor) == 0x0000B4, "Member 'UInterpTrackFade::FadeColor' has a wrong offset!");

// Class Engine.ParticleModuleLocationPrimitiveTriangle
// 0x00F8 (0x0148 - 0x0050)
class UParticleModuleLocationPrimitiveTriangle final : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                 StartOffset;                                       // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Height;                                            // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Angle;                                             // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Thickness;                                         // 0x0110(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationPrimitiveTriangle">();
	}
	static class UParticleModuleLocationPrimitiveTriangle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationPrimitiveTriangle>();
	}
};
static_assert(alignof(UParticleModuleLocationPrimitiveTriangle) == 0x000008, "Wrong alignment on UParticleModuleLocationPrimitiveTriangle");
static_assert(sizeof(UParticleModuleLocationPrimitiveTriangle) == 0x000148, "Wrong size on UParticleModuleLocationPrimitiveTriangle");
static_assert(offsetof(UParticleModuleLocationPrimitiveTriangle, StartOffset) == 0x000050, "Member 'UParticleModuleLocationPrimitiveTriangle::StartOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationPrimitiveTriangle, Height) == 0x0000A0, "Member 'UParticleModuleLocationPrimitiveTriangle::Height' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationPrimitiveTriangle, Angle) == 0x0000D8, "Member 'UParticleModuleLocationPrimitiveTriangle::Angle' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationPrimitiveTriangle, Thickness) == 0x000110, "Member 'UParticleModuleLocationPrimitiveTriangle::Thickness' has a wrong offset!");

// Class Engine.VectorField
// 0x0020 (0x0060 - 0x0040)
class UVectorField : public UObject
{
public:
	struct FBox                                   Bounds;                                            // 0x0040(0x001C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VectorField">();
	}
	static class UVectorField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVectorField>();
	}
};
static_assert(alignof(UVectorField) == 0x000008, "Wrong alignment on UVectorField");
static_assert(sizeof(UVectorField) == 0x000060, "Wrong size on UVectorField");
static_assert(offsetof(UVectorField, Bounds) == 0x000040, "Member 'UVectorField::Bounds' has a wrong offset!");
static_assert(offsetof(UVectorField, Intensity) == 0x00005C, "Member 'UVectorField::Intensity' has a wrong offset!");

// Class Engine.VectorFieldAnimated
// 0x0040 (0x00A0 - 0x0060)
class UVectorFieldAnimated final : public UVectorField
{
public:
	class UTexture2D*                             Texture;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVectorFieldConstructionOp                    ConstructionOp;                                    // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VolumeSizeX;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumeSizeY;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumeSizeZ;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubImagesX;                                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubImagesY;                                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameCount;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FramesPerSecond;                                   // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoop : 1;                                         // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVectorFieldStatic*                     NoiseField;                                        // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseScale;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseMax;                                          // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VectorFieldAnimated">();
	}
	static class UVectorFieldAnimated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVectorFieldAnimated>();
	}
};
static_assert(alignof(UVectorFieldAnimated) == 0x000008, "Wrong alignment on UVectorFieldAnimated");
static_assert(sizeof(UVectorFieldAnimated) == 0x0000A0, "Wrong size on UVectorFieldAnimated");
static_assert(offsetof(UVectorFieldAnimated, Texture) == 0x000060, "Member 'UVectorFieldAnimated::Texture' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, ConstructionOp) == 0x000068, "Member 'UVectorFieldAnimated::ConstructionOp' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, VolumeSizeX) == 0x00006C, "Member 'UVectorFieldAnimated::VolumeSizeX' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, VolumeSizeY) == 0x000070, "Member 'UVectorFieldAnimated::VolumeSizeY' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, VolumeSizeZ) == 0x000074, "Member 'UVectorFieldAnimated::VolumeSizeZ' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, SubImagesX) == 0x000078, "Member 'UVectorFieldAnimated::SubImagesX' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, SubImagesY) == 0x00007C, "Member 'UVectorFieldAnimated::SubImagesY' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, FrameCount) == 0x000080, "Member 'UVectorFieldAnimated::FrameCount' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, FramesPerSecond) == 0x000084, "Member 'UVectorFieldAnimated::FramesPerSecond' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, NoiseField) == 0x000090, "Member 'UVectorFieldAnimated::NoiseField' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, NoiseScale) == 0x000098, "Member 'UVectorFieldAnimated::NoiseScale' has a wrong offset!");
static_assert(offsetof(UVectorFieldAnimated, NoiseMax) == 0x00009C, "Member 'UVectorFieldAnimated::NoiseMax' has a wrong offset!");

// Class Engine.BrushComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UBrushComponent final : public UPrimitiveComponent
{
public:
	class UModel*                                 Brush;                                             // 0x0868(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodySetup*                             BrushBodySetup;                                    // 0x0870(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrePivot;                                          // 0x0878(0x000C)(Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_884[0x4];                                      // 0x0884(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     M_pSqexDebugMaterial;                              // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrushComponent">();
	}
	static class UBrushComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrushComponent>();
	}
};
static_assert(alignof(UBrushComponent) == 0x112E9AF0, "Wrong alignment on UBrushComponent");
static_assert(sizeof(UBrushComponent) == 0x112E9AF0, "Wrong size on UBrushComponent");
static_assert(offsetof(UBrushComponent, Brush) == 0x000868, "Member 'UBrushComponent::Brush' has a wrong offset!");
static_assert(offsetof(UBrushComponent, BrushBodySetup) == 0x000870, "Member 'UBrushComponent::BrushBodySetup' has a wrong offset!");
static_assert(offsetof(UBrushComponent, PrePivot) == 0x000878, "Member 'UBrushComponent::PrePivot' has a wrong offset!");
static_assert(offsetof(UBrushComponent, M_pSqexDebugMaterial) == 0x000888, "Member 'UBrushComponent::M_pSqexDebugMaterial' has a wrong offset!");

// Class Engine.InterpTrackFloatMaterialParam
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
#pragma pack(push, 0x1)
class alignas(0x112EC5B0) UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
public:
	TArray<class UMaterialInterface*>             TargetMaterials;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackFloatMaterialParam">();
	}
	static class UInterpTrackFloatMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackFloatMaterialParam>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackFloatMaterialParam) == 0x112EC5B0, "Wrong alignment on UInterpTrackFloatMaterialParam");
static_assert(sizeof(UInterpTrackFloatMaterialParam) == 0x112EC5B0, "Wrong size on UInterpTrackFloatMaterialParam");
static_assert(offsetof(UInterpTrackFloatMaterialParam, TargetMaterials) == 0x0000B0, "Member 'UInterpTrackFloatMaterialParam::TargetMaterials' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatMaterialParam, ParamName) == 0x0000C0, "Member 'UInterpTrackFloatMaterialParam::ParamName' has a wrong offset!");

// Class Engine.ParticleEmitter
// 0x01F0 (0x0230 - 0x0040)
class UParticleEmitter : public UObject
{
public:
	class FName                                   EmitterName;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterPriority;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NoUseSpawnRateScaleToCameraDistance : 1;           // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USqEx_EffectShaderParameter_Base*       SqExShaderParameter;                               // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseMaterialParameter : 1;                         // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DrawBatching : 1;                                  // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_PARTICLE_DRAW_BATCHING_CATEGORY         BatchingCategory;                                  // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_PARTICLE_DRAW_BATCHING_TYPE             BatchingType;                                      // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0xA];                                       // 0x005E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubUVDataOffset;                                   // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterRenderMode                            EmitterRenderMode;                                 // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleLODLevel*>              LODLevels;                                         // 0x0070(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         ConvertedModules : 1;                              // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PeakActiveParticles;                               // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialAllocationCount;                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MediumDetailSpawnRateScale;                        // 0x008C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QualityLevelSpawnRateScale;                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   DetailMode;                                        // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsSoloing : 1;                                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCookedOut : 1;                                    // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisabledLODsKeepEmitterAlive : 1;                 // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableWhenInsignficant : 1;                      // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleSignificanceLevel                    SignificanceLevel;                                 // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x193];                                     // 0x009D(0x0193)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleEmitter">();
	}
	static class UParticleEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleEmitter>();
	}
};
static_assert(alignof(UParticleEmitter) == 0x000008, "Wrong alignment on UParticleEmitter");
static_assert(sizeof(UParticleEmitter) == 0x000230, "Wrong size on UParticleEmitter");
static_assert(offsetof(UParticleEmitter, EmitterName) == 0x000040, "Member 'UParticleEmitter::EmitterName' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, EmitterPriority) == 0x000048, "Member 'UParticleEmitter::EmitterPriority' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, SqExShaderParameter) == 0x000050, "Member 'UParticleEmitter::SqExShaderParameter' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, BatchingCategory) == 0x00005C, "Member 'UParticleEmitter::BatchingCategory' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, BatchingType) == 0x00005D, "Member 'UParticleEmitter::BatchingType' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, SubUVDataOffset) == 0x000068, "Member 'UParticleEmitter::SubUVDataOffset' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, EmitterRenderMode) == 0x00006C, "Member 'UParticleEmitter::EmitterRenderMode' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, LODLevels) == 0x000070, "Member 'UParticleEmitter::LODLevels' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, PeakActiveParticles) == 0x000084, "Member 'UParticleEmitter::PeakActiveParticles' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, InitialAllocationCount) == 0x000088, "Member 'UParticleEmitter::InitialAllocationCount' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, MediumDetailSpawnRateScale) == 0x00008C, "Member 'UParticleEmitter::MediumDetailSpawnRateScale' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, QualityLevelSpawnRateScale) == 0x000090, "Member 'UParticleEmitter::QualityLevelSpawnRateScale' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, DetailMode) == 0x000094, "Member 'UParticleEmitter::DetailMode' has a wrong offset!");
static_assert(offsetof(UParticleEmitter, SignificanceLevel) == 0x00009C, "Member 'UParticleEmitter::SignificanceLevel' has a wrong offset!");

// Class Engine.AsyncActionChangePrimaryAssetBundles
// 0x0010 (0x0098 - 0x0088)
class UAsyncActionChangePrimaryAssetBundles final : public UAsyncActionLoadPrimaryAssetBase
{
public:
	UMulticastDelegateProperty_                   Completed;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForMatchingPrimaryAssets(const TArray<class FName>& NewBundles, const TArray<class FName>& OldBundles);
	static class UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForPrimaryAssetList(const TArray<struct FPrimaryAssetId>& PrimaryAssetList, const TArray<class FName>& AddBundles, const TArray<class FName>& RemoveBundles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionChangePrimaryAssetBundles">();
	}
	static class UAsyncActionChangePrimaryAssetBundles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionChangePrimaryAssetBundles>();
	}
};
static_assert(alignof(UAsyncActionChangePrimaryAssetBundles) == 0x000008, "Wrong alignment on UAsyncActionChangePrimaryAssetBundles");
static_assert(sizeof(UAsyncActionChangePrimaryAssetBundles) == 0x000098, "Wrong size on UAsyncActionChangePrimaryAssetBundles");
static_assert(offsetof(UAsyncActionChangePrimaryAssetBundles, Completed) == 0x000088, "Member 'UAsyncActionChangePrimaryAssetBundles::Completed' has a wrong offset!");

// Class Engine.InterpTrackFloatProp
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
#pragma pack(push, 0x1)
class alignas(0x112EC5B0) UInterpTrackFloatProp : public UInterpTrackFloatBase
{
public:
	class FName                                   PropertyName;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseInterpolation;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_StartInterpType;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_EndInterpType;                                   // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackFloatProp">();
	}
	static class UInterpTrackFloatProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackFloatProp>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackFloatProp) == 0x112EC5B0, "Wrong alignment on UInterpTrackFloatProp");
static_assert(sizeof(UInterpTrackFloatProp) == 0x112EC5B0, "Wrong size on UInterpTrackFloatProp");
static_assert(offsetof(UInterpTrackFloatProp, PropertyName) == 0x0000B0, "Member 'UInterpTrackFloatProp::PropertyName' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatProp, M_UseInterpolation) == 0x0000B8, "Member 'UInterpTrackFloatProp::M_UseInterpolation' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatProp, M_StartInterpType) == 0x0000B9, "Member 'UInterpTrackFloatProp::M_StartInterpType' has a wrong offset!");
static_assert(offsetof(UInterpTrackFloatProp, M_EndInterpType) == 0x0000BA, "Member 'UInterpTrackFloatProp::M_EndInterpType' has a wrong offset!");

// Class Engine.SkeletalMeshSocket
// 0x112E9AB0 (0x112E9AF0 - 0x0040)
class USkeletalMeshSocket final : public UObject
{
public:
	class FName                                   SocketName;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x005C(0x112E9AF0)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0068(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceAlwaysAnimated;                              // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeSocketFromLocation(const class USkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal);

	struct FVector GetSocketLocation(const class USkeletalMeshComponent* SkelComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshSocket">();
	}
	static class USkeletalMeshSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalMeshSocket>();
	}
};
static_assert(alignof(USkeletalMeshSocket) == 0x112E9AF0, "Wrong alignment on USkeletalMeshSocket");
static_assert(sizeof(USkeletalMeshSocket) == 0x112E9AF0, "Wrong size on USkeletalMeshSocket");
static_assert(offsetof(USkeletalMeshSocket, SocketName) == 0x000040, "Member 'USkeletalMeshSocket::SocketName' has a wrong offset!");
static_assert(offsetof(USkeletalMeshSocket, BoneName) == 0x000048, "Member 'USkeletalMeshSocket::BoneName' has a wrong offset!");
static_assert(offsetof(USkeletalMeshSocket, RelativeLocation) == 0x000050, "Member 'USkeletalMeshSocket::RelativeLocation' has a wrong offset!");
static_assert(offsetof(USkeletalMeshSocket, RelativeRotation) == 0x00005C, "Member 'USkeletalMeshSocket::RelativeRotation' has a wrong offset!");
static_assert(offsetof(USkeletalMeshSocket, RelativeScale) == 0x000068, "Member 'USkeletalMeshSocket::RelativeScale' has a wrong offset!");
static_assert(offsetof(USkeletalMeshSocket, bForceAlwaysAnimated) == 0x000074, "Member 'USkeletalMeshSocket::bForceAlwaysAnimated' has a wrong offset!");

// Class Engine.InputSettings
// 0x112F6AB0 (0x112F6AF0 - 0x0040)
class UInputSettings final : public UObject
{
public:
	TArray<struct FInputAxisConfigEntry>          AxisConfig;                                        // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         bAltEnterTogglesFullscreen : 1;                    // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bF11TogglesFullscreen : 1;                         // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMouseForTouch : 1;                             // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMouseSmoothing : 1;                         // 0x0050(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableFOVScaling : 1;                             // 0x0050(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVScale;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoubleClickTime;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureMouseOnLaunch;                             // 0x005C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseCaptureMode                             DefaultViewportMouseCaptureMode;                   // 0x005D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultViewportMouseLock;                         // 0x005E(0x0001)(ZeroConstructor, Config, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseLockMode                                DefaultViewportMouseLockMode;                      // 0x005F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowTouchInterface;                         // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowConsoleOnFourFingerTap;                       // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStringAssetReference                  DefaultTouchInterface;                             // 0x0088(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ConsoleKey;                                        // 0x0098(0x112F6AF0)(Config, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           ConsoleKeys;                                       // 0x00B0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UInputSettings* GetInputSettings();

	void AddActionMapping(const struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
	void AddAxisMapping(const struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
	void ForceRebuildKeymaps();
	void RemoveActionMapping(const struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
	void RemoveAxisMapping(const struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
	void SaveKeyMappings();

	void GetActionMappingByName(const class FName InActionName, TArray<struct FInputActionKeyMapping>* OutMappings) const;
	void GetActionNames(TArray<class FName>* ActionNames) const;
	void GetAxisMappingByName(const class FName InAxisName, TArray<struct FInputAxisKeyMapping>* OutMappings) const;
	void GetAxisNames(TArray<class FName>* AxisNames) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettings">();
	}
	static class UInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettings>();
	}
};
static_assert(alignof(UInputSettings) == 0x112F6AF0, "Wrong alignment on UInputSettings");
static_assert(sizeof(UInputSettings) == 0x112F6AF0, "Wrong size on UInputSettings");
static_assert(offsetof(UInputSettings, AxisConfig) == 0x000040, "Member 'UInputSettings::AxisConfig' has a wrong offset!");
static_assert(offsetof(UInputSettings, FOVScale) == 0x000054, "Member 'UInputSettings::FOVScale' has a wrong offset!");
static_assert(offsetof(UInputSettings, DoubleClickTime) == 0x000058, "Member 'UInputSettings::DoubleClickTime' has a wrong offset!");
static_assert(offsetof(UInputSettings, bCaptureMouseOnLaunch) == 0x00005C, "Member 'UInputSettings::bCaptureMouseOnLaunch' has a wrong offset!");
static_assert(offsetof(UInputSettings, DefaultViewportMouseCaptureMode) == 0x00005D, "Member 'UInputSettings::DefaultViewportMouseCaptureMode' has a wrong offset!");
static_assert(offsetof(UInputSettings, bDefaultViewportMouseLock) == 0x00005E, "Member 'UInputSettings::bDefaultViewportMouseLock' has a wrong offset!");
static_assert(offsetof(UInputSettings, DefaultViewportMouseLockMode) == 0x00005F, "Member 'UInputSettings::DefaultViewportMouseLockMode' has a wrong offset!");
static_assert(offsetof(UInputSettings, ActionMappings) == 0x000060, "Member 'UInputSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(UInputSettings, AxisMappings) == 0x000070, "Member 'UInputSettings::AxisMappings' has a wrong offset!");
static_assert(offsetof(UInputSettings, bAlwaysShowTouchInterface) == 0x000080, "Member 'UInputSettings::bAlwaysShowTouchInterface' has a wrong offset!");
static_assert(offsetof(UInputSettings, bShowConsoleOnFourFingerTap) == 0x000081, "Member 'UInputSettings::bShowConsoleOnFourFingerTap' has a wrong offset!");
static_assert(offsetof(UInputSettings, DefaultTouchInterface) == 0x000088, "Member 'UInputSettings::DefaultTouchInterface' has a wrong offset!");
static_assert(offsetof(UInputSettings, ConsoleKey) == 0x000098, "Member 'UInputSettings::ConsoleKey' has a wrong offset!");
static_assert(offsetof(UInputSettings, ConsoleKeys) == 0x0000B0, "Member 'UInputSettings::ConsoleKeys' has a wrong offset!");

// Class Engine.NavLinkCustomInterface
// 0x0000 (0x0040 - 0x0040)
class INavLinkCustomInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkCustomInterface">();
	}
	static class INavLinkCustomInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavLinkCustomInterface>();
	}
};
static_assert(alignof(INavLinkCustomInterface) == 0x000008, "Wrong alignment on INavLinkCustomInterface");
static_assert(sizeof(INavLinkCustomInterface) == 0x000040, "Wrong size on INavLinkCustomInterface");

// Class Engine.ReflectionCapture
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AReflectionCapture : public AActor
{
public:
	class UReflectionCaptureComponent*            CaptureComponent;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflectionCapture">();
	}
	static class AReflectionCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReflectionCapture>();
	}
};
#pragma pack(pop)
static_assert(alignof(AReflectionCapture) == 0x1EF72E00, "Wrong alignment on AReflectionCapture");
static_assert(sizeof(AReflectionCapture) == 0x1EF72E00, "Wrong size on AReflectionCapture");
static_assert(offsetof(AReflectionCapture, CaptureComponent) == 0x0003E0, "Member 'AReflectionCapture::CaptureComponent' has a wrong offset!");

// Class Engine.NavNodeInterface
// 0x0000 (0x0040 - 0x0040)
class INavNodeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavNodeInterface">();
	}
	static class INavNodeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavNodeInterface>();
	}
};
static_assert(alignof(INavNodeInterface) == 0x000008, "Wrong alignment on INavNodeInterface");
static_assert(sizeof(INavNodeInterface) == 0x000040, "Wrong size on INavNodeInterface");

// Class Engine.InterpTrackInstBoolProp
// 0x0018 (0x0068 - 0x0050)
class UInterpTrackInstBoolProp : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoolProperty*                          BoolProperty;                                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetBool;                                         // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstBoolProp">();
	}
	static class UInterpTrackInstBoolProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstBoolProp>();
	}
};
static_assert(alignof(UInterpTrackInstBoolProp) == 0x000008, "Wrong alignment on UInterpTrackInstBoolProp");
static_assert(sizeof(UInterpTrackInstBoolProp) == 0x000068, "Wrong size on UInterpTrackInstBoolProp");
static_assert(offsetof(UInterpTrackInstBoolProp, BoolProperty) == 0x000058, "Member 'UInterpTrackInstBoolProp::BoolProperty' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstBoolProp, ResetBool) == 0x000060, "Member 'UInterpTrackInstBoolProp::ResetBool' has a wrong offset!");

// Class Engine.ParticleModuleVelocityBase
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleVelocityBase : public UParticleModule
{
public:
	uint8                                         bInWorldSpace : 1;                                 // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyOwnerScale : 1;                              // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVelocityBase">();
	}
	static class UParticleModuleVelocityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVelocityBase>();
	}
};
static_assert(alignof(UParticleModuleVelocityBase) == 0x000008, "Wrong alignment on UParticleModuleVelocityBase");
static_assert(sizeof(UParticleModuleVelocityBase) == 0x000058, "Wrong size on UParticleModuleVelocityBase");

// Class Engine.ParticleModuleVelocityCone
// 0x0080 (0x00D8 - 0x0058)
class UParticleModuleVelocityCone final : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionFloat                  Angle;                                             // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Velocity;                                          // 0x0090(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x00C8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVelocityCone">();
	}
	static class UParticleModuleVelocityCone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVelocityCone>();
	}
};
static_assert(alignof(UParticleModuleVelocityCone) == 0x000008, "Wrong alignment on UParticleModuleVelocityCone");
static_assert(sizeof(UParticleModuleVelocityCone) == 0x0000D8, "Wrong size on UParticleModuleVelocityCone");
static_assert(offsetof(UParticleModuleVelocityCone, Angle) == 0x000058, "Member 'UParticleModuleVelocityCone::Angle' has a wrong offset!");
static_assert(offsetof(UParticleModuleVelocityCone, Velocity) == 0x000090, "Member 'UParticleModuleVelocityCone::Velocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleVelocityCone, Direction) == 0x0000C8, "Member 'UParticleModuleVelocityCone::Direction' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleTypeDataBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataBase">();
	}
	static class UParticleModuleTypeDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataBase>();
	}
};
static_assert(alignof(UParticleModuleTypeDataBase) == 0x000008, "Wrong alignment on UParticleModuleTypeDataBase");
static_assert(sizeof(UParticleModuleTypeDataBase) == 0x000050, "Wrong size on UParticleModuleTypeDataBase");

// Class Engine.ParticleModuleTypeDataSQEX_TestTypeData
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleTypeDataSQEX_TestTypeData final : public UParticleModuleTypeDataBase
{
public:
	int32                                         ThreadNumber;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TestTypeData">();
	}
	static class UParticleModuleTypeDataSQEX_TestTypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TestTypeData>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TestTypeData) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_TestTypeData");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TestTypeData) == 0x000058, "Wrong size on UParticleModuleTypeDataSQEX_TestTypeData");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TestTypeData, ThreadNumber) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_TestTypeData::ThreadNumber' has a wrong offset!");

// Class Engine.InterpTrackInstFloatAnimBPParam
// 0x0018 (0x0058 - 0x0040)
class UInterpTrackInstFloatAnimBPParam : public UInterpTrackInst
{
public:
	class UAnimInstance*                          AnimScriptInstance;                                // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetFloat;                                        // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0xC];                                       // 0x004C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstFloatAnimBPParam">();
	}
	static class UInterpTrackInstFloatAnimBPParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstFloatAnimBPParam>();
	}
};
static_assert(alignof(UInterpTrackInstFloatAnimBPParam) == 0x000008, "Wrong alignment on UInterpTrackInstFloatAnimBPParam");
static_assert(sizeof(UInterpTrackInstFloatAnimBPParam) == 0x000058, "Wrong size on UInterpTrackInstFloatAnimBPParam");
static_assert(offsetof(UInterpTrackInstFloatAnimBPParam, AnimScriptInstance) == 0x000040, "Member 'UInterpTrackInstFloatAnimBPParam::AnimScriptInstance' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstFloatAnimBPParam, ResetFloat) == 0x000048, "Member 'UInterpTrackInstFloatAnimBPParam::ResetFloat' has a wrong offset!");

// Class Engine.SQEX_CameraUpVector
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASQEX_CameraUpVector final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_CameraUpVector">();
	}
	static class ASQEX_CameraUpVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASQEX_CameraUpVector>();
	}
};
static_assert(alignof(ASQEX_CameraUpVector) == 0x1EF72E00, "Wrong alignment on ASQEX_CameraUpVector");
static_assert(sizeof(ASQEX_CameraUpVector) == 0x1EF72E00, "Wrong size on ASQEX_CameraUpVector");

// Class Engine.KismetInputLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetInputLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CalibrateTilt();
	static bool EqualEqual_InputChordInputChord(const struct FInputChord& A, const struct FInputChord& B);
	static bool EqualEqual_KeyKey(const struct FKey& A, const struct FKey& B);
	static float GetAnalogValue(const struct FAnalogInputEvent& Input);
	static struct FKey GetKey(const struct FKeyEvent& Input);
	static int32 GetUserIndex(const struct FKeyEvent& Input);
	static bool InputEvent_IsAltDown(const struct FInputEvent& Input);
	static bool InputEvent_IsCommandDown(const struct FInputEvent& Input);
	static bool InputEvent_IsControlDown(const struct FInputEvent& Input);
	static bool InputEvent_IsLeftAltDown(const struct FInputEvent& Input);
	static bool InputEvent_IsLeftCommandDown(const struct FInputEvent& Input);
	static bool InputEvent_IsLeftControlDown(const struct FInputEvent& Input);
	static bool InputEvent_IsLeftShiftDown(const struct FInputEvent& Input);
	static bool InputEvent_IsRepeat(const struct FInputEvent& Input);
	static bool InputEvent_IsRightAltDown(const struct FInputEvent& Input);
	static bool InputEvent_IsRightCommandDown(const struct FInputEvent& Input);
	static bool InputEvent_IsRightControlDown(const struct FInputEvent& Input);
	static bool InputEvent_IsRightShiftDown(const struct FInputEvent& Input);
	static bool InputEvent_IsShiftDown(const struct FInputEvent& Input);
	static class FText Key_GetDisplayName(const struct FKey& Key);
	static bool Key_IsFloatAxis(const struct FKey& Key);
	static bool Key_IsGamepadKey(const struct FKey& Key);
	static bool Key_IsKeyboardKey(const struct FKey& Key);
	static bool Key_IsModifierKey(const struct FKey& Key);
	static bool Key_IsMouseButton(const struct FKey& Key);
	static bool Key_IsVectorAxis(const struct FKey& Key);
	static struct FVector2D PointerEvent_GetCursorDelta(const struct FPointerEvent& Input);
	static struct FKey PointerEvent_GetEffectingButton(const struct FPointerEvent& Input);
	static struct FVector2D PointerEvent_GetGestureDelta(const struct FPointerEvent& Input);
	static ESlateGesture PointerEvent_GetGestureType(const struct FPointerEvent& Input);
	static struct FVector2D PointerEvent_GetLastScreenSpacePosition(const struct FPointerEvent& Input);
	static int32 PointerEvent_GetPointerIndex(const struct FPointerEvent& Input);
	static struct FVector2D PointerEvent_GetScreenSpacePosition(const struct FPointerEvent& Input);
	static int32 PointerEvent_GetTouchpadIndex(const struct FPointerEvent& Input);
	static int32 PointerEvent_GetUserIndex(const struct FPointerEvent& Input);
	static float PointerEvent_GetWheelDelta(const struct FPointerEvent& Input);
	static bool PointerEvent_IsMouseButtonDown(const struct FPointerEvent& Input, const struct FKey& MouseButton);
	static bool PointerEvent_IsTouchEvent(const struct FPointerEvent& Input);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetInputLibrary">();
	}
	static class UKismetInputLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetInputLibrary>();
	}
};
static_assert(alignof(UKismetInputLibrary) == 0x000008, "Wrong alignment on UKismetInputLibrary");
static_assert(sizeof(UKismetInputLibrary) == 0x000040, "Wrong size on UKismetInputLibrary");

// Class Engine.InterpTrackInstFloatMaterialParam
// 0x0038 (0x0078 - 0x0040)
class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ResetFloats;                                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimitiveMaterialRef>          PrimitiveMaterialRefs;                             // 0x0060(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UInterpTrackFloatMaterialParam*         InstancedTrack;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstFloatMaterialParam">();
	}
	static class UInterpTrackInstFloatMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstFloatMaterialParam>();
	}
};
static_assert(alignof(UInterpTrackInstFloatMaterialParam) == 0x000008, "Wrong alignment on UInterpTrackInstFloatMaterialParam");
static_assert(sizeof(UInterpTrackInstFloatMaterialParam) == 0x000078, "Wrong size on UInterpTrackInstFloatMaterialParam");
static_assert(offsetof(UInterpTrackInstFloatMaterialParam, MaterialInstances) == 0x000040, "Member 'UInterpTrackInstFloatMaterialParam::MaterialInstances' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstFloatMaterialParam, ResetFloats) == 0x000050, "Member 'UInterpTrackInstFloatMaterialParam::ResetFloats' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstFloatMaterialParam, PrimitiveMaterialRefs) == 0x000060, "Member 'UInterpTrackInstFloatMaterialParam::PrimitiveMaterialRefs' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstFloatMaterialParam, InstancedTrack) == 0x000070, "Member 'UInterpTrackInstFloatMaterialParam::InstancedTrack' has a wrong offset!");

// Class Engine.ParticleModuleVectorFieldBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleVectorFieldBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldBase">();
	}
	static class UParticleModuleVectorFieldBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldBase>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldBase) == 0x000008, "Wrong alignment on UParticleModuleVectorFieldBase");
static_assert(sizeof(UParticleModuleVectorFieldBase) == 0x000050, "Wrong size on UParticleModuleVectorFieldBase");

// Class Engine.ParticleModuleVectorFieldScale
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleVectorFieldScale final : public UParticleModuleVectorFieldBase
{
public:
	class UDistributionFloat*                     VectorFieldScale;                                  // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  VectorFieldScaleRaw;                               // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldScale">();
	}
	static class UParticleModuleVectorFieldScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldScale>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldScale) == 0x000008, "Wrong alignment on UParticleModuleVectorFieldScale");
static_assert(sizeof(UParticleModuleVectorFieldScale) == 0x000090, "Wrong size on UParticleModuleVectorFieldScale");
static_assert(offsetof(UParticleModuleVectorFieldScale, VectorFieldScale) == 0x000050, "Member 'UParticleModuleVectorFieldScale::VectorFieldScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldScale, VectorFieldScaleRaw) == 0x000058, "Member 'UParticleModuleVectorFieldScale::VectorFieldScaleRaw' has a wrong offset!");

// Class Engine.InterpTrackInstFloatProp
// 0x0010 (0x0060 - 0x0050)
class UInterpTrackInstFloatProp : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetFloat;                                        // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstFloatProp">();
	}
	static class UInterpTrackInstFloatProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstFloatProp>();
	}
};
static_assert(alignof(UInterpTrackInstFloatProp) == 0x000008, "Wrong alignment on UInterpTrackInstFloatProp");
static_assert(sizeof(UInterpTrackInstFloatProp) == 0x000060, "Wrong size on UInterpTrackInstFloatProp");
static_assert(offsetof(UInterpTrackInstFloatProp, ResetFloat) == 0x000058, "Member 'UInterpTrackInstFloatProp::ResetFloat' has a wrong offset!");

// Class Engine.ParticleModuleRotationRateBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleRotationRateBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotationRateBase">();
	}
	static class UParticleModuleRotationRateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotationRateBase>();
	}
};
static_assert(alignof(UParticleModuleRotationRateBase) == 0x000008, "Wrong alignment on UParticleModuleRotationRateBase");
static_assert(sizeof(UParticleModuleRotationRateBase) == 0x000050, "Wrong size on UParticleModuleRotationRateBase");

// Class Engine.ParticleModuleRotationRate
// 0x0038 (0x0088 - 0x0050)
class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionFloat                  StartRotationRate;                                 // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotationRate">();
	}
	static class UParticleModuleRotationRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotationRate>();
	}
};
static_assert(alignof(UParticleModuleRotationRate) == 0x000008, "Wrong alignment on UParticleModuleRotationRate");
static_assert(sizeof(UParticleModuleRotationRate) == 0x000088, "Wrong size on UParticleModuleRotationRate");
static_assert(offsetof(UParticleModuleRotationRate, StartRotationRate) == 0x000050, "Member 'UParticleModuleRotationRate::StartRotationRate' has a wrong offset!");

// Class Engine.ParticleModuleRotationRate_Seeded
// 0x0020 (0x00A8 - 0x0088)
class UParticleModuleRotationRate_Seeded final : public UParticleModuleRotationRate
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0088(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotationRate_Seeded">();
	}
	static class UParticleModuleRotationRate_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotationRate_Seeded>();
	}
};
static_assert(alignof(UParticleModuleRotationRate_Seeded) == 0x000008, "Wrong alignment on UParticleModuleRotationRate_Seeded");
static_assert(sizeof(UParticleModuleRotationRate_Seeded) == 0x0000A8, "Wrong size on UParticleModuleRotationRate_Seeded");
static_assert(offsetof(UParticleModuleRotationRate_Seeded, RandomSeedInfo) == 0x000088, "Member 'UParticleModuleRotationRate_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.InterpTrackInstLinearColorProp
// 0x112EAE30 (0x112EAE80 - 0x0050)
class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ResetColor;                                        // 0x0058(0x112EAE80)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstLinearColorProp">();
	}
	static class UInterpTrackInstLinearColorProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstLinearColorProp>();
	}
};
static_assert(alignof(UInterpTrackInstLinearColorProp) == 0x112EAE80, "Wrong alignment on UInterpTrackInstLinearColorProp");
static_assert(sizeof(UInterpTrackInstLinearColorProp) == 0x112EAE80, "Wrong size on UInterpTrackInstLinearColorProp");
static_assert(offsetof(UInterpTrackInstLinearColorProp, ResetColor) == 0x000058, "Member 'UInterpTrackInstLinearColorProp::ResetColor' has a wrong offset!");

// Class Engine.InterpTrackInstMove
// 0x112E9AB0 (0x112E9AF0 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UInterpTrackInstMove : public UInterpTrackInst
{
public:
	struct FVector                                ResetLocation;                                     // 0x0040(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ResetRotation;                                     // 0x004C(0x112E9AF0)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LastPos;                                           // 0x0058(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastEuler;                                         // 0x0064(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstMove">();
	}
	static class UInterpTrackInstMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstMove>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackInstMove) == 0x112E9AF0, "Wrong alignment on UInterpTrackInstMove");
static_assert(sizeof(UInterpTrackInstMove) == 0x112E9AF0, "Wrong size on UInterpTrackInstMove");
static_assert(offsetof(UInterpTrackInstMove, ResetLocation) == 0x000040, "Member 'UInterpTrackInstMove::ResetLocation' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstMove, ResetRotation) == 0x00004C, "Member 'UInterpTrackInstMove::ResetRotation' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstMove, LastPos) == 0x000058, "Member 'UInterpTrackInstMove::LastPos' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstMove, LastEuler) == 0x000064, "Member 'UInterpTrackInstMove::LastEuler' has a wrong offset!");

// Class Engine.ParticleModuleCameraBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleCameraBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleCameraBase">();
	}
	static class UParticleModuleCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleCameraBase>();
	}
};
static_assert(alignof(UParticleModuleCameraBase) == 0x000008, "Wrong alignment on UParticleModuleCameraBase");
static_assert(sizeof(UParticleModuleCameraBase) == 0x000050, "Wrong size on UParticleModuleCameraBase");

// Class Engine.ParticleModuleCameraOffset
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleCameraOffset final : public UParticleModuleCameraBase
{
public:
	struct FRawDistributionFloat                  CameraOffset;                                      // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bSpawnTimeOnly : 1;                                // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleCameraOffsetUpdateMethod             UpdateMethod;                                      // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleCameraOffset">();
	}
	static class UParticleModuleCameraOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleCameraOffset>();
	}
};
static_assert(alignof(UParticleModuleCameraOffset) == 0x000008, "Wrong alignment on UParticleModuleCameraOffset");
static_assert(sizeof(UParticleModuleCameraOffset) == 0x000090, "Wrong size on UParticleModuleCameraOffset");
static_assert(offsetof(UParticleModuleCameraOffset, CameraOffset) == 0x000050, "Member 'UParticleModuleCameraOffset::CameraOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleCameraOffset, UpdateMethod) == 0x00008C, "Member 'UParticleModuleCameraOffset::UpdateMethod' has a wrong offset!");

// Class Engine.InterpTrackInstVectorMaterialParam
// 0x0038 (0x0078 - 0x0040)
class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ResetVectors;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimitiveMaterialRef>          PrimitiveMaterialRefs;                             // 0x0060(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UInterpTrackVectorMaterialParam*        InstancedTrack;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstVectorMaterialParam">();
	}
	static class UInterpTrackInstVectorMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstVectorMaterialParam>();
	}
};
static_assert(alignof(UInterpTrackInstVectorMaterialParam) == 0x000008, "Wrong alignment on UInterpTrackInstVectorMaterialParam");
static_assert(sizeof(UInterpTrackInstVectorMaterialParam) == 0x000078, "Wrong size on UInterpTrackInstVectorMaterialParam");
static_assert(offsetof(UInterpTrackInstVectorMaterialParam, MaterialInstances) == 0x000040, "Member 'UInterpTrackInstVectorMaterialParam::MaterialInstances' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstVectorMaterialParam, ResetVectors) == 0x000050, "Member 'UInterpTrackInstVectorMaterialParam::ResetVectors' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstVectorMaterialParam, PrimitiveMaterialRefs) == 0x000060, "Member 'UInterpTrackInstVectorMaterialParam::PrimitiveMaterialRefs' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstVectorMaterialParam, InstancedTrack) == 0x000070, "Member 'UInterpTrackInstVectorMaterialParam::InstancedTrack' has a wrong offset!");

// Class Engine.BrushBuilder
// 0x0058 (0x0098 - 0x0040)
class UBrushBuilder : public UObject
{
public:
	class FString                                 BitmapFilename;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToolTip;                                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NotifyBadParams : 1;                               // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vertices;                                          // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBuilderPoly>                   Polys;                                             // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   Layer;                                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MergeCoplanars : 1;                                // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrushBuilder">();
	}
	static class UBrushBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrushBuilder>();
	}
};
static_assert(alignof(UBrushBuilder) == 0x000008, "Wrong alignment on UBrushBuilder");
static_assert(sizeof(UBrushBuilder) == 0x000098, "Wrong size on UBrushBuilder");
static_assert(offsetof(UBrushBuilder, BitmapFilename) == 0x000040, "Member 'UBrushBuilder::BitmapFilename' has a wrong offset!");
static_assert(offsetof(UBrushBuilder, ToolTip) == 0x000050, "Member 'UBrushBuilder::ToolTip' has a wrong offset!");
static_assert(offsetof(UBrushBuilder, Vertices) == 0x000068, "Member 'UBrushBuilder::Vertices' has a wrong offset!");
static_assert(offsetof(UBrushBuilder, Polys) == 0x000078, "Member 'UBrushBuilder::Polys' has a wrong offset!");
static_assert(offsetof(UBrushBuilder, Layer) == 0x000088, "Member 'UBrushBuilder::Layer' has a wrong offset!");

// Class Engine.InterpTrackInstVisibility
// 0x0008 (0x0048 - 0x0040)
class UInterpTrackInstVisibility : public UInterpTrackInst
{
public:
	EVisibilityTrackAction                        Action;                                            // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastUpdatePosition;                                // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstVisibility">();
	}
	static class UInterpTrackInstVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstVisibility>();
	}
};
static_assert(alignof(UInterpTrackInstVisibility) == 0x000008, "Wrong alignment on UInterpTrackInstVisibility");
static_assert(sizeof(UInterpTrackInstVisibility) == 0x000048, "Wrong size on UInterpTrackInstVisibility");
static_assert(offsetof(UInterpTrackInstVisibility, Action) == 0x000040, "Member 'UInterpTrackInstVisibility::Action' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstVisibility, LastUpdatePosition) == 0x000044, "Member 'UInterpTrackInstVisibility::LastUpdatePosition' has a wrong offset!");

// Class Engine.OcclusionPluginSourceSettingsBase
// 0x0000 (0x0040 - 0x0040)
class UOcclusionPluginSourceSettingsBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OcclusionPluginSourceSettingsBase">();
	}
	static class UOcclusionPluginSourceSettingsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOcclusionPluginSourceSettingsBase>();
	}
};
static_assert(alignof(UOcclusionPluginSourceSettingsBase) == 0x000008, "Wrong alignment on UOcclusionPluginSourceSettingsBase");
static_assert(sizeof(UOcclusionPluginSourceSettingsBase) == 0x000040, "Wrong size on UOcclusionPluginSourceSettingsBase");

// Class Engine.SoundEffectSourcePresetChain
// 0x0018 (0x0058 - 0x0040)
class USoundEffectSourcePresetChain final : public UObject
{
public:
	TArray<struct FSourceEffectChainEntry>        Chain;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bPlayEffectChainTails : 1;                         // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundEffectSourcePresetChain">();
	}
	static class USoundEffectSourcePresetChain* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundEffectSourcePresetChain>();
	}
};
static_assert(alignof(USoundEffectSourcePresetChain) == 0x000008, "Wrong alignment on USoundEffectSourcePresetChain");
static_assert(sizeof(USoundEffectSourcePresetChain) == 0x000058, "Wrong size on USoundEffectSourcePresetChain");
static_assert(offsetof(USoundEffectSourcePresetChain, Chain) == 0x000040, "Member 'USoundEffectSourcePresetChain::Chain' has a wrong offset!");

// Class Engine.InterpTrackLinearColorProp
// 0x0000 (0x112EE8B0 - 0x112EE8B0)
#pragma pack(push, 0x1)
class alignas(0x112EE8B0) UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase
{
public:
	class FName                                   PropertyName;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseInterpolation;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_StartInterpType;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_EndInterpType;                                   // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackLinearColorProp">();
	}
	static class UInterpTrackLinearColorProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackLinearColorProp>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackLinearColorProp) == 0x112EE8B0, "Wrong alignment on UInterpTrackLinearColorProp");
static_assert(sizeof(UInterpTrackLinearColorProp) == 0x112EE8B0, "Wrong size on UInterpTrackLinearColorProp");
static_assert(offsetof(UInterpTrackLinearColorProp, PropertyName) == 0x0000B0, "Member 'UInterpTrackLinearColorProp::PropertyName' has a wrong offset!");
static_assert(offsetof(UInterpTrackLinearColorProp, M_UseInterpolation) == 0x0000B8, "Member 'UInterpTrackLinearColorProp::M_UseInterpolation' has a wrong offset!");
static_assert(offsetof(UInterpTrackLinearColorProp, M_StartInterpType) == 0x0000B9, "Member 'UInterpTrackLinearColorProp::M_StartInterpType' has a wrong offset!");
static_assert(offsetof(UInterpTrackLinearColorProp, M_EndInterpType) == 0x0000BA, "Member 'UInterpTrackLinearColorProp::M_EndInterpType' has a wrong offset!");

// Class Engine.UserDefinedStruct
// 0x112E8C70 (0x112E8D20 - 0x00B0)
class UUserDefinedStruct : public UScriptStruct
{
public:
	struct FGuid                                  Guid;                                              // 0x00B0(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserDefinedStruct">();
	}
	static class UUserDefinedStruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserDefinedStruct>();
	}
};
static_assert(alignof(UUserDefinedStruct) == 0x112E8D20, "Wrong alignment on UUserDefinedStruct");
static_assert(sizeof(UUserDefinedStruct) == 0x112E8D20, "Wrong size on UUserDefinedStruct");
static_assert(offsetof(UUserDefinedStruct, Guid) == 0x0000B0, "Member 'UUserDefinedStruct::Guid' has a wrong offset!");

// Class Engine.SQEX_InterpTrackVector4Base
// 0x112EEF00 (0x112EEF90 - 0x0090)
#pragma pack(push, 0x1)
class alignas(0x112EEF90) USQEX_InterpTrackVector4Base : public UInterpTrack
{
public:
	struct FSQEX_InterpCurveVector4               Vector4Track;                                      // 0x0090(0x112EEF90)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveTension;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_InterpTrackVector4Base">();
	}
	static class USQEX_InterpTrackVector4Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_InterpTrackVector4Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(USQEX_InterpTrackVector4Base) == 0x112EEF90, "Wrong alignment on USQEX_InterpTrackVector4Base");
static_assert(sizeof(USQEX_InterpTrackVector4Base) == 0x112EEF90, "Wrong size on USQEX_InterpTrackVector4Base");
static_assert(offsetof(USQEX_InterpTrackVector4Base, Vector4Track) == 0x000090, "Member 'USQEX_InterpTrackVector4Base::Vector4Track' has a wrong offset!");
static_assert(offsetof(USQEX_InterpTrackVector4Base, CurveTension) == 0x0000A8, "Member 'USQEX_InterpTrackVector4Base::CurveTension' has a wrong offset!");

// Class Engine.ParticleModuleSize
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleSize : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                 StartSize;                                         // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReverseScaleXRate;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bXAndYSameSizeRate : 1;                            // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSize">();
	}
	static class UParticleModuleSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSize>();
	}
};
static_assert(alignof(UParticleModuleSize) == 0x000008, "Wrong alignment on UParticleModuleSize");
static_assert(sizeof(UParticleModuleSize) == 0x0000A8, "Wrong size on UParticleModuleSize");
static_assert(offsetof(UParticleModuleSize, StartSize) == 0x000050, "Member 'UParticleModuleSize::StartSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSize, ReverseScaleXRate) == 0x0000A0, "Member 'UParticleModuleSize::ReverseScaleXRate' has a wrong offset!");

// Class Engine.ParticleModuleSize_Seeded
// 0x0020 (0x00C8 - 0x00A8)
class UParticleModuleSize_Seeded final : public UParticleModuleSize
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00A8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSize_Seeded">();
	}
	static class UParticleModuleSize_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSize_Seeded>();
	}
};
static_assert(alignof(UParticleModuleSize_Seeded) == 0x000008, "Wrong alignment on UParticleModuleSize_Seeded");
static_assert(sizeof(UParticleModuleSize_Seeded) == 0x0000C8, "Wrong size on UParticleModuleSize_Seeded");
static_assert(offsetof(UParticleModuleSize_Seeded, RandomSeedInfo) == 0x0000A8, "Member 'UParticleModuleSize_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.NavArea
// 0x0018 (0x0058 - 0x0040)
class UNavArea : public UObject
{
public:
	float                                         DefaultCost;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedAreaEnteringCost;                             // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DrawColor;                                         // 0x0048(0x0004)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAgentSelector                      SupportedAgents;                                   // 0x004C(0x0004)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bSupportsAgent0 : 1;                               // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent1 : 1;                               // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent2 : 1;                               // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent3 : 1;                               // 0x0050(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent4 : 1;                               // 0x0050(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent5 : 1;                               // 0x0050(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent6 : 1;                               // 0x0050(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent7 : 1;                               // 0x0050(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent8 : 1;                               // 0x0051(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent9 : 1;                               // 0x0051(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent10 : 1;                              // 0x0051(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent11 : 1;                              // 0x0051(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent12 : 1;                              // 0x0051(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent13 : 1;                              // 0x0051(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent14 : 1;                              // 0x0051(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent15 : 1;                              // 0x0051(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea">();
	}
	static class UNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea>();
	}
};
static_assert(alignof(UNavArea) == 0x000008, "Wrong alignment on UNavArea");
static_assert(sizeof(UNavArea) == 0x000058, "Wrong size on UNavArea");
static_assert(offsetof(UNavArea, DefaultCost) == 0x000040, "Member 'UNavArea::DefaultCost' has a wrong offset!");
static_assert(offsetof(UNavArea, FixedAreaEnteringCost) == 0x000044, "Member 'UNavArea::FixedAreaEnteringCost' has a wrong offset!");
static_assert(offsetof(UNavArea, DrawColor) == 0x000048, "Member 'UNavArea::DrawColor' has a wrong offset!");
static_assert(offsetof(UNavArea, SupportedAgents) == 0x00004C, "Member 'UNavArea::SupportedAgents' has a wrong offset!");

// Class Engine.NavArea_LowHeight
// 0x0000 (0x0058 - 0x0058)
class UNavArea_LowHeight final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_LowHeight">();
	}
	static class UNavArea_LowHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_LowHeight>();
	}
};
static_assert(alignof(UNavArea_LowHeight) == 0x000008, "Wrong alignment on UNavArea_LowHeight");
static_assert(sizeof(UNavArea_LowHeight) == 0x000058, "Wrong size on UNavArea_LowHeight");

// Class Engine.SQEX_InterpTrackVector4Prop
// 0x0000 (0x112EEF90 - 0x112EEF90)
#pragma pack(push, 0x1)
class alignas(0x112EEF90) USQEX_InterpTrackVector4Prop : public USQEX_InterpTrackVector4Base
{
public:
	class FName                                   PropertyName;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseInterpolation;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_StartInterpType;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_EndInterpType;                                   // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_InterpTrackVector4Prop">();
	}
	static class USQEX_InterpTrackVector4Prop* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_InterpTrackVector4Prop>();
	}
};
#pragma pack(pop)
static_assert(alignof(USQEX_InterpTrackVector4Prop) == 0x112EEF90, "Wrong alignment on USQEX_InterpTrackVector4Prop");
static_assert(sizeof(USQEX_InterpTrackVector4Prop) == 0x112EEF90, "Wrong size on USQEX_InterpTrackVector4Prop");
static_assert(offsetof(USQEX_InterpTrackVector4Prop, PropertyName) == 0x0000B0, "Member 'USQEX_InterpTrackVector4Prop::PropertyName' has a wrong offset!");
static_assert(offsetof(USQEX_InterpTrackVector4Prop, M_UseInterpolation) == 0x0000B8, "Member 'USQEX_InterpTrackVector4Prop::M_UseInterpolation' has a wrong offset!");
static_assert(offsetof(USQEX_InterpTrackVector4Prop, M_StartInterpType) == 0x0000B9, "Member 'USQEX_InterpTrackVector4Prop::M_StartInterpType' has a wrong offset!");
static_assert(offsetof(USQEX_InterpTrackVector4Prop, M_EndInterpType) == 0x0000BA, "Member 'USQEX_InterpTrackVector4Prop::M_EndInterpType' has a wrong offset!");

// Class Engine.SQEX_EffectEmitterPresetDataBase
// 0x0000 (0x0040 - 0x0040)
class USQEX_EffectEmitterPresetDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_EffectEmitterPresetDataBase">();
	}
	static class USQEX_EffectEmitterPresetDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_EffectEmitterPresetDataBase>();
	}
};
static_assert(alignof(USQEX_EffectEmitterPresetDataBase) == 0x000008, "Wrong alignment on USQEX_EffectEmitterPresetDataBase");
static_assert(sizeof(USQEX_EffectEmitterPresetDataBase) == 0x000040, "Wrong size on USQEX_EffectEmitterPresetDataBase");

// Class Engine.AsyncActionLoadPrimaryAssetClass
// 0x0010 (0x0098 - 0x0088)
class UAsyncActionLoadPrimaryAssetClass final : public UAsyncActionLoadPrimaryAssetBase
{
public:
	UMulticastDelegateProperty_                   Completed;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncActionLoadPrimaryAssetClass* AsyncLoadPrimaryAssetClass(const struct FPrimaryAssetId& PrimaryAsset, const TArray<class FName>& LoadBundles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionLoadPrimaryAssetClass">();
	}
	static class UAsyncActionLoadPrimaryAssetClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionLoadPrimaryAssetClass>();
	}
};
static_assert(alignof(UAsyncActionLoadPrimaryAssetClass) == 0x000008, "Wrong alignment on UAsyncActionLoadPrimaryAssetClass");
static_assert(sizeof(UAsyncActionLoadPrimaryAssetClass) == 0x000098, "Wrong size on UAsyncActionLoadPrimaryAssetClass");
static_assert(offsetof(UAsyncActionLoadPrimaryAssetClass, Completed) == 0x000088, "Member 'UAsyncActionLoadPrimaryAssetClass::Completed' has a wrong offset!");

// Class Engine.InterpTrackVectorMaterialParam
// 0x0000 (0x112ED410 - 0x112ED410)
#pragma pack(push, 0x1)
class alignas(0x112ED410) UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase
{
public:
	TArray<class UMaterialInterface*>             TargetMaterials;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackVectorMaterialParam">();
	}
	static class UInterpTrackVectorMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackVectorMaterialParam>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackVectorMaterialParam) == 0x112ED410, "Wrong alignment on UInterpTrackVectorMaterialParam");
static_assert(sizeof(UInterpTrackVectorMaterialParam) == 0x112ED410, "Wrong size on UInterpTrackVectorMaterialParam");
static_assert(offsetof(UInterpTrackVectorMaterialParam, TargetMaterials) == 0x0000B0, "Member 'UInterpTrackVectorMaterialParam::TargetMaterials' has a wrong offset!");
static_assert(offsetof(UInterpTrackVectorMaterialParam, ParamName) == 0x0000C0, "Member 'UInterpTrackVectorMaterialParam::ParamName' has a wrong offset!");

// Class Engine.NavigationData
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ANavigationData : public AActor
{
public:
	class UPrimitiveComponent*                    RenderingComp;                                     // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavDataConfig                         NavDataConfig;                                     // 0x03E8(0x12A61)(Protected, NativeAccessSpecifierProtected)
	uint8                                         bEnableDrawing : 1;                                // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bForceRebuildOnLoad : 1;                           // 0x0438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanBeMainNavData : 1;                             // 0x0438(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSpawnOnRebuild : 1;                            // 0x0438(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRebuildAtRuntime : 1;                             // 0x0438(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ERuntimeGenerationType                        RuntimeGeneration;                                 // 0x043C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObservedPathsTickInterval;                         // 0x0440(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        DataVersion;                                       // 0x0444(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0xD0];                                     // 0x0448(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSupportedAreaData>             SupportedAreas;                                    // 0x0518(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x58];                                     // 0x0528(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationData">();
	}
	static class ANavigationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationData>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANavigationData) == 0x1EF72E00, "Wrong alignment on ANavigationData");
static_assert(sizeof(ANavigationData) == 0x1EF72E00, "Wrong size on ANavigationData");
static_assert(offsetof(ANavigationData, RenderingComp) == 0x0003E0, "Member 'ANavigationData::RenderingComp' has a wrong offset!");
static_assert(offsetof(ANavigationData, NavDataConfig) == 0x0003E8, "Member 'ANavigationData::NavDataConfig' has a wrong offset!");
static_assert(offsetof(ANavigationData, RuntimeGeneration) == 0x00043C, "Member 'ANavigationData::RuntimeGeneration' has a wrong offset!");
static_assert(offsetof(ANavigationData, ObservedPathsTickInterval) == 0x000440, "Member 'ANavigationData::ObservedPathsTickInterval' has a wrong offset!");
static_assert(offsetof(ANavigationData, DataVersion) == 0x000444, "Member 'ANavigationData::DataVersion' has a wrong offset!");
static_assert(offsetof(ANavigationData, SupportedAreas) == 0x000518, "Member 'ANavigationData::SupportedAreas' has a wrong offset!");

// Class Engine.NavigationGraph
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ANavigationGraph final : public ANavigationData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationGraph">();
	}
	static class ANavigationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationGraph>();
	}
};
static_assert(alignof(ANavigationGraph) == 0x1EF72E00, "Wrong alignment on ANavigationGraph");
static_assert(sizeof(ANavigationGraph) == 0x1EF72E00, "Wrong size on ANavigationGraph");

// Class Engine.InterpTrackVectorProp
// 0x0000 (0x112ED410 - 0x112ED410)
#pragma pack(push, 0x1)
class alignas(0x112ED410) UInterpTrackVectorProp : public UInterpTrackVectorBase
{
public:
	class FName                                   PropertyName;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_UseInterpolation;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_StartInterpType;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             M_EndInterpType;                                   // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackVectorProp">();
	}
	static class UInterpTrackVectorProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackVectorProp>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInterpTrackVectorProp) == 0x112ED410, "Wrong alignment on UInterpTrackVectorProp");
static_assert(sizeof(UInterpTrackVectorProp) == 0x112ED410, "Wrong size on UInterpTrackVectorProp");
static_assert(offsetof(UInterpTrackVectorProp, PropertyName) == 0x0000B0, "Member 'UInterpTrackVectorProp::PropertyName' has a wrong offset!");
static_assert(offsetof(UInterpTrackVectorProp, M_UseInterpolation) == 0x0000B8, "Member 'UInterpTrackVectorProp::M_UseInterpolation' has a wrong offset!");
static_assert(offsetof(UInterpTrackVectorProp, M_StartInterpType) == 0x0000B9, "Member 'UInterpTrackVectorProp::M_StartInterpType' has a wrong offset!");
static_assert(offsetof(UInterpTrackVectorProp, M_EndInterpType) == 0x0000BA, "Member 'UInterpTrackVectorProp::M_EndInterpType' has a wrong offset!");

// Class Engine.LocalMessage
// 0x0000 (0x0040 - 0x0040)
class ULocalMessage : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalMessage">();
	}
	static class ULocalMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalMessage>();
	}
};
static_assert(alignof(ULocalMessage) == 0x000008, "Wrong alignment on ULocalMessage");
static_assert(sizeof(ULocalMessage) == 0x000040, "Wrong size on ULocalMessage");

// Class Engine.InterpTrackVisibility
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackVisibility : public UInterpTrack
{
public:
	TArray<struct FVisibilityTrackKey>            VisibilityTrack;                                   // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenJumpingForwards : 1;                // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackVisibility">();
	}
	static class UInterpTrackVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackVisibility>();
	}
};
static_assert(alignof(UInterpTrackVisibility) == 0x000008, "Wrong alignment on UInterpTrackVisibility");
static_assert(sizeof(UInterpTrackVisibility) == 0x0000A8, "Wrong size on UInterpTrackVisibility");
static_assert(offsetof(UInterpTrackVisibility, VisibilityTrack) == 0x000090, "Member 'UInterpTrackVisibility::VisibilityTrack' has a wrong offset!");

// Class Engine.MatineeAnimInterface
// 0x0000 (0x0040 - 0x0040)
class IMatineeAnimInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatineeAnimInterface">();
	}
	static class IMatineeAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatineeAnimInterface>();
	}
};
static_assert(alignof(IMatineeAnimInterface) == 0x000008, "Wrong alignment on IMatineeAnimInterface");
static_assert(sizeof(IMatineeAnimInterface) == 0x000040, "Wrong size on IMatineeAnimInterface");

// Class Engine.InterpTrackInstSound
// 0x0010 (0x0050 - 0x0040)
class UInterpTrackInstSound : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        PlayAudioComp;                                     // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstSound">();
	}
	static class UInterpTrackInstSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstSound>();
	}
};
static_assert(alignof(UInterpTrackInstSound) == 0x000008, "Wrong alignment on UInterpTrackInstSound");
static_assert(sizeof(UInterpTrackInstSound) == 0x000050, "Wrong size on UInterpTrackInstSound");
static_assert(offsetof(UInterpTrackInstSound, LastUpdatePosition) == 0x000040, "Member 'UInterpTrackInstSound::LastUpdatePosition' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstSound, PlayAudioComp) == 0x000048, "Member 'UInterpTrackInstSound::PlayAudioComp' has a wrong offset!");

// Class Engine.LevelScriptActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ALevelScriptActor : public AActor
{
public:
	uint8                                         bInputEnabled : 1;                                 // 0x03E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LevelReset();
	bool RemoteEvent(class FName EventName);
	void SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
	void SQEX_BegunPlay();
	class ALevelScriptActor* SQEX_GetLevelScriptActor(const class FString& LevelName);
	void WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelScriptActor">();
	}
	static class ALevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelScriptActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ALevelScriptActor) == 0x1EF72E00, "Wrong alignment on ALevelScriptActor");
static_assert(sizeof(ALevelScriptActor) == 0x1EF72E00, "Wrong size on ALevelScriptActor");

// Class Engine.TextRenderActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ATextRenderActor final : public AActor
{
public:
	class UTextRenderComponent*                   TextRender;                                        // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextRenderActor">();
	}
	static class ATextRenderActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATextRenderActor>();
	}
};
static_assert(alignof(ATextRenderActor) == 0x1EF72E00, "Wrong alignment on ATextRenderActor");
static_assert(sizeof(ATextRenderActor) == 0x1EF72E00, "Wrong size on ATextRenderActor");
static_assert(offsetof(ATextRenderActor, TextRender) == 0x0003E0, "Member 'ATextRenderActor::TextRender' has a wrong offset!");

// Class Engine.PendingNetGame
// 0x00A0 (0x00E0 - 0x0040)
class UPendingNetGame : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetDriver*                             NetDriver;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDemoNetDriver*                         DemoNetDriver;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x88];                                      // 0x0058(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PendingNetGame">();
	}
	static class UPendingNetGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPendingNetGame>();
	}
};
static_assert(alignof(UPendingNetGame) == 0x000008, "Wrong alignment on UPendingNetGame");
static_assert(sizeof(UPendingNetGame) == 0x0000E0, "Wrong size on UPendingNetGame");
static_assert(offsetof(UPendingNetGame, NetDriver) == 0x000048, "Member 'UPendingNetGame::NetDriver' has a wrong offset!");
static_assert(offsetof(UPendingNetGame, DemoNetDriver) == 0x000050, "Member 'UPendingNetGame::DemoNetDriver' has a wrong offset!");

// Class Engine.AnimSingleNodeInstance
// 0x0018 (0x03B0 - 0x0398)
class UAnimSingleNodeInstance : public UAnimInstance
{
public:
	class UAnimationAsset*                        CurrentAsset;                                      // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PostEvaluateAnimEvent;                             // 0x03A0(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	float GetLength();
	void PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition);
	void SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate);
	void SetBlendSpaceInput(const struct FVector& InBlendInput);
	void SetLooping(bool bIsLooping);
	void SetPlaying(bool bIsPlaying);
	void SetPlayRate(float InPlayRate);
	void SetPosition(float InPosition, bool bFireNotifies);
	void SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies);
	void SetPreviewCurveOverride(const class FName& PoseName, float Value, bool bRemoveIfZero);
	void SetReverse(bool bInReverse);
	void StopAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimSingleNodeInstance">();
	}
	static class UAnimSingleNodeInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimSingleNodeInstance>();
	}
};
static_assert(alignof(UAnimSingleNodeInstance) == 0x000008, "Wrong alignment on UAnimSingleNodeInstance");
static_assert(sizeof(UAnimSingleNodeInstance) == 0x0003B0, "Wrong size on UAnimSingleNodeInstance");
static_assert(offsetof(UAnimSingleNodeInstance, CurrentAsset) == 0x000398, "Member 'UAnimSingleNodeInstance::CurrentAsset' has a wrong offset!");
static_assert(offsetof(UAnimSingleNodeInstance, PostEvaluateAnimEvent) == 0x0003A0, "Member 'UAnimSingleNodeInstance::PostEvaluateAnimEvent' has a wrong offset!");

// Class Engine.BlueprintCore
// 0x112E8CE0 (0x112E8D20 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UBlueprintCore : public UObject
{
public:
	TSubclassOf<class UObject>                    SkeletonGeneratedClass;                            // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    GeneratedClass;                                    // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLegacyNeedToPurgeSkelRefs;                        // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLegacyGeneratedClassIsAuthoritative;              // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  BlueprintGuid;                                     // 0x0054(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintCore">();
	}
	static class UBlueprintCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintCore>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBlueprintCore) == 0x112E8D20, "Wrong alignment on UBlueprintCore");
static_assert(sizeof(UBlueprintCore) == 0x112E8D20, "Wrong size on UBlueprintCore");
static_assert(offsetof(UBlueprintCore, SkeletonGeneratedClass) == 0x000040, "Member 'UBlueprintCore::SkeletonGeneratedClass' has a wrong offset!");
static_assert(offsetof(UBlueprintCore, GeneratedClass) == 0x000048, "Member 'UBlueprintCore::GeneratedClass' has a wrong offset!");
static_assert(offsetof(UBlueprintCore, bLegacyNeedToPurgeSkelRefs) == 0x000050, "Member 'UBlueprintCore::bLegacyNeedToPurgeSkelRefs' has a wrong offset!");
static_assert(offsetof(UBlueprintCore, bLegacyGeneratedClassIsAuthoritative) == 0x000051, "Member 'UBlueprintCore::bLegacyGeneratedClassIsAuthoritative' has a wrong offset!");
static_assert(offsetof(UBlueprintCore, BlueprintGuid) == 0x000054, "Member 'UBlueprintCore::BlueprintGuid' has a wrong offset!");

// Class Engine.Blueprint
// 0x0000 (0x112E8D20 - 0x112E8D20)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UBlueprint : public UBlueprintCore
{
public:
	uint8                                         bRecompileOnLoad : 1;                              // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    ParentClass;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                PRIVATE_InnermostPreviousCDO;                      // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasBeenRegenerated : 1;                           // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRegeneratingOnLoad : 1;                         // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USimpleConstructionScript*              SimpleConstructionScript;                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ComponentTemplates;                                // 0x0090(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UTimelineTemplate*>              Timelines;                                         // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UInheritableComponentHandler*           InheritableComponentHandler;                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlueprintType                                BlueprintType;                                     // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlueprintSystemVersion;                            // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0xE0];                                      // 0x00C0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNativize;                                         // 0x01A0(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Blueprint">();
	}
	static class UBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprint>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBlueprint) == 0x112E8D20, "Wrong alignment on UBlueprint");
static_assert(sizeof(UBlueprint) == 0x112E8D20, "Wrong size on UBlueprint");
static_assert(offsetof(UBlueprint, ParentClass) == 0x000070, "Member 'UBlueprint::ParentClass' has a wrong offset!");
static_assert(offsetof(UBlueprint, PRIVATE_InnermostPreviousCDO) == 0x000078, "Member 'UBlueprint::PRIVATE_InnermostPreviousCDO' has a wrong offset!");
static_assert(offsetof(UBlueprint, SimpleConstructionScript) == 0x000088, "Member 'UBlueprint::SimpleConstructionScript' has a wrong offset!");
static_assert(offsetof(UBlueprint, ComponentTemplates) == 0x000090, "Member 'UBlueprint::ComponentTemplates' has a wrong offset!");
static_assert(offsetof(UBlueprint, Timelines) == 0x0000A0, "Member 'UBlueprint::Timelines' has a wrong offset!");
static_assert(offsetof(UBlueprint, InheritableComponentHandler) == 0x0000B0, "Member 'UBlueprint::InheritableComponentHandler' has a wrong offset!");
static_assert(offsetof(UBlueprint, BlueprintType) == 0x0000B8, "Member 'UBlueprint::BlueprintType' has a wrong offset!");
static_assert(offsetof(UBlueprint, BlueprintSystemVersion) == 0x0000BC, "Member 'UBlueprint::BlueprintSystemVersion' has a wrong offset!");
static_assert(offsetof(UBlueprint, bNativize) == 0x0001A0, "Member 'UBlueprint::bNativize' has a wrong offset!");

// Class Engine.AnimBlueprint
// 0x0000 (0x112E8D20 - 0x112E8D20)
class UAnimBlueprint final : public UBlueprint
{
public:
	class USkeleton*                              TargetSkeleton;                                    // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimGroupInfo>                 Groups;                                            // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseMultiThreadedAnimationUpdate;                  // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnAboutBlueprintUsage;                          // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0xE];                                      // 0x01C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimBlueprint">();
	}
	static class UAnimBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimBlueprint>();
	}
};
static_assert(alignof(UAnimBlueprint) == 0x112E8D20, "Wrong alignment on UAnimBlueprint");
static_assert(sizeof(UAnimBlueprint) == 0x112E8D20, "Wrong size on UAnimBlueprint");
static_assert(offsetof(UAnimBlueprint, TargetSkeleton) == 0x0001A8, "Member 'UAnimBlueprint::TargetSkeleton' has a wrong offset!");
static_assert(offsetof(UAnimBlueprint, Groups) == 0x0001B0, "Member 'UAnimBlueprint::Groups' has a wrong offset!");
static_assert(offsetof(UAnimBlueprint, bUseMultiThreadedAnimationUpdate) == 0x0001C0, "Member 'UAnimBlueprint::bUseMultiThreadedAnimationUpdate' has a wrong offset!");
static_assert(offsetof(UAnimBlueprint, bWarnAboutBlueprintUsage) == 0x0001C1, "Member 'UAnimBlueprint::bWarnAboutBlueprintUsage' has a wrong offset!");

// Class Engine.MapBuildDataRegistry
// 0x0150 (0x0190 - 0x0040)
class UMapBuildDataRegistry final : public UObject
{
public:
	ELightingBuildQuality                         LevelLightingQuality;                              // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x14F];                                     // 0x0041(0x014F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapBuildDataRegistry">();
	}
	static class UMapBuildDataRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapBuildDataRegistry>();
	}
};
static_assert(alignof(UMapBuildDataRegistry) == 0x000008, "Wrong alignment on UMapBuildDataRegistry");
static_assert(sizeof(UMapBuildDataRegistry) == 0x000190, "Wrong size on UMapBuildDataRegistry");
static_assert(offsetof(UMapBuildDataRegistry, LevelLightingQuality) == 0x000040, "Member 'UMapBuildDataRegistry::LevelLightingQuality' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_BlurBase
// 0x0020 (0x0070 - 0x0050)
class UParticleModuleSQEX_BlurBase : public UParticleModuleSQEX_Base
{
public:
	float                                         StartTime;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReestPlayList : 1;                                // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETresScreenEffectPriority                     EffectPriority;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsEnableAdjastFade : 1;                           // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjastFadeRate;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsEnableDistanceFade : 1;                         // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceFadeRate;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_BlurBase">();
	}
	static class UParticleModuleSQEX_BlurBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_BlurBase>();
	}
};
static_assert(alignof(UParticleModuleSQEX_BlurBase) == 0x000008, "Wrong alignment on UParticleModuleSQEX_BlurBase");
static_assert(sizeof(UParticleModuleSQEX_BlurBase) == 0x000070, "Wrong size on UParticleModuleSQEX_BlurBase");
static_assert(offsetof(UParticleModuleSQEX_BlurBase, StartTime) == 0x000050, "Member 'UParticleModuleSQEX_BlurBase::StartTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BlurBase, EndTime) == 0x000054, "Member 'UParticleModuleSQEX_BlurBase::EndTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BlurBase, EffectPriority) == 0x00005C, "Member 'UParticleModuleSQEX_BlurBase::EffectPriority' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BlurBase, AdjastFadeRate) == 0x000064, "Member 'UParticleModuleSQEX_BlurBase::AdjastFadeRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BlurBase, DistanceFadeRate) == 0x00006C, "Member 'UParticleModuleSQEX_BlurBase::DistanceFadeRate' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_RadialBlur
// 0x0210 (0x0280 - 0x0070)
class UParticleModuleSQEX_RadialBlur final : public UParticleModuleSQEX_BlurBase
{
public:
	ESqexRadialBlurMode                           Mode;                                              // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Power;                                             // 0x0078(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Angle;                                             // 0x00B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Alpha;                                             // 0x00E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseScreenPos : 1;                                 // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  PosX;                                              // 0x0128(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  PosY;                                              // 0x0160(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Range;                                             // 0x0198(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  HoleSize;                                          // 0x01D0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AttenuationDistanceOutside;                        // 0x0208(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AttenuationDistanceInside;                         // 0x0240(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCameraPitchCheck : 1;                             // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckCameraPich;                                   // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_RadialBlur">();
	}
	static class UParticleModuleSQEX_RadialBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_RadialBlur>();
	}
};
static_assert(alignof(UParticleModuleSQEX_RadialBlur) == 0x000008, "Wrong alignment on UParticleModuleSQEX_RadialBlur");
static_assert(sizeof(UParticleModuleSQEX_RadialBlur) == 0x000280, "Wrong size on UParticleModuleSQEX_RadialBlur");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, Mode) == 0x000070, "Member 'UParticleModuleSQEX_RadialBlur::Mode' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, Power) == 0x000078, "Member 'UParticleModuleSQEX_RadialBlur::Power' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, Angle) == 0x0000B0, "Member 'UParticleModuleSQEX_RadialBlur::Angle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, Alpha) == 0x0000E8, "Member 'UParticleModuleSQEX_RadialBlur::Alpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, PosX) == 0x000128, "Member 'UParticleModuleSQEX_RadialBlur::PosX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, PosY) == 0x000160, "Member 'UParticleModuleSQEX_RadialBlur::PosY' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, Range) == 0x000198, "Member 'UParticleModuleSQEX_RadialBlur::Range' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, HoleSize) == 0x0001D0, "Member 'UParticleModuleSQEX_RadialBlur::HoleSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, AttenuationDistanceOutside) == 0x000208, "Member 'UParticleModuleSQEX_RadialBlur::AttenuationDistanceOutside' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, AttenuationDistanceInside) == 0x000240, "Member 'UParticleModuleSQEX_RadialBlur::AttenuationDistanceInside' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RadialBlur, CheckCameraPich) == 0x00027C, "Member 'UParticleModuleSQEX_RadialBlur::CheckCameraPich' has a wrong offset!");

// Class Engine.MaterialExpressionFunctionOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFunctionOutput final : public UMaterialExpression
{
public:
	class FString                                 OutputName;                                        // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       A;                                                 // 0x00A0(0x112F2730)(NativeAccessSpecifierPublic)
	uint8                                         bLastPreviewed : 1;                                // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ID;                                                // 0x00DC(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFunctionOutput">();
	}
	static class UMaterialExpressionFunctionOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFunctionOutput>();
	}
};
static_assert(alignof(UMaterialExpressionFunctionOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionFunctionOutput");
static_assert(sizeof(UMaterialExpressionFunctionOutput) == 0x112F2730, "Wrong size on UMaterialExpressionFunctionOutput");
static_assert(offsetof(UMaterialExpressionFunctionOutput, OutputName) == 0x000078, "Member 'UMaterialExpressionFunctionOutput::OutputName' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionOutput, Description) == 0x000088, "Member 'UMaterialExpressionFunctionOutput::Description' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionOutput, SortPriority) == 0x000098, "Member 'UMaterialExpressionFunctionOutput::SortPriority' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionOutput, A) == 0x0000A0, "Member 'UMaterialExpressionFunctionOutput::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionOutput, ID) == 0x0000DC, "Member 'UMaterialExpressionFunctionOutput::ID' has a wrong offset!");

// Class Engine.World
// 0x1EF734F0 (0x1EF73530 - 0x0040)
class UWorld final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevel*                                 PersistentLevel;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetDriver*                             NetDriver;                                         // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULineBatchComponent*                    LineBatcher;                                       // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULineBatchComponent*                    PersistentLineBatcher;                             // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULineBatchComponent*                    ForegroundLineBatcher;                             // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameNetworkManager*                    NetworkManager;                                    // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsCollisionHandler*               PhysicsCollisionHandler;                           // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        ExtraReferencedObjects;                            // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        PerModuleDataObjects;                              // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                StreamingLevels;                                   // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FString                                 StreamingLevelsPrefix;                             // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 CurrentLevelPendingVisibility;                     // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 CurrentLevelPendingInvisibility;                   // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDemoNetDriver*                         DemoNetDriver;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AParticleEventManager*                  MyParticleEventManager;                            // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APhysicsVolume*                         DefaultPhysicsVolume;                              // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavigationSystem*                      NavigationSystem;                                  // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameModeBase*                          AuthorityGameMode;                                 // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameStateBase*                         GameState;                                         // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAISystemBase*                          AISystem;                                          // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAvoidanceManager*                      AvoidanceManager;                                  // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ULevel*>                         Levels;                                            // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FLevelCollection>               LevelCollections;                                  // 0x0138(0x0010)(ZeroConstructor, Transient, NonTransactional, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevel*                                 CurrentLevel;                                      // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameInstance*                          OwningGameInstance;                                // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialParameterCollectionInstance*> ParameterCollectionInstances;                      // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCanvas*                                CanvasForRenderingToTarget;                        // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvas*                                CanvasForDrawMaterialToRenderTarget;               // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x7F8];                                    // 0x0180(0x07F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldComposition*                      WorldComposition;                                  // 0x0978(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_980[0x4A];                                     // 0x0980(0x004A)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAreConstraintsDirty : 1;                          // 0x09CA(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9CB[0xD];                                      // 0x09CB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorldPSCPool                          PSCPool;                                           // 0x09D8(0x1EF73530)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ALevelScriptActor*>              M_BegunPlayLevelScriptActors;                      // 0x0A30(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMatineeActor*>                  M_PendingPlayMatineeActors;                        // 0x0A40(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A50[0x30];                                     // 0x0A50(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class APhysicsVolume*                         SQEX_OceanPhysicsVolume;                           // 0x0A80(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicalMaterial*                      SQEX_OceanPhysMaterial;                            // 0x0A88(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A90[0x20];                                     // 0x0A90(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        SQEX_CmnSnowTailAsset;                             // 0x0AB0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB8[0x18];                                     // 0x0AB8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UWorld* GetWorld();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"World">();
	}
	static class UWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorld>();
	}
};
static_assert(alignof(UWorld) == 0x1EF73530, "Wrong alignment on UWorld");
static_assert(sizeof(UWorld) == 0x1EF73530, "Wrong size on UWorld");
static_assert(offsetof(UWorld, PersistentLevel) == 0x000048, "Member 'UWorld::PersistentLevel' has a wrong offset!");
static_assert(offsetof(UWorld, NetDriver) == 0x000050, "Member 'UWorld::NetDriver' has a wrong offset!");
static_assert(offsetof(UWorld, LineBatcher) == 0x000058, "Member 'UWorld::LineBatcher' has a wrong offset!");
static_assert(offsetof(UWorld, PersistentLineBatcher) == 0x000060, "Member 'UWorld::PersistentLineBatcher' has a wrong offset!");
static_assert(offsetof(UWorld, ForegroundLineBatcher) == 0x000068, "Member 'UWorld::ForegroundLineBatcher' has a wrong offset!");
static_assert(offsetof(UWorld, NetworkManager) == 0x000070, "Member 'UWorld::NetworkManager' has a wrong offset!");
static_assert(offsetof(UWorld, PhysicsCollisionHandler) == 0x000078, "Member 'UWorld::PhysicsCollisionHandler' has a wrong offset!");
static_assert(offsetof(UWorld, ExtraReferencedObjects) == 0x000080, "Member 'UWorld::ExtraReferencedObjects' has a wrong offset!");
static_assert(offsetof(UWorld, PerModuleDataObjects) == 0x000090, "Member 'UWorld::PerModuleDataObjects' has a wrong offset!");
static_assert(offsetof(UWorld, StreamingLevels) == 0x0000A0, "Member 'UWorld::StreamingLevels' has a wrong offset!");
static_assert(offsetof(UWorld, StreamingLevelsPrefix) == 0x0000B0, "Member 'UWorld::StreamingLevelsPrefix' has a wrong offset!");
static_assert(offsetof(UWorld, CurrentLevelPendingVisibility) == 0x0000C0, "Member 'UWorld::CurrentLevelPendingVisibility' has a wrong offset!");
static_assert(offsetof(UWorld, CurrentLevelPendingInvisibility) == 0x0000C8, "Member 'UWorld::CurrentLevelPendingInvisibility' has a wrong offset!");
static_assert(offsetof(UWorld, DemoNetDriver) == 0x0000D0, "Member 'UWorld::DemoNetDriver' has a wrong offset!");
static_assert(offsetof(UWorld, MyParticleEventManager) == 0x0000D8, "Member 'UWorld::MyParticleEventManager' has a wrong offset!");
static_assert(offsetof(UWorld, DefaultPhysicsVolume) == 0x0000E0, "Member 'UWorld::DefaultPhysicsVolume' has a wrong offset!");
static_assert(offsetof(UWorld, NavigationSystem) == 0x000100, "Member 'UWorld::NavigationSystem' has a wrong offset!");
static_assert(offsetof(UWorld, AuthorityGameMode) == 0x000108, "Member 'UWorld::AuthorityGameMode' has a wrong offset!");
static_assert(offsetof(UWorld, GameState) == 0x000110, "Member 'UWorld::GameState' has a wrong offset!");
static_assert(offsetof(UWorld, AISystem) == 0x000118, "Member 'UWorld::AISystem' has a wrong offset!");
static_assert(offsetof(UWorld, AvoidanceManager) == 0x000120, "Member 'UWorld::AvoidanceManager' has a wrong offset!");
static_assert(offsetof(UWorld, Levels) == 0x000128, "Member 'UWorld::Levels' has a wrong offset!");
static_assert(offsetof(UWorld, LevelCollections) == 0x000138, "Member 'UWorld::LevelCollections' has a wrong offset!");
static_assert(offsetof(UWorld, CurrentLevel) == 0x000150, "Member 'UWorld::CurrentLevel' has a wrong offset!");
static_assert(offsetof(UWorld, OwningGameInstance) == 0x000158, "Member 'UWorld::OwningGameInstance' has a wrong offset!");
static_assert(offsetof(UWorld, ParameterCollectionInstances) == 0x000160, "Member 'UWorld::ParameterCollectionInstances' has a wrong offset!");
static_assert(offsetof(UWorld, CanvasForRenderingToTarget) == 0x000170, "Member 'UWorld::CanvasForRenderingToTarget' has a wrong offset!");
static_assert(offsetof(UWorld, CanvasForDrawMaterialToRenderTarget) == 0x000178, "Member 'UWorld::CanvasForDrawMaterialToRenderTarget' has a wrong offset!");
static_assert(offsetof(UWorld, WorldComposition) == 0x000978, "Member 'UWorld::WorldComposition' has a wrong offset!");
static_assert(offsetof(UWorld, PSCPool) == 0x0009D8, "Member 'UWorld::PSCPool' has a wrong offset!");
static_assert(offsetof(UWorld, M_BegunPlayLevelScriptActors) == 0x000A30, "Member 'UWorld::M_BegunPlayLevelScriptActors' has a wrong offset!");
static_assert(offsetof(UWorld, M_PendingPlayMatineeActors) == 0x000A40, "Member 'UWorld::M_PendingPlayMatineeActors' has a wrong offset!");
static_assert(offsetof(UWorld, SQEX_OceanPhysicsVolume) == 0x000A80, "Member 'UWorld::SQEX_OceanPhysicsVolume' has a wrong offset!");
static_assert(offsetof(UWorld, SQEX_OceanPhysMaterial) == 0x000A88, "Member 'UWorld::SQEX_OceanPhysMaterial' has a wrong offset!");
static_assert(offsetof(UWorld, SQEX_CmnSnowTailAsset) == 0x000AB0, "Member 'UWorld::SQEX_CmnSnowTailAsset' has a wrong offset!");

// Class Engine.ImportantToggleSettingInterface
// 0x0000 (0x0040 - 0x0040)
class IImportantToggleSettingInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImportantToggleSettingInterface">();
	}
	static class IImportantToggleSettingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IImportantToggleSettingInterface>();
	}
};
static_assert(alignof(IImportantToggleSettingInterface) == 0x000008, "Wrong alignment on IImportantToggleSettingInterface");
static_assert(sizeof(IImportantToggleSettingInterface) == 0x000040, "Wrong size on IImportantToggleSettingInterface");

// Class Engine.NavigationSystem
// 0x0440 (0x0480 - 0x0040)
class UNavigationSystem : public UBlueprintFunctionLibrary
{
public:
	class ANavigationData*                        MainNavData;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationData*                        AbstractNavData;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCrowdManagerBase>          CrowdManagerClass;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoCreateNavigationData : 1;                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowClientSideNavigation : 1;                    // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSupportRebuilding : 1;                            // 0x0058(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInitialBuildingLocked : 1;                        // 0x0058(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_58_4 : 1;                                   // 0x0058(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSkipAgentHeightCheckWhenPickingNavData : 1;       // 0x0058(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ENavDataGatheringModeConfig                   DataGatheringMode;                                 // 0x005C(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bGenerateNavigationOnlyAroundNavigationInvokers : 1; // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActiveTilesUpdateInterval;                         // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FNavDataConfig>                 SupportedAgents;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         DirtyAreasUpdateFreq;                              // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANavigationData*>                NavDataSet;                                        // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ANavigationData*>                NavDataRegistrationQueue;                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnNavDataRegisteredEvent;                          // 0x0100(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNavigationGenerationFinishedDelegate;            // 0x0110(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x124];                                    // 0x0120(0x0124)(Fixing Size After Last Property [ Dumper-7 ])
	EFNavigationSystemRunMode                     OperationMode;                                     // 0x0244(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245[0x23B];                                    // 0x0245(0x023B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UNavigationPath* FindPathToActorSynchronously(class UObject* WorldContextObject, const struct FVector& PathStart, class AActor* GoalActor, float TetherDistance, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static class UNavigationPath* FindPathToLocationSynchronously(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static class UNavigationSystem* GetNavigationSystem(class UObject* WorldContextObject);
	static ENavigationQueryResult GetPathCost(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathCost, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static ENavigationQueryResult GetPathLength(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathLength, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static struct FVector GetRandomPointInNavigableRadius(class UObject* WorldContextObject, const struct FVector& Origin, float Radius, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static struct FVector GetRandomReachablePointInRadius(class UObject* WorldContextObject, const struct FVector& Origin, float Radius, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static bool IsNavigationBeingBuilt(class UObject* WorldContextObject);
	static bool IsNavigationBeingBuiltOrLocked(class UObject* WorldContextObject);
	static bool K2_GetRandomPointInNavigableRadius(class UObject* WorldContextObject, const struct FVector& Origin, struct FVector* RandomLocation, float Radius, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static bool K2_GetRandomReachablePointInRadius(class UObject* WorldContextObject, const struct FVector& Origin, struct FVector* RandomLocation, float Radius, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static bool K2_ProjectPointToNavigation(class UObject* WorldContextObject, const struct FVector& Point, struct FVector* ProjectedLocation, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, const struct FVector& QueryExtent);
	static bool NavigationRaycast(class UObject* WorldContextObject, const struct FVector& RayStart, const struct FVector& RayEnd, struct FVector* HitLocation, TSubclassOf<class UNavigationQueryFilter> FilterClass, class AController* Querier);
	static struct FVector ProjectPointToNavigation(class UObject* WorldContextObject, const struct FVector& Point, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, const struct FVector& QueryExtent);
	static void SimpleMoveToActor(class AController* Controller, const class AActor* Goal);
	static void SimpleMoveToLocation(class AController* Controller, const struct FVector& Goal);

	void OnNavigationBoundsUpdated(class ANavMeshBoundsVolume* NavVolume);
	void RegisterNavigationInvoker(class AActor* Invoker, float TileGenerationRadius, float TileRemovalRadius);
	void ResetMaxSimultaneousTileGenerationJobsCount();
	void SetGeometryGatheringMode(ENavDataGatheringModeConfig NewMode);
	void SetMaxSimultaneousTileGenerationJobsCount(int32 MaxNumberOfJobs);
	void UnregisterNavigationInvoker(class AActor* Invoker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationSystem">();
	}
	static class UNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationSystem>();
	}
};
static_assert(alignof(UNavigationSystem) == 0x000008, "Wrong alignment on UNavigationSystem");
static_assert(sizeof(UNavigationSystem) == 0x000480, "Wrong size on UNavigationSystem");
static_assert(offsetof(UNavigationSystem, MainNavData) == 0x000040, "Member 'UNavigationSystem::MainNavData' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, AbstractNavData) == 0x000048, "Member 'UNavigationSystem::AbstractNavData' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, CrowdManagerClass) == 0x000050, "Member 'UNavigationSystem::CrowdManagerClass' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, DataGatheringMode) == 0x00005C, "Member 'UNavigationSystem::DataGatheringMode' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, ActiveTilesUpdateInterval) == 0x000064, "Member 'UNavigationSystem::ActiveTilesUpdateInterval' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, SupportedAgents) == 0x000068, "Member 'UNavigationSystem::SupportedAgents' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, DirtyAreasUpdateFreq) == 0x000078, "Member 'UNavigationSystem::DirtyAreasUpdateFreq' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, NavDataSet) == 0x000080, "Member 'UNavigationSystem::NavDataSet' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, NavDataRegistrationQueue) == 0x000090, "Member 'UNavigationSystem::NavDataRegistrationQueue' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, OnNavDataRegisteredEvent) == 0x000100, "Member 'UNavigationSystem::OnNavDataRegisteredEvent' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, OnNavigationGenerationFinishedDelegate) == 0x000110, "Member 'UNavigationSystem::OnNavigationGenerationFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UNavigationSystem, OperationMode) == 0x000244, "Member 'UNavigationSystem::OperationMode' has a wrong offset!");

// Class Engine.VisualLoggerAutomationTests
// 0x0000 (0x0040 - 0x0040)
class UVisualLoggerAutomationTests final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualLoggerAutomationTests">();
	}
	static class UVisualLoggerAutomationTests* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualLoggerAutomationTests>();
	}
};
static_assert(alignof(UVisualLoggerAutomationTests) == 0x000008, "Wrong alignment on UVisualLoggerAutomationTests");
static_assert(sizeof(UVisualLoggerAutomationTests) == 0x000040, "Wrong size on UVisualLoggerAutomationTests");

// Class Engine.NavLinkProxy
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ANavLinkProxy : public AActor
{
public:
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavigationLink>                PointLinks;                                        // 0x03F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavigationSegmentLink>         SegmentLinks;                                      // 0x0400(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UNavLinkCustomComponent*                SmartLinkComp;                                     // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSmartLinkIsRelevant;                              // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnSmartLinkReached;                                // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void ReceiveSmartLinkReached(class AActor* Agent, const struct FVector& Destination);
	void ResumePathFollowing(class AActor* Agent);
	void SetSmartLinkEnabled(bool bEnabled);

	bool HasMovingAgents() const;
	bool IsSmartLinkEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy">();
	}
	static class ANavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy>();
	}
};
static_assert(alignof(ANavLinkProxy) == 0x1EF72E00, "Wrong alignment on ANavLinkProxy");
static_assert(sizeof(ANavLinkProxy) == 0x1EF72E00, "Wrong size on ANavLinkProxy");
static_assert(offsetof(ANavLinkProxy, PointLinks) == 0x0003F0, "Member 'ANavLinkProxy::PointLinks' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy, SegmentLinks) == 0x000400, "Member 'ANavLinkProxy::SegmentLinks' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy, SmartLinkComp) == 0x000410, "Member 'ANavLinkProxy::SmartLinkComp' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy, bSmartLinkIsRelevant) == 0x000418, "Member 'ANavLinkProxy::bSmartLinkIsRelevant' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy, OnSmartLinkReached) == 0x000420, "Member 'ANavLinkProxy::OnSmartLinkReached' has a wrong offset!");

// Class Engine.DefaultPhysicsVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADefaultPhysicsVolume final : public APhysicsVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultPhysicsVolume">();
	}
	static class ADefaultPhysicsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefaultPhysicsVolume>();
	}
};
static_assert(alignof(ADefaultPhysicsVolume) == 0x1EF72E00, "Wrong alignment on ADefaultPhysicsVolume");
static_assert(sizeof(ADefaultPhysicsVolume) == 0x1EF72E00, "Wrong size on ADefaultPhysicsVolume");

// Class Engine.SceneCapture
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ASceneCapture : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComp;                                          // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCapture">();
	}
	static class ASceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneCapture>();
	}
};
#pragma pack(pop)
static_assert(alignof(ASceneCapture) == 0x1EF72E00, "Wrong alignment on ASceneCapture");
static_assert(sizeof(ASceneCapture) == 0x1EF72E00, "Wrong size on ASceneCapture");
static_assert(offsetof(ASceneCapture, MeshComp) == 0x0003E0, "Member 'ASceneCapture::MeshComp' has a wrong offset!");

// Class Engine.SceneCapture2D
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ASceneCapture2D : public ASceneCapture
{
public:
	class USceneCaptureComponent2D*               CaptureComponent2D;                                // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDrawFrustumComponent*                  DrawFrustum;                                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInterpToggle(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCapture2D">();
	}
	static class ASceneCapture2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneCapture2D>();
	}
};
#pragma pack(pop)
static_assert(alignof(ASceneCapture2D) == 0x1EF72E00, "Wrong alignment on ASceneCapture2D");
static_assert(sizeof(ASceneCapture2D) == 0x1EF72E00, "Wrong size on ASceneCapture2D");
static_assert(offsetof(ASceneCapture2D, CaptureComponent2D) == 0x0003E8, "Member 'ASceneCapture2D::CaptureComponent2D' has a wrong offset!");
static_assert(offsetof(ASceneCapture2D, DrawFrustum) == 0x0003F0, "Member 'ASceneCapture2D::DrawFrustum' has a wrong offset!");

// Class Engine.Interface_CollisionDataProvider
// 0x0000 (0x0040 - 0x0040)
class IInterface_CollisionDataProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interface_CollisionDataProvider">();
	}
	static class IInterface_CollisionDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterface_CollisionDataProvider>();
	}
};
static_assert(alignof(IInterface_CollisionDataProvider) == 0x000008, "Wrong alignment on IInterface_CollisionDataProvider");
static_assert(sizeof(IInterface_CollisionDataProvider) == 0x000040, "Wrong size on IInterface_CollisionDataProvider");

// Class Engine.PlayerStartPIE
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APlayerStartPIE final : public APlayerStart
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartPIE">();
	}
	static class APlayerStartPIE* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartPIE>();
	}
};
static_assert(alignof(APlayerStartPIE) == 0x1EF72E00, "Wrong alignment on APlayerStartPIE");
static_assert(sizeof(APlayerStartPIE) == 0x1EF72E00, "Wrong size on APlayerStartPIE");

// Class Engine.VisualLoggerKismetLibrary
// 0x0000 (0x0040 - 0x0040)
class UVisualLoggerKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void LogBox(class UObject* WorldContextObject, const struct FBox& BoxShape, const class FString& Text, const struct FLinearColor& ObjectColor, class FName LogCategory);
	static void LogLocation(class UObject* WorldContextObject, const struct FVector& Location, const class FString& Text, const struct FLinearColor& ObjectColor, float Radius, class FName LogCategory);
	static void LogText(class UObject* WorldContextObject, const class FString& Text, class FName LogCategory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualLoggerKismetLibrary">();
	}
	static class UVisualLoggerKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualLoggerKismetLibrary>();
	}
};
static_assert(alignof(UVisualLoggerKismetLibrary) == 0x000008, "Wrong alignment on UVisualLoggerKismetLibrary");
static_assert(sizeof(UVisualLoggerKismetLibrary) == 0x000040, "Wrong size on UVisualLoggerKismetLibrary");

// Class Engine.NavModifierComponent
// 0x0000 (0xD38D - 0xD38D)
#pragma pack(push, 0x1)
class alignas(0xD38D) UNavModifierComponent : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FailsafeExtent;                                    // 0x0238(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReferToCollisionProfile;                          // 0x0244(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x13];                                     // 0x0245(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavModifierComponent">();
	}
	static class UNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavModifierComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNavModifierComponent) == 0x00D38D, "Wrong alignment on UNavModifierComponent");
static_assert(sizeof(UNavModifierComponent) == 0x00D38D, "Wrong size on UNavModifierComponent");
static_assert(offsetof(UNavModifierComponent, AreaClass) == 0x000230, "Member 'UNavModifierComponent::AreaClass' has a wrong offset!");
static_assert(offsetof(UNavModifierComponent, FailsafeExtent) == 0x000238, "Member 'UNavModifierComponent::FailsafeExtent' has a wrong offset!");
static_assert(offsetof(UNavModifierComponent, bReferToCollisionProfile) == 0x000244, "Member 'UNavModifierComponent::bReferToCollisionProfile' has a wrong offset!");

// Class Engine.SkeletalMesh
// 0x112EB650 (0x112EB690 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x112EB690) USkeletalMesh : public UObject
{
public:
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       ImportedBounds;                                    // 0x0068(0x112EB690)(Transient, DuplicateTransient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       ExtendedBounds;                                    // 0x0084(0x112EB690)(Transient, DuplicateTransient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                PositiveBoundsExtension;                           // 0x00A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NegativeBoundsExtension;                           // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSkeletalMaterial>              Materials;                                         // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<struct FBoneMirrorInfo>                SkelMirrorTable;                                   // 0x00C8(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	EAxis                                         SkelMirrorAxis;                                    // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         SkelMirrorFlipAxis;                                // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkeletalMeshLODInfo>           LODInfo;                                           // 0x00E0(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bUseFullPrecisionUVs : 1;                          // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasBeenSimplified : 1;                            // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasVertexColors : 1;                              // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePerPolyCollision : 1;                       // 0x00F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          ShadowPhysicsAsset;                                // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNodeMappingContainer*>          NodeMappingData;                                   // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMorphTarget*>                   MorphTargets;                                      // 0x0120(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x168];                                    // 0x0130(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bParticleUse;                                      // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParticleUseLOD;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLargestPolygonForTextureFactor;                // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FClothingAssetData_Legacy>      ClothingAssets;                                    // 0x02A8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              PostProcessAnimBlueprint;                          // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClothingAssetBase*>             MeshClothingAssets;                                // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x02D8(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshSocket*>            Sockets;                                           // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SQEX_BoundsBaseBoneName;                           // 0x0310(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         SQEX_BoundsBaseBone;                               // 0x0318(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AccurateNormalsWeight;                             // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSqEX_BonePoseToMaterialParam>  M_BonePoseToMaterialParam;                         // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<uint16>                                M_FaceToBoneIndex;                                 // 0x0348(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         SQEX_bOverrideTranslucencySortPriority : 1;        // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_OBJECT_TYPE_TRANSLUCENCYSORTPRIORITY    SQEXInitialTranslucencySortPriorityCategory;       // 0x035C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SQEX_InitialTranslucencySortPriority;              // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEX_bEnableCastShadowLimitLOD : 1;                // 0x0364(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SQEX_CastShadowLimitLOD;                           // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEX_bEnableLimitShadowModel : 1;                  // 0x036C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SQEX_LimitShadowLODModel;                          // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FBoxSphereBounds GetBounds();
	struct FBoxSphereBounds GetImportedBounds();

	class USkeletalMeshSocket* FindSocket(class FName InSocketName) const;
	class USkeletalMeshSocket* FindSocketAndIndex(class FName InSocketName, int32* OutIndex) const;
	class UNodeMappingContainer* GetNodeMappingContainer(class UBlueprint* SourceAsset) const;
	class USkeletalMeshSocket* GetSocketByIndex(int32 Index_0) const;
	bool IsSectionUsingCloth(int32 InSectionIndex, bool bCheckCorrespondingSections) const;
	int32 NumSockets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMesh">();
	}
	static class USkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalMesh>();
	}
};
#pragma pack(pop)
static_assert(alignof(USkeletalMesh) == 0x112EB690, "Wrong alignment on USkeletalMesh");
static_assert(sizeof(USkeletalMesh) == 0x112EB690, "Wrong size on USkeletalMesh");
static_assert(offsetof(USkeletalMesh, Skeleton) == 0x000060, "Member 'USkeletalMesh::Skeleton' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, ImportedBounds) == 0x000068, "Member 'USkeletalMesh::ImportedBounds' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, ExtendedBounds) == 0x000084, "Member 'USkeletalMesh::ExtendedBounds' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, PositiveBoundsExtension) == 0x0000A0, "Member 'USkeletalMesh::PositiveBoundsExtension' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, NegativeBoundsExtension) == 0x0000AC, "Member 'USkeletalMesh::NegativeBoundsExtension' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, Materials) == 0x0000B8, "Member 'USkeletalMesh::Materials' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SkelMirrorTable) == 0x0000C8, "Member 'USkeletalMesh::SkelMirrorTable' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SkelMirrorAxis) == 0x0000D8, "Member 'USkeletalMesh::SkelMirrorAxis' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SkelMirrorFlipAxis) == 0x0000D9, "Member 'USkeletalMesh::SkelMirrorFlipAxis' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, LODInfo) == 0x0000E0, "Member 'USkeletalMesh::LODInfo' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, BodySetup) == 0x0000F8, "Member 'USkeletalMesh::BodySetup' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, PhysicsAsset) == 0x000100, "Member 'USkeletalMesh::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, ShadowPhysicsAsset) == 0x000108, "Member 'USkeletalMesh::ShadowPhysicsAsset' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, NodeMappingData) == 0x000110, "Member 'USkeletalMesh::NodeMappingData' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, MorphTargets) == 0x000120, "Member 'USkeletalMesh::MorphTargets' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, bParticleUse) == 0x000298, "Member 'USkeletalMesh::bParticleUse' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, ParticleUseLOD) == 0x00029C, "Member 'USkeletalMesh::ParticleUseLOD' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, bUseLargestPolygonForTextureFactor) == 0x0002A0, "Member 'USkeletalMesh::bUseLargestPolygonForTextureFactor' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, ClothingAssets) == 0x0002A8, "Member 'USkeletalMesh::ClothingAssets' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, PostProcessAnimBlueprint) == 0x0002B8, "Member 'USkeletalMesh::PostProcessAnimBlueprint' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, MeshClothingAssets) == 0x0002C0, "Member 'USkeletalMesh::MeshClothingAssets' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, AssetUserData) == 0x0002D8, "Member 'USkeletalMesh::AssetUserData' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, Sockets) == 0x0002F0, "Member 'USkeletalMesh::Sockets' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SQEX_BoundsBaseBoneName) == 0x000310, "Member 'USkeletalMesh::SQEX_BoundsBaseBoneName' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SQEX_BoundsBaseBone) == 0x000318, "Member 'USkeletalMesh::SQEX_BoundsBaseBone' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, AccurateNormalsWeight) == 0x000330, "Member 'USkeletalMesh::AccurateNormalsWeight' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, M_BonePoseToMaterialParam) == 0x000338, "Member 'USkeletalMesh::M_BonePoseToMaterialParam' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, M_FaceToBoneIndex) == 0x000348, "Member 'USkeletalMesh::M_FaceToBoneIndex' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SQEXInitialTranslucencySortPriorityCategory) == 0x00035C, "Member 'USkeletalMesh::SQEXInitialTranslucencySortPriorityCategory' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SQEX_InitialTranslucencySortPriority) == 0x000360, "Member 'USkeletalMesh::SQEX_InitialTranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SQEX_CastShadowLimitLOD) == 0x000368, "Member 'USkeletalMesh::SQEX_CastShadowLimitLOD' has a wrong offset!");
static_assert(offsetof(USkeletalMesh, SQEX_LimitShadowLODModel) == 0x000370, "Member 'USkeletalMesh::SQEX_LimitShadowLODModel' has a wrong offset!");

// Class Engine.DestructibleMesh
// 0x0000 (0x112EB690 - 0x112EB690)
class UDestructibleMesh final : public USkeletalMesh
{
public:
	struct FDestructibleParameters                DefaultDestructibleParameters;                     // 0x0378(0x1162B6B0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FFractureEffect>                FractureEffects;                                   // 0x0400(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleMesh">();
	}
	static class UDestructibleMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleMesh>();
	}
};
static_assert(alignof(UDestructibleMesh) == 0x112EB690, "Wrong alignment on UDestructibleMesh");
static_assert(sizeof(UDestructibleMesh) == 0x112EB690, "Wrong size on UDestructibleMesh");
static_assert(offsetof(UDestructibleMesh, DefaultDestructibleParameters) == 0x000378, "Member 'UDestructibleMesh::DefaultDestructibleParameters' has a wrong offset!");
static_assert(offsetof(UDestructibleMesh, FractureEffects) == 0x000400, "Member 'UDestructibleMesh::FractureEffects' has a wrong offset!");

// Class Engine.InterpTrackInstFloatParticleParam
// 0x0008 (0x0048 - 0x0040)
class UInterpTrackInstFloatParticleParam final : public UInterpTrackInst
{
public:
	float                                         ResetFloat;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstFloatParticleParam">();
	}
	static class UInterpTrackInstFloatParticleParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstFloatParticleParam>();
	}
};
static_assert(alignof(UInterpTrackInstFloatParticleParam) == 0x000008, "Wrong alignment on UInterpTrackInstFloatParticleParam");
static_assert(sizeof(UInterpTrackInstFloatParticleParam) == 0x000048, "Wrong size on UInterpTrackInstFloatParticleParam");
static_assert(offsetof(UInterpTrackInstFloatParticleParam, ResetFloat) == 0x000040, "Member 'UInterpTrackInstFloatParticleParam::ResetFloat' has a wrong offset!");

// Class Engine.MaterialExpressionParticleMotionBlurFade
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleMotionBlurFade final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleMotionBlurFade">();
	}
	static class UMaterialExpressionParticleMotionBlurFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleMotionBlurFade>();
	}
};
static_assert(alignof(UMaterialExpressionParticleMotionBlurFade) == 0x000008, "Wrong alignment on UMaterialExpressionParticleMotionBlurFade");
static_assert(sizeof(UMaterialExpressionParticleMotionBlurFade) == 0x000078, "Wrong size on UMaterialExpressionParticleMotionBlurFade");

// Class Engine.PostProcessVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APostProcessVolume : public AVolume
{
public:
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   Settings;                                          // 0x0430(0x112EAE80)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0B70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0B7C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnbound : 1;                                      // 0x0B7C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B7D[0x3];                                      // 0x0B7D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessVolume">();
	}
	static class APostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessVolume>();
	}
};
static_assert(alignof(APostProcessVolume) == 0x1EF72E00, "Wrong alignment on APostProcessVolume");
static_assert(sizeof(APostProcessVolume) == 0x1EF72E00, "Wrong size on APostProcessVolume");
static_assert(offsetof(APostProcessVolume, Settings) == 0x000430, "Member 'APostProcessVolume::Settings' has a wrong offset!");
static_assert(offsetof(APostProcessVolume, Priority) == 0x000B70, "Member 'APostProcessVolume::Priority' has a wrong offset!");
static_assert(offsetof(APostProcessVolume, BlendRadius) == 0x000B74, "Member 'APostProcessVolume::BlendRadius' has a wrong offset!");
static_assert(offsetof(APostProcessVolume, BlendWeight) == 0x000B78, "Member 'APostProcessVolume::BlendWeight' has a wrong offset!");

// Class Engine.MaterialExpressionVertexColor
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionVertexColor final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVertexColor">();
	}
	static class UMaterialExpressionVertexColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVertexColor>();
	}
};
static_assert(alignof(UMaterialExpressionVertexColor) == 0x000008, "Wrong alignment on UMaterialExpressionVertexColor");
static_assert(sizeof(UMaterialExpressionVertexColor) == 0x000078, "Wrong size on UMaterialExpressionVertexColor");

// Class Engine.LightmassPortal
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ALightmassPortal final : public AActor
{
public:
	class ULightmassPortalComponent*              PortalComponent;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightmassPortal">();
	}
	static class ALightmassPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightmassPortal>();
	}
};
static_assert(alignof(ALightmassPortal) == 0x1EF72E00, "Wrong alignment on ALightmassPortal");
static_assert(sizeof(ALightmassPortal) == 0x1EF72E00, "Wrong size on ALightmassPortal");
static_assert(offsetof(ALightmassPortal, PortalComponent) == 0x0003E0, "Member 'ALightmassPortal::PortalComponent' has a wrong offset!");

// Class Engine.SQEX_OceanEnvSwitchActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ASQEX_OceanEnvSwitchActor : public AActor
{
public:
	class USceneComponent*                        MyRoot;                                            // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_OceanEnvSwitchActor">();
	}
	static class ASQEX_OceanEnvSwitchActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASQEX_OceanEnvSwitchActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ASQEX_OceanEnvSwitchActor) == 0x1EF72E00, "Wrong alignment on ASQEX_OceanEnvSwitchActor");
static_assert(sizeof(ASQEX_OceanEnvSwitchActor) == 0x1EF72E00, "Wrong size on ASQEX_OceanEnvSwitchActor");
static_assert(offsetof(ASQEX_OceanEnvSwitchActor, MyRoot) == 0x0003E0, "Member 'ASQEX_OceanEnvSwitchActor::MyRoot' has a wrong offset!");

// Class Engine.CameraActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ACameraActor : public AActor
{
public:
	EAutoReceiveInput                             AutoActivateForPlayer;                             // 0x03E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        SceneComponent;                                    // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_AddViewInformationWhenBeginPlay;                 // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0xB];                                      // 0x03F9(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bConstrainAspectRatio : 1;                         // 0x0404(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AspectRatio;                                       // 0x0408(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FOVAngle;                                          // 0x040C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PostProcessBlendWeight;                            // 0x0410(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_414[0xC];                                      // 0x0414(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0420(0x112EAE80)(Deprecated, NativeAccessSpecifierPrivate)

public:
	int32 GetAutoActivatePlayerIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraActor">();
	}
	static class ACameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACameraActor) == 0x1EF72E00, "Wrong alignment on ACameraActor");
static_assert(sizeof(ACameraActor) == 0x1EF72E00, "Wrong size on ACameraActor");
static_assert(offsetof(ACameraActor, AutoActivateForPlayer) == 0x0003E0, "Member 'ACameraActor::AutoActivateForPlayer' has a wrong offset!");
static_assert(offsetof(ACameraActor, CameraComponent) == 0x0003E8, "Member 'ACameraActor::CameraComponent' has a wrong offset!");
static_assert(offsetof(ACameraActor, SceneComponent) == 0x0003F0, "Member 'ACameraActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ACameraActor, M_AddViewInformationWhenBeginPlay) == 0x0003F8, "Member 'ACameraActor::M_AddViewInformationWhenBeginPlay' has a wrong offset!");
static_assert(offsetof(ACameraActor, AspectRatio) == 0x000408, "Member 'ACameraActor::AspectRatio' has a wrong offset!");
static_assert(offsetof(ACameraActor, FOVAngle) == 0x00040C, "Member 'ACameraActor::FOVAngle' has a wrong offset!");
static_assert(offsetof(ACameraActor, PostProcessBlendWeight) == 0x000410, "Member 'ACameraActor::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(ACameraActor, PostProcessSettings) == 0x000420, "Member 'ACameraActor::PostProcessSettings' has a wrong offset!");

// Class Engine.ParticleModuleAccelerationBase
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleAccelerationBase : public UParticleModule
{
public:
	uint8                                         bAlwaysInWorldSpace : 1;                           // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAccelerationBase">();
	}
	static class UParticleModuleAccelerationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAccelerationBase>();
	}
};
static_assert(alignof(UParticleModuleAccelerationBase) == 0x000008, "Wrong alignment on UParticleModuleAccelerationBase");
static_assert(sizeof(UParticleModuleAccelerationBase) == 0x000058, "Wrong size on UParticleModuleAccelerationBase");

// Class Engine.ParticleModuleAcceleration
// 0x0058 (0x00B0 - 0x0058)
class UParticleModuleAcceleration final : public UParticleModuleAccelerationBase
{
public:
	struct FRawDistributionVector                 Acceleration;                                      // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bApplyOwnerScale : 1;                              // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAcceleration">();
	}
	static class UParticleModuleAcceleration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAcceleration>();
	}
};
static_assert(alignof(UParticleModuleAcceleration) == 0x000008, "Wrong alignment on UParticleModuleAcceleration");
static_assert(sizeof(UParticleModuleAcceleration) == 0x0000B0, "Wrong size on UParticleModuleAcceleration");
static_assert(offsetof(UParticleModuleAcceleration, Acceleration) == 0x000058, "Member 'UParticleModuleAcceleration::Acceleration' has a wrong offset!");

// Class Engine.PlayerState
// 0x68BE10 (0x1F5FEC10 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1F5FEC10) APlayerState : public AInfo
{
public:
	float                                         Score;                                             // 0x03E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Ping;                                              // 0x03E4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x03E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerId;                                          // 0x0408(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsSpectator : 1;                                  // 0x040C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlySpectator : 1;                                // 0x040C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsABot : 1;                                       // 0x040C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_40C_3 : 1;                                  // 0x040C(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsInactive : 1;                                   // 0x040C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFromPreviousLevel : 1;                            // 0x040C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartTime;                                         // 0x0410(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULocalMessage>              EngineMessageClass;                                // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedNetworkAddress;                               // 0x0428(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0438(0x1F5FEC10)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_bIsInactive();
	void OnRep_PlayerName();
	void OnRep_Score();
	void OnRep_UniqueId();
	void ReceiveCopyProperties(class APlayerState* NewPlayerState);
	void ReceiveOverrideWith(class APlayerState* OldPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerState">();
	}
	static class APlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerState>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerState) == 0x1F5FEC10, "Wrong alignment on APlayerState");
static_assert(sizeof(APlayerState) == 0x1F5FEC10, "Wrong size on APlayerState");
static_assert(offsetof(APlayerState, Score) == 0x0003E0, "Member 'APlayerState::Score' has a wrong offset!");
static_assert(offsetof(APlayerState, Ping) == 0x0003E4, "Member 'APlayerState::Ping' has a wrong offset!");
static_assert(offsetof(APlayerState, PlayerName) == 0x0003E8, "Member 'APlayerState::PlayerName' has a wrong offset!");
static_assert(offsetof(APlayerState, PlayerId) == 0x000408, "Member 'APlayerState::PlayerId' has a wrong offset!");
static_assert(offsetof(APlayerState, StartTime) == 0x000410, "Member 'APlayerState::StartTime' has a wrong offset!");
static_assert(offsetof(APlayerState, EngineMessageClass) == 0x000418, "Member 'APlayerState::EngineMessageClass' has a wrong offset!");
static_assert(offsetof(APlayerState, SavedNetworkAddress) == 0x000428, "Member 'APlayerState::SavedNetworkAddress' has a wrong offset!");
static_assert(offsetof(APlayerState, UniqueId) == 0x000438, "Member 'APlayerState::UniqueId' has a wrong offset!");

// Class Engine.ParticleModuleMeshRotationRate
// 0x0050 (0x00A0 - 0x0050)
class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                 StartRotationRate;                                 // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshRotationRate">();
	}
	static class UParticleModuleMeshRotationRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshRotationRate>();
	}
};
static_assert(alignof(UParticleModuleMeshRotationRate) == 0x000008, "Wrong alignment on UParticleModuleMeshRotationRate");
static_assert(sizeof(UParticleModuleMeshRotationRate) == 0x0000A0, "Wrong size on UParticleModuleMeshRotationRate");
static_assert(offsetof(UParticleModuleMeshRotationRate, StartRotationRate) == 0x000050, "Member 'UParticleModuleMeshRotationRate::StartRotationRate' has a wrong offset!");

// Class Engine.ParticleModuleMeshRotationRate_Seeded
// 0x0020 (0x00C0 - 0x00A0)
class UParticleModuleMeshRotationRate_Seeded final : public UParticleModuleMeshRotationRate
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00A0(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshRotationRate_Seeded">();
	}
	static class UParticleModuleMeshRotationRate_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshRotationRate_Seeded>();
	}
};
static_assert(alignof(UParticleModuleMeshRotationRate_Seeded) == 0x000008, "Wrong alignment on UParticleModuleMeshRotationRate_Seeded");
static_assert(sizeof(UParticleModuleMeshRotationRate_Seeded) == 0x0000C0, "Wrong size on UParticleModuleMeshRotationRate_Seeded");
static_assert(offsetof(UParticleModuleMeshRotationRate_Seeded, RandomSeedInfo) == 0x0000A0, "Member 'UParticleModuleMeshRotationRate_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ProjectileMovementComponent
// 0x0000 (0xD38D - 0xD38D)
#pragma pack(push, 0x1)
class alignas(0xD38D) UProjectileMovementComponent : public UMovementComponent
{
public:
	float                                         InitialSpeed;                                      // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRotationFollowsVelocity : 1;                      // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBounce : 1;                                 // 0x0250(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitialVelocityInLocalSpace : 1;                  // 0x0250(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceSubStepping : 1;                             // 0x0250(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsHomingProjectile : 1;                           // 0x0250(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBounceAngleAffectsFriction : 1;                   // 0x0250(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSliding : 1;                                    // 0x0250(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviousHitTime;                                   // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousHitNormal;                                 // 0x0258(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileGravityScale;                            // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buoyancy;                                          // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bounciness;                                        // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityStopSimulatingThreshold;             // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnProjectileBounce;                                // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnProjectileStop;                                  // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HomingAccelerationMagnitude;                       // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         HomingTargetComponent;                             // 0x029C(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEX_bNoReduceVelocityOnDeflect : 1;               // 0x02A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSimulationTimeStep;                             // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnProjectileBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnProjectileStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult);
	void SetVelocityInLocalSpace(const struct FVector& NewVelocity);
	void StopSimulating(const struct FHitResult& HitResult);

	struct FVector LimitVelocity(const struct FVector& NewVelocity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMovementComponent">();
	}
	static class UProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UProjectileMovementComponent) == 0x00D38D, "Wrong alignment on UProjectileMovementComponent");
static_assert(sizeof(UProjectileMovementComponent) == 0x00D38D, "Wrong size on UProjectileMovementComponent");
static_assert(offsetof(UProjectileMovementComponent, InitialSpeed) == 0x000248, "Member 'UProjectileMovementComponent::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, MaxSpeed) == 0x00024C, "Member 'UProjectileMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, PreviousHitTime) == 0x000254, "Member 'UProjectileMovementComponent::PreviousHitTime' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, PreviousHitNormal) == 0x000258, "Member 'UProjectileMovementComponent::PreviousHitNormal' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, ProjectileGravityScale) == 0x000264, "Member 'UProjectileMovementComponent::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, Buoyancy) == 0x000268, "Member 'UProjectileMovementComponent::Buoyancy' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, Bounciness) == 0x00026C, "Member 'UProjectileMovementComponent::Bounciness' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, Friction) == 0x000270, "Member 'UProjectileMovementComponent::Friction' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, BounceVelocityStopSimulatingThreshold) == 0x000274, "Member 'UProjectileMovementComponent::BounceVelocityStopSimulatingThreshold' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, OnProjectileBounce) == 0x000278, "Member 'UProjectileMovementComponent::OnProjectileBounce' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, OnProjectileStop) == 0x000288, "Member 'UProjectileMovementComponent::OnProjectileStop' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, HomingAccelerationMagnitude) == 0x000298, "Member 'UProjectileMovementComponent::HomingAccelerationMagnitude' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, HomingTargetComponent) == 0x00029C, "Member 'UProjectileMovementComponent::HomingTargetComponent' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, MaxSimulationTimeStep) == 0x0002A8, "Member 'UProjectileMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UProjectileMovementComponent, MaxSimulationIterations) == 0x0002AC, "Member 'UProjectileMovementComponent::MaxSimulationIterations' has a wrong offset!");

// Class Engine.CapsuleComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UCapsuleComponent : public UShapeComponent
{
public:
	float                                         CapsuleHalfHeight;                                 // 0x0888(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleRadius;                                     // 0x088C(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleHeight;                                     // 0x0890(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_894[0xC];                                      // 0x0894(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps);
	void SetCapsuleRadius(float Radius, bool bUpdateOverlaps);
	void SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps);

	float GetScaledCapsuleHalfHeight() const;
	float GetScaledCapsuleHalfHeight_WithoutHemisphere() const;
	float GetScaledCapsuleRadius() const;
	void GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight) const;
	void GetScaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) const;
	float GetShapeScale() const;
	float GetUnscaledCapsuleHalfHeight() const;
	float GetUnscaledCapsuleHalfHeight_WithoutHemisphere() const;
	float GetUnscaledCapsuleRadius() const;
	void GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight) const;
	void GetUnscaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsuleComponent">();
	}
	static class UCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsuleComponent>();
	}
};
static_assert(alignof(UCapsuleComponent) == 0x112E9AF0, "Wrong alignment on UCapsuleComponent");
static_assert(sizeof(UCapsuleComponent) == 0x112E9AF0, "Wrong size on UCapsuleComponent");
static_assert(offsetof(UCapsuleComponent, CapsuleHalfHeight) == 0x000888, "Member 'UCapsuleComponent::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UCapsuleComponent, CapsuleRadius) == 0x00088C, "Member 'UCapsuleComponent::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(UCapsuleComponent, CapsuleHeight) == 0x000890, "Member 'UCapsuleComponent::CapsuleHeight' has a wrong offset!");

// Class Engine.SQEXMatineeActorAsset
// 0x0000 (0x0048 - 0x0048)
class USQEXMatineeActorAsset : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEXMatineeActorAsset">();
	}
	static class USQEXMatineeActorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEXMatineeActorAsset>();
	}
};
static_assert(alignof(USQEXMatineeActorAsset) == 0x000008, "Wrong alignment on USQEXMatineeActorAsset");
static_assert(sizeof(USQEXMatineeActorAsset) == 0x000048, "Wrong size on USQEXMatineeActorAsset");

// Class Engine.AsyncActionLoadPrimaryAssetClassList
// 0x0010 (0x0098 - 0x0088)
class UAsyncActionLoadPrimaryAssetClassList final : public UAsyncActionLoadPrimaryAssetBase
{
public:
	UMulticastDelegateProperty_                   Completed;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncActionLoadPrimaryAssetClassList* AsyncLoadPrimaryAssetClassList(const TArray<struct FPrimaryAssetId>& PrimaryAssetList, const TArray<class FName>& LoadBundles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionLoadPrimaryAssetClassList">();
	}
	static class UAsyncActionLoadPrimaryAssetClassList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionLoadPrimaryAssetClassList>();
	}
};
static_assert(alignof(UAsyncActionLoadPrimaryAssetClassList) == 0x000008, "Wrong alignment on UAsyncActionLoadPrimaryAssetClassList");
static_assert(sizeof(UAsyncActionLoadPrimaryAssetClassList) == 0x000098, "Wrong size on UAsyncActionLoadPrimaryAssetClassList");
static_assert(offsetof(UAsyncActionLoadPrimaryAssetClassList, Completed) == 0x000088, "Member 'UAsyncActionLoadPrimaryAssetClassList::Completed' has a wrong offset!");

// Class Engine.TriggerVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) ATriggerVolume : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerVolume">();
	}
	static class ATriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerVolume>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATriggerVolume) == 0x1EF72E00, "Wrong alignment on ATriggerVolume");
static_assert(sizeof(ATriggerVolume) == 0x1EF72E00, "Wrong size on ATriggerVolume");

// Class Engine.MaterialExpressionMaterialFunctionCall
// 0x0028 (0x00A0 - 0x0078)
class UMaterialExpressionMaterialFunctionCall final : public UMaterialExpression
{
public:
	class UMaterialFunction*                      MaterialFunction;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFunctionExpressionInput>       FunctionInputs;                                    // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFunctionExpressionOutput>      FunctionOutputs;                                   // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialFunctionCall">();
	}
	static class UMaterialExpressionMaterialFunctionCall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialFunctionCall>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialFunctionCall) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialFunctionCall");
static_assert(sizeof(UMaterialExpressionMaterialFunctionCall) == 0x0000A0, "Wrong size on UMaterialExpressionMaterialFunctionCall");
static_assert(offsetof(UMaterialExpressionMaterialFunctionCall, MaterialFunction) == 0x000078, "Member 'UMaterialExpressionMaterialFunctionCall::MaterialFunction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialFunctionCall, FunctionInputs) == 0x000080, "Member 'UMaterialExpressionMaterialFunctionCall::FunctionInputs' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialFunctionCall, FunctionOutputs) == 0x000090, "Member 'UMaterialExpressionMaterialFunctionCall::FunctionOutputs' has a wrong offset!");

// Class Engine.ParticleModuleVectorFieldScaleOverLife
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleVectorFieldScaleOverLife final : public UParticleModuleVectorFieldBase
{
public:
	class UDistributionFloat*                     VectorFieldScaleOverLife;                          // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  VectorFieldScaleOverLifeRaw;                       // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldScaleOverLife">();
	}
	static class UParticleModuleVectorFieldScaleOverLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldScaleOverLife>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldScaleOverLife) == 0x000008, "Wrong alignment on UParticleModuleVectorFieldScaleOverLife");
static_assert(sizeof(UParticleModuleVectorFieldScaleOverLife) == 0x000090, "Wrong size on UParticleModuleVectorFieldScaleOverLife");
static_assert(offsetof(UParticleModuleVectorFieldScaleOverLife, VectorFieldScaleOverLife) == 0x000050, "Member 'UParticleModuleVectorFieldScaleOverLife::VectorFieldScaleOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldScaleOverLife, VectorFieldScaleOverLifeRaw) == 0x000058, "Member 'UParticleModuleVectorFieldScaleOverLife::VectorFieldScaleOverLifeRaw' has a wrong offset!");

// Class Engine.Player
// 0x0020 (0x0060 - 0x0040)
class UPlayer : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentNetSpeed;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfiguredInternetSpeed;                           // 0x0054(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfiguredLanSpeed;                                // 0x0058(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Player">();
	}
	static class UPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayer>();
	}
};
static_assert(alignof(UPlayer) == 0x000008, "Wrong alignment on UPlayer");
static_assert(sizeof(UPlayer) == 0x000060, "Wrong size on UPlayer");
static_assert(offsetof(UPlayer, PlayerController) == 0x000048, "Member 'UPlayer::PlayerController' has a wrong offset!");
static_assert(offsetof(UPlayer, CurrentNetSpeed) == 0x000050, "Member 'UPlayer::CurrentNetSpeed' has a wrong offset!");
static_assert(offsetof(UPlayer, ConfiguredInternetSpeed) == 0x000054, "Member 'UPlayer::ConfiguredInternetSpeed' has a wrong offset!");
static_assert(offsetof(UPlayer, ConfiguredLanSpeed) == 0x000058, "Member 'UPlayer::ConfiguredLanSpeed' has a wrong offset!");

// Class Engine.NetConnection
// 0x1F5FEBB0 (0x1F5FEC10 - 0x0060)
#pragma pack(push, 0x1)
class alignas(0x1F5FEC10) UNetConnection : public UPlayer
{
public:
	TArray<class UChildConnection*>               Children;                                          // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UNetDriver*                             Driver;                                            // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPackageMap*                            PackageMap;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UChannel*>                       OpenChannels;                                      // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SentTemporaries;                                   // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 ViewTarget;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPacket;                                         // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InternalAck : 1;                                   // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0xB3];                                      // 0x00B5(0x00B3)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0168(0x1F5FEC10)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        LastReceiveTime;                                   // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x33448];                                  // 0x01F0(0x33448)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UChannel*>                       ChannelsToTick;                                    // 0x33638(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33648[0x28];                                   // 0x33648(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetConnection">();
	}
	static class UNetConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetConnection>();
	}
};
#pragma pack(pop)
static_assert(alignof(UNetConnection) == 0x1F5FEC10, "Wrong alignment on UNetConnection");
static_assert(sizeof(UNetConnection) == 0x1F5FEC10, "Wrong size on UNetConnection");
static_assert(offsetof(UNetConnection, Children) == 0x000060, "Member 'UNetConnection::Children' has a wrong offset!");
static_assert(offsetof(UNetConnection, Driver) == 0x000070, "Member 'UNetConnection::Driver' has a wrong offset!");
static_assert(offsetof(UNetConnection, PackageMap) == 0x000078, "Member 'UNetConnection::PackageMap' has a wrong offset!");
static_assert(offsetof(UNetConnection, OpenChannels) == 0x000080, "Member 'UNetConnection::OpenChannels' has a wrong offset!");
static_assert(offsetof(UNetConnection, SentTemporaries) == 0x000090, "Member 'UNetConnection::SentTemporaries' has a wrong offset!");
static_assert(offsetof(UNetConnection, ViewTarget) == 0x0000A0, "Member 'UNetConnection::ViewTarget' has a wrong offset!");
static_assert(offsetof(UNetConnection, OwningActor) == 0x0000A8, "Member 'UNetConnection::OwningActor' has a wrong offset!");
static_assert(offsetof(UNetConnection, MaxPacket) == 0x0000B0, "Member 'UNetConnection::MaxPacket' has a wrong offset!");
static_assert(offsetof(UNetConnection, PlayerId) == 0x000168, "Member 'UNetConnection::PlayerId' has a wrong offset!");
static_assert(offsetof(UNetConnection, LastReceiveTime) == 0x0001E8, "Member 'UNetConnection::LastReceiveTime' has a wrong offset!");
static_assert(offsetof(UNetConnection, ChannelsToTick) == 0x033638, "Member 'UNetConnection::ChannelsToTick' has a wrong offset!");

// Class Engine.DemoNetConnection
// 0x0000 (0x1F5FEC10 - 0x1F5FEC10)
class UDemoNetConnection final : public UNetConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemoNetConnection">();
	}
	static class UDemoNetConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemoNetConnection>();
	}
};
static_assert(alignof(UDemoNetConnection) == 0x1F5FEC10, "Wrong alignment on UDemoNetConnection");
static_assert(sizeof(UDemoNetConnection) == 0x1F5FEC10, "Wrong size on UDemoNetConnection");

// Class Engine.KismetRenderingLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetRenderingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas** Canvas, struct FVector2D* Size, struct FDrawToRenderTargetContext* Context);
	static void BreakSkinWeightInfo(const struct FSkelMeshSkinWeightInfo& InWeight, int32* Bone0, uint8* Weight0, int32* Bone1, uint8* Weight1, int32* Bone2, uint8* Weight2, int32* Bone3, uint8* Weight3);
	static void ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FLinearColor& ClearColor);
	static void ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget, class UTexture2D* Texture);
	static class UTextureRenderTarget2D* CreateRenderTarget2D(class UObject* WorldContextObject, int32 Width, int32 Height);
	static void DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material);
	static void EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const struct FDrawToRenderTargetContext& Context);
	static void ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const class FString& FilePath, const class FString& FileName);
	static void ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, const class FString& FilePath, const class FString& FileName);
	static struct FSkelMeshSkinWeightInfo MakeSkinWeightInfo(int32 Bone0, uint8 Weight0, int32 Bone1, uint8 Weight1, int32 Bone2, uint8 Weight2, int32 Bone3, uint8 Weight3);
	static void ReleaseRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget);
	static class UTextureRenderTarget2D* SqexCreateRenderTargetDepth(class UObject* WorldContextObject, int32 Width, int32 Height);
	static struct FIntPoint SqexGetEffectiveRenderSize(const struct FIntPoint& InPoint);
	static void SqexRenderTargetInitAutoFormat(class UTextureRenderTarget2D* TextureRenderTarget, int32 Width, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetRenderingLibrary">();
	}
	static class UKismetRenderingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetRenderingLibrary>();
	}
};
static_assert(alignof(UKismetRenderingLibrary) == 0x000008, "Wrong alignment on UKismetRenderingLibrary");
static_assert(sizeof(UKismetRenderingLibrary) == 0x000040, "Wrong size on UKismetRenderingLibrary");

// Class Engine.MaterialExpressionPerInstanceFadeAmount
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPerInstanceFadeAmount final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPerInstanceFadeAmount">();
	}
	static class UMaterialExpressionPerInstanceFadeAmount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPerInstanceFadeAmount>();
	}
};
static_assert(alignof(UMaterialExpressionPerInstanceFadeAmount) == 0x000008, "Wrong alignment on UMaterialExpressionPerInstanceFadeAmount");
static_assert(sizeof(UMaterialExpressionPerInstanceFadeAmount) == 0x000078, "Wrong size on UMaterialExpressionPerInstanceFadeAmount");

// Class Engine.Texture
// 0x112E8CE0 (0x112E8D20 - 0x0040)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UTexture : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LightingGuid;                                      // 0x0048(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LODBias;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCinematicMipLevels;                             // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SRGB : 1;                                          // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         NeverStream : 1;                                   // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexOverwriteMaxAllowedMip : 1;                   // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoTiling : 1;                                     // 0x0060(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCinematicMipLevels : 1;                        // 0x0060(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0068(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	int32                                         CachedCombinedLODBias;                             // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAsyncResourceReleaseHasBeenStarted : 1;           // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETextureCompressionSettings                   CompressionSettings;                               // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureFilter                                Filter;                                            // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureGroup                                 LODGroup;                                          // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x1];                                       // 0x0083(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SqexMinLODSize;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SqexTextureQualityLODBias;                         // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x5C];                                      // 0x008C(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_TexColorData>             ColorList;                                         // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Texture">();
	}
	static class UTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTexture>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTexture) == 0x112E8D20, "Wrong alignment on UTexture");
static_assert(sizeof(UTexture) == 0x112E8D20, "Wrong size on UTexture");
static_assert(offsetof(UTexture, LightingGuid) == 0x000048, "Member 'UTexture::LightingGuid' has a wrong offset!");
static_assert(offsetof(UTexture, LODBias) == 0x000058, "Member 'UTexture::LODBias' has a wrong offset!");
static_assert(offsetof(UTexture, NumCinematicMipLevels) == 0x00005C, "Member 'UTexture::NumCinematicMipLevels' has a wrong offset!");
static_assert(offsetof(UTexture, AssetUserData) == 0x000068, "Member 'UTexture::AssetUserData' has a wrong offset!");
static_assert(offsetof(UTexture, CachedCombinedLODBias) == 0x000078, "Member 'UTexture::CachedCombinedLODBias' has a wrong offset!");
static_assert(offsetof(UTexture, CompressionSettings) == 0x000080, "Member 'UTexture::CompressionSettings' has a wrong offset!");
static_assert(offsetof(UTexture, Filter) == 0x000081, "Member 'UTexture::Filter' has a wrong offset!");
static_assert(offsetof(UTexture, LODGroup) == 0x000082, "Member 'UTexture::LODGroup' has a wrong offset!");
static_assert(offsetof(UTexture, SqexMinLODSize) == 0x000084, "Member 'UTexture::SqexMinLODSize' has a wrong offset!");
static_assert(offsetof(UTexture, SqexTextureQualityLODBias) == 0x000088, "Member 'UTexture::SqexTextureQualityLODBias' has a wrong offset!");
static_assert(offsetof(UTexture, ColorList) == 0x0000E8, "Member 'UTexture::ColorList' has a wrong offset!");

// Class Engine.PhysicsSpringComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UPhysicsSpringComponent final : public USceneComponent
{
public:
	float                                         SpringStiffness;                                   // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDamping;                                     // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringLengthAtRest;                                // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringRadius;                                      // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             SpringChannel;                                     // 0x0428(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x2];                                      // 0x042A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringCompression;                                 // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetNormalizedCompressionScalar() const;
	struct FVector GetSpringCurrentEndPoint() const;
	struct FVector GetSpringDirection() const;
	struct FVector GetSpringRestingPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsSpringComponent">();
	}
	static class UPhysicsSpringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsSpringComponent>();
	}
};
static_assert(alignof(UPhysicsSpringComponent) == 0x112E9AF0, "Wrong alignment on UPhysicsSpringComponent");
static_assert(sizeof(UPhysicsSpringComponent) == 0x112E9AF0, "Wrong size on UPhysicsSpringComponent");
static_assert(offsetof(UPhysicsSpringComponent, SpringStiffness) == 0x000418, "Member 'UPhysicsSpringComponent::SpringStiffness' has a wrong offset!");
static_assert(offsetof(UPhysicsSpringComponent, SpringDamping) == 0x00041C, "Member 'UPhysicsSpringComponent::SpringDamping' has a wrong offset!");
static_assert(offsetof(UPhysicsSpringComponent, SpringLengthAtRest) == 0x000420, "Member 'UPhysicsSpringComponent::SpringLengthAtRest' has a wrong offset!");
static_assert(offsetof(UPhysicsSpringComponent, SpringRadius) == 0x000424, "Member 'UPhysicsSpringComponent::SpringRadius' has a wrong offset!");
static_assert(offsetof(UPhysicsSpringComponent, SpringChannel) == 0x000428, "Member 'UPhysicsSpringComponent::SpringChannel' has a wrong offset!");
static_assert(offsetof(UPhysicsSpringComponent, bIgnoreSelf) == 0x000429, "Member 'UPhysicsSpringComponent::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(UPhysicsSpringComponent, SpringCompression) == 0x00042C, "Member 'UPhysicsSpringComponent::SpringCompression' has a wrong offset!");

// Class Engine.SQEX_VideoTexture
// 0x0000 (0x112E8D20 - 0x112E8D20)
class USQEX_VideoTexture : public UTexture
{
public:
	TArray<class USQEX_VideoComponentTexture*>    ComponentTextures;                                 // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x48];                                     // 0x0108(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VideoTexture">();
	}
	static class USQEX_VideoTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_VideoTexture>();
	}
};
static_assert(alignof(USQEX_VideoTexture) == 0x112E8D20, "Wrong alignment on USQEX_VideoTexture");
static_assert(sizeof(USQEX_VideoTexture) == 0x112E8D20, "Wrong size on USQEX_VideoTexture");
static_assert(offsetof(USQEX_VideoTexture, ComponentTextures) == 0x0000F8, "Member 'USQEX_VideoTexture::ComponentTextures' has a wrong offset!");

// Class Engine.MaterialExpressionMakeMaterialAttributes
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionMakeMaterialAttributes final : public UMaterialExpression
{
public:
	struct FExpressionInput                       BaseColor;                                         // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Metallic;                                          // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Specular;                                          // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Roughness;                                         // 0x0120(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       EmissiveColor;                                     // 0x0158(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Opacity;                                           // 0x0190(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       OpacityMask;                                       // 0x01C8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Normal;                                            // 0x0200(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       WorldPositionOffset;                               // 0x0238(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       WorldDisplacement;                                 // 0x0270(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       TessellationMultiplier;                            // 0x02A8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       SubsurfaceColor;                                   // 0x02E0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       ClearCoat;                                         // 0x0318(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       ClearCoatRoughness;                                // 0x0350(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       AmbientOcclusion;                                  // 0x0388(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Refraction;                                        // 0x03C0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       SQEXDarkColor;                                     // 0x03F8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       SqexLightAttenuation;                              // 0x0430(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       CustomizedUVs[0x8];                                // 0x0468(0x112F2730)(NativeAccessSpecifierPublic)
	uint8                                         Pad_-7686C218[0x7686C840];                         // 0x-7686C218(0x7686C840)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       PixelDepthOffset;                                  // 0x0628(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMakeMaterialAttributes">();
	}
	static class UMaterialExpressionMakeMaterialAttributes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMakeMaterialAttributes>();
	}
};
static_assert(alignof(UMaterialExpressionMakeMaterialAttributes) == 0x112F2730, "Wrong alignment on UMaterialExpressionMakeMaterialAttributes");
static_assert(sizeof(UMaterialExpressionMakeMaterialAttributes) == 0x112F2730, "Wrong size on UMaterialExpressionMakeMaterialAttributes");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, BaseColor) == 0x000078, "Member 'UMaterialExpressionMakeMaterialAttributes::BaseColor' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, Metallic) == 0x0000B0, "Member 'UMaterialExpressionMakeMaterialAttributes::Metallic' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, Specular) == 0x0000E8, "Member 'UMaterialExpressionMakeMaterialAttributes::Specular' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, Roughness) == 0x000120, "Member 'UMaterialExpressionMakeMaterialAttributes::Roughness' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, EmissiveColor) == 0x000158, "Member 'UMaterialExpressionMakeMaterialAttributes::EmissiveColor' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, Opacity) == 0x000190, "Member 'UMaterialExpressionMakeMaterialAttributes::Opacity' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, OpacityMask) == 0x0001C8, "Member 'UMaterialExpressionMakeMaterialAttributes::OpacityMask' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, Normal) == 0x000200, "Member 'UMaterialExpressionMakeMaterialAttributes::Normal' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, WorldPositionOffset) == 0x000238, "Member 'UMaterialExpressionMakeMaterialAttributes::WorldPositionOffset' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, WorldDisplacement) == 0x000270, "Member 'UMaterialExpressionMakeMaterialAttributes::WorldDisplacement' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, TessellationMultiplier) == 0x0002A8, "Member 'UMaterialExpressionMakeMaterialAttributes::TessellationMultiplier' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, SubsurfaceColor) == 0x0002E0, "Member 'UMaterialExpressionMakeMaterialAttributes::SubsurfaceColor' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, ClearCoat) == 0x000318, "Member 'UMaterialExpressionMakeMaterialAttributes::ClearCoat' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, ClearCoatRoughness) == 0x000350, "Member 'UMaterialExpressionMakeMaterialAttributes::ClearCoatRoughness' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, AmbientOcclusion) == 0x000388, "Member 'UMaterialExpressionMakeMaterialAttributes::AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, Refraction) == 0x0003C0, "Member 'UMaterialExpressionMakeMaterialAttributes::Refraction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, SQEXDarkColor) == 0x0003F8, "Member 'UMaterialExpressionMakeMaterialAttributes::SQEXDarkColor' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, SqexLightAttenuation) == 0x000430, "Member 'UMaterialExpressionMakeMaterialAttributes::SqexLightAttenuation' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, CustomizedUVs) == 0x000468, "Member 'UMaterialExpressionMakeMaterialAttributes::CustomizedUVs' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMakeMaterialAttributes, PixelDepthOffset) == 0x000628, "Member 'UMaterialExpressionMakeMaterialAttributes::PixelDepthOffset' has a wrong offset!");

// Class Engine.WorldSettings
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AWorldSettings : public AInfo
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableWorldBoundsChecks : 1;                      // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableNavigationSystem : 1;                       // 0x03E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableAISystem : 1;                               // 0x03E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableWorldComposition : 1;                       // 0x03E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClientSideLevelStreamingVolumes : 1;           // 0x03E8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableWorldOriginRebasing : 1;                    // 0x03E8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWorldGravitySet : 1;                              // 0x03E8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGlobalGravitySet : 1;                             // 0x03E8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillZ;                                             // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                KillZDamageType;                                   // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldGravityZ;                                     // 0x03F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalGravityZ;                                    // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADefaultPhysicsVolume>      DefaultPhysicsVolumeClass;                         // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPhysicsCollisionHandler>   PhysicsCollisionHandlerClass;                      // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADefaultPhysicsVolume>      SQEX_DefaultOceanPhysicsVolumeClass;               // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      SQEX_OceanPhysMaterial;                            // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_WorldDeepDiveSetting                    SQEX_DeepDiveSetting;                              // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameModeBase>              DefaultGameMode;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGameNetworkManager>        GameNetworkManagerClass;                           // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PackedLightAndShadowMapTextureSize;                // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMinimizeBSPSections : 1;                          // 0x043C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultColorScale;                                 // 0x0440(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxDistanceFieldOcclusionDistance;          // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalDistanceFieldViewDistance;                   // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicIndirectShadowsSelfShadowingIntensity;      // 0x0454(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SqexDisableReflectionEnvironmentLightmapMixing;    // 0x0458(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SqexDistanceFadeMaxTravel;                         // 0x045C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqexLODFadeTime;                                   // 0x0460(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPrecomputeVisibility : 1;                         // 0x0464(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlaceCellsOnlyAlongCameraTracks : 1;              // 0x0464(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqexPlaceFullSpaceCells : 1;                      // 0x0464(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VisibilityCellSize;                                // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSqexPlayAreaHeight;                               // 0x046C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SqexPlayAreaHeight;                                // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibilityAggressiveness                     VisibilityAggressiveness;                          // 0x0474(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceNoPrecomputedLighting : 1;                   // 0x0478(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_479[0x3];                                      // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightmassWorldInfoSettings            LightmassSettings;                                 // 0x047C(0x0110)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReverbSettings                        DefaultReverbSettings;                             // 0x0590(0x11606540)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FInteriorSettings                      DefaultAmbientZoneSettings;                        // 0x05A8(0x11605F70)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	class USoundMix*                              DefaultBaseSoundMix;                               // 0x05D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldToMeters;                                     // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonoCullingDistance;                               // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBookMark*                              BookMarks[0xA];                                    // 0x05E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDilation;                                      // 0x0630(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqEX_CustomTimeDilation;                           // 0x0634(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatineeTimeDilation;                               // 0x0638(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DemoPlayTimeDilation;                              // 0x063C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGlobalTimeDilation;                             // 0x0640(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGlobalTimeDilation;                             // 0x0644(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinUndilatedFrameTime;                             // 0x0648(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUndilatedFrameTime;                             // 0x064C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           Pauser;                                            // 0x0650(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHighPriorityLoading : 1;                          // 0x0658(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHighPriorityLoadingLocal : 1;                     // 0x0658(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNetViewer>                     ReplicationViewers;                                // 0x0660(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0670(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_WorldGravityZ();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSettings">();
	}
	static class AWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldSettings>();
	}
};
#pragma pack(pop)
static_assert(alignof(AWorldSettings) == 0x1EF72E00, "Wrong alignment on AWorldSettings");
static_assert(sizeof(AWorldSettings) == 0x1EF72E00, "Wrong size on AWorldSettings");
static_assert(offsetof(AWorldSettings, KillZ) == 0x0003EC, "Member 'AWorldSettings::KillZ' has a wrong offset!");
static_assert(offsetof(AWorldSettings, KillZDamageType) == 0x0003F0, "Member 'AWorldSettings::KillZDamageType' has a wrong offset!");
static_assert(offsetof(AWorldSettings, WorldGravityZ) == 0x0003F8, "Member 'AWorldSettings::WorldGravityZ' has a wrong offset!");
static_assert(offsetof(AWorldSettings, GlobalGravityZ) == 0x0003FC, "Member 'AWorldSettings::GlobalGravityZ' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultPhysicsVolumeClass) == 0x000400, "Member 'AWorldSettings::DefaultPhysicsVolumeClass' has a wrong offset!");
static_assert(offsetof(AWorldSettings, PhysicsCollisionHandlerClass) == 0x000408, "Member 'AWorldSettings::PhysicsCollisionHandlerClass' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SQEX_DefaultOceanPhysicsVolumeClass) == 0x000410, "Member 'AWorldSettings::SQEX_DefaultOceanPhysicsVolumeClass' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SQEX_OceanPhysMaterial) == 0x000418, "Member 'AWorldSettings::SQEX_OceanPhysMaterial' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SQEX_DeepDiveSetting) == 0x000420, "Member 'AWorldSettings::SQEX_DeepDiveSetting' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultGameMode) == 0x000428, "Member 'AWorldSettings::DefaultGameMode' has a wrong offset!");
static_assert(offsetof(AWorldSettings, GameNetworkManagerClass) == 0x000430, "Member 'AWorldSettings::GameNetworkManagerClass' has a wrong offset!");
static_assert(offsetof(AWorldSettings, PackedLightAndShadowMapTextureSize) == 0x000438, "Member 'AWorldSettings::PackedLightAndShadowMapTextureSize' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultColorScale) == 0x000440, "Member 'AWorldSettings::DefaultColorScale' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultMaxDistanceFieldOcclusionDistance) == 0x00044C, "Member 'AWorldSettings::DefaultMaxDistanceFieldOcclusionDistance' has a wrong offset!");
static_assert(offsetof(AWorldSettings, GlobalDistanceFieldViewDistance) == 0x000450, "Member 'AWorldSettings::GlobalDistanceFieldViewDistance' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DynamicIndirectShadowsSelfShadowingIntensity) == 0x000454, "Member 'AWorldSettings::DynamicIndirectShadowsSelfShadowingIntensity' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SqexDisableReflectionEnvironmentLightmapMixing) == 0x000458, "Member 'AWorldSettings::SqexDisableReflectionEnvironmentLightmapMixing' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SqexDistanceFadeMaxTravel) == 0x00045C, "Member 'AWorldSettings::SqexDistanceFadeMaxTravel' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SqexLODFadeTime) == 0x000460, "Member 'AWorldSettings::SqexLODFadeTime' has a wrong offset!");
static_assert(offsetof(AWorldSettings, VisibilityCellSize) == 0x000468, "Member 'AWorldSettings::VisibilityCellSize' has a wrong offset!");
static_assert(offsetof(AWorldSettings, bSqexPlayAreaHeight) == 0x00046C, "Member 'AWorldSettings::bSqexPlayAreaHeight' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SqexPlayAreaHeight) == 0x000470, "Member 'AWorldSettings::SqexPlayAreaHeight' has a wrong offset!");
static_assert(offsetof(AWorldSettings, VisibilityAggressiveness) == 0x000474, "Member 'AWorldSettings::VisibilityAggressiveness' has a wrong offset!");
static_assert(offsetof(AWorldSettings, LightmassSettings) == 0x00047C, "Member 'AWorldSettings::LightmassSettings' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultReverbSettings) == 0x000590, "Member 'AWorldSettings::DefaultReverbSettings' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultAmbientZoneSettings) == 0x0005A8, "Member 'AWorldSettings::DefaultAmbientZoneSettings' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DefaultBaseSoundMix) == 0x0005D0, "Member 'AWorldSettings::DefaultBaseSoundMix' has a wrong offset!");
static_assert(offsetof(AWorldSettings, WorldToMeters) == 0x0005D8, "Member 'AWorldSettings::WorldToMeters' has a wrong offset!");
static_assert(offsetof(AWorldSettings, MonoCullingDistance) == 0x0005DC, "Member 'AWorldSettings::MonoCullingDistance' has a wrong offset!");
static_assert(offsetof(AWorldSettings, BookMarks) == 0x0005E0, "Member 'AWorldSettings::BookMarks' has a wrong offset!");
static_assert(offsetof(AWorldSettings, TimeDilation) == 0x000630, "Member 'AWorldSettings::TimeDilation' has a wrong offset!");
static_assert(offsetof(AWorldSettings, SqEX_CustomTimeDilation) == 0x000634, "Member 'AWorldSettings::SqEX_CustomTimeDilation' has a wrong offset!");
static_assert(offsetof(AWorldSettings, MatineeTimeDilation) == 0x000638, "Member 'AWorldSettings::MatineeTimeDilation' has a wrong offset!");
static_assert(offsetof(AWorldSettings, DemoPlayTimeDilation) == 0x00063C, "Member 'AWorldSettings::DemoPlayTimeDilation' has a wrong offset!");
static_assert(offsetof(AWorldSettings, MinGlobalTimeDilation) == 0x000640, "Member 'AWorldSettings::MinGlobalTimeDilation' has a wrong offset!");
static_assert(offsetof(AWorldSettings, MaxGlobalTimeDilation) == 0x000644, "Member 'AWorldSettings::MaxGlobalTimeDilation' has a wrong offset!");
static_assert(offsetof(AWorldSettings, MinUndilatedFrameTime) == 0x000648, "Member 'AWorldSettings::MinUndilatedFrameTime' has a wrong offset!");
static_assert(offsetof(AWorldSettings, MaxUndilatedFrameTime) == 0x00064C, "Member 'AWorldSettings::MaxUndilatedFrameTime' has a wrong offset!");
static_assert(offsetof(AWorldSettings, Pauser) == 0x000650, "Member 'AWorldSettings::Pauser' has a wrong offset!");
static_assert(offsetof(AWorldSettings, ReplicationViewers) == 0x000660, "Member 'AWorldSettings::ReplicationViewers' has a wrong offset!");
static_assert(offsetof(AWorldSettings, AssetUserData) == 0x000670, "Member 'AWorldSettings::AssetUserData' has a wrong offset!");

// Class Engine.NetDriver
// 0x03E8 (0x0428 - 0x0040)
class UNetDriver : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NetConnectionClassName;                            // 0x0048(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDownloadSize;                                   // 0x0058(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bClampListenServerTickRate : 1;                    // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NetServerMaxTickRate;                              // 0x0060(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxInternetClientRate;                             // 0x0064(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxClientRate;                                     // 0x0068(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTravelPause;                                 // 0x006C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPrioritySeconds;                              // 0x0070(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelevantTimeout;                                   // 0x0074(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepAliveTime;                                     // 0x0078(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialConnectTimeout;                             // 0x007C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConnectionTimeout;                                 // 0x0080(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeoutMultiplierForUnoptimizedBuilds;             // 0x0084(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoTimeouts;                                       // 0x0088(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetConnection*                         ServerConnection;                                  // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNetConnection*>                 ClientConnections;                                 // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 NetConnectionClass;                                // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProperty*                              RoleProperty;                                      // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProperty*                              RemoteRoleProperty;                                // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NetDriverName;                                     // 0x0100(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x314];                                    // 0x0114(0x0314)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetDriver">();
	}
	static class UNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetDriver>();
	}
};
static_assert(alignof(UNetDriver) == 0x000008, "Wrong alignment on UNetDriver");
static_assert(sizeof(UNetDriver) == 0x000428, "Wrong size on UNetDriver");
static_assert(offsetof(UNetDriver, NetConnectionClassName) == 0x000048, "Member 'UNetDriver::NetConnectionClassName' has a wrong offset!");
static_assert(offsetof(UNetDriver, MaxDownloadSize) == 0x000058, "Member 'UNetDriver::MaxDownloadSize' has a wrong offset!");
static_assert(offsetof(UNetDriver, NetServerMaxTickRate) == 0x000060, "Member 'UNetDriver::NetServerMaxTickRate' has a wrong offset!");
static_assert(offsetof(UNetDriver, MaxInternetClientRate) == 0x000064, "Member 'UNetDriver::MaxInternetClientRate' has a wrong offset!");
static_assert(offsetof(UNetDriver, MaxClientRate) == 0x000068, "Member 'UNetDriver::MaxClientRate' has a wrong offset!");
static_assert(offsetof(UNetDriver, ServerTravelPause) == 0x00006C, "Member 'UNetDriver::ServerTravelPause' has a wrong offset!");
static_assert(offsetof(UNetDriver, SpawnPrioritySeconds) == 0x000070, "Member 'UNetDriver::SpawnPrioritySeconds' has a wrong offset!");
static_assert(offsetof(UNetDriver, RelevantTimeout) == 0x000074, "Member 'UNetDriver::RelevantTimeout' has a wrong offset!");
static_assert(offsetof(UNetDriver, KeepAliveTime) == 0x000078, "Member 'UNetDriver::KeepAliveTime' has a wrong offset!");
static_assert(offsetof(UNetDriver, InitialConnectTimeout) == 0x00007C, "Member 'UNetDriver::InitialConnectTimeout' has a wrong offset!");
static_assert(offsetof(UNetDriver, ConnectionTimeout) == 0x000080, "Member 'UNetDriver::ConnectionTimeout' has a wrong offset!");
static_assert(offsetof(UNetDriver, TimeoutMultiplierForUnoptimizedBuilds) == 0x000084, "Member 'UNetDriver::TimeoutMultiplierForUnoptimizedBuilds' has a wrong offset!");
static_assert(offsetof(UNetDriver, bNoTimeouts) == 0x000088, "Member 'UNetDriver::bNoTimeouts' has a wrong offset!");
static_assert(offsetof(UNetDriver, ServerConnection) == 0x000090, "Member 'UNetDriver::ServerConnection' has a wrong offset!");
static_assert(offsetof(UNetDriver, ClientConnections) == 0x000098, "Member 'UNetDriver::ClientConnections' has a wrong offset!");
static_assert(offsetof(UNetDriver, World) == 0x0000C0, "Member 'UNetDriver::World' has a wrong offset!");
static_assert(offsetof(UNetDriver, NetConnectionClass) == 0x0000E8, "Member 'UNetDriver::NetConnectionClass' has a wrong offset!");
static_assert(offsetof(UNetDriver, RoleProperty) == 0x0000F0, "Member 'UNetDriver::RoleProperty' has a wrong offset!");
static_assert(offsetof(UNetDriver, RemoteRoleProperty) == 0x0000F8, "Member 'UNetDriver::RemoteRoleProperty' has a wrong offset!");
static_assert(offsetof(UNetDriver, NetDriverName) == 0x000100, "Member 'UNetDriver::NetDriverName' has a wrong offset!");
static_assert(offsetof(UNetDriver, Time) == 0x000110, "Member 'UNetDriver::Time' has a wrong offset!");

// Class Engine.DemoNetDriver
// 0x0538 (0x0960 - 0x0428)
class UDemoNetDriver final : public UNetDriver
{
public:
	uint8                                         Pad_428[0xF8];                                     // 0x0428(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FRollbackNetStartupActorInfo> RollbackNetStartupActors;                          // 0x0520(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x394];                                    // 0x0570(0x0394)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckpointSaveMaxMSPerFrame;                       // 0x0904(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_908[0x30];                                     // 0x0908(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLocalReplay;                                    // 0x0938(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_939[0x27];                                     // 0x0939(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemoNetDriver">();
	}
	static class UDemoNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemoNetDriver>();
	}
};
static_assert(alignof(UDemoNetDriver) == 0x000008, "Wrong alignment on UDemoNetDriver");
static_assert(sizeof(UDemoNetDriver) == 0x000960, "Wrong size on UDemoNetDriver");
static_assert(offsetof(UDemoNetDriver, RollbackNetStartupActors) == 0x000520, "Member 'UDemoNetDriver::RollbackNetStartupActors' has a wrong offset!");
static_assert(offsetof(UDemoNetDriver, CheckpointSaveMaxMSPerFrame) == 0x000904, "Member 'UDemoNetDriver::CheckpointSaveMaxMSPerFrame' has a wrong offset!");
static_assert(offsetof(UDemoNetDriver, bIsLocalReplay) == 0x000938, "Member 'UDemoNetDriver::bIsLocalReplay' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXDecalZFadePowOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXDecalZFadePowOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input0;                                            // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXDecalZFadePowOutput">();
	}
	static class UMaterialExpressionSQEXDecalZFadePowOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXDecalZFadePowOutput>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXDecalZFadePowOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXDecalZFadePowOutput");
static_assert(sizeof(UMaterialExpressionSQEXDecalZFadePowOutput) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXDecalZFadePowOutput");
static_assert(offsetof(UMaterialExpressionSQEXDecalZFadePowOutput, Input0) == 0x000078, "Member 'UMaterialExpressionSQEXDecalZFadePowOutput::Input0' has a wrong offset!");

// Class Engine.HierarchicalInstancedStaticMeshComponent
// 0x0000 (0x11635BE0 - 0x11635BE0)
#pragma pack(push, 0x1)
class alignas(0x11635BE0) UHierarchicalInstancedStaticMeshComponent : public UInstancedStaticMeshComponent
{
public:
	uint8                                         Pad_B40[0x10];                                     // 0x0B40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SortedInstances;                                   // 0x0B50(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumBuiltInstances;                                 // 0x0B60(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B64[0x4];                                      // 0x0B64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   BuiltInstanceBounds;                               // 0x0B68(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   UnbuiltInstanceBounds;                             // 0x0B84(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBox>                           UnbuiltInstanceBoundsList;                         // 0x0BA0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEnableDensityScaling : 1;                         // 0x0BB0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BB1[0x27];                                     // 0x0BB1(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OcclusionLayerNumNodes;                            // 0x0BD8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       CacheMeshExtendedBounds;                           // 0x0BDC(0x112EB690)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDisableCollision;                                 // 0x0BFC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BFD[0x23];                                     // 0x0BFD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RemoveInstances(const TArray<int32>& InstancesToRemove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HierarchicalInstancedStaticMeshComponent">();
	}
	static class UHierarchicalInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHierarchicalInstancedStaticMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UHierarchicalInstancedStaticMeshComponent) == 0x11635BE0, "Wrong alignment on UHierarchicalInstancedStaticMeshComponent");
static_assert(sizeof(UHierarchicalInstancedStaticMeshComponent) == 0x11635BE0, "Wrong size on UHierarchicalInstancedStaticMeshComponent");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, SortedInstances) == 0x000B50, "Member 'UHierarchicalInstancedStaticMeshComponent::SortedInstances' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, NumBuiltInstances) == 0x000B60, "Member 'UHierarchicalInstancedStaticMeshComponent::NumBuiltInstances' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, BuiltInstanceBounds) == 0x000B68, "Member 'UHierarchicalInstancedStaticMeshComponent::BuiltInstanceBounds' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, UnbuiltInstanceBounds) == 0x000B84, "Member 'UHierarchicalInstancedStaticMeshComponent::UnbuiltInstanceBounds' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, UnbuiltInstanceBoundsList) == 0x000BA0, "Member 'UHierarchicalInstancedStaticMeshComponent::UnbuiltInstanceBoundsList' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, OcclusionLayerNumNodes) == 0x000BD8, "Member 'UHierarchicalInstancedStaticMeshComponent::OcclusionLayerNumNodes' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, CacheMeshExtendedBounds) == 0x000BDC, "Member 'UHierarchicalInstancedStaticMeshComponent::CacheMeshExtendedBounds' has a wrong offset!");
static_assert(offsetof(UHierarchicalInstancedStaticMeshComponent, bDisableCollision) == 0x000BFC, "Member 'UHierarchicalInstancedStaticMeshComponent::bDisableCollision' has a wrong offset!");

// Class Engine.MaterialInterface
// 0x0048 (0x0088 - 0x0040)
class UMaterialInterface : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USubsurfaceProfile*                     SubsurfaceProfile;                                 // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightmassMaterialInterfaceSettings    LightmassSettings;                                 // 0x0058(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialTextureInfo>           TextureStreamingData;                              // 0x0070(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterial* GetBaseMaterial();

	class UPhysicalMaterial* GetPhysicalMaterial() const;
	EPhysicalSurface GetSqexPhysicalMaterialSurfaceType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInterface">();
	}
	static class UMaterialInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialInterface>();
	}
};
static_assert(alignof(UMaterialInterface) == 0x000008, "Wrong alignment on UMaterialInterface");
static_assert(sizeof(UMaterialInterface) == 0x000088, "Wrong size on UMaterialInterface");
static_assert(offsetof(UMaterialInterface, SubsurfaceProfile) == 0x000048, "Member 'UMaterialInterface::SubsurfaceProfile' has a wrong offset!");
static_assert(offsetof(UMaterialInterface, LightmassSettings) == 0x000058, "Member 'UMaterialInterface::LightmassSettings' has a wrong offset!");
static_assert(offsetof(UMaterialInterface, TextureStreamingData) == 0x000070, "Member 'UMaterialInterface::TextureStreamingData' has a wrong offset!");

// Class Engine.ParticleModuleRotationBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleRotationBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotationBase">();
	}
	static class UParticleModuleRotationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotationBase>();
	}
};
static_assert(alignof(UParticleModuleRotationBase) == 0x000008, "Wrong alignment on UParticleModuleRotationBase");
static_assert(sizeof(UParticleModuleRotationBase) == 0x000050, "Wrong size on UParticleModuleRotationBase");

// Class Engine.ParticleModuleRotation
// 0x0038 (0x0088 - 0x0050)
class UParticleModuleRotation : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                  StartRotation;                                     // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotation">();
	}
	static class UParticleModuleRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotation>();
	}
};
static_assert(alignof(UParticleModuleRotation) == 0x000008, "Wrong alignment on UParticleModuleRotation");
static_assert(sizeof(UParticleModuleRotation) == 0x000088, "Wrong size on UParticleModuleRotation");
static_assert(offsetof(UParticleModuleRotation, StartRotation) == 0x000050, "Member 'UParticleModuleRotation::StartRotation' has a wrong offset!");

// Class Engine.MaterialInstanceActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMaterialInstanceActor final : public AActor
{
public:
	TArray<class AActor*>                         TargetActors;                                      // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInstanceActor">();
	}
	static class AMaterialInstanceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMaterialInstanceActor>();
	}
};
static_assert(alignof(AMaterialInstanceActor) == 0x1EF72E00, "Wrong alignment on AMaterialInstanceActor");
static_assert(sizeof(AMaterialInstanceActor) == 0x1EF72E00, "Wrong size on AMaterialInstanceActor");
static_assert(offsetof(AMaterialInstanceActor, TargetActors) == 0x0003E0, "Member 'AMaterialInstanceActor::TargetActors' has a wrong offset!");

// Class Engine.DialogueSoundWaveProxy
// 0x0000 (0x1166C9B0 - 0x1166C9B0)
class UDialogueSoundWaveProxy final : public USoundBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueSoundWaveProxy">();
	}
	static class UDialogueSoundWaveProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueSoundWaveProxy>();
	}
};
static_assert(alignof(UDialogueSoundWaveProxy) == 0x1166C9B0, "Wrong alignment on UDialogueSoundWaveProxy");
static_assert(sizeof(UDialogueSoundWaveProxy) == 0x1166C9B0, "Wrong size on UDialogueSoundWaveProxy");

// Class Engine.MaterialInstance
// 0x0150 (0x01D8 - 0x0088)
class UMaterialInstance : public UMaterialInterface
{
public:
	class UPhysicalMaterial*                      PhysMaterial;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Parent;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasStaticPermutationResource : 1;                 // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_98_1 : 1;                                   // 0x0098(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bOverrideSubsurfaceProfile : 1;                    // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFontParameterValue>            FontParameterValues;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FScalarParameterValue>          ScalarParameterValues;                             // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTextureParameterValue>         TextureParameterValues;                            // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVectorParameterValue>          VectorParameterValues;                             // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideBaseProperties;                           // 0x00E0(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaterialInstanceBasePropertyOverrides BasePropertyOverrides;                             // 0x00E4(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0xD8];                                     // 0x0100(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInstance">();
	}
	static class UMaterialInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialInstance>();
	}
};
static_assert(alignof(UMaterialInstance) == 0x000008, "Wrong alignment on UMaterialInstance");
static_assert(sizeof(UMaterialInstance) == 0x0001D8, "Wrong size on UMaterialInstance");
static_assert(offsetof(UMaterialInstance, PhysMaterial) == 0x000088, "Member 'UMaterialInstance::PhysMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, Parent) == 0x000090, "Member 'UMaterialInstance::Parent' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, FontParameterValues) == 0x0000A0, "Member 'UMaterialInstance::FontParameterValues' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, ScalarParameterValues) == 0x0000B0, "Member 'UMaterialInstance::ScalarParameterValues' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, TextureParameterValues) == 0x0000C0, "Member 'UMaterialInstance::TextureParameterValues' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, VectorParameterValues) == 0x0000D0, "Member 'UMaterialInstance::VectorParameterValues' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, bOverrideBaseProperties) == 0x0000E0, "Member 'UMaterialInstance::bOverrideBaseProperties' has a wrong offset!");
static_assert(offsetof(UMaterialInstance, BasePropertyOverrides) == 0x0000E4, "Member 'UMaterialInstance::BasePropertyOverrides' has a wrong offset!");

// Class Engine.PointLightComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UPointLightComponent : public ULightComponent
{
public:
	float                                         Radius;                                            // 0x0560(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationRadius;                                 // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseInverseSquaredFalloff : 1;                     // 0x0568(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightFalloffExponent;                              // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceRadius;                                      // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLength;                                      // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightmassPointLightSettings           LightmassSettings;                                 // 0x0578(0x12933)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	void SetAttenuationRadius(float NewRadius);
	void SetLightFalloffExponent(float NewLightFalloffExponent);
	void SetSourceLength(float NewValue);
	void SetSourceRadius(float bNewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointLightComponent">();
	}
	static class UPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointLightComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UPointLightComponent) == 0x112E9AF0, "Wrong alignment on UPointLightComponent");
static_assert(sizeof(UPointLightComponent) == 0x112E9AF0, "Wrong size on UPointLightComponent");
static_assert(offsetof(UPointLightComponent, Radius) == 0x000560, "Member 'UPointLightComponent::Radius' has a wrong offset!");
static_assert(offsetof(UPointLightComponent, AttenuationRadius) == 0x000564, "Member 'UPointLightComponent::AttenuationRadius' has a wrong offset!");
static_assert(offsetof(UPointLightComponent, LightFalloffExponent) == 0x00056C, "Member 'UPointLightComponent::LightFalloffExponent' has a wrong offset!");
static_assert(offsetof(UPointLightComponent, SourceRadius) == 0x000570, "Member 'UPointLightComponent::SourceRadius' has a wrong offset!");
static_assert(offsetof(UPointLightComponent, SourceLength) == 0x000574, "Member 'UPointLightComponent::SourceLength' has a wrong offset!");
static_assert(offsetof(UPointLightComponent, LightmassSettings) == 0x000578, "Member 'UPointLightComponent::LightmassSettings' has a wrong offset!");

// Class Engine.MaterialInstanceConstant
// 0x0000 (0x01D8 - 0x01D8)
class UMaterialInstanceConstant : public UMaterialInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInstanceConstant">();
	}
	static class UMaterialInstanceConstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialInstanceConstant>();
	}
};
static_assert(alignof(UMaterialInstanceConstant) == 0x000008, "Wrong alignment on UMaterialInstanceConstant");
static_assert(sizeof(UMaterialInstanceConstant) == 0x0001D8, "Wrong size on UMaterialInstanceConstant");

// Class Engine.MaterialInstanceDynamic
// 0x0050 (0x0228 - 0x01D8)
class UMaterialInstanceDynamic final : public UMaterialInstance
{
public:
	uint8                                         Pad_1D8[0x50];                                     // 0x01D8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyInterpParameters(class UMaterialInstance* Source);
	void CopyParameterOverrides(class UMaterialInstance* MaterialInstance);
	void K2_CopyMaterialInstanceParameters(class UMaterialInterface* Source);
	float K2_GetScalarParameterValue(class FName ParameterName);
	class UTexture* K2_GetTextureParameterValue(class FName ParameterName);
	struct FLinearColor K2_GetVectorParameterValue(class FName ParameterName);
	void K2_InterpolateMaterialInstanceParams(class UMaterialInstance* SourceA, class UMaterialInstance* SourceB, float Alpha);
	void SetScalarParameterValue(class FName ParameterName, float Value);
	void SetTextureParameterValue(class FName ParameterName, class UTexture* Value);
	void SetVectorParameterValue(class FName ParameterName, const struct FLinearColor& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialInstanceDynamic">();
	}
	static class UMaterialInstanceDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialInstanceDynamic>();
	}
};
static_assert(alignof(UMaterialInstanceDynamic) == 0x000008, "Wrong alignment on UMaterialInstanceDynamic");
static_assert(sizeof(UMaterialInstanceDynamic) == 0x000228, "Wrong size on UMaterialInstanceDynamic");

// Class Engine.MorphTarget
// 0x0018 (0x0058 - 0x0040)
class UMorphTarget final : public UObject
{
public:
	class USkeletalMesh*                          BaseSkelMesh;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MorphTarget">();
	}
	static class UMorphTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMorphTarget>();
	}
};
static_assert(alignof(UMorphTarget) == 0x000008, "Wrong alignment on UMorphTarget");
static_assert(sizeof(UMorphTarget) == 0x000058, "Wrong size on UMorphTarget");
static_assert(offsetof(UMorphTarget, BaseSkelMesh) == 0x000040, "Member 'UMorphTarget::BaseSkelMesh' has a wrong offset!");

// Class Engine.BlueprintGeneratedClass
// 0x0108 (0x0330 - 0x0228)
class UBlueprintGeneratedClass : public UClass
{
public:
	int32                                         NumReplicatedProperties;                           // 0x0228(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDynamicBlueprintBinding*>       DynamicBindingObjects;                             // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ComponentTemplates;                                // 0x0240(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UTimelineTemplate*>              Timelines;                                         // 0x0250(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class USimpleConstructionScript*              SimpleConstructionScript;                          // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInheritableComponentHandler*           InheritableComponentHandler;                       // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStructProperty*                        UberGraphFramePointerProperty;                     // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFunction*                              UberGraphFunction;                                 // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEventGraphFastCallPair>        FastCallPairs;                                     // 0x0280(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	bool                                          bHasInstrumentation;                               // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FBlueprintCookedComponentInstancingData> CookedComponentInstancingData;                     // 0x0298(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasNativizedParent;                               // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x47];                                     // 0x02E9(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintGeneratedClass">();
	}
	static class UBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UBlueprintGeneratedClass) == 0x000008, "Wrong alignment on UBlueprintGeneratedClass");
static_assert(sizeof(UBlueprintGeneratedClass) == 0x000330, "Wrong size on UBlueprintGeneratedClass");
static_assert(offsetof(UBlueprintGeneratedClass, NumReplicatedProperties) == 0x000228, "Member 'UBlueprintGeneratedClass::NumReplicatedProperties' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, DynamicBindingObjects) == 0x000230, "Member 'UBlueprintGeneratedClass::DynamicBindingObjects' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, ComponentTemplates) == 0x000240, "Member 'UBlueprintGeneratedClass::ComponentTemplates' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, Timelines) == 0x000250, "Member 'UBlueprintGeneratedClass::Timelines' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, SimpleConstructionScript) == 0x000260, "Member 'UBlueprintGeneratedClass::SimpleConstructionScript' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, InheritableComponentHandler) == 0x000268, "Member 'UBlueprintGeneratedClass::InheritableComponentHandler' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, UberGraphFramePointerProperty) == 0x000270, "Member 'UBlueprintGeneratedClass::UberGraphFramePointerProperty' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, UberGraphFunction) == 0x000278, "Member 'UBlueprintGeneratedClass::UberGraphFunction' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, FastCallPairs) == 0x000280, "Member 'UBlueprintGeneratedClass::FastCallPairs' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, bHasInstrumentation) == 0x000290, "Member 'UBlueprintGeneratedClass::bHasInstrumentation' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, CookedComponentInstancingData) == 0x000298, "Member 'UBlueprintGeneratedClass::CookedComponentInstancingData' has a wrong offset!");
static_assert(offsetof(UBlueprintGeneratedClass, bHasNativizedParent) == 0x0002E8, "Member 'UBlueprintGeneratedClass::bHasNativizedParent' has a wrong offset!");

// Class Engine.MaterialExpressionPrecomputedAOMask
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPrecomputedAOMask final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPrecomputedAOMask">();
	}
	static class UMaterialExpressionPrecomputedAOMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPrecomputedAOMask>();
	}
};
static_assert(alignof(UMaterialExpressionPrecomputedAOMask) == 0x000008, "Wrong alignment on UMaterialExpressionPrecomputedAOMask");
static_assert(sizeof(UMaterialExpressionPrecomputedAOMask) == 0x000078, "Wrong size on UMaterialExpressionPrecomputedAOMask");

// Class Engine.AssetUserData
// 0x0000 (0x0040 - 0x0040)
class UAssetUserData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetUserData">();
	}
	static class UAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetUserData>();
	}
};
static_assert(alignof(UAssetUserData) == 0x000008, "Wrong alignment on UAssetUserData");
static_assert(sizeof(UAssetUserData) == 0x000040, "Wrong size on UAssetUserData");

// Class Engine.BodySetup2D
// 0x0000 (0x11389E60 - 0x11389E60)
class UBodySetup2D final : public UBodySetup
{
public:
	struct FAggregateGeometry2D                   AggGeom2D;                                         // 0x03B8(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodySetup2D">();
	}
	static class UBodySetup2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodySetup2D>();
	}
};
static_assert(alignof(UBodySetup2D) == 0x11389E60, "Wrong alignment on UBodySetup2D");
static_assert(sizeof(UBodySetup2D) == 0x11389E60, "Wrong size on UBodySetup2D");
static_assert(offsetof(UBodySetup2D, AggGeom2D) == 0x0003B8, "Member 'UBodySetup2D::AggGeom2D' has a wrong offset!");

// Class Engine.MaterialExpressionTextureObjectParameter
// 0x0000 (0x112F2730 - 0x112F2730)
class UMaterialExpressionTextureObjectParameter final : public UMaterialExpressionTextureSampleParameter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureObjectParameter">();
	}
	static class UMaterialExpressionTextureObjectParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureObjectParameter>();
	}
};
static_assert(alignof(UMaterialExpressionTextureObjectParameter) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureObjectParameter");
static_assert(sizeof(UMaterialExpressionTextureObjectParameter) == 0x112F2730, "Wrong size on UMaterialExpressionTextureObjectParameter");

// Class Engine.WindDirectionalSourceComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UWindDirectionalSourceComponent final : public USceneComponent
{
public:
	float                                         Strength;                                          // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGustAmount;                                     // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGustAmount;                                     // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPointWind : 1;                                    // 0x042C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_42D[0x13];                                     // 0x042D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaximumGustAmount(float InNewMaxGust);
	void SetMinimumGustAmount(float InNewMinGust);
	void SetRadius(float InNewRadius);
	void SetSpeed(float InNewSpeed);
	void SetStrength(float InNewStrength);
	void SetWindType(EWindSourceType InNewType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindDirectionalSourceComponent">();
	}
	static class UWindDirectionalSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindDirectionalSourceComponent>();
	}
};
static_assert(alignof(UWindDirectionalSourceComponent) == 0x112E9AF0, "Wrong alignment on UWindDirectionalSourceComponent");
static_assert(sizeof(UWindDirectionalSourceComponent) == 0x112E9AF0, "Wrong size on UWindDirectionalSourceComponent");
static_assert(offsetof(UWindDirectionalSourceComponent, Strength) == 0x000418, "Member 'UWindDirectionalSourceComponent::Strength' has a wrong offset!");
static_assert(offsetof(UWindDirectionalSourceComponent, Speed) == 0x00041C, "Member 'UWindDirectionalSourceComponent::Speed' has a wrong offset!");
static_assert(offsetof(UWindDirectionalSourceComponent, MinGustAmount) == 0x000420, "Member 'UWindDirectionalSourceComponent::MinGustAmount' has a wrong offset!");
static_assert(offsetof(UWindDirectionalSourceComponent, MaxGustAmount) == 0x000424, "Member 'UWindDirectionalSourceComponent::MaxGustAmount' has a wrong offset!");
static_assert(offsetof(UWindDirectionalSourceComponent, Radius) == 0x000428, "Member 'UWindDirectionalSourceComponent::Radius' has a wrong offset!");

// Class Engine.ParticleModuleBeamBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleBeamBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBeamBase">();
	}
	static class UParticleModuleBeamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBeamBase>();
	}
};
static_assert(alignof(UParticleModuleBeamBase) == 0x000008, "Wrong alignment on UParticleModuleBeamBase");
static_assert(sizeof(UParticleModuleBeamBase) == 0x000050, "Wrong size on UParticleModuleBeamBase");

// Class Engine.ParticleModuleBeamTarget
// 0x0108 (0x0158 - 0x0050)
class UParticleModuleBeamTarget final : public UParticleModuleBeamBase
{
public:
	EBeam2SourceTargetMethod                      TargetMethod;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetName;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 Target;                                            // 0x0060(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bTargetAbsolute : 1;                               // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockTarget : 1;                                   // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBeam2SourceTargetTangentMethod               TargetTangentMethod;                               // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 TargetTangent;                                     // 0x00B8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLockTargetTangent : 1;                            // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  TargetStrength;                                    // 0x0110(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLockTargetStength : 1;                            // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockRadius;                                        // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBeamTarget">();
	}
	static class UParticleModuleBeamTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBeamTarget>();
	}
};
static_assert(alignof(UParticleModuleBeamTarget) == 0x000008, "Wrong alignment on UParticleModuleBeamTarget");
static_assert(sizeof(UParticleModuleBeamTarget) == 0x000158, "Wrong size on UParticleModuleBeamTarget");
static_assert(offsetof(UParticleModuleBeamTarget, TargetMethod) == 0x000050, "Member 'UParticleModuleBeamTarget::TargetMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamTarget, TargetName) == 0x000058, "Member 'UParticleModuleBeamTarget::TargetName' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamTarget, Target) == 0x000060, "Member 'UParticleModuleBeamTarget::Target' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamTarget, TargetTangentMethod) == 0x0000B4, "Member 'UParticleModuleBeamTarget::TargetTangentMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamTarget, TargetTangent) == 0x0000B8, "Member 'UParticleModuleBeamTarget::TargetTangent' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamTarget, TargetStrength) == 0x000110, "Member 'UParticleModuleBeamTarget::TargetStrength' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamTarget, LockRadius) == 0x00014C, "Member 'UParticleModuleBeamTarget::LockRadius' has a wrong offset!");

// Class Engine.LODActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ALODActor final : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         SubActors;                                         // 0x03E8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         LODDrawDistance;                                   // 0x03F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODLevel;                                          // 0x03FC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        SubObjects;                                        // 0x0400(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SQEX_SetForceLODDisable(bool bForceLODDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LODActor">();
	}
	static class ALODActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALODActor>();
	}
};
static_assert(alignof(ALODActor) == 0x1EF72E00, "Wrong alignment on ALODActor");
static_assert(sizeof(ALODActor) == 0x1EF72E00, "Wrong size on ALODActor");
static_assert(offsetof(ALODActor, StaticMeshComponent) == 0x0003E0, "Member 'ALODActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ALODActor, SubActors) == 0x0003E8, "Member 'ALODActor::SubActors' has a wrong offset!");
static_assert(offsetof(ALODActor, LODDrawDistance) == 0x0003F8, "Member 'ALODActor::LODDrawDistance' has a wrong offset!");
static_assert(offsetof(ALODActor, LODLevel) == 0x0003FC, "Member 'ALODActor::LODLevel' has a wrong offset!");
static_assert(offsetof(ALODActor, SubObjects) == 0x000400, "Member 'ALODActor::SubObjects' has a wrong offset!");

// Class Engine.CrowdManagerBase
// 0x0000 (0x0040 - 0x0040)
class UCrowdManagerBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowdManagerBase">();
	}
	static class UCrowdManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowdManagerBase>();
	}
};
static_assert(alignof(UCrowdManagerBase) == 0x000008, "Wrong alignment on UCrowdManagerBase");
static_assert(sizeof(UCrowdManagerBase) == 0x000040, "Wrong size on UCrowdManagerBase");

// Class Engine.Model
// 0x0550 (0x0590 - 0x0040)
class UModel final : public UObject
{
public:
	uint8                                         Pad_40[0x550];                                     // 0x0040(0x0550)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Model">();
	}
	static class UModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModel>();
	}
};
static_assert(alignof(UModel) == 0x000008, "Wrong alignment on UModel");
static_assert(sizeof(UModel) == 0x000590, "Wrong size on UModel");

// Class Engine.TextureCube
// 0x0000 (0x112E8D20 - 0x112E8D20)
class UTextureCube final : public UTexture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureCube">();
	}
	static class UTextureCube* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureCube>();
	}
};
static_assert(alignof(UTextureCube) == 0x112E8D20, "Wrong alignment on UTextureCube");
static_assert(sizeof(UTextureCube) == 0x112E8D20, "Wrong size on UTextureCube");

// Class Engine.DecalActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADecalActor final : public AActor
{
public:
	class UDecalComponent*                        Decal;                                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
	void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);

	class UMaterialInterface* GetDecalMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalActor">();
	}
	static class ADecalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADecalActor>();
	}
};
static_assert(alignof(ADecalActor) == 0x1EF72E00, "Wrong alignment on ADecalActor");
static_assert(sizeof(ADecalActor) == 0x1EF72E00, "Wrong size on ADecalActor");
static_assert(offsetof(ADecalActor, Decal) == 0x0003E0, "Member 'ADecalActor::Decal' has a wrong offset!");

// Class Engine.MaterialExpressionConstant
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionConstant final : public UMaterialExpression
{
public:
	float                                         R;                                                 // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionConstant">();
	}
	static class UMaterialExpressionConstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionConstant>();
	}
};
static_assert(alignof(UMaterialExpressionConstant) == 0x000008, "Wrong alignment on UMaterialExpressionConstant");
static_assert(sizeof(UMaterialExpressionConstant) == 0x000080, "Wrong size on UMaterialExpressionConstant");
static_assert(offsetof(UMaterialExpressionConstant, R) == 0x000078, "Member 'UMaterialExpressionConstant::R' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TailShapeExData_Wave
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleSQEX_TailShapeExData_Wave final : public UParticleModuleSQEX_TailShape_Base
{
public:
	uint8                                         bUseEmitterMat : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveVector;                                        // 0x0054(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInterval;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RandomMoveVector;                                  // 0x0070(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x00C0(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bNoSetSamePostionData : 1;                         // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TailShapeExData_Wave">();
	}
	static class UParticleModuleSQEX_TailShapeExData_Wave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TailShapeExData_Wave>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TailShapeExData_Wave) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_TailShapeExData_Wave");
static_assert(sizeof(UParticleModuleSQEX_TailShapeExData_Wave) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_TailShapeExData_Wave");
static_assert(offsetof(UParticleModuleSQEX_TailShapeExData_Wave, MoveVector) == 0x000054, "Member 'UParticleModuleSQEX_TailShapeExData_Wave::MoveVector' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShapeExData_Wave, RandomInterval) == 0x000060, "Member 'UParticleModuleSQEX_TailShapeExData_Wave::RandomInterval' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShapeExData_Wave, RandomMoveVector) == 0x000070, "Member 'UParticleModuleSQEX_TailShapeExData_Wave::RandomMoveVector' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShapeExData_Wave, RotationOffset) == 0x0000C0, "Member 'UParticleModuleSQEX_TailShapeExData_Wave::RotationOffset' has a wrong offset!");

// Class Engine.AbstractNavData
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AAbstractNavData final : public ANavigationData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractNavData">();
	}
	static class AAbstractNavData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbstractNavData>();
	}
};
static_assert(alignof(AAbstractNavData) == 0x1EF72E00, "Wrong alignment on AAbstractNavData");
static_assert(sizeof(AAbstractNavData) == 0x1EF72E00, "Wrong size on AAbstractNavData");

// Class Engine.DestructibleFractureSettings
// 0x11629C00 (0x11629C40 - 0x0040)
class UDestructibleFractureSettings final : public UObject
{
public:
	int32                                         CellSiteCount;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFractureMaterial                      FractureMaterialDesc;                              // 0x0044(0x11629C40)(Edit, Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RandomSeed;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        VoronoiSites;                                      // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         OriginalSubmeshCount;                              // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDestructibleChunkParameters>   ChunkParameters;                                   // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleFractureSettings">();
	}
	static class UDestructibleFractureSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleFractureSettings>();
	}
};
static_assert(alignof(UDestructibleFractureSettings) == 0x11629C40, "Wrong alignment on UDestructibleFractureSettings");
static_assert(sizeof(UDestructibleFractureSettings) == 0x11629C40, "Wrong size on UDestructibleFractureSettings");
static_assert(offsetof(UDestructibleFractureSettings, CellSiteCount) == 0x000040, "Member 'UDestructibleFractureSettings::CellSiteCount' has a wrong offset!");
static_assert(offsetof(UDestructibleFractureSettings, FractureMaterialDesc) == 0x000044, "Member 'UDestructibleFractureSettings::FractureMaterialDesc' has a wrong offset!");
static_assert(offsetof(UDestructibleFractureSettings, RandomSeed) == 0x000068, "Member 'UDestructibleFractureSettings::RandomSeed' has a wrong offset!");
static_assert(offsetof(UDestructibleFractureSettings, VoronoiSites) == 0x000070, "Member 'UDestructibleFractureSettings::VoronoiSites' has a wrong offset!");
static_assert(offsetof(UDestructibleFractureSettings, OriginalSubmeshCount) == 0x000080, "Member 'UDestructibleFractureSettings::OriginalSubmeshCount' has a wrong offset!");
static_assert(offsetof(UDestructibleFractureSettings, Materials) == 0x000088, "Member 'UDestructibleFractureSettings::Materials' has a wrong offset!");
static_assert(offsetof(UDestructibleFractureSettings, ChunkParameters) == 0x000098, "Member 'UDestructibleFractureSettings::ChunkParameters' has a wrong offset!");

// Class Engine.Channel
// 0x0040 (0x0080 - 0x0040)
class UChannel : public UObject
{
public:
	class UNetConnection*                         Connection;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x38];                                      // 0x0048(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Channel">();
	}
	static class UChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChannel>();
	}
};
static_assert(alignof(UChannel) == 0x000008, "Wrong alignment on UChannel");
static_assert(sizeof(UChannel) == 0x000080, "Wrong size on UChannel");
static_assert(offsetof(UChannel, Connection) == 0x000040, "Member 'UChannel::Connection' has a wrong offset!");

// Class Engine.ActorChannel
// 0x01C8 (0x0248 - 0x0080)
class UActorChannel final : public UChannel
{
public:
	class AActor*                                 Actor;                                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x1C0];                                     // 0x0088(0x01C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorChannel">();
	}
	static class UActorChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorChannel>();
	}
};
static_assert(alignof(UActorChannel) == 0x000008, "Wrong alignment on UActorChannel");
static_assert(sizeof(UActorChannel) == 0x000248, "Wrong size on UActorChannel");
static_assert(offsetof(UActorChannel, Actor) == 0x000080, "Member 'UActorChannel::Actor' has a wrong offset!");

// Class Engine.AnimationAsset
// 0x0050 (0x0090 - 0x0040)
class UAnimationAsset : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMetaData*>                  MetaData;                                          // 0x0070(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0080(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationAsset">();
	}
	static class UAnimationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationAsset>();
	}
};
static_assert(alignof(UAnimationAsset) == 0x000008, "Wrong alignment on UAnimationAsset");
static_assert(sizeof(UAnimationAsset) == 0x000090, "Wrong size on UAnimationAsset");
static_assert(offsetof(UAnimationAsset, Skeleton) == 0x000048, "Member 'UAnimationAsset::Skeleton' has a wrong offset!");
static_assert(offsetof(UAnimationAsset, MetaData) == 0x000070, "Member 'UAnimationAsset::MetaData' has a wrong offset!");
static_assert(offsetof(UAnimationAsset, AssetUserData) == 0x000080, "Member 'UAnimationAsset::AssetUserData' has a wrong offset!");

// Class Engine.BlendSpaceBase
// 0x11609D20 (0x11609DB0 - 0x0090)
#pragma pack(push, 0x1)
class alignas(0x11609DB0) UBlendSpaceBase : public UAnimationAsset
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRotationBlendInMeshSpace;                         // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimLength;                                        // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpolationParameter                InterpolationParam[0x3];                           // 0x00A0(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TargetWeightInterpolationSpeedPerSec;              // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyTriggerMode                            NotifyTriggerMode;                                 // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerBoneInterpolation>          PerBoneBlend;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         SampleIndexWithMarkers;                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlendSample>                   SampleData;                                        // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEditorElement>                 GridSamples;                                       // 0x00F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBlendParameter                        BlendParameters[0x3];                              // 0x0108(0x11609DB0)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         M_IsEyeLookAtBlendSpace : 1;                       // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_InterpolationTime;                               // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendSpaceBase">();
	}
	static class UBlendSpaceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendSpaceBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBlendSpaceBase) == 0x11609DB0, "Wrong alignment on UBlendSpaceBase");
static_assert(sizeof(UBlendSpaceBase) == 0x11609DB0, "Wrong size on UBlendSpaceBase");
static_assert(offsetof(UBlendSpaceBase, bRotationBlendInMeshSpace) == 0x000098, "Member 'UBlendSpaceBase::bRotationBlendInMeshSpace' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, AnimLength) == 0x00009C, "Member 'UBlendSpaceBase::AnimLength' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, InterpolationParam) == 0x0000A0, "Member 'UBlendSpaceBase::InterpolationParam' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, TargetWeightInterpolationSpeedPerSec) == 0x0000C4, "Member 'UBlendSpaceBase::TargetWeightInterpolationSpeedPerSec' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, NotifyTriggerMode) == 0x0000C8, "Member 'UBlendSpaceBase::NotifyTriggerMode' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, PerBoneBlend) == 0x0000D0, "Member 'UBlendSpaceBase::PerBoneBlend' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, SampleIndexWithMarkers) == 0x0000E0, "Member 'UBlendSpaceBase::SampleIndexWithMarkers' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, SampleData) == 0x0000E8, "Member 'UBlendSpaceBase::SampleData' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, GridSamples) == 0x0000F8, "Member 'UBlendSpaceBase::GridSamples' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, BlendParameters) == 0x000108, "Member 'UBlendSpaceBase::BlendParameters' has a wrong offset!");
static_assert(offsetof(UBlendSpaceBase, M_InterpolationTime) == 0x00016C, "Member 'UBlendSpaceBase::M_InterpolationTime' has a wrong offset!");

// Class Engine.ParticleModuleMaterialBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleMaterialBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMaterialBase">();
	}
	static class UParticleModuleMaterialBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMaterialBase>();
	}
};
static_assert(alignof(UParticleModuleMaterialBase) == 0x000008, "Wrong alignment on UParticleModuleMaterialBase");
static_assert(sizeof(UParticleModuleMaterialBase) == 0x000050, "Wrong size on UParticleModuleMaterialBase");

// Class Engine.BlendSpace
// 0x0000 (0x11609DB0 - 0x11609DB0)
class UBlendSpace : public UBlendSpaceBase
{
public:
	EBlendSpaceAxis                               AxisToScaleAnimation;                              // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendSpace">();
	}
	static class UBlendSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendSpace>();
	}
};
static_assert(alignof(UBlendSpace) == 0x11609DB0, "Wrong alignment on UBlendSpace");
static_assert(sizeof(UBlendSpace) == 0x11609DB0, "Wrong size on UBlendSpace");
static_assert(offsetof(UBlendSpace, AxisToScaleAnimation) == 0x000170, "Member 'UBlendSpace::AxisToScaleAnimation' has a wrong offset!");

// Class Engine.MaterialExpressionDistance
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDistance final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDistance">();
	}
	static class UMaterialExpressionDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDistance>();
	}
};
static_assert(alignof(UMaterialExpressionDistance) == 0x112F2730, "Wrong alignment on UMaterialExpressionDistance");
static_assert(sizeof(UMaterialExpressionDistance) == 0x112F2730, "Wrong size on UMaterialExpressionDistance");
static_assert(offsetof(UMaterialExpressionDistance, A) == 0x000078, "Member 'UMaterialExpressionDistance::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDistance, B) == 0x0000B0, "Member 'UMaterialExpressionDistance::B' has a wrong offset!");

// Class Engine.DebugCameraHUD
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADebugCameraHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugCameraHUD">();
	}
	static class ADebugCameraHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugCameraHUD>();
	}
};
static_assert(alignof(ADebugCameraHUD) == 0x1EF72E00, "Wrong alignment on ADebugCameraHUD");
static_assert(sizeof(ADebugCameraHUD) == 0x1EF72E00, "Wrong size on ADebugCameraHUD");

// Class Engine.AimOffsetBlendSpace
// 0x0000 (0x11609DB0 - 0x11609DB0)
class UAimOffsetBlendSpace final : public UBlendSpace
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimOffsetBlendSpace">();
	}
	static class UAimOffsetBlendSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimOffsetBlendSpace>();
	}
};
static_assert(alignof(UAimOffsetBlendSpace) == 0x11609DB0, "Wrong alignment on UAimOffsetBlendSpace");
static_assert(sizeof(UAimOffsetBlendSpace) == 0x11609DB0, "Wrong size on UAimOffsetBlendSpace");

// Class Engine.MaterialExpressionFloor
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFloor final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFloor">();
	}
	static class UMaterialExpressionFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFloor>();
	}
};
static_assert(alignof(UMaterialExpressionFloor) == 0x112F2730, "Wrong alignment on UMaterialExpressionFloor");
static_assert(sizeof(UMaterialExpressionFloor) == 0x112F2730, "Wrong size on UMaterialExpressionFloor");
static_assert(offsetof(UMaterialExpressionFloor, Input) == 0x000078, "Member 'UMaterialExpressionFloor::Input' has a wrong offset!");

// Class Engine.DestructibleActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADestructibleActor final : public AActor
{
public:
	class UDestructibleComponent*                 DestructibleComponent;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAffectNavigation : 1;                             // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActorFracture;                                   // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleActor">();
	}
	static class ADestructibleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADestructibleActor>();
	}
};
static_assert(alignof(ADestructibleActor) == 0x1EF72E00, "Wrong alignment on ADestructibleActor");
static_assert(sizeof(ADestructibleActor) == 0x1EF72E00, "Wrong size on ADestructibleActor");
static_assert(offsetof(ADestructibleActor, DestructibleComponent) == 0x0003E0, "Member 'ADestructibleActor::DestructibleComponent' has a wrong offset!");
static_assert(offsetof(ADestructibleActor, OnActorFracture) == 0x0003F0, "Member 'ADestructibleActor::OnActorFracture' has a wrong offset!");

// Class Engine.MaterialExpressionComponentMask
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionComponentMask final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	uint8                                         R : 1;                                             // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         G : 1;                                             // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         B : 1;                                             // 0x00B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         A : 1;                                             // 0x00B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionComponentMask">();
	}
	static class UMaterialExpressionComponentMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionComponentMask>();
	}
};
static_assert(alignof(UMaterialExpressionComponentMask) == 0x112F2730, "Wrong alignment on UMaterialExpressionComponentMask");
static_assert(sizeof(UMaterialExpressionComponentMask) == 0x112F2730, "Wrong size on UMaterialExpressionComponentMask");
static_assert(offsetof(UMaterialExpressionComponentMask, Input) == 0x000078, "Member 'UMaterialExpressionComponentMask::Input' has a wrong offset!");

// Class Engine.BlendSpace1D
// 0x0000 (0x11609DB0 - 0x11609DB0)
class UBlendSpace1D : public UBlendSpaceBase
{
public:
	bool                                          bScaleAnimation;                                   // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendSpace1D">();
	}
	static class UBlendSpace1D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendSpace1D>();
	}
};
static_assert(alignof(UBlendSpace1D) == 0x11609DB0, "Wrong alignment on UBlendSpace1D");
static_assert(sizeof(UBlendSpace1D) == 0x11609DB0, "Wrong size on UBlendSpace1D");
static_assert(offsetof(UBlendSpace1D, bScaleAnimation) == 0x000170, "Member 'UBlendSpace1D::bScaleAnimation' has a wrong offset!");

// Class Engine.ParticleModuleLifetimeBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleLifetimeBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLifetimeBase">();
	}
	static class UParticleModuleLifetimeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLifetimeBase>();
	}
};
static_assert(alignof(UParticleModuleLifetimeBase) == 0x000008, "Wrong alignment on UParticleModuleLifetimeBase");
static_assert(sizeof(UParticleModuleLifetimeBase) == 0x000050, "Wrong size on UParticleModuleLifetimeBase");

// Class Engine.ParticleModuleLifetime
// 0x0038 (0x0088 - 0x0050)
class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
public:
	struct FRawDistributionFloat                  LifeTime;                                          // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLifetime">();
	}
	static class UParticleModuleLifetime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLifetime>();
	}
};
static_assert(alignof(UParticleModuleLifetime) == 0x000008, "Wrong alignment on UParticleModuleLifetime");
static_assert(sizeof(UParticleModuleLifetime) == 0x000088, "Wrong size on UParticleModuleLifetime");
static_assert(offsetof(UParticleModuleLifetime, LifeTime) == 0x000050, "Member 'UParticleModuleLifetime::LifeTime' has a wrong offset!");

// Class Engine.ParticleModuleLifetime_Seeded
// 0x0020 (0x00A8 - 0x0088)
class UParticleModuleLifetime_Seeded final : public UParticleModuleLifetime
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0088(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLifetime_Seeded">();
	}
	static class UParticleModuleLifetime_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLifetime_Seeded>();
	}
};
static_assert(alignof(UParticleModuleLifetime_Seeded) == 0x000008, "Wrong alignment on UParticleModuleLifetime_Seeded");
static_assert(sizeof(UParticleModuleLifetime_Seeded) == 0x0000A8, "Wrong size on UParticleModuleLifetime_Seeded");
static_assert(offsetof(UParticleModuleLifetime_Seeded, RandomSeedInfo) == 0x000088, "Member 'UParticleModuleLifetime_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.AimOffsetBlendSpace1D
// 0x0000 (0x11609DB0 - 0x11609DB0)
class UAimOffsetBlendSpace1D final : public UBlendSpace1D
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimOffsetBlendSpace1D">();
	}
	static class UAimOffsetBlendSpace1D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimOffsetBlendSpace1D>();
	}
};
static_assert(alignof(UAimOffsetBlendSpace1D) == 0x11609DB0, "Wrong alignment on UAimOffsetBlendSpace1D");
static_assert(sizeof(UAimOffsetBlendSpace1D) == 0x11609DB0, "Wrong size on UAimOffsetBlendSpace1D");

// Class Engine.DialogueVoice
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class UDialogueVoice final : public UObject
{
public:
	EGrammaticalGender                            Gender;                                            // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrammaticalNumber                            Plurality;                                         // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LocalizationGUID;                                  // 0x0044(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueVoice">();
	}
	static class UDialogueVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueVoice>();
	}
};
static_assert(alignof(UDialogueVoice) == 0x112E8D20, "Wrong alignment on UDialogueVoice");
static_assert(sizeof(UDialogueVoice) == 0x112E8D20, "Wrong size on UDialogueVoice");
static_assert(offsetof(UDialogueVoice, Gender) == 0x000040, "Member 'UDialogueVoice::Gender' has a wrong offset!");
static_assert(offsetof(UDialogueVoice, Plurality) == 0x000041, "Member 'UDialogueVoice::Plurality' has a wrong offset!");
static_assert(offsetof(UDialogueVoice, LocalizationGUID) == 0x000044, "Member 'UDialogueVoice::LocalizationGUID' has a wrong offset!");

// Class Engine.AmbientSound
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AAmbientSound final : public AActor
{
public:
	class UAudioComponent*                        AudioComponent;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel);
	void FadeIn(float FadeInDuration, float FadeVolumeLevel);
	void FadeOut(float FadeOutDuration, float FadeVolumeLevel);
	void Play(float StartTime);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmbientSound">();
	}
	static class AAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmbientSound>();
	}
};
static_assert(alignof(AAmbientSound) == 0x1EF72E00, "Wrong alignment on AAmbientSound");
static_assert(sizeof(AAmbientSound) == 0x1EF72E00, "Wrong size on AAmbientSound");
static_assert(offsetof(AAmbientSound, AudioComponent) == 0x0003E0, "Member 'AAmbientSound::AudioComponent' has a wrong offset!");

// Class Engine.AnimationSettings
// 0x0038 (0x0088 - 0x0050)
class UAnimationSettings final : public UDeveloperSettings
{
public:
	int32                                         CompressCommandletVersion;                         // 0x0050(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         KeyEndEffectorsMatchNameArray;                     // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimCompress>              DefaultCompressionAlgorithm;                       // 0x0068(0x0008)(Edit, ZeroConstructor, Config, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationCompressionFormat                   RotationCompressionFormat;                         // 0x0070(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimationCompressionFormat                   TranslationCompressionFormat;                      // 0x0071(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCurveError;                                     // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlternativeCompressionThreshold;                   // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceRecompression;                                // 0x007C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyCheckForMissingSkeletalMeshes;                // 0x007D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceBelowThreshold;                              // 0x007E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstRecompressUsingCurrentOrDefault;             // 0x007F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRaiseMaxErrorToExisting;                          // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryFixedBitwiseCompression;                       // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryPerTrackBitwiseCompression;                    // 0x0082(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryLinearKeyRemovalCompression;                   // 0x0083(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryIntervalKeyRemoval;                            // 0x0084(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePerformanceLog;                             // 0x0085(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStripAnimationDataOnDedicatedServer;              // 0x0086(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationSettings">();
	}
	static class UAnimationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationSettings>();
	}
};
static_assert(alignof(UAnimationSettings) == 0x000008, "Wrong alignment on UAnimationSettings");
static_assert(sizeof(UAnimationSettings) == 0x000088, "Wrong size on UAnimationSettings");
static_assert(offsetof(UAnimationSettings, CompressCommandletVersion) == 0x000050, "Member 'UAnimationSettings::CompressCommandletVersion' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, KeyEndEffectorsMatchNameArray) == 0x000058, "Member 'UAnimationSettings::KeyEndEffectorsMatchNameArray' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, DefaultCompressionAlgorithm) == 0x000068, "Member 'UAnimationSettings::DefaultCompressionAlgorithm' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, RotationCompressionFormat) == 0x000070, "Member 'UAnimationSettings::RotationCompressionFormat' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, TranslationCompressionFormat) == 0x000071, "Member 'UAnimationSettings::TranslationCompressionFormat' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, MaxCurveError) == 0x000074, "Member 'UAnimationSettings::MaxCurveError' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, AlternativeCompressionThreshold) == 0x000078, "Member 'UAnimationSettings::AlternativeCompressionThreshold' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, ForceRecompression) == 0x00007C, "Member 'UAnimationSettings::ForceRecompression' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bOnlyCheckForMissingSkeletalMeshes) == 0x00007D, "Member 'UAnimationSettings::bOnlyCheckForMissingSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bForceBelowThreshold) == 0x00007E, "Member 'UAnimationSettings::bForceBelowThreshold' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bFirstRecompressUsingCurrentOrDefault) == 0x00007F, "Member 'UAnimationSettings::bFirstRecompressUsingCurrentOrDefault' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bRaiseMaxErrorToExisting) == 0x000080, "Member 'UAnimationSettings::bRaiseMaxErrorToExisting' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bTryFixedBitwiseCompression) == 0x000081, "Member 'UAnimationSettings::bTryFixedBitwiseCompression' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bTryPerTrackBitwiseCompression) == 0x000082, "Member 'UAnimationSettings::bTryPerTrackBitwiseCompression' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bTryLinearKeyRemovalCompression) == 0x000083, "Member 'UAnimationSettings::bTryLinearKeyRemovalCompression' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bTryIntervalKeyRemoval) == 0x000084, "Member 'UAnimationSettings::bTryIntervalKeyRemoval' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bEnablePerformanceLog) == 0x000085, "Member 'UAnimationSettings::bEnablePerformanceLog' has a wrong offset!");
static_assert(offsetof(UAnimationSettings, bStripAnimationDataOnDedicatedServer) == 0x000086, "Member 'UAnimationSettings::bStripAnimationDataOnDedicatedServer' has a wrong offset!");

// Class Engine.ParticleModuleRotationRateMultiplyLife
// 0x0038 (0x0088 - 0x0050)
class UParticleModuleRotationRateMultiplyLife final : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionFloat                  LifeMultiplier;                                    // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotationRateMultiplyLife">();
	}
	static class UParticleModuleRotationRateMultiplyLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotationRateMultiplyLife>();
	}
};
static_assert(alignof(UParticleModuleRotationRateMultiplyLife) == 0x000008, "Wrong alignment on UParticleModuleRotationRateMultiplyLife");
static_assert(sizeof(UParticleModuleRotationRateMultiplyLife) == 0x000088, "Wrong size on UParticleModuleRotationRateMultiplyLife");
static_assert(offsetof(UParticleModuleRotationRateMultiplyLife, LifeMultiplier) == 0x000050, "Member 'UParticleModuleRotationRateMultiplyLife::LifeMultiplier' has a wrong offset!");

// Class Engine.AnimBlueprintGeneratedClass
// 0x0070 (0x03A0 - 0x0330)
class UAnimBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBakedAnimationStateMachine>    BakedStateMachines;                                // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class USkeleton*                              TargetSkeleton;                                    // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               AnimNotifies;                                      // 0x0350(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         RootAnimNodeIndex;                                 // 0x0360(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OrderedSavedPoseIndices;                           // 0x0368(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SyncGroupNames;                                    // 0x0390(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimBlueprintGeneratedClass">();
	}
	static class UAnimBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UAnimBlueprintGeneratedClass) == 0x000008, "Wrong alignment on UAnimBlueprintGeneratedClass");
static_assert(sizeof(UAnimBlueprintGeneratedClass) == 0x0003A0, "Wrong size on UAnimBlueprintGeneratedClass");
static_assert(offsetof(UAnimBlueprintGeneratedClass, BakedStateMachines) == 0x000338, "Member 'UAnimBlueprintGeneratedClass::BakedStateMachines' has a wrong offset!");
static_assert(offsetof(UAnimBlueprintGeneratedClass, TargetSkeleton) == 0x000348, "Member 'UAnimBlueprintGeneratedClass::TargetSkeleton' has a wrong offset!");
static_assert(offsetof(UAnimBlueprintGeneratedClass, AnimNotifies) == 0x000350, "Member 'UAnimBlueprintGeneratedClass::AnimNotifies' has a wrong offset!");
static_assert(offsetof(UAnimBlueprintGeneratedClass, RootAnimNodeIndex) == 0x000360, "Member 'UAnimBlueprintGeneratedClass::RootAnimNodeIndex' has a wrong offset!");
static_assert(offsetof(UAnimBlueprintGeneratedClass, OrderedSavedPoseIndices) == 0x000368, "Member 'UAnimBlueprintGeneratedClass::OrderedSavedPoseIndices' has a wrong offset!");
static_assert(offsetof(UAnimBlueprintGeneratedClass, SyncGroupNames) == 0x000390, "Member 'UAnimBlueprintGeneratedClass::SyncGroupNames' has a wrong offset!");

// Class Engine.MaterialExpressionDesaturation
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDesaturation final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Fraction;                                          // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FLinearColor                           LuminanceFactors;                                  // 0x00E8(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDesaturation">();
	}
	static class UMaterialExpressionDesaturation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDesaturation>();
	}
};
static_assert(alignof(UMaterialExpressionDesaturation) == 0x112F2730, "Wrong alignment on UMaterialExpressionDesaturation");
static_assert(sizeof(UMaterialExpressionDesaturation) == 0x112F2730, "Wrong size on UMaterialExpressionDesaturation");
static_assert(offsetof(UMaterialExpressionDesaturation, Input) == 0x000078, "Member 'UMaterialExpressionDesaturation::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDesaturation, Fraction) == 0x0000B0, "Member 'UMaterialExpressionDesaturation::Fraction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDesaturation, LuminanceFactors) == 0x0000E8, "Member 'UMaterialExpressionDesaturation::LuminanceFactors' has a wrong offset!");

// Class Engine.ParticleModuleTrailSource
// 0x0068 (0x00B8 - 0x0050)
class UParticleModuleTrailSource final : public UParticleModuleTrailBase
{
public:
	ETrail2SourceMethod                           SourceMethod;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SourceName;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SourceStrength;                                    // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLockSourceStength : 1;                            // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SourceOffsetCount;                                 // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SourceOffsetDefaults;                              // 0x00A0(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	EParticleSourceSelectionMethod                SelectionMethod;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInheritRotation : 1;                              // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTrailSource">();
	}
	static class UParticleModuleTrailSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTrailSource>();
	}
};
static_assert(alignof(UParticleModuleTrailSource) == 0x000008, "Wrong alignment on UParticleModuleTrailSource");
static_assert(sizeof(UParticleModuleTrailSource) == 0x0000B8, "Wrong size on UParticleModuleTrailSource");
static_assert(offsetof(UParticleModuleTrailSource, SourceMethod) == 0x000050, "Member 'UParticleModuleTrailSource::SourceMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleTrailSource, SourceName) == 0x000058, "Member 'UParticleModuleTrailSource::SourceName' has a wrong offset!");
static_assert(offsetof(UParticleModuleTrailSource, SourceStrength) == 0x000060, "Member 'UParticleModuleTrailSource::SourceStrength' has a wrong offset!");
static_assert(offsetof(UParticleModuleTrailSource, SourceOffsetCount) == 0x00009C, "Member 'UParticleModuleTrailSource::SourceOffsetCount' has a wrong offset!");
static_assert(offsetof(UParticleModuleTrailSource, SourceOffsetDefaults) == 0x0000A0, "Member 'UParticleModuleTrailSource::SourceOffsetDefaults' has a wrong offset!");
static_assert(offsetof(UParticleModuleTrailSource, SelectionMethod) == 0x0000B0, "Member 'UParticleModuleTrailSource::SelectionMethod' has a wrong offset!");

// Class Engine.AnimClassInterface
// 0x0000 (0x0040 - 0x0040)
class IAnimClassInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimClassInterface">();
	}
	static class IAnimClassInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimClassInterface>();
	}
};
static_assert(alignof(IAnimClassInterface) == 0x000008, "Wrong alignment on IAnimClassInterface");
static_assert(sizeof(IAnimClassInterface) == 0x000040, "Wrong size on IAnimClassInterface");

// Class Engine.AnimSequenceBase
// 0x0030 (0x00C0 - 0x0090)
class UAnimSequenceBase : public UAnimationAsset
{
public:
	TArray<struct FAnimNotifyEvent>               Notifies;                                          // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SequenceLength;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateScale;                                         // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawCurveTracks                        RawCurveData;                                      // 0x00A8(0x0010)(NativeAccessSpecifierPublic)
	float                                         M_InterpolationTime;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetPlayLength();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimSequenceBase">();
	}
	static class UAnimSequenceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimSequenceBase>();
	}
};
static_assert(alignof(UAnimSequenceBase) == 0x000008, "Wrong alignment on UAnimSequenceBase");
static_assert(sizeof(UAnimSequenceBase) == 0x0000C0, "Wrong size on UAnimSequenceBase");
static_assert(offsetof(UAnimSequenceBase, Notifies) == 0x000090, "Member 'UAnimSequenceBase::Notifies' has a wrong offset!");
static_assert(offsetof(UAnimSequenceBase, SequenceLength) == 0x0000A0, "Member 'UAnimSequenceBase::SequenceLength' has a wrong offset!");
static_assert(offsetof(UAnimSequenceBase, RateScale) == 0x0000A4, "Member 'UAnimSequenceBase::RateScale' has a wrong offset!");
static_assert(offsetof(UAnimSequenceBase, RawCurveData) == 0x0000A8, "Member 'UAnimSequenceBase::RawCurveData' has a wrong offset!");
static_assert(offsetof(UAnimSequenceBase, M_InterpolationTime) == 0x0000B8, "Member 'UAnimSequenceBase::M_InterpolationTime' has a wrong offset!");

// Class Engine.AnimCompositeBase
// 0x0000 (0x00C0 - 0x00C0)
class UAnimCompositeBase : public UAnimSequenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompositeBase">();
	}
	static class UAnimCompositeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompositeBase>();
	}
};
static_assert(alignof(UAnimCompositeBase) == 0x000008, "Wrong alignment on UAnimCompositeBase");
static_assert(sizeof(UAnimCompositeBase) == 0x0000C0, "Wrong size on UAnimCompositeBase");

// Class Engine.AnimComposite
// 0x0010 (0x00D0 - 0x00C0)
class UAnimComposite final : public UAnimCompositeBase
{
public:
	struct FAnimTrack                             AnimationTrack;                                    // 0x00C0(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComposite">();
	}
	static class UAnimComposite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComposite>();
	}
};
static_assert(alignof(UAnimComposite) == 0x000008, "Wrong alignment on UAnimComposite");
static_assert(sizeof(UAnimComposite) == 0x0000D0, "Wrong size on UAnimComposite");
static_assert(offsetof(UAnimComposite, AnimationTrack) == 0x0000C0, "Member 'UAnimComposite::AnimationTrack' has a wrong offset!");

// Class Engine.ParticleModuleParameterDynamic_Seeded
// 0x0020 (0x0088 - 0x0068)
class UParticleModuleParameterDynamic_Seeded final : public UParticleModuleParameterDynamic
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleParameterDynamic_Seeded">();
	}
	static class UParticleModuleParameterDynamic_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleParameterDynamic_Seeded>();
	}
};
static_assert(alignof(UParticleModuleParameterDynamic_Seeded) == 0x000008, "Wrong alignment on UParticleModuleParameterDynamic_Seeded");
static_assert(sizeof(UParticleModuleParameterDynamic_Seeded) == 0x000088, "Wrong size on UParticleModuleParameterDynamic_Seeded");
static_assert(offsetof(UParticleModuleParameterDynamic_Seeded, RandomSeedInfo) == 0x000068, "Member 'UParticleModuleParameterDynamic_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.AnimCompress_Automatic
// 0x0008 (0x0068 - 0x0060)
class UAnimCompress_Automatic final : public UAnimCompress
{
public:
	float                                         MaxEndEffectorError;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTryFixedBitwiseCompression : 1;                   // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTryPerTrackBitwiseCompression : 1;                // 0x0064(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTryLinearKeyRemovalCompression : 1;               // 0x0064(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTryIntervalKeyRemoval : 1;                        // 0x0064(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRunCurrentDefaultCompressor : 1;                  // 0x0064(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoReplaceIfExistingErrorTooGreat : 1;           // 0x0064(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRaiseMaxErrorToExisting : 1;                      // 0x0064(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_Automatic">();
	}
	static class UAnimCompress_Automatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_Automatic>();
	}
};
static_assert(alignof(UAnimCompress_Automatic) == 0x000008, "Wrong alignment on UAnimCompress_Automatic");
static_assert(sizeof(UAnimCompress_Automatic) == 0x000068, "Wrong size on UAnimCompress_Automatic");
static_assert(offsetof(UAnimCompress_Automatic, MaxEndEffectorError) == 0x000060, "Member 'UAnimCompress_Automatic::MaxEndEffectorError' has a wrong offset!");

// Class Engine.MaterialExpressionAdd
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionAdd final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAdd">();
	}
	static class UMaterialExpressionAdd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAdd>();
	}
};
static_assert(alignof(UMaterialExpressionAdd) == 0x112F2730, "Wrong alignment on UMaterialExpressionAdd");
static_assert(sizeof(UMaterialExpressionAdd) == 0x112F2730, "Wrong size on UMaterialExpressionAdd");
static_assert(offsetof(UMaterialExpressionAdd, A) == 0x000078, "Member 'UMaterialExpressionAdd::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAdd, B) == 0x0000B0, "Member 'UMaterialExpressionAdd::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAdd, ConstA) == 0x0000E8, "Member 'UMaterialExpressionAdd::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAdd, ConstB) == 0x0000EC, "Member 'UMaterialExpressionAdd::ConstB' has a wrong offset!");

// Class Engine.TextureLODSettings
// 0x0010 (0x0050 - 0x0040)
class UTextureLODSettings : public UObject
{
public:
	TArray<struct FTextureLODGroup>               TextureLODGroups;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureLODSettings">();
	}
	static class UTextureLODSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureLODSettings>();
	}
};
static_assert(alignof(UTextureLODSettings) == 0x000008, "Wrong alignment on UTextureLODSettings");
static_assert(sizeof(UTextureLODSettings) == 0x000050, "Wrong size on UTextureLODSettings");
static_assert(offsetof(UTextureLODSettings, TextureLODGroups) == 0x000040, "Member 'UTextureLODSettings::TextureLODGroups' has a wrong offset!");

// Class Engine.DeviceProfile
// 0x0090 (0x00E0 - 0x0050)
class UDeviceProfile final : public UTextureLODSettings
{
public:
	class FString                                 DeviceType;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, Config, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BaseProfileName;                                   // 0x0060(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Parent;                                            // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CVars;                                             // 0x0090(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x40];                                      // 0x00A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeviceProfile">();
	}
	static class UDeviceProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeviceProfile>();
	}
};
static_assert(alignof(UDeviceProfile) == 0x000008, "Wrong alignment on UDeviceProfile");
static_assert(sizeof(UDeviceProfile) == 0x0000E0, "Wrong size on UDeviceProfile");
static_assert(offsetof(UDeviceProfile, DeviceType) == 0x000050, "Member 'UDeviceProfile::DeviceType' has a wrong offset!");
static_assert(offsetof(UDeviceProfile, BaseProfileName) == 0x000060, "Member 'UDeviceProfile::BaseProfileName' has a wrong offset!");
static_assert(offsetof(UDeviceProfile, Parent) == 0x000070, "Member 'UDeviceProfile::Parent' has a wrong offset!");
static_assert(offsetof(UDeviceProfile, CVars) == 0x000090, "Member 'UDeviceProfile::CVars' has a wrong offset!");

// Class Engine.AnimCompress_LeastDestructive
// 0x0000 (0x0060 - 0x0060)
class UAnimCompress_LeastDestructive final : public UAnimCompress
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_LeastDestructive">();
	}
	static class UAnimCompress_LeastDestructive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_LeastDestructive>();
	}
};
static_assert(alignof(UAnimCompress_LeastDestructive) == 0x000008, "Wrong alignment on UAnimCompress_LeastDestructive");
static_assert(sizeof(UAnimCompress_LeastDestructive) == 0x000060, "Wrong size on UAnimCompress_LeastDestructive");

// Class Engine.AnimCompress_RemoveLinearKeys
// 0x0020 (0x0080 - 0x0060)
class UAnimCompress_RemoveLinearKeys : public UAnimCompress
{
public:
	float                                         MaxPosDiff;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDiff;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScaleDiff;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEffectorDiff;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinEffectorDiff;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectorDiffSocket;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentKeyScale;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRetarget : 1;                                     // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActuallyFilterLinearKeys : 1;                     // 0x007C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_RemoveLinearKeys">();
	}
	static class UAnimCompress_RemoveLinearKeys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_RemoveLinearKeys>();
	}
};
static_assert(alignof(UAnimCompress_RemoveLinearKeys) == 0x000008, "Wrong alignment on UAnimCompress_RemoveLinearKeys");
static_assert(sizeof(UAnimCompress_RemoveLinearKeys) == 0x000080, "Wrong size on UAnimCompress_RemoveLinearKeys");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, MaxPosDiff) == 0x000060, "Member 'UAnimCompress_RemoveLinearKeys::MaxPosDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, MaxAngleDiff) == 0x000064, "Member 'UAnimCompress_RemoveLinearKeys::MaxAngleDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, MaxScaleDiff) == 0x000068, "Member 'UAnimCompress_RemoveLinearKeys::MaxScaleDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, MaxEffectorDiff) == 0x00006C, "Member 'UAnimCompress_RemoveLinearKeys::MaxEffectorDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, MinEffectorDiff) == 0x000070, "Member 'UAnimCompress_RemoveLinearKeys::MinEffectorDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, EffectorDiffSocket) == 0x000074, "Member 'UAnimCompress_RemoveLinearKeys::EffectorDiffSocket' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveLinearKeys, ParentKeyScale) == 0x000078, "Member 'UAnimCompress_RemoveLinearKeys::ParentKeyScale' has a wrong offset!");

// Class Engine.AnimCompress_PerTrackCompression
// 0x0080 (0x0100 - 0x0080)
class UAnimCompress_PerTrackCompression final : public UAnimCompress_RemoveLinearKeys
{
public:
	float                                         MaxZeroingThreshold;                               // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPosDiffBitwise;                                 // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDiffBitwise;                               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScaleDiffBitwise;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAnimationCompressionFormat>           AllowedRotationFormats;                            // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAnimationCompressionFormat>           AllowedTranslationFormats;                         // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAnimationCompressionFormat>           AllowedScaleFormats;                               // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bResampleAnimation : 1;                            // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResampledFramerate;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinKeysForResampling;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAdaptiveError : 1;                             // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseOverrideForEndEffectors : 1;                   // 0x00CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TrackHeightBias;                                   // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentingDivisor;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentingDivisorExponent;                          // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAdaptiveError2 : 1;                            // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationErrorSourceRatio;                          // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationErrorSourceRatio;                       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleErrorSourceRatio;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxErrorPerTrackRatio;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerturbationProbeSize;                             // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_PerTrackCompression">();
	}
	static class UAnimCompress_PerTrackCompression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_PerTrackCompression>();
	}
};
static_assert(alignof(UAnimCompress_PerTrackCompression) == 0x000008, "Wrong alignment on UAnimCompress_PerTrackCompression");
static_assert(sizeof(UAnimCompress_PerTrackCompression) == 0x000100, "Wrong size on UAnimCompress_PerTrackCompression");
static_assert(offsetof(UAnimCompress_PerTrackCompression, MaxZeroingThreshold) == 0x000080, "Member 'UAnimCompress_PerTrackCompression::MaxZeroingThreshold' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, MaxPosDiffBitwise) == 0x000084, "Member 'UAnimCompress_PerTrackCompression::MaxPosDiffBitwise' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, MaxAngleDiffBitwise) == 0x000088, "Member 'UAnimCompress_PerTrackCompression::MaxAngleDiffBitwise' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, MaxScaleDiffBitwise) == 0x00008C, "Member 'UAnimCompress_PerTrackCompression::MaxScaleDiffBitwise' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, AllowedRotationFormats) == 0x000090, "Member 'UAnimCompress_PerTrackCompression::AllowedRotationFormats' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, AllowedTranslationFormats) == 0x0000A0, "Member 'UAnimCompress_PerTrackCompression::AllowedTranslationFormats' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, AllowedScaleFormats) == 0x0000B0, "Member 'UAnimCompress_PerTrackCompression::AllowedScaleFormats' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, ResampledFramerate) == 0x0000C4, "Member 'UAnimCompress_PerTrackCompression::ResampledFramerate' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, MinKeysForResampling) == 0x0000C8, "Member 'UAnimCompress_PerTrackCompression::MinKeysForResampling' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, TrackHeightBias) == 0x0000D0, "Member 'UAnimCompress_PerTrackCompression::TrackHeightBias' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, ParentingDivisor) == 0x0000D4, "Member 'UAnimCompress_PerTrackCompression::ParentingDivisor' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, ParentingDivisorExponent) == 0x0000D8, "Member 'UAnimCompress_PerTrackCompression::ParentingDivisorExponent' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, RotationErrorSourceRatio) == 0x0000E0, "Member 'UAnimCompress_PerTrackCompression::RotationErrorSourceRatio' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, TranslationErrorSourceRatio) == 0x0000E4, "Member 'UAnimCompress_PerTrackCompression::TranslationErrorSourceRatio' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, ScaleErrorSourceRatio) == 0x0000E8, "Member 'UAnimCompress_PerTrackCompression::ScaleErrorSourceRatio' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, MaxErrorPerTrackRatio) == 0x0000EC, "Member 'UAnimCompress_PerTrackCompression::MaxErrorPerTrackRatio' has a wrong offset!");
static_assert(offsetof(UAnimCompress_PerTrackCompression, PerturbationProbeSize) == 0x0000F0, "Member 'UAnimCompress_PerTrackCompression::PerturbationProbeSize' has a wrong offset!");

// Class Engine.MaterialExpressionLightmassReplace
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionLightmassReplace final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Realtime;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Lightmass;                                         // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLightmassReplace">();
	}
	static class UMaterialExpressionLightmassReplace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLightmassReplace>();
	}
};
static_assert(alignof(UMaterialExpressionLightmassReplace) == 0x112F2730, "Wrong alignment on UMaterialExpressionLightmassReplace");
static_assert(sizeof(UMaterialExpressionLightmassReplace) == 0x112F2730, "Wrong size on UMaterialExpressionLightmassReplace");
static_assert(offsetof(UMaterialExpressionLightmassReplace, Realtime) == 0x000078, "Member 'UMaterialExpressionLightmassReplace::Realtime' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLightmassReplace, Lightmass) == 0x0000B0, "Member 'UMaterialExpressionLightmassReplace::Lightmass' has a wrong offset!");

// Class Engine.AnimCompress_RemoveEverySecondKey
// 0x0008 (0x0068 - 0x0060)
class UAnimCompress_RemoveEverySecondKey final : public UAnimCompress
{
public:
	int32                                         MinKeys;                                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bStartAtSecondKey : 1;                             // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_RemoveEverySecondKey">();
	}
	static class UAnimCompress_RemoveEverySecondKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_RemoveEverySecondKey>();
	}
};
static_assert(alignof(UAnimCompress_RemoveEverySecondKey) == 0x000008, "Wrong alignment on UAnimCompress_RemoveEverySecondKey");
static_assert(sizeof(UAnimCompress_RemoveEverySecondKey) == 0x000068, "Wrong size on UAnimCompress_RemoveEverySecondKey");
static_assert(offsetof(UAnimCompress_RemoveEverySecondKey, MinKeys) == 0x000060, "Member 'UAnimCompress_RemoveEverySecondKey::MinKeys' has a wrong offset!");

// Class Engine.PlatformEventsComponent
// 0x0000 (0xD38D - 0xD38D)
class UPlatformEventsComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   PlatformChangedToLaptopModeDelegate;               // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   PlatformChangedToTabletModeDelegate;               // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsInLaptopMode();
	bool IsInTabletMode();
	void PlatformEventDelegate__DelegateSignature();
	bool SupportsConvertibleLaptops();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformEventsComponent">();
	}
	static class UPlatformEventsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformEventsComponent>();
	}
};
static_assert(alignof(UPlatformEventsComponent) == 0x00D38D, "Wrong alignment on UPlatformEventsComponent");
static_assert(sizeof(UPlatformEventsComponent) == 0x00D38D, "Wrong size on UPlatformEventsComponent");
static_assert(offsetof(UPlatformEventsComponent, PlatformChangedToLaptopModeDelegate) == 0x000200, "Member 'UPlatformEventsComponent::PlatformChangedToLaptopModeDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformEventsComponent, PlatformChangedToTabletModeDelegate) == 0x000210, "Member 'UPlatformEventsComponent::PlatformChangedToTabletModeDelegate' has a wrong offset!");

// Class Engine.AnimCompress_RemoveTrivialKeys
// 0x0010 (0x0070 - 0x0060)
class UAnimCompress_RemoveTrivialKeys final : public UAnimCompress
{
public:
	float                                         MaxPosDiff;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDiff;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScaleDiff;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCompress_RemoveTrivialKeys">();
	}
	static class UAnimCompress_RemoveTrivialKeys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCompress_RemoveTrivialKeys>();
	}
};
static_assert(alignof(UAnimCompress_RemoveTrivialKeys) == 0x000008, "Wrong alignment on UAnimCompress_RemoveTrivialKeys");
static_assert(sizeof(UAnimCompress_RemoveTrivialKeys) == 0x000070, "Wrong size on UAnimCompress_RemoveTrivialKeys");
static_assert(offsetof(UAnimCompress_RemoveTrivialKeys, MaxPosDiff) == 0x000060, "Member 'UAnimCompress_RemoveTrivialKeys::MaxPosDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveTrivialKeys, MaxAngleDiff) == 0x000064, "Member 'UAnimCompress_RemoveTrivialKeys::MaxAngleDiff' has a wrong offset!");
static_assert(offsetof(UAnimCompress_RemoveTrivialKeys, MaxScaleDiff) == 0x000068, "Member 'UAnimCompress_RemoveTrivialKeys::MaxScaleDiff' has a wrong offset!");

// Class Engine.AnimMontage
// 0x11543220 (0x115432E0 - 0x00C0)
class UAnimMontage final : public UAnimCompositeBase
{
public:
	struct FAlphaBlend                            BlendIn;                                           // 0x00C0(0x115432E0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00F8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            BlendOut;                                          // 0x0100(0x115432E0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0138(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SyncGroup;                                         // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SyncSlotIndex;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMarkerSyncData                        MarkerData;                                        // 0x0150(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FCompositeSection>              CompositeSections;                                 // 0x0170(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSlotAnimationTrack>            SlotAnimTracks;                                    // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBranchingPoint>                BranchingPoints;                                   // 0x0190(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	bool                                          bEnableRootMotionTranslation;                      // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRootMotionRotation;                         // 0x01A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionRootLock                           RootMotionRootLock;                                // 0x01A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A3[0x5];                                      // 0x01A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBranchingPointMarker>          BranchingPointMarkers;                             // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 BranchingPointStateNotifyIndices;                  // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimMontage">();
	}
	static class UAnimMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimMontage>();
	}
};
static_assert(alignof(UAnimMontage) == 0x115432E0, "Wrong alignment on UAnimMontage");
static_assert(sizeof(UAnimMontage) == 0x115432E0, "Wrong size on UAnimMontage");
static_assert(offsetof(UAnimMontage, BlendIn) == 0x0000C0, "Member 'UAnimMontage::BlendIn' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BlendInTime) == 0x0000F8, "Member 'UAnimMontage::BlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BlendOut) == 0x000100, "Member 'UAnimMontage::BlendOut' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BlendOutTime) == 0x000138, "Member 'UAnimMontage::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BlendOutTriggerTime) == 0x00013C, "Member 'UAnimMontage::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(UAnimMontage, SyncGroup) == 0x000140, "Member 'UAnimMontage::SyncGroup' has a wrong offset!");
static_assert(offsetof(UAnimMontage, SyncSlotIndex) == 0x000148, "Member 'UAnimMontage::SyncSlotIndex' has a wrong offset!");
static_assert(offsetof(UAnimMontage, MarkerData) == 0x000150, "Member 'UAnimMontage::MarkerData' has a wrong offset!");
static_assert(offsetof(UAnimMontage, CompositeSections) == 0x000170, "Member 'UAnimMontage::CompositeSections' has a wrong offset!");
static_assert(offsetof(UAnimMontage, SlotAnimTracks) == 0x000180, "Member 'UAnimMontage::SlotAnimTracks' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BranchingPoints) == 0x000190, "Member 'UAnimMontage::BranchingPoints' has a wrong offset!");
static_assert(offsetof(UAnimMontage, bEnableRootMotionTranslation) == 0x0001A0, "Member 'UAnimMontage::bEnableRootMotionTranslation' has a wrong offset!");
static_assert(offsetof(UAnimMontage, bEnableRootMotionRotation) == 0x0001A1, "Member 'UAnimMontage::bEnableRootMotionRotation' has a wrong offset!");
static_assert(offsetof(UAnimMontage, RootMotionRootLock) == 0x0001A2, "Member 'UAnimMontage::RootMotionRootLock' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BranchingPointMarkers) == 0x0001A8, "Member 'UAnimMontage::BranchingPointMarkers' has a wrong offset!");
static_assert(offsetof(UAnimMontage, BranchingPointStateNotifyIndices) == 0x0001B8, "Member 'UAnimMontage::BranchingPointStateNotifyIndices' has a wrong offset!");

// Class Engine.MaterialExpressionViewProperty
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionViewProperty final : public UMaterialExpression
{
public:
	EMaterialExposedViewProperty                  Property;                                          // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionViewProperty">();
	}
	static class UMaterialExpressionViewProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionViewProperty>();
	}
};
static_assert(alignof(UMaterialExpressionViewProperty) == 0x000008, "Wrong alignment on UMaterialExpressionViewProperty");
static_assert(sizeof(UMaterialExpressionViewProperty) == 0x000080, "Wrong size on UMaterialExpressionViewProperty");
static_assert(offsetof(UMaterialExpressionViewProperty, Property) == 0x000078, "Member 'UMaterialExpressionViewProperty::Property' has a wrong offset!");

// Class Engine.AnimNotify_PlayParticleEffect
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UAnimNotify_PlayParticleEffect final : public UAnimNotify
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0064(0x112E9AF0)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Attached : 1;                                      // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayParticleEffect">();
	}
	static class UAnimNotify_PlayParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayParticleEffect>();
	}
};
static_assert(alignof(UAnimNotify_PlayParticleEffect) == 0x112E9AF0, "Wrong alignment on UAnimNotify_PlayParticleEffect");
static_assert(sizeof(UAnimNotify_PlayParticleEffect) == 0x112E9AF0, "Wrong size on UAnimNotify_PlayParticleEffect");
static_assert(offsetof(UAnimNotify_PlayParticleEffect, PSTemplate) == 0x000050, "Member 'UAnimNotify_PlayParticleEffect::PSTemplate' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayParticleEffect, LocationOffset) == 0x000058, "Member 'UAnimNotify_PlayParticleEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayParticleEffect, RotationOffset) == 0x000064, "Member 'UAnimNotify_PlayParticleEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayParticleEffect, SocketName) == 0x000088, "Member 'UAnimNotify_PlayParticleEffect::SocketName' has a wrong offset!");

// Class Engine.AnimNotify_PlaySound
// 0x0020 (0x0070 - 0x0050)
class UAnimNotify_PlaySound final : public UAnimNotify
{
public:
	class USoundBase*                             Sound;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachName;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlaySound">();
	}
	static class UAnimNotify_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlaySound>();
	}
};
static_assert(alignof(UAnimNotify_PlaySound) == 0x000008, "Wrong alignment on UAnimNotify_PlaySound");
static_assert(sizeof(UAnimNotify_PlaySound) == 0x000070, "Wrong size on UAnimNotify_PlaySound");
static_assert(offsetof(UAnimNotify_PlaySound, Sound) == 0x000050, "Member 'UAnimNotify_PlaySound::Sound' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySound, VolumeMultiplier) == 0x000058, "Member 'UAnimNotify_PlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySound, PitchMultiplier) == 0x00005C, "Member 'UAnimNotify_PlaySound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySound, AttachName) == 0x000068, "Member 'UAnimNotify_PlaySound::AttachName' has a wrong offset!");

// Class Engine.AnimNotify_ResetClothingSimulation
// 0x0000 (0x0050 - 0x0050)
class UAnimNotify_ResetClothingSimulation final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ResetClothingSimulation">();
	}
	static class UAnimNotify_ResetClothingSimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ResetClothingSimulation>();
	}
};
static_assert(alignof(UAnimNotify_ResetClothingSimulation) == 0x000008, "Wrong alignment on UAnimNotify_ResetClothingSimulation");
static_assert(sizeof(UAnimNotify_ResetClothingSimulation) == 0x000050, "Wrong size on UAnimNotify_ResetClothingSimulation");

// Class Engine.NavMeshRenderingComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UNavMeshRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshRenderingComponent">();
	}
	static class UNavMeshRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMeshRenderingComponent>();
	}
};
static_assert(alignof(UNavMeshRenderingComponent) == 0x112E9AF0, "Wrong alignment on UNavMeshRenderingComponent");
static_assert(sizeof(UNavMeshRenderingComponent) == 0x112E9AF0, "Wrong size on UNavMeshRenderingComponent");

// Class Engine.AnimNotifyState_DisableRootMotion
// 0x0000 (0x0048 - 0x0048)
class UAnimNotifyState_DisableRootMotion final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableRootMotion">();
	}
	static class UAnimNotifyState_DisableRootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableRootMotion>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableRootMotion) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableRootMotion");
static_assert(sizeof(UAnimNotifyState_DisableRootMotion) == 0x000048, "Wrong size on UAnimNotifyState_DisableRootMotion");

// Class Engine.AnimNotifyState_TimedParticleEffect
// 0x112E9AA8 (0x112E9AF0 - 0x0048)
class UAnimNotifyState_TimedParticleEffect final : public UAnimNotifyState
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0058(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0064(0x112E9AF0)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TimedParticleEffect">();
	}
	static class UAnimNotifyState_TimedParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TimedParticleEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_TimedParticleEffect) == 0x112E9AF0, "Wrong alignment on UAnimNotifyState_TimedParticleEffect");
static_assert(sizeof(UAnimNotifyState_TimedParticleEffect) == 0x112E9AF0, "Wrong size on UAnimNotifyState_TimedParticleEffect");
static_assert(offsetof(UAnimNotifyState_TimedParticleEffect, PSTemplate) == 0x000048, "Member 'UAnimNotifyState_TimedParticleEffect::PSTemplate' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedParticleEffect, SocketName) == 0x000050, "Member 'UAnimNotifyState_TimedParticleEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedParticleEffect, LocationOffset) == 0x000058, "Member 'UAnimNotifyState_TimedParticleEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedParticleEffect, RotationOffset) == 0x000064, "Member 'UAnimNotifyState_TimedParticleEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimedParticleEffect, bDestroyAtEnd) == 0x000070, "Member 'UAnimNotifyState_TimedParticleEffect::bDestroyAtEnd' has a wrong offset!");

// Class Engine.AnimNotifyState_Trail
// 0x0030 (0x0078 - 0x0048)
class UAnimNotifyState_Trail final : public UAnimNotifyState
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstSocketName;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidthScaleCurve;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecycleSpawnedSystems : 1;                        // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UParticleSystem* OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_Trail">();
	}
	static class UAnimNotifyState_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_Trail>();
	}
};
static_assert(alignof(UAnimNotifyState_Trail) == 0x000008, "Wrong alignment on UAnimNotifyState_Trail");
static_assert(sizeof(UAnimNotifyState_Trail) == 0x000078, "Wrong size on UAnimNotifyState_Trail");
static_assert(offsetof(UAnimNotifyState_Trail, PSTemplate) == 0x000048, "Member 'UAnimNotifyState_Trail::PSTemplate' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Trail, FirstSocketName) == 0x000050, "Member 'UAnimNotifyState_Trail::FirstSocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Trail, SecondSocketName) == 0x000058, "Member 'UAnimNotifyState_Trail::SecondSocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Trail, WidthScaleMode) == 0x000060, "Member 'UAnimNotifyState_Trail::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Trail, WidthScaleCurve) == 0x000068, "Member 'UAnimNotifyState_Trail::WidthScaleCurve' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataMesh
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_MESH_PAR_BILLBORAD_TYPE                 SQEXBillboardType;                                 // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SQEXBillboardRotaionOffset;                        // 0x005C(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUseSQEXBillboradRotaionAxis : 1;                  // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSQEXBillboradInitMeshRotToTangent : 1;         // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSubMeshs : 1;                                  // 0x0068(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEmitterTime : 1;                               // 0x0068(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseRandomStart : 1;                               // 0x0068(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoLoop : 1;                                       // 0x0068(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    SubMeshs;                                          // 0x0070(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_MeshMeshListData>         SubMeshLists;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MeshIndexIntervalTime;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SubMeshsIndex;                                     // 0x0098(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESQEX_MeshSetIndexType                        MesSetIndexType;                                   // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSubMeshsSetUseEmitterTime : 1;                    // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SubMeshsSetIndex;                                  // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         CastShadows : 1;                                   // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_TAILPOL_UV_ROT_TYPE                     UVType;                                            // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTexUReverse : 1;                                  // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTexVReverse : 1;                                  // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DoCollisions : 1;                                  // 0x0118(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMeshScreenAlignment                          MeshAlignment;                                     // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideMaterial : 1;                             // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDefaultMotionBlurSettings : 1;            // 0x0120(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMotionBlur : 1;                             // 0x0120(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Pitch;                                             // 0x0124(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0128(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x012C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 RollPitchYawRange;                                 // 0x0130(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_CalcScaleType                           CalcParticleSizeType;                              // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_CalcScaleType                           CalcComponentScaleType;                            // 0x0189(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_CalcScaleType                           CalcParentScaleType;                               // 0x018A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleAxisLock                             AxisLockOption;                                    // 0x018B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCameraFacing : 1;                                 // 0x018C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMeshCameraFacingUpAxis                       CameraFacingUpAxisOption;                          // 0x0190(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshCameraFacingOptions                      CameraFacingOption;                                // 0x0191(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x2];                                      // 0x0192(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCorrectMeshRotation : 1;                          // 0x0194(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoWorldRotation : 1;                              // 0x0194(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoLocalRotation : 1;                              // 0x0194(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInitMeshRotToTangent : 1;                      // 0x0194(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BillboardRotaionOffset;                            // 0x0198(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bNoCameraHeadUp : 1;                               // 0x01A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyParticleRotationAsSpin : 1;                  // 0x01A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFaceCameraDirectionRatherThanPosition : 1;        // 0x01A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseExtensionMesh : 1;                             // 0x01A4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExtensionMeshKey;                                  // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCollisionsConsiderPartilceSize : 1;               // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataMesh">();
	}
	static class UParticleModuleTypeDataMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataMesh>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleTypeDataMesh) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataMesh");
static_assert(sizeof(UParticleModuleTypeDataMesh) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataMesh");
static_assert(offsetof(UParticleModuleTypeDataMesh, Mesh) == 0x000050, "Member 'UParticleModuleTypeDataMesh::Mesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, SQEXBillboardType) == 0x000058, "Member 'UParticleModuleTypeDataMesh::SQEXBillboardType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, SQEXBillboardRotaionOffset) == 0x00005C, "Member 'UParticleModuleTypeDataMesh::SQEXBillboardRotaionOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, SubMeshs) == 0x000070, "Member 'UParticleModuleTypeDataMesh::SubMeshs' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, SubMeshLists) == 0x000080, "Member 'UParticleModuleTypeDataMesh::SubMeshLists' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, MeshIndexIntervalTime) == 0x000090, "Member 'UParticleModuleTypeDataMesh::MeshIndexIntervalTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, SubMeshsIndex) == 0x000098, "Member 'UParticleModuleTypeDataMesh::SubMeshsIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, MesSetIndexType) == 0x0000D0, "Member 'UParticleModuleTypeDataMesh::MesSetIndexType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, SubMeshsSetIndex) == 0x0000D8, "Member 'UParticleModuleTypeDataMesh::SubMeshsSetIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, UVType) == 0x000114, "Member 'UParticleModuleTypeDataMesh::UVType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, MeshAlignment) == 0x00011C, "Member 'UParticleModuleTypeDataMesh::MeshAlignment' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, Pitch) == 0x000124, "Member 'UParticleModuleTypeDataMesh::Pitch' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, Roll) == 0x000128, "Member 'UParticleModuleTypeDataMesh::Roll' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, Yaw) == 0x00012C, "Member 'UParticleModuleTypeDataMesh::Yaw' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, RollPitchYawRange) == 0x000130, "Member 'UParticleModuleTypeDataMesh::RollPitchYawRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, CalcParticleSizeType) == 0x000188, "Member 'UParticleModuleTypeDataMesh::CalcParticleSizeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, CalcComponentScaleType) == 0x000189, "Member 'UParticleModuleTypeDataMesh::CalcComponentScaleType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, CalcParentScaleType) == 0x00018A, "Member 'UParticleModuleTypeDataMesh::CalcParentScaleType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, AxisLockOption) == 0x00018B, "Member 'UParticleModuleTypeDataMesh::AxisLockOption' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, CameraFacingUpAxisOption) == 0x000190, "Member 'UParticleModuleTypeDataMesh::CameraFacingUpAxisOption' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, CameraFacingOption) == 0x000191, "Member 'UParticleModuleTypeDataMesh::CameraFacingOption' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, BillboardRotaionOffset) == 0x000198, "Member 'UParticleModuleTypeDataMesh::BillboardRotaionOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataMesh, ExtensionMeshKey) == 0x0001A8, "Member 'UParticleModuleTypeDataMesh::ExtensionMeshKey' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_DevilWave
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_DevilWave final : public UParticleModuleTypeDataMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_DevilWave">();
	}
	static class UParticleModuleTypeDataSQEX_DevilWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_DevilWave>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_DevilWave) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_DevilWave");
static_assert(sizeof(UParticleModuleTypeDataSQEX_DevilWave) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_DevilWave");

// Class Engine.DefaultPawn
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADefaultPawn : public APawn
{
public:
	float                                         BaseTurnRate;                                      // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPawnMovementComponent*                 MovementComponent;                                 // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       CollisionComponent;                                // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAddDefaultMovementBindings : 1;                   // 0x0460(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookUpAtRate(float Rate);
	void MoveForward(float Val);
	void MoveRight(float Val);
	void MoveUp_World(float Val);
	void TurnAtRate(float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultPawn">();
	}
	static class ADefaultPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefaultPawn>();
	}
};
static_assert(alignof(ADefaultPawn) == 0x1EF72E00, "Wrong alignment on ADefaultPawn");
static_assert(sizeof(ADefaultPawn) == 0x1EF72E00, "Wrong size on ADefaultPawn");
static_assert(offsetof(ADefaultPawn, BaseTurnRate) == 0x000440, "Member 'ADefaultPawn::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ADefaultPawn, BaseLookUpRate) == 0x000444, "Member 'ADefaultPawn::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ADefaultPawn, MovementComponent) == 0x000448, "Member 'ADefaultPawn::MovementComponent' has a wrong offset!");
static_assert(offsetof(ADefaultPawn, CollisionComponent) == 0x000450, "Member 'ADefaultPawn::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ADefaultPawn, MeshComponent) == 0x000458, "Member 'ADefaultPawn::MeshComponent' has a wrong offset!");

// Class Engine.SpectatorPawn
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASpectatorPawn final : public ADefaultPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorPawn">();
	}
	static class ASpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectatorPawn>();
	}
};
static_assert(alignof(ASpectatorPawn) == 0x1EF72E00, "Wrong alignment on ASpectatorPawn");
static_assert(sizeof(ASpectatorPawn) == 0x1EF72E00, "Wrong size on ASpectatorPawn");

// Class Engine.AnimSequence
// 0x00F8 (0x01B8 - 0x00C0)
class UAnimSequence final : public UAnimSequenceBase
{
public:
	int32                                         NumFrames;                                         // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTrackToSkeletonMap>            TrackToSkeletonMapTable;                           // 0x00C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x94];                                      // 0x00D8(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	EAdditiveAnimationType                        AdditiveAnimType;                                  // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAdditiveBasePoseType                         RefPoseType;                                       // 0x016D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E[0x2];                                      // 0x016E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          RefPoseSeq;                                        // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RefFrameIndex;                                     // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EncodingPkgVersion;                                // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RetargetSource;                                    // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimInterpolationType                        Interpolation;                                     // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRootMotion;                                 // 0x0189(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionRootLock                           RootMotionRootLock;                                // 0x018A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRootLock;                                    // 0x018B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootMotionSettingsCopiedFromMontage;              // 0x018C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DisableInterpolation;                            // 0x018D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimSyncMarker>                AuthoredSyncMarkers;                               // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x18];                                     // 0x01A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimSequence">();
	}
	static class UAnimSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimSequence>();
	}
};
static_assert(alignof(UAnimSequence) == 0x000008, "Wrong alignment on UAnimSequence");
static_assert(sizeof(UAnimSequence) == 0x0001B8, "Wrong size on UAnimSequence");
static_assert(offsetof(UAnimSequence, NumFrames) == 0x0000C0, "Member 'UAnimSequence::NumFrames' has a wrong offset!");
static_assert(offsetof(UAnimSequence, TrackToSkeletonMapTable) == 0x0000C8, "Member 'UAnimSequence::TrackToSkeletonMapTable' has a wrong offset!");
static_assert(offsetof(UAnimSequence, AdditiveAnimType) == 0x00016C, "Member 'UAnimSequence::AdditiveAnimType' has a wrong offset!");
static_assert(offsetof(UAnimSequence, RefPoseType) == 0x00016D, "Member 'UAnimSequence::RefPoseType' has a wrong offset!");
static_assert(offsetof(UAnimSequence, RefPoseSeq) == 0x000170, "Member 'UAnimSequence::RefPoseSeq' has a wrong offset!");
static_assert(offsetof(UAnimSequence, RefFrameIndex) == 0x000178, "Member 'UAnimSequence::RefFrameIndex' has a wrong offset!");
static_assert(offsetof(UAnimSequence, EncodingPkgVersion) == 0x00017C, "Member 'UAnimSequence::EncodingPkgVersion' has a wrong offset!");
static_assert(offsetof(UAnimSequence, RetargetSource) == 0x000180, "Member 'UAnimSequence::RetargetSource' has a wrong offset!");
static_assert(offsetof(UAnimSequence, Interpolation) == 0x000188, "Member 'UAnimSequence::Interpolation' has a wrong offset!");
static_assert(offsetof(UAnimSequence, bEnableRootMotion) == 0x000189, "Member 'UAnimSequence::bEnableRootMotion' has a wrong offset!");
static_assert(offsetof(UAnimSequence, RootMotionRootLock) == 0x00018A, "Member 'UAnimSequence::RootMotionRootLock' has a wrong offset!");
static_assert(offsetof(UAnimSequence, bForceRootLock) == 0x00018B, "Member 'UAnimSequence::bForceRootLock' has a wrong offset!");
static_assert(offsetof(UAnimSequence, bRootMotionSettingsCopiedFromMontage) == 0x00018C, "Member 'UAnimSequence::bRootMotionSettingsCopiedFromMontage' has a wrong offset!");
static_assert(offsetof(UAnimSequence, M_DisableInterpolation) == 0x00018D, "Member 'UAnimSequence::M_DisableInterpolation' has a wrong offset!");
static_assert(offsetof(UAnimSequence, AuthoredSyncMarkers) == 0x000190, "Member 'UAnimSequence::AuthoredSyncMarkers' has a wrong offset!");

// Class Engine.AnimSet
// 0x00C8 (0x0108 - 0x0040)
class UAnimSet final : public UObject
{
public:
	uint8                                         bAnimRotationOnly : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TrackBoneNames;                                    // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimSetMeshLinkup>             LinkupCache;                                       // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 BoneUseAnimTranslation;                            // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 ForceUseMeshTranslation;                           // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class FName>                           UseTranslationBoneNames;                           // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ForceMeshTranslationBoneNames;                     // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   PreviewSkelMeshName;                               // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BestRatioSkelMeshName;                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimSet">();
	}
	static class UAnimSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimSet>();
	}
};
static_assert(alignof(UAnimSet) == 0x000008, "Wrong alignment on UAnimSet");
static_assert(sizeof(UAnimSet) == 0x000108, "Wrong size on UAnimSet");
static_assert(offsetof(UAnimSet, TrackBoneNames) == 0x000048, "Member 'UAnimSet::TrackBoneNames' has a wrong offset!");
static_assert(offsetof(UAnimSet, LinkupCache) == 0x000058, "Member 'UAnimSet::LinkupCache' has a wrong offset!");
static_assert(offsetof(UAnimSet, BoneUseAnimTranslation) == 0x000068, "Member 'UAnimSet::BoneUseAnimTranslation' has a wrong offset!");
static_assert(offsetof(UAnimSet, ForceUseMeshTranslation) == 0x000078, "Member 'UAnimSet::ForceUseMeshTranslation' has a wrong offset!");
static_assert(offsetof(UAnimSet, UseTranslationBoneNames) == 0x000088, "Member 'UAnimSet::UseTranslationBoneNames' has a wrong offset!");
static_assert(offsetof(UAnimSet, ForceMeshTranslationBoneNames) == 0x000098, "Member 'UAnimSet::ForceMeshTranslationBoneNames' has a wrong offset!");
static_assert(offsetof(UAnimSet, PreviewSkelMeshName) == 0x0000A8, "Member 'UAnimSet::PreviewSkelMeshName' has a wrong offset!");
static_assert(offsetof(UAnimSet, BestRatioSkelMeshName) == 0x0000B0, "Member 'UAnimSet::BestRatioSkelMeshName' has a wrong offset!");

// Class Engine.NavAreaMeta
// 0x0000 (0x0058 - 0x0058)
class UNavAreaMeta : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavAreaMeta">();
	}
	static class UNavAreaMeta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavAreaMeta>();
	}
};
static_assert(alignof(UNavAreaMeta) == 0x000008, "Wrong alignment on UNavAreaMeta");
static_assert(sizeof(UNavAreaMeta) == 0x000058, "Wrong size on UNavAreaMeta");

// Class Engine.NavAreaMeta_SwitchByAgent
// 0x0080 (0x00D8 - 0x0058)
class UNavAreaMeta_SwitchByAgent final : public UNavAreaMeta
{
public:
	TSubclassOf<class UNavArea>                   Agent0Area;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent1Area;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent2Area;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent3Area;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent4Area;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent5Area;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent6Area;                                        // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent7Area;                                        // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent8Area;                                        // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent9Area;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent10Area;                                       // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent11Area;                                       // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent12Area;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent13Area;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent14Area;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   Agent15Area;                                       // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavAreaMeta_SwitchByAgent">();
	}
	static class UNavAreaMeta_SwitchByAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavAreaMeta_SwitchByAgent>();
	}
};
static_assert(alignof(UNavAreaMeta_SwitchByAgent) == 0x000008, "Wrong alignment on UNavAreaMeta_SwitchByAgent");
static_assert(sizeof(UNavAreaMeta_SwitchByAgent) == 0x0000D8, "Wrong size on UNavAreaMeta_SwitchByAgent");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent0Area) == 0x000058, "Member 'UNavAreaMeta_SwitchByAgent::Agent0Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent1Area) == 0x000060, "Member 'UNavAreaMeta_SwitchByAgent::Agent1Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent2Area) == 0x000068, "Member 'UNavAreaMeta_SwitchByAgent::Agent2Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent3Area) == 0x000070, "Member 'UNavAreaMeta_SwitchByAgent::Agent3Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent4Area) == 0x000078, "Member 'UNavAreaMeta_SwitchByAgent::Agent4Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent5Area) == 0x000080, "Member 'UNavAreaMeta_SwitchByAgent::Agent5Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent6Area) == 0x000088, "Member 'UNavAreaMeta_SwitchByAgent::Agent6Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent7Area) == 0x000090, "Member 'UNavAreaMeta_SwitchByAgent::Agent7Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent8Area) == 0x000098, "Member 'UNavAreaMeta_SwitchByAgent::Agent8Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent9Area) == 0x0000A0, "Member 'UNavAreaMeta_SwitchByAgent::Agent9Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent10Area) == 0x0000A8, "Member 'UNavAreaMeta_SwitchByAgent::Agent10Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent11Area) == 0x0000B0, "Member 'UNavAreaMeta_SwitchByAgent::Agent11Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent12Area) == 0x0000B8, "Member 'UNavAreaMeta_SwitchByAgent::Agent12Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent13Area) == 0x0000C0, "Member 'UNavAreaMeta_SwitchByAgent::Agent13Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent14Area) == 0x0000C8, "Member 'UNavAreaMeta_SwitchByAgent::Agent14Area' has a wrong offset!");
static_assert(offsetof(UNavAreaMeta_SwitchByAgent, Agent15Area) == 0x0000D0, "Member 'UNavAreaMeta_SwitchByAgent::Agent15Area' has a wrong offset!");

// Class Engine.MaterialExpressionConstant2Vector
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionConstant2Vector final : public UMaterialExpression
{
public:
	float                                         R;                                                 // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionConstant2Vector">();
	}
	static class UMaterialExpressionConstant2Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionConstant2Vector>();
	}
};
static_assert(alignof(UMaterialExpressionConstant2Vector) == 0x000008, "Wrong alignment on UMaterialExpressionConstant2Vector");
static_assert(sizeof(UMaterialExpressionConstant2Vector) == 0x000080, "Wrong size on UMaterialExpressionConstant2Vector");
static_assert(offsetof(UMaterialExpressionConstant2Vector, R) == 0x000078, "Member 'UMaterialExpressionConstant2Vector::R' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionConstant2Vector, G) == 0x00007C, "Member 'UMaterialExpressionConstant2Vector::G' has a wrong offset!");

// Class Engine.AnimStateMachineTypes
// 0x0000 (0x0040 - 0x0040)
class UAnimStateMachineTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimStateMachineTypes">();
	}
	static class UAnimStateMachineTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimStateMachineTypes>();
	}
};
static_assert(alignof(UAnimStateMachineTypes) == 0x000008, "Wrong alignment on UAnimStateMachineTypes");
static_assert(sizeof(UAnimStateMachineTypes) == 0x000040, "Wrong size on UAnimStateMachineTypes");

// Class Engine.ApplicationLifecycleComponent
// 0x0000 (0xD38D - 0xD38D)
class UApplicationLifecycleComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   ApplicationWillDeactivateDelegate;                 // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationHasReactivatedDelegate;                 // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationWillEnterBackgroundDelegate;            // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationHasEnteredForegroundDelegate;           // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationWillTerminateDelegate;                  // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SqEX_AppSystemUiOverlaidMenuStartDelegate;         // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SqEX_AppSystemUiOverlaidMenuEndDelegate;           // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ApplicationLifetimeDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicationLifecycleComponent">();
	}
	static class UApplicationLifecycleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicationLifecycleComponent>();
	}
};
static_assert(alignof(UApplicationLifecycleComponent) == 0x00D38D, "Wrong alignment on UApplicationLifecycleComponent");
static_assert(sizeof(UApplicationLifecycleComponent) == 0x00D38D, "Wrong size on UApplicationLifecycleComponent");
static_assert(offsetof(UApplicationLifecycleComponent, ApplicationWillDeactivateDelegate) == 0x000200, "Member 'UApplicationLifecycleComponent::ApplicationWillDeactivateDelegate' has a wrong offset!");
static_assert(offsetof(UApplicationLifecycleComponent, ApplicationHasReactivatedDelegate) == 0x000210, "Member 'UApplicationLifecycleComponent::ApplicationHasReactivatedDelegate' has a wrong offset!");
static_assert(offsetof(UApplicationLifecycleComponent, ApplicationWillEnterBackgroundDelegate) == 0x000220, "Member 'UApplicationLifecycleComponent::ApplicationWillEnterBackgroundDelegate' has a wrong offset!");
static_assert(offsetof(UApplicationLifecycleComponent, ApplicationHasEnteredForegroundDelegate) == 0x000230, "Member 'UApplicationLifecycleComponent::ApplicationHasEnteredForegroundDelegate' has a wrong offset!");
static_assert(offsetof(UApplicationLifecycleComponent, ApplicationWillTerminateDelegate) == 0x000240, "Member 'UApplicationLifecycleComponent::ApplicationWillTerminateDelegate' has a wrong offset!");
static_assert(offsetof(UApplicationLifecycleComponent, SqEX_AppSystemUiOverlaidMenuStartDelegate) == 0x000250, "Member 'UApplicationLifecycleComponent::SqEX_AppSystemUiOverlaidMenuStartDelegate' has a wrong offset!");
static_assert(offsetof(UApplicationLifecycleComponent, SqEX_AppSystemUiOverlaidMenuEndDelegate) == 0x000260, "Member 'UApplicationLifecycleComponent::SqEX_AppSystemUiOverlaidMenuEndDelegate' has a wrong offset!");

// Class Engine.SqExEffectEmitterPresetDataPresetMenu
// 0x0028 (0x0068 - 0x0040)
class USqExEffectEmitterPresetDataPresetMenu final : public USQEX_EffectEmitterPresetDataBase
{
public:
	class FString                                 Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PresetName;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PresetAsset;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqExEffectEmitterPresetDataPresetMenu">();
	}
	static class USqExEffectEmitterPresetDataPresetMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqExEffectEmitterPresetDataPresetMenu>();
	}
};
static_assert(alignof(USqExEffectEmitterPresetDataPresetMenu) == 0x000008, "Wrong alignment on USqExEffectEmitterPresetDataPresetMenu");
static_assert(sizeof(USqExEffectEmitterPresetDataPresetMenu) == 0x000068, "Wrong size on USqExEffectEmitterPresetDataPresetMenu");
static_assert(offsetof(USqExEffectEmitterPresetDataPresetMenu, Description) == 0x000040, "Member 'USqExEffectEmitterPresetDataPresetMenu::Description' has a wrong offset!");
static_assert(offsetof(USqExEffectEmitterPresetDataPresetMenu, PresetName) == 0x000050, "Member 'USqExEffectEmitterPresetDataPresetMenu::PresetName' has a wrong offset!");
static_assert(offsetof(USqExEffectEmitterPresetDataPresetMenu, PresetAsset) == 0x000060, "Member 'USqExEffectEmitterPresetDataPresetMenu::PresetAsset' has a wrong offset!");

// Class Engine.AssetImportData
// 0x0000 (0x0040 - 0x0040)
class UAssetImportData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetImportData">();
	}
	static class UAssetImportData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetImportData>();
	}
};
static_assert(alignof(UAssetImportData) == 0x000008, "Wrong alignment on UAssetImportData");
static_assert(sizeof(UAssetImportData) == 0x000040, "Wrong size on UAssetImportData");

// Class Engine.SQEX_CapsuleComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USQEX_CapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_CapsuleComponent">();
	}
	static class USQEX_CapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_CapsuleComponent>();
	}
};
static_assert(alignof(USQEX_CapsuleComponent) == 0x112E9AF0, "Wrong alignment on USQEX_CapsuleComponent");
static_assert(sizeof(USQEX_CapsuleComponent) == 0x112E9AF0, "Wrong size on USQEX_CapsuleComponent");

// Class Engine.AssetManagerSettings
// 0x0068 (0x00B8 - 0x0050)
class UAssetManagerSettings final : public UDeveloperSettings
{
public:
	TArray<struct FPrimaryAssetTypeInfo>          PrimaryAssetTypesToScan;                           // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FDirectoryPath>                 DirectoriesToExclude;                              // 0x0060(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetRulesOverride>     PrimaryAssetRules;                                 // 0x0070(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bOnlyCookProductionAssets;                         // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldGuessTypeAndNameInEditor;                   // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetManagerRedirect>          PrimaryAssetIdRedirects;                           // 0x0088(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FAssetManagerRedirect>          PrimaryAssetTypeRedirects;                         // 0x0098(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FAssetManagerRedirect>          AssetPathRedirects;                                // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetManagerSettings">();
	}
	static class UAssetManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetManagerSettings>();
	}
};
static_assert(alignof(UAssetManagerSettings) == 0x000008, "Wrong alignment on UAssetManagerSettings");
static_assert(sizeof(UAssetManagerSettings) == 0x0000B8, "Wrong size on UAssetManagerSettings");
static_assert(offsetof(UAssetManagerSettings, PrimaryAssetTypesToScan) == 0x000050, "Member 'UAssetManagerSettings::PrimaryAssetTypesToScan' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, DirectoriesToExclude) == 0x000060, "Member 'UAssetManagerSettings::DirectoriesToExclude' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, PrimaryAssetRules) == 0x000070, "Member 'UAssetManagerSettings::PrimaryAssetRules' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, bOnlyCookProductionAssets) == 0x000080, "Member 'UAssetManagerSettings::bOnlyCookProductionAssets' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, bShouldGuessTypeAndNameInEditor) == 0x000081, "Member 'UAssetManagerSettings::bShouldGuessTypeAndNameInEditor' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, PrimaryAssetIdRedirects) == 0x000088, "Member 'UAssetManagerSettings::PrimaryAssetIdRedirects' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, PrimaryAssetTypeRedirects) == 0x000098, "Member 'UAssetManagerSettings::PrimaryAssetTypeRedirects' has a wrong offset!");
static_assert(offsetof(UAssetManagerSettings, AssetPathRedirects) == 0x0000A8, "Member 'UAssetManagerSettings::AssetPathRedirects' has a wrong offset!");

// Class Engine.MaterialExpressionFontSample
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionFontSample : public UMaterialExpression
{
public:
	class UFont*                                  Font;                                              // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontTexturePage;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFontSample">();
	}
	static class UMaterialExpressionFontSample* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFontSample>();
	}
};
static_assert(alignof(UMaterialExpressionFontSample) == 0x000008, "Wrong alignment on UMaterialExpressionFontSample");
static_assert(sizeof(UMaterialExpressionFontSample) == 0x000088, "Wrong size on UMaterialExpressionFontSample");
static_assert(offsetof(UMaterialExpressionFontSample, Font) == 0x000078, "Member 'UMaterialExpressionFontSample::Font' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFontSample, FontTexturePage) == 0x000080, "Member 'UMaterialExpressionFontSample::FontTexturePage' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TailModelCirculation
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_TailModelCirculation final : public UParticleModuleTypeDataMesh
{
public:
	uint8                                         bReversModelRotLerp : 1;                           // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsGroundZCheck : 1;                               // 0x01C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundZOffset;                                     // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailModelCirculation">();
	}
	static class UParticleModuleTypeDataSQEX_TailModelCirculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailModelCirculation>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailModelCirculation) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_TailModelCirculation");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailModelCirculation) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_TailModelCirculation");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelCirculation, GroundZOffset) == 0x0001C4, "Member 'UParticleModuleTypeDataSQEX_TailModelCirculation::GroundZOffset' has a wrong offset!");

// Class Engine.AssetMappingTable
// 0x0010 (0x0050 - 0x0040)
class UAssetMappingTable final : public UObject
{
public:
	TArray<struct FAssetMapping>                  MappedAssets;                                      // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetMappingTable">();
	}
	static class UAssetMappingTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetMappingTable>();
	}
};
static_assert(alignof(UAssetMappingTable) == 0x000008, "Wrong alignment on UAssetMappingTable");
static_assert(sizeof(UAssetMappingTable) == 0x000050, "Wrong size on UAssetMappingTable");
static_assert(offsetof(UAssetMappingTable, MappedAssets) == 0x000040, "Member 'UAssetMappingTable::MappedAssets' has a wrong offset!");

// Class Engine.AsyncActionLoadPrimaryAsset
// 0x0010 (0x0098 - 0x0088)
class UAsyncActionLoadPrimaryAsset final : public UAsyncActionLoadPrimaryAssetBase
{
public:
	UMulticastDelegateProperty_                   Completed;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncActionLoadPrimaryAsset* AsyncLoadPrimaryAsset(const struct FPrimaryAssetId& PrimaryAsset, const TArray<class FName>& LoadBundles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionLoadPrimaryAsset">();
	}
	static class UAsyncActionLoadPrimaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionLoadPrimaryAsset>();
	}
};
static_assert(alignof(UAsyncActionLoadPrimaryAsset) == 0x000008, "Wrong alignment on UAsyncActionLoadPrimaryAsset");
static_assert(sizeof(UAsyncActionLoadPrimaryAsset) == 0x000098, "Wrong size on UAsyncActionLoadPrimaryAsset");
static_assert(offsetof(UAsyncActionLoadPrimaryAsset, Completed) == 0x000088, "Member 'UAsyncActionLoadPrimaryAsset::Completed' has a wrong offset!");

// Class Engine.MaterialExpressionSaturate
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSaturate final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSaturate">();
	}
	static class UMaterialExpressionSaturate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSaturate>();
	}
};
static_assert(alignof(UMaterialExpressionSaturate) == 0x112F2730, "Wrong alignment on UMaterialExpressionSaturate");
static_assert(sizeof(UMaterialExpressionSaturate) == 0x112F2730, "Wrong size on UMaterialExpressionSaturate");
static_assert(offsetof(UMaterialExpressionSaturate, Input) == 0x000078, "Member 'UMaterialExpressionSaturate::Input' has a wrong offset!");

// Class Engine.AtmosphericFog
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AAtmosphericFog final : public AInfo
{
public:
	class UAtmosphericFogComponent*               AtmosphericFogComponent;                           // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtmosphericFog">();
	}
	static class AAtmosphericFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtmosphericFog>();
	}
};
static_assert(alignof(AAtmosphericFog) == 0x1EF72E00, "Wrong alignment on AAtmosphericFog");
static_assert(sizeof(AAtmosphericFog) == 0x1EF72E00, "Wrong size on AAtmosphericFog");
static_assert(offsetof(AAtmosphericFog, AtmosphericFogComponent) == 0x0003E0, "Member 'AAtmosphericFog::AtmosphericFogComponent' has a wrong offset!");

// Class Engine.AtmosphericFogComponent
// 0x31B830 (0x11605320 - 0x112E9AF0)
class UAtmosphericFogComponent final : public USceneComponent
{
public:
	float                                         SunMultiplier;                                     // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMultiplier;                                     // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DensityMultiplier;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DensityOffset;                                     // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltitudeScale;                                     // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOffset;                                    // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundOffset;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunDiscScale;                                      // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultBrightness;                                 // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DefaultLightColor;                                 // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableSunDisk : 1;                               // 0x0448(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableGroundScattering : 1;                      // 0x0448(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAtmospherePrecomputeParameters        PrecomputeParams;                                  // 0x044C(0x11605320)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             TransmittanceTexture;                              // 0x0478(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IrradianceTexture;                                 // 0x0480(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x178];                                    // 0x0488(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableGroundScattering(bool NewGroundScattering);
	void DisableSunDisk(bool NewSunDisk);
	void SetAltitudeScale(float NewAltitudeScale);
	void SetDefaultBrightness(float NewBrightness);
	void SetDefaultLightColor(const struct FLinearColor& NewLightColor);
	void SetDensityMultiplier(float NewDensityMultiplier);
	void SetDensityOffset(float NewDensityOffset);
	void SetDistanceOffset(float NewDistanceOffset);
	void SetDistanceScale(float NewDistanceScale);
	void SetFogMultiplier(float NewFogMultiplier);
	void SetPrecomputeParams(float DensityHeight, int32 MaxScatteringOrder, int32 InscatterAltitudeSampleNum);
	void SetStartDistance(float NewStartDistance);
	void SetSunMultiplier(float NewSunMultiplier);
	void StartPrecompute();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtmosphericFogComponent">();
	}
	static class UAtmosphericFogComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtmosphericFogComponent>();
	}
};
static_assert(alignof(UAtmosphericFogComponent) == 0x11605320, "Wrong alignment on UAtmosphericFogComponent");
static_assert(sizeof(UAtmosphericFogComponent) == 0x11605320, "Wrong size on UAtmosphericFogComponent");
static_assert(offsetof(UAtmosphericFogComponent, SunMultiplier) == 0x000418, "Member 'UAtmosphericFogComponent::SunMultiplier' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, FogMultiplier) == 0x00041C, "Member 'UAtmosphericFogComponent::FogMultiplier' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, DensityMultiplier) == 0x000420, "Member 'UAtmosphericFogComponent::DensityMultiplier' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, DensityOffset) == 0x000424, "Member 'UAtmosphericFogComponent::DensityOffset' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, DistanceScale) == 0x000428, "Member 'UAtmosphericFogComponent::DistanceScale' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, AltitudeScale) == 0x00042C, "Member 'UAtmosphericFogComponent::AltitudeScale' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, DistanceOffset) == 0x000430, "Member 'UAtmosphericFogComponent::DistanceOffset' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, GroundOffset) == 0x000434, "Member 'UAtmosphericFogComponent::GroundOffset' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, StartDistance) == 0x000438, "Member 'UAtmosphericFogComponent::StartDistance' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, SunDiscScale) == 0x00043C, "Member 'UAtmosphericFogComponent::SunDiscScale' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, DefaultBrightness) == 0x000440, "Member 'UAtmosphericFogComponent::DefaultBrightness' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, DefaultLightColor) == 0x000444, "Member 'UAtmosphericFogComponent::DefaultLightColor' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, PrecomputeParams) == 0x00044C, "Member 'UAtmosphericFogComponent::PrecomputeParams' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, TransmittanceTexture) == 0x000478, "Member 'UAtmosphericFogComponent::TransmittanceTexture' has a wrong offset!");
static_assert(offsetof(UAtmosphericFogComponent, IrradianceTexture) == 0x000480, "Member 'UAtmosphericFogComponent::IrradianceTexture' has a wrong offset!");

// Class Engine.TimelineComponent
// 0x0000 (0xD38D - 0xD38D)
class UTimelineComponent final : public UActorComponent
{
public:
	struct FTimeline                              TheTimeline;                                       // 0x0200(0x00E0)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         bIgnoreTimeDilation : 1;                           // 0x02E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2E1[0xF];                                      // 0x02E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Timeline();
	void Play();
	void PlayFromStart();
	void Reverse();
	void ReverseFromEnd();
	void SetFloatCurve(class UCurveFloat* NewFloatCurve, class FName FloatTrackName);
	void SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation);
	void SetLinearColorCurve(class UCurveLinearColor* NewLinearColorCurve, class FName LinearColorTrackName);
	void SetLooping(bool bNewLooping);
	void SetNewTime(float NewTime);
	void SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate);
	void SetPlayRate(float NewRate);
	void SetTimelineLength(float NewLength);
	void SetTimelineLengthMode(ETimelineLengthMode NewLengthMode);
	void SetVectorCurve(class UCurveVector* NewVectorCurve, class FName VectorTrackName);
	void Stop();

	bool GetIgnoreTimeDilation() const;
	float GetPlaybackPosition() const;
	float GetPlayRate() const;
	float GetTimelineLength() const;
	bool IsLooping() const;
	bool IsPlaying() const;
	bool IsReversing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimelineComponent">();
	}
	static class UTimelineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimelineComponent>();
	}
};
static_assert(alignof(UTimelineComponent) == 0x00D38D, "Wrong alignment on UTimelineComponent");
static_assert(sizeof(UTimelineComponent) == 0x00D38D, "Wrong size on UTimelineComponent");
static_assert(offsetof(UTimelineComponent, TheTimeline) == 0x000200, "Member 'UTimelineComponent::TheTimeline' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TailModelMarch
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_TailModelMarch final : public UParticleModuleTypeDataMesh
{
public:
	ESQEX_MARCH_SHAPE_TYPE                        ShapeType;                                         // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModelWidthNumbetr;                                 // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelHeightNumbetr;                                // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelWidthInterval;                                // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelHeightInterval;                               // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnIntervalScale : 1;                              // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ModelIntervalScale;                                // 0x01D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ModelWidthIntervalScale;                           // 0x0210(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ModelHeightIntervalScale;                          // 0x0248(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOnInterValScroll : 1;                             // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ModelIntervalScrollScale;                          // 0x0288(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ModelWidthIntervalScrollScale;                     // 0x02C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ModelHeightIntervalScrollScale;                    // 0x02F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ImpactModelIntervalScrollScale;                    // 0x0330(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOnNoiseMove : 1;                                  // 0x0380(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Intensity;                                         // 0x0388(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  PositionScale;                                     // 0x03C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TimeScale;                                         // 0x03F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 CurlNoiseScale;                                    // 0x0430(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 CurlNoiseTimeScale;                                // 0x0480(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bIsPlayerAvoid : 1;                                // 0x04D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D1[0x3];                                      // 0x04D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_PARTICLE_AVOID                          PlayerAvoidType;                                   // 0x04D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerAvoidRange;                                  // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerAvoidRangeOffset;                            // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsCameraAvoid : 1;                                // 0x04E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_PARTICLE_AVOID                          CameraAvoidType;                                   // 0x04E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E5[0x3];                                      // 0x04E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraAvoidRange;                                  // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraAvoidRangeOffset;                            // 0x04EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsGoAround : 1;                                   // 0x04F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4F1[0x3];                                      // 0x04F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TestAroundPostion;                                 // 0x04F4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestAroundRadius;                                  // 0x0500(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x4];                                      // 0x0504(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailModelMarch">();
	}
	static class UParticleModuleTypeDataSQEX_TailModelMarch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailModelMarch>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailModelMarch) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_TailModelMarch");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailModelMarch) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_TailModelMarch");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ShapeType) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ShapeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelWidthNumbetr) == 0x0001C4, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelWidthNumbetr' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelHeightNumbetr) == 0x0001C8, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelHeightNumbetr' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelWidthInterval) == 0x0001CC, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelWidthInterval' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelHeightInterval) == 0x0001D0, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelHeightInterval' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelIntervalScale) == 0x0001D8, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelIntervalScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelWidthIntervalScale) == 0x000210, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelWidthIntervalScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelHeightIntervalScale) == 0x000248, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelHeightIntervalScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelIntervalScrollScale) == 0x000288, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelIntervalScrollScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelWidthIntervalScrollScale) == 0x0002C0, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelWidthIntervalScrollScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ModelHeightIntervalScrollScale) == 0x0002F8, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ModelHeightIntervalScrollScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, ImpactModelIntervalScrollScale) == 0x000330, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::ImpactModelIntervalScrollScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, Intensity) == 0x000388, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::Intensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, PositionScale) == 0x0003C0, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::PositionScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, TimeScale) == 0x0003F8, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::TimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, CurlNoiseScale) == 0x000430, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::CurlNoiseScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, CurlNoiseTimeScale) == 0x000480, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::CurlNoiseTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, PlayerAvoidType) == 0x0004D4, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::PlayerAvoidType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, PlayerAvoidRange) == 0x0004D8, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::PlayerAvoidRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, PlayerAvoidRangeOffset) == 0x0004DC, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::PlayerAvoidRangeOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, CameraAvoidType) == 0x0004E4, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::CameraAvoidType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, CameraAvoidRange) == 0x0004E8, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::CameraAvoidRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, CameraAvoidRangeOffset) == 0x0004EC, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::CameraAvoidRangeOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, TestAroundPostion) == 0x0004F4, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::TestAroundPostion' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailModelMarch, TestAroundRadius) == 0x000500, "Member 'UParticleModuleTypeDataSQEX_TailModelMarch::TestAroundRadius' has a wrong offset!");

// Class Engine.AudioComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UAudioComponent : public USceneComponent
{
public:
	class USoundBase*                             Sound;                                             // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAudioComponentParam>           InstanceParameters;                                // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	class USoundClass*                            SoundClassOverride;                                // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoDestroy : 1;                                  // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopWhenOwnerDestroyed : 1;                       // 0x0438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldRemainActiveIfDropped : 1;                  // 0x0438(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpatialization : 1;                          // 0x0438(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideAttenuation : 1;                          // 0x0438(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_438_5 : 3;                                  // 0x0438(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideSubtitlePriority : 1;                     // 0x043C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_43C_1 : 7;                                  // 0x043C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsUISound : 1;                                    // 0x0440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableLowPassFilter : 1;                          // 0x0440(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePriority : 1;                             // 0x0440(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuppressSubtitles : 1;                            // 0x0440(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_441[0xF];                                      // 0x0441(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AudioComponentUserID;                              // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchModulationMin;                                // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchModulationMax;                                // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeModulationMin;                               // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeModulationMax;                               // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitlePriority;                                  // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeWeightedPriorityScale;                       // 0x0474(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighFrequencyGainMultiplier;                       // 0x047C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowPassFilterFrequency;                            // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundAttenuationSettings              AttenuationOverrides;                              // 0x0490(0x11487DA0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAudioFinished;                                   // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x70];                                     // 0x05E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAudioPlaybackPercent;                            // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x70];                                     // 0x0660(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(TArray<struct FSubtitleCue>& Subtitles, float CueDuration)> OnQueueSubtitles;                                  // 0x06D0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x10];                                     // 0x06E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustAttenuation(const struct FSoundAttenuationSettings& InAttenuationSettings);
	void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel);
	bool BP_GetAttenuationSettingsToApply(struct FSoundAttenuationSettings* OutAttenuationSettings);
	void FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime);
	void FadeOut(float FadeOutDuration, float FadeVolumeLevel);
	void Play(float StartTime);
	void SetBoolParameter(class FName InName, bool InBool);
	void SetFloatParameter(class FName InName, float InFloat);
	void SetIntParameter(class FName InName, int32 InInt);
	void SetLowPassFilterEnabled(bool InLowPassFilterEnabled);
	void SetLowPassFilterFrequency(float InLowPassFilterFrequency);
	void SetPaused(bool bPause);
	void SetPitchMultiplier(float NewPitchMultiplier);
	void SetSound(class USoundBase* NewSound);
	void SetSubmixSend(class USoundSubmix* Submix, float SendLevel);
	void SetUISound(bool bInUISound);
	void SetVolumeMultiplier(float NewVolumeMultiplier);
	void SetWaveParameter(class FName InName, class USoundWave* InWave);
	void Stop();

	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioComponent">();
	}
	static class UAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UAudioComponent) == 0x112E9AF0, "Wrong alignment on UAudioComponent");
static_assert(sizeof(UAudioComponent) == 0x112E9AF0, "Wrong size on UAudioComponent");
static_assert(offsetof(UAudioComponent, Sound) == 0x000418, "Member 'UAudioComponent::Sound' has a wrong offset!");
static_assert(offsetof(UAudioComponent, InstanceParameters) == 0x000420, "Member 'UAudioComponent::InstanceParameters' has a wrong offset!");
static_assert(offsetof(UAudioComponent, SoundClassOverride) == 0x000430, "Member 'UAudioComponent::SoundClassOverride' has a wrong offset!");
static_assert(offsetof(UAudioComponent, AudioComponentUserID) == 0x000450, "Member 'UAudioComponent::AudioComponentUserID' has a wrong offset!");
static_assert(offsetof(UAudioComponent, PitchModulationMin) == 0x000458, "Member 'UAudioComponent::PitchModulationMin' has a wrong offset!");
static_assert(offsetof(UAudioComponent, PitchModulationMax) == 0x00045C, "Member 'UAudioComponent::PitchModulationMax' has a wrong offset!");
static_assert(offsetof(UAudioComponent, VolumeModulationMin) == 0x000460, "Member 'UAudioComponent::VolumeModulationMin' has a wrong offset!");
static_assert(offsetof(UAudioComponent, VolumeModulationMax) == 0x000464, "Member 'UAudioComponent::VolumeModulationMax' has a wrong offset!");
static_assert(offsetof(UAudioComponent, VolumeMultiplier) == 0x000468, "Member 'UAudioComponent::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UAudioComponent, Priority) == 0x00046C, "Member 'UAudioComponent::Priority' has a wrong offset!");
static_assert(offsetof(UAudioComponent, SubtitlePriority) == 0x000470, "Member 'UAudioComponent::SubtitlePriority' has a wrong offset!");
static_assert(offsetof(UAudioComponent, VolumeWeightedPriorityScale) == 0x000474, "Member 'UAudioComponent::VolumeWeightedPriorityScale' has a wrong offset!");
static_assert(offsetof(UAudioComponent, PitchMultiplier) == 0x000478, "Member 'UAudioComponent::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(UAudioComponent, HighFrequencyGainMultiplier) == 0x00047C, "Member 'UAudioComponent::HighFrequencyGainMultiplier' has a wrong offset!");
static_assert(offsetof(UAudioComponent, LowPassFilterFrequency) == 0x000480, "Member 'UAudioComponent::LowPassFilterFrequency' has a wrong offset!");
static_assert(offsetof(UAudioComponent, AttenuationSettings) == 0x000488, "Member 'UAudioComponent::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(UAudioComponent, AttenuationOverrides) == 0x000490, "Member 'UAudioComponent::AttenuationOverrides' has a wrong offset!");
static_assert(offsetof(UAudioComponent, ConcurrencySettings) == 0x0005C0, "Member 'UAudioComponent::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(UAudioComponent, OnAudioFinished) == 0x0005D0, "Member 'UAudioComponent::OnAudioFinished' has a wrong offset!");
static_assert(offsetof(UAudioComponent, OnAudioPlaybackPercent) == 0x000650, "Member 'UAudioComponent::OnAudioPlaybackPercent' has a wrong offset!");
static_assert(offsetof(UAudioComponent, OnQueueSubtitles) == 0x0006D0, "Member 'UAudioComponent::OnQueueSubtitles' has a wrong offset!");

// Class Engine.AudioSettings
// 0x0078 (0x00C8 - 0x0050)
class UAudioSettings final : public UDeveloperSettings
{
public:
	struct FStringAssetReference                  DefaultSoundClassName;                             // 0x0050(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultSoundConcurrencyName;                       // 0x0060(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  DefaultBaseSoundMix;                               // 0x0070(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  VoiPSoundClass;                                    // 0x0080(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowPassFilterResonance;                            // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumConcurrentStreams;                          // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAudioQualitySettings>          QualityLevels;                                     // 0x0098(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         bAllowVirtualizedSounds : 1;                       // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMasterEQ : 1;                              // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMasterReverb : 1;                          // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowCenterChannel3DPanning : 1;                  // 0x00A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DialogueFilenameFormat;                            // 0x00B0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioSettings">();
	}
	static class UAudioSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioSettings>();
	}
};
static_assert(alignof(UAudioSettings) == 0x000008, "Wrong alignment on UAudioSettings");
static_assert(sizeof(UAudioSettings) == 0x0000C8, "Wrong size on UAudioSettings");
static_assert(offsetof(UAudioSettings, DefaultSoundClassName) == 0x000050, "Member 'UAudioSettings::DefaultSoundClassName' has a wrong offset!");
static_assert(offsetof(UAudioSettings, DefaultSoundConcurrencyName) == 0x000060, "Member 'UAudioSettings::DefaultSoundConcurrencyName' has a wrong offset!");
static_assert(offsetof(UAudioSettings, DefaultBaseSoundMix) == 0x000070, "Member 'UAudioSettings::DefaultBaseSoundMix' has a wrong offset!");
static_assert(offsetof(UAudioSettings, VoiPSoundClass) == 0x000080, "Member 'UAudioSettings::VoiPSoundClass' has a wrong offset!");
static_assert(offsetof(UAudioSettings, LowPassFilterResonance) == 0x000090, "Member 'UAudioSettings::LowPassFilterResonance' has a wrong offset!");
static_assert(offsetof(UAudioSettings, MaximumConcurrentStreams) == 0x000094, "Member 'UAudioSettings::MaximumConcurrentStreams' has a wrong offset!");
static_assert(offsetof(UAudioSettings, QualityLevels) == 0x000098, "Member 'UAudioSettings::QualityLevels' has a wrong offset!");
static_assert(offsetof(UAudioSettings, DialogueFilenameFormat) == 0x0000B0, "Member 'UAudioSettings::DialogueFilenameFormat' has a wrong offset!");

// Class Engine.NavLinkHostInterface
// 0x0000 (0x0040 - 0x0040)
class INavLinkHostInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkHostInterface">();
	}
	static class INavLinkHostInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavLinkHostInterface>();
	}
};
static_assert(alignof(INavLinkHostInterface) == 0x000008, "Wrong alignment on INavLinkHostInterface");
static_assert(sizeof(INavLinkHostInterface) == 0x000040, "Wrong size on INavLinkHostInterface");

// Class Engine.AudioVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AAudioVolume final : public AVolume
{
public:
	float                                         Priority;                                          // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnabled : 1;                                      // 0x0424(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReverbSettings                        Settings;                                          // 0x0428(0x11606540)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	struct FInteriorSettings                      AmbientZoneSettings;                               // 0x0440(0x11605F70)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_bEnabled();
	void SetEnabled(bool bNewEnabled);
	void SetInteriorSettings(const struct FInteriorSettings& NewInteriorSettings);
	void SetPriority(float NewPriority);
	void SetReverbSettings(const struct FReverbSettings& NewReverbSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioVolume">();
	}
	static class AAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioVolume>();
	}
};
static_assert(alignof(AAudioVolume) == 0x1EF72E00, "Wrong alignment on AAudioVolume");
static_assert(sizeof(AAudioVolume) == 0x1EF72E00, "Wrong size on AAudioVolume");
static_assert(offsetof(AAudioVolume, Priority) == 0x000420, "Member 'AAudioVolume::Priority' has a wrong offset!");
static_assert(offsetof(AAudioVolume, Settings) == 0x000428, "Member 'AAudioVolume::Settings' has a wrong offset!");
static_assert(offsetof(AAudioVolume, AmbientZoneSettings) == 0x000440, "Member 'AAudioVolume::AmbientZoneSettings' has a wrong offset!");

// Class Engine.AutomationTestSettings
// 0x112EA6E0 (0x112EA720 - 0x0040)
class UAutomationTestSettings final : public UObject
{
public:
	TArray<class FString>                         EngineTestModules;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         EditorTestModules;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  AutomationTestmap;                                 // 0x0060(0x0010)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEditorMapPerformanceTestDefinition> EditorPerformanceTestMaps;                         // 0x0070(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FStringAssetReference>          AssetsToOpen;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FBuildPromotionTestSettings            BuildPromotionTest;                                // 0x0090(0x11606FE0)(Edit, Config, NativeAccessSpecifierPublic)
	struct FMaterialEditorPromotionSettings       MaterialEditorPromotionTest;                       // 0x0280(0x0030)(Edit, Config, NativeAccessSpecifierPublic)
	struct FParticleEditorPromotionSettings       ParticleEditorPromotionTest;                       // 0x02B0(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBlueprintEditorPromotionSettings      BlueprintEditorPromotionTest;                      // 0x02C0(0x0030)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         TestLevelFolders;                                  // 0x02F0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FExternalToolDefinition>        ExternalTools;                                     // 0x0300(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FEditorImportExportTestDefinition> ImportExportTestDefinitions;                       // 0x0310(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLaunchOnTestSettings>          LaunchOnSettings;                                  // 0x0320(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FIntPoint                              DefaultScreenshotResolution;                       // 0x0330(0x112EA720)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomationTestSettings">();
	}
	static class UAutomationTestSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomationTestSettings>();
	}
};
static_assert(alignof(UAutomationTestSettings) == 0x112EA720, "Wrong alignment on UAutomationTestSettings");
static_assert(sizeof(UAutomationTestSettings) == 0x112EA720, "Wrong size on UAutomationTestSettings");
static_assert(offsetof(UAutomationTestSettings, EngineTestModules) == 0x000040, "Member 'UAutomationTestSettings::EngineTestModules' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, EditorTestModules) == 0x000050, "Member 'UAutomationTestSettings::EditorTestModules' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, AutomationTestmap) == 0x000060, "Member 'UAutomationTestSettings::AutomationTestmap' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, EditorPerformanceTestMaps) == 0x000070, "Member 'UAutomationTestSettings::EditorPerformanceTestMaps' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, AssetsToOpen) == 0x000080, "Member 'UAutomationTestSettings::AssetsToOpen' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, BuildPromotionTest) == 0x000090, "Member 'UAutomationTestSettings::BuildPromotionTest' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, MaterialEditorPromotionTest) == 0x000280, "Member 'UAutomationTestSettings::MaterialEditorPromotionTest' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, ParticleEditorPromotionTest) == 0x0002B0, "Member 'UAutomationTestSettings::ParticleEditorPromotionTest' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, BlueprintEditorPromotionTest) == 0x0002C0, "Member 'UAutomationTestSettings::BlueprintEditorPromotionTest' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, TestLevelFolders) == 0x0002F0, "Member 'UAutomationTestSettings::TestLevelFolders' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, ExternalTools) == 0x000300, "Member 'UAutomationTestSettings::ExternalTools' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, ImportExportTestDefinitions) == 0x000310, "Member 'UAutomationTestSettings::ImportExportTestDefinitions' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, LaunchOnSettings) == 0x000320, "Member 'UAutomationTestSettings::LaunchOnSettings' has a wrong offset!");
static_assert(offsetof(UAutomationTestSettings, DefaultScreenshotResolution) == 0x000330, "Member 'UAutomationTestSettings::DefaultScreenshotResolution' has a wrong offset!");

// Class Engine.AvoidanceManager
// 0x00B8 (0x00F8 - 0x0040)
class UAvoidanceManager final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultTimeToLive;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockTimeAfterAvoid;                                // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockTimeAfterClean;                                // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTimeToPredict;                                // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArtificialRadiusExpansion;                         // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestHeightDifference;                              // 0x005C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightCheckMargin;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x94];                                      // 0x0064(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp);
	int32 GetNewAvoidanceUID();
	int32 GetObjectCount();
	bool RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvoidanceManager">();
	}
	static class UAvoidanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvoidanceManager>();
	}
};
static_assert(alignof(UAvoidanceManager) == 0x000008, "Wrong alignment on UAvoidanceManager");
static_assert(sizeof(UAvoidanceManager) == 0x0000F8, "Wrong size on UAvoidanceManager");
static_assert(offsetof(UAvoidanceManager, DefaultTimeToLive) == 0x000048, "Member 'UAvoidanceManager::DefaultTimeToLive' has a wrong offset!");
static_assert(offsetof(UAvoidanceManager, LockTimeAfterAvoid) == 0x00004C, "Member 'UAvoidanceManager::LockTimeAfterAvoid' has a wrong offset!");
static_assert(offsetof(UAvoidanceManager, LockTimeAfterClean) == 0x000050, "Member 'UAvoidanceManager::LockTimeAfterClean' has a wrong offset!");
static_assert(offsetof(UAvoidanceManager, DeltaTimeToPredict) == 0x000054, "Member 'UAvoidanceManager::DeltaTimeToPredict' has a wrong offset!");
static_assert(offsetof(UAvoidanceManager, ArtificialRadiusExpansion) == 0x000058, "Member 'UAvoidanceManager::ArtificialRadiusExpansion' has a wrong offset!");
static_assert(offsetof(UAvoidanceManager, TestHeightDifference) == 0x00005C, "Member 'UAvoidanceManager::TestHeightDifference' has a wrong offset!");
static_assert(offsetof(UAvoidanceManager, HeightCheckMargin) == 0x000060, "Member 'UAvoidanceManager::HeightCheckMargin' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_SkeletalMesh
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleTypeDataSQEX_SkeletalMesh final : public UParticleModuleTypeDataBase
{
public:
	uint8                                         bUseExtanalSkeletalMesh : 1;                       // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAttachParentObject : 1;                           // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachBone;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideMaterial : 1;                             // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastCapsuleDirectShadow : 1;                      // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadow : 1;                                   // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bOverrideTranslucencySortPriority : 1;        // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_OBJECT_TYPE_TRANSLUCENCYSORTPRIORITY    SQEXTranslucencySortPriorityCategory;              // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSimulatePhysics : 1;                              // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_SKELETAL_MODULE_AURA_ID                 AuraID;                                            // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseExtanalSkeletalAnimation : 1;                  // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_SkeletalAnimationData>    AnimationData;                                     // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRotator                               RotaionOffset;                                     // 0x0098(0x112E9AF0)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_SkeletalMesh">();
	}
	static class UParticleModuleTypeDataSQEX_SkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_SkeletalMesh>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_SkeletalMesh) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_SkeletalMesh");
static_assert(sizeof(UParticleModuleTypeDataSQEX_SkeletalMesh) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_SkeletalMesh");
static_assert(offsetof(UParticleModuleTypeDataSQEX_SkeletalMesh, SkeletalMesh) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_SkeletalMesh::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_SkeletalMesh, AttachBone) == 0x000068, "Member 'UParticleModuleTypeDataSQEX_SkeletalMesh::AttachBone' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_SkeletalMesh, SQEXTranslucencySortPriorityCategory) == 0x000074, "Member 'UParticleModuleTypeDataSQEX_SkeletalMesh::SQEXTranslucencySortPriorityCategory' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_SkeletalMesh, AuraID) == 0x00007C, "Member 'UParticleModuleTypeDataSQEX_SkeletalMesh::AuraID' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_SkeletalMesh, AnimationData) == 0x000088, "Member 'UParticleModuleTypeDataSQEX_SkeletalMesh::AnimationData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_SkeletalMesh, RotaionOffset) == 0x000098, "Member 'UParticleModuleTypeDataSQEX_SkeletalMesh::RotaionOffset' has a wrong offset!");

// Class Engine.SQEX_CameraInterest
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASQEX_CameraInterest final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_CameraInterest">();
	}
	static class ASQEX_CameraInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASQEX_CameraInterest>();
	}
};
static_assert(alignof(ASQEX_CameraInterest) == 0x1EF72E00, "Wrong alignment on ASQEX_CameraInterest");
static_assert(sizeof(ASQEX_CameraInterest) == 0x1EF72E00, "Wrong size on ASQEX_CameraInterest");

// Class Engine.MaterialExpressionParticleSQEXAreaColorSynthesis
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionParticleSQEXAreaColorSynthesis final : public UMaterialExpression
{
public:
	float                                         DefaultValue;                                      // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXAreaColorSynthesis">();
	}
	static class UMaterialExpressionParticleSQEXAreaColorSynthesis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXAreaColorSynthesis>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXAreaColorSynthesis) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXAreaColorSynthesis");
static_assert(sizeof(UMaterialExpressionParticleSQEXAreaColorSynthesis) == 0x000080, "Wrong size on UMaterialExpressionParticleSQEXAreaColorSynthesis");
static_assert(offsetof(UMaterialExpressionParticleSQEXAreaColorSynthesis, DefaultValue) == 0x000078, "Member 'UMaterialExpressionParticleSQEXAreaColorSynthesis::DefaultValue' has a wrong offset!");

// Class Engine.BillboardComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UBillboardComponent final : public UPrimitiveComponent
{
public:
	class UTexture2D*                             Sprite;                                            // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsScreenSizeScaled : 1;                           // 0x0870(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_871[0x3];                                      // 0x0871(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenSize;                                        // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         U;                                                 // 0x0878(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UL;                                                // 0x087C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V;                                                 // 0x0880(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VL;                                                // 0x0884(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_888[0x8];                                      // 0x0888(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSprite(class UTexture2D* NewSprite);
	void SetSpriteAndUV(class UTexture2D* NewSprite, int32 NewU, int32 NewUL, int32 NewV, int32 NewVL);
	void SetUV(int32 NewU, int32 NewUL, int32 NewV, int32 NewVL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BillboardComponent">();
	}
	static class UBillboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBillboardComponent>();
	}
};
static_assert(alignof(UBillboardComponent) == 0x112E9AF0, "Wrong alignment on UBillboardComponent");
static_assert(sizeof(UBillboardComponent) == 0x112E9AF0, "Wrong size on UBillboardComponent");
static_assert(offsetof(UBillboardComponent, Sprite) == 0x000868, "Member 'UBillboardComponent::Sprite' has a wrong offset!");
static_assert(offsetof(UBillboardComponent, ScreenSize) == 0x000874, "Member 'UBillboardComponent::ScreenSize' has a wrong offset!");
static_assert(offsetof(UBillboardComponent, U) == 0x000878, "Member 'UBillboardComponent::U' has a wrong offset!");
static_assert(offsetof(UBillboardComponent, UL) == 0x00087C, "Member 'UBillboardComponent::UL' has a wrong offset!");
static_assert(offsetof(UBillboardComponent, V) == 0x000880, "Member 'UBillboardComponent::V' has a wrong offset!");
static_assert(offsetof(UBillboardComponent, VL) == 0x000884, "Member 'UBillboardComponent::VL' has a wrong offset!");

// Class Engine.BlendableInterface
// 0x0000 (0x0040 - 0x0040)
class IBlendableInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendableInterface">();
	}
	static class IBlendableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlendableInterface>();
	}
};
static_assert(alignof(IBlendableInterface) == 0x000008, "Wrong alignment on IBlendableInterface");
static_assert(sizeof(IBlendableInterface) == 0x000040, "Wrong size on IBlendableInterface");

// Class Engine.MaterialExpressionArctangent
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArctangent final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArctangent">();
	}
	static class UMaterialExpressionArctangent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArctangent>();
	}
};
static_assert(alignof(UMaterialExpressionArctangent) == 0x112F2730, "Wrong alignment on UMaterialExpressionArctangent");
static_assert(sizeof(UMaterialExpressionArctangent) == 0x112F2730, "Wrong size on UMaterialExpressionArctangent");
static_assert(offsetof(UMaterialExpressionArctangent, Input) == 0x000078, "Member 'UMaterialExpressionArctangent::Input' has a wrong offset!");

// Class Engine.Skeleton
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class USkeleton final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneNode>                      BoneTree;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTransform>                     RefLocalPoses;                                     // 0x0058(0x0010)(ZeroConstructor, Deprecated, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x110];                                     // 0x0068(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  VirtualBoneGuid;                                   // 0x0178(0x112E8D20)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVirtualBone>                   VirtualBones;                                      // 0x0188(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshSocket*>            Sockets;                                           // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x50];                                     // 0x01A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSmartNameContainer                    SmartNames;                                        // 0x01F8(0x7F7E)(Protected, NativeAccessSpecifierProtected)
	TArray<class UBlendProfile*>                  BlendProfiles;                                     // 0x0260(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAnimSlotGroup>                 SlotGroups;                                        // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x120];                                    // 0x0280(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x03A0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSQEX_DefaultCurveValue>        M_DefaultCurveValues;                              // 0x03B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSqEX_CompatibleSkeletonData>   SQEX_CompatibleSkeletonLists;                      // 0x03C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class USkeleton*, struct FSqEX_CompatibleSkeletonBoneRemapTable> SQEX_CompatibleSkeletonRemapTables;                // 0x03D0(0x0050)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skeleton">();
	}
	static class USkeleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeleton>();
	}
};
static_assert(alignof(USkeleton) == 0x112E8D20, "Wrong alignment on USkeleton");
static_assert(sizeof(USkeleton) == 0x112E8D20, "Wrong size on USkeleton");
static_assert(offsetof(USkeleton, BoneTree) == 0x000048, "Member 'USkeleton::BoneTree' has a wrong offset!");
static_assert(offsetof(USkeleton, RefLocalPoses) == 0x000058, "Member 'USkeleton::RefLocalPoses' has a wrong offset!");
static_assert(offsetof(USkeleton, VirtualBoneGuid) == 0x000178, "Member 'USkeleton::VirtualBoneGuid' has a wrong offset!");
static_assert(offsetof(USkeleton, VirtualBones) == 0x000188, "Member 'USkeleton::VirtualBones' has a wrong offset!");
static_assert(offsetof(USkeleton, Sockets) == 0x000198, "Member 'USkeleton::Sockets' has a wrong offset!");
static_assert(offsetof(USkeleton, SmartNames) == 0x0001F8, "Member 'USkeleton::SmartNames' has a wrong offset!");
static_assert(offsetof(USkeleton, BlendProfiles) == 0x000260, "Member 'USkeleton::BlendProfiles' has a wrong offset!");
static_assert(offsetof(USkeleton, SlotGroups) == 0x000270, "Member 'USkeleton::SlotGroups' has a wrong offset!");
static_assert(offsetof(USkeleton, AssetUserData) == 0x0003A0, "Member 'USkeleton::AssetUserData' has a wrong offset!");
static_assert(offsetof(USkeleton, M_DefaultCurveValues) == 0x0003B0, "Member 'USkeleton::M_DefaultCurveValues' has a wrong offset!");
static_assert(offsetof(USkeleton, SQEX_CompatibleSkeletonLists) == 0x0003C0, "Member 'USkeleton::SQEX_CompatibleSkeletonLists' has a wrong offset!");
static_assert(offsetof(USkeleton, SQEX_CompatibleSkeletonRemapTables) == 0x0003D0, "Member 'USkeleton::SQEX_CompatibleSkeletonRemapTables' has a wrong offset!");

// Class Engine.BlendProfile
// 0x0020 (0x0060 - 0x0040)
class UBlendProfile final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              OwningSkeleton;                                    // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBlendProfileBoneEntry>         ProfileEntries;                                    // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendProfile">();
	}
	static class UBlendProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendProfile>();
	}
};
static_assert(alignof(UBlendProfile) == 0x000008, "Wrong alignment on UBlendProfile");
static_assert(sizeof(UBlendProfile) == 0x000060, "Wrong size on UBlendProfile");
static_assert(offsetof(UBlendProfile, OwningSkeleton) == 0x000048, "Member 'UBlendProfile::OwningSkeleton' has a wrong offset!");
static_assert(offsetof(UBlendProfile, ProfileEntries) == 0x000050, "Member 'UBlendProfile::ProfileEntries' has a wrong offset!");

// Class Engine.MaterialExpressionNormalize
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionNormalize final : public UMaterialExpression
{
public:
	struct FExpressionInput                       VectorInput;                                       // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionNormalize">();
	}
	static class UMaterialExpressionNormalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionNormalize>();
	}
};
static_assert(alignof(UMaterialExpressionNormalize) == 0x112F2730, "Wrong alignment on UMaterialExpressionNormalize");
static_assert(sizeof(UMaterialExpressionNormalize) == 0x112F2730, "Wrong size on UMaterialExpressionNormalize");
static_assert(offsetof(UMaterialExpressionNormalize, VectorInput) == 0x000078, "Member 'UMaterialExpressionNormalize::VectorInput' has a wrong offset!");

// Class Engine.BlockingVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ABlockingVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockingVolume">();
	}
	static class ABlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlockingVolume>();
	}
};
static_assert(alignof(ABlockingVolume) == 0x1EF72E00, "Wrong alignment on ABlockingVolume");
static_assert(sizeof(ABlockingVolume) == 0x1EF72E00, "Wrong size on ABlockingVolume");

// Class Engine.BlueprintMapLibrary
// 0x0000 (0x0040 - 0x0040)
class UBlueprintMapLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool Map_Add(const TMap<int32, int32>& TargetMap, const int32& Key, const int32& Value);
	static void Map_Clear(const TMap<int32, int32>& TargetMap);
	static bool Map_Contains(const TMap<int32, int32>& TargetMap, const int32& Key);
	static bool Map_Find(const TMap<int32, int32>& TargetMap, const int32& Key, int32* Value);
	static void Map_Keys(const TMap<int32, int32>& TargetMap, TArray<int32>* Keys);
	static int32 Map_Length(const TMap<int32, int32>& TargetMap);
	static bool Map_Remove(const TMap<int32, int32>& TargetMap, const int32& Key);
	static void Map_Values(const TMap<int32, int32>& TargetMap, TArray<int32>* Values);
	static void SetMapPropertyByName(class UObject* Object, class FName PropertyName, const TMap<int32, int32>& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintMapLibrary">();
	}
	static class UBlueprintMapLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintMapLibrary>();
	}
};
static_assert(alignof(UBlueprintMapLibrary) == 0x000008, "Wrong alignment on UBlueprintMapLibrary");
static_assert(sizeof(UBlueprintMapLibrary) == 0x000040, "Wrong size on UBlueprintMapLibrary");

// Class Engine.SQEX_AutoEffectDebugDataBase
// 0x0028 (0x0068 - 0x0040)
class USQEX_AutoEffectDebugDataBase : public UObject
{
public:
	class FString                                 Description;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_AutoEffectDebugDataBase">();
	}
	static class USQEX_AutoEffectDebugDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_AutoEffectDebugDataBase>();
	}
};
static_assert(alignof(USQEX_AutoEffectDebugDataBase) == 0x000008, "Wrong alignment on USQEX_AutoEffectDebugDataBase");
static_assert(sizeof(USQEX_AutoEffectDebugDataBase) == 0x000068, "Wrong size on USQEX_AutoEffectDebugDataBase");
static_assert(offsetof(USQEX_AutoEffectDebugDataBase, Description) == 0x000040, "Member 'USQEX_AutoEffectDebugDataBase::Description' has a wrong offset!");
static_assert(offsetof(USQEX_AutoEffectDebugDataBase, Command) == 0x000050, "Member 'USQEX_AutoEffectDebugDataBase::Command' has a wrong offset!");
static_assert(offsetof(USQEX_AutoEffectDebugDataBase, Timer) == 0x000060, "Member 'USQEX_AutoEffectDebugDataBase::Timer' has a wrong offset!");

// Class Engine.SQEX_AutoEffectDebugDataLocationData
// 0x0010 (0x0078 - 0x0068)
class USQEX_AutoEffectDebugDataLocationData final : public USQEX_AutoEffectDebugDataBase
{
public:
	struct FVector                                Location;                                          // 0x0068(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_AutoEffectDebugDataLocationData">();
	}
	static class USQEX_AutoEffectDebugDataLocationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_AutoEffectDebugDataLocationData>();
	}
};
static_assert(alignof(USQEX_AutoEffectDebugDataLocationData) == 0x000008, "Wrong alignment on USQEX_AutoEffectDebugDataLocationData");
static_assert(sizeof(USQEX_AutoEffectDebugDataLocationData) == 0x000078, "Wrong size on USQEX_AutoEffectDebugDataLocationData");
static_assert(offsetof(USQEX_AutoEffectDebugDataLocationData, Location) == 0x000068, "Member 'USQEX_AutoEffectDebugDataLocationData::Location' has a wrong offset!");

// Class Engine.MaterialExpressionLinearInterpolate
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionLinearInterpolate final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLinearInterpolate">();
	}
	static class UMaterialExpressionLinearInterpolate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLinearInterpolate>();
	}
};
static_assert(alignof(UMaterialExpressionLinearInterpolate) == 0x112F2730, "Wrong alignment on UMaterialExpressionLinearInterpolate");
static_assert(sizeof(UMaterialExpressionLinearInterpolate) == 0x112F2730, "Wrong size on UMaterialExpressionLinearInterpolate");
static_assert(offsetof(UMaterialExpressionLinearInterpolate, A) == 0x000078, "Member 'UMaterialExpressionLinearInterpolate::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLinearInterpolate, B) == 0x0000B0, "Member 'UMaterialExpressionLinearInterpolate::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLinearInterpolate, Alpha) == 0x0000E8, "Member 'UMaterialExpressionLinearInterpolate::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLinearInterpolate, ConstA) == 0x000120, "Member 'UMaterialExpressionLinearInterpolate::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLinearInterpolate, ConstB) == 0x000124, "Member 'UMaterialExpressionLinearInterpolate::ConstB' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionLinearInterpolate, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionLinearInterpolate::ConstAlpha' has a wrong offset!");

// Class Engine.PlatformGameInstance
// 0x00B0 (0x01F0 - 0x0140)
class UPlatformGameInstance final : public UGameInstance
{
public:
	UMulticastDelegateProperty_                   ApplicationWillDeactivateDelegate;                 // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationHasReactivatedDelegate;                 // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationWillEnterBackgroundDelegate;            // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationHasEnteredForegroundDelegate;           // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationWillTerminateDelegate;                  // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationRegisteredForRemoteNotificationsDelegate; // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationRegisteredForUserNotificationsDelegate; // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationFailedToRegisterForRemoteNotificationsDelegate; // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationReceivedRemoteNotificationDelegate;     // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationReceivedLocalNotificationDelegate;      // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ApplicationReceivedScreenOrientationChangedNotificationDelegate; // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void PlatformDelegate__DelegateSignature();
	void PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(const class FString& InString);
	void PlatformReceivedLocalNotificationDelegate__DelegateSignature(const class FString& InString, int32 InInt, EApplicationState InAppState);
	void PlatformReceivedRemoteNotificationDelegate__DelegateSignature(const class FString& InString, EApplicationState InAppState);
	void PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(const TArray<uint8>& InArray);
	void PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(int32 InInt);
	void PlatformScreenOrientationChangedDelegate__DelegateSignature(EScreenOrientation InScreenOrientation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformGameInstance">();
	}
	static class UPlatformGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformGameInstance>();
	}
};
static_assert(alignof(UPlatformGameInstance) == 0x000008, "Wrong alignment on UPlatformGameInstance");
static_assert(sizeof(UPlatformGameInstance) == 0x0001F0, "Wrong size on UPlatformGameInstance");
static_assert(offsetof(UPlatformGameInstance, ApplicationWillDeactivateDelegate) == 0x000140, "Member 'UPlatformGameInstance::ApplicationWillDeactivateDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationHasReactivatedDelegate) == 0x000150, "Member 'UPlatformGameInstance::ApplicationHasReactivatedDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationWillEnterBackgroundDelegate) == 0x000160, "Member 'UPlatformGameInstance::ApplicationWillEnterBackgroundDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationHasEnteredForegroundDelegate) == 0x000170, "Member 'UPlatformGameInstance::ApplicationHasEnteredForegroundDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationWillTerminateDelegate) == 0x000180, "Member 'UPlatformGameInstance::ApplicationWillTerminateDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationRegisteredForRemoteNotificationsDelegate) == 0x000190, "Member 'UPlatformGameInstance::ApplicationRegisteredForRemoteNotificationsDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationRegisteredForUserNotificationsDelegate) == 0x0001A0, "Member 'UPlatformGameInstance::ApplicationRegisteredForUserNotificationsDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationFailedToRegisterForRemoteNotificationsDelegate) == 0x0001B0, "Member 'UPlatformGameInstance::ApplicationFailedToRegisterForRemoteNotificationsDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationReceivedRemoteNotificationDelegate) == 0x0001C0, "Member 'UPlatformGameInstance::ApplicationReceivedRemoteNotificationDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationReceivedLocalNotificationDelegate) == 0x0001D0, "Member 'UPlatformGameInstance::ApplicationReceivedLocalNotificationDelegate' has a wrong offset!");
static_assert(offsetof(UPlatformGameInstance, ApplicationReceivedScreenOrientationChangedNotificationDelegate) == 0x0001E0, "Member 'UPlatformGameInstance::ApplicationReceivedScreenOrientationChangedNotificationDelegate' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_RestraintTail
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleTypeDataSQEX_RestraintTail final : public UParticleModuleTypeDataBase
{
public:
	float                                         UpdateTime;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_THUNDER_GET_TYPE                        SetStartPointType;                                 // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_THUNDER_GET_TYPE                        SetEndPointType;                                   // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_RestraintTail">();
	}
	static class UParticleModuleTypeDataSQEX_RestraintTail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_RestraintTail>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_RestraintTail) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_RestraintTail");
static_assert(sizeof(UParticleModuleTypeDataSQEX_RestraintTail) == 0x000058, "Wrong size on UParticleModuleTypeDataSQEX_RestraintTail");
static_assert(offsetof(UParticleModuleTypeDataSQEX_RestraintTail, UpdateTime) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_RestraintTail::UpdateTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_RestraintTail, SetStartPointType) == 0x000054, "Member 'UParticleModuleTypeDataSQEX_RestraintTail::SetStartPointType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_RestraintTail, SetEndPointType) == 0x000055, "Member 'UParticleModuleTypeDataSQEX_RestraintTail::SetEndPointType' has a wrong offset!");

// Class Engine.MaterialExpressionReroute
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionReroute final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionReroute">();
	}
	static class UMaterialExpressionReroute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionReroute>();
	}
};
static_assert(alignof(UMaterialExpressionReroute) == 0x112F2730, "Wrong alignment on UMaterialExpressionReroute");
static_assert(sizeof(UMaterialExpressionReroute) == 0x112F2730, "Wrong size on UMaterialExpressionReroute");
static_assert(offsetof(UMaterialExpressionReroute, Input) == 0x000078, "Member 'UMaterialExpressionReroute::Input' has a wrong offset!");

// Class Engine.BlueprintSetLibrary
// 0x0000 (0x0040 - 0x0040)
class UBlueprintSetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool Set_Add(const TSet<int32>& TargetSet, const int32& NewItem);
	static void Set_AddItems(const TSet<int32>& TargetSet, const TArray<int32>& NewItems);
	static void Set_Clear(const TSet<int32>& TargetSet);
	static bool Set_Contains(const TSet<int32>& TargetSet, const int32& ItemToFind);
	static void Set_Difference(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>* Result);
	static void Set_Intersection(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>* Result);
	static int32 Set_Length(const TSet<int32>& TargetSet);
	static bool Set_Remove(const TSet<int32>& TargetSet, const int32& Item);
	static void Set_RemoveItems(const TSet<int32>& TargetSet, const TArray<int32>& Items);
	static void Set_ToArray(const TSet<int32>& A, TArray<int32>* Result);
	static void Set_Union(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>* Result);
	static void SetSetPropertyByName(class UObject* Object, class FName PropertyName, const TSet<int32>& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintSetLibrary">();
	}
	static class UBlueprintSetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintSetLibrary>();
	}
};
static_assert(alignof(UBlueprintSetLibrary) == 0x000008, "Wrong alignment on UBlueprintSetLibrary");
static_assert(sizeof(UBlueprintSetLibrary) == 0x000040, "Wrong size on UBlueprintSetLibrary");

// Class Engine.SQEX_ParticleSpawnVertexAssetUserData
// 0x0008 (0x0048 - 0x0040)
class USQEX_ParticleSpawnVertexAssetUserData final : public UAssetUserData
{
public:
	class USQEX_ParticleSpawnVertexDataAsset*     VertexData;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_ParticleSpawnVertexAssetUserData">();
	}
	static class USQEX_ParticleSpawnVertexAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_ParticleSpawnVertexAssetUserData>();
	}
};
static_assert(alignof(USQEX_ParticleSpawnVertexAssetUserData) == 0x000008, "Wrong alignment on USQEX_ParticleSpawnVertexAssetUserData");
static_assert(sizeof(USQEX_ParticleSpawnVertexAssetUserData) == 0x000048, "Wrong size on USQEX_ParticleSpawnVertexAssetUserData");
static_assert(offsetof(USQEX_ParticleSpawnVertexAssetUserData, VertexData) == 0x000040, "Member 'USQEX_ParticleSpawnVertexAssetUserData::VertexData' has a wrong offset!");

// Class Engine.ParticleModuleVelocity
// 0x0088 (0x00E0 - 0x0058)
class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                 StartVelocity;                                     // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StartVelocityRadial;                               // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVelocity">();
	}
	static class UParticleModuleVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVelocity>();
	}
};
static_assert(alignof(UParticleModuleVelocity) == 0x000008, "Wrong alignment on UParticleModuleVelocity");
static_assert(sizeof(UParticleModuleVelocity) == 0x0000E0, "Wrong size on UParticleModuleVelocity");
static_assert(offsetof(UParticleModuleVelocity, StartVelocity) == 0x000058, "Member 'UParticleModuleVelocity::StartVelocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleVelocity, StartVelocityRadial) == 0x0000A8, "Member 'UParticleModuleVelocity::StartVelocityRadial' has a wrong offset!");

// Class Engine.BoneMaskFilter
// 0x0010 (0x0050 - 0x0040)
class UBoneMaskFilter final : public UObject
{
public:
	TArray<struct FInputBlendPose>                BlendPoses;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoneMaskFilter">();
	}
	static class UBoneMaskFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoneMaskFilter>();
	}
};
static_assert(alignof(UBoneMaskFilter) == 0x000008, "Wrong alignment on UBoneMaskFilter");
static_assert(sizeof(UBoneMaskFilter) == 0x000050, "Wrong size on UBoneMaskFilter");
static_assert(offsetof(UBoneMaskFilter, BlendPoses) == 0x000040, "Member 'UBoneMaskFilter::BlendPoses' has a wrong offset!");

// Class Engine.BookMark
// 0x112E9AB0 (0x112E9AF0 - 0x0040)
class UBookMark final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x004C(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         HiddenLevels;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BookMark">();
	}
	static class UBookMark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBookMark>();
	}
};
static_assert(alignof(UBookMark) == 0x112E9AF0, "Wrong alignment on UBookMark");
static_assert(sizeof(UBookMark) == 0x112E9AF0, "Wrong size on UBookMark");
static_assert(offsetof(UBookMark, Location) == 0x000040, "Member 'UBookMark::Location' has a wrong offset!");
static_assert(offsetof(UBookMark, Rotation) == 0x00004C, "Member 'UBookMark::Rotation' has a wrong offset!");
static_assert(offsetof(UBookMark, HiddenLevels) == 0x000058, "Member 'UBookMark::HiddenLevels' has a wrong offset!");

// Class Engine.OnlineBlueprintCallProxyBase
// 0x0000 (0x0040 - 0x0040)
class UOnlineBlueprintCallProxyBase : public UObject
{
public:
	void Activate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineBlueprintCallProxyBase">();
	}
	static class UOnlineBlueprintCallProxyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineBlueprintCallProxyBase>();
	}
};
static_assert(alignof(UOnlineBlueprintCallProxyBase) == 0x000008, "Wrong alignment on UOnlineBlueprintCallProxyBase");
static_assert(sizeof(UOnlineBlueprintCallProxyBase) == 0x000040, "Wrong size on UOnlineBlueprintCallProxyBase");

// Class Engine.BookMark2D
// 0x112EA6E0 (0x112EA720 - 0x0040)
class UBookMark2D final : public UObject
{
public:
	float                                         Zoom2D;                                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Location;                                          // 0x0044(0x112EA720)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BookMark2D">();
	}
	static class UBookMark2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBookMark2D>();
	}
};
static_assert(alignof(UBookMark2D) == 0x112EA720, "Wrong alignment on UBookMark2D");
static_assert(sizeof(UBookMark2D) == 0x112EA720, "Wrong size on UBookMark2D");
static_assert(offsetof(UBookMark2D, Zoom2D) == 0x000040, "Member 'UBookMark2D::Zoom2D' has a wrong offset!");
static_assert(offsetof(UBookMark2D, Location) == 0x000044, "Member 'UBookMark2D::Location' has a wrong offset!");

// Class Engine.VectorFieldStatic
// 0x0088 (0x00E8 - 0x0060)
class UVectorFieldStatic final : public UVectorField
{
public:
	int32                                         SizeX;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeZ;                                             // 0x0068(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x7C];                                      // 0x006C(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VectorFieldStatic">();
	}
	static class UVectorFieldStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVectorFieldStatic>();
	}
};
static_assert(alignof(UVectorFieldStatic) == 0x000008, "Wrong alignment on UVectorFieldStatic");
static_assert(sizeof(UVectorFieldStatic) == 0x0000E8, "Wrong size on UVectorFieldStatic");
static_assert(offsetof(UVectorFieldStatic, SizeX) == 0x000060, "Member 'UVectorFieldStatic::SizeX' has a wrong offset!");
static_assert(offsetof(UVectorFieldStatic, SizeY) == 0x000064, "Member 'UVectorFieldStatic::SizeY' has a wrong offset!");
static_assert(offsetof(UVectorFieldStatic, SizeZ) == 0x000068, "Member 'UVectorFieldStatic::SizeZ' has a wrong offset!");

// Class Engine.BoxReflectionCapture
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ABoxReflectionCapture final : public AReflectionCapture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxReflectionCapture">();
	}
	static class ABoxReflectionCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoxReflectionCapture>();
	}
};
static_assert(alignof(ABoxReflectionCapture) == 0x1EF72E00, "Wrong alignment on ABoxReflectionCapture");
static_assert(sizeof(ABoxReflectionCapture) == 0x1EF72E00, "Wrong size on ABoxReflectionCapture");

// Class Engine.ParticleModuleVectorFieldRotation
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleVectorFieldRotation final : public UParticleModuleVectorFieldBase
{
public:
	struct FVector                                MinInitialRotation;                                // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxInitialRotation;                                // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldRotation">();
	}
	static class UParticleModuleVectorFieldRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldRotation>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldRotation) == 0x000008, "Wrong alignment on UParticleModuleVectorFieldRotation");
static_assert(sizeof(UParticleModuleVectorFieldRotation) == 0x000068, "Wrong size on UParticleModuleVectorFieldRotation");
static_assert(offsetof(UParticleModuleVectorFieldRotation, MinInitialRotation) == 0x000050, "Member 'UParticleModuleVectorFieldRotation::MinInitialRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldRotation, MaxInitialRotation) == 0x00005C, "Member 'UParticleModuleVectorFieldRotation::MaxInitialRotation' has a wrong offset!");

// Class Engine.MaterialExpressionPixelNormalWS
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPixelNormalWS final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPixelNormalWS">();
	}
	static class UMaterialExpressionPixelNormalWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPixelNormalWS>();
	}
};
static_assert(alignof(UMaterialExpressionPixelNormalWS) == 0x000008, "Wrong alignment on UMaterialExpressionPixelNormalWS");
static_assert(sizeof(UMaterialExpressionPixelNormalWS) == 0x000078, "Wrong size on UMaterialExpressionPixelNormalWS");

// Class Engine.ReflectionCaptureComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UReflectionCaptureComponent : public USceneComponent
{
public:
	class UBillboardComponent*                    CaptureOffsetComponent;                            // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReflectionSourceType                         ReflectionSourceType;                              // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           Cubemap;                                           // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceCubemapAngle;                                // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CaptureOffset;                                     // 0x0438(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MapBuildDataId;                                    // 0x0444(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflectionCaptureComponent">();
	}
	static class UReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReflectionCaptureComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UReflectionCaptureComponent) == 0x112E9AF0, "Wrong alignment on UReflectionCaptureComponent");
static_assert(sizeof(UReflectionCaptureComponent) == 0x112E9AF0, "Wrong size on UReflectionCaptureComponent");
static_assert(offsetof(UReflectionCaptureComponent, CaptureOffsetComponent) == 0x000418, "Member 'UReflectionCaptureComponent::CaptureOffsetComponent' has a wrong offset!");
static_assert(offsetof(UReflectionCaptureComponent, ReflectionSourceType) == 0x000420, "Member 'UReflectionCaptureComponent::ReflectionSourceType' has a wrong offset!");
static_assert(offsetof(UReflectionCaptureComponent, Cubemap) == 0x000428, "Member 'UReflectionCaptureComponent::Cubemap' has a wrong offset!");
static_assert(offsetof(UReflectionCaptureComponent, SourceCubemapAngle) == 0x000430, "Member 'UReflectionCaptureComponent::SourceCubemapAngle' has a wrong offset!");
static_assert(offsetof(UReflectionCaptureComponent, Brightness) == 0x000434, "Member 'UReflectionCaptureComponent::Brightness' has a wrong offset!");
static_assert(offsetof(UReflectionCaptureComponent, CaptureOffset) == 0x000438, "Member 'UReflectionCaptureComponent::CaptureOffset' has a wrong offset!");
static_assert(offsetof(UReflectionCaptureComponent, MapBuildDataId) == 0x000444, "Member 'UReflectionCaptureComponent::MapBuildDataId' has a wrong offset!");

// Class Engine.BoxReflectionCaptureComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UBoxReflectionCaptureComponent final : public UReflectionCaptureComponent
{
public:
	float                                         BoxTransitionDistance;                             // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          PreviewInfluenceBox;                               // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PreviewCaptureBox;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxReflectionCaptureComponent">();
	}
	static class UBoxReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxReflectionCaptureComponent>();
	}
};
static_assert(alignof(UBoxReflectionCaptureComponent) == 0x112E9AF0, "Wrong alignment on UBoxReflectionCaptureComponent");
static_assert(sizeof(UBoxReflectionCaptureComponent) == 0x112E9AF0, "Wrong size on UBoxReflectionCaptureComponent");
static_assert(offsetof(UBoxReflectionCaptureComponent, BoxTransitionDistance) == 0x000488, "Member 'UBoxReflectionCaptureComponent::BoxTransitionDistance' has a wrong offset!");
static_assert(offsetof(UBoxReflectionCaptureComponent, PreviewInfluenceBox) == 0x000490, "Member 'UBoxReflectionCaptureComponent::PreviewInfluenceBox' has a wrong offset!");
static_assert(offsetof(UBoxReflectionCaptureComponent, PreviewCaptureBox) == 0x000498, "Member 'UBoxReflectionCaptureComponent::PreviewCaptureBox' has a wrong offset!");

// Class Engine.PhysicsCollisionHandler
// 0x0018 (0x0058 - 0x0040)
class UPhysicsCollisionHandler final : public UObject
{
public:
	float                                         ImpactThreshold;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactReFireDelay;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultImpactSound;                                // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastImpactSoundTime;                               // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsCollisionHandler">();
	}
	static class UPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsCollisionHandler>();
	}
};
static_assert(alignof(UPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UPhysicsCollisionHandler");
static_assert(sizeof(UPhysicsCollisionHandler) == 0x000058, "Wrong size on UPhysicsCollisionHandler");
static_assert(offsetof(UPhysicsCollisionHandler, ImpactThreshold) == 0x000040, "Member 'UPhysicsCollisionHandler::ImpactThreshold' has a wrong offset!");
static_assert(offsetof(UPhysicsCollisionHandler, ImpactReFireDelay) == 0x000044, "Member 'UPhysicsCollisionHandler::ImpactReFireDelay' has a wrong offset!");
static_assert(offsetof(UPhysicsCollisionHandler, DefaultImpactSound) == 0x000048, "Member 'UPhysicsCollisionHandler::DefaultImpactSound' has a wrong offset!");
static_assert(offsetof(UPhysicsCollisionHandler, LastImpactSoundTime) == 0x000050, "Member 'UPhysicsCollisionHandler::LastImpactSoundTime' has a wrong offset!");

// Class Engine.Breakpoint
// 0x0018 (0x0058 - 0x0040)
class UBreakpoint final : public UObject
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdGraphNode*                           Node;                                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bStepOnce : 1;                                     // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bStepOnce_WasPreviouslyDisabled : 1;               // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bStepOnce_RemoveAfterHit : 1;                      // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Breakpoint">();
	}
	static class UBreakpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakpoint>();
	}
};
static_assert(alignof(UBreakpoint) == 0x000008, "Wrong alignment on UBreakpoint");
static_assert(sizeof(UBreakpoint) == 0x000058, "Wrong size on UBreakpoint");
static_assert(offsetof(UBreakpoint, Node) == 0x000048, "Member 'UBreakpoint::Node' has a wrong offset!");

// Class Engine.SQEX_BrushBuilderFile
// 0x0010 (0x00A8 - 0x0098)
class USQEX_BrushBuilderFile final : public UBrushBuilder
{
public:
	class FString                                 M_FilePath;                                        // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_BrushBuilderFile">();
	}
	static class USQEX_BrushBuilderFile* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_BrushBuilderFile>();
	}
};
static_assert(alignof(USQEX_BrushBuilderFile) == 0x000008, "Wrong alignment on USQEX_BrushBuilderFile");
static_assert(sizeof(USQEX_BrushBuilderFile) == 0x0000A8, "Wrong size on USQEX_BrushBuilderFile");
static_assert(offsetof(USQEX_BrushBuilderFile, M_FilePath) == 0x000098, "Member 'USQEX_BrushBuilderFile::M_FilePath' has a wrong offset!");

// Class Engine.MaterialExpressionTextureCoordinate
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionTextureCoordinate final : public UMaterialExpression
{
public:
	int32                                         CoordinateIndex;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTiling;                                           // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VTiling;                                           // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UnMirrorU : 1;                                     // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UnMirrorV : 1;                                     // 0x0084(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureCoordinate">();
	}
	static class UMaterialExpressionTextureCoordinate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureCoordinate>();
	}
};
static_assert(alignof(UMaterialExpressionTextureCoordinate) == 0x000008, "Wrong alignment on UMaterialExpressionTextureCoordinate");
static_assert(sizeof(UMaterialExpressionTextureCoordinate) == 0x000088, "Wrong size on UMaterialExpressionTextureCoordinate");
static_assert(offsetof(UMaterialExpressionTextureCoordinate, CoordinateIndex) == 0x000078, "Member 'UMaterialExpressionTextureCoordinate::CoordinateIndex' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureCoordinate, UTiling) == 0x00007C, "Member 'UMaterialExpressionTextureCoordinate::UTiling' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureCoordinate, VTiling) == 0x000080, "Member 'UMaterialExpressionTextureCoordinate::VTiling' has a wrong offset!");

// Class Engine.MaterialExpressionPanner
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionPanner final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinate;                                        // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Time;                                              // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Speed;                                             // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         SpeedX;                                            // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedY;                                            // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ConstCoordinate;                                   // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFractionalPart;                                   // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSQEXAbsoluteValue;                                // 0x012D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPanner">();
	}
	static class UMaterialExpressionPanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPanner>();
	}
};
static_assert(alignof(UMaterialExpressionPanner) == 0x112F2730, "Wrong alignment on UMaterialExpressionPanner");
static_assert(sizeof(UMaterialExpressionPanner) == 0x112F2730, "Wrong size on UMaterialExpressionPanner");
static_assert(offsetof(UMaterialExpressionPanner, Coordinate) == 0x000078, "Member 'UMaterialExpressionPanner::Coordinate' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, Time) == 0x0000B0, "Member 'UMaterialExpressionPanner::Time' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, Speed) == 0x0000E8, "Member 'UMaterialExpressionPanner::Speed' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, SpeedX) == 0x000120, "Member 'UMaterialExpressionPanner::SpeedX' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, SpeedY) == 0x000124, "Member 'UMaterialExpressionPanner::SpeedY' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, ConstCoordinate) == 0x000128, "Member 'UMaterialExpressionPanner::ConstCoordinate' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, bFractionalPart) == 0x00012C, "Member 'UMaterialExpressionPanner::bFractionalPart' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPanner, bSQEXAbsoluteValue) == 0x00012D, "Member 'UMaterialExpressionPanner::bSQEXAbsoluteValue' has a wrong offset!");

// Class Engine.BrushShape
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ABrushShape final : public ABrush
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrushShape">();
	}
	static class ABrushShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrushShape>();
	}
};
static_assert(alignof(ABrushShape) == 0x1EF72E00, "Wrong alignment on ABrushShape");
static_assert(sizeof(ABrushShape) == 0x1EF72E00, "Wrong size on ABrushShape");

// Class Engine.ParticleModuleVectorFieldLocal
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleVectorFieldLocal final : public UParticleModuleVectorFieldBase
{
public:
	class UVectorField*                           VectorField;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeTranslation;                               // 0x0058(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0064(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale3D;                                   // 0x0070(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tightness;                                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreComponentTransform : 1;                     // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTileX : 1;                                        // 0x0084(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTileY : 1;                                        // 0x0084(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTileZ : 1;                                        // 0x0084(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFixDT : 1;                                     // 0x0084(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldLocal">();
	}
	static class UParticleModuleVectorFieldLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldLocal>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldLocal) == 0x112E9AF0, "Wrong alignment on UParticleModuleVectorFieldLocal");
static_assert(sizeof(UParticleModuleVectorFieldLocal) == 0x112E9AF0, "Wrong size on UParticleModuleVectorFieldLocal");
static_assert(offsetof(UParticleModuleVectorFieldLocal, VectorField) == 0x000050, "Member 'UParticleModuleVectorFieldLocal::VectorField' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldLocal, RelativeTranslation) == 0x000058, "Member 'UParticleModuleVectorFieldLocal::RelativeTranslation' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldLocal, RelativeRotation) == 0x000064, "Member 'UParticleModuleVectorFieldLocal::RelativeRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldLocal, RelativeScale3D) == 0x000070, "Member 'UParticleModuleVectorFieldLocal::RelativeScale3D' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldLocal, Intensity) == 0x00007C, "Member 'UParticleModuleVectorFieldLocal::Intensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldLocal, Tightness) == 0x000080, "Member 'UParticleModuleVectorFieldLocal::Tightness' has a wrong offset!");

// Class Engine.ButtonStyleAsset
// 0x114650A0 (0x114650E0 - 0x0040)
class UButtonStyleAsset final : public UObject
{
public:
	struct FButtonStyle                           ButtonStyle;                                       // 0x0040(0x114650E0)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonStyleAsset">();
	}
	static class UButtonStyleAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonStyleAsset>();
	}
};
static_assert(alignof(UButtonStyleAsset) == 0x114650E0, "Wrong alignment on UButtonStyleAsset");
static_assert(sizeof(UButtonStyleAsset) == 0x114650E0, "Wrong size on UButtonStyleAsset");
static_assert(offsetof(UButtonStyleAsset, ButtonStyle) == 0x000040, "Member 'UButtonStyleAsset::ButtonStyle' has a wrong offset!");

// Class Engine.MaterialExpressionSphereMask
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSphereMask final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Radius;                                            // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Hardness;                                          // 0x0120(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         AttenuationRadius;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardnessPercent;                                   // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSphereMask">();
	}
	static class UMaterialExpressionSphereMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSphereMask>();
	}
};
static_assert(alignof(UMaterialExpressionSphereMask) == 0x112F2730, "Wrong alignment on UMaterialExpressionSphereMask");
static_assert(sizeof(UMaterialExpressionSphereMask) == 0x112F2730, "Wrong size on UMaterialExpressionSphereMask");
static_assert(offsetof(UMaterialExpressionSphereMask, A) == 0x000078, "Member 'UMaterialExpressionSphereMask::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSphereMask, B) == 0x0000B0, "Member 'UMaterialExpressionSphereMask::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSphereMask, Radius) == 0x0000E8, "Member 'UMaterialExpressionSphereMask::Radius' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSphereMask, Hardness) == 0x000120, "Member 'UMaterialExpressionSphereMask::Hardness' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSphereMask, AttenuationRadius) == 0x000158, "Member 'UMaterialExpressionSphereMask::AttenuationRadius' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSphereMask, HardnessPercent) == 0x00015C, "Member 'UMaterialExpressionSphereMask::HardnessPercent' has a wrong offset!");

// Class Engine.CameraAnim
// 0x07A0 (0x07E0 - 0x0040)
class UCameraAnim final : public UObject
{
public:
	class UInterpGroup*                           CameraInterpGroup;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpGroup*                           M_CameraInterestInterpGroup;                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpGroup*                           M_CameraUpVectorInterpGroup;                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpGroup*                           M_PreviewInterestInterpGroup;                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpGroup*                           M_PreviewUpVectorInterpGroup;                      // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLength;                                        // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x006C(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bRelativeToInitialTransform : 1;                   // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRelativeToInitialFOV : 1;                         // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseFOV;                                           // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   BasePostProcessSettings;                           // 0x0090(0x112EAE80)(NativeAccessSpecifierPublic)
	float                                         BasePostProcessBlendWeight;                        // 0x07D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D4[0xC];                                      // 0x07D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAnim">();
	}
	static class UCameraAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAnim>();
	}
};
static_assert(alignof(UCameraAnim) == 0x000008, "Wrong alignment on UCameraAnim");
static_assert(sizeof(UCameraAnim) == 0x0007E0, "Wrong size on UCameraAnim");
static_assert(offsetof(UCameraAnim, CameraInterpGroup) == 0x000040, "Member 'UCameraAnim::CameraInterpGroup' has a wrong offset!");
static_assert(offsetof(UCameraAnim, M_CameraInterestInterpGroup) == 0x000048, "Member 'UCameraAnim::M_CameraInterestInterpGroup' has a wrong offset!");
static_assert(offsetof(UCameraAnim, M_CameraUpVectorInterpGroup) == 0x000050, "Member 'UCameraAnim::M_CameraUpVectorInterpGroup' has a wrong offset!");
static_assert(offsetof(UCameraAnim, M_PreviewInterestInterpGroup) == 0x000058, "Member 'UCameraAnim::M_PreviewInterestInterpGroup' has a wrong offset!");
static_assert(offsetof(UCameraAnim, M_PreviewUpVectorInterpGroup) == 0x000060, "Member 'UCameraAnim::M_PreviewUpVectorInterpGroup' has a wrong offset!");
static_assert(offsetof(UCameraAnim, AnimLength) == 0x000068, "Member 'UCameraAnim::AnimLength' has a wrong offset!");
static_assert(offsetof(UCameraAnim, BoundingBox) == 0x00006C, "Member 'UCameraAnim::BoundingBox' has a wrong offset!");
static_assert(offsetof(UCameraAnim, BaseFOV) == 0x00008C, "Member 'UCameraAnim::BaseFOV' has a wrong offset!");
static_assert(offsetof(UCameraAnim, BasePostProcessSettings) == 0x000090, "Member 'UCameraAnim::BasePostProcessSettings' has a wrong offset!");
static_assert(offsetof(UCameraAnim, BasePostProcessBlendWeight) == 0x0007D0, "Member 'UCameraAnim::BasePostProcessBlendWeight' has a wrong offset!");

// Class Engine.CameraAnimInst
// 0x0120 (0x0160 - 0x0040)
class UCameraAnimInst final : public UObject
{
public:
	class UCameraAnim*                            CamAnim;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpGroupInst*                       InterpGroupInst;                                   // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpGroupInst*                       M_InterestInterpGroupInst;                         // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterpGroupInst*                       M_UpVectorInterpGroupInst;                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x14];                                      // 0x007C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpTrackMove*                       MoveTrack;                                         // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrackInstMove*                   MoveInst;                                          // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrackMove*                       M_InterestMoveTrack;                               // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrackInstMove*                   M_InterestMoveInst;                                // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrackMove*                       M_UpVectorMoveTrack;                               // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrackInstMove*                   M_UpVectorMoveInst;                                // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x9F];                                      // 0x00C1(0x009F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDuration(float NewDuration);
	void SetScale(float NewDuration);
	void Stop(bool bImmediate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAnimInst">();
	}
	static class UCameraAnimInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAnimInst>();
	}
};
static_assert(alignof(UCameraAnimInst) == 0x000008, "Wrong alignment on UCameraAnimInst");
static_assert(sizeof(UCameraAnimInst) == 0x000160, "Wrong size on UCameraAnimInst");
static_assert(offsetof(UCameraAnimInst, CamAnim) == 0x000040, "Member 'UCameraAnimInst::CamAnim' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, InterpGroupInst) == 0x000048, "Member 'UCameraAnimInst::InterpGroupInst' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, M_InterestInterpGroupInst) == 0x000050, "Member 'UCameraAnimInst::M_InterestInterpGroupInst' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, M_UpVectorInterpGroupInst) == 0x000058, "Member 'UCameraAnimInst::M_UpVectorInterpGroupInst' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, PlayRate) == 0x000078, "Member 'UCameraAnimInst::PlayRate' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, MoveTrack) == 0x000090, "Member 'UCameraAnimInst::MoveTrack' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, MoveInst) == 0x000098, "Member 'UCameraAnimInst::MoveInst' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, M_InterestMoveTrack) == 0x0000A0, "Member 'UCameraAnimInst::M_InterestMoveTrack' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, M_InterestMoveInst) == 0x0000A8, "Member 'UCameraAnimInst::M_InterestMoveInst' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, M_UpVectorMoveTrack) == 0x0000B0, "Member 'UCameraAnimInst::M_UpVectorMoveTrack' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, M_UpVectorMoveInst) == 0x0000B8, "Member 'UCameraAnimInst::M_UpVectorMoveInst' has a wrong offset!");
static_assert(offsetof(UCameraAnimInst, PlaySpace) == 0x0000C0, "Member 'UCameraAnimInst::PlaySpace' has a wrong offset!");

// Class Engine.CameraBlockingVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ACameraBlockingVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBlockingVolume">();
	}
	static class ACameraBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraBlockingVolume>();
	}
};
static_assert(alignof(ACameraBlockingVolume) == 0x1EF72E00, "Wrong alignment on ACameraBlockingVolume");
static_assert(sizeof(ACameraBlockingVolume) == 0x1EF72E00, "Wrong size on ACameraBlockingVolume");

// Class Engine.SoundNodeLooping
// 0x0008 (0x0058 - 0x0050)
class USoundNodeLooping final : public USoundNode
{
public:
	int32                                         LoopCount;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoopIndefinitely : 1;                             // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeLooping">();
	}
	static class USoundNodeLooping* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeLooping>();
	}
};
static_assert(alignof(USoundNodeLooping) == 0x000008, "Wrong alignment on USoundNodeLooping");
static_assert(sizeof(USoundNodeLooping) == 0x000058, "Wrong size on USoundNodeLooping");
static_assert(offsetof(USoundNodeLooping, LoopCount) == 0x000050, "Member 'USoundNodeLooping::LoopCount' has a wrong offset!");

// Class Engine.CameraModifier
// 0x0020 (0x0060 - 0x0040)
class UCameraModifier : public UObject
{
public:
	uint8                                         bDebug : 1;                                        // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExclusive : 1;                                    // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         Priority;                                          // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   CameraOwner;                                       // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlphaInTime;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlphaOutTime;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Alpha;                                             // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintModifyCamera(float DeltaTime, const struct FVector& ViewLocation, const struct FRotator& ViewRotation, float FOV, struct FVector* NewViewLocation, struct FRotator* NewViewRotation, float* NewFOV);
	void BlueprintModifyPostProcess(float DeltaTime, float* PostProcessBlendWeight, struct FPostProcessSettings* PostProcessSettings);
	void DisableModifier(bool bImmediate);
	void EnableModifier();

	class AActor* GetViewTarget() const;
	bool IsDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier">();
	}
	static class UCameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier>();
	}
};
static_assert(alignof(UCameraModifier) == 0x000008, "Wrong alignment on UCameraModifier");
static_assert(sizeof(UCameraModifier) == 0x000060, "Wrong size on UCameraModifier");
static_assert(offsetof(UCameraModifier, Priority) == 0x000044, "Member 'UCameraModifier::Priority' has a wrong offset!");
static_assert(offsetof(UCameraModifier, CameraOwner) == 0x000048, "Member 'UCameraModifier::CameraOwner' has a wrong offset!");
static_assert(offsetof(UCameraModifier, AlphaInTime) == 0x000050, "Member 'UCameraModifier::AlphaInTime' has a wrong offset!");
static_assert(offsetof(UCameraModifier, AlphaOutTime) == 0x000054, "Member 'UCameraModifier::AlphaOutTime' has a wrong offset!");
static_assert(offsetof(UCameraModifier, Alpha) == 0x000058, "Member 'UCameraModifier::Alpha' has a wrong offset!");

// Class Engine.CameraModifier_CameraShake
// 0x0018 (0x0078 - 0x0060)
class UCameraModifier_CameraShake final : public UCameraModifier
{
public:
	TArray<class UCameraShake*>                   ActiveShakes;                                      // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SplitScreenShakeScale;                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_CameraShake">();
	}
	static class UCameraModifier_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_CameraShake>();
	}
};
static_assert(alignof(UCameraModifier_CameraShake) == 0x000008, "Wrong alignment on UCameraModifier_CameraShake");
static_assert(sizeof(UCameraModifier_CameraShake) == 0x000078, "Wrong size on UCameraModifier_CameraShake");
static_assert(offsetof(UCameraModifier_CameraShake, ActiveShakes) == 0x000060, "Member 'UCameraModifier_CameraShake::ActiveShakes' has a wrong offset!");
static_assert(offsetof(UCameraModifier_CameraShake, SplitScreenShakeScale) == 0x000070, "Member 'UCameraModifier_CameraShake::SplitScreenShakeScale' has a wrong offset!");

// Class Engine.ParticleModuleAttractorParticle
// 0x0090 (0x00E0 - 0x0050)
class UParticleModuleAttractorParticle final : public UParticleModuleAttractorBase
{
public:
	class FName                                   EmitterName;                                       // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Range;                                             // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bStrengthByDistance : 1;                           // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Strength;                                          // 0x0098(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAffectBaseVelocity : 1;                           // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAttractorParticleSelectionMethod             SelectionMethod;                                   // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bRenewSource : 1;                                  // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritSourceVel : 1;                             // 0x00D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastSelIndex;                                      // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAttractorParticle">();
	}
	static class UParticleModuleAttractorParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAttractorParticle>();
	}
};
static_assert(alignof(UParticleModuleAttractorParticle) == 0x000008, "Wrong alignment on UParticleModuleAttractorParticle");
static_assert(sizeof(UParticleModuleAttractorParticle) == 0x0000E0, "Wrong size on UParticleModuleAttractorParticle");
static_assert(offsetof(UParticleModuleAttractorParticle, EmitterName) == 0x000050, "Member 'UParticleModuleAttractorParticle::EmitterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorParticle, Range) == 0x000058, "Member 'UParticleModuleAttractorParticle::Range' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorParticle, Strength) == 0x000098, "Member 'UParticleModuleAttractorParticle::Strength' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorParticle, SelectionMethod) == 0x0000D4, "Member 'UParticleModuleAttractorParticle::SelectionMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorParticle, LastSelIndex) == 0x0000DC, "Member 'UParticleModuleAttractorParticle::LastSelIndex' has a wrong offset!");

// Class Engine.MaterialExpressionAtmosphericLightColor
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionAtmosphericLightColor final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAtmosphericLightColor">();
	}
	static class UMaterialExpressionAtmosphericLightColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAtmosphericLightColor>();
	}
};
static_assert(alignof(UMaterialExpressionAtmosphericLightColor) == 0x000008, "Wrong alignment on UMaterialExpressionAtmosphericLightColor");
static_assert(sizeof(UMaterialExpressionAtmosphericLightColor) == 0x000078, "Wrong size on UMaterialExpressionAtmosphericLightColor");

// Class Engine.Canvas
// 0x02A0 (0x02E0 - 0x0040)
class UCanvas final : public UObject
{
public:
	float                                         OrgX;                                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrgY;                                              // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClipX;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClipY;                                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DrawColor;                                         // 0x0050(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCenterX : 1;                                      // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCenterY : 1;                                      // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoSmooth : 1;                                     // 0x0054(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SizeX;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 ColorModulate;                                     // 0x0060(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultTexture;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GradientTexture0;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         ReporterGraph;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x258];                                     // 0x0088(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection);
	void K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize);
	void K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness);
	void K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor);
	void K2_DrawMaterial(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint);
	void K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, const TArray<struct FCanvasUVTri>& Triangles);
	void K2_DrawPolygon(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int32 NumberOfSides, const struct FLinearColor& RenderColor);
	void K2_DrawText(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& ScreenPosition, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor);
	void K2_DrawTexture(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, EBlendMode BlendMode, float Rotation, const struct FVector2D& PivotPoint);
	void K2_DrawTriangle(class UTexture* RenderTexture, const TArray<struct FCanvasUVTri>& Triangles);
	struct FVector K2_Project(const struct FVector& WorldLocation);
	struct FVector2D K2_StrLen(class UFont* RenderFont, const class FString& RenderText);
	struct FVector2D K2_TextSize(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& Scale);
	void SQEX_K2_DrawMaterial_ColorAndAlpha(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Canvas">();
	}
	static class UCanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanvas>();
	}
};
static_assert(alignof(UCanvas) == 0x000008, "Wrong alignment on UCanvas");
static_assert(sizeof(UCanvas) == 0x0002E0, "Wrong size on UCanvas");
static_assert(offsetof(UCanvas, OrgX) == 0x000040, "Member 'UCanvas::OrgX' has a wrong offset!");
static_assert(offsetof(UCanvas, OrgY) == 0x000044, "Member 'UCanvas::OrgY' has a wrong offset!");
static_assert(offsetof(UCanvas, ClipX) == 0x000048, "Member 'UCanvas::ClipX' has a wrong offset!");
static_assert(offsetof(UCanvas, ClipY) == 0x00004C, "Member 'UCanvas::ClipY' has a wrong offset!");
static_assert(offsetof(UCanvas, DrawColor) == 0x000050, "Member 'UCanvas::DrawColor' has a wrong offset!");
static_assert(offsetof(UCanvas, SizeX) == 0x000058, "Member 'UCanvas::SizeX' has a wrong offset!");
static_assert(offsetof(UCanvas, SizeY) == 0x00005C, "Member 'UCanvas::SizeY' has a wrong offset!");
static_assert(offsetof(UCanvas, ColorModulate) == 0x000060, "Member 'UCanvas::ColorModulate' has a wrong offset!");
static_assert(offsetof(UCanvas, DefaultTexture) == 0x000070, "Member 'UCanvas::DefaultTexture' has a wrong offset!");
static_assert(offsetof(UCanvas, GradientTexture0) == 0x000078, "Member 'UCanvas::GradientTexture0' has a wrong offset!");
static_assert(offsetof(UCanvas, ReporterGraph) == 0x000080, "Member 'UCanvas::ReporterGraph' has a wrong offset!");

// Class Engine.SoundNodeDoppler
// 0x0008 (0x0058 - 0x0050)
class USoundNodeDoppler final : public USoundNode
{
public:
	float                                         DopplerIntensity;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeDoppler">();
	}
	static class USoundNodeDoppler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeDoppler>();
	}
};
static_assert(alignof(USoundNodeDoppler) == 0x000008, "Wrong alignment on USoundNodeDoppler");
static_assert(sizeof(USoundNodeDoppler) == 0x000058, "Wrong size on USoundNodeDoppler");
static_assert(offsetof(USoundNodeDoppler, DopplerIntensity) == 0x000050, "Member 'USoundNodeDoppler::DopplerIntensity' has a wrong offset!");

// Class Engine.TextureRenderTarget
// 0x0000 (0x112E8D20 - 0x112E8D20)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UTextureRenderTarget : public UTexture
{
public:
	float                                         TargetGamma;                                       // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureRenderTarget">();
	}
	static class UTextureRenderTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureRenderTarget>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTextureRenderTarget) == 0x112E8D20, "Wrong alignment on UTextureRenderTarget");
static_assert(sizeof(UTextureRenderTarget) == 0x112E8D20, "Wrong size on UTextureRenderTarget");
static_assert(offsetof(UTextureRenderTarget, TargetGamma) == 0x0000F8, "Member 'UTextureRenderTarget::TargetGamma' has a wrong offset!");

// Class Engine.TextureRenderTarget2D
// 0x2160 (0x112EAE80 - 0x112E8D20)
#pragma pack(push, 0x1)
class alignas(0x112EAE80) UTextureRenderTarget2D : public UTextureRenderTarget
{
public:
	int32                                         SizeX;                                             // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ClearColor;                                        // 0x0108(0x112EAE80)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureAddress                               AddressX;                                          // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureAddress                               AddressY;                                          // 0x0119(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x2];                                      // 0x011A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceLinearGamma : 1;                             // 0x011C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHDR : 1;                                          // 0x011C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETextureRenderTargetFormat                    RenderTargetFormat;                                // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bGPUSharedFlag : 1;                                // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoGenerateMips : 1;                             // 0x0124(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPixelFormat                                  OverrideFormat;                                    // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0xF];                                      // 0x0129(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureRenderTarget2D">();
	}
	static class UTextureRenderTarget2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureRenderTarget2D>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTextureRenderTarget2D) == 0x112EAE80, "Wrong alignment on UTextureRenderTarget2D");
static_assert(sizeof(UTextureRenderTarget2D) == 0x112EAE80, "Wrong size on UTextureRenderTarget2D");
static_assert(offsetof(UTextureRenderTarget2D, SizeX) == 0x000100, "Member 'UTextureRenderTarget2D::SizeX' has a wrong offset!");
static_assert(offsetof(UTextureRenderTarget2D, SizeY) == 0x000104, "Member 'UTextureRenderTarget2D::SizeY' has a wrong offset!");
static_assert(offsetof(UTextureRenderTarget2D, ClearColor) == 0x000108, "Member 'UTextureRenderTarget2D::ClearColor' has a wrong offset!");
static_assert(offsetof(UTextureRenderTarget2D, AddressX) == 0x000118, "Member 'UTextureRenderTarget2D::AddressX' has a wrong offset!");
static_assert(offsetof(UTextureRenderTarget2D, AddressY) == 0x000119, "Member 'UTextureRenderTarget2D::AddressY' has a wrong offset!");
static_assert(offsetof(UTextureRenderTarget2D, RenderTargetFormat) == 0x000120, "Member 'UTextureRenderTarget2D::RenderTargetFormat' has a wrong offset!");
static_assert(offsetof(UTextureRenderTarget2D, OverrideFormat) == 0x000128, "Member 'UTextureRenderTarget2D::OverrideFormat' has a wrong offset!");

// Class Engine.MaterialExpressionSceneTexelSize
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionSceneTexelSize final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSceneTexelSize">();
	}
	static class UMaterialExpressionSceneTexelSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSceneTexelSize>();
	}
};
static_assert(alignof(UMaterialExpressionSceneTexelSize) == 0x000008, "Wrong alignment on UMaterialExpressionSceneTexelSize");
static_assert(sizeof(UMaterialExpressionSceneTexelSize) == 0x000078, "Wrong size on UMaterialExpressionSceneTexelSize");

// Class Engine.CanvasRenderTarget2D
// 0x0000 (0x112EAE80 - 0x112EAE80)
class UCanvasRenderTarget2D final : public UTextureRenderTarget2D
{
public:
	UMulticastDelegateProperty_                   OnCanvasRenderTargetUpdate;                        // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UWorld>                  World;                                             // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldClearRenderTargetOnReceiveUpdate;           // 0x0150(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCanvasRenderTarget2D* CreateCanvasRenderTarget2D(class UObject* WorldContextObject, TSubclassOf<class UCanvasRenderTarget2D> CanvasRenderTarget2DClass, int32 Width, int32 Height);

	void GetSize(int32* Width, int32* Height);
	void ReceiveUpdate(class UCanvas* Canvas, int32 Width, int32 Height);
	void UpdateResource();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanvasRenderTarget2D">();
	}
	static class UCanvasRenderTarget2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanvasRenderTarget2D>();
	}
};
static_assert(alignof(UCanvasRenderTarget2D) == 0x112EAE80, "Wrong alignment on UCanvasRenderTarget2D");
static_assert(sizeof(UCanvasRenderTarget2D) == 0x112EAE80, "Wrong size on UCanvasRenderTarget2D");
static_assert(offsetof(UCanvasRenderTarget2D, OnCanvasRenderTargetUpdate) == 0x000138, "Member 'UCanvasRenderTarget2D::OnCanvasRenderTargetUpdate' has a wrong offset!");
static_assert(offsetof(UCanvasRenderTarget2D, World) == 0x000148, "Member 'UCanvasRenderTarget2D::World' has a wrong offset!");
static_assert(offsetof(UCanvasRenderTarget2D, bShouldClearRenderTargetOnReceiveUpdate) == 0x000150, "Member 'UCanvasRenderTarget2D::bShouldClearRenderTargetOnReceiveUpdate' has a wrong offset!");

// Class Engine.CharacterMovementComponent
// 0x115E4CCF (0x115F7730 - 0x12A61)
#pragma pack(push, 0x1)
class alignas(0x115F7730) UCharacterMovementComponent : public UPawnMovementComponent
{
public:
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             CharacterOwner;                                    // 0x0298(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplyGravityWhileJumping : 1;                     // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZVelocity;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOffJumpZFactor;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngle;                                // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkableFloorZ;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMovementMode                                 MovementMode;                                      // 0x02BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CustomMovementMode;                                // 0x02BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE[0x22];                                     // 0x02BE(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundFriction;                                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeed;                                      // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedCrouched;                              // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSwimSpeed;                                      // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlySpeed;                                       // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCustomMovementSpeed;                            // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAnalogWalkSpeed;                                // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactor;                             // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFriction;                                   // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSeparateBrakingFriction : 1;                   // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakingDecelerationWalking;                        // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFalling;                        // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationSwimming;                       // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFlying;                         // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControl;                                        // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlBoostMultiplier;                         // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlBoostVelocityThreshold;                  // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingLateralFriction;                            // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchedHalfHeight;                                // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buoyancy;                                          // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchRadiusThreshold;                              // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchAdditionalHeight;                             // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationRate;                                      // 0x033C(0x112E9AF0)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUseControllerDesiredRotation : 1;                 // 0x0348(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOrientRotationToMovement : 1;                     // 0x0348(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSweepWhileNavWalking : 1;                         // 0x0348(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_348_3 : 1;                                  // 0x0348(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bMovementInProgress : 1;                           // 0x0348(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableScopedMovementUpdates : 1;                  // 0x0348(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceMaxAccel : 1;                                // 0x0348(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRunPhysicsWithNoController : 1;                   // 0x0348(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceNextFloorCheck : 1;                          // 0x0349(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShrinkProxyCapsule : 1;                           // 0x0349(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanWalkOffLedges : 1;                             // 0x0349(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanWalkOffLedgesWhenCrouching : 1;                // 0x0349(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_349_4 : 1;                                  // 0x0349(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bDeferUpdateMoveComponent : 1;                     // 0x0349(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DeferredUpdatedMoveComponent;                      // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOutOfWaterStepHeight;                           // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutofWaterZ;                                       // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePhysicsInteraction;                         // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTouchForceScaledToMass;                           // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPushForceScaledToMass;                            // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPushForceUsingZOffset;                            // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePushForceToVelocity;                         // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandingDownwardForceScale;                        // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialPushForceFactor;                            // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushForceFactor;                                   // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushForcePointZOffsetFactor;                       // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchForceFactor;                                  // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTouchForce;                                     // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTouchForce;                                     // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepulsionForce;                                    // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bForceBraking : 1;                                 // 0x038C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchedSpeedMultiplier;                           // 0x0390(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperImpactNormalScale;                            // 0x0394(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x0398(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastUpdateLocation;                                // 0x03A4(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FQuat                                  LastUpdateRotation;                                // 0x03B0(0x112E9D50)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LastUpdateVelocity;                                // 0x03C0(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerLastTransformUpdateTimeStamp;                // 0x03CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingImpulseToApply;                             // 0x03D0(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingForceToApply;                               // 0x03DC(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnalogInputModifier;                               // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x8];                                      // 0x03EC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSimulationTimeStep;                             // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithGeometry;                      // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithGeometryAsProxy;               // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithPawn;                          // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationWithPawnAsProxy;                   // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkSimulatedSmoothLocationTime;                // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkSimulatedSmoothRotationTime;                // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ListenServerNetworkSimulatedSmoothLocationTime;    // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ListenServerNetworkSimulatedSmoothRotationTime;    // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetProxyShrinkRadius;                              // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetProxyShrinkHalfHeight;                          // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkMaxSmoothUpdateDistance;                    // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkNoSmoothUpdateDistance;                     // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkSmoothingMode                         NetworkSmoothingMode;                              // 0x042C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LedgeCheckThreshold;                               // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOutOfWaterPitch;                               // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFindFloorResult                       CurrentFloor;                                      // 0x0438(0x112F5920)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMovementMode                                 DefaultLandMovementMode;                           // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 DefaultWaterMovementMode;                          // 0x04D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 GroundMovementMode;                                // 0x04D2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D3[0x1];                                      // 0x04D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bMaintainHorizontalGroundVelocity : 1;             // 0x04D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseVelocityX : 1;                          // 0x04D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseVelocityY : 1;                          // 0x04D4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseVelocityZ : 1;                          // 0x04D4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImpartBaseAngularVelocity : 1;                    // 0x04D4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bJustTeleported : 1;                               // 0x04D4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetworkUpdateReceived : 1;                        // 0x04D4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNetworkMovementModeChanged : 1;                   // 0x04D4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreClientMovementErrorChecksAndCorrection : 1; // 0x04D5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNotifyApex : 1;                                   // 0x04D5(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheatFlying : 1;                                  // 0x04D5(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToCrouch : 1;                                // 0x04D5(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCrouchMaintainsBaseLocation : 1;                  // 0x04D5(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreBaseRotation : 1;                           // 0x04D5(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFastAttachedMove : 1;                             // 0x04D5(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysCheckFloor : 1;                             // 0x04D5(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFlatBaseForFloorChecks : 1;                    // 0x04D6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPerformingJumpOff : 1;                            // 0x04D6(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToLeaveNavWalking : 1;                       // 0x04D6(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseRVOAvoidance : 1;                              // 0x04D6(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequestedMoveUseAcceleration : 1;                 // 0x04D6(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_4D6_5 : 1;                                  // 0x04D6(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bHasRequestedVelocity : 1;                         // 0x04D6(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequestedMoveWithMaxSpeed : 1;                    // 0x04D6(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWasAvoidanceUpdated : 1;                          // 0x04D7(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_4D7_1 : 2;                                  // 0x04D7(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bProjectNavMeshWalking : 1;                        // 0x04D7(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProjectNavMeshOnBothWorldChannels : 1;            // 0x04D7(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4D8[0x10];                                     // 0x04D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidanceConsiderationRadius;                      // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RequestedVelocity;                                 // 0x04EC(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AvoidanceUID;                                      // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      AvoidanceGroup;                                    // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      GroupsToAvoid;                                     // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FNavAvoidanceMask                      GroupsToIgnore;                                    // 0x0504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         AvoidanceWeight;                                   // 0x0508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PendingLaunchVelocity;                             // 0x050C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0xA0];                                     // 0x0518(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavMeshProjectionInterval;                         // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionTimer;                            // 0x05BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionInterpSpeed;                      // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionHeightScaleUp;                    // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavMeshProjectionHeightScaleDown;                  // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkingFloorDistTolerance;                      // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterMovementComponentPostPhysicsTickFunction PostPhysicsTickFunction;                           // 0x05D0(0x7266)(NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenTimeStampResets;                     // 0x0640(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionSourceGroup                 CurrentRootMotion;                                 // 0x0648(0x0100)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_748[0x98];                                     // 0x0748(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionMovementParams              RootMotionParams;                                  // 0x07E0(0x115F7730)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AnimRootMotionVelocity;                            // 0x0830(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSimulatingRootMotion;                          // 0x083C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83D[0x3];                                      // 0x083D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowPhysicsRotationDuringAnimRootMotion : 1;     // 0x0840(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_841[0x7];                                      // 0x0841(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddForce(const struct FVector& Force);
	void AddImpulse(const struct FVector& Impulse, bool bVelocityChange);
	void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
	void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ClearAccumulatedForces();
	void ClientAckGoodMove(float Timestamp);
	void ClientAdjustPosition(float Timestamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
	void ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
	void ClientAdjustRootMotionSourcePosition(float Timestamp, const struct FRootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
	void ClientVeryShortAdjustPosition(float Timestamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
	void DisableMovement();
	void ServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode);
	void ServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode);
	void ServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode);
	void ServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags);
	void SetAvoidanceEnabled(bool bEnable);
	void SetAvoidanceGroup(int32 GroupFlags);
	void SetAvoidanceGroupMask(const struct FNavAvoidanceMask& GroupMask);
	void SetGroupsToAvoid(int32 GroupFlags);
	void SetGroupsToAvoidMask(const struct FNavAvoidanceMask& GroupMask);
	void SetGroupsToIgnore(int32 GroupFlags);
	void SetGroupsToIgnoreMask(const struct FNavAvoidanceMask& GroupMask);
	void SetMovementMode(EMovementMode NewMovementMode, uint8 NewCustomMode);
	void SetWalkableFloorAngle(float InWalkableFloorAngle);
	void SetWalkableFloorZ(float InWalkableFloorZ);

	float GetAnalogInputModifier() const;
	class ACharacter* GetCharacterOwner() const;
	struct FVector GetCurrentAcceleration() const;
	struct FVector GetImpartedMovementBaseVelocity() const;
	float GetMaxAcceleration() const;
	float GetMaxBrakingDeceleration() const;
	float GetMaxJumpHeight() const;
	float GetMaxJumpHeightWithJumpTime() const;
	float GetMinAnalogSpeed() const;
	class UPrimitiveComponent* GetMovementBase() const;
	float GetPerchRadiusThreshold() const;
	float GetValidPerchRadius() const;
	bool IsWalkable(const struct FHitResult& Hit) const;
	bool IsWalking() const;
	void K2_ComputeFloorDist(const struct FVector& CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FFindFloorResult* FloorResult) const;
	void K2_FindFloor(const struct FVector& CapsuleLocation, struct FFindFloorResult* FloorResult) const;
	float K2_GetModifiedMaxAcceleration() const;
	float K2_GetWalkableFloorAngle() const;
	float K2_GetWalkableFloorZ() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMovementComponent">();
	}
	static class UCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCharacterMovementComponent) == 0x115F7730, "Wrong alignment on UCharacterMovementComponent");
static_assert(sizeof(UCharacterMovementComponent) == 0x115F7730, "Wrong size on UCharacterMovementComponent");
static_assert(offsetof(UCharacterMovementComponent, CharacterOwner) == 0x000298, "Member 'UCharacterMovementComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, GravityScale) == 0x0002A4, "Member 'UCharacterMovementComponent::GravityScale' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxStepHeight) == 0x0002A8, "Member 'UCharacterMovementComponent::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, JumpZVelocity) == 0x0002AC, "Member 'UCharacterMovementComponent::JumpZVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, JumpOffJumpZFactor) == 0x0002B0, "Member 'UCharacterMovementComponent::JumpOffJumpZFactor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, WalkableFloorAngle) == 0x0002B4, "Member 'UCharacterMovementComponent::WalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, WalkableFloorZ) == 0x0002B8, "Member 'UCharacterMovementComponent::WalkableFloorZ' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MovementMode) == 0x0002BC, "Member 'UCharacterMovementComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, CustomMovementMode) == 0x0002BD, "Member 'UCharacterMovementComponent::CustomMovementMode' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, GroundFriction) == 0x0002E0, "Member 'UCharacterMovementComponent::GroundFriction' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxWalkSpeed) == 0x0002E4, "Member 'UCharacterMovementComponent::MaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxWalkSpeedCrouched) == 0x0002E8, "Member 'UCharacterMovementComponent::MaxWalkSpeedCrouched' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxSwimSpeed) == 0x0002EC, "Member 'UCharacterMovementComponent::MaxSwimSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxFlySpeed) == 0x0002F0, "Member 'UCharacterMovementComponent::MaxFlySpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxCustomMovementSpeed) == 0x0002F4, "Member 'UCharacterMovementComponent::MaxCustomMovementSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxAcceleration) == 0x0002F8, "Member 'UCharacterMovementComponent::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MinAnalogWalkSpeed) == 0x0002FC, "Member 'UCharacterMovementComponent::MinAnalogWalkSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, BrakingFrictionFactor) == 0x000300, "Member 'UCharacterMovementComponent::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, BrakingFriction) == 0x000304, "Member 'UCharacterMovementComponent::BrakingFriction' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, BrakingDecelerationWalking) == 0x00030C, "Member 'UCharacterMovementComponent::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, BrakingDecelerationFalling) == 0x000310, "Member 'UCharacterMovementComponent::BrakingDecelerationFalling' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, BrakingDecelerationSwimming) == 0x000314, "Member 'UCharacterMovementComponent::BrakingDecelerationSwimming' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, BrakingDecelerationFlying) == 0x000318, "Member 'UCharacterMovementComponent::BrakingDecelerationFlying' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AirControl) == 0x00031C, "Member 'UCharacterMovementComponent::AirControl' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AirControlBoostMultiplier) == 0x000320, "Member 'UCharacterMovementComponent::AirControlBoostMultiplier' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AirControlBoostVelocityThreshold) == 0x000324, "Member 'UCharacterMovementComponent::AirControlBoostVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, FallingLateralFriction) == 0x000328, "Member 'UCharacterMovementComponent::FallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, CrouchedHalfHeight) == 0x00032C, "Member 'UCharacterMovementComponent::CrouchedHalfHeight' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, Buoyancy) == 0x000330, "Member 'UCharacterMovementComponent::Buoyancy' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PerchRadiusThreshold) == 0x000334, "Member 'UCharacterMovementComponent::PerchRadiusThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PerchAdditionalHeight) == 0x000338, "Member 'UCharacterMovementComponent::PerchAdditionalHeight' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, RotationRate) == 0x00033C, "Member 'UCharacterMovementComponent::RotationRate' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, DeferredUpdatedMoveComponent) == 0x000350, "Member 'UCharacterMovementComponent::DeferredUpdatedMoveComponent' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxOutOfWaterStepHeight) == 0x000358, "Member 'UCharacterMovementComponent::MaxOutOfWaterStepHeight' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, OutofWaterZ) == 0x00035C, "Member 'UCharacterMovementComponent::OutofWaterZ' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, Mass) == 0x000360, "Member 'UCharacterMovementComponent::Mass' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, bEnablePhysicsInteraction) == 0x000364, "Member 'UCharacterMovementComponent::bEnablePhysicsInteraction' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, bTouchForceScaledToMass) == 0x000365, "Member 'UCharacterMovementComponent::bTouchForceScaledToMass' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, bPushForceScaledToMass) == 0x000366, "Member 'UCharacterMovementComponent::bPushForceScaledToMass' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, bPushForceUsingZOffset) == 0x000367, "Member 'UCharacterMovementComponent::bPushForceUsingZOffset' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, bScalePushForceToVelocity) == 0x000368, "Member 'UCharacterMovementComponent::bScalePushForceToVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, StandingDownwardForceScale) == 0x00036C, "Member 'UCharacterMovementComponent::StandingDownwardForceScale' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, InitialPushForceFactor) == 0x000370, "Member 'UCharacterMovementComponent::InitialPushForceFactor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PushForceFactor) == 0x000374, "Member 'UCharacterMovementComponent::PushForceFactor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PushForcePointZOffsetFactor) == 0x000378, "Member 'UCharacterMovementComponent::PushForcePointZOffsetFactor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, TouchForceFactor) == 0x00037C, "Member 'UCharacterMovementComponent::TouchForceFactor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MinTouchForce) == 0x000380, "Member 'UCharacterMovementComponent::MinTouchForce' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxTouchForce) == 0x000384, "Member 'UCharacterMovementComponent::MaxTouchForce' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, RepulsionForce) == 0x000388, "Member 'UCharacterMovementComponent::RepulsionForce' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, CrouchedSpeedMultiplier) == 0x000390, "Member 'UCharacterMovementComponent::CrouchedSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, UpperImpactNormalScale) == 0x000394, "Member 'UCharacterMovementComponent::UpperImpactNormalScale' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, Acceleration) == 0x000398, "Member 'UCharacterMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, LastUpdateLocation) == 0x0003A4, "Member 'UCharacterMovementComponent::LastUpdateLocation' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, LastUpdateRotation) == 0x0003B0, "Member 'UCharacterMovementComponent::LastUpdateRotation' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, LastUpdateVelocity) == 0x0003C0, "Member 'UCharacterMovementComponent::LastUpdateVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, ServerLastTransformUpdateTimeStamp) == 0x0003CC, "Member 'UCharacterMovementComponent::ServerLastTransformUpdateTimeStamp' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PendingImpulseToApply) == 0x0003D0, "Member 'UCharacterMovementComponent::PendingImpulseToApply' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PendingForceToApply) == 0x0003DC, "Member 'UCharacterMovementComponent::PendingForceToApply' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AnalogInputModifier) == 0x0003E8, "Member 'UCharacterMovementComponent::AnalogInputModifier' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxSimulationTimeStep) == 0x0003F4, "Member 'UCharacterMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxSimulationIterations) == 0x0003F8, "Member 'UCharacterMovementComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxDepenetrationWithGeometry) == 0x0003FC, "Member 'UCharacterMovementComponent::MaxDepenetrationWithGeometry' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxDepenetrationWithGeometryAsProxy) == 0x000400, "Member 'UCharacterMovementComponent::MaxDepenetrationWithGeometryAsProxy' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxDepenetrationWithPawn) == 0x000404, "Member 'UCharacterMovementComponent::MaxDepenetrationWithPawn' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MaxDepenetrationWithPawnAsProxy) == 0x000408, "Member 'UCharacterMovementComponent::MaxDepenetrationWithPawnAsProxy' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetworkSimulatedSmoothLocationTime) == 0x00040C, "Member 'UCharacterMovementComponent::NetworkSimulatedSmoothLocationTime' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetworkSimulatedSmoothRotationTime) == 0x000410, "Member 'UCharacterMovementComponent::NetworkSimulatedSmoothRotationTime' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, ListenServerNetworkSimulatedSmoothLocationTime) == 0x000414, "Member 'UCharacterMovementComponent::ListenServerNetworkSimulatedSmoothLocationTime' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, ListenServerNetworkSimulatedSmoothRotationTime) == 0x000418, "Member 'UCharacterMovementComponent::ListenServerNetworkSimulatedSmoothRotationTime' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetProxyShrinkRadius) == 0x00041C, "Member 'UCharacterMovementComponent::NetProxyShrinkRadius' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetProxyShrinkHalfHeight) == 0x000420, "Member 'UCharacterMovementComponent::NetProxyShrinkHalfHeight' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetworkMaxSmoothUpdateDistance) == 0x000424, "Member 'UCharacterMovementComponent::NetworkMaxSmoothUpdateDistance' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetworkNoSmoothUpdateDistance) == 0x000428, "Member 'UCharacterMovementComponent::NetworkNoSmoothUpdateDistance' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NetworkSmoothingMode) == 0x00042C, "Member 'UCharacterMovementComponent::NetworkSmoothingMode' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, LedgeCheckThreshold) == 0x000430, "Member 'UCharacterMovementComponent::LedgeCheckThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, JumpOutOfWaterPitch) == 0x000434, "Member 'UCharacterMovementComponent::JumpOutOfWaterPitch' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, CurrentFloor) == 0x000438, "Member 'UCharacterMovementComponent::CurrentFloor' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, DefaultLandMovementMode) == 0x0004D0, "Member 'UCharacterMovementComponent::DefaultLandMovementMode' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, DefaultWaterMovementMode) == 0x0004D1, "Member 'UCharacterMovementComponent::DefaultWaterMovementMode' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, GroundMovementMode) == 0x0004D2, "Member 'UCharacterMovementComponent::GroundMovementMode' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AvoidanceConsiderationRadius) == 0x0004E8, "Member 'UCharacterMovementComponent::AvoidanceConsiderationRadius' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, RequestedVelocity) == 0x0004EC, "Member 'UCharacterMovementComponent::RequestedVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AvoidanceUID) == 0x0004F8, "Member 'UCharacterMovementComponent::AvoidanceUID' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AvoidanceGroup) == 0x0004FC, "Member 'UCharacterMovementComponent::AvoidanceGroup' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, GroupsToAvoid) == 0x000500, "Member 'UCharacterMovementComponent::GroupsToAvoid' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, GroupsToIgnore) == 0x000504, "Member 'UCharacterMovementComponent::GroupsToIgnore' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AvoidanceWeight) == 0x000508, "Member 'UCharacterMovementComponent::AvoidanceWeight' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PendingLaunchVelocity) == 0x00050C, "Member 'UCharacterMovementComponent::PendingLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NavMeshProjectionInterval) == 0x0005B8, "Member 'UCharacterMovementComponent::NavMeshProjectionInterval' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NavMeshProjectionTimer) == 0x0005BC, "Member 'UCharacterMovementComponent::NavMeshProjectionTimer' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NavMeshProjectionInterpSpeed) == 0x0005C0, "Member 'UCharacterMovementComponent::NavMeshProjectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NavMeshProjectionHeightScaleUp) == 0x0005C4, "Member 'UCharacterMovementComponent::NavMeshProjectionHeightScaleUp' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NavMeshProjectionHeightScaleDown) == 0x0005C8, "Member 'UCharacterMovementComponent::NavMeshProjectionHeightScaleDown' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, NavWalkingFloorDistTolerance) == 0x0005CC, "Member 'UCharacterMovementComponent::NavWalkingFloorDistTolerance' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, PostPhysicsTickFunction) == 0x0005D0, "Member 'UCharacterMovementComponent::PostPhysicsTickFunction' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, MinTimeBetweenTimeStampResets) == 0x000640, "Member 'UCharacterMovementComponent::MinTimeBetweenTimeStampResets' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, CurrentRootMotion) == 0x000648, "Member 'UCharacterMovementComponent::CurrentRootMotion' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, RootMotionParams) == 0x0007E0, "Member 'UCharacterMovementComponent::RootMotionParams' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, AnimRootMotionVelocity) == 0x000830, "Member 'UCharacterMovementComponent::AnimRootMotionVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementComponent, bWasSimulatingRootMotion) == 0x00083C, "Member 'UCharacterMovementComponent::bWasSimulatingRootMotion' has a wrong offset!");

// Class Engine.CheckBoxStyleAsset
// 0x1159F110 (0x1159F150 - 0x0040)
class UCheckBoxStyleAsset final : public UObject
{
public:
	struct FCheckBoxStyle                         CheckBoxStyle;                                     // 0x0040(0x1159F150)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckBoxStyleAsset">();
	}
	static class UCheckBoxStyleAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckBoxStyleAsset>();
	}
};
static_assert(alignof(UCheckBoxStyleAsset) == 0x1159F150, "Wrong alignment on UCheckBoxStyleAsset");
static_assert(sizeof(UCheckBoxStyleAsset) == 0x1159F150, "Wrong size on UCheckBoxStyleAsset");
static_assert(offsetof(UCheckBoxStyleAsset, CheckBoxStyle) == 0x000040, "Member 'UCheckBoxStyleAsset::CheckBoxStyle' has a wrong offset!");

// Class Engine.ChildConnection
// 0x0000 (0x1F5FEC10 - 0x1F5FEC10)
class UChildConnection final : public UNetConnection
{
public:
	class UNetConnection*                         Parent;                                            // 0x33670(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChildConnection">();
	}
	static class UChildConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChildConnection>();
	}
};
static_assert(alignof(UChildConnection) == 0x1F5FEC10, "Wrong alignment on UChildConnection");
static_assert(sizeof(UChildConnection) == 0x1F5FEC10, "Wrong size on UChildConnection");
static_assert(offsetof(UChildConnection, Parent) == 0x033670, "Member 'UChildConnection::Parent' has a wrong offset!");

// Class Engine.PlatformInterfaceBase
// 0x0010 (0x0050 - 0x0040)
class UPlatformInterfaceBase : public UObject
{
public:
	TArray<struct FDelegateArray>                 AllDelegates;                                      // 0x0040(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformInterfaceBase">();
	}
	static class UPlatformInterfaceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformInterfaceBase>();
	}
};
static_assert(alignof(UPlatformInterfaceBase) == 0x000008, "Wrong alignment on UPlatformInterfaceBase");
static_assert(sizeof(UPlatformInterfaceBase) == 0x000050, "Wrong size on UPlatformInterfaceBase");
static_assert(offsetof(UPlatformInterfaceBase, AllDelegates) == 0x000040, "Member 'UPlatformInterfaceBase::AllDelegates' has a wrong offset!");

// Class Engine.CloudStorageBase
// 0x0018 (0x0068 - 0x0050)
class UCloudStorageBase final : public UPlatformInterfaceBase
{
public:
	TArray<class FString>                         LocalCloudFiles;                                   // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSuppressDelegateCalls : 1;                        // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudStorageBase">();
	}
	static class UCloudStorageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudStorageBase>();
	}
};
static_assert(alignof(UCloudStorageBase) == 0x000008, "Wrong alignment on UCloudStorageBase");
static_assert(sizeof(UCloudStorageBase) == 0x000068, "Wrong size on UCloudStorageBase");
static_assert(offsetof(UCloudStorageBase, LocalCloudFiles) == 0x000050, "Member 'UCloudStorageBase::LocalCloudFiles' has a wrong offset!");

// Class Engine.MaterialExpressionAbs
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionAbs final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAbs">();
	}
	static class UMaterialExpressionAbs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAbs>();
	}
};
static_assert(alignof(UMaterialExpressionAbs) == 0x112F2730, "Wrong alignment on UMaterialExpressionAbs");
static_assert(sizeof(UMaterialExpressionAbs) == 0x112F2730, "Wrong size on UMaterialExpressionAbs");
static_assert(offsetof(UMaterialExpressionAbs, Input) == 0x000078, "Member 'UMaterialExpressionAbs::Input' has a wrong offset!");

// Class Engine.CollisionProfile
// 0x0120 (0x0170 - 0x0050)
class UCollisionProfile final : public UDeveloperSettings
{
public:
	TArray<struct FCollisionResponseTemplate>     Profiles;                                          // 0x0050(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPrivate)
	TArray<struct FCustomChannelSetup>            DefaultChannelResponses;                           // 0x0060(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPrivate)
	TArray<struct FCustomProfile>                 EditProfiles;                                      // 0x0070(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPrivate)
	TArray<struct FRedirector>                    ProfileRedirects;                                  // 0x0080(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPrivate)
	TArray<struct FRedirector>                    CollisionChannelRedirects;                         // 0x0090(0x0010)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0xD0];                                      // 0x00A0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionProfile">();
	}
	static class UCollisionProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionProfile>();
	}
};
static_assert(alignof(UCollisionProfile) == 0x000008, "Wrong alignment on UCollisionProfile");
static_assert(sizeof(UCollisionProfile) == 0x000170, "Wrong size on UCollisionProfile");
static_assert(offsetof(UCollisionProfile, Profiles) == 0x000050, "Member 'UCollisionProfile::Profiles' has a wrong offset!");
static_assert(offsetof(UCollisionProfile, DefaultChannelResponses) == 0x000060, "Member 'UCollisionProfile::DefaultChannelResponses' has a wrong offset!");
static_assert(offsetof(UCollisionProfile, EditProfiles) == 0x000070, "Member 'UCollisionProfile::EditProfiles' has a wrong offset!");
static_assert(offsetof(UCollisionProfile, ProfileRedirects) == 0x000080, "Member 'UCollisionProfile::ProfileRedirects' has a wrong offset!");
static_assert(offsetof(UCollisionProfile, CollisionChannelRedirects) == 0x000090, "Member 'UCollisionProfile::CollisionChannelRedirects' has a wrong offset!");

// Class Engine.MaterialExpressionCosine
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionCosine final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCosine">();
	}
	static class UMaterialExpressionCosine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCosine>();
	}
};
static_assert(alignof(UMaterialExpressionCosine) == 0x112F2730, "Wrong alignment on UMaterialExpressionCosine");
static_assert(sizeof(UMaterialExpressionCosine) == 0x112F2730, "Wrong size on UMaterialExpressionCosine");
static_assert(offsetof(UMaterialExpressionCosine, Input) == 0x000078, "Member 'UMaterialExpressionCosine::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCosine, Period) == 0x0000B0, "Member 'UMaterialExpressionCosine::Period' has a wrong offset!");

// Class Engine.Commandlet
// 0x0058 (0x0098 - 0x0040)
class UCommandlet : public UObject
{
public:
	class FString                                 HelpDescription;                                   // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HelpUsage;                                         // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HelpWebLink;                                       // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         HelpParamNames;                                    // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         HelpParamDescriptions;                             // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         IsServer : 1;                                      // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsClient : 1;                                      // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsEditor : 1;                                      // 0x0090(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         LogToConsole : 1;                                  // 0x0090(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ShowErrorCount : 1;                                // 0x0090(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Commandlet">();
	}
	static class UCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandlet>();
	}
};
static_assert(alignof(UCommandlet) == 0x000008, "Wrong alignment on UCommandlet");
static_assert(sizeof(UCommandlet) == 0x000098, "Wrong size on UCommandlet");
static_assert(offsetof(UCommandlet, HelpDescription) == 0x000040, "Member 'UCommandlet::HelpDescription' has a wrong offset!");
static_assert(offsetof(UCommandlet, HelpUsage) == 0x000050, "Member 'UCommandlet::HelpUsage' has a wrong offset!");
static_assert(offsetof(UCommandlet, HelpWebLink) == 0x000060, "Member 'UCommandlet::HelpWebLink' has a wrong offset!");
static_assert(offsetof(UCommandlet, HelpParamNames) == 0x000070, "Member 'UCommandlet::HelpParamNames' has a wrong offset!");
static_assert(offsetof(UCommandlet, HelpParamDescriptions) == 0x000080, "Member 'UCommandlet::HelpParamDescriptions' has a wrong offset!");

// Class Engine.DynamicBlueprintBinding
// 0x0000 (0x0040 - 0x0040)
class UDynamicBlueprintBinding : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicBlueprintBinding">();
	}
	static class UDynamicBlueprintBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicBlueprintBinding>();
	}
};
static_assert(alignof(UDynamicBlueprintBinding) == 0x000008, "Wrong alignment on UDynamicBlueprintBinding");
static_assert(sizeof(UDynamicBlueprintBinding) == 0x000040, "Wrong size on UDynamicBlueprintBinding");

// Class Engine.ComponentDelegateBinding
// 0x0010 (0x0050 - 0x0040)
class UComponentDelegateBinding final : public UDynamicBlueprintBinding
{
public:
	TArray<struct FBlueprintComponentDelegateBinding> ComponentDelegateBindings;                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComponentDelegateBinding">();
	}
	static class UComponentDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComponentDelegateBinding>();
	}
};
static_assert(alignof(UComponentDelegateBinding) == 0x000008, "Wrong alignment on UComponentDelegateBinding");
static_assert(sizeof(UComponentDelegateBinding) == 0x000050, "Wrong size on UComponentDelegateBinding");
static_assert(offsetof(UComponentDelegateBinding, ComponentDelegateBindings) == 0x000040, "Member 'UComponentDelegateBinding::ComponentDelegateBindings' has a wrong offset!");

// Class Engine.ControlChannel
// 0x0018 (0x0098 - 0x0080)
class UControlChannel final : public UChannel
{
public:
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlChannel">();
	}
	static class UControlChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlChannel>();
	}
};
static_assert(alignof(UControlChannel) == 0x000008, "Wrong alignment on UControlChannel");
static_assert(sizeof(UControlChannel) == 0x000098, "Wrong size on UControlChannel");

// Class Engine.PreviewMeshCollection
// 0x0020 (0x0068 - 0x0048)
class UPreviewMeshCollection final : public UDataAsset
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPreviewMeshCollectionEntry>    SkeletalMeshes;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewMeshCollection">();
	}
	static class UPreviewMeshCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreviewMeshCollection>();
	}
};
static_assert(alignof(UPreviewMeshCollection) == 0x000008, "Wrong alignment on UPreviewMeshCollection");
static_assert(sizeof(UPreviewMeshCollection) == 0x000068, "Wrong size on UPreviewMeshCollection");
static_assert(offsetof(UPreviewMeshCollection, Skeleton) == 0x000050, "Member 'UPreviewMeshCollection::Skeleton' has a wrong offset!");
static_assert(offsetof(UPreviewMeshCollection, SkeletalMeshes) == 0x000058, "Member 'UPreviewMeshCollection::SkeletalMeshes' has a wrong offset!");

// Class Engine.ControlRigInterface
// 0x0000 (0x0040 - 0x0040)
class IControlRigInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlRigInterface">();
	}
	static class IControlRigInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IControlRigInterface>();
	}
};
static_assert(alignof(IControlRigInterface) == 0x000008, "Wrong alignment on IControlRigInterface");
static_assert(sizeof(IControlRigInterface) == 0x000040, "Wrong size on IControlRigInterface");

// Class Engine.StreamingSettings
// 0x0030 (0x0080 - 0x0050)
class UStreamingSettings final : public UDeveloperSettings
{
public:
	uint8                                         AsyncLoadingThreadEnabled : 1;                     // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         WarnIfTimeLimitExceeded : 1;                       // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLimitExceededMultiplier;                       // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeLimitExceededMinTime;                          // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinBulkDataSizeForAsyncLoading;                    // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         UseBackgroundLevelStreaming : 1;                   // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         AsyncLoadingUseFullTimeLimit : 1;                  // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AsyncLoadingTimeLimit;                             // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PriorityAsyncLoadingExtraTime;                     // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LevelStreamingActorsUpdateTimeLimit;               // 0x006C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelStreamingComponentsRegistrationGranularity;   // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LevelStreamingUnregisterComponentsTimeLimit;       // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LevelStreamingComponentsUnregistrationGranularity; // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         EventDrivenLoaderEnabled : 1;                      // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingSettings">();
	}
	static class UStreamingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamingSettings>();
	}
};
static_assert(alignof(UStreamingSettings) == 0x000008, "Wrong alignment on UStreamingSettings");
static_assert(sizeof(UStreamingSettings) == 0x000080, "Wrong size on UStreamingSettings");
static_assert(offsetof(UStreamingSettings, TimeLimitExceededMultiplier) == 0x000054, "Member 'UStreamingSettings::TimeLimitExceededMultiplier' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, TimeLimitExceededMinTime) == 0x000058, "Member 'UStreamingSettings::TimeLimitExceededMinTime' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, MinBulkDataSizeForAsyncLoading) == 0x00005C, "Member 'UStreamingSettings::MinBulkDataSizeForAsyncLoading' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, AsyncLoadingTimeLimit) == 0x000064, "Member 'UStreamingSettings::AsyncLoadingTimeLimit' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, PriorityAsyncLoadingExtraTime) == 0x000068, "Member 'UStreamingSettings::PriorityAsyncLoadingExtraTime' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, LevelStreamingActorsUpdateTimeLimit) == 0x00006C, "Member 'UStreamingSettings::LevelStreamingActorsUpdateTimeLimit' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, LevelStreamingComponentsRegistrationGranularity) == 0x000070, "Member 'UStreamingSettings::LevelStreamingComponentsRegistrationGranularity' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, LevelStreamingUnregisterComponentsTimeLimit) == 0x000074, "Member 'UStreamingSettings::LevelStreamingUnregisterComponentsTimeLimit' has a wrong offset!");
static_assert(offsetof(UStreamingSettings, LevelStreamingComponentsUnregistrationGranularity) == 0x000078, "Member 'UStreamingSettings::LevelStreamingComponentsUnregistrationGranularity' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXSceneTexture
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXSceneTexture final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	ESQEXSceneTextureId                           SceneTextureId;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampUVs;                                         // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXSceneTexture">();
	}
	static class UMaterialExpressionSQEXSceneTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXSceneTexture>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXSceneTexture) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXSceneTexture");
static_assert(sizeof(UMaterialExpressionSQEXSceneTexture) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXSceneTexture");
static_assert(offsetof(UMaterialExpressionSQEXSceneTexture, Coordinates) == 0x000078, "Member 'UMaterialExpressionSQEXSceneTexture::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSQEXSceneTexture, SceneTextureId) == 0x0000B0, "Member 'UMaterialExpressionSQEXSceneTexture::SceneTextureId' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSQEXSceneTexture, bClampUVs) == 0x0000B1, "Member 'UMaterialExpressionSQEXSceneTexture::bClampUVs' has a wrong offset!");

// Class Engine.GarbageCollectionSettings
// 0x0020 (0x0070 - 0x0050)
class UGarbageCollectionSettings final : public UDeveloperSettings
{
public:
	float                                         TimeBetweenPurgingPendingKillObjects;              // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         FlushStreamingOnGC : 1;                            // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         AllowParallelGC : 1;                               // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         CreateGCClusters : 1;                              // 0x0054(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         MergeGCClusters : 1;                               // 0x0054(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         ActorClusteringEnabled : 1;                        // 0x0054(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BlueprintClusteringEnabled : 1;                    // 0x0054(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         UseDisregardForGCOnDedicatedServers : 1;           // 0x0054(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, Config, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRetriesBeforeForcingGC;                         // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxObjectsNotConsideredByGC;                       // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SizeOfPermanentObjectPool;                         // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxObjectsInGame;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxObjectsInEditor;                                // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GarbageCollectionSettings">();
	}
	static class UGarbageCollectionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGarbageCollectionSettings>();
	}
};
static_assert(alignof(UGarbageCollectionSettings) == 0x000008, "Wrong alignment on UGarbageCollectionSettings");
static_assert(sizeof(UGarbageCollectionSettings) == 0x000070, "Wrong size on UGarbageCollectionSettings");
static_assert(offsetof(UGarbageCollectionSettings, TimeBetweenPurgingPendingKillObjects) == 0x000050, "Member 'UGarbageCollectionSettings::TimeBetweenPurgingPendingKillObjects' has a wrong offset!");
static_assert(offsetof(UGarbageCollectionSettings, NumRetriesBeforeForcingGC) == 0x000058, "Member 'UGarbageCollectionSettings::NumRetriesBeforeForcingGC' has a wrong offset!");
static_assert(offsetof(UGarbageCollectionSettings, MaxObjectsNotConsideredByGC) == 0x00005C, "Member 'UGarbageCollectionSettings::MaxObjectsNotConsideredByGC' has a wrong offset!");
static_assert(offsetof(UGarbageCollectionSettings, SizeOfPermanentObjectPool) == 0x000060, "Member 'UGarbageCollectionSettings::SizeOfPermanentObjectPool' has a wrong offset!");
static_assert(offsetof(UGarbageCollectionSettings, MaxObjectsInGame) == 0x000064, "Member 'UGarbageCollectionSettings::MaxObjectsInGame' has a wrong offset!");
static_assert(offsetof(UGarbageCollectionSettings, MaxObjectsInEditor) == 0x000068, "Member 'UGarbageCollectionSettings::MaxObjectsInEditor' has a wrong offset!");

// Class Engine.CullDistanceVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ACullDistanceVolume final : public AVolume
{
public:
	TArray<struct FCullDistanceSizePair>          CullDistances;                                     // 0x0420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CullDistanceVolume">();
	}
	static class ACullDistanceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACullDistanceVolume>();
	}
};
static_assert(alignof(ACullDistanceVolume) == 0x1EF72E00, "Wrong alignment on ACullDistanceVolume");
static_assert(sizeof(ACullDistanceVolume) == 0x1EF72E00, "Wrong size on ACullDistanceVolume");
static_assert(offsetof(ACullDistanceVolume, CullDistances) == 0x000420, "Member 'ACullDistanceVolume::CullDistances' has a wrong offset!");

// Class Engine.CurveBase
// 0x0008 (0x0048 - 0x0040)
class UCurveBase : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetTimeRange(float* MinTime, float* MaxTime) const;
	void GetValueRange(float* MinValue, float* MaxValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveBase">();
	}
	static class UCurveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveBase>();
	}
};
static_assert(alignof(UCurveBase) == 0x000008, "Wrong alignment on UCurveBase");
static_assert(sizeof(UCurveBase) == 0x000048, "Wrong size on UCurveBase");

// Class Engine.MaterialExpressionConstant4Vector
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionConstant4Vector final : public UMaterialExpression
{
public:
	struct FLinearColor                           Constant;                                          // 0x0078(0x112EAE80)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionConstant4Vector">();
	}
	static class UMaterialExpressionConstant4Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionConstant4Vector>();
	}
};
static_assert(alignof(UMaterialExpressionConstant4Vector) == 0x112EAE80, "Wrong alignment on UMaterialExpressionConstant4Vector");
static_assert(sizeof(UMaterialExpressionConstant4Vector) == 0x112EAE80, "Wrong size on UMaterialExpressionConstant4Vector");
static_assert(offsetof(UMaterialExpressionConstant4Vector, Constant) == 0x000078, "Member 'UMaterialExpressionConstant4Vector::Constant' has a wrong offset!");

// Class Engine.CurveEdPresetCurve
// 0x0000 (0x0040 - 0x0040)
class UCurveEdPresetCurve final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveEdPresetCurve">();
	}
	static class UCurveEdPresetCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveEdPresetCurve>();
	}
};
static_assert(alignof(UCurveEdPresetCurve) == 0x000008, "Wrong alignment on UCurveEdPresetCurve");
static_assert(sizeof(UCurveEdPresetCurve) == 0x000040, "Wrong size on UCurveEdPresetCurve");

// Class Engine.CurveFloat
// 0x110BA (0x11102 - 0x0048)
class UCurveFloat : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurve;                                        // 0x0048(0x11102)(NativeAccessSpecifierPublic)
	bool                                          bIsEventCurve;                                     // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFloatValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveFloat">();
	}
	static class UCurveFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveFloat>();
	}
};
static_assert(alignof(UCurveFloat) == 0x011102, "Wrong alignment on UCurveFloat");
static_assert(sizeof(UCurveFloat) == 0x011102, "Wrong size on UCurveFloat");
static_assert(offsetof(UCurveFloat, FloatCurve) == 0x000048, "Member 'UCurveFloat::FloatCurve' has a wrong offset!");
static_assert(offsetof(UCurveFloat, bIsEventCurve) == 0x0000B8, "Member 'UCurveFloat::bIsEventCurve' has a wrong offset!");

// Class Engine.ModelComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UModelComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_868[0x18];                                     // 0x0868(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             ModelBodySetup;                                    // 0x0880(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_888[0x28];                                     // 0x0888(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelComponent">();
	}
	static class UModelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelComponent>();
	}
};
static_assert(alignof(UModelComponent) == 0x112E9AF0, "Wrong alignment on UModelComponent");
static_assert(sizeof(UModelComponent) == 0x112E9AF0, "Wrong size on UModelComponent");
static_assert(offsetof(UModelComponent, ModelBodySetup) == 0x000880, "Member 'UModelComponent::ModelBodySetup' has a wrong offset!");

// Class Engine.CurveLinearColor
// 0x110BA (0x11102 - 0x0048)
class UCurveLinearColor : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x4];                                  // 0x0048(0x11102)(NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetLinearColorValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveLinearColor">();
	}
	static class UCurveLinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveLinearColor>();
	}
};
static_assert(alignof(UCurveLinearColor) == 0x011102, "Wrong alignment on UCurveLinearColor");
static_assert(sizeof(UCurveLinearColor) == 0x011102, "Wrong size on UCurveLinearColor");
static_assert(offsetof(UCurveLinearColor, FloatCurves) == 0x000048, "Member 'UCurveLinearColor::FloatCurves' has a wrong offset!");

// Class Engine.CurveSourceInterface
// 0x0000 (0x0040 - 0x0040)
class ICurveSourceInterface final : public IInterface
{
public:
	class FName GetBindingName() const;
	void GetCurves(TArray<struct FNamedCurveValue>* OutValues) const;
	float GetCurveValue(class FName CurveName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveSourceInterface">();
	}
	static class ICurveSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICurveSourceInterface>();
	}
};
static_assert(alignof(ICurveSourceInterface) == 0x000008, "Wrong alignment on ICurveSourceInterface");
static_assert(sizeof(ICurveSourceInterface) == 0x000040, "Wrong size on ICurveSourceInterface");

// Class Engine.CurveTable
// 0x0058 (0x0098 - 0x0040)
class UCurveTable final : public UObject
{
public:
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveTable">();
	}
	static class UCurveTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveTable>();
	}
};
static_assert(alignof(UCurveTable) == 0x000008, "Wrong alignment on UCurveTable");
static_assert(sizeof(UCurveTable) == 0x000098, "Wrong size on UCurveTable");

// Class Engine.MaterialExpressionArctangentFast
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArctangentFast final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArctangentFast">();
	}
	static class UMaterialExpressionArctangentFast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArctangentFast>();
	}
};
static_assert(alignof(UMaterialExpressionArctangentFast) == 0x112F2730, "Wrong alignment on UMaterialExpressionArctangentFast");
static_assert(sizeof(UMaterialExpressionArctangentFast) == 0x112F2730, "Wrong size on UMaterialExpressionArctangentFast");
static_assert(offsetof(UMaterialExpressionArctangentFast, Input) == 0x000078, "Member 'UMaterialExpressionArctangentFast::Input' has a wrong offset!");

// Class Engine.CurveVector
// 0x110BA (0x11102 - 0x0048)
class UCurveVector final : public UCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0048(0x11102)(NativeAccessSpecifierPublic)

public:
	struct FVector GetVectorValue(float InTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveVector">();
	}
	static class UCurveVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveVector>();
	}
};
static_assert(alignof(UCurveVector) == 0x011102, "Wrong alignment on UCurveVector");
static_assert(sizeof(UCurveVector) == 0x011102, "Wrong size on UCurveVector");
static_assert(offsetof(UCurveVector, FloatCurves) == 0x000048, "Member 'UCurveVector::FloatCurves' has a wrong offset!");

// Class Engine.SkyLightComponent
// 0x1390 (0x112EAE80 - 0x112E9AF0)
class USkyLightComponent final : public ULightComponentBase
{
public:
	ESkyLightSourceType                           SourceType;                                        // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           Cubemap;                                           // 0x0458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceCubemapAngle;                                // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CubemapResolution;                                 // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyDistanceThreshold;                              // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureEmissiveOnly;                              // 0x046C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerHemisphereIsBlack;                           // 0x046D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46E[0x2];                                      // 0x046E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LowerHemisphereColor;                              // 0x0470(0x112EAE80)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionMaxDistance;                              // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Contrast;                                          // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionExponent;                                 // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOcclusion;                                      // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 OcclusionTint;                                     // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionCombineMode                         OcclusionCombineMode;                              // 0x0494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_495[0xA3];                                     // 0x0495(0x00A3)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           BlendDestinationCubemap;                           // 0x0538(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0xC0];                                     // 0x0540(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecaptureSky();
	void SetCubemap(class UTextureCube* NewCubemap);
	void SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction);
	void SetIndirectLightingIntensity(float NewIntensity);
	void SetIntensity(float NewIntensity);
	void SetLightColor(const struct FLinearColor& NewLightColor);
	void SetMinOcclusion(float InMinOcclusion);
	void SetOcclusionContrast(float InOcclusionContrast);
	void SetOcclusionExponent(float InOcclusionExponent);
	void SetOcclusionTint(const struct FColor& InTint);
	void SetVolumetricScatteringIntensity(float NewIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkyLightComponent">();
	}
	static class USkyLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkyLightComponent>();
	}
};
static_assert(alignof(USkyLightComponent) == 0x112EAE80, "Wrong alignment on USkyLightComponent");
static_assert(sizeof(USkyLightComponent) == 0x112EAE80, "Wrong size on USkyLightComponent");
static_assert(offsetof(USkyLightComponent, SourceType) == 0x000450, "Member 'USkyLightComponent::SourceType' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, Cubemap) == 0x000458, "Member 'USkyLightComponent::Cubemap' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, SourceCubemapAngle) == 0x000460, "Member 'USkyLightComponent::SourceCubemapAngle' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, CubemapResolution) == 0x000464, "Member 'USkyLightComponent::CubemapResolution' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, SkyDistanceThreshold) == 0x000468, "Member 'USkyLightComponent::SkyDistanceThreshold' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, bCaptureEmissiveOnly) == 0x00046C, "Member 'USkyLightComponent::bCaptureEmissiveOnly' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, bLowerHemisphereIsBlack) == 0x00046D, "Member 'USkyLightComponent::bLowerHemisphereIsBlack' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, LowerHemisphereColor) == 0x000470, "Member 'USkyLightComponent::LowerHemisphereColor' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, OcclusionMaxDistance) == 0x000480, "Member 'USkyLightComponent::OcclusionMaxDistance' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, Contrast) == 0x000484, "Member 'USkyLightComponent::Contrast' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, OcclusionExponent) == 0x000488, "Member 'USkyLightComponent::OcclusionExponent' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, MinOcclusion) == 0x00048C, "Member 'USkyLightComponent::MinOcclusion' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, OcclusionTint) == 0x000490, "Member 'USkyLightComponent::OcclusionTint' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, OcclusionCombineMode) == 0x000494, "Member 'USkyLightComponent::OcclusionCombineMode' has a wrong offset!");
static_assert(offsetof(USkyLightComponent, BlendDestinationCubemap) == 0x000538, "Member 'USkyLightComponent::BlendDestinationCubemap' has a wrong offset!");

// Class Engine.MaterialExpressionDivide
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDivide final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDivide">();
	}
	static class UMaterialExpressionDivide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDivide>();
	}
};
static_assert(alignof(UMaterialExpressionDivide) == 0x112F2730, "Wrong alignment on UMaterialExpressionDivide");
static_assert(sizeof(UMaterialExpressionDivide) == 0x112F2730, "Wrong size on UMaterialExpressionDivide");
static_assert(offsetof(UMaterialExpressionDivide, A) == 0x000078, "Member 'UMaterialExpressionDivide::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDivide, B) == 0x0000B0, "Member 'UMaterialExpressionDivide::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDivide, ConstA) == 0x0000E8, "Member 'UMaterialExpressionDivide::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDivide, ConstB) == 0x0000EC, "Member 'UMaterialExpressionDivide::ConstB' has a wrong offset!");

// Class Engine.PrimaryDataAsset
// 0x0000 (0x0048 - 0x0048)
class UPrimaryDataAsset : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryDataAsset">();
	}
	static class UPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrimaryDataAsset>();
	}
};
static_assert(alignof(UPrimaryDataAsset) == 0x000008, "Wrong alignment on UPrimaryDataAsset");
static_assert(sizeof(UPrimaryDataAsset) == 0x000048, "Wrong size on UPrimaryDataAsset");

// Class Engine.DataTable
// 0x0058 (0x0098 - 0x0040)
class UDataTable final : public UObject
{
public:
	class UScriptStruct*                          RowStruct;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, uint8*>                     RowMap;                                            // 0x0048(0x0050)(So, here's a RowMap. Good luck with it.)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTable">();
	}
	static class UDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTable>();
	}
};
static_assert(alignof(UDataTable) == 0x000008, "Wrong alignment on UDataTable");
static_assert(sizeof(UDataTable) == 0x000098, "Wrong size on UDataTable");
static_assert(offsetof(UDataTable, RowStruct) == 0x000040, "Member 'UDataTable::RowStruct' has a wrong offset!");
static_assert(offsetof(UDataTable, RowMap) == 0x000048, "Member 'UDataTable::RowMap' has a wrong offset!");

// Class Engine.Selection
// 0x0078 (0x00B8 - 0x0040)
class USelection final : public UObject
{
public:
	uint8                                         Pad_40[0x78];                                      // 0x0040(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Selection">();
	}
	static class USelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelection>();
	}
};
static_assert(alignof(USelection) == 0x000008, "Wrong alignment on USelection");
static_assert(sizeof(USelection) == 0x0000B8, "Wrong size on USelection");

// Class Engine.DataTableFunctionLibrary
// 0x0000 (0x0040 - 0x0040)
class UDataTableFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EvaluateCurveTableRow(class UCurveTable* CurveTable, class FName RowName, float InXY, EEvaluateCurveTableResult* OutResult, float* OutXY, const class FString& ContextString);
	static bool GetDataTableRowFromName(class UDataTable* Table, class FName RowName, struct FTableRowBase* OutRow);
	static void GetDataTableRowNames(class UDataTable* Table, TArray<class FName>* OutRowNames);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableFunctionLibrary">();
	}
	static class UDataTableFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableFunctionLibrary>();
	}
};
static_assert(alignof(UDataTableFunctionLibrary) == 0x000008, "Wrong alignment on UDataTableFunctionLibrary");
static_assert(sizeof(UDataTableFunctionLibrary) == 0x000040, "Wrong size on UDataTableFunctionLibrary");

// Class Engine.NavigationDataChunk
// 0x0008 (0x0048 - 0x0040)
class UNavigationDataChunk : public UObject
{
public:
	class FName                                   NavigationDataName;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationDataChunk">();
	}
	static class UNavigationDataChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationDataChunk>();
	}
};
static_assert(alignof(UNavigationDataChunk) == 0x000008, "Wrong alignment on UNavigationDataChunk");
static_assert(sizeof(UNavigationDataChunk) == 0x000048, "Wrong size on UNavigationDataChunk");
static_assert(offsetof(UNavigationDataChunk, NavigationDataName) == 0x000040, "Member 'UNavigationDataChunk::NavigationDataName' has a wrong offset!");

// Class Engine.RecastNavMeshDataChunk
// 0x0010 (0x0058 - 0x0048)
class URecastNavMeshDataChunk final : public UNavigationDataChunk
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecastNavMeshDataChunk">();
	}
	static class URecastNavMeshDataChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecastNavMeshDataChunk>();
	}
};
static_assert(alignof(URecastNavMeshDataChunk) == 0x000008, "Wrong alignment on URecastNavMeshDataChunk");
static_assert(sizeof(URecastNavMeshDataChunk) == 0x000058, "Wrong size on URecastNavMeshDataChunk");

// Class Engine.DebugCameraController
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADebugCameraController final : public APlayerController
{
public:
	uint8                                         bShowSelectedInfo : 1;                             // 0x0828(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFrozenRendering : 1;                            // 0x0828(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_829[0x7];                                      // 0x0829(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDrawFrustumComponent*                  DrawFrustum;                                       // 0x0830(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_838[0x20];                                     // 0x0838(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedScale;                                        // 0x0858(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialMaxSpeed;                                   // 0x085C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAccel;                                      // 0x0860(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDecel;                                      // 0x0864(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveOnActivate(class APlayerController* OriginalPC);
	void ReceiveOnActorSelected(class AActor* NewSelectedActor, const struct FVector& SelectHitLocation, const struct FVector& SelectHitNormal, const struct FHitResult& Hit);
	void ReceiveOnDeactivate(class APlayerController* RestoredPC);
	void SetPawnMovementSpeedScale(float NewSpeedScale);
	void ShowDebugSelectedInfo();
	void ToggleDisplay();

	class AActor* GetSelectedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugCameraController">();
	}
	static class ADebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugCameraController>();
	}
};
static_assert(alignof(ADebugCameraController) == 0x1EF72E00, "Wrong alignment on ADebugCameraController");
static_assert(sizeof(ADebugCameraController) == 0x1EF72E00, "Wrong size on ADebugCameraController");
static_assert(offsetof(ADebugCameraController, DrawFrustum) == 0x000830, "Member 'ADebugCameraController::DrawFrustum' has a wrong offset!");
static_assert(offsetof(ADebugCameraController, SpeedScale) == 0x000858, "Member 'ADebugCameraController::SpeedScale' has a wrong offset!");
static_assert(offsetof(ADebugCameraController, InitialMaxSpeed) == 0x00085C, "Member 'ADebugCameraController::InitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(ADebugCameraController, InitialAccel) == 0x000860, "Member 'ADebugCameraController::InitialAccel' has a wrong offset!");
static_assert(offsetof(ADebugCameraController, InitialDecel) == 0x000864, "Member 'ADebugCameraController::InitialDecel' has a wrong offset!");

// Class Engine.MaterialExpressionTextureSampleParameterCube
// 0x0000 (0x112F2730 - 0x112F2730)
class UMaterialExpressionTextureSampleParameterCube final : public UMaterialExpressionTextureSampleParameter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureSampleParameterCube">();
	}
	static class UMaterialExpressionTextureSampleParameterCube* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureSampleParameterCube>();
	}
};
static_assert(alignof(UMaterialExpressionTextureSampleParameterCube) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureSampleParameterCube");
static_assert(sizeof(UMaterialExpressionTextureSampleParameterCube) == 0x112F2730, "Wrong size on UMaterialExpressionTextureSampleParameterCube");

// Class Engine.DemoPendingNetGame
// 0x0000 (0x00E0 - 0x00E0)
class UDemoPendingNetGame final : public UPendingNetGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemoPendingNetGame">();
	}
	static class UDemoPendingNetGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemoPendingNetGame>();
	}
};
static_assert(alignof(UDemoPendingNetGame) == 0x000008, "Wrong alignment on UDemoPendingNetGame");
static_assert(sizeof(UDemoPendingNetGame) == 0x0000E0, "Wrong size on UDemoPendingNetGame");

// Class Engine.MeshMergeCullingVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMeshMergeCullingVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshMergeCullingVolume">();
	}
	static class AMeshMergeCullingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeshMergeCullingVolume>();
	}
};
static_assert(alignof(AMeshMergeCullingVolume) == 0x1EF72E00, "Wrong alignment on AMeshMergeCullingVolume");
static_assert(sizeof(AMeshMergeCullingVolume) == 0x1EF72E00, "Wrong size on AMeshMergeCullingVolume");

// Class Engine.DestructibleComponent
// 0x0000 (0x112EB690 - 0x112EB690)
class UDestructibleComponent final : public USkinnedMeshComponent
{
public:
	uint8                                         bFractureEffectOverride : 1;                       // 0x0B28(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B29[0x7];                                      // 0x0B29(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFractureEffect>                FractureEffects;                                   // 0x0B30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableHardSleeping;                               // 0x0B40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B41[0x3];                                      // 0x0B41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LargeChunkThreshold;                               // 0x0B44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B48[0x10];                                     // 0x0B48(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnComponentFracture;                               // 0x0B58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B68[0x98];                                     // 0x0B68(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDamage(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength);
	void ApplyRadiusDamage(float BaseDamage, const struct FVector& HurtOrigin, float DamageRadius, float ImpulseStrength, bool bFullDamage);
	class UDestructibleMesh* GetDestructibleMesh();
	void SetDestructibleMesh(class UDestructibleMesh* NewMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleComponent">();
	}
	static class UDestructibleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleComponent>();
	}
};
static_assert(alignof(UDestructibleComponent) == 0x112EB690, "Wrong alignment on UDestructibleComponent");
static_assert(sizeof(UDestructibleComponent) == 0x112EB690, "Wrong size on UDestructibleComponent");
static_assert(offsetof(UDestructibleComponent, FractureEffects) == 0x000B30, "Member 'UDestructibleComponent::FractureEffects' has a wrong offset!");
static_assert(offsetof(UDestructibleComponent, bEnableHardSleeping) == 0x000B40, "Member 'UDestructibleComponent::bEnableHardSleeping' has a wrong offset!");
static_assert(offsetof(UDestructibleComponent, LargeChunkThreshold) == 0x000B44, "Member 'UDestructibleComponent::LargeChunkThreshold' has a wrong offset!");
static_assert(offsetof(UDestructibleComponent, OnComponentFracture) == 0x000B58, "Member 'UDestructibleComponent::OnComponentFracture' has a wrong offset!");

// Class Engine.SimpleConstructionScript
// 0x0090 (0x00D0 - 0x0040)
class USimpleConstructionScript final : public UObject
{
public:
	TArray<class USCS_Node*>                      RootNodes;                                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USCS_Node*>                      AllNodes;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class USCS_Node*                              DefaultSceneRootNode;                              // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USCS_Node*                              RootNode;                                          // 0x0068(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USCS_Node*>                      ActorComponentNodes;                               // 0x0070(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleConstructionScript">();
	}
	static class USimpleConstructionScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleConstructionScript>();
	}
};
static_assert(alignof(USimpleConstructionScript) == 0x000008, "Wrong alignment on USimpleConstructionScript");
static_assert(sizeof(USimpleConstructionScript) == 0x0000D0, "Wrong size on USimpleConstructionScript");
static_assert(offsetof(USimpleConstructionScript, RootNodes) == 0x000040, "Member 'USimpleConstructionScript::RootNodes' has a wrong offset!");
static_assert(offsetof(USimpleConstructionScript, AllNodes) == 0x000050, "Member 'USimpleConstructionScript::AllNodes' has a wrong offset!");
static_assert(offsetof(USimpleConstructionScript, DefaultSceneRootNode) == 0x000060, "Member 'USimpleConstructionScript::DefaultSceneRootNode' has a wrong offset!");
static_assert(offsetof(USimpleConstructionScript, RootNode) == 0x000068, "Member 'USimpleConstructionScript::RootNode' has a wrong offset!");
static_assert(offsetof(USimpleConstructionScript, ActorComponentNodes) == 0x000070, "Member 'USimpleConstructionScript::ActorComponentNodes' has a wrong offset!");

// Class Engine.DialogueWave
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class UDialogueWave final : public UObject
{
public:
	uint8                                         bMature : 1;                                       // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SubtitleOverride : 1;                    // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpokenText;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubtitleOverride;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDialogueContextMapping>        ContextMappings;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  LocalizationGUID;                                  // 0x0078(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueWave">();
	}
	static class UDialogueWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueWave>();
	}
};
static_assert(alignof(UDialogueWave) == 0x112E8D20, "Wrong alignment on UDialogueWave");
static_assert(sizeof(UDialogueWave) == 0x112E8D20, "Wrong size on UDialogueWave");
static_assert(offsetof(UDialogueWave, SpokenText) == 0x000048, "Member 'UDialogueWave::SpokenText' has a wrong offset!");
static_assert(offsetof(UDialogueWave, SubtitleOverride) == 0x000058, "Member 'UDialogueWave::SubtitleOverride' has a wrong offset!");
static_assert(offsetof(UDialogueWave, ContextMappings) == 0x000068, "Member 'UDialogueWave::ContextMappings' has a wrong offset!");
static_assert(offsetof(UDialogueWave, LocalizationGUID) == 0x000078, "Member 'UDialogueWave::LocalizationGUID' has a wrong offset!");

// Class Engine.DirectionalLight
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADirectionalLight final : public ALight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalLight">();
	}
	static class ADirectionalLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADirectionalLight>();
	}
};
static_assert(alignof(ADirectionalLight) == 0x1EF72E00, "Wrong alignment on ADirectionalLight");
static_assert(sizeof(ADirectionalLight) == 0x1EF72E00, "Wrong size on ADirectionalLight");

// Class Engine.NavRelevantInterface
// 0x0000 (0x0040 - 0x0040)
class INavRelevantInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavRelevantInterface">();
	}
	static class INavRelevantInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavRelevantInterface>();
	}
};
static_assert(alignof(INavRelevantInterface) == 0x000008, "Wrong alignment on INavRelevantInterface");
static_assert(sizeof(INavRelevantInterface) == 0x000040, "Wrong size on INavRelevantInterface");

// Class Engine.DistributionFloatConstant
// 0x0008 (0x0058 - 0x0050)
class UDistributionFloatConstant : public UDistributionFloat
{
public:
	float                                         Constant;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatConstant">();
	}
	static class UDistributionFloatConstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatConstant>();
	}
};
static_assert(alignof(UDistributionFloatConstant) == 0x000008, "Wrong alignment on UDistributionFloatConstant");
static_assert(sizeof(UDistributionFloatConstant) == 0x000058, "Wrong size on UDistributionFloatConstant");
static_assert(offsetof(UDistributionFloatConstant, Constant) == 0x000050, "Member 'UDistributionFloatConstant::Constant' has a wrong offset!");

// Class Engine.SoundGroups
// 0x0060 (0x00A0 - 0x0040)
class USoundGroups final : public UObject
{
public:
	TArray<struct FSoundGroup>                    SoundGroupProfiles;                                // 0x0040(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundGroups">();
	}
	static class USoundGroups* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundGroups>();
	}
};
static_assert(alignof(USoundGroups) == 0x000008, "Wrong alignment on USoundGroups");
static_assert(sizeof(USoundGroups) == 0x0000A0, "Wrong size on USoundGroups");
static_assert(offsetof(USoundGroups, SoundGroupProfiles) == 0x000040, "Member 'USoundGroups::SoundGroupProfiles' has a wrong offset!");

// Class Engine.DistributionFloatParameterBase
// 0x0020 (0x0078 - 0x0058)
class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
public:
	class FName                                   ParameterName;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInput;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInput;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOutput;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOutput;                                         // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistributionParamMode                        ParamMode;                                         // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatParameterBase">();
	}
	static class UDistributionFloatParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatParameterBase>();
	}
};
static_assert(alignof(UDistributionFloatParameterBase) == 0x000008, "Wrong alignment on UDistributionFloatParameterBase");
static_assert(sizeof(UDistributionFloatParameterBase) == 0x000078, "Wrong size on UDistributionFloatParameterBase");
static_assert(offsetof(UDistributionFloatParameterBase, ParameterName) == 0x000058, "Member 'UDistributionFloatParameterBase::ParameterName' has a wrong offset!");
static_assert(offsetof(UDistributionFloatParameterBase, MinInput) == 0x000060, "Member 'UDistributionFloatParameterBase::MinInput' has a wrong offset!");
static_assert(offsetof(UDistributionFloatParameterBase, MaxInput) == 0x000064, "Member 'UDistributionFloatParameterBase::MaxInput' has a wrong offset!");
static_assert(offsetof(UDistributionFloatParameterBase, MinOutput) == 0x000068, "Member 'UDistributionFloatParameterBase::MinOutput' has a wrong offset!");
static_assert(offsetof(UDistributionFloatParameterBase, MaxOutput) == 0x00006C, "Member 'UDistributionFloatParameterBase::MaxOutput' has a wrong offset!");
static_assert(offsetof(UDistributionFloatParameterBase, ParamMode) == 0x000070, "Member 'UDistributionFloatParameterBase::ParamMode' has a wrong offset!");

// Class Engine.MaterialExpressionNoise
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionNoise final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Position;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       FilterWidth;                                       // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quality;                                           // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENoiseFunction                                NoiseFunction;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTurbulence : 1;                                   // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Levels;                                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutputMin;                                         // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutputMax;                                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelScale;                                        // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTiling : 1;                                       // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        RepeatSize;                                        // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionNoise">();
	}
	static class UMaterialExpressionNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionNoise>();
	}
};
static_assert(alignof(UMaterialExpressionNoise) == 0x112F2730, "Wrong alignment on UMaterialExpressionNoise");
static_assert(sizeof(UMaterialExpressionNoise) == 0x112F2730, "Wrong size on UMaterialExpressionNoise");
static_assert(offsetof(UMaterialExpressionNoise, Position) == 0x000078, "Member 'UMaterialExpressionNoise::Position' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, FilterWidth) == 0x0000B0, "Member 'UMaterialExpressionNoise::FilterWidth' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, Scale) == 0x0000E8, "Member 'UMaterialExpressionNoise::Scale' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, Quality) == 0x0000EC, "Member 'UMaterialExpressionNoise::Quality' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, NoiseFunction) == 0x0000F0, "Member 'UMaterialExpressionNoise::NoiseFunction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, Levels) == 0x0000F8, "Member 'UMaterialExpressionNoise::Levels' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, OutputMin) == 0x0000FC, "Member 'UMaterialExpressionNoise::OutputMin' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, OutputMax) == 0x000100, "Member 'UMaterialExpressionNoise::OutputMax' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, LevelScale) == 0x000104, "Member 'UMaterialExpressionNoise::LevelScale' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionNoise, RepeatSize) == 0x00010C, "Member 'UMaterialExpressionNoise::RepeatSize' has a wrong offset!");

// Class Engine.DistributionFloatParticleParameter
// 0x0000 (0x0078 - 0x0078)
class UDistributionFloatParticleParameter final : public UDistributionFloatParameterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatParticleParameter">();
	}
	static class UDistributionFloatParticleParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatParticleParameter>();
	}
};
static_assert(alignof(UDistributionFloatParticleParameter) == 0x000008, "Wrong alignment on UDistributionFloatParticleParameter");
static_assert(sizeof(UDistributionFloatParticleParameter) == 0x000078, "Wrong size on UDistributionFloatParticleParameter");

// Class Engine.DistributionFloatUniform
// 0x0008 (0x0058 - 0x0050)
class UDistributionFloatUniform final : public UDistributionFloat
{
public:
	float                                         Min;                                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatUniform">();
	}
	static class UDistributionFloatUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatUniform>();
	}
};
static_assert(alignof(UDistributionFloatUniform) == 0x000008, "Wrong alignment on UDistributionFloatUniform");
static_assert(sizeof(UDistributionFloatUniform) == 0x000058, "Wrong size on UDistributionFloatUniform");
static_assert(offsetof(UDistributionFloatUniform, Min) == 0x000050, "Member 'UDistributionFloatUniform::Min' has a wrong offset!");
static_assert(offsetof(UDistributionFloatUniform, Max) == 0x000054, "Member 'UDistributionFloatUniform::Max' has a wrong offset!");

// Class Engine.DistributionFloatUniformCurve
// 0x112ECCE0 (0x112ECD30 - 0x0050)
class UDistributionFloatUniformCurve final : public UDistributionFloat
{
public:
	struct FInterpCurveVector2D                   ConstantCurve;                                     // 0x0050(0x112ECD30)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionFloatUniformCurve">();
	}
	static class UDistributionFloatUniformCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionFloatUniformCurve>();
	}
};
static_assert(alignof(UDistributionFloatUniformCurve) == 0x112ECD30, "Wrong alignment on UDistributionFloatUniformCurve");
static_assert(sizeof(UDistributionFloatUniformCurve) == 0x112ECD30, "Wrong size on UDistributionFloatUniformCurve");
static_assert(offsetof(UDistributionFloatUniformCurve, ConstantCurve) == 0x000050, "Member 'UDistributionFloatUniformCurve::ConstantCurve' has a wrong offset!");

// Class Engine.MaterialExpressionCustom
// 0x0058 (0x00D0 - 0x0078)
class UMaterialExpressionCustom final : public UMaterialExpression
{
public:
	class FString                                 Code;                                              // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomMaterialOutputType                     OutputType;                                        // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomInput>                   Inputs;                                            // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SQEX_IncludeFiles;                                 // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SQEX_CacheVariableName;                            // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCustom">();
	}
	static class UMaterialExpressionCustom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCustom>();
	}
};
static_assert(alignof(UMaterialExpressionCustom) == 0x000008, "Wrong alignment on UMaterialExpressionCustom");
static_assert(sizeof(UMaterialExpressionCustom) == 0x0000D0, "Wrong size on UMaterialExpressionCustom");
static_assert(offsetof(UMaterialExpressionCustom, Code) == 0x000078, "Member 'UMaterialExpressionCustom::Code' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCustom, OutputType) == 0x000088, "Member 'UMaterialExpressionCustom::OutputType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCustom, Description) == 0x000090, "Member 'UMaterialExpressionCustom::Description' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCustom, Inputs) == 0x0000A0, "Member 'UMaterialExpressionCustom::Inputs' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCustom, SQEX_IncludeFiles) == 0x0000B0, "Member 'UMaterialExpressionCustom::SQEX_IncludeFiles' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCustom, SQEX_CacheVariableName) == 0x0000C0, "Member 'UMaterialExpressionCustom::SQEX_CacheVariableName' has a wrong offset!");

// Class Engine.DistributionVectorConstant
// 0x0018 (0x0068 - 0x0050)
class UDistributionVectorConstant : public UDistributionVector
{
public:
	struct FVector                                Constant;                                          // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockAxes : 1;                                     // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDistributionVectorLockFlags                  LockedAxes;                                        // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorConstant">();
	}
	static class UDistributionVectorConstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorConstant>();
	}
};
static_assert(alignof(UDistributionVectorConstant) == 0x000008, "Wrong alignment on UDistributionVectorConstant");
static_assert(sizeof(UDistributionVectorConstant) == 0x000068, "Wrong size on UDistributionVectorConstant");
static_assert(offsetof(UDistributionVectorConstant, Constant) == 0x000050, "Member 'UDistributionVectorConstant::Constant' has a wrong offset!");
static_assert(offsetof(UDistributionVectorConstant, LockedAxes) == 0x000060, "Member 'UDistributionVectorConstant::LockedAxes' has a wrong offset!");

// Class Engine.DistributionVectorConstantCurve
// 0x112ED3C0 (0x112ED410 - 0x0050)
class UDistributionVectorConstantCurve final : public UDistributionVector
{
public:
	struct FInterpCurveVector                     ConstantCurve;                                     // 0x0050(0x112ED410)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockAxes : 1;                                     // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDistributionVectorLockFlags                  LockedAxes;                                        // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorConstantCurve">();
	}
	static class UDistributionVectorConstantCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorConstantCurve>();
	}
};
static_assert(alignof(UDistributionVectorConstantCurve) == 0x112ED410, "Wrong alignment on UDistributionVectorConstantCurve");
static_assert(sizeof(UDistributionVectorConstantCurve) == 0x112ED410, "Wrong size on UDistributionVectorConstantCurve");
static_assert(offsetof(UDistributionVectorConstantCurve, ConstantCurve) == 0x000050, "Member 'UDistributionVectorConstantCurve::ConstantCurve' has a wrong offset!");
static_assert(offsetof(UDistributionVectorConstantCurve, LockedAxes) == 0x00006C, "Member 'UDistributionVectorConstantCurve::LockedAxes' has a wrong offset!");

// Class Engine.MaterialExpressionBentNormalCustomOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionBentNormalCustomOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBentNormalCustomOutput">();
	}
	static class UMaterialExpressionBentNormalCustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBentNormalCustomOutput>();
	}
};
static_assert(alignof(UMaterialExpressionBentNormalCustomOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionBentNormalCustomOutput");
static_assert(sizeof(UMaterialExpressionBentNormalCustomOutput) == 0x112F2730, "Wrong size on UMaterialExpressionBentNormalCustomOutput");
static_assert(offsetof(UMaterialExpressionBentNormalCustomOutput, Input) == 0x000078, "Member 'UMaterialExpressionBentNormalCustomOutput::Input' has a wrong offset!");

// Class Engine.DistributionVectorParameterBase
// 0x0040 (0x00A8 - 0x0068)
class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
public:
	class FName                                   ParameterName;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinInput;                                          // 0x0070(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxInput;                                          // 0x007C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinOutput;                                         // 0x0088(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxOutput;                                         // 0x0094(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistributionParamMode                        ParamModes[0x3];                                   // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorParameterBase">();
	}
	static class UDistributionVectorParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorParameterBase>();
	}
};
static_assert(alignof(UDistributionVectorParameterBase) == 0x000008, "Wrong alignment on UDistributionVectorParameterBase");
static_assert(sizeof(UDistributionVectorParameterBase) == 0x0000A8, "Wrong size on UDistributionVectorParameterBase");
static_assert(offsetof(UDistributionVectorParameterBase, ParameterName) == 0x000068, "Member 'UDistributionVectorParameterBase::ParameterName' has a wrong offset!");
static_assert(offsetof(UDistributionVectorParameterBase, MinInput) == 0x000070, "Member 'UDistributionVectorParameterBase::MinInput' has a wrong offset!");
static_assert(offsetof(UDistributionVectorParameterBase, MaxInput) == 0x00007C, "Member 'UDistributionVectorParameterBase::MaxInput' has a wrong offset!");
static_assert(offsetof(UDistributionVectorParameterBase, MinOutput) == 0x000088, "Member 'UDistributionVectorParameterBase::MinOutput' has a wrong offset!");
static_assert(offsetof(UDistributionVectorParameterBase, MaxOutput) == 0x000094, "Member 'UDistributionVectorParameterBase::MaxOutput' has a wrong offset!");
static_assert(offsetof(UDistributionVectorParameterBase, ParamModes) == 0x0000A0, "Member 'UDistributionVectorParameterBase::ParamModes' has a wrong offset!");

// Class Engine.SoundAttenuation
// 0x110BA (0x110FA - 0x0040)
class USoundAttenuation final : public UObject
{
public:
	struct FSoundAttenuationSettings              Attenuation;                                       // 0x0040(0x11487DA0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundAttenuation">();
	}
	static class USoundAttenuation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundAttenuation>();
	}
};
static_assert(alignof(USoundAttenuation) == 0x0110FA, "Wrong alignment on USoundAttenuation");
static_assert(sizeof(USoundAttenuation) == 0x0110FA, "Wrong size on USoundAttenuation");
static_assert(offsetof(USoundAttenuation, Attenuation) == 0x000040, "Member 'USoundAttenuation::Attenuation' has a wrong offset!");

// Class Engine.DistributionVectorParticleParameter
// 0x0000 (0x00A8 - 0x00A8)
class UDistributionVectorParticleParameter final : public UDistributionVectorParameterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorParticleParameter">();
	}
	static class UDistributionVectorParticleParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorParticleParameter>();
	}
};
static_assert(alignof(UDistributionVectorParticleParameter) == 0x000008, "Wrong alignment on UDistributionVectorParticleParameter");
static_assert(sizeof(UDistributionVectorParticleParameter) == 0x0000A8, "Wrong size on UDistributionVectorParticleParameter");

// Class Engine.DistributionVectorUniformCurve
// 0x112EE180 (0x112EE1D0 - 0x0050)
class UDistributionVectorUniformCurve final : public UDistributionVector
{
public:
	struct FInterpCurveTwoVectors                 ConstantCurve;                                     // 0x0050(0x112EE1D0)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockAxes1 : 1;                                    // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockAxes2 : 1;                                    // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDistributionVectorLockFlags                  LockedAxes[0x2];                                   // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistributionVectorMirrorFlags                MirrorFlags[0x3];                                  // 0x006E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseExtremes : 1;                                  // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistributionVectorUniformCurve">();
	}
	static class UDistributionVectorUniformCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistributionVectorUniformCurve>();
	}
};
static_assert(alignof(UDistributionVectorUniformCurve) == 0x112EE1D0, "Wrong alignment on UDistributionVectorUniformCurve");
static_assert(sizeof(UDistributionVectorUniformCurve) == 0x112EE1D0, "Wrong size on UDistributionVectorUniformCurve");
static_assert(offsetof(UDistributionVectorUniformCurve, ConstantCurve) == 0x000050, "Member 'UDistributionVectorUniformCurve::ConstantCurve' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniformCurve, LockedAxes) == 0x00006C, "Member 'UDistributionVectorUniformCurve::LockedAxes' has a wrong offset!");
static_assert(offsetof(UDistributionVectorUniformCurve, MirrorFlags) == 0x00006E, "Member 'UDistributionVectorUniformCurve::MirrorFlags' has a wrong offset!");

// Class Engine.DocumentationActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ADocumentationActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DocumentationActor">();
	}
	static class ADocumentationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADocumentationActor>();
	}
};
static_assert(alignof(ADocumentationActor) == 0x1EF72E00, "Wrong alignment on ADocumentationActor");
static_assert(sizeof(ADocumentationActor) == 0x1EF72E00, "Wrong size on ADocumentationActor");

// Class Engine.MaterialExpressionFresnel
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFresnel final : public UMaterialExpression
{
public:
	struct FExpressionInput                       ExponentIn;                                        // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       BaseReflectFractionIn;                             // 0x00B8(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         BaseReflectFraction;                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Normal;                                            // 0x00F8(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFresnel">();
	}
	static class UMaterialExpressionFresnel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFresnel>();
	}
};
static_assert(alignof(UMaterialExpressionFresnel) == 0x112F2730, "Wrong alignment on UMaterialExpressionFresnel");
static_assert(sizeof(UMaterialExpressionFresnel) == 0x112F2730, "Wrong size on UMaterialExpressionFresnel");
static_assert(offsetof(UMaterialExpressionFresnel, ExponentIn) == 0x000078, "Member 'UMaterialExpressionFresnel::ExponentIn' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFresnel, Exponent) == 0x0000B0, "Member 'UMaterialExpressionFresnel::Exponent' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFresnel, BaseReflectFractionIn) == 0x0000B8, "Member 'UMaterialExpressionFresnel::BaseReflectFractionIn' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFresnel, BaseReflectFraction) == 0x0000F0, "Member 'UMaterialExpressionFresnel::BaseReflectFraction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFresnel, Normal) == 0x0000F8, "Member 'UMaterialExpressionFresnel::Normal' has a wrong offset!");

// Class Engine.DrawFrustumComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UDrawFrustumComponent : public UPrimitiveComponent
{
public:
	struct FColor                                 FrustumColor;                                      // 0x0868(0x0004)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumAngle;                                      // 0x086C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumAspectRatio;                                // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumStartDist;                                  // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumEndDist;                                    // 0x0878(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87C[0x4];                                      // 0x087C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Texture;                                           // 0x0880(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_888[0x8];                                      // 0x0888(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawFrustumComponent">();
	}
	static class UDrawFrustumComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawFrustumComponent>();
	}
};
static_assert(alignof(UDrawFrustumComponent) == 0x112E9AF0, "Wrong alignment on UDrawFrustumComponent");
static_assert(sizeof(UDrawFrustumComponent) == 0x112E9AF0, "Wrong size on UDrawFrustumComponent");
static_assert(offsetof(UDrawFrustumComponent, FrustumColor) == 0x000868, "Member 'UDrawFrustumComponent::FrustumColor' has a wrong offset!");
static_assert(offsetof(UDrawFrustumComponent, FrustumAngle) == 0x00086C, "Member 'UDrawFrustumComponent::FrustumAngle' has a wrong offset!");
static_assert(offsetof(UDrawFrustumComponent, FrustumAspectRatio) == 0x000870, "Member 'UDrawFrustumComponent::FrustumAspectRatio' has a wrong offset!");
static_assert(offsetof(UDrawFrustumComponent, FrustumStartDist) == 0x000874, "Member 'UDrawFrustumComponent::FrustumStartDist' has a wrong offset!");
static_assert(offsetof(UDrawFrustumComponent, FrustumEndDist) == 0x000878, "Member 'UDrawFrustumComponent::FrustumEndDist' has a wrong offset!");
static_assert(offsetof(UDrawFrustumComponent, Texture) == 0x000880, "Member 'UDrawFrustumComponent::Texture' has a wrong offset!");

// Class Engine.ReporterGraph
// 0x0078 (0x00C0 - 0x0048)
class UReporterGraph final : public UReporterBase
{
public:
	uint8                                         Pad_48[0x78];                                      // 0x0048(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReporterGraph">();
	}
	static class UReporterGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReporterGraph>();
	}
};
static_assert(alignof(UReporterGraph) == 0x000008, "Wrong alignment on UReporterGraph");
static_assert(sizeof(UReporterGraph) == 0x0000C0, "Wrong size on UReporterGraph");

// Class Engine.DrawSphereComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UDrawSphereComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawSphereComponent">();
	}
	static class UDrawSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawSphereComponent>();
	}
};
static_assert(alignof(UDrawSphereComponent) == 0x112E9AF0, "Wrong alignment on UDrawSphereComponent");
static_assert(sizeof(UDrawSphereComponent) == 0x112E9AF0, "Wrong size on UDrawSphereComponent");

// Class Engine.EdGraph
// 0x0090 (0x00D0 - 0x0040)
class UEdGraph final : public UObject
{
public:
	TSubclassOf<class UEdGraphSchema>             Schema;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEdGraphNode*>                   Nodes;                                             // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEditable : 1;                                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDeletion : 1;                                // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRenaming : 1;                                // 0x0058(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x77];                                      // 0x0059(0x0077)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdGraph">();
	}
	static class UEdGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdGraph>();
	}
};
static_assert(alignof(UEdGraph) == 0x000008, "Wrong alignment on UEdGraph");
static_assert(sizeof(UEdGraph) == 0x0000D0, "Wrong size on UEdGraph");
static_assert(offsetof(UEdGraph, Schema) == 0x000040, "Member 'UEdGraph::Schema' has a wrong offset!");
static_assert(offsetof(UEdGraph, Nodes) == 0x000048, "Member 'UEdGraph::Nodes' has a wrong offset!");

// Class Engine.RecastFilter_UseDefaultArea
// 0x0000 (0x0060 - 0x0060)
class URecastFilter_UseDefaultArea final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecastFilter_UseDefaultArea">();
	}
	static class URecastFilter_UseDefaultArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecastFilter_UseDefaultArea>();
	}
};
static_assert(alignof(URecastFilter_UseDefaultArea) == 0x000008, "Wrong alignment on URecastFilter_UseDefaultArea");
static_assert(sizeof(URecastFilter_UseDefaultArea) == 0x000060, "Wrong size on URecastFilter_UseDefaultArea");

// Class Engine.SoundNodeModulator
// 0x0010 (0x0060 - 0x0050)
class USoundNodeModulator final : public USoundNode
{
public:
	float                                         PitchMin;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMin;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMax;                                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeModulator">();
	}
	static class USoundNodeModulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeModulator>();
	}
};
static_assert(alignof(USoundNodeModulator) == 0x000008, "Wrong alignment on USoundNodeModulator");
static_assert(sizeof(USoundNodeModulator) == 0x000060, "Wrong size on USoundNodeModulator");
static_assert(offsetof(USoundNodeModulator, PitchMin) == 0x000050, "Member 'USoundNodeModulator::PitchMin' has a wrong offset!");
static_assert(offsetof(USoundNodeModulator, PitchMax) == 0x000054, "Member 'USoundNodeModulator::PitchMax' has a wrong offset!");
static_assert(offsetof(USoundNodeModulator, VolumeMin) == 0x000058, "Member 'USoundNodeModulator::VolumeMin' has a wrong offset!");
static_assert(offsetof(USoundNodeModulator, VolumeMax) == 0x00005C, "Member 'USoundNodeModulator::VolumeMax' has a wrong offset!");

// Class Engine.EdGraphNode_Documentation
// 0x0000 (0x112E8D20 - 0x112E8D20)
class UEdGraphNode_Documentation final : public UEdGraphNode
{
public:
	class FString                                 Link;                                              // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Excerpt;                                           // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdGraphNode_Documentation">();
	}
	static class UEdGraphNode_Documentation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdGraphNode_Documentation>();
	}
};
static_assert(alignof(UEdGraphNode_Documentation) == 0x112E8D20, "Wrong alignment on UEdGraphNode_Documentation");
static_assert(sizeof(UEdGraphNode_Documentation) == 0x112E8D20, "Wrong size on UEdGraphNode_Documentation");
static_assert(offsetof(UEdGraphNode_Documentation, Link) == 0x0000B0, "Member 'UEdGraphNode_Documentation::Link' has a wrong offset!");
static_assert(offsetof(UEdGraphNode_Documentation, Excerpt) == 0x0000C0, "Member 'UEdGraphNode_Documentation::Excerpt' has a wrong offset!");

// Class Engine.EdGraphPin_Deprecated
// 0x0118 (0x0158 - 0x0040)
class UEdGraphPin_Deprecated final : public UObject
{
public:
	class FString                                 PinName;                                           // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PinToolTip;                                        // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEdGraphPinDirection                          Direction;                                         // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEdGraphPinType                        PinType;                                           // 0x0068(0x0080)(NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AutogeneratedDefaultValue;                         // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DefaultObject;                                     // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DefaultTextValue;                                  // 0x0110(0x0018)(NativeAccessSpecifierPublic)
	TArray<class UEdGraphPin_Deprecated*>         LinkedTo;                                          // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UEdGraphPin_Deprecated*>         SubPins;                                           // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UEdGraphPin_Deprecated*                 ParentPin;                                         // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEdGraphPin_Deprecated*                 ReferencePassThroughConnection;                    // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdGraphPin_Deprecated">();
	}
	static class UEdGraphPin_Deprecated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdGraphPin_Deprecated>();
	}
};
static_assert(alignof(UEdGraphPin_Deprecated) == 0x000008, "Wrong alignment on UEdGraphPin_Deprecated");
static_assert(sizeof(UEdGraphPin_Deprecated) == 0x000158, "Wrong size on UEdGraphPin_Deprecated");
static_assert(offsetof(UEdGraphPin_Deprecated, PinName) == 0x000040, "Member 'UEdGraphPin_Deprecated::PinName' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, PinToolTip) == 0x000050, "Member 'UEdGraphPin_Deprecated::PinToolTip' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, Direction) == 0x000060, "Member 'UEdGraphPin_Deprecated::Direction' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, PinType) == 0x000068, "Member 'UEdGraphPin_Deprecated::PinType' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, DefaultValue) == 0x0000E8, "Member 'UEdGraphPin_Deprecated::DefaultValue' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, AutogeneratedDefaultValue) == 0x0000F8, "Member 'UEdGraphPin_Deprecated::AutogeneratedDefaultValue' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, DefaultObject) == 0x000108, "Member 'UEdGraphPin_Deprecated::DefaultObject' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, DefaultTextValue) == 0x000110, "Member 'UEdGraphPin_Deprecated::DefaultTextValue' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, LinkedTo) == 0x000128, "Member 'UEdGraphPin_Deprecated::LinkedTo' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, SubPins) == 0x000138, "Member 'UEdGraphPin_Deprecated::SubPins' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, ParentPin) == 0x000148, "Member 'UEdGraphPin_Deprecated::ParentPin' has a wrong offset!");
static_assert(offsetof(UEdGraphPin_Deprecated, ReferencePassThroughConnection) == 0x000150, "Member 'UEdGraphPin_Deprecated::ReferencePassThroughConnection' has a wrong offset!");

// Class Engine.SoundSubmix
// 0x0028 (0x0068 - 0x0040)
class USoundSubmix final : public UObject
{
public:
	TArray<class USoundSubmix*>                   ChildSubmixes;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundSubmix*                           ParentSubmix;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundEffectSubmixPreset*>       SubmixEffectChain;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundSubmix">();
	}
	static class USoundSubmix* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundSubmix>();
	}
};
static_assert(alignof(USoundSubmix) == 0x000008, "Wrong alignment on USoundSubmix");
static_assert(sizeof(USoundSubmix) == 0x000068, "Wrong size on USoundSubmix");
static_assert(offsetof(USoundSubmix, ChildSubmixes) == 0x000040, "Member 'USoundSubmix::ChildSubmixes' has a wrong offset!");
static_assert(offsetof(USoundSubmix, ParentSubmix) == 0x000050, "Member 'USoundSubmix::ParentSubmix' has a wrong offset!");
static_assert(offsetof(USoundSubmix, SubmixEffectChain) == 0x000058, "Member 'USoundSubmix::SubmixEffectChain' has a wrong offset!");

// Class Engine.EdGraphSchema
// 0x0000 (0x0040 - 0x0040)
class UEdGraphSchema final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdGraphSchema">();
	}
	static class UEdGraphSchema* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdGraphSchema>();
	}
};
static_assert(alignof(UEdGraphSchema) == 0x000008, "Wrong alignment on UEdGraphSchema");
static_assert(sizeof(UEdGraphSchema) == 0x000040, "Wrong size on UEdGraphSchema");

// Class Engine.EndUserSettings
// 0x0010 (0x0050 - 0x0040)
class UEndUserSettings final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSendAnonymousUsageDataToEpic;                     // 0x0048(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendMeanTimeBetweenFailureDataToEpic;             // 0x0049(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowUserIdInUsageData;                           // 0x004A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndUserSettings">();
	}
	static class UEndUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndUserSettings>();
	}
};
static_assert(alignof(UEndUserSettings) == 0x000008, "Wrong alignment on UEndUserSettings");
static_assert(sizeof(UEndUserSettings) == 0x000050, "Wrong size on UEndUserSettings");
static_assert(offsetof(UEndUserSettings, bSendAnonymousUsageDataToEpic) == 0x000048, "Member 'UEndUserSettings::bSendAnonymousUsageDataToEpic' has a wrong offset!");
static_assert(offsetof(UEndUserSettings, bSendMeanTimeBetweenFailureDataToEpic) == 0x000049, "Member 'UEndUserSettings::bSendMeanTimeBetweenFailureDataToEpic' has a wrong offset!");
static_assert(offsetof(UEndUserSettings, bAllowUserIdInUsageData) == 0x00004A, "Member 'UEndUserSettings::bAllowUserIdInUsageData' has a wrong offset!");

// Class Engine.MaterialExpressionDynamicParameter
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionDynamicParameter final : public UMaterialExpression
{
public:
	TArray<class FString>                         ParamNames;                                        // 0x0078(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultValue;                                      // 0x0088(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDynamicParameter">();
	}
	static class UMaterialExpressionDynamicParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDynamicParameter>();
	}
};
static_assert(alignof(UMaterialExpressionDynamicParameter) == 0x112EAE80, "Wrong alignment on UMaterialExpressionDynamicParameter");
static_assert(sizeof(UMaterialExpressionDynamicParameter) == 0x112EAE80, "Wrong size on UMaterialExpressionDynamicParameter");
static_assert(offsetof(UMaterialExpressionDynamicParameter, ParamNames) == 0x000078, "Member 'UMaterialExpressionDynamicParameter::ParamNames' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDynamicParameter, DefaultValue) == 0x000088, "Member 'UMaterialExpressionDynamicParameter::DefaultValue' has a wrong offset!");

// Class Engine.NavLinkComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UNavLinkComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNavigationLink>                Links;                                             // 0x0870(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkComponent">();
	}
	static class UNavLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkComponent>();
	}
};
static_assert(alignof(UNavLinkComponent) == 0x112E9AF0, "Wrong alignment on UNavLinkComponent");
static_assert(sizeof(UNavLinkComponent) == 0x112E9AF0, "Wrong size on UNavLinkComponent");
static_assert(offsetof(UNavLinkComponent, Links) == 0x000870, "Member 'UNavLinkComponent::Links' has a wrong offset!");

// Class Engine.EngineBaseTypes
// 0x0000 (0x0040 - 0x0040)
class UEngineBaseTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngineBaseTypes">();
	}
	static class UEngineBaseTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngineBaseTypes>();
	}
};
static_assert(alignof(UEngineBaseTypes) == 0x000008, "Wrong alignment on UEngineBaseTypes");
static_assert(sizeof(UEngineBaseTypes) == 0x000040, "Wrong size on UEngineBaseTypes");

// Class Engine.MaterialExpressionCollectionParameter
// 0x112E8CA8 (0x112E8D20 - 0x0078)
class UMaterialExpressionCollectionParameter final : public UMaterialExpression
{
public:
	class UMaterialParameterCollection*           Collection;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ParameterId;                                       // 0x0088(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCollectionParameter">();
	}
	static class UMaterialExpressionCollectionParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCollectionParameter>();
	}
};
static_assert(alignof(UMaterialExpressionCollectionParameter) == 0x112E8D20, "Wrong alignment on UMaterialExpressionCollectionParameter");
static_assert(sizeof(UMaterialExpressionCollectionParameter) == 0x112E8D20, "Wrong size on UMaterialExpressionCollectionParameter");
static_assert(offsetof(UMaterialExpressionCollectionParameter, Collection) == 0x000078, "Member 'UMaterialExpressionCollectionParameter::Collection' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCollectionParameter, ParameterName) == 0x000080, "Member 'UMaterialExpressionCollectionParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionCollectionParameter, ParameterId) == 0x000088, "Member 'UMaterialExpressionCollectionParameter::ParameterId' has a wrong offset!");

// Class Engine.EngineHandlerComponentFactory
// 0x0000 (0x0040 - 0x0040)
class UEngineHandlerComponentFactory final : public UHandlerComponentFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngineHandlerComponentFactory">();
	}
	static class UEngineHandlerComponentFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngineHandlerComponentFactory>();
	}
};
static_assert(alignof(UEngineHandlerComponentFactory) == 0x000008, "Wrong alignment on UEngineHandlerComponentFactory");
static_assert(sizeof(UEngineHandlerComponentFactory) == 0x000040, "Wrong size on UEngineHandlerComponentFactory");

// Class Engine.EngineMessage
// 0x0080 (0x00C0 - 0x0040)
class UEngineMessage final : public ULocalMessage
{
public:
	class FString                                 FailedPlaceMessage;                                // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaxedOutMessage;                                   // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnteredMessage;                                    // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftMessage;                                       // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GlobalNameChange;                                  // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecEnteredMessage;                                // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewPlayerMessage;                                  // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewSpecMessage;                                    // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngineMessage">();
	}
	static class UEngineMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngineMessage>();
	}
};
static_assert(alignof(UEngineMessage) == 0x000008, "Wrong alignment on UEngineMessage");
static_assert(sizeof(UEngineMessage) == 0x0000C0, "Wrong size on UEngineMessage");
static_assert(offsetof(UEngineMessage, FailedPlaceMessage) == 0x000040, "Member 'UEngineMessage::FailedPlaceMessage' has a wrong offset!");
static_assert(offsetof(UEngineMessage, MaxedOutMessage) == 0x000050, "Member 'UEngineMessage::MaxedOutMessage' has a wrong offset!");
static_assert(offsetof(UEngineMessage, EnteredMessage) == 0x000060, "Member 'UEngineMessage::EnteredMessage' has a wrong offset!");
static_assert(offsetof(UEngineMessage, LeftMessage) == 0x000070, "Member 'UEngineMessage::LeftMessage' has a wrong offset!");
static_assert(offsetof(UEngineMessage, GlobalNameChange) == 0x000080, "Member 'UEngineMessage::GlobalNameChange' has a wrong offset!");
static_assert(offsetof(UEngineMessage, SpecEnteredMessage) == 0x000090, "Member 'UEngineMessage::SpecEnteredMessage' has a wrong offset!");
static_assert(offsetof(UEngineMessage, NewPlayerMessage) == 0x0000A0, "Member 'UEngineMessage::NewPlayerMessage' has a wrong offset!");
static_assert(offsetof(UEngineMessage, NewSpecMessage) == 0x0000B0, "Member 'UEngineMessage::NewSpecMessage' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSpeed
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleSpeed final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSpeed">();
	}
	static class UMaterialExpressionParticleSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSpeed>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSpeed) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSpeed");
static_assert(sizeof(UMaterialExpressionParticleSpeed) == 0x000078, "Wrong size on UMaterialExpressionParticleSpeed");

// Class Engine.SoundNodeDialoguePlayer
// 0x0028 (0x0078 - 0x0050)
class USoundNodeDialoguePlayer final : public USoundNode
{
public:
	struct FDialogueWaveParameter                 DialogueWaveParameter;                             // 0x0050(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeDialoguePlayer">();
	}
	static class USoundNodeDialoguePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeDialoguePlayer>();
	}
};
static_assert(alignof(USoundNodeDialoguePlayer) == 0x000008, "Wrong alignment on USoundNodeDialoguePlayer");
static_assert(sizeof(USoundNodeDialoguePlayer) == 0x000078, "Wrong size on USoundNodeDialoguePlayer");
static_assert(offsetof(USoundNodeDialoguePlayer, DialogueWaveParameter) == 0x000050, "Member 'USoundNodeDialoguePlayer::DialogueWaveParameter' has a wrong offset!");

// Class Engine.EngineTypes
// 0x0000 (0x0040 - 0x0040)
class UEngineTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngineTypes">();
	}
	static class UEngineTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngineTypes>();
	}
};
static_assert(alignof(UEngineTypes) == 0x000008, "Wrong alignment on UEngineTypes");
static_assert(sizeof(UEngineTypes) == 0x000040, "Wrong size on UEngineTypes");

// Class Engine.MaterialExpressionCameraVectorWS
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionCameraVectorWS final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCameraVectorWS">();
	}
	static class UMaterialExpressionCameraVectorWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCameraVectorWS>();
	}
};
static_assert(alignof(UMaterialExpressionCameraVectorWS) == 0x000008, "Wrong alignment on UMaterialExpressionCameraVectorWS");
static_assert(sizeof(UMaterialExpressionCameraVectorWS) == 0x000078, "Wrong size on UMaterialExpressionCameraVectorWS");

// Class Engine.ExponentialHeightFog
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AExponentialHeightFog final : public AInfo
{
public:
	class UExponentialHeightFogComponent*         Component;                                         // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnabled : 1;                                      // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExponentialHeightFog">();
	}
	static class AExponentialHeightFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExponentialHeightFog>();
	}
};
static_assert(alignof(AExponentialHeightFog) == 0x1EF72E00, "Wrong alignment on AExponentialHeightFog");
static_assert(sizeof(AExponentialHeightFog) == 0x1EF72E00, "Wrong size on AExponentialHeightFog");
static_assert(offsetof(AExponentialHeightFog, Component) == 0x0003E0, "Member 'AExponentialHeightFog::Component' has a wrong offset!");

// Class Engine.Exporter
// 0x0040 (0x0080 - 0x0040)
class UExporter final : public UObject
{
public:
	TSubclassOf<class UObject>                    SupportedClass;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ExportRootScope;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         FormatExtension;                                   // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FormatDescription;                                 // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PreferredFormatIndex;                              // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextIndent;                                        // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bText : 1;                                         // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSelectedOnly : 1;                                 // 0x0078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceFileOperations : 1;                          // 0x0078(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Exporter">();
	}
	static class UExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExporter>();
	}
};
static_assert(alignof(UExporter) == 0x000008, "Wrong alignment on UExporter");
static_assert(sizeof(UExporter) == 0x000080, "Wrong size on UExporter");
static_assert(offsetof(UExporter, SupportedClass) == 0x000040, "Member 'UExporter::SupportedClass' has a wrong offset!");
static_assert(offsetof(UExporter, ExportRootScope) == 0x000048, "Member 'UExporter::ExportRootScope' has a wrong offset!");
static_assert(offsetof(UExporter, FormatExtension) == 0x000050, "Member 'UExporter::FormatExtension' has a wrong offset!");
static_assert(offsetof(UExporter, FormatDescription) == 0x000060, "Member 'UExporter::FormatDescription' has a wrong offset!");
static_assert(offsetof(UExporter, PreferredFormatIndex) == 0x000070, "Member 'UExporter::PreferredFormatIndex' has a wrong offset!");
static_assert(offsetof(UExporter, TextIndent) == 0x000074, "Member 'UExporter::TextIndent' has a wrong offset!");

// Class Engine.MaterialExpressionMin
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionMin final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMin">();
	}
	static class UMaterialExpressionMin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMin>();
	}
};
static_assert(alignof(UMaterialExpressionMin) == 0x112F2730, "Wrong alignment on UMaterialExpressionMin");
static_assert(sizeof(UMaterialExpressionMin) == 0x112F2730, "Wrong size on UMaterialExpressionMin");
static_assert(offsetof(UMaterialExpressionMin, A) == 0x000078, "Member 'UMaterialExpressionMin::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMin, B) == 0x0000B0, "Member 'UMaterialExpressionMin::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMin, ConstA) == 0x0000E8, "Member 'UMaterialExpressionMin::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMin, ConstB) == 0x0000EC, "Member 'UMaterialExpressionMin::ConstB' has a wrong offset!");

// Class Engine.SqEx_EffectShaderParameter_Base
// 0x0000 (0x0040 - 0x0040)
class USqEx_EffectShaderParameter_Base : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqEx_EffectShaderParameter_Base">();
	}
	static class USqEx_EffectShaderParameter_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqEx_EffectShaderParameter_Base>();
	}
};
static_assert(alignof(USqEx_EffectShaderParameter_Base) == 0x000008, "Wrong alignment on USqEx_EffectShaderParameter_Base");
static_assert(sizeof(USqEx_EffectShaderParameter_Base) == 0x000040, "Wrong size on USqEx_EffectShaderParameter_Base");

// Class Engine.Font
// 0x116383A0 (0x116383E0 - 0x0040)
class UFont final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFontCacheType                                FontCacheType;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFontCharacter>                 Characters;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Textures;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         IsRemapped;                                        // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmScale;                                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ascent;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Descent;                                           // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Leading;                                           // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kerning;                                           // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFontImportOptionsData                 ImportOptions;                                     // 0x0088(0x116383E0)(Edit, NativeAccessSpecifierPublic)
	int32                                         NumCharacters;                                     // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MaxCharHeight;                                     // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         ScalingFactor;                                     // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegacyFontSize;                                    // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LegacyFontName;                                    // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCompositeFont                         CompositeFont;                                     // 0x0160(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x50];                                     // 0x0180(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Font">();
	}
	static class UFont* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFont>();
	}
};
static_assert(alignof(UFont) == 0x116383E0, "Wrong alignment on UFont");
static_assert(sizeof(UFont) == 0x116383E0, "Wrong size on UFont");
static_assert(offsetof(UFont, FontCacheType) == 0x000048, "Member 'UFont::FontCacheType' has a wrong offset!");
static_assert(offsetof(UFont, Characters) == 0x000050, "Member 'UFont::Characters' has a wrong offset!");
static_assert(offsetof(UFont, Textures) == 0x000060, "Member 'UFont::Textures' has a wrong offset!");
static_assert(offsetof(UFont, IsRemapped) == 0x000070, "Member 'UFont::IsRemapped' has a wrong offset!");
static_assert(offsetof(UFont, EmScale) == 0x000074, "Member 'UFont::EmScale' has a wrong offset!");
static_assert(offsetof(UFont, Ascent) == 0x000078, "Member 'UFont::Ascent' has a wrong offset!");
static_assert(offsetof(UFont, Descent) == 0x00007C, "Member 'UFont::Descent' has a wrong offset!");
static_assert(offsetof(UFont, Leading) == 0x000080, "Member 'UFont::Leading' has a wrong offset!");
static_assert(offsetof(UFont, Kerning) == 0x000084, "Member 'UFont::Kerning' has a wrong offset!");
static_assert(offsetof(UFont, ImportOptions) == 0x000088, "Member 'UFont::ImportOptions' has a wrong offset!");
static_assert(offsetof(UFont, NumCharacters) == 0x000138, "Member 'UFont::NumCharacters' has a wrong offset!");
static_assert(offsetof(UFont, MaxCharHeight) == 0x000140, "Member 'UFont::MaxCharHeight' has a wrong offset!");
static_assert(offsetof(UFont, ScalingFactor) == 0x000150, "Member 'UFont::ScalingFactor' has a wrong offset!");
static_assert(offsetof(UFont, LegacyFontSize) == 0x000154, "Member 'UFont::LegacyFontSize' has a wrong offset!");
static_assert(offsetof(UFont, LegacyFontName) == 0x000158, "Member 'UFont::LegacyFontName' has a wrong offset!");
static_assert(offsetof(UFont, CompositeFont) == 0x000160, "Member 'UFont::CompositeFont' has a wrong offset!");

// Class Engine.FontFace
// 0x0030 (0x0070 - 0x0040)
class UFontFace final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SourceFilename;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFontHinting                                  Hinting;                                           // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFontLoadingPolicy                            LoadingPolicy;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFontLayoutMethod                             LayoutMethod;                                      // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x15];                                      // 0x005B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FontFace">();
	}
	static class UFontFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFontFace>();
	}
};
static_assert(alignof(UFontFace) == 0x000008, "Wrong alignment on UFontFace");
static_assert(sizeof(UFontFace) == 0x000070, "Wrong size on UFontFace");
static_assert(offsetof(UFontFace, SourceFilename) == 0x000048, "Member 'UFontFace::SourceFilename' has a wrong offset!");
static_assert(offsetof(UFontFace, Hinting) == 0x000058, "Member 'UFontFace::Hinting' has a wrong offset!");
static_assert(offsetof(UFontFace, LoadingPolicy) == 0x000059, "Member 'UFontFace::LoadingPolicy' has a wrong offset!");
static_assert(offsetof(UFontFace, LayoutMethod) == 0x00005A, "Member 'UFontFace::LayoutMethod' has a wrong offset!");

// Class Engine.SQEX_DynamicBindAssetUserData
// 0x0030 (0x0078 - 0x0048)
class USQEX_DynamicBindAssetUserData final : public UDataAsset
{
public:
	struct FStringAssetReference                  M_BindTargetPath;                                  // 0x0048(0x0010)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetUserData*                         M_AssetUserData;                                   // 0x0058(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                M_BindTarget;                                      // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetUserData*                         M_OriginalAssetUserData;                           // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAssetUserData*                         M_DuplicatedAssetUserData;                         // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Bind();
	bool Unbind();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_DynamicBindAssetUserData">();
	}
	static class USQEX_DynamicBindAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_DynamicBindAssetUserData>();
	}
};
static_assert(alignof(USQEX_DynamicBindAssetUserData) == 0x000008, "Wrong alignment on USQEX_DynamicBindAssetUserData");
static_assert(sizeof(USQEX_DynamicBindAssetUserData) == 0x000078, "Wrong size on USQEX_DynamicBindAssetUserData");
static_assert(offsetof(USQEX_DynamicBindAssetUserData, M_BindTargetPath) == 0x000048, "Member 'USQEX_DynamicBindAssetUserData::M_BindTargetPath' has a wrong offset!");
static_assert(offsetof(USQEX_DynamicBindAssetUserData, M_AssetUserData) == 0x000058, "Member 'USQEX_DynamicBindAssetUserData::M_AssetUserData' has a wrong offset!");
static_assert(offsetof(USQEX_DynamicBindAssetUserData, M_BindTarget) == 0x000060, "Member 'USQEX_DynamicBindAssetUserData::M_BindTarget' has a wrong offset!");
static_assert(offsetof(USQEX_DynamicBindAssetUserData, M_OriginalAssetUserData) == 0x000068, "Member 'USQEX_DynamicBindAssetUserData::M_OriginalAssetUserData' has a wrong offset!");
static_assert(offsetof(USQEX_DynamicBindAssetUserData, M_DuplicatedAssetUserData) == 0x000070, "Member 'USQEX_DynamicBindAssetUserData::M_DuplicatedAssetUserData' has a wrong offset!");

// Class Engine.FontImportOptions
// 0x116383A0 (0x116383E0 - 0x0040)
class UFontImportOptions final : public UObject
{
public:
	struct FFontImportOptionsData                 Data;                                              // 0x0040(0x116383E0)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FontImportOptions">();
	}
	static class UFontImportOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFontImportOptions>();
	}
};
static_assert(alignof(UFontImportOptions) == 0x116383E0, "Wrong alignment on UFontImportOptions");
static_assert(sizeof(UFontImportOptions) == 0x116383E0, "Wrong size on UFontImportOptions");
static_assert(offsetof(UFontImportOptions, Data) == 0x000040, "Member 'UFontImportOptions::Data' has a wrong offset!");

// Class Engine.ForceFeedbackAttenuation
// 0x1229D (0x122DD - 0x0040)
class UForceFeedbackAttenuation final : public UObject
{
public:
	struct FForceFeedbackAttenuationSettings      Attenuation;                                       // 0x0040(0x11487DA0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackAttenuation">();
	}
	static class UForceFeedbackAttenuation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackAttenuation>();
	}
};
static_assert(alignof(UForceFeedbackAttenuation) == 0x0122DD, "Wrong alignment on UForceFeedbackAttenuation");
static_assert(sizeof(UForceFeedbackAttenuation) == 0x0122DD, "Wrong size on UForceFeedbackAttenuation");
static_assert(offsetof(UForceFeedbackAttenuation, Attenuation) == 0x000040, "Member 'UForceFeedbackAttenuation::Attenuation' has a wrong offset!");

// Class Engine.ParticleModuleLocationEmitterDirect
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleLocationEmitterDirect final : public UParticleModuleLocationBase
{
public:
	class FName                                   EmitterName;                                       // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationEmitterDirect">();
	}
	static class UParticleModuleLocationEmitterDirect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationEmitterDirect>();
	}
};
static_assert(alignof(UParticleModuleLocationEmitterDirect) == 0x000008, "Wrong alignment on UParticleModuleLocationEmitterDirect");
static_assert(sizeof(UParticleModuleLocationEmitterDirect) == 0x000058, "Wrong size on UParticleModuleLocationEmitterDirect");
static_assert(offsetof(UParticleModuleLocationEmitterDirect, EmitterName) == 0x000050, "Member 'UParticleModuleLocationEmitterDirect::EmitterName' has a wrong offset!");

// Class Engine.SphereReflectionCaptureComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USphereReflectionCaptureComponent final : public UReflectionCaptureComponent
{
public:
	float                                         InfluenceRadius;                                   // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureDistanceScale;                              // 0x048C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDrawSphereComponent*                   PreviewInfluenceRadius;                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereReflectionCaptureComponent">();
	}
	static class USphereReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USphereReflectionCaptureComponent>();
	}
};
static_assert(alignof(USphereReflectionCaptureComponent) == 0x112E9AF0, "Wrong alignment on USphereReflectionCaptureComponent");
static_assert(sizeof(USphereReflectionCaptureComponent) == 0x112E9AF0, "Wrong size on USphereReflectionCaptureComponent");
static_assert(offsetof(USphereReflectionCaptureComponent, InfluenceRadius) == 0x000488, "Member 'USphereReflectionCaptureComponent::InfluenceRadius' has a wrong offset!");
static_assert(offsetof(USphereReflectionCaptureComponent, CaptureDistanceScale) == 0x00048C, "Member 'USphereReflectionCaptureComponent::CaptureDistanceScale' has a wrong offset!");
static_assert(offsetof(USphereReflectionCaptureComponent, PreviewInfluenceRadius) == 0x000490, "Member 'USphereReflectionCaptureComponent::PreviewInfluenceRadius' has a wrong offset!");

// Class Engine.ForceFeedbackComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UForceFeedbackComponent final : public USceneComponent
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoDestroy : 1;                                  // 0x0420(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopWhenOwnerDestroyed : 1;                       // 0x0420(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLooping : 1;                                      // 0x0420(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideAttenuation : 1;                          // 0x0420(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityMultiplier;                               // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              AttenuationSettings;                               // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceFeedbackAttenuationSettings      AttenuationOverrides;                              // 0x0430(0x11487DA0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnForceFeedbackFinished;                           // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustAttenuation(const struct FForceFeedbackAttenuationSettings& InAttenuationSettings);
	void Play(float StartTime);
	void SetForceFeedbackEffect(class UForceFeedbackEffect* NewForceFeedbackEffect);
	void SetIntensityMultiplier(float NewIntensityMultiplier);
	void Stop();

	bool BP_GetAttenuationSettingsToApply(struct FForceFeedbackAttenuationSettings* OutAttenuationSettings) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackComponent">();
	}
	static class UForceFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackComponent>();
	}
};
static_assert(alignof(UForceFeedbackComponent) == 0x112E9AF0, "Wrong alignment on UForceFeedbackComponent");
static_assert(sizeof(UForceFeedbackComponent) == 0x112E9AF0, "Wrong size on UForceFeedbackComponent");
static_assert(offsetof(UForceFeedbackComponent, ForceFeedbackEffect) == 0x000418, "Member 'UForceFeedbackComponent::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UForceFeedbackComponent, IntensityMultiplier) == 0x000424, "Member 'UForceFeedbackComponent::IntensityMultiplier' has a wrong offset!");
static_assert(offsetof(UForceFeedbackComponent, AttenuationSettings) == 0x000428, "Member 'UForceFeedbackComponent::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(UForceFeedbackComponent, AttenuationOverrides) == 0x000430, "Member 'UForceFeedbackComponent::AttenuationOverrides' has a wrong offset!");
static_assert(offsetof(UForceFeedbackComponent, OnForceFeedbackFinished) == 0x0004D8, "Member 'UForceFeedbackComponent::OnForceFeedbackFinished' has a wrong offset!");

// Class Engine.ForceFeedbackEffect
// 0x0018 (0x0058 - 0x0040)
class UForceFeedbackEffect final : public UObject
{
public:
	TArray<struct FForceFeedbackChannelDetails>   ChannelDetails;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceFeedbackEffect">();
	}
	static class UForceFeedbackEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceFeedbackEffect>();
	}
};
static_assert(alignof(UForceFeedbackEffect) == 0x000008, "Wrong alignment on UForceFeedbackEffect");
static_assert(sizeof(UForceFeedbackEffect) == 0x000058, "Wrong size on UForceFeedbackEffect");
static_assert(offsetof(UForceFeedbackEffect, ChannelDetails) == 0x000040, "Member 'UForceFeedbackEffect::ChannelDetails' has a wrong offset!");
static_assert(offsetof(UForceFeedbackEffect, Duration) == 0x000050, "Member 'UForceFeedbackEffect::Duration' has a wrong offset!");

// Class Engine.GameNetworkManager
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AGameNetworkManager final : public AInfo
{
public:
	int32                                         AdjustedNetSpeed;                                  // 0x03E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastNetSpeedUpdateTime;                            // 0x03E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNetBandwidth;                                 // 0x03E8(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinDynamicBandwidth;                               // 0x03EC(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDynamicBandwidth;                               // 0x03F0(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsStandbyCheckingEnabled : 1;                     // 0x03F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasStandbyCheatTriggered : 1;                     // 0x03F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandbyRxCheatTime;                                // 0x03F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandbyTxCheatTime;                                // 0x03FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadPingThreshold;                                  // 0x0400(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentMissingForRxStandby;                        // 0x0404(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentMissingForTxStandby;                        // 0x0408(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentForBadPing;                                 // 0x040C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoinInProgressStandbyWaitTime;                     // 0x0410(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRepSize;                                       // 0x0414(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAXPOSITIONERRORSQUARED;                           // 0x0418(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAXNEARZEROVELOCITYSQUARED;                        // 0x041C(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CLIENTADJUSTUPDATECOST;                            // 0x0420(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAXCLIENTUPDATEINTERVAL;                           // 0x0424(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveDeltaTime;                                  // 0x0428(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientNetSendMoveDeltaTime;                        // 0x042C(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientNetSendMoveDeltaTimeThrottled;               // 0x0430(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClientNetSendMoveThrottleAtNetSpeed;               // 0x0434(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClientNetSendMoveThrottleOverPlayerCount;          // 0x0438(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClientAuthorativePosition;                         // 0x043C(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientErrorUpdateRateLimit;                        // 0x0440(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementTimeDiscrepancyDetection;                 // 0x0444(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementTimeDiscrepancyResolution;                // 0x0445(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_446[0x2];                                      // 0x0446(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementTimeDiscrepancyMaxTimeMargin;              // 0x0448(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementTimeDiscrepancyMinTimeMargin;              // 0x044C(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementTimeDiscrepancyResolutionRate;             // 0x0450(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementTimeDiscrepancyDriftAllowance;             // 0x0454(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementTimeDiscrepancyForceCorrectionsDuringResolution; // 0x0458(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceBasedRelevancy;                        // 0x0459(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45A[0xE];                                      // 0x045A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameNetworkManager">();
	}
	static class AGameNetworkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameNetworkManager>();
	}
};
static_assert(alignof(AGameNetworkManager) == 0x1EF72E00, "Wrong alignment on AGameNetworkManager");
static_assert(sizeof(AGameNetworkManager) == 0x1EF72E00, "Wrong size on AGameNetworkManager");
static_assert(offsetof(AGameNetworkManager, AdjustedNetSpeed) == 0x0003E0, "Member 'AGameNetworkManager::AdjustedNetSpeed' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, LastNetSpeedUpdateTime) == 0x0003E4, "Member 'AGameNetworkManager::LastNetSpeedUpdateTime' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, TotalNetBandwidth) == 0x0003E8, "Member 'AGameNetworkManager::TotalNetBandwidth' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MinDynamicBandwidth) == 0x0003EC, "Member 'AGameNetworkManager::MinDynamicBandwidth' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MaxDynamicBandwidth) == 0x0003F0, "Member 'AGameNetworkManager::MaxDynamicBandwidth' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, StandbyRxCheatTime) == 0x0003F8, "Member 'AGameNetworkManager::StandbyRxCheatTime' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, StandbyTxCheatTime) == 0x0003FC, "Member 'AGameNetworkManager::StandbyTxCheatTime' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, BadPingThreshold) == 0x000400, "Member 'AGameNetworkManager::BadPingThreshold' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, PercentMissingForRxStandby) == 0x000404, "Member 'AGameNetworkManager::PercentMissingForRxStandby' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, PercentMissingForTxStandby) == 0x000408, "Member 'AGameNetworkManager::PercentMissingForTxStandby' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, PercentForBadPing) == 0x00040C, "Member 'AGameNetworkManager::PercentForBadPing' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, JoinInProgressStandbyWaitTime) == 0x000410, "Member 'AGameNetworkManager::JoinInProgressStandbyWaitTime' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MoveRepSize) == 0x000414, "Member 'AGameNetworkManager::MoveRepSize' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MAXPOSITIONERRORSQUARED) == 0x000418, "Member 'AGameNetworkManager::MAXPOSITIONERRORSQUARED' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MAXNEARZEROVELOCITYSQUARED) == 0x00041C, "Member 'AGameNetworkManager::MAXNEARZEROVELOCITYSQUARED' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, CLIENTADJUSTUPDATECOST) == 0x000420, "Member 'AGameNetworkManager::CLIENTADJUSTUPDATECOST' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MAXCLIENTUPDATEINTERVAL) == 0x000424, "Member 'AGameNetworkManager::MAXCLIENTUPDATEINTERVAL' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MaxMoveDeltaTime) == 0x000428, "Member 'AGameNetworkManager::MaxMoveDeltaTime' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, ClientNetSendMoveDeltaTime) == 0x00042C, "Member 'AGameNetworkManager::ClientNetSendMoveDeltaTime' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, ClientNetSendMoveDeltaTimeThrottled) == 0x000430, "Member 'AGameNetworkManager::ClientNetSendMoveDeltaTimeThrottled' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, ClientNetSendMoveThrottleAtNetSpeed) == 0x000434, "Member 'AGameNetworkManager::ClientNetSendMoveThrottleAtNetSpeed' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, ClientNetSendMoveThrottleOverPlayerCount) == 0x000438, "Member 'AGameNetworkManager::ClientNetSendMoveThrottleOverPlayerCount' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, ClientAuthorativePosition) == 0x00043C, "Member 'AGameNetworkManager::ClientAuthorativePosition' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, ClientErrorUpdateRateLimit) == 0x000440, "Member 'AGameNetworkManager::ClientErrorUpdateRateLimit' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, bMovementTimeDiscrepancyDetection) == 0x000444, "Member 'AGameNetworkManager::bMovementTimeDiscrepancyDetection' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, bMovementTimeDiscrepancyResolution) == 0x000445, "Member 'AGameNetworkManager::bMovementTimeDiscrepancyResolution' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MovementTimeDiscrepancyMaxTimeMargin) == 0x000448, "Member 'AGameNetworkManager::MovementTimeDiscrepancyMaxTimeMargin' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MovementTimeDiscrepancyMinTimeMargin) == 0x00044C, "Member 'AGameNetworkManager::MovementTimeDiscrepancyMinTimeMargin' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MovementTimeDiscrepancyResolutionRate) == 0x000450, "Member 'AGameNetworkManager::MovementTimeDiscrepancyResolutionRate' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, MovementTimeDiscrepancyDriftAllowance) == 0x000454, "Member 'AGameNetworkManager::MovementTimeDiscrepancyDriftAllowance' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, bMovementTimeDiscrepancyForceCorrectionsDuringResolution) == 0x000458, "Member 'AGameNetworkManager::bMovementTimeDiscrepancyForceCorrectionsDuringResolution' has a wrong offset!");
static_assert(offsetof(AGameNetworkManager, bUseDistanceBasedRelevancy) == 0x000459, "Member 'AGameNetworkManager::bUseDistanceBasedRelevancy' has a wrong offset!");

// Class Engine.GameSession
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AGameSession final : public AInfo
{
public:
	int32                                         MaxSpectators;                                     // 0x03E0(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x03E4(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPartySize;                                      // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxSplitscreensPerConnection;                      // 0x03EC(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresPushToTalk;                               // 0x03ED(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EE[0x2];                                      // 0x03EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SessionName;                                       // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSession">();
	}
	static class AGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameSession>();
	}
};
static_assert(alignof(AGameSession) == 0x1EF72E00, "Wrong alignment on AGameSession");
static_assert(sizeof(AGameSession) == 0x1EF72E00, "Wrong size on AGameSession");
static_assert(offsetof(AGameSession, MaxSpectators) == 0x0003E0, "Member 'AGameSession::MaxSpectators' has a wrong offset!");
static_assert(offsetof(AGameSession, MaxPlayers) == 0x0003E4, "Member 'AGameSession::MaxPlayers' has a wrong offset!");
static_assert(offsetof(AGameSession, MaxPartySize) == 0x0003E8, "Member 'AGameSession::MaxPartySize' has a wrong offset!");
static_assert(offsetof(AGameSession, MaxSplitscreensPerConnection) == 0x0003EC, "Member 'AGameSession::MaxSplitscreensPerConnection' has a wrong offset!");
static_assert(offsetof(AGameSession, bRequiresPushToTalk) == 0x0003ED, "Member 'AGameSession::bRequiresPushToTalk' has a wrong offset!");
static_assert(offsetof(AGameSession, SessionName) == 0x0003F0, "Member 'AGameSession::SessionName' has a wrong offset!");

// Class Engine.GameState
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AGameState : public AGameStateBase
{
public:
	class FName                                   MatchState;                                        // 0x11F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PreviousMatchState;                                // 0x11F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ElapsedTime;                                       // 0x1200(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1204[0xC];                                     // 0x1204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ElapsedTime();
	void OnRep_MatchState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameState">();
	}
	static class AGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameState>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGameState) == 0x1EF72E00, "Wrong alignment on AGameState");
static_assert(sizeof(AGameState) == 0x1EF72E00, "Wrong size on AGameState");
static_assert(offsetof(AGameState, MatchState) == 0x0011F0, "Member 'AGameState::MatchState' has a wrong offset!");
static_assert(offsetof(AGameState, PreviousMatchState) == 0x0011F8, "Member 'AGameState::PreviousMatchState' has a wrong offset!");
static_assert(offsetof(AGameState, ElapsedTime) == 0x001200, "Member 'AGameState::ElapsedTime' has a wrong offset!");

// Class Engine.GeneratedMeshAreaLight
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AGeneratedMeshAreaLight final : public ASpotLight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratedMeshAreaLight">();
	}
	static class AGeneratedMeshAreaLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratedMeshAreaLight>();
	}
};
static_assert(alignof(AGeneratedMeshAreaLight) == 0x1EF72E00, "Wrong alignment on AGeneratedMeshAreaLight");
static_assert(sizeof(AGeneratedMeshAreaLight) == 0x1EF72E00, "Wrong size on AGeneratedMeshAreaLight");

// Class Engine.NavigationPath
// 0x00A0 (0x00E0 - 0x0040)
class UNavigationPath final : public UObject
{
public:
	UMulticastDelegateProperty_                   PathUpdatedNotifier;                               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PathPoints;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ENavigationOptionFlag                         RecalculateOnInvalidation;                         // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7F];                                      // 0x0061(0x007F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableDebugDrawing(bool bShouldDrawDebugData, const struct FLinearColor& PathColor);
	void EnableRecalculationOnInvalidation(ENavigationOptionFlag DoRecalculation);

	class FString GetDebugString() const;
	float GetPathCost() const;
	float GetPathLength() const;
	bool IsPartial() const;
	bool IsStringPulled() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationPath">();
	}
	static class UNavigationPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationPath>();
	}
};
static_assert(alignof(UNavigationPath) == 0x000008, "Wrong alignment on UNavigationPath");
static_assert(sizeof(UNavigationPath) == 0x0000E0, "Wrong size on UNavigationPath");
static_assert(offsetof(UNavigationPath, PathUpdatedNotifier) == 0x000040, "Member 'UNavigationPath::PathUpdatedNotifier' has a wrong offset!");
static_assert(offsetof(UNavigationPath, PathPoints) == 0x000050, "Member 'UNavigationPath::PathPoints' has a wrong offset!");
static_assert(offsetof(UNavigationPath, RecalculateOnInvalidation) == 0x000060, "Member 'UNavigationPath::RecalculateOnInvalidation' has a wrong offset!");

// Class Engine.MaterialExpressionDDY
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDDY final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Value;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDDY">();
	}
	static class UMaterialExpressionDDY* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDDY>();
	}
};
static_assert(alignof(UMaterialExpressionDDY) == 0x112F2730, "Wrong alignment on UMaterialExpressionDDY");
static_assert(sizeof(UMaterialExpressionDDY) == 0x112F2730, "Wrong size on UMaterialExpressionDDY");
static_assert(offsetof(UMaterialExpressionDDY, Value) == 0x000078, "Member 'UMaterialExpressionDDY::Value' has a wrong offset!");

// Class Engine.HapticFeedbackEffect_Base
// 0x0000 (0x0040 - 0x0040)
class UHapticFeedbackEffect_Base : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HapticFeedbackEffect_Base">();
	}
	static class UHapticFeedbackEffect_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHapticFeedbackEffect_Base>();
	}
};
static_assert(alignof(UHapticFeedbackEffect_Base) == 0x000008, "Wrong alignment on UHapticFeedbackEffect_Base");
static_assert(sizeof(UHapticFeedbackEffect_Base) == 0x000040, "Wrong size on UHapticFeedbackEffect_Base");

// Class Engine.HapticFeedbackEffect_Buffer
// 0x0040 (0x0080 - 0x0040)
class UHapticFeedbackEffect_Buffer final : public UHapticFeedbackEffect_Base
{
public:
	TArray<uint8>                                 Amplitudes;                                        // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SampleRate;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x2C];                                      // 0x0054(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HapticFeedbackEffect_Buffer">();
	}
	static class UHapticFeedbackEffect_Buffer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHapticFeedbackEffect_Buffer>();
	}
};
static_assert(alignof(UHapticFeedbackEffect_Buffer) == 0x000008, "Wrong alignment on UHapticFeedbackEffect_Buffer");
static_assert(sizeof(UHapticFeedbackEffect_Buffer) == 0x000080, "Wrong size on UHapticFeedbackEffect_Buffer");
static_assert(offsetof(UHapticFeedbackEffect_Buffer, Amplitudes) == 0x000040, "Member 'UHapticFeedbackEffect_Buffer::Amplitudes' has a wrong offset!");
static_assert(offsetof(UHapticFeedbackEffect_Buffer, SampleRate) == 0x000050, "Member 'UHapticFeedbackEffect_Buffer::SampleRate' has a wrong offset!");

// Class Engine.MaterialExpressionParticleRadius
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleRadius final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleRadius">();
	}
	static class UMaterialExpressionParticleRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleRadius>();
	}
};
static_assert(alignof(UMaterialExpressionParticleRadius) == 0x000008, "Wrong alignment on UMaterialExpressionParticleRadius");
static_assert(sizeof(UMaterialExpressionParticleRadius) == 0x000078, "Wrong size on UMaterialExpressionParticleRadius");

// Class Engine.HapticFeedbackEffect_Curve
// 0x00F0 (0x0130 - 0x0040)
class UHapticFeedbackEffect_Curve final : public UHapticFeedbackEffect_Base
{
public:
	struct FHapticFeedbackDetails_Curve           HapticDetails;                                     // 0x0040(0x00F0)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HapticFeedbackEffect_Curve">();
	}
	static class UHapticFeedbackEffect_Curve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHapticFeedbackEffect_Curve>();
	}
};
static_assert(alignof(UHapticFeedbackEffect_Curve) == 0x000008, "Wrong alignment on UHapticFeedbackEffect_Curve");
static_assert(sizeof(UHapticFeedbackEffect_Curve) == 0x000130, "Wrong size on UHapticFeedbackEffect_Curve");
static_assert(offsetof(UHapticFeedbackEffect_Curve, HapticDetails) == 0x000040, "Member 'UHapticFeedbackEffect_Curve::HapticDetails' has a wrong offset!");

// Class Engine.HapticFeedbackEffect_SoundWave
// 0x0038 (0x0078 - 0x0040)
class UHapticFeedbackEffect_SoundWave final : public UHapticFeedbackEffect_Base
{
public:
	class USoundWave*                             SoundWave;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HapticFeedbackEffect_SoundWave">();
	}
	static class UHapticFeedbackEffect_SoundWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHapticFeedbackEffect_SoundWave>();
	}
};
static_assert(alignof(UHapticFeedbackEffect_SoundWave) == 0x000008, "Wrong alignment on UHapticFeedbackEffect_SoundWave");
static_assert(sizeof(UHapticFeedbackEffect_SoundWave) == 0x000078, "Wrong size on UHapticFeedbackEffect_SoundWave");
static_assert(offsetof(UHapticFeedbackEffect_SoundWave, SoundWave) == 0x000040, "Member 'UHapticFeedbackEffect_SoundWave::SoundWave' has a wrong offset!");

// Class Engine.SoundNodeAttenuation
// 0x110AA (0x110FA - 0x0050)
class USoundNodeAttenuation final : public USoundNode
{
public:
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoundAttenuationSettings              AttenuationOverrides;                              // 0x0058(0x11487DA0)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bOverrideAttenuation : 1;                          // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeAttenuation">();
	}
	static class USoundNodeAttenuation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeAttenuation>();
	}
};
static_assert(alignof(USoundNodeAttenuation) == 0x0110FA, "Wrong alignment on USoundNodeAttenuation");
static_assert(sizeof(USoundNodeAttenuation) == 0x0110FA, "Wrong size on USoundNodeAttenuation");
static_assert(offsetof(USoundNodeAttenuation, AttenuationSettings) == 0x000050, "Member 'USoundNodeAttenuation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(USoundNodeAttenuation, AttenuationOverrides) == 0x000058, "Member 'USoundNodeAttenuation::AttenuationOverrides' has a wrong offset!");

// Class Engine.SpatializationPluginSourceSettingsBase
// 0x0000 (0x0040 - 0x0040)
class USpatializationPluginSourceSettingsBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpatializationPluginSourceSettingsBase">();
	}
	static class USpatializationPluginSourceSettingsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpatializationPluginSourceSettingsBase>();
	}
};
static_assert(alignof(USpatializationPluginSourceSettingsBase) == 0x000008, "Wrong alignment on USpatializationPluginSourceSettingsBase");
static_assert(sizeof(USpatializationPluginSourceSettingsBase) == 0x000040, "Wrong size on USpatializationPluginSourceSettingsBase");

// Class Engine.ReverbPluginSourceSettingsBase
// 0x0000 (0x0040 - 0x0040)
class UReverbPluginSourceSettingsBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverbPluginSourceSettingsBase">();
	}
	static class UReverbPluginSourceSettingsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReverbPluginSourceSettingsBase>();
	}
};
static_assert(alignof(UReverbPluginSourceSettingsBase) == 0x000008, "Wrong alignment on UReverbPluginSourceSettingsBase");
static_assert(sizeof(UReverbPluginSourceSettingsBase) == 0x000040, "Wrong size on UReverbPluginSourceSettingsBase");

// Class Engine.ImportanceSamplingLibrary
// 0x0000 (0x0040 - 0x0040)
class UImportanceSamplingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BreakImportanceTexture(const struct FImportanceTexture& ImportanceTexture, class UTexture2D** Texture, EImportanceWeight* WeightingFunc);
	static void ImportanceSample(const struct FImportanceTexture& Texture, const struct FVector2D& Rand, int32 Samples, float Intensity, struct FVector2D* SamplePosition, struct FLinearColor* SampleColor, float* SampleIntensity, float* SampleSize);
	static struct FImportanceTexture MakeImportanceTexture(class UTexture2D* Texture, EImportanceWeight WeightingFunc);
	static struct FVector2D NextSobolCell2D(int32 Index_0, int32 NumCells, const struct FVector2D& PreviousValue);
	static struct FVector NextSobolCell3D(int32 Index_0, int32 NumCells, const struct FVector& PreviousValue);
	static float NextSobolFloat(int32 Index_0, int32 Dimension, float PreviousValue);
	static struct FVector2D RandomSobolCell2D(int32 Index_0, int32 NumCells, const struct FVector2D& Cell, const struct FVector2D& Seed);
	static struct FVector RandomSobolCell3D(int32 Index_0, int32 NumCells, const struct FVector& Cell, const struct FVector& Seed);
	static float RandomSobolFloat(int32 Index_0, int32 Dimension, float Seed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImportanceSamplingLibrary">();
	}
	static class UImportanceSamplingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImportanceSamplingLibrary>();
	}
};
static_assert(alignof(UImportanceSamplingLibrary) == 0x000008, "Wrong alignment on UImportanceSamplingLibrary");
static_assert(sizeof(UImportanceSamplingLibrary) == 0x000040, "Wrong size on UImportanceSamplingLibrary");

// Class Engine.InGameAdManager
// 0x0028 (0x0078 - 0x0050)
class UInGameAdManager final : public UPlatformInterfaceBase
{
public:
	uint8                                         bShouldPauseWhileAdOpen : 1;                       // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TDelegate<void()>>                     ClickedBannerDelegates;                            // 0x0058(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TDelegate<void()>>                     ClosedAdDelegates;                                 // 0x0068(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAdManager">();
	}
	static class UInGameAdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAdManager>();
	}
};
static_assert(alignof(UInGameAdManager) == 0x000008, "Wrong alignment on UInGameAdManager");
static_assert(sizeof(UInGameAdManager) == 0x000078, "Wrong size on UInGameAdManager");
static_assert(offsetof(UInGameAdManager, ClickedBannerDelegates) == 0x000058, "Member 'UInGameAdManager::ClickedBannerDelegates' has a wrong offset!");
static_assert(offsetof(UInGameAdManager, ClosedAdDelegates) == 0x000068, "Member 'UInGameAdManager::ClosedAdDelegates' has a wrong offset!");

// Class Engine.InheritableComponentHandler
// 0x0020 (0x0060 - 0x0040)
class UInheritableComponentHandler final : public UObject
{
public:
	TArray<struct FComponentOverrideRecord>       Records;                                           // 0x0040(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UActorComponent*>                UnnecessaryComponents;                             // 0x0050(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InheritableComponentHandler">();
	}
	static class UInheritableComponentHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInheritableComponentHandler>();
	}
};
static_assert(alignof(UInheritableComponentHandler) == 0x000008, "Wrong alignment on UInheritableComponentHandler");
static_assert(sizeof(UInheritableComponentHandler) == 0x000060, "Wrong size on UInheritableComponentHandler");
static_assert(offsetof(UInheritableComponentHandler, Records) == 0x000040, "Member 'UInheritableComponentHandler::Records' has a wrong offset!");
static_assert(offsetof(UInheritableComponentHandler, UnnecessaryComponents) == 0x000050, "Member 'UInheritableComponentHandler::UnnecessaryComponents' has a wrong offset!");

// Class Engine.ParticleModuleAccelerationDragScaleOverLife
// 0x0040 (0x0098 - 0x0058)
class UParticleModuleAccelerationDragScaleOverLife final : public UParticleModuleAccelerationBase
{
public:
	class UDistributionFloat*                     DragScale;                                         // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DragScaleRaw;                                      // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAccelerationDragScaleOverLife">();
	}
	static class UParticleModuleAccelerationDragScaleOverLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAccelerationDragScaleOverLife>();
	}
};
static_assert(alignof(UParticleModuleAccelerationDragScaleOverLife) == 0x000008, "Wrong alignment on UParticleModuleAccelerationDragScaleOverLife");
static_assert(sizeof(UParticleModuleAccelerationDragScaleOverLife) == 0x000098, "Wrong size on UParticleModuleAccelerationDragScaleOverLife");
static_assert(offsetof(UParticleModuleAccelerationDragScaleOverLife, DragScale) == 0x000058, "Member 'UParticleModuleAccelerationDragScaleOverLife::DragScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleAccelerationDragScaleOverLife, DragScaleRaw) == 0x000060, "Member 'UParticleModuleAccelerationDragScaleOverLife::DragScaleRaw' has a wrong offset!");

// Class Engine.InputDelegateBinding
// 0x0000 (0x0040 - 0x0040)
class UInputDelegateBinding : public UDynamicBlueprintBinding
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputDelegateBinding">();
	}
	static class UInputDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputDelegateBinding>();
	}
};
static_assert(alignof(UInputDelegateBinding) == 0x000008, "Wrong alignment on UInputDelegateBinding");
static_assert(sizeof(UInputDelegateBinding) == 0x000040, "Wrong size on UInputDelegateBinding");

// Class Engine.InputActionDelegateBinding
// 0x0010 (0x0050 - 0x0040)
class UInputActionDelegateBinding final : public UInputDelegateBinding
{
public:
	TArray<struct FBlueprintInputActionDelegateBinding> InputActionDelegateBindings;                       // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionDelegateBinding">();
	}
	static class UInputActionDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionDelegateBinding>();
	}
};
static_assert(alignof(UInputActionDelegateBinding) == 0x000008, "Wrong alignment on UInputActionDelegateBinding");
static_assert(sizeof(UInputActionDelegateBinding) == 0x000050, "Wrong size on UInputActionDelegateBinding");
static_assert(offsetof(UInputActionDelegateBinding, InputActionDelegateBindings) == 0x000040, "Member 'UInputActionDelegateBinding::InputActionDelegateBindings' has a wrong offset!");

// Class Engine.InputAxisDelegateBinding
// 0x0010 (0x0050 - 0x0040)
class UInputAxisDelegateBinding final : public UInputDelegateBinding
{
public:
	TArray<struct FBlueprintInputAxisDelegateBinding> InputAxisDelegateBindings;                         // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputAxisDelegateBinding">();
	}
	static class UInputAxisDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputAxisDelegateBinding>();
	}
};
static_assert(alignof(UInputAxisDelegateBinding) == 0x000008, "Wrong alignment on UInputAxisDelegateBinding");
static_assert(sizeof(UInputAxisDelegateBinding) == 0x000050, "Wrong size on UInputAxisDelegateBinding");
static_assert(offsetof(UInputAxisDelegateBinding, InputAxisDelegateBindings) == 0x000040, "Member 'UInputAxisDelegateBinding::InputAxisDelegateBindings' has a wrong offset!");

// Class Engine.InputAxisKeyDelegateBinding
// 0x0010 (0x0050 - 0x0040)
class UInputAxisKeyDelegateBinding : public UInputDelegateBinding
{
public:
	TArray<struct FBlueprintInputAxisKeyDelegateBinding> InputAxisKeyDelegateBindings;                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputAxisKeyDelegateBinding">();
	}
	static class UInputAxisKeyDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputAxisKeyDelegateBinding>();
	}
};
static_assert(alignof(UInputAxisKeyDelegateBinding) == 0x000008, "Wrong alignment on UInputAxisKeyDelegateBinding");
static_assert(sizeof(UInputAxisKeyDelegateBinding) == 0x000050, "Wrong size on UInputAxisKeyDelegateBinding");
static_assert(offsetof(UInputAxisKeyDelegateBinding, InputAxisKeyDelegateBindings) == 0x000040, "Member 'UInputAxisKeyDelegateBinding::InputAxisKeyDelegateBindings' has a wrong offset!");

// Class Engine.InputComponent
// 0x0000 (0xD38D - 0xD38D)
class UInputComponent final : public UActorComponent
{
public:
	float GetControllerAnalogKeyState(const struct FKey& Key) const;
	void GetControllerAnalogStickState(EControllerAnalogStick WhichStick, float* StickX, float* StickY) const;
	float GetControllerKeyTimeDown(const struct FKey& Key) const;
	void GetControllerMouseDelta(float* DeltaX, float* DeltaY) const;
	struct FVector GetControllerVectorKeyState(const struct FKey& Key) const;
	void GetTouchState(int32 FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed) const;
	bool IsControllerKeyDown(const struct FKey& Key) const;
	bool WasControllerKeyJustPressed(const struct FKey& Key) const;
	bool WasControllerKeyJustReleased(const struct FKey& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputComponent">();
	}
	static class UInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputComponent>();
	}
};
static_assert(alignof(UInputComponent) == 0x00D38D, "Wrong alignment on UInputComponent");
static_assert(sizeof(UInputComponent) == 0x00D38D, "Wrong size on UInputComponent");

// Class Engine.MaterialExpressionFeatureLevelSwitch
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFeatureLevelSwitch final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Default;                                           // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Inputs[0x4];                                       // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFeatureLevelSwitch">();
	}
	static class UMaterialExpressionFeatureLevelSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFeatureLevelSwitch>();
	}
};
static_assert(alignof(UMaterialExpressionFeatureLevelSwitch) == 0x112F2730, "Wrong alignment on UMaterialExpressionFeatureLevelSwitch");
static_assert(sizeof(UMaterialExpressionFeatureLevelSwitch) == 0x112F2730, "Wrong size on UMaterialExpressionFeatureLevelSwitch");
static_assert(offsetof(UMaterialExpressionFeatureLevelSwitch, Default) == 0x000078, "Member 'UMaterialExpressionFeatureLevelSwitch::Default' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFeatureLevelSwitch, Inputs) == 0x0000B0, "Member 'UMaterialExpressionFeatureLevelSwitch::Inputs' has a wrong offset!");

// Class Engine.InputKeyDelegateBinding
// 0x0010 (0x0050 - 0x0040)
class UInputKeyDelegateBinding final : public UInputDelegateBinding
{
public:
	TArray<struct FBlueprintInputKeyDelegateBinding> InputKeyDelegateBindings;                          // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputKeyDelegateBinding">();
	}
	static class UInputKeyDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputKeyDelegateBinding>();
	}
};
static_assert(alignof(UInputKeyDelegateBinding) == 0x000008, "Wrong alignment on UInputKeyDelegateBinding");
static_assert(sizeof(UInputKeyDelegateBinding) == 0x000050, "Wrong size on UInputKeyDelegateBinding");
static_assert(offsetof(UInputKeyDelegateBinding, InputKeyDelegateBindings) == 0x000040, "Member 'UInputKeyDelegateBinding::InputKeyDelegateBindings' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXSceneDarkColor
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleSQEXSceneDarkColor final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXSceneDarkColor">();
	}
	static class UMaterialExpressionParticleSQEXSceneDarkColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXSceneDarkColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXSceneDarkColor) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXSceneDarkColor");
static_assert(sizeof(UMaterialExpressionParticleSQEXSceneDarkColor) == 0x000078, "Wrong size on UMaterialExpressionParticleSQEXSceneDarkColor");

// Class Engine.InputTouchDelegateBinding
// 0x0010 (0x0050 - 0x0040)
class UInputTouchDelegateBinding final : public UInputDelegateBinding
{
public:
	TArray<struct FBlueprintInputTouchDelegateBinding> InputTouchDelegateBindings;                        // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputTouchDelegateBinding">();
	}
	static class UInputTouchDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputTouchDelegateBinding>();
	}
};
static_assert(alignof(UInputTouchDelegateBinding) == 0x000008, "Wrong alignment on UInputTouchDelegateBinding");
static_assert(sizeof(UInputTouchDelegateBinding) == 0x000050, "Wrong size on UInputTouchDelegateBinding");
static_assert(offsetof(UInputTouchDelegateBinding, InputTouchDelegateBindings) == 0x000040, "Member 'UInputTouchDelegateBinding::InputTouchDelegateBindings' has a wrong offset!");

// Class Engine.InputVectorAxisDelegateBinding
// 0x0000 (0x0050 - 0x0050)
class UInputVectorAxisDelegateBinding final : public UInputAxisKeyDelegateBinding
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputVectorAxisDelegateBinding">();
	}
	static class UInputVectorAxisDelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputVectorAxisDelegateBinding>();
	}
};
static_assert(alignof(UInputVectorAxisDelegateBinding) == 0x000008, "Wrong alignment on UInputVectorAxisDelegateBinding");
static_assert(sizeof(UInputVectorAxisDelegateBinding) == 0x000050, "Wrong size on UInputVectorAxisDelegateBinding");

// Class Engine.PoseAsset
// 0x0110 (0x01A0 - 0x0090)
class UPoseAsset final : public UAnimationAsset
{
public:
	struct FPoseDataContainer                     PoseContainer;                                     // 0x0090(0x0090)(NativeAccessSpecifierPrivate)
	bool                                          bAdditivePose;                                     // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BasePoseIndex;                                     // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   RetargetSource;                                    // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x70];                                     // 0x0130(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseAsset">();
	}
	static class UPoseAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoseAsset>();
	}
};
static_assert(alignof(UPoseAsset) == 0x000008, "Wrong alignment on UPoseAsset");
static_assert(sizeof(UPoseAsset) == 0x0001A0, "Wrong size on UPoseAsset");
static_assert(offsetof(UPoseAsset, PoseContainer) == 0x000090, "Member 'UPoseAsset::PoseContainer' has a wrong offset!");
static_assert(offsetof(UPoseAsset, bAdditivePose) == 0x000120, "Member 'UPoseAsset::bAdditivePose' has a wrong offset!");
static_assert(offsetof(UPoseAsset, BasePoseIndex) == 0x000124, "Member 'UPoseAsset::BasePoseIndex' has a wrong offset!");
static_assert(offsetof(UPoseAsset, RetargetSource) == 0x000128, "Member 'UPoseAsset::RetargetSource' has a wrong offset!");

// Class Engine.MaterialExpressionBlendMaterialAttributes
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionBlendMaterialAttributes final : public UMaterialExpression
{
public:
	struct FMaterialAttributesInput               A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FMaterialAttributesInput               B;                                                 // 0x00B8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x00F8(0x112F2730)(NativeAccessSpecifierPublic)
	EMaterialAttributeBlend                       PixelAttributeBlendType;                           // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialAttributeBlend                       VertexAttributeBlendType;                          // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBlendMaterialAttributes">();
	}
	static class UMaterialExpressionBlendMaterialAttributes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBlendMaterialAttributes>();
	}
};
static_assert(alignof(UMaterialExpressionBlendMaterialAttributes) == 0x112F2730, "Wrong alignment on UMaterialExpressionBlendMaterialAttributes");
static_assert(sizeof(UMaterialExpressionBlendMaterialAttributes) == 0x112F2730, "Wrong size on UMaterialExpressionBlendMaterialAttributes");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributes, A) == 0x000078, "Member 'UMaterialExpressionBlendMaterialAttributes::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributes, B) == 0x0000B8, "Member 'UMaterialExpressionBlendMaterialAttributes::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributes, Alpha) == 0x0000F8, "Member 'UMaterialExpressionBlendMaterialAttributes::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributes, PixelAttributeBlendType) == 0x000130, "Member 'UMaterialExpressionBlendMaterialAttributes::PixelAttributeBlendType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributes, VertexAttributeBlendType) == 0x000131, "Member 'UMaterialExpressionBlendMaterialAttributes::VertexAttributeBlendType' has a wrong offset!");

// Class Engine.Interface_AssetUserData
// 0x0000 (0x0040 - 0x0040)
class IInterface_AssetUserData final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interface_AssetUserData">();
	}
	static class IInterface_AssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterface_AssetUserData>();
	}
};
static_assert(alignof(IInterface_AssetUserData) == 0x000008, "Wrong alignment on IInterface_AssetUserData");
static_assert(sizeof(IInterface_AssetUserData) == 0x000040, "Wrong size on IInterface_AssetUserData");

// Class Engine.Interface_PostProcessVolume
// 0x0000 (0x0040 - 0x0040)
class IInterface_PostProcessVolume final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interface_PostProcessVolume">();
	}
	static class IInterface_PostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterface_PostProcessVolume>();
	}
};
static_assert(alignof(IInterface_PostProcessVolume) == 0x000008, "Wrong alignment on IInterface_PostProcessVolume");
static_assert(sizeof(IInterface_PostProcessVolume) == 0x000040, "Wrong size on IInterface_PostProcessVolume");

// Class Engine.InterpCurveEdSetup
// 0x0018 (0x0058 - 0x0040)
class UInterpCurveEdSetup final : public UObject
{
public:
	TArray<struct FCurveEdTab>                    Tabs;                                              // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActiveTab;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpCurveEdSetup">();
	}
	static class UInterpCurveEdSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpCurveEdSetup>();
	}
};
static_assert(alignof(UInterpCurveEdSetup) == 0x000008, "Wrong alignment on UInterpCurveEdSetup");
static_assert(sizeof(UInterpCurveEdSetup) == 0x000058, "Wrong size on UInterpCurveEdSetup");
static_assert(offsetof(UInterpCurveEdSetup, Tabs) == 0x000040, "Member 'UInterpCurveEdSetup::Tabs' has a wrong offset!");
static_assert(offsetof(UInterpCurveEdSetup, ActiveTab) == 0x000050, "Member 'UInterpCurveEdSetup::ActiveTab' has a wrong offset!");

// Class Engine.ParticleModuleColorOverLife
// 0x0090 (0x00E0 - 0x0050)
class UParticleModuleColorOverLife final : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                 ColorOverLife;                                     // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AlphaOverLife;                                     // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bClampAlpha : 1;                                   // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleColorOverLife">();
	}
	static class UParticleModuleColorOverLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleColorOverLife>();
	}
};
static_assert(alignof(UParticleModuleColorOverLife) == 0x000008, "Wrong alignment on UParticleModuleColorOverLife");
static_assert(sizeof(UParticleModuleColorOverLife) == 0x0000E0, "Wrong size on UParticleModuleColorOverLife");
static_assert(offsetof(UParticleModuleColorOverLife, ColorOverLife) == 0x000050, "Member 'UParticleModuleColorOverLife::ColorOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleColorOverLife, AlphaOverLife) == 0x0000A0, "Member 'UParticleModuleColorOverLife::AlphaOverLife' has a wrong offset!");

// Class Engine.InterpData
// 0x0048 (0x0088 - 0x0040)
class UInterpData final : public UObject
{
public:
	float                                         InterpLength;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathBuildTime;                                     // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInterpGroup*>                   InterpGroups;                                      // 0x0048(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UInterpCurveEdSetup*                    CurveEdSetup;                                      // 0x0058(0x0008)(ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdSectionStart;                                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdSectionEnd;                                      // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShouldBakeAndPrune : 1;                           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInterpGroupDirector*                   CachedDirectorGroup;                               // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AllEventNames;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpData">();
	}
	static class UInterpData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpData>();
	}
};
static_assert(alignof(UInterpData) == 0x000008, "Wrong alignment on UInterpData");
static_assert(sizeof(UInterpData) == 0x000088, "Wrong size on UInterpData");
static_assert(offsetof(UInterpData, InterpLength) == 0x000040, "Member 'UInterpData::InterpLength' has a wrong offset!");
static_assert(offsetof(UInterpData, PathBuildTime) == 0x000044, "Member 'UInterpData::PathBuildTime' has a wrong offset!");
static_assert(offsetof(UInterpData, InterpGroups) == 0x000048, "Member 'UInterpData::InterpGroups' has a wrong offset!");
static_assert(offsetof(UInterpData, CurveEdSetup) == 0x000058, "Member 'UInterpData::CurveEdSetup' has a wrong offset!");
static_assert(offsetof(UInterpData, EdSectionStart) == 0x000060, "Member 'UInterpData::EdSectionStart' has a wrong offset!");
static_assert(offsetof(UInterpData, EdSectionEnd) == 0x000064, "Member 'UInterpData::EdSectionEnd' has a wrong offset!");
static_assert(offsetof(UInterpData, CachedDirectorGroup) == 0x000070, "Member 'UInterpData::CachedDirectorGroup' has a wrong offset!");
static_assert(offsetof(UInterpData, AllEventNames) == 0x000078, "Member 'UInterpData::AllEventNames' has a wrong offset!");

// Class Engine.InterpFilter
// 0x0010 (0x0050 - 0x0040)
class UInterpFilter : public UObject
{
public:
	class FString                                 Caption;                                           // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpFilter">();
	}
	static class UInterpFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpFilter>();
	}
};
static_assert(alignof(UInterpFilter) == 0x000008, "Wrong alignment on UInterpFilter");
static_assert(sizeof(UInterpFilter) == 0x000050, "Wrong size on UInterpFilter");
static_assert(offsetof(UInterpFilter, Caption) == 0x000040, "Member 'UInterpFilter::Caption' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXAreaDarkColor
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionParticleSQEXAreaDarkColor final : public UMaterialExpression
{
public:
	struct FLinearColor                           DefaultValue;                                      // 0x0078(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXAreaDarkColor">();
	}
	static class UMaterialExpressionParticleSQEXAreaDarkColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXAreaDarkColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXAreaDarkColor) == 0x112EAE80, "Wrong alignment on UMaterialExpressionParticleSQEXAreaDarkColor");
static_assert(sizeof(UMaterialExpressionParticleSQEXAreaDarkColor) == 0x112EAE80, "Wrong size on UMaterialExpressionParticleSQEXAreaDarkColor");
static_assert(offsetof(UMaterialExpressionParticleSQEXAreaDarkColor, DefaultValue) == 0x000078, "Member 'UMaterialExpressionParticleSQEXAreaDarkColor::DefaultValue' has a wrong offset!");

// Class Engine.InterpFilter_Classes
// 0x0000 (0x0050 - 0x0050)
class UInterpFilter_Classes final : public UInterpFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpFilter_Classes">();
	}
	static class UInterpFilter_Classes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpFilter_Classes>();
	}
};
static_assert(alignof(UInterpFilter_Classes) == 0x000008, "Wrong alignment on UInterpFilter_Classes");
static_assert(sizeof(UInterpFilter_Classes) == 0x000050, "Wrong size on UInterpFilter_Classes");

// Class Engine.InterpFilter_Custom
// 0x0000 (0x0050 - 0x0050)
class UInterpFilter_Custom final : public UInterpFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpFilter_Custom">();
	}
	static class UInterpFilter_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpFilter_Custom>();
	}
};
static_assert(alignof(UInterpFilter_Custom) == 0x000008, "Wrong alignment on UInterpFilter_Custom");
static_assert(sizeof(UInterpFilter_Custom) == 0x000050, "Wrong size on UInterpFilter_Custom");

// Class Engine.PlatformInterfaceWebResponse
// 0x0088 (0x00C8 - 0x0040)
class UPlatformInterfaceWebResponse final : public UObject
{
public:
	class FString                                 OriginalURL;                                       // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseCode;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tag;                                               // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringResponse;                                    // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 BinaryResponse;                                    // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetHeader(int32 HeaderIndex, class FString* Header, class FString* Value);
	class FString GetHeaderValue(const class FString& HeaderName);
	int32 GetNumHeaders();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformInterfaceWebResponse">();
	}
	static class UPlatformInterfaceWebResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformInterfaceWebResponse>();
	}
};
static_assert(alignof(UPlatformInterfaceWebResponse) == 0x000008, "Wrong alignment on UPlatformInterfaceWebResponse");
static_assert(sizeof(UPlatformInterfaceWebResponse) == 0x0000C8, "Wrong size on UPlatformInterfaceWebResponse");
static_assert(offsetof(UPlatformInterfaceWebResponse, OriginalURL) == 0x000040, "Member 'UPlatformInterfaceWebResponse::OriginalURL' has a wrong offset!");
static_assert(offsetof(UPlatformInterfaceWebResponse, ResponseCode) == 0x000050, "Member 'UPlatformInterfaceWebResponse::ResponseCode' has a wrong offset!");
static_assert(offsetof(UPlatformInterfaceWebResponse, Tag) == 0x000054, "Member 'UPlatformInterfaceWebResponse::Tag' has a wrong offset!");
static_assert(offsetof(UPlatformInterfaceWebResponse, StringResponse) == 0x000058, "Member 'UPlatformInterfaceWebResponse::StringResponse' has a wrong offset!");
static_assert(offsetof(UPlatformInterfaceWebResponse, BinaryResponse) == 0x000068, "Member 'UPlatformInterfaceWebResponse::BinaryResponse' has a wrong offset!");

// Class Engine.MaterialExpressionArctangent2
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArctangent2 final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Y;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       X;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArctangent2">();
	}
	static class UMaterialExpressionArctangent2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArctangent2>();
	}
};
static_assert(alignof(UMaterialExpressionArctangent2) == 0x112F2730, "Wrong alignment on UMaterialExpressionArctangent2");
static_assert(sizeof(UMaterialExpressionArctangent2) == 0x112F2730, "Wrong size on UMaterialExpressionArctangent2");
static_assert(offsetof(UMaterialExpressionArctangent2, Y) == 0x000078, "Member 'UMaterialExpressionArctangent2::Y' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionArctangent2, X) == 0x0000B0, "Member 'UMaterialExpressionArctangent2::X' has a wrong offset!");

// Class Engine.InterpGroupCamera
// 0x0010 (0x0080 - 0x0070)
class UInterpGroupCamera final : public UInterpGroup
{
public:
	class UCameraAnim*                            CameraAnimInst;                                    // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompressTolerance;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpGroupCamera">();
	}
	static class UInterpGroupCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpGroupCamera>();
	}
};
static_assert(alignof(UInterpGroupCamera) == 0x000008, "Wrong alignment on UInterpGroupCamera");
static_assert(sizeof(UInterpGroupCamera) == 0x000080, "Wrong size on UInterpGroupCamera");
static_assert(offsetof(UInterpGroupCamera, CameraAnimInst) == 0x000070, "Member 'UInterpGroupCamera::CameraAnimInst' has a wrong offset!");
static_assert(offsetof(UInterpGroupCamera, CompressTolerance) == 0x000078, "Member 'UInterpGroupCamera::CompressTolerance' has a wrong offset!");

// Class Engine.InterpGroupDirector
// 0x0000 (0x0070 - 0x0070)
class UInterpGroupDirector final : public UInterpGroup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpGroupDirector">();
	}
	static class UInterpGroupDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpGroupDirector>();
	}
};
static_assert(alignof(UInterpGroupDirector) == 0x000008, "Wrong alignment on UInterpGroupDirector");
static_assert(sizeof(UInterpGroupDirector) == 0x000070, "Wrong size on UInterpGroupDirector");

// Class Engine.SoundNodeConcatenator
// 0x0010 (0x0060 - 0x0050)
class USoundNodeConcatenator final : public USoundNode
{
public:
	TArray<float>                                 InputVolume;                                       // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeConcatenator">();
	}
	static class USoundNodeConcatenator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeConcatenator>();
	}
};
static_assert(alignof(USoundNodeConcatenator) == 0x000008, "Wrong alignment on USoundNodeConcatenator");
static_assert(sizeof(USoundNodeConcatenator) == 0x000060, "Wrong size on USoundNodeConcatenator");
static_assert(offsetof(USoundNodeConcatenator, InputVolume) == 0x000050, "Member 'USoundNodeConcatenator::InputVolume' has a wrong offset!");

// Class Engine.MaterialExpressionObjectBounds
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionObjectBounds final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionObjectBounds">();
	}
	static class UMaterialExpressionObjectBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionObjectBounds>();
	}
};
static_assert(alignof(UMaterialExpressionObjectBounds) == 0x000008, "Wrong alignment on UMaterialExpressionObjectBounds");
static_assert(sizeof(UMaterialExpressionObjectBounds) == 0x000078, "Wrong size on UMaterialExpressionObjectBounds");

// Class Engine.InterpGroupInstCamera
// 0x0000 (0x0068 - 0x0068)
class UInterpGroupInstCamera final : public UInterpGroupInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpGroupInstCamera">();
	}
	static class UInterpGroupInstCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpGroupInstCamera>();
	}
};
static_assert(alignof(UInterpGroupInstCamera) == 0x000008, "Wrong alignment on UInterpGroupInstCamera");
static_assert(sizeof(UInterpGroupInstCamera) == 0x000068, "Wrong size on UInterpGroupInstCamera");

// Class Engine.InterpGroupInstDirector
// 0x0000 (0x0068 - 0x0068)
class UInterpGroupInstDirector final : public UInterpGroupInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpGroupInstDirector">();
	}
	static class UInterpGroupInstDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpGroupInstDirector>();
	}
};
static_assert(alignof(UInterpGroupInstDirector) == 0x000008, "Wrong alignment on UInterpGroupInstDirector");
static_assert(sizeof(UInterpGroupInstDirector) == 0x000068, "Wrong size on UInterpGroupInstDirector");

// Class Engine.MaterialExpressionLogarithm10
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionLogarithm10 final : public UMaterialExpression
{
public:
	struct FExpressionInput                       X;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLogarithm10">();
	}
	static class UMaterialExpressionLogarithm10* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLogarithm10>();
	}
};
static_assert(alignof(UMaterialExpressionLogarithm10) == 0x112F2730, "Wrong alignment on UMaterialExpressionLogarithm10");
static_assert(sizeof(UMaterialExpressionLogarithm10) == 0x112F2730, "Wrong size on UMaterialExpressionLogarithm10");
static_assert(offsetof(UMaterialExpressionLogarithm10, X) == 0x000078, "Member 'UMaterialExpressionLogarithm10::X' has a wrong offset!");

// Class Engine.InterpToMovementComponent
// 0x0000 (0xD38D - 0xD38D)
class UInterpToMovementComponent final : public UMovementComponent
{
public:
	float                                         Duration;                                          // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPauseOnImpact : 1;                                // 0x024C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EInterpToBehaviourType                        BehaviourType;                                     // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceSubStepping : 1;                             // 0x0254(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInterpToReverse;                                 // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterpToStop;                                    // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaitBeginDelegate;                               // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWaitEndDelegate;                                 // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResetDelegate;                                   // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTimeStep;                             // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInterpControlPoint>            ControlPoints;                                     // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x30];                                     // 0x02C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinaliseControlPoints();
	void OnInterpToResetDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time);
	void OnInterpToReverseDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time);
	void OnInterpToStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time);
	void OnInterpToWaitBeginDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time);
	void OnInterpToWaitEndDelegate__DelegateSignature(const struct FHitResult& ImpactResult, float Time);
	void RestartMovement(float InitialDirection);
	void StopSimulating(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpToMovementComponent">();
	}
	static class UInterpToMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpToMovementComponent>();
	}
};
static_assert(alignof(UInterpToMovementComponent) == 0x00D38D, "Wrong alignment on UInterpToMovementComponent");
static_assert(sizeof(UInterpToMovementComponent) == 0x00D38D, "Wrong size on UInterpToMovementComponent");
static_assert(offsetof(UInterpToMovementComponent, Duration) == 0x000248, "Member 'UInterpToMovementComponent::Duration' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, BehaviourType) == 0x000250, "Member 'UInterpToMovementComponent::BehaviourType' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, OnInterpToReverse) == 0x000258, "Member 'UInterpToMovementComponent::OnInterpToReverse' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, OnInterpToStop) == 0x000268, "Member 'UInterpToMovementComponent::OnInterpToStop' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, OnWaitBeginDelegate) == 0x000278, "Member 'UInterpToMovementComponent::OnWaitBeginDelegate' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, OnWaitEndDelegate) == 0x000288, "Member 'UInterpToMovementComponent::OnWaitEndDelegate' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, OnResetDelegate) == 0x000298, "Member 'UInterpToMovementComponent::OnResetDelegate' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, MaxSimulationTimeStep) == 0x0002A8, "Member 'UInterpToMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, MaxSimulationIterations) == 0x0002AC, "Member 'UInterpToMovementComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(UInterpToMovementComponent, ControlPoints) == 0x0002B0, "Member 'UInterpToMovementComponent::ControlPoints' has a wrong offset!");

// Class Engine.MaterialExpressionRotateAboutAxis
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionRotateAboutAxis final : public UMaterialExpression
{
public:
	struct FExpressionInput                       NormalizedRotationAxis;                            // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       RotationAngle;                                     // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       PivotPoint;                                        // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Position;                                          // 0x0120(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRotateAboutAxis">();
	}
	static class UMaterialExpressionRotateAboutAxis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRotateAboutAxis>();
	}
};
static_assert(alignof(UMaterialExpressionRotateAboutAxis) == 0x112F2730, "Wrong alignment on UMaterialExpressionRotateAboutAxis");
static_assert(sizeof(UMaterialExpressionRotateAboutAxis) == 0x112F2730, "Wrong size on UMaterialExpressionRotateAboutAxis");
static_assert(offsetof(UMaterialExpressionRotateAboutAxis, NormalizedRotationAxis) == 0x000078, "Member 'UMaterialExpressionRotateAboutAxis::NormalizedRotationAxis' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotateAboutAxis, RotationAngle) == 0x0000B0, "Member 'UMaterialExpressionRotateAboutAxis::RotationAngle' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotateAboutAxis, PivotPoint) == 0x0000E8, "Member 'UMaterialExpressionRotateAboutAxis::PivotPoint' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotateAboutAxis, Position) == 0x000120, "Member 'UMaterialExpressionRotateAboutAxis::Position' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotateAboutAxis, Period) == 0x000158, "Member 'UMaterialExpressionRotateAboutAxis::Period' has a wrong offset!");

// Class Engine.InterpTrackAudioMaster
// 0x0000 (0x112ED410 - 0x112ED410)
class UInterpTrackAudioMaster final : public UInterpTrackVectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackAudioMaster">();
	}
	static class UInterpTrackAudioMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackAudioMaster>();
	}
};
static_assert(alignof(UInterpTrackAudioMaster) == 0x112ED410, "Wrong alignment on UInterpTrackAudioMaster");
static_assert(sizeof(UInterpTrackAudioMaster) == 0x112ED410, "Wrong size on UInterpTrackAudioMaster");

// Class Engine.InterpTrackColorScale
// 0x0000 (0x112ED410 - 0x112ED410)
class UInterpTrackColorScale final : public UInterpTrackVectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackColorScale">();
	}
	static class UInterpTrackColorScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackColorScale>();
	}
};
static_assert(alignof(UInterpTrackColorScale) == 0x112ED410, "Wrong alignment on UInterpTrackColorScale");
static_assert(sizeof(UInterpTrackColorScale) == 0x112ED410, "Wrong size on UInterpTrackColorScale");

// Class Engine.ParticleModuleLocationPrimitiveSphere
// 0x0038 (0x0118 - 0x00E0)
class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
public:
	struct FRawDistributionFloat                  StartRadius;                                       // 0x00E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationPrimitiveSphere">();
	}
	static class UParticleModuleLocationPrimitiveSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationPrimitiveSphere>();
	}
};
static_assert(alignof(UParticleModuleLocationPrimitiveSphere) == 0x000008, "Wrong alignment on UParticleModuleLocationPrimitiveSphere");
static_assert(sizeof(UParticleModuleLocationPrimitiveSphere) == 0x000118, "Wrong size on UParticleModuleLocationPrimitiveSphere");
static_assert(offsetof(UParticleModuleLocationPrimitiveSphere, StartRadius) == 0x0000E0, "Member 'UParticleModuleLocationPrimitiveSphere::StartRadius' has a wrong offset!");

// Class Engine.SQEX_AutoEffectDebugDataAsset
// 0x0028 (0x0070 - 0x0048)
class USQEX_AutoEffectDebugDataAsset final : public UDataAsset
{
public:
	class FString                                 Description;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLoop : 1;                                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_EffectAutoDebugData>      AutoDebugData;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_AutoEffectDebugDataAsset">();
	}
	static class USQEX_AutoEffectDebugDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_AutoEffectDebugDataAsset>();
	}
};
static_assert(alignof(USQEX_AutoEffectDebugDataAsset) == 0x000008, "Wrong alignment on USQEX_AutoEffectDebugDataAsset");
static_assert(sizeof(USQEX_AutoEffectDebugDataAsset) == 0x000070, "Wrong size on USQEX_AutoEffectDebugDataAsset");
static_assert(offsetof(USQEX_AutoEffectDebugDataAsset, Description) == 0x000048, "Member 'USQEX_AutoEffectDebugDataAsset::Description' has a wrong offset!");
static_assert(offsetof(USQEX_AutoEffectDebugDataAsset, AutoDebugData) == 0x000060, "Member 'USQEX_AutoEffectDebugDataAsset::AutoDebugData' has a wrong offset!");

// Class Engine.InterpTrackDirector
// 0x0028 (0x00B8 - 0x0090)
class UInterpTrackDirector final : public UInterpTrack
{
public:
	TArray<struct FDirectorTrackCut>              CutTrack;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSimulateCameraCutsOnClients : 1;                  // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_EndBlendTime;                                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      M_BlendFunction;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_BlendExp;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendInterp                        M_BlendInterp;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendInterpYaw                     M_BlendInterpYaw;                                  // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bDelaySwitch : 1;                                // 0x00B2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bEndBlendPostProcess : 1;                        // 0x00B2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bTakeover : 1;                                   // 0x00B2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bTakeoverDOF : 1;                                // 0x00B2(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bResetCamera : 1;                                // 0x00B2(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackDirector">();
	}
	static class UInterpTrackDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackDirector>();
	}
};
static_assert(alignof(UInterpTrackDirector) == 0x000008, "Wrong alignment on UInterpTrackDirector");
static_assert(sizeof(UInterpTrackDirector) == 0x0000B8, "Wrong size on UInterpTrackDirector");
static_assert(offsetof(UInterpTrackDirector, CutTrack) == 0x000090, "Member 'UInterpTrackDirector::CutTrack' has a wrong offset!");
static_assert(offsetof(UInterpTrackDirector, M_EndBlendTime) == 0x0000A4, "Member 'UInterpTrackDirector::M_EndBlendTime' has a wrong offset!");
static_assert(offsetof(UInterpTrackDirector, M_BlendFunction) == 0x0000A8, "Member 'UInterpTrackDirector::M_BlendFunction' has a wrong offset!");
static_assert(offsetof(UInterpTrackDirector, M_BlendExp) == 0x0000AC, "Member 'UInterpTrackDirector::M_BlendExp' has a wrong offset!");
static_assert(offsetof(UInterpTrackDirector, M_BlendInterp) == 0x0000B0, "Member 'UInterpTrackDirector::M_BlendInterp' has a wrong offset!");
static_assert(offsetof(UInterpTrackDirector, M_BlendInterpYaw) == 0x0000B1, "Member 'UInterpTrackDirector::M_BlendInterpYaw' has a wrong offset!");

// Class Engine.ParticleModuleLocationBoneSocket
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleLocationBoneSocket final : public UParticleModuleLocationBase
{
public:
	ELocationBoneSocketSource                     SourceType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UniversalOffset;                                   // 0x0054(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLocationBoneSocketInfo>        SourceLocations;                                   // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ELocationBoneSocketSelectionMethod            SelectionMethod;                                   // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUpdatePositionEachFrame : 1;                      // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOrientMeshEmitters : 1;                           // 0x0074(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritBoneVelocity : 1;                          // 0x0074(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InheritVelocityScale;                              // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkelMeshActorParamName;                            // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPreSelectedIndices;                             // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationBoneSocket">();
	}
	static class UParticleModuleLocationBoneSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationBoneSocket>();
	}
};
static_assert(alignof(UParticleModuleLocationBoneSocket) == 0x000008, "Wrong alignment on UParticleModuleLocationBoneSocket");
static_assert(sizeof(UParticleModuleLocationBoneSocket) == 0x000090, "Wrong size on UParticleModuleLocationBoneSocket");
static_assert(offsetof(UParticleModuleLocationBoneSocket, SourceType) == 0x000050, "Member 'UParticleModuleLocationBoneSocket::SourceType' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationBoneSocket, UniversalOffset) == 0x000054, "Member 'UParticleModuleLocationBoneSocket::UniversalOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationBoneSocket, SourceLocations) == 0x000060, "Member 'UParticleModuleLocationBoneSocket::SourceLocations' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationBoneSocket, SelectionMethod) == 0x000070, "Member 'UParticleModuleLocationBoneSocket::SelectionMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationBoneSocket, InheritVelocityScale) == 0x000078, "Member 'UParticleModuleLocationBoneSocket::InheritVelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationBoneSocket, SkelMeshActorParamName) == 0x000080, "Member 'UParticleModuleLocationBoneSocket::SkelMeshActorParamName' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationBoneSocket, NumPreSelectedIndices) == 0x000088, "Member 'UParticleModuleLocationBoneSocket::NumPreSelectedIndices' has a wrong offset!");

// Class Engine.InterpTrackFloatParticleParam
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
class UInterpTrackFloatParticleParam final : public UInterpTrackFloatBase
{
public:
	class FName                                   ParamName;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackFloatParticleParam">();
	}
	static class UInterpTrackFloatParticleParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackFloatParticleParam>();
	}
};
static_assert(alignof(UInterpTrackFloatParticleParam) == 0x112EC5B0, "Wrong alignment on UInterpTrackFloatParticleParam");
static_assert(sizeof(UInterpTrackFloatParticleParam) == 0x112EC5B0, "Wrong size on UInterpTrackFloatParticleParam");
static_assert(offsetof(UInterpTrackFloatParticleParam, ParamName) == 0x0000B0, "Member 'UInterpTrackFloatParticleParam::ParamName' has a wrong offset!");

// Class Engine.SpectatorPawnMovement
// 0x0000 (0x12A61 - 0x12A61)
class USpectatorPawnMovement final : public UFloatingPawnMovement
{
public:
	uint8                                         bIgnoreTimeDilation : 1;                           // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A1[0xF];                                      // 0x02A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorPawnMovement">();
	}
	static class USpectatorPawnMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorPawnMovement>();
	}
};
static_assert(alignof(USpectatorPawnMovement) == 0x012A61, "Wrong alignment on USpectatorPawnMovement");
static_assert(sizeof(USpectatorPawnMovement) == 0x012A61, "Wrong size on USpectatorPawnMovement");

// Class Engine.SQEX_VoxelMeshBoneData
// 0x1165AF30 (0x1165AF70 - 0x0040)
class USQEX_VoxelMeshBoneData final : public USQEX_VoxelMeshBoneDataBase
{
public:
	struct FSQEX_VoxelCheckBoneData               Data;                                              // 0x0040(0x1165AF70)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class USQEX_VoxelMeshBoneDataBase*>    List;                                              // 0x0058(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VoxelMeshBoneData">();
	}
	static class USQEX_VoxelMeshBoneData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_VoxelMeshBoneData>();
	}
};
static_assert(alignof(USQEX_VoxelMeshBoneData) == 0x1165AF70, "Wrong alignment on USQEX_VoxelMeshBoneData");
static_assert(sizeof(USQEX_VoxelMeshBoneData) == 0x1165AF70, "Wrong size on USQEX_VoxelMeshBoneData");
static_assert(offsetof(USQEX_VoxelMeshBoneData, Data) == 0x000040, "Member 'USQEX_VoxelMeshBoneData::Data' has a wrong offset!");
static_assert(offsetof(USQEX_VoxelMeshBoneData, List) == 0x000058, "Member 'USQEX_VoxelMeshBoneData::List' has a wrong offset!");

// Class Engine.ParticleModuleEventSendToGame
// 0x0000 (0x0040 - 0x0040)
class UParticleModuleEventSendToGame final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleEventSendToGame">();
	}
	static class UParticleModuleEventSendToGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleEventSendToGame>();
	}
};
static_assert(alignof(UParticleModuleEventSendToGame) == 0x000008, "Wrong alignment on UParticleModuleEventSendToGame");
static_assert(sizeof(UParticleModuleEventSendToGame) == 0x000040, "Wrong size on UParticleModuleEventSendToGame");

// Class Engine.InterpTrackInstAudioMaster
// 0x0000 (0x0040 - 0x0040)
class UInterpTrackInstAudioMaster final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstAudioMaster">();
	}
	static class UInterpTrackInstAudioMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstAudioMaster>();
	}
};
static_assert(alignof(UInterpTrackInstAudioMaster) == 0x000008, "Wrong alignment on UInterpTrackInstAudioMaster");
static_assert(sizeof(UInterpTrackInstAudioMaster) == 0x000040, "Wrong size on UInterpTrackInstAudioMaster");

// Class Engine.ParticleModuleLightBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleLightBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLightBase">();
	}
	static class UParticleModuleLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLightBase>();
	}
};
static_assert(alignof(UParticleModuleLightBase) == 0x000008, "Wrong alignment on UParticleModuleLightBase");
static_assert(sizeof(UParticleModuleLightBase) == 0x000050, "Wrong size on UParticleModuleLightBase");

// Class Engine.ParticleModuleLight
// 0x0110 (0x0160 - 0x0050)
class UParticleModuleLight : public UParticleModuleLightBase
{
public:
	bool                                          bExposureSuppression;                              // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInverseSquaredFalloff;                         // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsTranslucency;                              // 0x0052(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewLightRadius;                               // 0x0053(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnFraction;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ColorScaleOverLife;                                // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  BrightnessOverLife;                                // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RadiusScale;                                       // 0x00E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  LightExponent;                                     // 0x0118(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x0150(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_153[0x1];                                      // 0x0153(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricScatteringIntensity;                     // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighQualityLights;                                // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShadowCastingLights;                              // 0x0159(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLight">();
	}
	static class UParticleModuleLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLight>();
	}
};
static_assert(alignof(UParticleModuleLight) == 0x000008, "Wrong alignment on UParticleModuleLight");
static_assert(sizeof(UParticleModuleLight) == 0x000160, "Wrong size on UParticleModuleLight");
static_assert(offsetof(UParticleModuleLight, bExposureSuppression) == 0x000050, "Member 'UParticleModuleLight::bExposureSuppression' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, bUseInverseSquaredFalloff) == 0x000051, "Member 'UParticleModuleLight::bUseInverseSquaredFalloff' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, bAffectsTranslucency) == 0x000052, "Member 'UParticleModuleLight::bAffectsTranslucency' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, bPreviewLightRadius) == 0x000053, "Member 'UParticleModuleLight::bPreviewLightRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, SpawnFraction) == 0x000054, "Member 'UParticleModuleLight::SpawnFraction' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, ColorScaleOverLife) == 0x000058, "Member 'UParticleModuleLight::ColorScaleOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, BrightnessOverLife) == 0x0000A8, "Member 'UParticleModuleLight::BrightnessOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, RadiusScale) == 0x0000E0, "Member 'UParticleModuleLight::RadiusScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, LightExponent) == 0x000118, "Member 'UParticleModuleLight::LightExponent' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, LightingChannels) == 0x000150, "Member 'UParticleModuleLight::LightingChannels' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, VolumetricScatteringIntensity) == 0x000154, "Member 'UParticleModuleLight::VolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, bHighQualityLights) == 0x000158, "Member 'UParticleModuleLight::bHighQualityLights' has a wrong offset!");
static_assert(offsetof(UParticleModuleLight, bShadowCastingLights) == 0x000159, "Member 'UParticleModuleLight::bShadowCastingLights' has a wrong offset!");

// Class Engine.ParticleModuleLight_Seeded
// 0x0020 (0x0180 - 0x0160)
class UParticleModuleLight_Seeded final : public UParticleModuleLight
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0160(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLight_Seeded">();
	}
	static class UParticleModuleLight_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLight_Seeded>();
	}
};
static_assert(alignof(UParticleModuleLight_Seeded) == 0x000008, "Wrong alignment on UParticleModuleLight_Seeded");
static_assert(sizeof(UParticleModuleLight_Seeded) == 0x000180, "Wrong size on UParticleModuleLight_Seeded");
static_assert(offsetof(UParticleModuleLight_Seeded, RandomSeedInfo) == 0x000160, "Member 'UParticleModuleLight_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.InterpTrackInstColorScale
// 0x0000 (0x0040 - 0x0040)
class UInterpTrackInstColorScale final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstColorScale">();
	}
	static class UInterpTrackInstColorScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstColorScale>();
	}
};
static_assert(alignof(UInterpTrackInstColorScale) == 0x000008, "Wrong alignment on UInterpTrackInstColorScale");
static_assert(sizeof(UInterpTrackInstColorScale) == 0x000040, "Wrong size on UInterpTrackInstColorScale");

// Class Engine.InterpTrackInstDirector
// 0x0010 (0x0050 - 0x0040)
class UInterpTrackInstDirector final : public UInterpTrackInst
{
public:
	class AActor*                                 OldViewTarget;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_NowViewTarget;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstDirector">();
	}
	static class UInterpTrackInstDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstDirector>();
	}
};
static_assert(alignof(UInterpTrackInstDirector) == 0x000008, "Wrong alignment on UInterpTrackInstDirector");
static_assert(sizeof(UInterpTrackInstDirector) == 0x000050, "Wrong size on UInterpTrackInstDirector");
static_assert(offsetof(UInterpTrackInstDirector, OldViewTarget) == 0x000040, "Member 'UInterpTrackInstDirector::OldViewTarget' has a wrong offset!");
static_assert(offsetof(UInterpTrackInstDirector, M_NowViewTarget) == 0x000048, "Member 'UInterpTrackInstDirector::M_NowViewTarget' has a wrong offset!");

// Class Engine.MaterialExpressionPower
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionPower final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Base;                                              // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Exponent;                                          // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	ESqExPowerMode                                SqExPowerMode;                                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstExponent;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPower">();
	}
	static class UMaterialExpressionPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPower>();
	}
};
static_assert(alignof(UMaterialExpressionPower) == 0x112F2730, "Wrong alignment on UMaterialExpressionPower");
static_assert(sizeof(UMaterialExpressionPower) == 0x112F2730, "Wrong size on UMaterialExpressionPower");
static_assert(offsetof(UMaterialExpressionPower, Base) == 0x000078, "Member 'UMaterialExpressionPower::Base' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPower, Exponent) == 0x0000B0, "Member 'UMaterialExpressionPower::Exponent' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPower, SqExPowerMode) == 0x0000E8, "Member 'UMaterialExpressionPower::SqExPowerMode' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPower, ConstExponent) == 0x0000EC, "Member 'UMaterialExpressionPower::ConstExponent' has a wrong offset!");

// Class Engine.InterpTrackInstEvent
// 0x0008 (0x0048 - 0x0040)
class UInterpTrackInstEvent final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstEvent">();
	}
	static class UInterpTrackInstEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstEvent>();
	}
};
static_assert(alignof(UInterpTrackInstEvent) == 0x000008, "Wrong alignment on UInterpTrackInstEvent");
static_assert(sizeof(UInterpTrackInstEvent) == 0x000048, "Wrong size on UInterpTrackInstEvent");
static_assert(offsetof(UInterpTrackInstEvent, LastUpdatePosition) == 0x000040, "Member 'UInterpTrackInstEvent::LastUpdatePosition' has a wrong offset!");

// Class Engine.InterpTrackInstParticleReplay
// 0x0008 (0x0048 - 0x0040)
class UInterpTrackInstParticleReplay final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstParticleReplay">();
	}
	static class UInterpTrackInstParticleReplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstParticleReplay>();
	}
};
static_assert(alignof(UInterpTrackInstParticleReplay) == 0x000008, "Wrong alignment on UInterpTrackInstParticleReplay");
static_assert(sizeof(UInterpTrackInstParticleReplay) == 0x000048, "Wrong size on UInterpTrackInstParticleReplay");
static_assert(offsetof(UInterpTrackInstParticleReplay, LastUpdatePosition) == 0x000040, "Member 'UInterpTrackInstParticleReplay::LastUpdatePosition' has a wrong offset!");

// Class Engine.PostProcessComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UPostProcessComponent final : public USceneComponent
{
public:
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   Settings;                                          // 0x0420(0x112EAE80)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x0B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0B68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0B6C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnbound : 1;                                      // 0x0B6C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B6D[0x3];                                      // 0x0B6D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessComponent">();
	}
	static class UPostProcessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessComponent>();
	}
};
static_assert(alignof(UPostProcessComponent) == 0x112E9AF0, "Wrong alignment on UPostProcessComponent");
static_assert(sizeof(UPostProcessComponent) == 0x112E9AF0, "Wrong size on UPostProcessComponent");
static_assert(offsetof(UPostProcessComponent, Settings) == 0x000420, "Member 'UPostProcessComponent::Settings' has a wrong offset!");
static_assert(offsetof(UPostProcessComponent, Priority) == 0x000B60, "Member 'UPostProcessComponent::Priority' has a wrong offset!");
static_assert(offsetof(UPostProcessComponent, BlendRadius) == 0x000B64, "Member 'UPostProcessComponent::BlendRadius' has a wrong offset!");
static_assert(offsetof(UPostProcessComponent, BlendWeight) == 0x000B68, "Member 'UPostProcessComponent::BlendWeight' has a wrong offset!");

// Class Engine.InterpTrackInstSlomo
// 0x0008 (0x0048 - 0x0040)
class UInterpTrackInstSlomo final : public UInterpTrackInst
{
public:
	float                                         OldTimeDilation;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstSlomo">();
	}
	static class UInterpTrackInstSlomo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstSlomo>();
	}
};
static_assert(alignof(UInterpTrackInstSlomo) == 0x000008, "Wrong alignment on UInterpTrackInstSlomo");
static_assert(sizeof(UInterpTrackInstSlomo) == 0x000048, "Wrong size on UInterpTrackInstSlomo");
static_assert(offsetof(UInterpTrackInstSlomo, OldTimeDilation) == 0x000040, "Member 'UInterpTrackInstSlomo::OldTimeDilation' has a wrong offset!");

// Class Engine.MaterialExpressionTextureObject
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionTextureObject final : public UMaterialExpressionTextureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureObject">();
	}
	static class UMaterialExpressionTextureObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureObject>();
	}
};
static_assert(alignof(UMaterialExpressionTextureObject) == 0x000008, "Wrong alignment on UMaterialExpressionTextureObject");
static_assert(sizeof(UMaterialExpressionTextureObject) == 0x000088, "Wrong size on UMaterialExpressionTextureObject");

// Class Engine.SoundNodeOscillator
// 0x0028 (0x0078 - 0x0050)
class USoundNodeOscillator final : public USoundNode
{
public:
	uint8                                         bModulateVolume : 1;                               // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bModulatePitch : 1;                                // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmplitudeMin;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplitudeMax;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyMin;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrequencyMax;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetMin;                                         // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetMax;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterMin;                                         // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterMax;                                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeOscillator">();
	}
	static class USoundNodeOscillator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeOscillator>();
	}
};
static_assert(alignof(USoundNodeOscillator) == 0x000008, "Wrong alignment on USoundNodeOscillator");
static_assert(sizeof(USoundNodeOscillator) == 0x000078, "Wrong size on USoundNodeOscillator");
static_assert(offsetof(USoundNodeOscillator, AmplitudeMin) == 0x000054, "Member 'USoundNodeOscillator::AmplitudeMin' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, AmplitudeMax) == 0x000058, "Member 'USoundNodeOscillator::AmplitudeMax' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, FrequencyMin) == 0x00005C, "Member 'USoundNodeOscillator::FrequencyMin' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, FrequencyMax) == 0x000060, "Member 'USoundNodeOscillator::FrequencyMax' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, OffsetMin) == 0x000064, "Member 'USoundNodeOscillator::OffsetMin' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, OffsetMax) == 0x000068, "Member 'USoundNodeOscillator::OffsetMax' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, CenterMin) == 0x00006C, "Member 'USoundNodeOscillator::CenterMin' has a wrong offset!");
static_assert(offsetof(USoundNodeOscillator, CenterMax) == 0x000070, "Member 'USoundNodeOscillator::CenterMax' has a wrong offset!");

// Class Engine.InterpTrackMoveAxis
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
class UInterpTrackMoveAxis final : public UInterpTrackFloatBase
{
public:
	EInterpMoveAxis                               MoveAxis;                                          // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpLookupTrack                     LookupTrack;                                       // 0x00B8(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackMoveAxis">();
	}
	static class UInterpTrackMoveAxis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackMoveAxis>();
	}
};
static_assert(alignof(UInterpTrackMoveAxis) == 0x112EC5B0, "Wrong alignment on UInterpTrackMoveAxis");
static_assert(sizeof(UInterpTrackMoveAxis) == 0x112EC5B0, "Wrong size on UInterpTrackMoveAxis");
static_assert(offsetof(UInterpTrackMoveAxis, MoveAxis) == 0x0000B0, "Member 'UInterpTrackMoveAxis::MoveAxis' has a wrong offset!");
static_assert(offsetof(UInterpTrackMoveAxis, LookupTrack) == 0x0000B8, "Member 'UInterpTrackMoveAxis::LookupTrack' has a wrong offset!");

// Class Engine.MaterialExpressionSphericalParticleOpacity
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSphericalParticleOpacity final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Density;                                           // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstantDensity;                                   // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSphericalParticleOpacity">();
	}
	static class UMaterialExpressionSphericalParticleOpacity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSphericalParticleOpacity>();
	}
};
static_assert(alignof(UMaterialExpressionSphericalParticleOpacity) == 0x112F2730, "Wrong alignment on UMaterialExpressionSphericalParticleOpacity");
static_assert(sizeof(UMaterialExpressionSphericalParticleOpacity) == 0x112F2730, "Wrong size on UMaterialExpressionSphericalParticleOpacity");
static_assert(offsetof(UMaterialExpressionSphericalParticleOpacity, Density) == 0x000078, "Member 'UMaterialExpressionSphericalParticleOpacity::Density' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSphericalParticleOpacity, ConstantDensity) == 0x0000B0, "Member 'UMaterialExpressionSphericalParticleOpacity::ConstantDensity' has a wrong offset!");

// Class Engine.InterpTrackParticleReplay
// 0x0010 (0x00A0 - 0x0090)
class UInterpTrackParticleReplay final : public UInterpTrack
{
public:
	TArray<struct FParticleReplayTrackKey>        TrackKeys;                                         // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackParticleReplay">();
	}
	static class UInterpTrackParticleReplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackParticleReplay>();
	}
};
static_assert(alignof(UInterpTrackParticleReplay) == 0x000008, "Wrong alignment on UInterpTrackParticleReplay");
static_assert(sizeof(UInterpTrackParticleReplay) == 0x0000A0, "Wrong size on UInterpTrackParticleReplay");
static_assert(offsetof(UInterpTrackParticleReplay, TrackKeys) == 0x000090, "Member 'UInterpTrackParticleReplay::TrackKeys' has a wrong offset!");

// Class Engine.UserDefinedEnum
// 0x0050 (0x00C8 - 0x0078)
class UUserDefinedEnum final : public UEnum
{
public:
	TMap<class FName, class FText>                DisplayNameMap;                                    // 0x0078(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserDefinedEnum">();
	}
	static class UUserDefinedEnum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserDefinedEnum>();
	}
};
static_assert(alignof(UUserDefinedEnum) == 0x000008, "Wrong alignment on UUserDefinedEnum");
static_assert(sizeof(UUserDefinedEnum) == 0x0000C8, "Wrong size on UUserDefinedEnum");
static_assert(offsetof(UUserDefinedEnum, DisplayNameMap) == 0x000078, "Member 'UUserDefinedEnum::DisplayNameMap' has a wrong offset!");

// Class Engine.InterpTrackSlomo
// 0x0000 (0x112EC5B0 - 0x112EC5B0)
class UInterpTrackSlomo final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackSlomo">();
	}
	static class UInterpTrackSlomo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackSlomo>();
	}
};
static_assert(alignof(UInterpTrackSlomo) == 0x112EC5B0, "Wrong alignment on UInterpTrackSlomo");
static_assert(sizeof(UInterpTrackSlomo) == 0x112EC5B0, "Wrong size on UInterpTrackSlomo");

// Class Engine.ParticleModuleOrbitBase
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleOrbitBase : public UParticleModule
{
public:
	uint8                                         bUseEmitterTime : 1;                               // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleOrbitBase">();
	}
	static class UParticleModuleOrbitBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleOrbitBase>();
	}
};
static_assert(alignof(UParticleModuleOrbitBase) == 0x000008, "Wrong alignment on UParticleModuleOrbitBase");
static_assert(sizeof(UParticleModuleOrbitBase) == 0x000058, "Wrong size on UParticleModuleOrbitBase");

// Class Engine.InterpTrackToggle
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackToggle final : public UInterpTrack
{
public:
	TArray<struct FToggleTrackKey>                ToggleTrack;                                       // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bActivateSystemEachUpdate : 1;                     // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActivateWithJustAttachedFlag : 1;                 // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenJumpingForwards : 1;                // 0x00A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackToggle">();
	}
	static class UInterpTrackToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackToggle>();
	}
};
static_assert(alignof(UInterpTrackToggle) == 0x000008, "Wrong alignment on UInterpTrackToggle");
static_assert(sizeof(UInterpTrackToggle) == 0x0000A8, "Wrong size on UInterpTrackToggle");
static_assert(offsetof(UInterpTrackToggle, ToggleTrack) == 0x000090, "Member 'UInterpTrackToggle::ToggleTrack' has a wrong offset!");

// Class Engine.ParticleModuleMeshRotation
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionVector                 StartRotation;                                     // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bInheritParent : 1;                                // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshRotation">();
	}
	static class UParticleModuleMeshRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshRotation>();
	}
};
static_assert(alignof(UParticleModuleMeshRotation) == 0x000008, "Wrong alignment on UParticleModuleMeshRotation");
static_assert(sizeof(UParticleModuleMeshRotation) == 0x0000A8, "Wrong size on UParticleModuleMeshRotation");
static_assert(offsetof(UParticleModuleMeshRotation, StartRotation) == 0x000050, "Member 'UParticleModuleMeshRotation::StartRotation' has a wrong offset!");

// Class Engine.TimelineTemplate
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class UTimelineTemplate final : public UObject
{
public:
	float                                         TimelineLength;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETimelineLengthMode                           LengthMode;                                        // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoPlay : 1;                                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoop : 1;                                         // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReplicated : 1;                                   // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bValidatedAsWired : 1;                             // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreTimeDilation : 1;                           // 0x0048(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTTEventTrack>                  EventTracks;                                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTTFloatTrack>                  FloatTracks;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTTVectorTrack>                 VectorTracks;                                      // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTTLinearColorTrack>            LinearColorTracks;                                 // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBPVariableMetaDataEntry>       MetaDataArray;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  TimelineGuid;                                      // 0x00A0(0x112E8D20)(DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimelineTemplate">();
	}
	static class UTimelineTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimelineTemplate>();
	}
};
static_assert(alignof(UTimelineTemplate) == 0x112E8D20, "Wrong alignment on UTimelineTemplate");
static_assert(sizeof(UTimelineTemplate) == 0x112E8D20, "Wrong size on UTimelineTemplate");
static_assert(offsetof(UTimelineTemplate, TimelineLength) == 0x000040, "Member 'UTimelineTemplate::TimelineLength' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, LengthMode) == 0x000044, "Member 'UTimelineTemplate::LengthMode' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, EventTracks) == 0x000050, "Member 'UTimelineTemplate::EventTracks' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, FloatTracks) == 0x000060, "Member 'UTimelineTemplate::FloatTracks' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, VectorTracks) == 0x000070, "Member 'UTimelineTemplate::VectorTracks' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, LinearColorTracks) == 0x000080, "Member 'UTimelineTemplate::LinearColorTracks' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, MetaDataArray) == 0x000090, "Member 'UTimelineTemplate::MetaDataArray' has a wrong offset!");
static_assert(offsetof(UTimelineTemplate, TimelineGuid) == 0x0000A0, "Member 'UTimelineTemplate::TimelineGuid' has a wrong offset!");

// Class Engine.IntSerialization
// 0x0028 (0x0068 - 0x0040)
class UIntSerialization final : public UObject
{
public:
	uint16                                        UnsignedInt16Variable;                             // 0x0040(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        UnsignedInt32Variable;                             // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        UnsignedInt64Variable;                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          SignedInt8Variable;                                // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x1];                                       // 0x0051(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int16                                         SignedInt16Variable;                               // 0x0052(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         SignedInt64Variable;                               // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UnsignedInt8Variable;                              // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SignedInt32Variable;                               // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntSerialization">();
	}
	static class UIntSerialization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntSerialization>();
	}
};
static_assert(alignof(UIntSerialization) == 0x000008, "Wrong alignment on UIntSerialization");
static_assert(sizeof(UIntSerialization) == 0x000068, "Wrong size on UIntSerialization");
static_assert(offsetof(UIntSerialization, UnsignedInt16Variable) == 0x000040, "Member 'UIntSerialization::UnsignedInt16Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, UnsignedInt32Variable) == 0x000044, "Member 'UIntSerialization::UnsignedInt32Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, UnsignedInt64Variable) == 0x000048, "Member 'UIntSerialization::UnsignedInt64Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, SignedInt8Variable) == 0x000050, "Member 'UIntSerialization::SignedInt8Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, SignedInt16Variable) == 0x000052, "Member 'UIntSerialization::SignedInt16Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, SignedInt64Variable) == 0x000058, "Member 'UIntSerialization::SignedInt64Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, UnsignedInt8Variable) == 0x000060, "Member 'UIntSerialization::UnsignedInt8Variable' has a wrong offset!");
static_assert(offsetof(UIntSerialization, SignedInt32Variable) == 0x000064, "Member 'UIntSerialization::SignedInt32Variable' has a wrong offset!");

// Class Engine.MaterialExpressionClamp
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionClamp final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Min;                                               // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Max;                                               // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	EClampMode                                    ClampMode;                                         // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDefault;                                        // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDefault;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionClamp">();
	}
	static class UMaterialExpressionClamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionClamp>();
	}
};
static_assert(alignof(UMaterialExpressionClamp) == 0x112F2730, "Wrong alignment on UMaterialExpressionClamp");
static_assert(sizeof(UMaterialExpressionClamp) == 0x112F2730, "Wrong size on UMaterialExpressionClamp");
static_assert(offsetof(UMaterialExpressionClamp, Input) == 0x000078, "Member 'UMaterialExpressionClamp::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionClamp, Min) == 0x0000B0, "Member 'UMaterialExpressionClamp::Min' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionClamp, Max) == 0x0000E8, "Member 'UMaterialExpressionClamp::Max' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionClamp, ClampMode) == 0x000120, "Member 'UMaterialExpressionClamp::ClampMode' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionClamp, MinDefault) == 0x000124, "Member 'UMaterialExpressionClamp::MinDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionClamp, MaxDefault) == 0x000128, "Member 'UMaterialExpressionClamp::MaxDefault' has a wrong offset!");

// Class Engine.KillZVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AKillZVolume final : public APhysicsVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillZVolume">();
	}
	static class AKillZVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillZVolume>();
	}
};
static_assert(alignof(AKillZVolume) == 0x1EF72E00, "Wrong alignment on AKillZVolume");
static_assert(sizeof(AKillZVolume) == 0x1EF72E00, "Wrong size on AKillZVolume");

// Class Engine.SubsurfaceProfile
// 0x0028 (0x0068 - 0x0040)
class USubsurfaceProfile final : public UObject
{
public:
	struct FSubsurfaceProfileStruct               Settings;                                          // 0x0040(0x112EAE80)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubsurfaceProfile">();
	}
	static class USubsurfaceProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubsurfaceProfile>();
	}
};
static_assert(alignof(USubsurfaceProfile) == 0x000008, "Wrong alignment on USubsurfaceProfile");
static_assert(sizeof(USubsurfaceProfile) == 0x000068, "Wrong size on USubsurfaceProfile");
static_assert(offsetof(USubsurfaceProfile, Settings) == 0x000040, "Member 'USubsurfaceProfile::Settings' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_EmitterDirectEX
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSQEX_EmitterDirectEX final : public UParticleModuleSQEX_Base
{
public:
	class FName                                   EmitterName;                                       // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_EmitterDirectEX">();
	}
	static class UParticleModuleSQEX_EmitterDirectEX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_EmitterDirectEX>();
	}
};
static_assert(alignof(UParticleModuleSQEX_EmitterDirectEX) == 0x000008, "Wrong alignment on UParticleModuleSQEX_EmitterDirectEX");
static_assert(sizeof(UParticleModuleSQEX_EmitterDirectEX) == 0x000058, "Wrong size on UParticleModuleSQEX_EmitterDirectEX");
static_assert(offsetof(UParticleModuleSQEX_EmitterDirectEX, EmitterName) == 0x000050, "Member 'UParticleModuleSQEX_EmitterDirectEX::EmitterName' has a wrong offset!");

// Class Engine.KismetArrayLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetArrayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 Array_Add(const TArray<int32>& TargetArray, const int32& NewItem);
	static int32 Array_AddUnique(const TArray<int32>& TargetArray, const int32& NewItem);
	static void Array_Append(const TArray<int32>& TargetArray, const TArray<int32>& SourceArray);
	static void Array_Clear(const TArray<int32>& TargetArray);
	static bool Array_Contains(const TArray<int32>& TargetArray, const int32& ItemToFind);
	static int32 Array_Find(const TArray<int32>& TargetArray, const int32& ItemToFind);
	static void Array_Get(const TArray<int32>& TargetArray, int32 Index_0, int32* Item);
	static void Array_Insert(const TArray<int32>& TargetArray, const int32& NewItem, int32 Index_0);
	static bool Array_IsValidIndex(const TArray<int32>& TargetArray, int32 IndexToTest);
	static int32 Array_LastIndex(const TArray<int32>& TargetArray);
	static int32 Array_Length(const TArray<int32>& TargetArray);
	static void Array_Remove(const TArray<int32>& TargetArray, int32 IndexToRemove);
	static bool Array_RemoveItem(const TArray<int32>& TargetArray, const int32& Item);
	static void Array_Resize(const TArray<int32>& TargetArray, int32 Size);
	static void Array_Set(const TArray<int32>& TargetArray, int32 Index_0, const int32& Item, bool bSizeToFit);
	static void Array_Shuffle(const TArray<int32>& TargetArray);
	static void FilterArray(const TArray<class AActor*>& TargetArray, TSubclassOf<class AActor> FilterClass, TArray<class AActor*>* FilteredArray);
	static void SetArrayPropertyByName(class UObject* Object, class FName PropertyName, const TArray<int32>& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetArrayLibrary">();
	}
	static class UKismetArrayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetArrayLibrary>();
	}
};
static_assert(alignof(UKismetArrayLibrary) == 0x000008, "Wrong alignment on UKismetArrayLibrary");
static_assert(sizeof(UKismetArrayLibrary) == 0x000040, "Wrong size on UKismetArrayLibrary");

// Class Engine.KismetInternationalizationLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetInternationalizationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearCurrentAssetGroupCulture(const class FName AssetGroup, const bool SaveToConfig);
	static class FString GetCurrentAssetGroupCulture(const class FName AssetGroup);
	static class FString GetCurrentCulture();
	static class FString GetCurrentLanguage();
	static class FString GetCurrentLocale();
	static bool SetCurrentAssetGroupCulture(const class FName AssetGroup, const class FString& Culture, const bool SaveToConfig);
	static bool SetCurrentCulture(const class FString& Culture, const bool SaveToConfig);
	static bool SetCurrentLanguage(const class FString& Culture, const bool SaveToConfig);
	static bool SetCurrentLanguageAndLocale(const class FString& Culture, const bool SaveToConfig);
	static bool SetCurrentLocale(const class FString& Culture, const bool SaveToConfig);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetInternationalizationLibrary">();
	}
	static class UKismetInternationalizationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetInternationalizationLibrary>();
	}
};
static_assert(alignof(UKismetInternationalizationLibrary) == 0x000008, "Wrong alignment on UKismetInternationalizationLibrary");
static_assert(sizeof(UKismetInternationalizationLibrary) == 0x000040, "Wrong size on UKismetInternationalizationLibrary");

// Class Engine.MaterialExpressionAppendVector
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionAppendVector final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAppendVector">();
	}
	static class UMaterialExpressionAppendVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAppendVector>();
	}
};
static_assert(alignof(UMaterialExpressionAppendVector) == 0x112F2730, "Wrong alignment on UMaterialExpressionAppendVector");
static_assert(sizeof(UMaterialExpressionAppendVector) == 0x112F2730, "Wrong size on UMaterialExpressionAppendVector");
static_assert(offsetof(UMaterialExpressionAppendVector, A) == 0x000078, "Member 'UMaterialExpressionAppendVector::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionAppendVector, B) == 0x0000B0, "Member 'UMaterialExpressionAppendVector::B' has a wrong offset!");

// Class Engine.KismetMaterialLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetMaterialLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UMaterialInstanceDynamic* CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent);
	static float GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName);
	static struct FLinearColor GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName);
	static void ResetDefaultParameterAll(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection);
	static void SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float ParameterValue);
	static void SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, const struct FLinearColor& ParameterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetMaterialLibrary">();
	}
	static class UKismetMaterialLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetMaterialLibrary>();
	}
};
static_assert(alignof(UKismetMaterialLibrary) == 0x000008, "Wrong alignment on UKismetMaterialLibrary");
static_assert(sizeof(UKismetMaterialLibrary) == 0x000040, "Wrong size on UKismetMaterialLibrary");

// Class Engine.SceneCaptureCube
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASceneCaptureCube final : public ASceneCapture
{
public:
	class USceneCaptureComponentCube*             CaptureComponentCube;                              // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDrawFrustumComponent*                  DrawFrustum;                                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInterpToggle(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureCube">();
	}
	static class ASceneCaptureCube* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneCaptureCube>();
	}
};
static_assert(alignof(ASceneCaptureCube) == 0x1EF72E00, "Wrong alignment on ASceneCaptureCube");
static_assert(sizeof(ASceneCaptureCube) == 0x1EF72E00, "Wrong size on ASceneCaptureCube");
static_assert(offsetof(ASceneCaptureCube, CaptureComponentCube) == 0x0003E8, "Member 'ASceneCaptureCube::CaptureComponentCube' has a wrong offset!");
static_assert(offsetof(ASceneCaptureCube, DrawFrustum) == 0x0003F0, "Member 'ASceneCaptureCube::DrawFrustum' has a wrong offset!");

// Class Engine.MaterialExpressionDepthFade
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDepthFade final : public UMaterialExpression
{
public:
	struct FExpressionInput                       InOpacity;                                         // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       FadeDistance;                                      // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         OpacityDefault;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDistanceDefault;                               // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDepthFade">();
	}
	static class UMaterialExpressionDepthFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDepthFade>();
	}
};
static_assert(alignof(UMaterialExpressionDepthFade) == 0x112F2730, "Wrong alignment on UMaterialExpressionDepthFade");
static_assert(sizeof(UMaterialExpressionDepthFade) == 0x112F2730, "Wrong size on UMaterialExpressionDepthFade");
static_assert(offsetof(UMaterialExpressionDepthFade, InOpacity) == 0x000078, "Member 'UMaterialExpressionDepthFade::InOpacity' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDepthFade, FadeDistance) == 0x0000B0, "Member 'UMaterialExpressionDepthFade::FadeDistance' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDepthFade, OpacityDefault) == 0x0000E8, "Member 'UMaterialExpressionDepthFade::OpacityDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDepthFade, FadeDistanceDefault) == 0x0000EC, "Member 'UMaterialExpressionDepthFade::FadeDistanceDefault' has a wrong offset!");

// Class Engine.KismetMathLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float Abs(float A);
	static int32 Abs_Int(int32 A);
	static float Acos(float A);
	static uint8 Add_ByteByte(uint8 A, uint8 B);
	static struct FDateTime Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B);
	static float Add_FloatFloat(float A, float B);
	static int32 Add_IntInt(int32 A, int32 B);
	static struct FTimespan Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static struct FVector2D Add_Vector2DFloat(const struct FVector2D& A, float B);
	static struct FVector2D Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector Add_VectorFloat(const struct FVector& A, float B);
	static struct FVector Add_VectorInt(const struct FVector& A, int32 B);
	static struct FVector Add_VectorVector(const struct FVector& A, const struct FVector& B);
	static int32 And_IntInt(int32 A, int32 B);
	static float Asin(float A);
	static float Atan(float A);
	static float Atan2(float A, float B);
	static uint8 BMax(uint8 A, uint8 B);
	static uint8 BMin(uint8 A, uint8 B);
	static bool BooleanAND(bool A, bool B);
	static bool BooleanNAND(bool A, bool B);
	static bool BooleanNOR(bool A, bool B);
	static bool BooleanOR(bool A, bool B);
	static bool BooleanXOR(bool A, bool B);
	static void BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A);
	static void BreakDateTime(const struct FDateTime& InDateTime, int32* Year, int32* Month, int32* Day, int32* Hour, int32* Minute, int32* Second, int32* Millisecond);
	static void BreakRandomStream(const struct FRandomStream& InRandomStream, int32* InitialSeed);
	static void BreakRotator(const struct FRotator& InRot, float* Roll, float* Pitch, float* Yaw);
	static void BreakRotIntoAxes(const struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z);
	static void BreakTimespan(const struct FTimespan& InTimespan, int32* Days, int32* Hours, int32* Minutes, int32* Seconds, int32* Milliseconds);
	static void BreakTransform(const struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale);
	static void BreakVector(const struct FVector& InVec, float* X, float* Y, float* Z);
	static void BreakVector2D(const struct FVector2D& InVec, float* X, float* Y);
	static struct FLinearColor CInterpTo(const struct FLinearColor& Current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed);
	static int32 Clamp(int32 Value, int32 Min_0, int32 Max_0);
	static float ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees);
	static float ClampAxis(float Angle);
	static struct FVector ClampVectorSize(const struct FVector& A, float Min_0, float Max_0);
	static bool ClassIsChildOf(TSubclassOf<class UObject> TestClass, TSubclassOf<class UObject> ParentClass);
	static struct FRotator ComposeRotators(const struct FRotator& A, const struct FRotator& B);
	static struct FTransform ComposeTransforms(const struct FTransform& A, const struct FTransform& B);
	static uint8 Conv_BoolToByte(bool InBool);
	static float Conv_BoolToFloat(bool InBool);
	static int32 Conv_BoolToInt(bool InBool);
	static float Conv_ByteToFloat(uint8 InByte);
	static int32 Conv_ByteToInt(uint8 InByte);
	static struct FLinearColor Conv_ColorToLinearColor(const struct FColor& InColor);
	static struct FLinearColor Conv_FloatToLinearColor(float InFloat);
	static struct FVector Conv_FloatToVector(float InFloat);
	static bool Conv_IntToBool(int32 InInt);
	static uint8 Conv_IntToByte(int32 InInt);
	static float Conv_IntToFloat(int32 InInt);
	static struct FIntVector Conv_IntToIntVector(int32 InInt);
	static struct FVector Conv_IntVectorToVector(const struct FIntVector& InIntVector);
	static struct FColor Conv_LinearColorToColor(const struct FLinearColor& InLinearColor);
	static struct FVector Conv_LinearColorToVector(const struct FLinearColor& InLinearColor);
	static struct FVector Conv_RotatorToVector(const struct FRotator& InRot);
	static struct FVector Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z);
	static struct FLinearColor Conv_VectorToLinearColor(const struct FVector& InVec);
	static struct FRotator Conv_VectorToRotator(const struct FVector& InVec);
	static struct FTransform Conv_VectorToTransform(const struct FVector& InLocation);
	static struct FVector2D Conv_VectorToVector2D(const struct FVector& InVector);
	static struct FTransform ConvertTransformToRelative(const struct FTransform& Transform, const struct FTransform& ParentTransform);
	static float Cos(float A);
	static struct FVector CreateVectorFromYawPitch(float Yaw, float Pitch, float Length);
	static struct FVector Cross_VectorVector(const struct FVector& A, const struct FVector& B);
	static float CrossProduct2D(const struct FVector2D& A, const struct FVector2D& B);
	static bool DateTimeFromIsoString(const class FString& IsoString, struct FDateTime* Result);
	static bool DateTimeFromString(const class FString& DateTimeString, struct FDateTime* Result);
	static struct FDateTime DateTimeMaxValue();
	static struct FDateTime DateTimeMinValue();
	static int32 DaysInMonth(int32 Year, int32 Month);
	static int32 DaysInYear(int32 Year);
	static float DegAcos(float A);
	static float DegAsin(float A);
	static float DegAtan(float A);
	static float DegAtan2(float A, float B);
	static float DegCos(float A);
	static float DegreesToRadians(float A);
	static float DegSin(float A);
	static float DegTan(float A);
	static uint8 Divide_ByteByte(uint8 A, uint8 B);
	static float Divide_FloatFloat(float A, float B);
	static int32 Divide_IntInt(int32 A, int32 B);
	static struct FVector2D Divide_Vector2DFloat(const struct FVector2D& A, float B);
	static struct FVector2D Divide_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector Divide_VectorFloat(const struct FVector& A, float B);
	static struct FVector Divide_VectorInt(const struct FVector& A, int32 B);
	static struct FVector Divide_VectorVector(const struct FVector& A, const struct FVector& B);
	static float Dot_VectorVector(const struct FVector& A, const struct FVector& B);
	static float DotProduct2D(const struct FVector2D& A, const struct FVector2D& B);
	static float Ease(float A, float B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static bool EqualEqual_BoolBool(bool A, bool B);
	static bool EqualEqual_ByteByte(uint8 A, uint8 B);
	static bool EqualEqual_ClassClass(class UClass* A, class UClass* B);
	static bool EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool EqualEqual_FloatFloat(float A, float B);
	static bool EqualEqual_IntInt(int32 A, int32 B);
	static bool EqualEqual_NameName(class FName A, class FName B);
	static bool EqualEqual_ObjectObject(class UObject* A, class UObject* B);
	static bool EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance);
	static bool EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static bool EqualEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B);
	static bool EqualEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance);
	static bool EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance);
	static float Exp(float A);
	static int32 FCeil(float A);
	static float FClamp(float Value, float Min_0, float Max_0);
	static int32 FFloor(float A);
	static struct FVector FindClosestPointOnLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection);
	static struct FVector FindClosestPointOnSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd);
	static struct FRotator FindLookAtRotation(const struct FVector& Start, const struct FVector& Target);
	static void FindNearestPointsOnLineSegments(const struct FVector& Segment1Start, const struct FVector& Segment1End, const struct FVector& Segment2Start, const struct FVector& Segment2End, struct FVector* Segment1Point, struct FVector* Segment2Point);
	static float FInterpEaseInOut(float A, float B, float Alpha, float Exponent);
	static float FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed);
	static float FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed);
	static float FixedTurn(float InCurrent, float InDesired, float InDeltaRate);
	static float FloatSpringInterp(float Current, float Target, struct FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass);
	static float FMax(float A, float B);
	static float FMin(float A, float B);
	static int32 FMod(float Dividend, float Divisor, float* Remainder);
	static float Fraction(float A);
	static struct FTimespan FromDays(float Days);
	static struct FTimespan FromHours(float Hours);
	static struct FTimespan FromMilliseconds(float Milliseconds);
	static struct FTimespan FromMinutes(float Minutes);
	static struct FTimespan FromSeconds(float Seconds);
	static int32 FTrunc(float A);
	static struct FIntVector FTruncVector(const struct FVector& InVector);
	static void GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z);
	static struct FDateTime GetDate(const struct FDateTime& A);
	static int32 GetDay(const struct FDateTime& A);
	static int32 GetDayOfYear(const struct FDateTime& A);
	static int32 GetDays(const struct FTimespan& A);
	static struct FVector GetDirectionUnitVector(const struct FVector& From, const struct FVector& To);
	static struct FTimespan GetDuration(const struct FTimespan& A);
	static struct FVector GetForwardVector(const struct FRotator& InRot);
	static int32 GetHour(const struct FDateTime& A);
	static int32 GetHour12(const struct FDateTime& A);
	static int32 GetHours(const struct FTimespan& A);
	static float GetMaxElement(const struct FVector& A);
	static int32 GetMillisecond(const struct FDateTime& A);
	static int32 GetMilliseconds(const struct FTimespan& A);
	static float GetMinElement(const struct FVector& A);
	static int32 GetMinute(const struct FDateTime& A);
	static int32 GetMinutes(const struct FTimespan& A);
	static int32 GetMonth(const struct FDateTime& A);
	static float GetPI();
	static float GetPointDistanceToLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection);
	static float GetPointDistanceToSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd);
	static struct FVector GetReflectionVector(const struct FVector& Direction, const struct FVector& SurfaceNormal);
	static struct FVector GetRightVector(const struct FRotator& InRot);
	static int32 GetSecond(const struct FDateTime& A);
	static int32 GetSeconds(const struct FTimespan& A);
	static float GetTAU();
	static struct FTimespan GetTimeOfDay(const struct FDateTime& A);
	static float GetTotalDays(const struct FTimespan& A);
	static float GetTotalHours(const struct FTimespan& A);
	static float GetTotalMilliseconds(const struct FTimespan& A);
	static float GetTotalMinutes(const struct FTimespan& A);
	static float GetTotalSeconds(const struct FTimespan& A);
	static struct FVector GetUpVector(const struct FRotator& InRot);
	static struct FVector GetVectorArrayAverage(const TArray<struct FVector>& Vectors);
	static void GetYawPitchFromVector(const struct FVector& InVec, float* Yaw, float* Pitch);
	static int32 GetYear(const struct FDateTime& A);
	static bool Greater_ByteByte(uint8 A, uint8 B);
	static bool Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool Greater_FloatFloat(float A, float B);
	static bool Greater_IntInt(int32 A, int32 B);
	static bool Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static bool GreaterEqual_ByteByte(uint8 A, uint8 B);
	static bool GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool GreaterEqual_FloatFloat(float A, float B);
	static bool GreaterEqual_IntInt(int32 A, int32 B);
	static bool GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static struct FVector GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B);
	static float GridSnap_Float(float Location, float GridSize);
	static struct FLinearColor HSVToRGB(float H, float S, float V, float A);
	static void HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB);
	static float Hypotenuse(float Width, float Height);
	static bool InRange_FloatFloat(float Value, float Min_0, float Max_0, bool InclusiveMin, bool InclusiveMax);
	static float InverseLerp(float A, float B, float Value);
	static struct FVector InverseTransformDirection(const struct FTransform& T, const struct FVector& Direction);
	static struct FVector InverseTransformLocation(const struct FTransform& T, const struct FVector& Location);
	static struct FTransform InvertTransform(const struct FTransform& T);
	static bool IsAfternoon(const struct FDateTime& A);
	static bool IsLeapYear(int32 Year);
	static bool IsMorning(const struct FDateTime& A);
	static bool IsPointInBox(const struct FVector& Point, const struct FVector& BoxOrigin, const struct FVector& BoxExtent);
	static bool IsPointInBoxWithTransform(const struct FVector& Point, const struct FTransform& BoxWorldTransform, const struct FVector& BoxExtent);
	static float Lerp(float A, float B, float Alpha);
	static bool Less_ByteByte(uint8 A, uint8 B);
	static bool Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool Less_FloatFloat(float A, float B);
	static bool Less_IntInt(int32 A, int32 B);
	static bool Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static bool LessEqual_ByteByte(uint8 A, uint8 B);
	static bool LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool LessEqual_FloatFloat(float A, float B);
	static bool LessEqual_IntInt(int32 A, int32 B);
	static bool LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static struct FVector LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B);
	static struct FLinearColor LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha);
	static struct FLinearColor LinearColorLerpUsingHSV(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha);
	static bool LinePlaneIntersection(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FPlane& APlane, float* T, struct FVector* Intersection);
	static bool LinePlaneIntersection_OriginNormal(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection);
	static float Log(float A, float Base);
	static float Loge(float A);
	static struct FBox MakeBox(const struct FVector& Min_0, const struct FVector& Max_0);
	static struct FBox2D MakeBox2D(const struct FVector2D& Min_0, const struct FVector2D& Max_0);
	static struct FLinearColor MakeColor(float R, float G, float B, float A);
	static struct FDateTime MakeDateTime(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second, int32 Millisecond);
	static struct FPlane MakePlaneFromPointAndNormal(const struct FVector& Point, const struct FVector& Normal_0);
	static float MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase);
	static struct FRandomStream MakeRandomStream(int32 InitialSeed);
	static struct FRotator MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up);
	static struct FRotator MakeRotator(float Roll, float Pitch, float Yaw);
	static struct FRotator MakeRotFromX(const struct FVector& X);
	static struct FRotator MakeRotFromXY(const struct FVector& X, const struct FVector& Y);
	static struct FRotator MakeRotFromXZ(const struct FVector& X, const struct FVector& Z);
	static struct FRotator MakeRotFromY(const struct FVector& Y);
	static struct FRotator MakeRotFromYX(const struct FVector& Y, const struct FVector& X);
	static struct FRotator MakeRotFromYZ(const struct FVector& Y, const struct FVector& Z);
	static struct FRotator MakeRotFromZ(const struct FVector& Z);
	static struct FRotator MakeRotFromZX(const struct FVector& Z, const struct FVector& X);
	static struct FRotator MakeRotFromZY(const struct FVector& Z, const struct FVector& Y);
	static struct FTimespan MakeTimespan(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 Milliseconds);
	static struct FTransform MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale);
	static struct FVector MakeVector(float X, float Y, float Z);
	static struct FVector2D MakeVector2D(float X, float Y);
	static float MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
	static float MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
	static int32 Max(int32 A, int32 B);
	static void MaxOfByteArray(const TArray<uint8>& ByteArray, int32* IndexOfMaxValue, uint8* MaxValue);
	static void MaxOfFloatArray(const TArray<float>& FloatArray, int32* IndexOfMaxValue, float* MaxValue);
	static void MaxOfIntArray(const TArray<int32>& IntArray, int32* IndexOfMaxValue, int32* MaxValue);
	static int32 Min(int32 A, int32 B);
	static void MinimumAreaRectangle(class UObject* WorldContextObject, const TArray<struct FVector>& InVerts, const struct FVector& SampleSurfaceNormal, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY, bool bDebugDraw);
	static void MinOfByteArray(const TArray<uint8>& ByteArray, int32* IndexOfMinValue, uint8* MinValue);
	static void MinOfFloatArray(const TArray<float>& FloatArray, int32* IndexOfMinValue, float* MinValue);
	static void MinOfIntArray(const TArray<int32>& IntArray, int32* IndexOfMinValue, int32* MinValue);
	static struct FVector MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal);
	static uint8 Multiply_ByteByte(uint8 A, uint8 B);
	static float Multiply_FloatFloat(float A, float B);
	static float Multiply_IntFloat(int32 A, float B);
	static int32 Multiply_IntInt(int32 A, int32 B);
	static struct FLinearColor Multiply_LinearColorFloat(const struct FLinearColor& A, float B);
	static struct FLinearColor Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B);
	static struct FRotator Multiply_RotatorFloat(const struct FRotator& A, float B);
	static struct FRotator Multiply_RotatorInt(const struct FRotator& A, int32 B);
	static struct FTimespan Multiply_TimespanFloat(const struct FTimespan& A, float Scalar);
	static struct FVector2D Multiply_Vector2DFloat(const struct FVector2D& A, float B);
	static struct FVector2D Multiply_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector Multiply_VectorFloat(const struct FVector& A, float B);
	static struct FVector Multiply_VectorInt(const struct FVector& A, int32 B);
	static struct FVector Multiply_VectorVector(const struct FVector& A, const struct FVector& B);
	static float MultiplyByPi(float Value);
	static float MultiplyMultiply_FloatFloat(float Base, float Exp);
	static bool NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance);
	static bool NearlyEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance);
	static struct FRotator NegateRotator(const struct FRotator& A);
	static struct FVector NegateVector(const struct FVector& A);
	static struct FVector Normal(const struct FVector& A);
	static struct FVector2D Normal2D(const struct FVector2D& A);
	static float NormalizeAxis(float Angle);
	static struct FRotator NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B);
	static float NormalizeToRange(float Value, float RangeMin, float RangeMax);
	static int32 Not_Int(int32 A);
	static bool Not_PreBool(bool A);
	static bool NotEqual_BoolBool(bool A, bool B);
	static bool NotEqual_ByteByte(uint8 A, uint8 B);
	static bool NotEqual_ClassClass(class UClass* A, class UClass* B);
	static bool NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool NotEqual_FloatFloat(float A, float B);
	static bool NotEqual_IntInt(int32 A, int32 B);
	static bool NotEqual_NameName(class FName A, class FName B);
	static bool NotEqual_ObjectObject(class UObject* A, class UObject* B);
	static bool NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance);
	static bool NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static bool NotEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance);
	static bool NotEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance);
	static struct FDateTime Now();
	static int32 Or_IntInt(int32 A, int32 B);
	static uint8 Percent_ByteByte(uint8 A, uint8 B);
	static float Percent_FloatFloat(float A, float B);
	static int32 Percent_IntInt(int32 A, int32 B);
	static bool PointsAreCoplanar(const TArray<struct FVector>& Points, float Tolerance);
	static struct FVector ProjectPointOnToPlane(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNormal);
	static struct FVector ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal);
	static struct FVector ProjectVectorOnToVector(const struct FVector& V, const struct FVector& Target);
	static float RadiansToDegrees(float A);
	static bool RandomBool();
	static bool RandomBoolFromStream(const struct FRandomStream& Stream);
	static bool RandomBoolWithWeight(float Weight);
	static bool RandomBoolWithWeightFromStream(float Weight, const struct FRandomStream& RandomStream);
	static float RandomFloat();
	static float RandomFloatFromStream(const struct FRandomStream& Stream);
	static float RandomFloatInRange(float Min, float Max);
	static float RandomFloatInRangeFromStream(float Min, float Max, const struct FRandomStream& Stream);
	static int32 RandomInteger(int32 Max);
	static int32 RandomIntegerFromStream(int32 Max, const struct FRandomStream& Stream);
	static int32 RandomIntegerInRange(int32 Min, int32 Max);
	static int32 RandomIntegerInRangeFromStream(int32 Min, int32 Max, const struct FRandomStream& Stream);
	static struct FVector RandomPointInBoundingBox(const struct FVector& Origin, const struct FVector& BoxExtent);
	static struct FRotator RandomRotator(bool bRoll);
	static struct FRotator RandomRotatorFromStream(bool bRoll, const struct FRandomStream& Stream);
	static struct FVector RandomUnitVector();
	static struct FVector RandomUnitVectorFromStream(const struct FRandomStream& Stream);
	static struct FVector RandomUnitVectorInCone(const struct FVector& ConeDir, float ConeHalfAngle);
	static struct FVector RandomUnitVectorInConeWithYawAndPitch(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees);
	static struct FRotator REase(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static void ResetFloatSpringState(struct FFloatSpringState& SpringState);
	static void ResetRandomStream(const struct FRandomStream& Stream);
	static void ResetVectorSpringState(struct FVectorSpringState& SpringState);
	static void RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A);
	static void RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV);
	static struct FRotator RInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed);
	static struct FRotator RInterpTo_Constant(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed);
	static struct FRotator RLerp(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath);
	static struct FVector RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis);
	static struct FRotator RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle);
	static int32 Round(float A);
	static void SeedRandomStream(struct FRandomStream& Stream);
	static class UClass* SelectClass(class UClass* A, class UClass* B, bool bSelectA);
	static struct FLinearColor SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA);
	static float SelectFloat(float A, float B, bool bPickA);
	static int32 SelectInt(int32 A, int32 B, bool bPickA);
	static class UObject* SelectObject(class UObject* A, class UObject* B, bool bSelectA);
	static struct FRotator SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA);
	static class FString SelectString(const class FString& A, const class FString& B, bool bPickA);
	static struct FTransform SelectTransform(const struct FTransform& A, const struct FTransform& B, bool bPickA);
	static struct FVector SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA);
	static void SetRandomStreamSeed(struct FRandomStream& Stream, int32 NewSeed);
	static float SignOfFloat(float A);
	static int32 SignOfInteger(int32 A);
	static float Sin(float A);
	static float Sqrt(float A);
	static float Square(float A);
	static uint8 Subtract_ByteByte(uint8 A, uint8 B);
	static struct FTimespan Subtract_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static struct FDateTime Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B);
	static float Subtract_FloatFloat(float A, float B);
	static int32 Subtract_IntInt(int32 A, int32 B);
	static struct FTimespan Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B);
	static struct FVector2D Subtract_Vector2DFloat(const struct FVector2D& A, float B);
	static struct FVector2D Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector Subtract_VectorFloat(const struct FVector& A, float B);
	static struct FVector Subtract_VectorInt(const struct FVector& A, int32 B);
	static struct FVector Subtract_VectorVector(const struct FVector& A, const struct FVector& B);
	static float Tan(float A);
	static struct FTransform TEase(const struct FTransform& A, const struct FTransform& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static bool TimespanFromString(const class FString& TimespanString, struct FTimespan* Result);
	static struct FTimespan TimespanMaxValue();
	static struct FTimespan TimespanMinValue();
	static float TimespanRatio(const struct FTimespan& A, const struct FTimespan& B);
	static struct FTimespan TimespanZeroValue();
	static struct FTransform TInterpTo(const struct FTransform& Current, const struct FTransform& Target, float DeltaTime, float InterpSpeed);
	static struct FTransform TLerp(const struct FTransform& A, const struct FTransform& B, float Alpha, ELerpInterpolationMode InterpMode);
	static struct FDateTime Today();
	static struct FVector TransformDirection(const struct FTransform& T, const struct FVector& Direction);
	static struct FVector TransformLocation(const struct FTransform& T, const struct FVector& Location);
	static struct FDateTime UtcNow();
	static struct FVector VEase(const struct FVector& A, const struct FVector& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps);
	static struct FVector2D Vector2DInterpTo(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed);
	static struct FVector2D Vector2DInterpTo_Constant(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed);
	static struct FVector VectorSpringInterp(const struct FVector& Current, const struct FVector& Target, struct FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass);
	static struct FVector VInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed);
	static struct FVector VInterpTo_Constant(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed);
	static struct FVector VLerp(const struct FVector& A, const struct FVector& B, float Alpha);
	static float VSize(const struct FVector& A);
	static float VSize2D(const struct FVector2D& A);
	static float VSize2DSquared(const struct FVector2D& A);
	static float VSizeSquared(const struct FVector& A);
	static int32 Xor_IntInt(int32 A, int32 B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetMathLibrary">();
	}
	static class UKismetMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetMathLibrary>();
	}
};
static_assert(alignof(UKismetMathLibrary) == 0x000008, "Wrong alignment on UKismetMathLibrary");
static_assert(sizeof(UKismetMathLibrary) == 0x000040, "Wrong size on UKismetMathLibrary");

// Class Engine.KismetNodeHelperLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetNodeHelperLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool BitIsMarked(int32 Data, int32 Index_0);
	static void ClearAllBits(int32* Data);
	static void ClearBit(int32* Data, int32 Index_0);
	static class FName GetEnumeratorName(const class UEnum* Enum, uint8 EnumeratorValue);
	static class FString GetEnumeratorUserFriendlyName(const class UEnum* Enum, uint8 EnumeratorValue);
	static uint8 GetEnumeratorValueFromIndex(const class UEnum* Enum, uint8 EnumeratorIndex);
	static int32 GetFirstUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits);
	static int32 GetRandomUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits);
	static int32 GetUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits, bool bRandom);
	static uint8 GetValidValue(const class UEnum* Enum, uint8 EnumeratorValue);
	static bool HasMarkedBit(int32 Data, int32 NumBits);
	static bool HasUnmarkedBit(int32 Data, int32 NumBits);
	static void MarkBit(int32* Data, int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetNodeHelperLibrary">();
	}
	static class UKismetNodeHelperLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetNodeHelperLibrary>();
	}
};
static_assert(alignof(UKismetNodeHelperLibrary) == 0x000008, "Wrong alignment on UKismetNodeHelperLibrary");
static_assert(sizeof(UKismetNodeHelperLibrary) == 0x000040, "Wrong size on UKismetNodeHelperLibrary");

// Class Engine.PrecomputedVisibilityVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APrecomputedVisibilityVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrecomputedVisibilityVolume">();
	}
	static class APrecomputedVisibilityVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrecomputedVisibilityVolume>();
	}
};
static_assert(alignof(APrecomputedVisibilityVolume) == 0x1EF72E00, "Wrong alignment on APrecomputedVisibilityVolume");
static_assert(sizeof(APrecomputedVisibilityVolume) == 0x1EF72E00, "Wrong size on APrecomputedVisibilityVolume");

// Class Engine.KismetStringLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetStringLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString BuildString_Bool(const class FString& AppendTo, const class FString& Prefix, bool InBool, const class FString& Suffix);
	static class FString BuildString_Color(const class FString& AppendTo, const class FString& Prefix, const struct FLinearColor& InColor, const class FString& Suffix);
	static class FString BuildString_Float(const class FString& AppendTo, const class FString& Prefix, float InFloat, const class FString& Suffix);
	static class FString BuildString_Int(const class FString& AppendTo, const class FString& Prefix, int32 InInt, const class FString& Suffix);
	static class FString BuildString_IntVector(const class FString& AppendTo, const class FString& Prefix, const struct FIntVector& InIntVector, const class FString& Suffix);
	static class FString BuildString_Name(const class FString& AppendTo, const class FString& Prefix, class FName InName, const class FString& Suffix);
	static class FString BuildString_Object(const class FString& AppendTo, const class FString& Prefix, class UObject* InObj, const class FString& Suffix);
	static class FString BuildString_Rotator(const class FString& AppendTo, const class FString& Prefix, const struct FRotator& InRot, const class FString& Suffix);
	static class FString BuildString_Vector(const class FString& AppendTo, const class FString& Prefix, const struct FVector& InVector, const class FString& Suffix);
	static class FString BuildString_Vector2d(const class FString& AppendTo, const class FString& Prefix, const struct FVector2D& InVector2D, const class FString& Suffix);
	static class FString Concat_StrStr(const class FString& A, const class FString& B);
	static bool Contains(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd);
	static class FString Conv_BoolToString(bool InBool);
	static class FString Conv_ByteToString(uint8 InByte);
	static class FString Conv_ColorToString(const struct FLinearColor& InColor);
	static class FString Conv_FloatToString(float InFloat);
	static class FString Conv_IntToString(int32 InInt);
	static class FString Conv_IntVectorToString(const struct FIntVector& InIntVec);
	static class FString Conv_NameToString(class FName InName);
	static class FString Conv_ObjectToString(class UObject* InObj);
	static class FString Conv_RotatorToString(const struct FRotator& InRot);
	static void Conv_StringToColor(const class FString& InString, struct FLinearColor* OutConvertedColor, bool* OutIsValid);
	static float Conv_StringToFloat(const class FString& InString);
	static int32 Conv_StringToInt(const class FString& InString);
	static class FName Conv_StringToName(const class FString& InString);
	static void Conv_StringToRotator(const class FString& InString, struct FRotator* OutConvertedRotator, bool* OutIsValid);
	static void Conv_StringToVector(const class FString& InString, struct FVector* OutConvertedVector, bool* OutIsValid);
	static void Conv_StringToVector2D(const class FString& InString, struct FVector2D* OutConvertedVector2D, bool* OutIsValid);
	static class FString Conv_TransformToString(const struct FTransform& InTrans);
	static class FString Conv_Vector2dToString(const struct FVector2D& InVec);
	static class FString Conv_VectorToString(const struct FVector& InVec);
	static int32 CullArray(const class FString& SourceString, TArray<class FString>* InArray);
	static bool EndsWith(const class FString& SourceString, const class FString& InSuffix, ESearchCase SearchCase);
	static bool EqualEqual_StriStri(const class FString& A, const class FString& B);
	static bool EqualEqual_StrStr(const class FString& A, const class FString& B);
	static int32 FindSubstring(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd, int32 StartPosition);
	static TArray<class FString> GetCharacterArrayFromString(const class FString& SourceString);
	static int32 GetCharacterAsNumber(const class FString& SourceString, int32 Index_0);
	static class FString GetSubstring(const class FString& SourceString, int32 StartIndex, int32 Length);
	static bool IsNumeric(const class FString& SourceString);
	static class FString JoinStringArray(const TArray<class FString>& SourceArray, const class FString& Separator);
	static class FString Left(const class FString& SourceString, int32 Count);
	static class FString LeftChop(const class FString& SourceString, int32 Count);
	static class FString LeftPad(const class FString& SourceString, int32 ChCount);
	static int32 Len(const class FString& S);
	static bool MatchesWildcard(const class FString& SourceString, const class FString& Wildcard, ESearchCase SearchCase);
	static class FString Mid(const class FString& SourceString, int32 Start, int32 Count);
	static bool NotEqual_StriStri(const class FString& A, const class FString& B);
	static bool NotEqual_StrStr(const class FString& A, const class FString& B);
	static TArray<class FString> ParseIntoArray(const class FString& SourceString, const class FString& Delimiter, const bool CullEmptyStrings);
	static class FString Replace(const class FString& SourceString, const class FString& From, const class FString& To, ESearchCase SearchCase);
	static int32 ReplaceInline(class FString& SourceString, const class FString& SearchText, const class FString& ReplacementText, ESearchCase SearchCase);
	static class FString Reverse(const class FString& SourceString);
	static class FString Right(const class FString& SourceString, int32 Count);
	static class FString RightChop(const class FString& SourceString, int32 Count);
	static class FString RightPad(const class FString& SourceString, int32 ChCount);
	static bool Split(const class FString& SourceString, const class FString& InStr, class FString* LeftS, class FString* RightS, ESearchCase SearchCase, ESearchDir SearchDir);
	static bool StartsWith(const class FString& SourceString, const class FString& InPrefix, ESearchCase SearchCase);
	static class FString TimeSecondsToString(float InSeconds);
	static class FString ToLower(const class FString& SourceString);
	static class FString ToUpper(const class FString& SourceString);
	static class FString Trim(const class FString& SourceString);
	static class FString TrimTrailing(const class FString& SourceString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetStringLibrary">();
	}
	static class UKismetStringLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetStringLibrary>();
	}
};
static_assert(alignof(UKismetStringLibrary) == 0x000008, "Wrong alignment on UKismetStringLibrary");
static_assert(sizeof(UKismetStringLibrary) == 0x000040, "Wrong size on UKismetStringLibrary");

// Class Engine.KismetStringTableLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetStringTableLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> GetKeysFromStringTable(const class FName TableId);
	static TArray<class FName> GetMetaDataIdsFromStringTableEntry(const class FName TableId, const class FString& Key);
	static TArray<class FName> GetRegisteredStringTables();
	static class FString GetTableEntryMetaData(const class FName TableId, const class FString& Key, const class FName MetaDataId);
	static class FString GetTableEntrySourceString(const class FName TableId, const class FString& Key);
	static class FString GetTableNamespace(const class FName TableId);
	static bool IsRegisteredTableEntry(const class FName TableId, const class FString& Key);
	static bool IsRegisteredTableId(const class FName TableId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetStringTableLibrary">();
	}
	static class UKismetStringTableLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetStringTableLibrary>();
	}
};
static_assert(alignof(UKismetStringTableLibrary) == 0x000008, "Wrong alignment on UKismetStringTableLibrary");
static_assert(sizeof(UKismetStringTableLibrary) == 0x000040, "Wrong size on UKismetStringTableLibrary");

// Class Engine.MaterialExpressionTangent
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTangent final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTangent">();
	}
	static class UMaterialExpressionTangent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTangent>();
	}
};
static_assert(alignof(UMaterialExpressionTangent) == 0x112F2730, "Wrong alignment on UMaterialExpressionTangent");
static_assert(sizeof(UMaterialExpressionTangent) == 0x112F2730, "Wrong size on UMaterialExpressionTangent");
static_assert(offsetof(UMaterialExpressionTangent, Input) == 0x000078, "Member 'UMaterialExpressionTangent::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTangent, Period) == 0x0000B0, "Member 'UMaterialExpressionTangent::Period' has a wrong offset!");

// Class Engine.KismetTextLibrary
// 0x0000 (0x0040 - 0x0040)
class UKismetTextLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText AsCurrency_Float(float Value, ERoundingMode RoundingMode, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, const class FString& CurrencyCode);
	static class FText AsCurrency_Integer(int32 Value, ERoundingMode RoundingMode, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, const class FString& CurrencyCode);
	static class FText AsCurrencyBase(int32 BaseValue, const class FString& CurrencyCode);
	static class FText AsDate_DateTime(const struct FDateTime& InDateTime);
	static class FText AsDateTime_DateTime(const struct FDateTime& In);
	static class FText AsPercent_Float(float Value, ERoundingMode RoundingMode, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits);
	static class FText AsTime_DateTime(const struct FDateTime& In);
	static class FText AsTimespan_Timespan(const struct FTimespan& InTimespan);
	static class FText AsTimeZoneDate_DateTime(const struct FDateTime& InDateTime, const class FString& InTimeZone);
	static class FText AsTimeZoneDateTime_DateTime(const struct FDateTime& InDateTime, const class FString& InTimeZone);
	static class FText AsTimeZoneTime_DateTime(const struct FDateTime& InDateTime, const class FString& InTimeZone);
	static class FText Conv_BoolToText(bool InBool);
	static class FText Conv_ByteToText(uint8 Value);
	static class FText Conv_ColorToText(const struct FLinearColor& InColor);
	static class FText Conv_FloatToText(float Value, ERoundingMode RoundingMode, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits);
	static class FText Conv_IntToText(int32 Value, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
	static class FText Conv_NameToText(class FName InName);
	static class FText Conv_ObjectToText(class UObject* InObj);
	static class FText Conv_RotatorToText(const struct FRotator& InRot);
	static class FText Conv_StringToText(const class FString& InString);
	static class FString Conv_TextToString(const class FText& InText);
	static class FText Conv_TransformToText(const struct FTransform& InTrans);
	static class FText Conv_Vector2dToText(const struct FVector2D& InVec);
	static class FText Conv_VectorToText(const struct FVector& InVec);
	static bool EqualEqual_IgnoreCase_TextText(const class FText& A, const class FText& B);
	static bool EqualEqual_TextText(const class FText& A, const class FText& B);
	static bool FindTextInLocalizationTable(const class FString& Namespace, const class FString& Key, class FText* OutText);
	static class FText Format(const class FText& InPattern, const TArray<struct FFormatArgumentData>& InArgs);
	static class FText GetEmptyText();
	static bool NotEqual_IgnoreCase_TextText(const class FText& A, const class FText& B);
	static bool NotEqual_TextText(const class FText& A, const class FText& B);
	static bool StringTableIdAndKeyFromText(const class FText& Text, class FName* OutTableId, class FString* OutKey);
	static class FText TextFromStringTable(const class FName TableId, const class FString& Key);
	static bool TextIsCultureInvariant(const class FText& InText);
	static bool TextIsEmpty(const class FText& InText);
	static bool TextIsFromStringTable(const class FText& Text);
	static bool TextIsTransient(const class FText& InText);
	static class FText TextToLower(const class FText& InText);
	static class FText TextToUpper(const class FText& InText);
	static class FText TextTrimPreceding(const class FText& InText);
	static class FText TextTrimPrecedingAndTrailing(const class FText& InText);
	static class FText TextTrimTrailing(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KismetTextLibrary">();
	}
	static class UKismetTextLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKismetTextLibrary>();
	}
};
static_assert(alignof(UKismetTextLibrary) == 0x000008, "Wrong alignment on UKismetTextLibrary");
static_assert(sizeof(UKismetTextLibrary) == 0x000040, "Wrong size on UKismetTextLibrary");

// Class Engine.SQEX_TrackItemBase
// 0x0000 (0x0040 - 0x0040)
class USQEX_TrackItemBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TrackItemBase">();
	}
	static class USQEX_TrackItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TrackItemBase>();
	}
};
static_assert(alignof(USQEX_TrackItemBase) == 0x000008, "Wrong alignment on USQEX_TrackItemBase");
static_assert(sizeof(USQEX_TrackItemBase) == 0x000040, "Wrong size on USQEX_TrackItemBase");

// Class Engine.Layer
// 0x0020 (0x0060 - 0x0040)
class ULayer final : public UObject
{
public:
	class FName                                   LayerName;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsVisible : 1;                                    // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLayerActorStats>               ActorStats;                                        // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Layer">();
	}
	static class ULayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULayer>();
	}
};
static_assert(alignof(ULayer) == 0x000008, "Wrong alignment on ULayer");
static_assert(sizeof(ULayer) == 0x000060, "Wrong size on ULayer");
static_assert(offsetof(ULayer, LayerName) == 0x000040, "Member 'ULayer::LayerName' has a wrong offset!");
static_assert(offsetof(ULayer, ActorStats) == 0x000050, "Member 'ULayer::ActorStats' has a wrong offset!");

// Class Engine.MaterialExpressionLightmapUVs
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionLightmapUVs final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLightmapUVs">();
	}
	static class UMaterialExpressionLightmapUVs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLightmapUVs>();
	}
};
static_assert(alignof(UMaterialExpressionLightmapUVs) == 0x000008, "Wrong alignment on UMaterialExpressionLightmapUVs");
static_assert(sizeof(UMaterialExpressionLightmapUVs) == 0x000078, "Wrong size on UMaterialExpressionLightmapUVs");

// Class Engine.Level
// 0x112EA8B0 (0x112EA8F0 - 0x0040)
class ULevel final : public UObject
{
public:
	uint8                                         Pad_40[0x78];                                      // 0x0040(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class TArray<class AActor*>                   Actors;                                            // 0x00B8(0x0010)(THIS IS THE ARRAY YOU'RE LOOKING FOR! [NOT AUTO-GENERATED PROPERTY])
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 OwningWorld;                                       // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModel*                                 Model;                                             // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UModelComponent*>                ModelComponents;                                   // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULevelActorContainer*                   ActorCluster;                                      // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTextureStreamingUnbuiltComponents;              // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTextureStreamingDirtyResources;                 // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelScriptActor*                      LevelScriptActor;                                  // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationObjectBase*                  NavListStart;                                      // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationObjectBase*                  NavListEnd;                                        // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNavigationDataChunk*>           NavDataChunks;                                     // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LightmapTotalSize;                                 // 0x0130(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowmapTotalSize;                                // 0x0134(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        StaticNavigableGeometry;                           // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          StreamingTextureGuids;                             // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x88];                                     // 0x0158(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLightingScenario;                               // 0x01E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LevelBuildDataId;                                  // 0x01E4(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapBuildDataRegistry*                  MapBuildData;                                      // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             LightBuildLevelOffset;                             // 0x0200(0x112EA8F0)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPad_20C_0 : 2;                                  // 0x020C(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bTextureStreamingRotationChanged : 1;              // 0x020C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsVisible : 1;                                    // 0x020C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLocked : 1;                                       // 0x020C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20D[0x103];                                    // 0x020D(0x0103)(Fixing Size After Last Property [ Dumper-7 ])
	class AWorldSettings*                         WorldSettings;                                     // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Level">();
	}
	static class ULevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevel>();
	}
};
static_assert(alignof(ULevel) == 0x112EA8F0, "Wrong alignment on ULevel");
static_assert(sizeof(ULevel) == 0x112EA8F0, "Wrong size on ULevel");
static_assert(offsetof(ULevel, Actors) == 0x0000B8, "Member 'ULevel::Actors' has a wrong offset!");
static_assert(offsetof(ULevel, OwningWorld) == 0x0000D8, "Member 'ULevel::OwningWorld' has a wrong offset!");
static_assert(offsetof(ULevel, Model) == 0x0000E0, "Member 'ULevel::Model' has a wrong offset!");
static_assert(offsetof(ULevel, ModelComponents) == 0x0000E8, "Member 'ULevel::ModelComponents' has a wrong offset!");
static_assert(offsetof(ULevel, ActorCluster) == 0x0000F8, "Member 'ULevel::ActorCluster' has a wrong offset!");
static_assert(offsetof(ULevel, NumTextureStreamingUnbuiltComponents) == 0x000100, "Member 'ULevel::NumTextureStreamingUnbuiltComponents' has a wrong offset!");
static_assert(offsetof(ULevel, NumTextureStreamingDirtyResources) == 0x000104, "Member 'ULevel::NumTextureStreamingDirtyResources' has a wrong offset!");
static_assert(offsetof(ULevel, LevelScriptActor) == 0x000108, "Member 'ULevel::LevelScriptActor' has a wrong offset!");
static_assert(offsetof(ULevel, NavListStart) == 0x000110, "Member 'ULevel::NavListStart' has a wrong offset!");
static_assert(offsetof(ULevel, NavListEnd) == 0x000118, "Member 'ULevel::NavListEnd' has a wrong offset!");
static_assert(offsetof(ULevel, NavDataChunks) == 0x000120, "Member 'ULevel::NavDataChunks' has a wrong offset!");
static_assert(offsetof(ULevel, LightmapTotalSize) == 0x000130, "Member 'ULevel::LightmapTotalSize' has a wrong offset!");
static_assert(offsetof(ULevel, ShadowmapTotalSize) == 0x000134, "Member 'ULevel::ShadowmapTotalSize' has a wrong offset!");
static_assert(offsetof(ULevel, StaticNavigableGeometry) == 0x000138, "Member 'ULevel::StaticNavigableGeometry' has a wrong offset!");
static_assert(offsetof(ULevel, StreamingTextureGuids) == 0x000148, "Member 'ULevel::StreamingTextureGuids' has a wrong offset!");
static_assert(offsetof(ULevel, bIsLightingScenario) == 0x0001E0, "Member 'ULevel::bIsLightingScenario' has a wrong offset!");
static_assert(offsetof(ULevel, LevelBuildDataId) == 0x0001E4, "Member 'ULevel::LevelBuildDataId' has a wrong offset!");
static_assert(offsetof(ULevel, MapBuildData) == 0x0001F8, "Member 'ULevel::MapBuildData' has a wrong offset!");
static_assert(offsetof(ULevel, LightBuildLevelOffset) == 0x000200, "Member 'ULevel::LightBuildLevelOffset' has a wrong offset!");
static_assert(offsetof(ULevel, WorldSettings) == 0x000310, "Member 'ULevel::WorldSettings' has a wrong offset!");
static_assert(offsetof(ULevel, AssetUserData) == 0x000320, "Member 'ULevel::AssetUserData' has a wrong offset!");

// Class Engine.SQEX_ParticleSpawnVertexDataAsset
// 0x0030 (0x0078 - 0x0048)
class USQEX_ParticleSpawnVertexDataAsset final : public UDataAsset
{
public:
	class UObject*                                OriginalMesh;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsPositonData : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsNormalData : 1;                                 // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsColorData : 1;                                  // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DataNumber;                                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_ParticleSpawnVertexData>  SpawnVertexList;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SpawnVertexIndexList;                              // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_ParticleSpawnVertexDataAsset">();
	}
	static class USQEX_ParticleSpawnVertexDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_ParticleSpawnVertexDataAsset>();
	}
};
static_assert(alignof(USQEX_ParticleSpawnVertexDataAsset) == 0x000008, "Wrong alignment on USQEX_ParticleSpawnVertexDataAsset");
static_assert(sizeof(USQEX_ParticleSpawnVertexDataAsset) == 0x000078, "Wrong size on USQEX_ParticleSpawnVertexDataAsset");
static_assert(offsetof(USQEX_ParticleSpawnVertexDataAsset, OriginalMesh) == 0x000048, "Member 'USQEX_ParticleSpawnVertexDataAsset::OriginalMesh' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleSpawnVertexDataAsset, DataNumber) == 0x000054, "Member 'USQEX_ParticleSpawnVertexDataAsset::DataNumber' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleSpawnVertexDataAsset, SpawnVertexList) == 0x000058, "Member 'USQEX_ParticleSpawnVertexDataAsset::SpawnVertexList' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleSpawnVertexDataAsset, SpawnVertexIndexList) == 0x000068, "Member 'USQEX_ParticleSpawnVertexDataAsset::SpawnVertexIndexList' has a wrong offset!");

// Class Engine.LevelActorContainer
// 0x0010 (0x0050 - 0x0040)
class ULevelActorContainer final : public UObject
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelActorContainer">();
	}
	static class ULevelActorContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelActorContainer>();
	}
};
static_assert(alignof(ULevelActorContainer) == 0x000008, "Wrong alignment on ULevelActorContainer");
static_assert(sizeof(ULevelActorContainer) == 0x000050, "Wrong size on ULevelActorContainer");
static_assert(offsetof(ULevelActorContainer, Actors) == 0x000040, "Member 'ULevelActorContainer::Actors' has a wrong offset!");

// Class Engine.MaterialExpressionDecalLifetimeOpacity
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionDecalLifetimeOpacity final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDecalLifetimeOpacity">();
	}
	static class UMaterialExpressionDecalLifetimeOpacity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDecalLifetimeOpacity>();
	}
};
static_assert(alignof(UMaterialExpressionDecalLifetimeOpacity) == 0x000008, "Wrong alignment on UMaterialExpressionDecalLifetimeOpacity");
static_assert(sizeof(UMaterialExpressionDecalLifetimeOpacity) == 0x000078, "Wrong size on UMaterialExpressionDecalLifetimeOpacity");

// Class Engine.LevelBounds
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ALevelBounds final : public AActor
{
public:
	bool                                          bAutoUpdateBounds;                                 // 0x03E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelBounds">();
	}
	static class ALevelBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelBounds>();
	}
};
static_assert(alignof(ALevelBounds) == 0x1EF72E00, "Wrong alignment on ALevelBounds");
static_assert(sizeof(ALevelBounds) == 0x1EF72E00, "Wrong size on ALevelBounds");
static_assert(offsetof(ALevelBounds, bAutoUpdateBounds) == 0x0003E0, "Member 'ALevelBounds::bAutoUpdateBounds' has a wrong offset!");

// Class Engine.TouchInterface
// 0x0030 (0x0070 - 0x0040)
class UTouchInterface final : public UObject
{
public:
	TArray<struct FTouchInputControl>             Controls;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActiveOpacity;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InactiveOpacity;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilDeactive;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilReset;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationDelay;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventRecenter;                                  // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartupDelay;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TouchInterface">();
	}
	static class UTouchInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTouchInterface>();
	}
};
static_assert(alignof(UTouchInterface) == 0x000008, "Wrong alignment on UTouchInterface");
static_assert(sizeof(UTouchInterface) == 0x000070, "Wrong size on UTouchInterface");
static_assert(offsetof(UTouchInterface, Controls) == 0x000040, "Member 'UTouchInterface::Controls' has a wrong offset!");
static_assert(offsetof(UTouchInterface, ActiveOpacity) == 0x000050, "Member 'UTouchInterface::ActiveOpacity' has a wrong offset!");
static_assert(offsetof(UTouchInterface, InactiveOpacity) == 0x000054, "Member 'UTouchInterface::InactiveOpacity' has a wrong offset!");
static_assert(offsetof(UTouchInterface, TimeUntilDeactive) == 0x000058, "Member 'UTouchInterface::TimeUntilDeactive' has a wrong offset!");
static_assert(offsetof(UTouchInterface, TimeUntilReset) == 0x00005C, "Member 'UTouchInterface::TimeUntilReset' has a wrong offset!");
static_assert(offsetof(UTouchInterface, ActivationDelay) == 0x000060, "Member 'UTouchInterface::ActivationDelay' has a wrong offset!");
static_assert(offsetof(UTouchInterface, bPreventRecenter) == 0x000064, "Member 'UTouchInterface::bPreventRecenter' has a wrong offset!");
static_assert(offsetof(UTouchInterface, StartupDelay) == 0x000068, "Member 'UTouchInterface::StartupDelay' has a wrong offset!");

// Class Engine.LevelScriptBlueprint
// 0x0000 (0x112E8D20 - 0x112E8D20)
class ULevelScriptBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelScriptBlueprint">();
	}
	static class ULevelScriptBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelScriptBlueprint>();
	}
};
static_assert(alignof(ULevelScriptBlueprint) == 0x112E8D20, "Wrong alignment on ULevelScriptBlueprint");
static_assert(sizeof(ULevelScriptBlueprint) == 0x112E8D20, "Wrong size on ULevelScriptBlueprint");

// Class Engine.LevelStreamingAlwaysLoaded
// 0x0000 (0x112EAE80 - 0x112EAE80)
class ULevelStreamingAlwaysLoaded final : public ULevelStreaming
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingAlwaysLoaded">();
	}
	static class ULevelStreamingAlwaysLoaded* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingAlwaysLoaded>();
	}
};
static_assert(alignof(ULevelStreamingAlwaysLoaded) == 0x112EAE80, "Wrong alignment on ULevelStreamingAlwaysLoaded");
static_assert(sizeof(ULevelStreamingAlwaysLoaded) == 0x112EAE80, "Wrong size on ULevelStreamingAlwaysLoaded");

// Class Engine.LevelStreamingKismet
// 0x0000 (0x112EAE80 - 0x112EAE80)
class ULevelStreamingKismet final : public ULevelStreaming
{
public:
	uint8                                         bInitiallyLoaded : 1;                              // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitiallyVisible : 1;                             // 0x0168(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULevelStreamingKismet* LoadLevelInstance(class UObject* WorldContextObject, const class FString& LevelName, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingKismet">();
	}
	static class ULevelStreamingKismet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingKismet>();
	}
};
static_assert(alignof(ULevelStreamingKismet) == 0x112EAE80, "Wrong alignment on ULevelStreamingKismet");
static_assert(sizeof(ULevelStreamingKismet) == 0x112EAE80, "Wrong size on ULevelStreamingKismet");

// Class Engine.MaterialExpressionBumpOffset
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionBumpOffset final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinate;                                        // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Height;                                            // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       HeightRatioInput;                                  // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         HeightRatio;                                       // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferencePlane;                                    // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ConstCoordinate;                                   // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBumpOffset">();
	}
	static class UMaterialExpressionBumpOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBumpOffset>();
	}
};
static_assert(alignof(UMaterialExpressionBumpOffset) == 0x112F2730, "Wrong alignment on UMaterialExpressionBumpOffset");
static_assert(sizeof(UMaterialExpressionBumpOffset) == 0x112F2730, "Wrong size on UMaterialExpressionBumpOffset");
static_assert(offsetof(UMaterialExpressionBumpOffset, Coordinate) == 0x000078, "Member 'UMaterialExpressionBumpOffset::Coordinate' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBumpOffset, Height) == 0x0000B0, "Member 'UMaterialExpressionBumpOffset::Height' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBumpOffset, HeightRatioInput) == 0x0000E8, "Member 'UMaterialExpressionBumpOffset::HeightRatioInput' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBumpOffset, HeightRatio) == 0x000120, "Member 'UMaterialExpressionBumpOffset::HeightRatio' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBumpOffset, ReferencePlane) == 0x000124, "Member 'UMaterialExpressionBumpOffset::ReferencePlane' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBumpOffset, ConstCoordinate) == 0x000128, "Member 'UMaterialExpressionBumpOffset::ConstCoordinate' has a wrong offset!");

// Class Engine.LevelStreamingPersistent
// 0x0000 (0x112EAE80 - 0x112EAE80)
class ULevelStreamingPersistent final : public ULevelStreaming
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingPersistent">();
	}
	static class ULevelStreamingPersistent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelStreamingPersistent>();
	}
};
static_assert(alignof(ULevelStreamingPersistent) == 0x112EAE80, "Wrong alignment on ULevelStreamingPersistent");
static_assert(sizeof(ULevelStreamingPersistent) == 0x112EAE80, "Wrong size on ULevelStreamingPersistent");

// Class Engine.Material
// 0x112F3C18 (0x112F3CA0 - 0x0088)
class UMaterial final : public UMaterialInterface
{
public:
	class UPhysicalMaterial*                      PhysMaterial;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColorMaterialInput                    DiffuseColor;                                      // 0x0090(0x112F31B0)(Deprecated, NativeAccessSpecifierPublic)
	struct FColorMaterialInput                    SpecularColor;                                     // 0x00D0(0x112F31B0)(Deprecated, NativeAccessSpecifierPublic)
	struct FColorMaterialInput                    BaseColor;                                         // 0x0110(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FColorMaterialInput                    SQEXDarkColor;                                     // 0x0150(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   SqexLightAttenuation;                              // 0x0190(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   Metallic;                                          // 0x01D0(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   Specular;                                          // 0x0210(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   Roughness;                                         // 0x0250(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FVectorMaterialInput                   Normal;                                            // 0x0290(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FColorMaterialInput                    EmissiveColor;                                     // 0x02D8(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   Opacity;                                           // 0x0318(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   OpacityMask;                                       // 0x0358(0x112F38D0)(NativeAccessSpecifierPublic)
	EMaterialDomain                               MaterialDomain;                                    // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0399(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDecalBlendMode                               DecalBlendMode;                                    // 0x039A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialDecalResponse                        MaterialDecalResponse;                             // 0x039B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialShadingModel                         ShadingModel;                                      // 0x039C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESQEXMaterialDiscernment                      SQEXDiscernment;                                   // 0x039D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39E[0x2];                                      // 0x039E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpacityMaskClipValue;                              // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorMaterialInput                   WorldPositionOffset;                               // 0x03A8(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FVectorMaterialInput                   WorldDisplacement;                                 // 0x03F0(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   TessellationMultiplier;                            // 0x0438(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FColorMaterialInput                    SubsurfaceColor;                                   // 0x0478(0x112F31B0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   ClearCoat;                                         // 0x04B8(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   ClearCoatRoughness;                                // 0x04F8(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   AmbientOcclusion;                                  // 0x0538(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   Refraction;                                        // 0x0578(0x112F38D0)(NativeAccessSpecifierPublic)
	struct FVector2MaterialInput                  CustomizedUVs[0x8];                                // 0x05B8(0x112F3CA0)(NativeAccessSpecifierPublic)
	uint8                                         Pad_-76861548[0x76861D40];                         // 0x-76861548(0x76861D40)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaterialAttributesInput               MaterialAttributes;                                // 0x07F8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FScalarMaterialInput                   PixelDepthOffset;                                  // 0x0838(0x112F38D0)(NativeAccessSpecifierPublic)
	uint8                                         bEnableSeparateTranslucency : 1;                   // 0x0878(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableMobileSeparateTranslucency : 1;             // 0x0878(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bPseudoVolume : 1;                            // 0x0878(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_878_3 : 5;                                  // 0x0878(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_879[0x7];                                      // 0x0879(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bProceduralCloud : 1;                              // 0x0880(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpscaleVolume : 1;                                // 0x0880(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_881[0x3];                                      // 0x0881(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SQEX_nShaderDebugLevel;                            // 0x0884(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEX_boEnableWaveCompiler : 1;                     // 0x0888(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bBackFaceOnly : 1;                            // 0x0888(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bSubtractiveMeshDecal : 1;                    // 0x0888(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bForceSynchronousShaderCompilation : 1;       // 0x0888(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableResponsiveAA : 1;                           // 0x0888(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScreenSpaceReflections : 1;                       // 0x0888(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         TwoSided : 1;                                      // 0x0888(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DitheredLODTransition : 1;                         // 0x0888(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DitherOpacityMask : 1;                             // 0x0889(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowNegativeEmissiveColor : 1;                   // 0x0889(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_88A[0x2];                                      // 0x088A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumCustomizedUVs;                                  // 0x088C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETranslucencyLightingMode                     TranslucencyLightingMode;                          // 0x0890(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_891[0x3];                                      // 0x0891(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslucencyDirectionalLightingIntensity;          // 0x0894(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AllowTranslucentCustomDepthWrites : 1;             // 0x0898(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_899[0x3];                                      // 0x0899(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslucentShadowDensityScale;                     // 0x089C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentSelfShadowDensityScale;                 // 0x08A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentSelfShadowSecondDensityScale;           // 0x08A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentSelfShadowSecondOpacity;                // 0x08A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentBackscatteringExponent;                 // 0x08AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TranslucentMultipleScatteringExtinction;           // 0x08B0(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentShadowStartOffset;                      // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableDepthTest : 1;                             // 0x08C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateSphericalParticleNormals : 1;             // 0x08C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableKHSubSurface : 1;                        // 0x08C4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableKHStoSCBlend : 1;                        // 0x08C4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableDiffusion : 1;                           // 0x08C4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableDecalZFadeManual : 1;                    // 0x08C4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8C5[0x3];                                      // 0x08C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SQEXDecalZFadeSegment;                             // 0x08C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SQEXDecalZFadePow;                                 // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEXEnableDecalWorldTangent : 1;                   // 0x08D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableEmissiveRevEyeAdaptation : 1;            // 0x08D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableForceNoRecieveChara : 1;                 // 0x08D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableReZ : 1;                                 // 0x08D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableForceMaskedClip : 1;                     // 0x08D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXEnableEmissiveMasterLightCoefficient : 1;      // 0x08D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXUseBackupSceneColorWithTranslucent : 1;        // 0x08D0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXDisableShadowMask : 1;                         // 0x08D0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXTranslucentSliceCapturing : 1;                 // 0x08D1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXUseTranslucentSliceCapture : 1;                // 0x08D1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTangentSpaceNormal : 1;                           // 0x08D1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEmissiveForDynamicAreaLighting : 1;            // 0x08D1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockGI : 1;                                      // 0x08D1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedAsSpecialEngineMaterial : 1;                  // 0x08D1(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithSkeletalMesh : 1;                         // 0x08D1(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithEditorCompositing : 1;                    // 0x08D1(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithParticleSprites : 1;                      // 0x08D2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithBeamTrails : 1;                           // 0x08D2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithMeshParticles : 1;                        // 0x08D2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithNiagaraSprites : 1;                       // 0x08D2(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithNiagaraRibbons : 1;                       // 0x08D2(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithNiagaraMeshParticles : 1;                 // 0x08D2(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithStaticLighting : 1;                       // 0x08D2(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithMorphTargets : 1;                         // 0x08D2(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithSplineMeshes : 1;                         // 0x08D3(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithInstancedStaticMeshes : 1;                // 0x08D3(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsesDistortion : 1;                               // 0x08D3(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithClothing : 1;                             // 0x08D3(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEXUsedWithAccurateNormals : 1;                   // 0x08D3(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsedWithUI : 1;                                   // 0x08D3(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXUsedWith2DFluid : 1;                          // 0x08D3(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXUsedWithVoxelMesh : 1;                        // 0x08D3(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXUsedWithGPUParticleMesh : 1;                  // 0x08D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXUsedWithNonOccluder : 1;                      // 0x08D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutomaticallySetUsageInEditor : 1;                // 0x08D4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFullyRough : 1;                                   // 0x08D4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFullPrecision : 1;                             // 0x08D4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLightmapDirectionality : 1;                    // 0x08D4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHQForwardReflections : 1;                      // 0x08D4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePlanarForwardReflections : 1;                  // 0x08D4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNormalCurvatureToRoughness : 1;                   // 0x08D5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D6[0x2];                                      // 0x08D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EMaterialTessellationMode                     D3D11TessellationMode;                             // 0x08D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D9[0x3];                                      // 0x08D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableCrackFreeDisplacement : 1;                  // 0x08DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableAdaptiveTessellation : 1;                   // 0x08DC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8DD[0x3];                                      // 0x08DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDisplacement;                                   // 0x08E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Wireframe : 1;                                     // 0x08E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOutputVelocityOnBasePass : 1;                     // 0x08E4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8E5[0x3];                                      // 0x08E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EditorX;                                           // 0x08E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EditorY;                                           // 0x08EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EditorPitch;                                       // 0x08F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EditorYaw;                                         // 0x08F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialExpression*>            Expressions;                                       // 0x08F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaterialFunctionInfo>          MaterialFunctionInfos;                             // 0x0908(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMaterialParameterCollectionInfo> MaterialParameterCollectionInfos;                  // 0x0918(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bCanMaskedBeAssumedOpaque : 1;                     // 0x0928(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMasked : 1;                                     // 0x0928(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPreviewMaterial : 1;                            // 0x0928(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMaterialAttributes : 1;                        // 0x0928(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTranslucencyVertexFog : 1;                     // 0x0928(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bComputeFogPerPixel : 1;                           // 0x0928(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDevelopmentShaderCompile : 1;                // 0x0928(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMaterialEditorStatsMaterial : 1;                // 0x0928(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_929[0x3];                                      // 0x0929(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        UsageFlagWarnings;                                 // 0x092C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendableLocation                            BlendableLocation;                                 // 0x0930(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_931[0x3];                                      // 0x0931(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlendablePriority;                                 // 0x0934(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlendableOutputAlpha;                              // 0x0938(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERefractionMode                               RefractionMode;                                    // 0x0939(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93A[0x2];                                      // 0x093A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefractionDepthBias;                               // 0x093C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  StateID;                                           // 0x0940(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture*>                       ExpressionTextureReferences;                       // 0x0A30(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A40[0xC0];                                     // 0x0A40(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Material">();
	}
	static class UMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterial>();
	}
};
static_assert(alignof(UMaterial) == 0x112F3CA0, "Wrong alignment on UMaterial");
static_assert(sizeof(UMaterial) == 0x112F3CA0, "Wrong size on UMaterial");
static_assert(offsetof(UMaterial, PhysMaterial) == 0x000088, "Member 'UMaterial::PhysMaterial' has a wrong offset!");
static_assert(offsetof(UMaterial, DiffuseColor) == 0x000090, "Member 'UMaterial::DiffuseColor' has a wrong offset!");
static_assert(offsetof(UMaterial, SpecularColor) == 0x0000D0, "Member 'UMaterial::SpecularColor' has a wrong offset!");
static_assert(offsetof(UMaterial, BaseColor) == 0x000110, "Member 'UMaterial::BaseColor' has a wrong offset!");
static_assert(offsetof(UMaterial, SQEXDarkColor) == 0x000150, "Member 'UMaterial::SQEXDarkColor' has a wrong offset!");
static_assert(offsetof(UMaterial, SqexLightAttenuation) == 0x000190, "Member 'UMaterial::SqexLightAttenuation' has a wrong offset!");
static_assert(offsetof(UMaterial, Metallic) == 0x0001D0, "Member 'UMaterial::Metallic' has a wrong offset!");
static_assert(offsetof(UMaterial, Specular) == 0x000210, "Member 'UMaterial::Specular' has a wrong offset!");
static_assert(offsetof(UMaterial, Roughness) == 0x000250, "Member 'UMaterial::Roughness' has a wrong offset!");
static_assert(offsetof(UMaterial, Normal) == 0x000290, "Member 'UMaterial::Normal' has a wrong offset!");
static_assert(offsetof(UMaterial, EmissiveColor) == 0x0002D8, "Member 'UMaterial::EmissiveColor' has a wrong offset!");
static_assert(offsetof(UMaterial, Opacity) == 0x000318, "Member 'UMaterial::Opacity' has a wrong offset!");
static_assert(offsetof(UMaterial, OpacityMask) == 0x000358, "Member 'UMaterial::OpacityMask' has a wrong offset!");
static_assert(offsetof(UMaterial, MaterialDomain) == 0x000398, "Member 'UMaterial::MaterialDomain' has a wrong offset!");
static_assert(offsetof(UMaterial, BlendMode) == 0x000399, "Member 'UMaterial::BlendMode' has a wrong offset!");
static_assert(offsetof(UMaterial, DecalBlendMode) == 0x00039A, "Member 'UMaterial::DecalBlendMode' has a wrong offset!");
static_assert(offsetof(UMaterial, MaterialDecalResponse) == 0x00039B, "Member 'UMaterial::MaterialDecalResponse' has a wrong offset!");
static_assert(offsetof(UMaterial, ShadingModel) == 0x00039C, "Member 'UMaterial::ShadingModel' has a wrong offset!");
static_assert(offsetof(UMaterial, SQEXDiscernment) == 0x00039D, "Member 'UMaterial::SQEXDiscernment' has a wrong offset!");
static_assert(offsetof(UMaterial, OpacityMaskClipValue) == 0x0003A0, "Member 'UMaterial::OpacityMaskClipValue' has a wrong offset!");
static_assert(offsetof(UMaterial, WorldPositionOffset) == 0x0003A8, "Member 'UMaterial::WorldPositionOffset' has a wrong offset!");
static_assert(offsetof(UMaterial, WorldDisplacement) == 0x0003F0, "Member 'UMaterial::WorldDisplacement' has a wrong offset!");
static_assert(offsetof(UMaterial, TessellationMultiplier) == 0x000438, "Member 'UMaterial::TessellationMultiplier' has a wrong offset!");
static_assert(offsetof(UMaterial, SubsurfaceColor) == 0x000478, "Member 'UMaterial::SubsurfaceColor' has a wrong offset!");
static_assert(offsetof(UMaterial, ClearCoat) == 0x0004B8, "Member 'UMaterial::ClearCoat' has a wrong offset!");
static_assert(offsetof(UMaterial, ClearCoatRoughness) == 0x0004F8, "Member 'UMaterial::ClearCoatRoughness' has a wrong offset!");
static_assert(offsetof(UMaterial, AmbientOcclusion) == 0x000538, "Member 'UMaterial::AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(UMaterial, Refraction) == 0x000578, "Member 'UMaterial::Refraction' has a wrong offset!");
static_assert(offsetof(UMaterial, CustomizedUVs) == 0x0005B8, "Member 'UMaterial::CustomizedUVs' has a wrong offset!");
static_assert(offsetof(UMaterial, MaterialAttributes) == 0x0007F8, "Member 'UMaterial::MaterialAttributes' has a wrong offset!");
static_assert(offsetof(UMaterial, PixelDepthOffset) == 0x000838, "Member 'UMaterial::PixelDepthOffset' has a wrong offset!");
static_assert(offsetof(UMaterial, SQEX_nShaderDebugLevel) == 0x000884, "Member 'UMaterial::SQEX_nShaderDebugLevel' has a wrong offset!");
static_assert(offsetof(UMaterial, NumCustomizedUVs) == 0x00088C, "Member 'UMaterial::NumCustomizedUVs' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucencyLightingMode) == 0x000890, "Member 'UMaterial::TranslucencyLightingMode' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucencyDirectionalLightingIntensity) == 0x000894, "Member 'UMaterial::TranslucencyDirectionalLightingIntensity' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentShadowDensityScale) == 0x00089C, "Member 'UMaterial::TranslucentShadowDensityScale' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentSelfShadowDensityScale) == 0x0008A0, "Member 'UMaterial::TranslucentSelfShadowDensityScale' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentSelfShadowSecondDensityScale) == 0x0008A4, "Member 'UMaterial::TranslucentSelfShadowSecondDensityScale' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentSelfShadowSecondOpacity) == 0x0008A8, "Member 'UMaterial::TranslucentSelfShadowSecondOpacity' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentBackscatteringExponent) == 0x0008AC, "Member 'UMaterial::TranslucentBackscatteringExponent' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentMultipleScatteringExtinction) == 0x0008B0, "Member 'UMaterial::TranslucentMultipleScatteringExtinction' has a wrong offset!");
static_assert(offsetof(UMaterial, TranslucentShadowStartOffset) == 0x0008C0, "Member 'UMaterial::TranslucentShadowStartOffset' has a wrong offset!");
static_assert(offsetof(UMaterial, SQEXDecalZFadeSegment) == 0x0008C8, "Member 'UMaterial::SQEXDecalZFadeSegment' has a wrong offset!");
static_assert(offsetof(UMaterial, SQEXDecalZFadePow) == 0x0008CC, "Member 'UMaterial::SQEXDecalZFadePow' has a wrong offset!");
static_assert(offsetof(UMaterial, D3D11TessellationMode) == 0x0008D8, "Member 'UMaterial::D3D11TessellationMode' has a wrong offset!");
static_assert(offsetof(UMaterial, MaxDisplacement) == 0x0008E0, "Member 'UMaterial::MaxDisplacement' has a wrong offset!");
static_assert(offsetof(UMaterial, EditorX) == 0x0008E8, "Member 'UMaterial::EditorX' has a wrong offset!");
static_assert(offsetof(UMaterial, EditorY) == 0x0008EC, "Member 'UMaterial::EditorY' has a wrong offset!");
static_assert(offsetof(UMaterial, EditorPitch) == 0x0008F0, "Member 'UMaterial::EditorPitch' has a wrong offset!");
static_assert(offsetof(UMaterial, EditorYaw) == 0x0008F4, "Member 'UMaterial::EditorYaw' has a wrong offset!");
static_assert(offsetof(UMaterial, Expressions) == 0x0008F8, "Member 'UMaterial::Expressions' has a wrong offset!");
static_assert(offsetof(UMaterial, MaterialFunctionInfos) == 0x000908, "Member 'UMaterial::MaterialFunctionInfos' has a wrong offset!");
static_assert(offsetof(UMaterial, MaterialParameterCollectionInfos) == 0x000918, "Member 'UMaterial::MaterialParameterCollectionInfos' has a wrong offset!");
static_assert(offsetof(UMaterial, UsageFlagWarnings) == 0x00092C, "Member 'UMaterial::UsageFlagWarnings' has a wrong offset!");
static_assert(offsetof(UMaterial, BlendableLocation) == 0x000930, "Member 'UMaterial::BlendableLocation' has a wrong offset!");
static_assert(offsetof(UMaterial, BlendablePriority) == 0x000934, "Member 'UMaterial::BlendablePriority' has a wrong offset!");
static_assert(offsetof(UMaterial, BlendableOutputAlpha) == 0x000938, "Member 'UMaterial::BlendableOutputAlpha' has a wrong offset!");
static_assert(offsetof(UMaterial, RefractionMode) == 0x000939, "Member 'UMaterial::RefractionMode' has a wrong offset!");
static_assert(offsetof(UMaterial, RefractionDepthBias) == 0x00093C, "Member 'UMaterial::RefractionDepthBias' has a wrong offset!");
static_assert(offsetof(UMaterial, StateID) == 0x000940, "Member 'UMaterial::StateID' has a wrong offset!");
static_assert(offsetof(UMaterial, ExpressionTextureReferences) == 0x000A30, "Member 'UMaterial::ExpressionTextureReferences' has a wrong offset!");

// Class Engine.LevelStreamingVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ALevelStreamingVolume final : public AVolume
{
public:
	TArray<class FName>                           StreamingLevelNames;                               // 0x0420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         bEditorPreVisOnly : 1;                             // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisabled : 1;                                     // 0x0430(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EStreamingVolumeUsage                         StreamingUsage;                                    // 0x0434(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelStreamingVolume">();
	}
	static class ALevelStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelStreamingVolume>();
	}
};
static_assert(alignof(ALevelStreamingVolume) == 0x1EF72E00, "Wrong alignment on ALevelStreamingVolume");
static_assert(sizeof(ALevelStreamingVolume) == 0x1EF72E00, "Wrong size on ALevelStreamingVolume");
static_assert(offsetof(ALevelStreamingVolume, StreamingLevelNames) == 0x000420, "Member 'ALevelStreamingVolume::StreamingLevelNames' has a wrong offset!");
static_assert(offsetof(ALevelStreamingVolume, StreamingUsage) == 0x000434, "Member 'ALevelStreamingVolume::StreamingUsage' has a wrong offset!");

// Class Engine.LightmappedSurfaceCollection
// 0x0018 (0x0058 - 0x0040)
class ULightmappedSurfaceCollection final : public UObject
{
public:
	class UModel*                                 SourceModel;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Surfaces;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightmappedSurfaceCollection">();
	}
	static class ULightmappedSurfaceCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightmappedSurfaceCollection>();
	}
};
static_assert(alignof(ULightmappedSurfaceCollection) == 0x000008, "Wrong alignment on ULightmappedSurfaceCollection");
static_assert(sizeof(ULightmappedSurfaceCollection) == 0x000058, "Wrong size on ULightmappedSurfaceCollection");
static_assert(offsetof(ULightmappedSurfaceCollection, SourceModel) == 0x000040, "Member 'ULightmappedSurfaceCollection::SourceModel' has a wrong offset!");
static_assert(offsetof(ULightmappedSurfaceCollection, Surfaces) == 0x000048, "Member 'ULightmappedSurfaceCollection::Surfaces' has a wrong offset!");

// Class Engine.SlateTextureAtlasInterface
// 0x0000 (0x0040 - 0x0040)
class ISlateTextureAtlasInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlateTextureAtlasInterface">();
	}
	static class ISlateTextureAtlasInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISlateTextureAtlasInterface>();
	}
};
static_assert(alignof(ISlateTextureAtlasInterface) == 0x000008, "Wrong alignment on ISlateTextureAtlasInterface");
static_assert(sizeof(ISlateTextureAtlasInterface) == 0x000040, "Wrong size on ISlateTextureAtlasInterface");

// Class Engine.MaterialExpressionGIReplace
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionGIReplace final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Default;                                           // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       StaticIndirect;                                    // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       DynamicIndirect;                                   // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionGIReplace">();
	}
	static class UMaterialExpressionGIReplace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionGIReplace>();
	}
};
static_assert(alignof(UMaterialExpressionGIReplace) == 0x112F2730, "Wrong alignment on UMaterialExpressionGIReplace");
static_assert(sizeof(UMaterialExpressionGIReplace) == 0x112F2730, "Wrong size on UMaterialExpressionGIReplace");
static_assert(offsetof(UMaterialExpressionGIReplace, Default) == 0x000078, "Member 'UMaterialExpressionGIReplace::Default' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionGIReplace, StaticIndirect) == 0x0000B0, "Member 'UMaterialExpressionGIReplace::StaticIndirect' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionGIReplace, DynamicIndirect) == 0x0000E8, "Member 'UMaterialExpressionGIReplace::DynamicIndirect' has a wrong offset!");

// Class Engine.Texture2D
// 0x1A00 (0x112EA720 - 0x112E8D20)
#pragma pack(push, 0x1)
class alignas(0x112EA720) UTexture2D : public UTexture
{
public:
	int32                                         RequestedMips;                                     // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResidentMips;                                      // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StreamingIndex;                                    // 0x0100(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelIndex;                                        // 0x0104(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstResourceMemMip;                               // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ImportedSize;                                      // 0x010C(0x112EA720)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        ForceMipLevelsToBeResidentTimestamp;               // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bTemporarilyDisableStreaming : 1;                  // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsStreamable : 1;                                 // 0x0120(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasStreamingUpdatePending : 1;                    // 0x0120(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasCancelationPending : 1;                        // 0x0120(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceMiplevelsToBeResident : 1;                   // 0x0120(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreStreamingMipBias : 1;                       // 0x0120(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGlobalForceMipLevelsToBeResident : 1;             // 0x0120(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_PumpedMipMap;                                    // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PumpedMipMapMax;                                 // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_ResidentLevel                           M_ResidentLevel;                                   // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ResidentRequests;                                // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureAddress                               AddressX;                                          // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureAddress                               AddressY;                                          // 0x0135(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136[0x1A];                                     // 0x0136(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 Blueprint_GetSizeX() const;
	int32 Blueprint_GetSizeY() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Texture2D">();
	}
	static class UTexture2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTexture2D>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTexture2D) == 0x112EA720, "Wrong alignment on UTexture2D");
static_assert(sizeof(UTexture2D) == 0x112EA720, "Wrong size on UTexture2D");
static_assert(offsetof(UTexture2D, RequestedMips) == 0x0000F8, "Member 'UTexture2D::RequestedMips' has a wrong offset!");
static_assert(offsetof(UTexture2D, ResidentMips) == 0x0000FC, "Member 'UTexture2D::ResidentMips' has a wrong offset!");
static_assert(offsetof(UTexture2D, StreamingIndex) == 0x000100, "Member 'UTexture2D::StreamingIndex' has a wrong offset!");
static_assert(offsetof(UTexture2D, LevelIndex) == 0x000104, "Member 'UTexture2D::LevelIndex' has a wrong offset!");
static_assert(offsetof(UTexture2D, FirstResourceMemMip) == 0x000108, "Member 'UTexture2D::FirstResourceMemMip' has a wrong offset!");
static_assert(offsetof(UTexture2D, ImportedSize) == 0x00010C, "Member 'UTexture2D::ImportedSize' has a wrong offset!");
static_assert(offsetof(UTexture2D, ForceMipLevelsToBeResidentTimestamp) == 0x000118, "Member 'UTexture2D::ForceMipLevelsToBeResidentTimestamp' has a wrong offset!");
static_assert(offsetof(UTexture2D, M_PumpedMipMap) == 0x000124, "Member 'UTexture2D::M_PumpedMipMap' has a wrong offset!");
static_assert(offsetof(UTexture2D, M_PumpedMipMapMax) == 0x000128, "Member 'UTexture2D::M_PumpedMipMapMax' has a wrong offset!");
static_assert(offsetof(UTexture2D, M_ResidentLevel) == 0x00012C, "Member 'UTexture2D::M_ResidentLevel' has a wrong offset!");
static_assert(offsetof(UTexture2D, M_ResidentRequests) == 0x000130, "Member 'UTexture2D::M_ResidentRequests' has a wrong offset!");
static_assert(offsetof(UTexture2D, AddressX) == 0x000134, "Member 'UTexture2D::AddressX' has a wrong offset!");
static_assert(offsetof(UTexture2D, AddressY) == 0x000135, "Member 'UTexture2D::AddressY' has a wrong offset!");

// Class Engine.RVOAvoidanceInterface
// 0x0000 (0x0040 - 0x0040)
class IRVOAvoidanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RVOAvoidanceInterface">();
	}
	static class IRVOAvoidanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRVOAvoidanceInterface>();
	}
};
static_assert(alignof(IRVOAvoidanceInterface) == 0x000008, "Wrong alignment on IRVOAvoidanceInterface");
static_assert(sizeof(IRVOAvoidanceInterface) == 0x000040, "Wrong size on IRVOAvoidanceInterface");

// Class Engine.LightMapTexture2D
// 0x0000 (0x112EA720 - 0x112EA720)
class ULightMapTexture2D final : public UTexture2D
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightMapTexture2D">();
	}
	static class ULightMapTexture2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightMapTexture2D>();
	}
};
static_assert(alignof(ULightMapTexture2D) == 0x112EA720, "Wrong alignment on ULightMapTexture2D");
static_assert(sizeof(ULightMapTexture2D) == 0x112EA720, "Wrong size on ULightMapTexture2D");

// Class Engine.LightmassImportanceVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ALightmassImportanceVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightmassImportanceVolume">();
	}
	static class ALightmassImportanceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightmassImportanceVolume>();
	}
};
static_assert(alignof(ALightmassImportanceVolume) == 0x1EF72E00, "Wrong alignment on ALightmassImportanceVolume");
static_assert(sizeof(ALightmassImportanceVolume) == 0x1EF72E00, "Wrong size on ALightmassImportanceVolume");

// Class Engine.LightmassPortalComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class ULightmassPortalComponent final : public USceneComponent
{
public:
	class UBoxComponent*                          PreviewBox;                                        // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightmassPortalComponent">();
	}
	static class ULightmassPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightmassPortalComponent>();
	}
};
static_assert(alignof(ULightmassPortalComponent) == 0x112E9AF0, "Wrong alignment on ULightmassPortalComponent");
static_assert(sizeof(ULightmassPortalComponent) == 0x112E9AF0, "Wrong size on ULightmassPortalComponent");
static_assert(offsetof(ULightmassPortalComponent, PreviewBox) == 0x000418, "Member 'ULightmassPortalComponent::PreviewBox' has a wrong offset!");

// Class Engine.SoundNodeQualityLevel
// 0x0000 (0x0050 - 0x0050)
class USoundNodeQualityLevel final : public USoundNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeQualityLevel">();
	}
	static class USoundNodeQualityLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeQualityLevel>();
	}
};
static_assert(alignof(USoundNodeQualityLevel) == 0x000008, "Wrong alignment on USoundNodeQualityLevel");
static_assert(sizeof(USoundNodeQualityLevel) == 0x000050, "Wrong size on USoundNodeQualityLevel");

// Class Engine.MaterialExpressionObjectPositionWS
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionObjectPositionWS final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionObjectPositionWS">();
	}
	static class UMaterialExpressionObjectPositionWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionObjectPositionWS>();
	}
};
static_assert(alignof(UMaterialExpressionObjectPositionWS) == 0x000008, "Wrong alignment on UMaterialExpressionObjectPositionWS");
static_assert(sizeof(UMaterialExpressionObjectPositionWS) == 0x000078, "Wrong size on UMaterialExpressionObjectPositionWS");

// Class Engine.LightmassPrimitiveSettingsObject
// 0x11635BA0 (0x11635BE0 - 0x0040)
class ULightmassPrimitiveSettingsObject final : public UObject
{
public:
	struct FLightmassPrimitiveSettings            LightmassSettings;                                 // 0x0040(0x11635BE0)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightmassPrimitiveSettingsObject">();
	}
	static class ULightmassPrimitiveSettingsObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightmassPrimitiveSettingsObject>();
	}
};
static_assert(alignof(ULightmassPrimitiveSettingsObject) == 0x11635BE0, "Wrong alignment on ULightmassPrimitiveSettingsObject");
static_assert(sizeof(ULightmassPrimitiveSettingsObject) == 0x11635BE0, "Wrong size on ULightmassPrimitiveSettingsObject");
static_assert(offsetof(ULightmassPrimitiveSettingsObject, LightmassSettings) == 0x000040, "Member 'ULightmassPrimitiveSettingsObject::LightmassSettings' has a wrong offset!");

// Class Engine.MaterialExpressionFmod
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFmod final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFmod">();
	}
	static class UMaterialExpressionFmod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFmod>();
	}
};
static_assert(alignof(UMaterialExpressionFmod) == 0x112F2730, "Wrong alignment on UMaterialExpressionFmod");
static_assert(sizeof(UMaterialExpressionFmod) == 0x112F2730, "Wrong size on UMaterialExpressionFmod");
static_assert(offsetof(UMaterialExpressionFmod, A) == 0x000078, "Member 'UMaterialExpressionFmod::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFmod, B) == 0x0000B0, "Member 'UMaterialExpressionFmod::B' has a wrong offset!");

// Class Engine.LocalPlayer
// 0x0510 (0x0570 - 0x0060)
class ULocalPlayer final : public UPlayer
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameViewportClient*                    ViewportClient;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x1C];                                      // 0x0078(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	EAspectRatioAxisConstraint                    AspectRatioAxisConstraint;                         // 0x0094(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APlayerController>          PendingLevelPlayerControllerClass;                 // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSentSplitJoin : 1;                                // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x407];                                     // 0x00A1(0x0407)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControllerId;                                      // 0x04A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4AC[0xC4];                                     // 0x04AC(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayer">();
	}
	static class ULocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayer>();
	}
};
static_assert(alignof(ULocalPlayer) == 0x000008, "Wrong alignment on ULocalPlayer");
static_assert(sizeof(ULocalPlayer) == 0x000570, "Wrong size on ULocalPlayer");
static_assert(offsetof(ULocalPlayer, ViewportClient) == 0x000070, "Member 'ULocalPlayer::ViewportClient' has a wrong offset!");
static_assert(offsetof(ULocalPlayer, AspectRatioAxisConstraint) == 0x000094, "Member 'ULocalPlayer::AspectRatioAxisConstraint' has a wrong offset!");
static_assert(offsetof(ULocalPlayer, PendingLevelPlayerControllerClass) == 0x000098, "Member 'ULocalPlayer::PendingLevelPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ULocalPlayer, ControllerId) == 0x0004A8, "Member 'ULocalPlayer::ControllerId' has a wrong offset!");

// Class Engine.MaterialBillboardComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UMaterialBillboardComponent final : public UPrimitiveComponent
{
public:
	TArray<struct FMaterialSpriteElement>         Elements;                                          // 0x0868(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve);
	void SetElements(const TArray<struct FMaterialSpriteElement>& NewElements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialBillboardComponent">();
	}
	static class UMaterialBillboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialBillboardComponent>();
	}
};
static_assert(alignof(UMaterialBillboardComponent) == 0x112E9AF0, "Wrong alignment on UMaterialBillboardComponent");
static_assert(sizeof(UMaterialBillboardComponent) == 0x112E9AF0, "Wrong size on UMaterialBillboardComponent");
static_assert(offsetof(UMaterialBillboardComponent, Elements) == 0x000868, "Member 'UMaterialBillboardComponent::Elements' has a wrong offset!");

// Class Engine.MaterialExpressionActorPositionWS
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionActorPositionWS final : public UMaterialExpression
{
public:
	uint8                                         bNoUseAttachmentActorLocation : 1;                 // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionActorPositionWS">();
	}
	static class UMaterialExpressionActorPositionWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionActorPositionWS>();
	}
};
static_assert(alignof(UMaterialExpressionActorPositionWS) == 0x000008, "Wrong alignment on UMaterialExpressionActorPositionWS");
static_assert(sizeof(UMaterialExpressionActorPositionWS) == 0x000080, "Wrong size on UMaterialExpressionActorPositionWS");

// Class Engine.MaterialExpressionArctangent2Fast
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionArctangent2Fast final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Y;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       X;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionArctangent2Fast">();
	}
	static class UMaterialExpressionArctangent2Fast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionArctangent2Fast>();
	}
};
static_assert(alignof(UMaterialExpressionArctangent2Fast) == 0x112F2730, "Wrong alignment on UMaterialExpressionArctangent2Fast");
static_assert(sizeof(UMaterialExpressionArctangent2Fast) == 0x112F2730, "Wrong size on UMaterialExpressionArctangent2Fast");
static_assert(offsetof(UMaterialExpressionArctangent2Fast, Y) == 0x000078, "Member 'UMaterialExpressionArctangent2Fast::Y' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionArctangent2Fast, X) == 0x0000B0, "Member 'UMaterialExpressionArctangent2Fast::X' has a wrong offset!");

// Class Engine.MaterialExpressionAtmosphericFogColor
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionAtmosphericFogColor final : public UMaterialExpression
{
public:
	struct FExpressionInput                       WorldPosition;                                     // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAtmosphericFogColor">();
	}
	static class UMaterialExpressionAtmosphericFogColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAtmosphericFogColor>();
	}
};
static_assert(alignof(UMaterialExpressionAtmosphericFogColor) == 0x112F2730, "Wrong alignment on UMaterialExpressionAtmosphericFogColor");
static_assert(sizeof(UMaterialExpressionAtmosphericFogColor) == 0x112F2730, "Wrong size on UMaterialExpressionAtmosphericFogColor");
static_assert(offsetof(UMaterialExpressionAtmosphericFogColor, WorldPosition) == 0x000078, "Member 'UMaterialExpressionAtmosphericFogColor::WorldPosition' has a wrong offset!");

// Class Engine.MaterialExpressionAtmosphericLightVector
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionAtmosphericLightVector final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionAtmosphericLightVector">();
	}
	static class UMaterialExpressionAtmosphericLightVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionAtmosphericLightVector>();
	}
};
static_assert(alignof(UMaterialExpressionAtmosphericLightVector) == 0x000008, "Wrong alignment on UMaterialExpressionAtmosphericLightVector");
static_assert(sizeof(UMaterialExpressionAtmosphericLightVector) == 0x000078, "Wrong size on UMaterialExpressionAtmosphericLightVector");

// Class Engine.MaterialExpressionBlackBody
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionBlackBody final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Temp;                                              // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBlackBody">();
	}
	static class UMaterialExpressionBlackBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBlackBody>();
	}
};
static_assert(alignof(UMaterialExpressionBlackBody) == 0x112F2730, "Wrong alignment on UMaterialExpressionBlackBody");
static_assert(sizeof(UMaterialExpressionBlackBody) == 0x112F2730, "Wrong size on UMaterialExpressionBlackBody");
static_assert(offsetof(UMaterialExpressionBlackBody, Temp) == 0x000078, "Member 'UMaterialExpressionBlackBody::Temp' has a wrong offset!");

// Class Engine.MaterialExpressionBreakMaterialAttributes
// 0x0040 (0x00B8 - 0x0078)
class UMaterialExpressionBreakMaterialAttributes final : public UMaterialExpression
{
public:
	struct FMaterialAttributesInput               MaterialAttributes;                                // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBreakMaterialAttributes">();
	}
	static class UMaterialExpressionBreakMaterialAttributes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBreakMaterialAttributes>();
	}
};
static_assert(alignof(UMaterialExpressionBreakMaterialAttributes) == 0x000008, "Wrong alignment on UMaterialExpressionBreakMaterialAttributes");
static_assert(sizeof(UMaterialExpressionBreakMaterialAttributes) == 0x0000B8, "Wrong size on UMaterialExpressionBreakMaterialAttributes");
static_assert(offsetof(UMaterialExpressionBreakMaterialAttributes, MaterialAttributes) == 0x000078, "Member 'UMaterialExpressionBreakMaterialAttributes::MaterialAttributes' has a wrong offset!");

// Class Engine.MaterialExpressionCameraPositionWS
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionCameraPositionWS final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCameraPositionWS">();
	}
	static class UMaterialExpressionCameraPositionWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCameraPositionWS>();
	}
};
static_assert(alignof(UMaterialExpressionCameraPositionWS) == 0x000008, "Wrong alignment on UMaterialExpressionCameraPositionWS");
static_assert(sizeof(UMaterialExpressionCameraPositionWS) == 0x000078, "Wrong size on UMaterialExpressionCameraPositionWS");

// Class Engine.MaterialExpressionCeil
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionCeil final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionCeil">();
	}
	static class UMaterialExpressionCeil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionCeil>();
	}
};
static_assert(alignof(UMaterialExpressionCeil) == 0x112F2730, "Wrong alignment on UMaterialExpressionCeil");
static_assert(sizeof(UMaterialExpressionCeil) == 0x112F2730, "Wrong size on UMaterialExpressionCeil");
static_assert(offsetof(UMaterialExpressionCeil, Input) == 0x000078, "Member 'UMaterialExpressionCeil::Input' has a wrong offset!");

// Class Engine.MaterialExpressionClearCoatNormalCustomOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionClearCoatNormalCustomOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionClearCoatNormalCustomOutput">();
	}
	static class UMaterialExpressionClearCoatNormalCustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionClearCoatNormalCustomOutput>();
	}
};
static_assert(alignof(UMaterialExpressionClearCoatNormalCustomOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionClearCoatNormalCustomOutput");
static_assert(sizeof(UMaterialExpressionClearCoatNormalCustomOutput) == 0x112F2730, "Wrong size on UMaterialExpressionClearCoatNormalCustomOutput");
static_assert(offsetof(UMaterialExpressionClearCoatNormalCustomOutput, Input) == 0x000078, "Member 'UMaterialExpressionClearCoatNormalCustomOutput::Input' has a wrong offset!");

// Class Engine.MaterialExpressionComment
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionComment final : public UMaterialExpression
{
public:
	int32                                         SizeX;                                             // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CommentColor;                                      // 0x0090(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionComment">();
	}
	static class UMaterialExpressionComment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionComment>();
	}
};
static_assert(alignof(UMaterialExpressionComment) == 0x112EAE80, "Wrong alignment on UMaterialExpressionComment");
static_assert(sizeof(UMaterialExpressionComment) == 0x112EAE80, "Wrong size on UMaterialExpressionComment");
static_assert(offsetof(UMaterialExpressionComment, SizeX) == 0x000078, "Member 'UMaterialExpressionComment::SizeX' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionComment, SizeY) == 0x00007C, "Member 'UMaterialExpressionComment::SizeY' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionComment, Text) == 0x000080, "Member 'UMaterialExpressionComment::Text' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionComment, CommentColor) == 0x000090, "Member 'UMaterialExpressionComment::CommentColor' has a wrong offset!");

// Class Engine.MaterialExpressionDDX
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDDX final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Value;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDDX">();
	}
	static class UMaterialExpressionDDX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDDX>();
	}
};
static_assert(alignof(UMaterialExpressionDDX) == 0x112F2730, "Wrong alignment on UMaterialExpressionDDX");
static_assert(sizeof(UMaterialExpressionDDX) == 0x112F2730, "Wrong size on UMaterialExpressionDDX");
static_assert(offsetof(UMaterialExpressionDDX, Value) == 0x000078, "Member 'UMaterialExpressionDDX::Value' has a wrong offset!");

// Class Engine.MaterialExpressionDecalMipmapLevel
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDecalMipmapLevel final : public UMaterialExpression
{
public:
	struct FExpressionInput                       TextureSize;                                       // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstWidth;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstHeight;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDecalMipmapLevel">();
	}
	static class UMaterialExpressionDecalMipmapLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDecalMipmapLevel>();
	}
};
static_assert(alignof(UMaterialExpressionDecalMipmapLevel) == 0x112F2730, "Wrong alignment on UMaterialExpressionDecalMipmapLevel");
static_assert(sizeof(UMaterialExpressionDecalMipmapLevel) == 0x112F2730, "Wrong size on UMaterialExpressionDecalMipmapLevel");
static_assert(offsetof(UMaterialExpressionDecalMipmapLevel, TextureSize) == 0x000078, "Member 'UMaterialExpressionDecalMipmapLevel::TextureSize' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDecalMipmapLevel, ConstWidth) == 0x0000B0, "Member 'UMaterialExpressionDecalMipmapLevel::ConstWidth' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDecalMipmapLevel, ConstHeight) == 0x0000B4, "Member 'UMaterialExpressionDecalMipmapLevel::ConstHeight' has a wrong offset!");

// Class Engine.MaterialExpressionDepthOfFieldFunction
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDepthOfFieldFunction final : public UMaterialExpression
{
public:
	EDepthOfFieldFunctionValue                    FunctionValue;                                     // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Depth;                                             // 0x0080(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDepthOfFieldFunction">();
	}
	static class UMaterialExpressionDepthOfFieldFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDepthOfFieldFunction>();
	}
};
static_assert(alignof(UMaterialExpressionDepthOfFieldFunction) == 0x112F2730, "Wrong alignment on UMaterialExpressionDepthOfFieldFunction");
static_assert(sizeof(UMaterialExpressionDepthOfFieldFunction) == 0x112F2730, "Wrong size on UMaterialExpressionDepthOfFieldFunction");
static_assert(offsetof(UMaterialExpressionDepthOfFieldFunction, FunctionValue) == 0x000078, "Member 'UMaterialExpressionDepthOfFieldFunction::FunctionValue' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDepthOfFieldFunction, Depth) == 0x000080, "Member 'UMaterialExpressionDepthOfFieldFunction::Depth' has a wrong offset!");

// Class Engine.MaterialExpressionDistanceCullFade
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionDistanceCullFade final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDistanceCullFade">();
	}
	static class UMaterialExpressionDistanceCullFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDistanceCullFade>();
	}
};
static_assert(alignof(UMaterialExpressionDistanceCullFade) == 0x000008, "Wrong alignment on UMaterialExpressionDistanceCullFade");
static_assert(sizeof(UMaterialExpressionDistanceCullFade) == 0x000078, "Wrong size on UMaterialExpressionDistanceCullFade");

// Class Engine.MaterialExpressionDistanceToNearestSurface
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDistanceToNearestSurface final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Position;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDistanceToNearestSurface">();
	}
	static class UMaterialExpressionDistanceToNearestSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDistanceToNearestSurface>();
	}
};
static_assert(alignof(UMaterialExpressionDistanceToNearestSurface) == 0x112F2730, "Wrong alignment on UMaterialExpressionDistanceToNearestSurface");
static_assert(sizeof(UMaterialExpressionDistanceToNearestSurface) == 0x112F2730, "Wrong size on UMaterialExpressionDistanceToNearestSurface");
static_assert(offsetof(UMaterialExpressionDistanceToNearestSurface, Position) == 0x000078, "Member 'UMaterialExpressionDistanceToNearestSurface::Position' has a wrong offset!");

// Class Engine.MaterialExpressionDotProduct
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionDotProduct final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionDotProduct">();
	}
	static class UMaterialExpressionDotProduct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionDotProduct>();
	}
};
static_assert(alignof(UMaterialExpressionDotProduct) == 0x112F2730, "Wrong alignment on UMaterialExpressionDotProduct");
static_assert(sizeof(UMaterialExpressionDotProduct) == 0x112F2730, "Wrong size on UMaterialExpressionDotProduct");
static_assert(offsetof(UMaterialExpressionDotProduct, A) == 0x000078, "Member 'UMaterialExpressionDotProduct::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionDotProduct, B) == 0x0000B0, "Member 'UMaterialExpressionDotProduct::B' has a wrong offset!");

// Class Engine.MaterialExpressionEyeAdaptation
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionEyeAdaptation final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionEyeAdaptation">();
	}
	static class UMaterialExpressionEyeAdaptation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionEyeAdaptation>();
	}
};
static_assert(alignof(UMaterialExpressionEyeAdaptation) == 0x000008, "Wrong alignment on UMaterialExpressionEyeAdaptation");
static_assert(sizeof(UMaterialExpressionEyeAdaptation) == 0x000078, "Wrong size on UMaterialExpressionEyeAdaptation");

// Class Engine.MaterialExpressionFontSampleParameter
// 0x112E8C98 (0x112E8D20 - 0x0088)
class UMaterialExpressionFontSampleParameter final : public UMaterialExpressionFontSample
{
public:
	class FName                                   ParameterName;                                     // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0090(0x112E8D20)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Group;                                             // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFontSampleParameter">();
	}
	static class UMaterialExpressionFontSampleParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFontSampleParameter>();
	}
};
static_assert(alignof(UMaterialExpressionFontSampleParameter) == 0x112E8D20, "Wrong alignment on UMaterialExpressionFontSampleParameter");
static_assert(sizeof(UMaterialExpressionFontSampleParameter) == 0x112E8D20, "Wrong size on UMaterialExpressionFontSampleParameter");
static_assert(offsetof(UMaterialExpressionFontSampleParameter, ParameterName) == 0x000088, "Member 'UMaterialExpressionFontSampleParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFontSampleParameter, ExpressionGUID) == 0x000090, "Member 'UMaterialExpressionFontSampleParameter::ExpressionGUID' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFontSampleParameter, Group) == 0x0000A0, "Member 'UMaterialExpressionFontSampleParameter::Group' has a wrong offset!");

// Class Engine.MaterialExpressionFrac
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFrac final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFrac">();
	}
	static class UMaterialExpressionFrac* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFrac>();
	}
};
static_assert(alignof(UMaterialExpressionFrac) == 0x112F2730, "Wrong alignment on UMaterialExpressionFrac");
static_assert(sizeof(UMaterialExpressionFrac) == 0x112F2730, "Wrong size on UMaterialExpressionFrac");
static_assert(offsetof(UMaterialExpressionFrac, Input) == 0x000078, "Member 'UMaterialExpressionFrac::Input' has a wrong offset!");

// Class Engine.MaterialExpressionFunctionInput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionFunctionInput final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Preview;                                           // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	class FString                                 InputName;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x00D0(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFunctionInputType                            InputType;                                         // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0xF];                                       // 0x00E1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               PreviewValue;                                      // 0x00F0(0x112E9300)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsePreviewValueAsDefault : 1;                     // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortPriority;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompilingFunctionPreview : 1;                     // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x47];                                     // 0x0109(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionFunctionInput">();
	}
	static class UMaterialExpressionFunctionInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionFunctionInput>();
	}
};
static_assert(alignof(UMaterialExpressionFunctionInput) == 0x112F2730, "Wrong alignment on UMaterialExpressionFunctionInput");
static_assert(sizeof(UMaterialExpressionFunctionInput) == 0x112F2730, "Wrong size on UMaterialExpressionFunctionInput");
static_assert(offsetof(UMaterialExpressionFunctionInput, Preview) == 0x000078, "Member 'UMaterialExpressionFunctionInput::Preview' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionInput, InputName) == 0x0000B0, "Member 'UMaterialExpressionFunctionInput::InputName' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionInput, Description) == 0x0000C0, "Member 'UMaterialExpressionFunctionInput::Description' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionInput, ID) == 0x0000D0, "Member 'UMaterialExpressionFunctionInput::ID' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionInput, InputType) == 0x0000E0, "Member 'UMaterialExpressionFunctionInput::InputType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionInput, PreviewValue) == 0x0000F0, "Member 'UMaterialExpressionFunctionInput::PreviewValue' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionFunctionInput, SortPriority) == 0x000104, "Member 'UMaterialExpressionFunctionInput::SortPriority' has a wrong offset!");

// Class Engine.MaterialExpressionGetMaterialAttributes
// 0x0050 (0x00C8 - 0x0078)
class UMaterialExpressionGetMaterialAttributes final : public UMaterialExpression
{
public:
	struct FMaterialAttributesInput               MaterialAttributes;                                // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          AttributeGetTypes;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionGetMaterialAttributes">();
	}
	static class UMaterialExpressionGetMaterialAttributes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionGetMaterialAttributes>();
	}
};
static_assert(alignof(UMaterialExpressionGetMaterialAttributes) == 0x000008, "Wrong alignment on UMaterialExpressionGetMaterialAttributes");
static_assert(sizeof(UMaterialExpressionGetMaterialAttributes) == 0x0000C8, "Wrong size on UMaterialExpressionGetMaterialAttributes");
static_assert(offsetof(UMaterialExpressionGetMaterialAttributes, MaterialAttributes) == 0x000078, "Member 'UMaterialExpressionGetMaterialAttributes::MaterialAttributes' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionGetMaterialAttributes, AttributeGetTypes) == 0x0000B8, "Member 'UMaterialExpressionGetMaterialAttributes::AttributeGetTypes' has a wrong offset!");

// Class Engine.MaterialExpressionIf
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionIf final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       AGreaterThanB;                                     // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       AEqualsB;                                          // 0x0120(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       ALessThanB;                                        // 0x0158(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         EqualsThreshold;                                   // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstAEqualsB;                                     // 0x0198(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionIf">();
	}
	static class UMaterialExpressionIf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionIf>();
	}
};
static_assert(alignof(UMaterialExpressionIf) == 0x112F2730, "Wrong alignment on UMaterialExpressionIf");
static_assert(sizeof(UMaterialExpressionIf) == 0x112F2730, "Wrong size on UMaterialExpressionIf");
static_assert(offsetof(UMaterialExpressionIf, A) == 0x000078, "Member 'UMaterialExpressionIf::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, B) == 0x0000B0, "Member 'UMaterialExpressionIf::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, AGreaterThanB) == 0x0000E8, "Member 'UMaterialExpressionIf::AGreaterThanB' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, AEqualsB) == 0x000120, "Member 'UMaterialExpressionIf::AEqualsB' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, ALessThanB) == 0x000158, "Member 'UMaterialExpressionIf::ALessThanB' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, EqualsThreshold) == 0x000190, "Member 'UMaterialExpressionIf::EqualsThreshold' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, ConstB) == 0x000194, "Member 'UMaterialExpressionIf::ConstB' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionIf, ConstAEqualsB) == 0x000198, "Member 'UMaterialExpressionIf::ConstAEqualsB' has a wrong offset!");

// Class Engine.MaterialExpressionLightVector
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionLightVector final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLightVector">();
	}
	static class UMaterialExpressionLightVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLightVector>();
	}
};
static_assert(alignof(UMaterialExpressionLightVector) == 0x000008, "Wrong alignment on UMaterialExpressionLightVector");
static_assert(sizeof(UMaterialExpressionLightVector) == 0x000078, "Wrong size on UMaterialExpressionLightVector");

// Class Engine.MaterialExpressionLogarithm2
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionLogarithm2 final : public UMaterialExpression
{
public:
	struct FExpressionInput                       X;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionLogarithm2">();
	}
	static class UMaterialExpressionLogarithm2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionLogarithm2>();
	}
};
static_assert(alignof(UMaterialExpressionLogarithm2) == 0x112F2730, "Wrong alignment on UMaterialExpressionLogarithm2");
static_assert(sizeof(UMaterialExpressionLogarithm2) == 0x112F2730, "Wrong size on UMaterialExpressionLogarithm2");
static_assert(offsetof(UMaterialExpressionLogarithm2, X) == 0x000078, "Member 'UMaterialExpressionLogarithm2::X' has a wrong offset!");

// Class Engine.MaterialExpressionMaterialProxyReplace
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionMaterialProxyReplace final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Realtime;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       MaterialProxy;                                     // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialProxyReplace">();
	}
	static class UMaterialExpressionMaterialProxyReplace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialProxyReplace>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialProxyReplace) == 0x112F2730, "Wrong alignment on UMaterialExpressionMaterialProxyReplace");
static_assert(sizeof(UMaterialExpressionMaterialProxyReplace) == 0x112F2730, "Wrong size on UMaterialExpressionMaterialProxyReplace");
static_assert(offsetof(UMaterialExpressionMaterialProxyReplace, Realtime) == 0x000078, "Member 'UMaterialExpressionMaterialProxyReplace::Realtime' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialProxyReplace, MaterialProxy) == 0x0000B0, "Member 'UMaterialExpressionMaterialProxyReplace::MaterialProxy' has a wrong offset!");

// Class Engine.MaterialExpressionMax
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionMax final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMax">();
	}
	static class UMaterialExpressionMax* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMax>();
	}
};
static_assert(alignof(UMaterialExpressionMax) == 0x112F2730, "Wrong alignment on UMaterialExpressionMax");
static_assert(sizeof(UMaterialExpressionMax) == 0x112F2730, "Wrong size on UMaterialExpressionMax");
static_assert(offsetof(UMaterialExpressionMax, A) == 0x000078, "Member 'UMaterialExpressionMax::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMax, B) == 0x0000B0, "Member 'UMaterialExpressionMax::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMax, ConstA) == 0x0000E8, "Member 'UMaterialExpressionMax::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMax, ConstB) == 0x0000EC, "Member 'UMaterialExpressionMax::ConstB' has a wrong offset!");

// Class Engine.MaterialExpressionMultiply
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionMultiply final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMultiply">();
	}
	static class UMaterialExpressionMultiply* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMultiply>();
	}
};
static_assert(alignof(UMaterialExpressionMultiply) == 0x112F2730, "Wrong alignment on UMaterialExpressionMultiply");
static_assert(sizeof(UMaterialExpressionMultiply) == 0x112F2730, "Wrong size on UMaterialExpressionMultiply");
static_assert(offsetof(UMaterialExpressionMultiply, A) == 0x000078, "Member 'UMaterialExpressionMultiply::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMultiply, B) == 0x0000B0, "Member 'UMaterialExpressionMultiply::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMultiply, ConstA) == 0x0000E8, "Member 'UMaterialExpressionMultiply::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMultiply, ConstB) == 0x0000EC, "Member 'UMaterialExpressionMultiply::ConstB' has a wrong offset!");

// Class Engine.MaterialExpressionObjectOrientation
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionObjectOrientation final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionObjectOrientation">();
	}
	static class UMaterialExpressionObjectOrientation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionObjectOrientation>();
	}
};
static_assert(alignof(UMaterialExpressionObjectOrientation) == 0x000008, "Wrong alignment on UMaterialExpressionObjectOrientation");
static_assert(sizeof(UMaterialExpressionObjectOrientation) == 0x000078, "Wrong size on UMaterialExpressionObjectOrientation");

// Class Engine.MaterialExpressionOneMinus
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionOneMinus final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionOneMinus">();
	}
	static class UMaterialExpressionOneMinus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionOneMinus>();
	}
};
static_assert(alignof(UMaterialExpressionOneMinus) == 0x112F2730, "Wrong alignment on UMaterialExpressionOneMinus");
static_assert(sizeof(UMaterialExpressionOneMinus) == 0x112F2730, "Wrong size on UMaterialExpressionOneMinus");
static_assert(offsetof(UMaterialExpressionOneMinus, Input) == 0x000078, "Member 'UMaterialExpressionOneMinus::Input' has a wrong offset!");

// Class Engine.MaterialExpressionParticleColor
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleColor final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleColor">();
	}
	static class UMaterialExpressionParticleColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleColor) == 0x000008, "Wrong alignment on UMaterialExpressionParticleColor");
static_assert(sizeof(UMaterialExpressionParticleColor) == 0x000078, "Wrong size on UMaterialExpressionParticleColor");

// Class Engine.MaterialExpressionParticleDirection
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleDirection final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleDirection">();
	}
	static class UMaterialExpressionParticleDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleDirection>();
	}
};
static_assert(alignof(UMaterialExpressionParticleDirection) == 0x000008, "Wrong alignment on UMaterialExpressionParticleDirection");
static_assert(sizeof(UMaterialExpressionParticleDirection) == 0x000078, "Wrong size on UMaterialExpressionParticleDirection");

// Class Engine.MaterialExpressionParticleMacroUV
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleMacroUV final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleMacroUV">();
	}
	static class UMaterialExpressionParticleMacroUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleMacroUV>();
	}
};
static_assert(alignof(UMaterialExpressionParticleMacroUV) == 0x000008, "Wrong alignment on UMaterialExpressionParticleMacroUV");
static_assert(sizeof(UMaterialExpressionParticleMacroUV) == 0x000078, "Wrong size on UMaterialExpressionParticleMacroUV");

// Class Engine.MaterialExpressionParticlePositionWS
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticlePositionWS final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticlePositionWS">();
	}
	static class UMaterialExpressionParticlePositionWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticlePositionWS>();
	}
};
static_assert(alignof(UMaterialExpressionParticlePositionWS) == 0x000008, "Wrong alignment on UMaterialExpressionParticlePositionWS");
static_assert(sizeof(UMaterialExpressionParticlePositionWS) == 0x000078, "Wrong size on UMaterialExpressionParticlePositionWS");

// Class Engine.MaterialExpressionParticleRandom
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleRandom final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleRandom">();
	}
	static class UMaterialExpressionParticleRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleRandom>();
	}
};
static_assert(alignof(UMaterialExpressionParticleRandom) == 0x000008, "Wrong alignment on UMaterialExpressionParticleRandom");
static_assert(sizeof(UMaterialExpressionParticleRandom) == 0x000078, "Wrong size on UMaterialExpressionParticleRandom");

// Class Engine.MaterialExpressionParticleRelativeTime
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleRelativeTime final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleRelativeTime">();
	}
	static class UMaterialExpressionParticleRelativeTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleRelativeTime>();
	}
};
static_assert(alignof(UMaterialExpressionParticleRelativeTime) == 0x000008, "Wrong alignment on UMaterialExpressionParticleRelativeTime");
static_assert(sizeof(UMaterialExpressionParticleRelativeTime) == 0x000078, "Wrong size on UMaterialExpressionParticleRelativeTime");

// Class Engine.MaterialExpressionParticleSize
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleSize final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSize">();
	}
	static class UMaterialExpressionParticleSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSize>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSize) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSize");
static_assert(sizeof(UMaterialExpressionParticleSize) == 0x000078, "Wrong size on UMaterialExpressionParticleSize");

// Class Engine.MaterialExpressionParticleSQEXAreaBaseColor
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionParticleSQEXAreaBaseColor final : public UMaterialExpression
{
public:
	struct FLinearColor                           DefaultValue;                                      // 0x0078(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXAreaBaseColor">();
	}
	static class UMaterialExpressionParticleSQEXAreaBaseColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXAreaBaseColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXAreaBaseColor) == 0x112EAE80, "Wrong alignment on UMaterialExpressionParticleSQEXAreaBaseColor");
static_assert(sizeof(UMaterialExpressionParticleSQEXAreaBaseColor) == 0x112EAE80, "Wrong size on UMaterialExpressionParticleSQEXAreaBaseColor");
static_assert(offsetof(UMaterialExpressionParticleSQEXAreaBaseColor, DefaultValue) == 0x000078, "Member 'UMaterialExpressionParticleSQEXAreaBaseColor::DefaultValue' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXAreaBrightColor
// 0x112EAE08 (0x112EAE80 - 0x0078)
class UMaterialExpressionParticleSQEXAreaBrightColor final : public UMaterialExpression
{
public:
	struct FLinearColor                           DefaultValue;                                      // 0x0078(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXAreaBrightColor">();
	}
	static class UMaterialExpressionParticleSQEXAreaBrightColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXAreaBrightColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXAreaBrightColor) == 0x112EAE80, "Wrong alignment on UMaterialExpressionParticleSQEXAreaBrightColor");
static_assert(sizeof(UMaterialExpressionParticleSQEXAreaBrightColor) == 0x112EAE80, "Wrong size on UMaterialExpressionParticleSQEXAreaBrightColor");
static_assert(offsetof(UMaterialExpressionParticleSQEXAreaBrightColor, DefaultValue) == 0x000078, "Member 'UMaterialExpressionParticleSQEXAreaBrightColor::DefaultValue' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXEmitterTime
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionParticleSQEXEmitterTime final : public UMaterialExpression
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXEmitterTime">();
	}
	static class UMaterialExpressionParticleSQEXEmitterTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXEmitterTime>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXEmitterTime) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXEmitterTime");
static_assert(sizeof(UMaterialExpressionParticleSQEXEmitterTime) == 0x000088, "Wrong size on UMaterialExpressionParticleSQEXEmitterTime");

// Class Engine.MaterialExpressionParticleSQEXKingdomHeartsSpace
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionParticleSQEXKingdomHeartsSpace final : public UMaterialExpression
{
public:
	ESQEX_KINGDOMHEARTSSPACE_TYPE                 Type;                                              // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       TimeTimeScaleTilingCustom;                         // 0x0080(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       TexCoord;                                          // 0x00B8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputColor0;                                       // 0x00F0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputColor1;                                       // 0x0128(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputColor2;                                       // 0x0160(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputColor3;                                       // 0x0198(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputColor4;                                       // 0x01D0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       ResolutionDivi;                                    // 0x0208(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXKingdomHeartsSpace">();
	}
	static class UMaterialExpressionParticleSQEXKingdomHeartsSpace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXKingdomHeartsSpace>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXKingdomHeartsSpace) == 0x112F2730, "Wrong alignment on UMaterialExpressionParticleSQEXKingdomHeartsSpace");
static_assert(sizeof(UMaterialExpressionParticleSQEXKingdomHeartsSpace) == 0x112F2730, "Wrong size on UMaterialExpressionParticleSQEXKingdomHeartsSpace");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, Type) == 0x000078, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::Type' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, TimeTimeScaleTilingCustom) == 0x000080, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::TimeTimeScaleTilingCustom' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, TexCoord) == 0x0000B8, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::TexCoord' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, InputColor0) == 0x0000F0, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::InputColor0' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, InputColor1) == 0x000128, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::InputColor1' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, InputColor2) == 0x000160, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::InputColor2' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, InputColor3) == 0x000198, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::InputColor3' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, InputColor4) == 0x0001D0, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::InputColor4' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXKingdomHeartsSpace, ResolutionDivi) == 0x000208, "Member 'UMaterialExpressionParticleSQEXKingdomHeartsSpace::ResolutionDivi' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXOpticalFlow
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionParticleSQEXOpticalFlow final : public UMaterialExpression
{
public:
	struct FExpressionInput                       InputTex;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputFlowScale;                                    // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputFlowIndex;                                    // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXOpticalFlow">();
	}
	static class UMaterialExpressionParticleSQEXOpticalFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXOpticalFlow>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXOpticalFlow) == 0x112F2730, "Wrong alignment on UMaterialExpressionParticleSQEXOpticalFlow");
static_assert(sizeof(UMaterialExpressionParticleSQEXOpticalFlow) == 0x112F2730, "Wrong size on UMaterialExpressionParticleSQEXOpticalFlow");
static_assert(offsetof(UMaterialExpressionParticleSQEXOpticalFlow, InputTex) == 0x000078, "Member 'UMaterialExpressionParticleSQEXOpticalFlow::InputTex' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXOpticalFlow, InputFlowScale) == 0x0000B0, "Member 'UMaterialExpressionParticleSQEXOpticalFlow::InputFlowScale' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionParticleSQEXOpticalFlow, InputFlowIndex) == 0x0000E8, "Member 'UMaterialExpressionParticleSQEXOpticalFlow::InputFlowIndex' has a wrong offset!");

// Class Engine.MaterialExpressionParticleSQEXSceneBaseColor
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleSQEXSceneBaseColor final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXSceneBaseColor">();
	}
	static class UMaterialExpressionParticleSQEXSceneBaseColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXSceneBaseColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXSceneBaseColor) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXSceneBaseColor");
static_assert(sizeof(UMaterialExpressionParticleSQEXSceneBaseColor) == 0x000078, "Wrong size on UMaterialExpressionParticleSQEXSceneBaseColor");

// Class Engine.MaterialExpressionParticleSQEXSceneBrightColor
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleSQEXSceneBrightColor final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXSceneBrightColor">();
	}
	static class UMaterialExpressionParticleSQEXSceneBrightColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXSceneBrightColor>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXSceneBrightColor) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXSceneBrightColor");
static_assert(sizeof(UMaterialExpressionParticleSQEXSceneBrightColor) == 0x000078, "Wrong size on UMaterialExpressionParticleSQEXSceneBrightColor");

// Class Engine.MaterialExpressionParticleSQEXSceneColorSynthesis
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionParticleSQEXSceneColorSynthesis final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXSceneColorSynthesis">();
	}
	static class UMaterialExpressionParticleSQEXSceneColorSynthesis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXSceneColorSynthesis>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXSceneColorSynthesis) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXSceneColorSynthesis");
static_assert(sizeof(UMaterialExpressionParticleSQEXSceneColorSynthesis) == 0x000078, "Wrong size on UMaterialExpressionParticleSQEXSceneColorSynthesis");

// Class Engine.MaterialExpressionParticleSQEXTexUVScale
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionParticleSQEXTexUVScale final : public UMaterialExpression
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionParticleSQEXTexUVScale">();
	}
	static class UMaterialExpressionParticleSQEXTexUVScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionParticleSQEXTexUVScale>();
	}
};
static_assert(alignof(UMaterialExpressionParticleSQEXTexUVScale) == 0x000008, "Wrong alignment on UMaterialExpressionParticleSQEXTexUVScale");
static_assert(sizeof(UMaterialExpressionParticleSQEXTexUVScale) == 0x000088, "Wrong size on UMaterialExpressionParticleSQEXTexUVScale");

// Class Engine.MaterialExpressionPerInstanceRandom
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPerInstanceRandom final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPerInstanceRandom">();
	}
	static class UMaterialExpressionPerInstanceRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPerInstanceRandom>();
	}
};
static_assert(alignof(UMaterialExpressionPerInstanceRandom) == 0x000008, "Wrong alignment on UMaterialExpressionPerInstanceRandom");
static_assert(sizeof(UMaterialExpressionPerInstanceRandom) == 0x000078, "Wrong size on UMaterialExpressionPerInstanceRandom");

// Class Engine.MaterialExpressionPixelDepth
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPixelDepth final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPixelDepth">();
	}
	static class UMaterialExpressionPixelDepth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPixelDepth>();
	}
};
static_assert(alignof(UMaterialExpressionPixelDepth) == 0x000008, "Wrong alignment on UMaterialExpressionPixelDepth");
static_assert(sizeof(UMaterialExpressionPixelDepth) == 0x000078, "Wrong size on UMaterialExpressionPixelDepth");

// Class Engine.MaterialExpressionPreSkinnedNormal
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPreSkinnedNormal final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPreSkinnedNormal">();
	}
	static class UMaterialExpressionPreSkinnedNormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPreSkinnedNormal>();
	}
};
static_assert(alignof(UMaterialExpressionPreSkinnedNormal) == 0x000008, "Wrong alignment on UMaterialExpressionPreSkinnedNormal");
static_assert(sizeof(UMaterialExpressionPreSkinnedNormal) == 0x000078, "Wrong size on UMaterialExpressionPreSkinnedNormal");

// Class Engine.MaterialExpressionPreSkinnedPosition
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionPreSkinnedPosition final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPreSkinnedPosition">();
	}
	static class UMaterialExpressionPreSkinnedPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPreSkinnedPosition>();
	}
};
static_assert(alignof(UMaterialExpressionPreSkinnedPosition) == 0x000008, "Wrong alignment on UMaterialExpressionPreSkinnedPosition");
static_assert(sizeof(UMaterialExpressionPreSkinnedPosition) == 0x000078, "Wrong size on UMaterialExpressionPreSkinnedPosition");

// Class Engine.MaterialExpressionPreviousFrameSwitch
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionPreviousFrameSwitch final : public UMaterialExpression
{
public:
	struct FExpressionInput                       CurrentFrame;                                      // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       PreviousFrame;                                     // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPreviousFrameSwitch">();
	}
	static class UMaterialExpressionPreviousFrameSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPreviousFrameSwitch>();
	}
};
static_assert(alignof(UMaterialExpressionPreviousFrameSwitch) == 0x112F2730, "Wrong alignment on UMaterialExpressionPreviousFrameSwitch");
static_assert(sizeof(UMaterialExpressionPreviousFrameSwitch) == 0x112F2730, "Wrong size on UMaterialExpressionPreviousFrameSwitch");
static_assert(offsetof(UMaterialExpressionPreviousFrameSwitch, CurrentFrame) == 0x000078, "Member 'UMaterialExpressionPreviousFrameSwitch::CurrentFrame' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionPreviousFrameSwitch, PreviousFrame) == 0x0000B0, "Member 'UMaterialExpressionPreviousFrameSwitch::PreviousFrame' has a wrong offset!");

// Class Engine.MaterialExpressionQualitySwitch
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionQualitySwitch final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Default;                                           // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Inputs[0x3];                                       // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionQualitySwitch">();
	}
	static class UMaterialExpressionQualitySwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionQualitySwitch>();
	}
};
static_assert(alignof(UMaterialExpressionQualitySwitch) == 0x112F2730, "Wrong alignment on UMaterialExpressionQualitySwitch");
static_assert(sizeof(UMaterialExpressionQualitySwitch) == 0x112F2730, "Wrong size on UMaterialExpressionQualitySwitch");
static_assert(offsetof(UMaterialExpressionQualitySwitch, Default) == 0x000078, "Member 'UMaterialExpressionQualitySwitch::Default' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionQualitySwitch, Inputs) == 0x0000B0, "Member 'UMaterialExpressionQualitySwitch::Inputs' has a wrong offset!");

// Class Engine.MaterialExpressionReflectionVectorWS
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionReflectionVectorWS final : public UMaterialExpression
{
public:
	struct FExpressionInput                       CustomWorldNormal;                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	uint8                                         bNormalizeCustomWorldNormal : 1;                   // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionReflectionVectorWS">();
	}
	static class UMaterialExpressionReflectionVectorWS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionReflectionVectorWS>();
	}
};
static_assert(alignof(UMaterialExpressionReflectionVectorWS) == 0x112F2730, "Wrong alignment on UMaterialExpressionReflectionVectorWS");
static_assert(sizeof(UMaterialExpressionReflectionVectorWS) == 0x112F2730, "Wrong size on UMaterialExpressionReflectionVectorWS");
static_assert(offsetof(UMaterialExpressionReflectionVectorWS, CustomWorldNormal) == 0x000078, "Member 'UMaterialExpressionReflectionVectorWS::CustomWorldNormal' has a wrong offset!");

// Class Engine.MaterialExpressionRotator
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionRotator final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinate;                                        // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Time;                                              // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         CenterX;                                           // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterY;                                           // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ConstCoordinate;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionRotator">();
	}
	static class UMaterialExpressionRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionRotator>();
	}
};
static_assert(alignof(UMaterialExpressionRotator) == 0x112F2730, "Wrong alignment on UMaterialExpressionRotator");
static_assert(sizeof(UMaterialExpressionRotator) == 0x112F2730, "Wrong size on UMaterialExpressionRotator");
static_assert(offsetof(UMaterialExpressionRotator, Coordinate) == 0x000078, "Member 'UMaterialExpressionRotator::Coordinate' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotator, Time) == 0x0000B0, "Member 'UMaterialExpressionRotator::Time' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotator, CenterX) == 0x0000E8, "Member 'UMaterialExpressionRotator::CenterX' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotator, CenterY) == 0x0000EC, "Member 'UMaterialExpressionRotator::CenterY' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotator, Speed) == 0x0000F0, "Member 'UMaterialExpressionRotator::Speed' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionRotator, ConstCoordinate) == 0x0000F4, "Member 'UMaterialExpressionRotator::ConstCoordinate' has a wrong offset!");

// Class Engine.MaterialExpressionScalarParameter
// 0x0000 (0x112E8D20 - 0x112E8D20)
class UMaterialExpressionScalarParameter final : public UMaterialExpressionParameter
{
public:
	float                                         DefaultValue;                                      // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderMin;                                         // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderMax;                                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionScalarParameter">();
	}
	static class UMaterialExpressionScalarParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionScalarParameter>();
	}
};
static_assert(alignof(UMaterialExpressionScalarParameter) == 0x112E8D20, "Wrong alignment on UMaterialExpressionScalarParameter");
static_assert(sizeof(UMaterialExpressionScalarParameter) == 0x112E8D20, "Wrong size on UMaterialExpressionScalarParameter");
static_assert(offsetof(UMaterialExpressionScalarParameter, DefaultValue) == 0x000098, "Member 'UMaterialExpressionScalarParameter::DefaultValue' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionScalarParameter, SliderMin) == 0x00009C, "Member 'UMaterialExpressionScalarParameter::SliderMin' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionScalarParameter, SliderMax) == 0x0000A0, "Member 'UMaterialExpressionScalarParameter::SliderMax' has a wrong offset!");

// Class Engine.MaterialExpressionSceneColor
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSceneColor final : public UMaterialExpression
{
public:
	EMaterialSceneAttributeInputMode              InputMode;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Input;                                             // 0x0080(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       OffsetFraction;                                    // 0x00B8(0x112F2730)(Deprecated, NativeAccessSpecifierPublic)
	struct FVector2D                              ConstInput;                                        // 0x00F0(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSceneColor">();
	}
	static class UMaterialExpressionSceneColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSceneColor>();
	}
};
static_assert(alignof(UMaterialExpressionSceneColor) == 0x112F2730, "Wrong alignment on UMaterialExpressionSceneColor");
static_assert(sizeof(UMaterialExpressionSceneColor) == 0x112F2730, "Wrong size on UMaterialExpressionSceneColor");
static_assert(offsetof(UMaterialExpressionSceneColor, InputMode) == 0x000078, "Member 'UMaterialExpressionSceneColor::InputMode' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneColor, Input) == 0x000080, "Member 'UMaterialExpressionSceneColor::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneColor, OffsetFraction) == 0x0000B8, "Member 'UMaterialExpressionSceneColor::OffsetFraction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneColor, ConstInput) == 0x0000F0, "Member 'UMaterialExpressionSceneColor::ConstInput' has a wrong offset!");

// Class Engine.MaterialExpressionSceneTexture
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSceneTexture final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	ESceneTextureId                               SceneTextureId;                                    // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampUVs;                                         // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFiltered;                                         // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSceneTexture">();
	}
	static class UMaterialExpressionSceneTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSceneTexture>();
	}
};
static_assert(alignof(UMaterialExpressionSceneTexture) == 0x112F2730, "Wrong alignment on UMaterialExpressionSceneTexture");
static_assert(sizeof(UMaterialExpressionSceneTexture) == 0x112F2730, "Wrong size on UMaterialExpressionSceneTexture");
static_assert(offsetof(UMaterialExpressionSceneTexture, Coordinates) == 0x000078, "Member 'UMaterialExpressionSceneTexture::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneTexture, SceneTextureId) == 0x0000B0, "Member 'UMaterialExpressionSceneTexture::SceneTextureId' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneTexture, bClampUVs) == 0x0000B1, "Member 'UMaterialExpressionSceneTexture::bClampUVs' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSceneTexture, bFiltered) == 0x0000B2, "Member 'UMaterialExpressionSceneTexture::bFiltered' has a wrong offset!");

// Class Engine.MaterialExpressionScreenPosition
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionScreenPosition final : public UMaterialExpression
{
public:
	EMaterialExpressionScreenPositionMapping      Mapping;                                           // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionScreenPosition">();
	}
	static class UMaterialExpressionScreenPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionScreenPosition>();
	}
};
static_assert(alignof(UMaterialExpressionScreenPosition) == 0x000008, "Wrong alignment on UMaterialExpressionScreenPosition");
static_assert(sizeof(UMaterialExpressionScreenPosition) == 0x000080, "Wrong size on UMaterialExpressionScreenPosition");
static_assert(offsetof(UMaterialExpressionScreenPosition, Mapping) == 0x000078, "Member 'UMaterialExpressionScreenPosition::Mapping' has a wrong offset!");

// Class Engine.MaterialExpressionSetMaterialAttributes
// 0x0020 (0x0098 - 0x0078)
class UMaterialExpressionSetMaterialAttributes final : public UMaterialExpression
{
public:
	TArray<struct FExpressionInput>               Inputs;                                            // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGuid>                          AttributeSetTypes;                                 // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSetMaterialAttributes">();
	}
	static class UMaterialExpressionSetMaterialAttributes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSetMaterialAttributes>();
	}
};
static_assert(alignof(UMaterialExpressionSetMaterialAttributes) == 0x000008, "Wrong alignment on UMaterialExpressionSetMaterialAttributes");
static_assert(sizeof(UMaterialExpressionSetMaterialAttributes) == 0x000098, "Wrong size on UMaterialExpressionSetMaterialAttributes");
static_assert(offsetof(UMaterialExpressionSetMaterialAttributes, Inputs) == 0x000078, "Member 'UMaterialExpressionSetMaterialAttributes::Inputs' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSetMaterialAttributes, AttributeSetTypes) == 0x000088, "Member 'UMaterialExpressionSetMaterialAttributes::AttributeSetTypes' has a wrong offset!");

// Class Engine.MaterialExpressionSign
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSign final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSign">();
	}
	static class UMaterialExpressionSign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSign>();
	}
};
static_assert(alignof(UMaterialExpressionSign) == 0x112F2730, "Wrong alignment on UMaterialExpressionSign");
static_assert(sizeof(UMaterialExpressionSign) == 0x112F2730, "Wrong size on UMaterialExpressionSign");
static_assert(offsetof(UMaterialExpressionSign, Input) == 0x000078, "Member 'UMaterialExpressionSign::Input' has a wrong offset!");

// Class Engine.MaterialExpressionSine
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSine final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSine">();
	}
	static class UMaterialExpressionSine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSine>();
	}
};
static_assert(alignof(UMaterialExpressionSine) == 0x112F2730, "Wrong alignment on UMaterialExpressionSine");
static_assert(sizeof(UMaterialExpressionSine) == 0x112F2730, "Wrong size on UMaterialExpressionSine");
static_assert(offsetof(UMaterialExpressionSine, Input) == 0x000078, "Member 'UMaterialExpressionSine::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSine, Period) == 0x0000B0, "Member 'UMaterialExpressionSine::Period' has a wrong offset!");

// Class Engine.MaterialExpressionSobol
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSobol final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Cell;                                              // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Index_0;                                           // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Seed;                                              // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)
	uint32                                        ConstIndex;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ConstSeed;                                         // 0x0124(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSobol">();
	}
	static class UMaterialExpressionSobol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSobol>();
	}
};
static_assert(alignof(UMaterialExpressionSobol) == 0x112F2730, "Wrong alignment on UMaterialExpressionSobol");
static_assert(sizeof(UMaterialExpressionSobol) == 0x112F2730, "Wrong size on UMaterialExpressionSobol");
static_assert(offsetof(UMaterialExpressionSobol, Cell) == 0x000078, "Member 'UMaterialExpressionSobol::Cell' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSobol, Index_0) == 0x0000B0, "Member 'UMaterialExpressionSobol::Index_0' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSobol, Seed) == 0x0000E8, "Member 'UMaterialExpressionSobol::Seed' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSobol, ConstIndex) == 0x000120, "Member 'UMaterialExpressionSobol::ConstIndex' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSobol, ConstSeed) == 0x000124, "Member 'UMaterialExpressionSobol::ConstSeed' has a wrong offset!");

// Class Engine.MaterialExpressionSpeedTree
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionSpeedTree final : public UMaterialExpression
{
public:
	ESpeedTreeGeometryType                        GeometryType;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpeedTreeWindType                            WindType;                                          // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpeedTreeLODType                             LODType;                                           // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BillboardThreshold;                                // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccurateWindVelocities;                           // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSpeedTree">();
	}
	static class UMaterialExpressionSpeedTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSpeedTree>();
	}
};
static_assert(alignof(UMaterialExpressionSpeedTree) == 0x000008, "Wrong alignment on UMaterialExpressionSpeedTree");
static_assert(sizeof(UMaterialExpressionSpeedTree) == 0x000088, "Wrong size on UMaterialExpressionSpeedTree");
static_assert(offsetof(UMaterialExpressionSpeedTree, GeometryType) == 0x000078, "Member 'UMaterialExpressionSpeedTree::GeometryType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSpeedTree, WindType) == 0x000079, "Member 'UMaterialExpressionSpeedTree::WindType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSpeedTree, LODType) == 0x00007A, "Member 'UMaterialExpressionSpeedTree::LODType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSpeedTree, BillboardThreshold) == 0x00007C, "Member 'UMaterialExpressionSpeedTree::BillboardThreshold' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSpeedTree, bAccurateWindVelocities) == 0x000080, "Member 'UMaterialExpressionSpeedTree::bAccurateWindVelocities' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXCameraFadeOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXCameraFadeOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input0;                                            // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXCameraFadeOutput">();
	}
	static class UMaterialExpressionSQEXCameraFadeOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXCameraFadeOutput>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXCameraFadeOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXCameraFadeOutput");
static_assert(sizeof(UMaterialExpressionSQEXCameraFadeOutput) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXCameraFadeOutput");
static_assert(offsetof(UMaterialExpressionSQEXCameraFadeOutput, Input0) == 0x000078, "Member 'UMaterialExpressionSQEXCameraFadeOutput::Input0' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXCharaFadeOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXCharaFadeOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input0;                                            // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXCharaFadeOutput">();
	}
	static class UMaterialExpressionSQEXCharaFadeOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXCharaFadeOutput>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXCharaFadeOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXCharaFadeOutput");
static_assert(sizeof(UMaterialExpressionSQEXCharaFadeOutput) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXCharaFadeOutput");
static_assert(offsetof(UMaterialExpressionSQEXCharaFadeOutput, Input0) == 0x000078, "Member 'UMaterialExpressionSQEXCharaFadeOutput::Input0' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXPostProcessBranchOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXPostProcessBranchOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input0;                                            // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Input1;                                            // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Input2;                                            // 0x00E8(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXPostProcessBranchOutput">();
	}
	static class UMaterialExpressionSQEXPostProcessBranchOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXPostProcessBranchOutput>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXPostProcessBranchOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXPostProcessBranchOutput");
static_assert(sizeof(UMaterialExpressionSQEXPostProcessBranchOutput) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXPostProcessBranchOutput");
static_assert(offsetof(UMaterialExpressionSQEXPostProcessBranchOutput, Input0) == 0x000078, "Member 'UMaterialExpressionSQEXPostProcessBranchOutput::Input0' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSQEXPostProcessBranchOutput, Input1) == 0x0000B0, "Member 'UMaterialExpressionSQEXPostProcessBranchOutput::Input1' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSQEXPostProcessBranchOutput, Input2) == 0x0000E8, "Member 'UMaterialExpressionSQEXPostProcessBranchOutput::Input2' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXReroute
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSQEXReroute final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXReroute">();
	}
	static class UMaterialExpressionSQEXReroute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXReroute>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXReroute) == 0x112F2730, "Wrong alignment on UMaterialExpressionSQEXReroute");
static_assert(sizeof(UMaterialExpressionSQEXReroute) == 0x112F2730, "Wrong size on UMaterialExpressionSQEXReroute");
static_assert(offsetof(UMaterialExpressionSQEXReroute, Input) == 0x000078, "Member 'UMaterialExpressionSQEXReroute::Input' has a wrong offset!");

// Class Engine.MaterialExpressionSQEXTextureSelector
// 0x0028 (0x00A0 - 0x0078)
class UMaterialExpressionSQEXTextureSelector final : public UMaterialExpression
{
public:
	ESQEX_TextureID                               TextureID;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTexture;                                     // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomInclude;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSQEXTextureSelector">();
	}
	static class UMaterialExpressionSQEXTextureSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSQEXTextureSelector>();
	}
};
static_assert(alignof(UMaterialExpressionSQEXTextureSelector) == 0x000008, "Wrong alignment on UMaterialExpressionSQEXTextureSelector");
static_assert(sizeof(UMaterialExpressionSQEXTextureSelector) == 0x0000A0, "Wrong size on UMaterialExpressionSQEXTextureSelector");
static_assert(offsetof(UMaterialExpressionSQEXTextureSelector, TextureID) == 0x000078, "Member 'UMaterialExpressionSQEXTextureSelector::TextureID' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSQEXTextureSelector, CustomTexture) == 0x000080, "Member 'UMaterialExpressionSQEXTextureSelector::CustomTexture' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSQEXTextureSelector, CustomInclude) == 0x000090, "Member 'UMaterialExpressionSQEXTextureSelector::CustomInclude' has a wrong offset!");

// Class Engine.MaterialExpressionSquareRoot
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSquareRoot final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSquareRoot">();
	}
	static class UMaterialExpressionSquareRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSquareRoot>();
	}
};
static_assert(alignof(UMaterialExpressionSquareRoot) == 0x112F2730, "Wrong alignment on UMaterialExpressionSquareRoot");
static_assert(sizeof(UMaterialExpressionSquareRoot) == 0x112F2730, "Wrong size on UMaterialExpressionSquareRoot");
static_assert(offsetof(UMaterialExpressionSquareRoot, Input) == 0x000078, "Member 'UMaterialExpressionSquareRoot::Input' has a wrong offset!");

// Class Engine.MaterialExpressionStaticBool
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionStaticBool final : public UMaterialExpression
{
public:
	uint8                                         Value : 1;                                         // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionStaticBool">();
	}
	static class UMaterialExpressionStaticBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionStaticBool>();
	}
};
static_assert(alignof(UMaterialExpressionStaticBool) == 0x000008, "Wrong alignment on UMaterialExpressionStaticBool");
static_assert(sizeof(UMaterialExpressionStaticBool) == 0x000080, "Wrong size on UMaterialExpressionStaticBool");

// Class Engine.MaterialExpressionStaticBoolParameter
// 0x0000 (0x112E8D20 - 0x112E8D20)
#pragma pack(push, 0x1)
class alignas(0x112E8D20) UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter
{
public:
	uint8                                         DefaultValue : 1;                                  // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionStaticBoolParameter">();
	}
	static class UMaterialExpressionStaticBoolParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionStaticBoolParameter>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMaterialExpressionStaticBoolParameter) == 0x112E8D20, "Wrong alignment on UMaterialExpressionStaticBoolParameter");
static_assert(sizeof(UMaterialExpressionStaticBoolParameter) == 0x112E8D20, "Wrong size on UMaterialExpressionStaticBoolParameter");

// Class Engine.MaterialExpressionStaticComponentMaskParameter
// 0x9A10 (0x112F2730 - 0x112E8D20)
class UMaterialExpressionStaticComponentMaskParameter final : public UMaterialExpressionParameter
{
public:
	struct FExpressionInput                       Input;                                             // 0x0098(0x112F2730)(NativeAccessSpecifierPublic)
	uint8                                         DefaultR : 1;                                      // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DefaultG : 1;                                      // 0x00D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DefaultB : 1;                                      // 0x00D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DefaultA : 1;                                      // 0x00D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionStaticComponentMaskParameter">();
	}
	static class UMaterialExpressionStaticComponentMaskParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionStaticComponentMaskParameter>();
	}
};
static_assert(alignof(UMaterialExpressionStaticComponentMaskParameter) == 0x112F2730, "Wrong alignment on UMaterialExpressionStaticComponentMaskParameter");
static_assert(sizeof(UMaterialExpressionStaticComponentMaskParameter) == 0x112F2730, "Wrong size on UMaterialExpressionStaticComponentMaskParameter");
static_assert(offsetof(UMaterialExpressionStaticComponentMaskParameter, Input) == 0x000098, "Member 'UMaterialExpressionStaticComponentMaskParameter::Input' has a wrong offset!");

// Class Engine.MaterialExpressionStaticSwitch
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionStaticSwitch final : public UMaterialExpression
{
public:
	uint8                                         DefaultValue : 1;                                  // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       A;                                                 // 0x0080(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B8(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Value;                                             // 0x00F0(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionStaticSwitch">();
	}
	static class UMaterialExpressionStaticSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionStaticSwitch>();
	}
};
static_assert(alignof(UMaterialExpressionStaticSwitch) == 0x112F2730, "Wrong alignment on UMaterialExpressionStaticSwitch");
static_assert(sizeof(UMaterialExpressionStaticSwitch) == 0x112F2730, "Wrong size on UMaterialExpressionStaticSwitch");
static_assert(offsetof(UMaterialExpressionStaticSwitch, A) == 0x000080, "Member 'UMaterialExpressionStaticSwitch::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionStaticSwitch, B) == 0x0000B8, "Member 'UMaterialExpressionStaticSwitch::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionStaticSwitch, Value) == 0x0000F0, "Member 'UMaterialExpressionStaticSwitch::Value' has a wrong offset!");

// Class Engine.MaterialExpressionStaticSwitchParameter
// 0x9A10 (0x112F2730 - 0x112E8D20)
class UMaterialExpressionStaticSwitchParameter final : public UMaterialExpressionStaticBoolParameter
{
public:
	struct FExpressionInput                       A;                                                 // 0x00A0(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionStaticSwitchParameter">();
	}
	static class UMaterialExpressionStaticSwitchParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionStaticSwitchParameter>();
	}
};
static_assert(alignof(UMaterialExpressionStaticSwitchParameter) == 0x112F2730, "Wrong alignment on UMaterialExpressionStaticSwitchParameter");
static_assert(sizeof(UMaterialExpressionStaticSwitchParameter) == 0x112F2730, "Wrong size on UMaterialExpressionStaticSwitchParameter");
static_assert(offsetof(UMaterialExpressionStaticSwitchParameter, A) == 0x0000A0, "Member 'UMaterialExpressionStaticSwitchParameter::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionStaticSwitchParameter, B) == 0x0000D8, "Member 'UMaterialExpressionStaticSwitchParameter::B' has a wrong offset!");

// Class Engine.MaterialExpressionSubtract
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionSubtract final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	float                                         ConstA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionSubtract">();
	}
	static class UMaterialExpressionSubtract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionSubtract>();
	}
};
static_assert(alignof(UMaterialExpressionSubtract) == 0x112F2730, "Wrong alignment on UMaterialExpressionSubtract");
static_assert(sizeof(UMaterialExpressionSubtract) == 0x112F2730, "Wrong size on UMaterialExpressionSubtract");
static_assert(offsetof(UMaterialExpressionSubtract, A) == 0x000078, "Member 'UMaterialExpressionSubtract::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSubtract, B) == 0x0000B0, "Member 'UMaterialExpressionSubtract::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSubtract, ConstA) == 0x0000E8, "Member 'UMaterialExpressionSubtract::ConstA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSubtract, ConstB) == 0x0000EC, "Member 'UMaterialExpressionSubtract::ConstB' has a wrong offset!");

// Class Engine.MaterialExpressionTangentOutput
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTangentOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTangentOutput">();
	}
	static class UMaterialExpressionTangentOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTangentOutput>();
	}
};
static_assert(alignof(UMaterialExpressionTangentOutput) == 0x112F2730, "Wrong alignment on UMaterialExpressionTangentOutput");
static_assert(sizeof(UMaterialExpressionTangentOutput) == 0x112F2730, "Wrong size on UMaterialExpressionTangentOutput");
static_assert(offsetof(UMaterialExpressionTangentOutput, Input) == 0x000078, "Member 'UMaterialExpressionTangentOutput::Input' has a wrong offset!");

// Class Engine.MaterialExpressionTemporalSobol
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTemporalSobol final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Index_0;                                           // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	struct FExpressionInput                       Seed;                                              // 0x00B0(0x112F2730)(NativeAccessSpecifierPublic)
	uint32                                        ConstIndex;                                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ConstSeed;                                         // 0x00EC(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTemporalSobol">();
	}
	static class UMaterialExpressionTemporalSobol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTemporalSobol>();
	}
};
static_assert(alignof(UMaterialExpressionTemporalSobol) == 0x112F2730, "Wrong alignment on UMaterialExpressionTemporalSobol");
static_assert(sizeof(UMaterialExpressionTemporalSobol) == 0x112F2730, "Wrong size on UMaterialExpressionTemporalSobol");
static_assert(offsetof(UMaterialExpressionTemporalSobol, Index_0) == 0x000078, "Member 'UMaterialExpressionTemporalSobol::Index_0' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTemporalSobol, Seed) == 0x0000B0, "Member 'UMaterialExpressionTemporalSobol::Seed' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTemporalSobol, ConstIndex) == 0x0000E8, "Member 'UMaterialExpressionTemporalSobol::ConstIndex' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTemporalSobol, ConstSeed) == 0x0000EC, "Member 'UMaterialExpressionTemporalSobol::ConstSeed' has a wrong offset!");

// Class Engine.MaterialExpressionTextureProperty
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTextureProperty final : public UMaterialExpression
{
public:
	struct FExpressionInput                       TextureObject;                                     // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	EMaterialExposedTextureProperty               Property;                                          // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureProperty">();
	}
	static class UMaterialExpressionTextureProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureProperty>();
	}
};
static_assert(alignof(UMaterialExpressionTextureProperty) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureProperty");
static_assert(sizeof(UMaterialExpressionTextureProperty) == 0x112F2730, "Wrong size on UMaterialExpressionTextureProperty");
static_assert(offsetof(UMaterialExpressionTextureProperty, TextureObject) == 0x000078, "Member 'UMaterialExpressionTextureProperty::TextureObject' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTextureProperty, Property) == 0x0000B0, "Member 'UMaterialExpressionTextureProperty::Property' has a wrong offset!");

// Class Engine.MaterialExpressionTextureSampleParameterSubUV
// 0x0000 (0x112F2730 - 0x112F2730)
class UMaterialExpressionTextureSampleParameterSubUV final : public UMaterialExpressionTextureSampleParameter2D
{
public:
	uint8                                         bBlend : 1;                                        // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTextureSampleParameterSubUV">();
	}
	static class UMaterialExpressionTextureSampleParameterSubUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTextureSampleParameterSubUV>();
	}
};
static_assert(alignof(UMaterialExpressionTextureSampleParameterSubUV) == 0x112F2730, "Wrong alignment on UMaterialExpressionTextureSampleParameterSubUV");
static_assert(sizeof(UMaterialExpressionTextureSampleParameterSubUV) == 0x112F2730, "Wrong size on UMaterialExpressionTextureSampleParameterSubUV");

// Class Engine.MaterialExpressionTime
// 0x0010 (0x0088 - 0x0078)
class UMaterialExpressionTime final : public UMaterialExpression
{
public:
	uint8                                         bIgnorePause : 1;                                  // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Period : 1;                              // 0x0078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Period;                                            // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TIME_NODE_TYPE                          SQEXTimeType;                                      // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTime">();
	}
	static class UMaterialExpressionTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTime>();
	}
};
static_assert(alignof(UMaterialExpressionTime) == 0x000008, "Wrong alignment on UMaterialExpressionTime");
static_assert(sizeof(UMaterialExpressionTime) == 0x000088, "Wrong size on UMaterialExpressionTime");
static_assert(offsetof(UMaterialExpressionTime, Period) == 0x00007C, "Member 'UMaterialExpressionTime::Period' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTime, SQEXTimeType) == 0x000080, "Member 'UMaterialExpressionTime::SQEXTimeType' has a wrong offset!");

// Class Engine.MaterialExpressionTransform
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTransform final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	EMaterialVectorCoordTransformSource           TransformSourceType;                               // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialVectorCoordTransform                 TransformType;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTransform">();
	}
	static class UMaterialExpressionTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTransform>();
	}
};
static_assert(alignof(UMaterialExpressionTransform) == 0x112F2730, "Wrong alignment on UMaterialExpressionTransform");
static_assert(sizeof(UMaterialExpressionTransform) == 0x112F2730, "Wrong size on UMaterialExpressionTransform");
static_assert(offsetof(UMaterialExpressionTransform, Input) == 0x000078, "Member 'UMaterialExpressionTransform::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTransform, TransformSourceType) == 0x0000B0, "Member 'UMaterialExpressionTransform::TransformSourceType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTransform, TransformType) == 0x0000B1, "Member 'UMaterialExpressionTransform::TransformType' has a wrong offset!");

// Class Engine.MaterialExpressionTransformPosition
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTransformPosition final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	EMaterialPositionTransformSource              TransformSourceType;                               // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialPositionTransformSource              TransformType;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTransformPosition">();
	}
	static class UMaterialExpressionTransformPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTransformPosition>();
	}
};
static_assert(alignof(UMaterialExpressionTransformPosition) == 0x112F2730, "Wrong alignment on UMaterialExpressionTransformPosition");
static_assert(sizeof(UMaterialExpressionTransformPosition) == 0x112F2730, "Wrong size on UMaterialExpressionTransformPosition");
static_assert(offsetof(UMaterialExpressionTransformPosition, Input) == 0x000078, "Member 'UMaterialExpressionTransformPosition::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTransformPosition, TransformSourceType) == 0x0000B0, "Member 'UMaterialExpressionTransformPosition::TransformSourceType' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionTransformPosition, TransformType) == 0x0000B1, "Member 'UMaterialExpressionTransformPosition::TransformType' has a wrong offset!");

// Class Engine.MaterialExpressionTruncate
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionTruncate final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTruncate">();
	}
	static class UMaterialExpressionTruncate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTruncate>();
	}
};
static_assert(alignof(UMaterialExpressionTruncate) == 0x112F2730, "Wrong alignment on UMaterialExpressionTruncate");
static_assert(sizeof(UMaterialExpressionTruncate) == 0x112F2730, "Wrong size on UMaterialExpressionTruncate");
static_assert(offsetof(UMaterialExpressionTruncate, Input) == 0x000078, "Member 'UMaterialExpressionTruncate::Input' has a wrong offset!");

// Class Engine.MaterialExpressionTwoSidedSign
// 0x0000 (0x0078 - 0x0078)
class UMaterialExpressionTwoSidedSign final : public UMaterialExpression
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionTwoSidedSign">();
	}
	static class UMaterialExpressionTwoSidedSign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionTwoSidedSign>();
	}
};
static_assert(alignof(UMaterialExpressionTwoSidedSign) == 0x000008, "Wrong alignment on UMaterialExpressionTwoSidedSign");
static_assert(sizeof(UMaterialExpressionTwoSidedSign) == 0x000078, "Wrong size on UMaterialExpressionTwoSidedSign");

// Class Engine.MaterialExpressionVectorNoise
// 0x112F26B8 (0x112F2730 - 0x0078)
class UMaterialExpressionVectorNoise final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Position;                                          // 0x0078(0x112F2730)(NativeAccessSpecifierPublic)
	EVectorNoiseFunction                          NoiseFunction;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Quality;                                           // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTiling : 1;                                       // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        TileSize;                                          // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVectorNoise">();
	}
	static class UMaterialExpressionVectorNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVectorNoise>();
	}
};
static_assert(alignof(UMaterialExpressionVectorNoise) == 0x112F2730, "Wrong alignment on UMaterialExpressionVectorNoise");
static_assert(sizeof(UMaterialExpressionVectorNoise) == 0x112F2730, "Wrong size on UMaterialExpressionVectorNoise");
static_assert(offsetof(UMaterialExpressionVectorNoise, Position) == 0x000078, "Member 'UMaterialExpressionVectorNoise::Position' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionVectorNoise, NoiseFunction) == 0x0000B0, "Member 'UMaterialExpressionVectorNoise::NoiseFunction' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionVectorNoise, Quality) == 0x0000B4, "Member 'UMaterialExpressionVectorNoise::Quality' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionVectorNoise, TileSize) == 0x0000BC, "Member 'UMaterialExpressionVectorNoise::TileSize' has a wrong offset!");

// Class Engine.MaterialExpressionVectorParameter
// 0x2160 (0x112EAE80 - 0x112E8D20)
class UMaterialExpressionVectorParameter final : public UMaterialExpressionParameter
{
public:
	struct FLinearColor                           DefaultValue;                                      // 0x0098(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVectorParameter">();
	}
	static class UMaterialExpressionVectorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVectorParameter>();
	}
};
static_assert(alignof(UMaterialExpressionVectorParameter) == 0x112EAE80, "Wrong alignment on UMaterialExpressionVectorParameter");
static_assert(sizeof(UMaterialExpressionVectorParameter) == 0x112EAE80, "Wrong size on UMaterialExpressionVectorParameter");
static_assert(offsetof(UMaterialExpressionVectorParameter, DefaultValue) == 0x000098, "Member 'UMaterialExpressionVectorParameter::DefaultValue' has a wrong offset!");

// Class Engine.MaterialExpressionWorldPosition
// 0x0008 (0x0080 - 0x0078)
class UMaterialExpressionWorldPosition final : public UMaterialExpression
{
public:
	EWorldPositionIncludedOffsets                 WorldPositionShaderOffset;                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionWorldPosition">();
	}
	static class UMaterialExpressionWorldPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionWorldPosition>();
	}
};
static_assert(alignof(UMaterialExpressionWorldPosition) == 0x000008, "Wrong alignment on UMaterialExpressionWorldPosition");
static_assert(sizeof(UMaterialExpressionWorldPosition) == 0x000080, "Wrong size on UMaterialExpressionWorldPosition");
static_assert(offsetof(UMaterialExpressionWorldPosition, WorldPositionShaderOffset) == 0x000078, "Member 'UMaterialExpressionWorldPosition::WorldPositionShaderOffset' has a wrong offset!");

// Class Engine.MaterialFunction
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class UMaterialFunction final : public UObject
{
public:
	struct FGuid                                  StateID;                                           // 0x0040(0x112E8D20)(DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bExposeToLibrary : 1;                              // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialExpression*>            FunctionExpressions;                               // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bReentrantFlag : 1;                                // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialFunction">();
	}
	static class UMaterialFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialFunction>();
	}
};
static_assert(alignof(UMaterialFunction) == 0x112E8D20, "Wrong alignment on UMaterialFunction");
static_assert(sizeof(UMaterialFunction) == 0x112E8D20, "Wrong size on UMaterialFunction");
static_assert(offsetof(UMaterialFunction, StateID) == 0x000040, "Member 'UMaterialFunction::StateID' has a wrong offset!");
static_assert(offsetof(UMaterialFunction, Description) == 0x000050, "Member 'UMaterialFunction::Description' has a wrong offset!");
static_assert(offsetof(UMaterialFunction, FunctionExpressions) == 0x000068, "Member 'UMaterialFunction::FunctionExpressions' has a wrong offset!");

// Class Engine.MaterialParameterCollection
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class UMaterialParameterCollection final : public UObject
{
public:
	struct FGuid                                  StateID;                                           // 0x0040(0x112E8D20)(DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCollectionScalarParameter>     ScalarParameters;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCollectionVectorParameter>     VectorParameters;                                  // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialParameterCollection">();
	}
	static class UMaterialParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialParameterCollection>();
	}
};
static_assert(alignof(UMaterialParameterCollection) == 0x112E8D20, "Wrong alignment on UMaterialParameterCollection");
static_assert(sizeof(UMaterialParameterCollection) == 0x112E8D20, "Wrong size on UMaterialParameterCollection");
static_assert(offsetof(UMaterialParameterCollection, StateID) == 0x000040, "Member 'UMaterialParameterCollection::StateID' has a wrong offset!");
static_assert(offsetof(UMaterialParameterCollection, ScalarParameters) == 0x000050, "Member 'UMaterialParameterCollection::ScalarParameters' has a wrong offset!");
static_assert(offsetof(UMaterialParameterCollection, VectorParameters) == 0x000060, "Member 'UMaterialParameterCollection::VectorParameters' has a wrong offset!");

// Class Engine.MaterialParameterCollectionInstance
// 0x00C0 (0x0100 - 0x0040)
class UMaterialParameterCollectionInstance final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           Collection;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xA8];                                      // 0x0058(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialParameterCollectionInstance">();
	}
	static class UMaterialParameterCollectionInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialParameterCollectionInstance>();
	}
};
static_assert(alignof(UMaterialParameterCollectionInstance) == 0x000008, "Wrong alignment on UMaterialParameterCollectionInstance");
static_assert(sizeof(UMaterialParameterCollectionInstance) == 0x000100, "Wrong size on UMaterialParameterCollectionInstance");
static_assert(offsetof(UMaterialParameterCollectionInstance, Collection) == 0x000048, "Member 'UMaterialParameterCollectionInstance::Collection' has a wrong offset!");
static_assert(offsetof(UMaterialParameterCollectionInstance, World) == 0x000050, "Member 'UMaterialParameterCollectionInstance::World' has a wrong offset!");

// Class Engine.MatineeActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
#pragma pack(push, 0x1)
class alignas(0x1EF72E00) AMatineeActor : public AActor
{
public:
	class UInterpData*                            MatineeData;                                       // 0x03E0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MatineeControllerName;                             // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x03F0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnLevelLoad : 1;                              // 0x03F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceStartPos : 1;                                // 0x03F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceStartPosition;                                // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x03FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRewindOnPlay : 1;                                 // 0x03FC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoResetOnRewind : 1;                              // 0x03FC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRewindIfAlreadyPlaying : 1;                       // 0x03FC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableRadioFilter : 1;                           // 0x03FC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientSideOnly : 1;                               // 0x03FC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipUpdateIfNotVisible : 1;                       // 0x03FC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSkippable : 1;                                  // 0x03FC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3FD[0x3];                                      // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreferredSplitScreenNum;                           // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableMovementInput : 1;                         // 0x0404(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableLookAtInput : 1;                           // 0x0404(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHidePlayer : 1;                                   // 0x0404(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideHud : 1;                                      // 0x0404(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInterpGroupActorInfo>          GroupActorInfos;                                   // 0x0408(0x0010)(Edit, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bShouldShowGore : 1;                               // 0x0418(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInterpGroupInst*>               GroupInst;                                         // 0x0420(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FCameraCutInfo>                 CameraCuts;                                        // 0x0430(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         bIsPlaying : 1;                                    // 0x0440(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_InPlayProcess;                                   // 0x0444(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bReversePlayback : 1;                              // 0x0448(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPaused : 1;                                       // 0x0448(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPendingStop : 1;                                  // 0x0448(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpPosition;                                    // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USQEXMatineeActorAsset*>         M_MatineeActorAssets;                              // 0x0450(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_ImmediatePlay;                                   // 0x0460(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_TickDuringPause;                                 // 0x0461(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_ControlGarbageCollection;                        // 0x0462(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_463[0x1];                                      // 0x0463(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_GarbageCollectionTime;                           // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_Waiting;                                         // 0x0468(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_IgnoreDeltaTime;                                 // 0x0469(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_CooperationOnMovie;                              // 0x046A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46B[0x5];                                      // 0x046B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReplicationForceIsPlaying;                         // 0x0470(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlay;                                            // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnStop;                                            // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPause;                                           // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x28];                                     // 0x04A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisableChildrenCollsion_;                          // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D1[0x17];                                     // 0x04D1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePlaybackDirection();
	void EnableGroupByName(const class FString& GroupName, bool bEnable);
	void Pause();
	void Play();
	void Reverse();
	void SetGroupActors(class FName GroupName, const TArray<class AActor*>& Actors);
	void SetLoopingState(bool bNewLooping);
	void SetPosition(float NewPosition, bool bJump);
	void SQEX_AbortTrack(class AActor* InActor, TSubclassOf<class UInterpTrack> TrackClass);
	class USQEXMatineeActorAsset* SQEX_GetAsset(TSubclassOf<class USQEXMatineeActorAsset> AssetClass);
	bool SQEX_IsImmediatePlay();
	void SQEX_SetActorLocationAtEndFrame();
	void SQEX_SetMaterialParameterAtEndFrame();
	void SQEX_SetTrackDisable(class FName GroupName, const class FString& TrackTitle, bool NewDisable);
	void SQEX_SetVisibilityAtEndFrame();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatineeActor">();
	}
	static class AMatineeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatineeActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMatineeActor) == 0x1EF72E00, "Wrong alignment on AMatineeActor");
static_assert(sizeof(AMatineeActor) == 0x1EF72E00, "Wrong size on AMatineeActor");
static_assert(offsetof(AMatineeActor, MatineeData) == 0x0003E0, "Member 'AMatineeActor::MatineeData' has a wrong offset!");
static_assert(offsetof(AMatineeActor, MatineeControllerName) == 0x0003E8, "Member 'AMatineeActor::MatineeControllerName' has a wrong offset!");
static_assert(offsetof(AMatineeActor, PlayRate) == 0x0003F0, "Member 'AMatineeActor::PlayRate' has a wrong offset!");
static_assert(offsetof(AMatineeActor, ForceStartPosition) == 0x0003F8, "Member 'AMatineeActor::ForceStartPosition' has a wrong offset!");
static_assert(offsetof(AMatineeActor, PreferredSplitScreenNum) == 0x000400, "Member 'AMatineeActor::PreferredSplitScreenNum' has a wrong offset!");
static_assert(offsetof(AMatineeActor, GroupActorInfos) == 0x000408, "Member 'AMatineeActor::GroupActorInfos' has a wrong offset!");
static_assert(offsetof(AMatineeActor, GroupInst) == 0x000420, "Member 'AMatineeActor::GroupInst' has a wrong offset!");
static_assert(offsetof(AMatineeActor, CameraCuts) == 0x000430, "Member 'AMatineeActor::CameraCuts' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_InPlayProcess) == 0x000444, "Member 'AMatineeActor::M_InPlayProcess' has a wrong offset!");
static_assert(offsetof(AMatineeActor, InterpPosition) == 0x00044C, "Member 'AMatineeActor::InterpPosition' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_MatineeActorAssets) == 0x000450, "Member 'AMatineeActor::M_MatineeActorAssets' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_ImmediatePlay) == 0x000460, "Member 'AMatineeActor::M_ImmediatePlay' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_TickDuringPause) == 0x000461, "Member 'AMatineeActor::M_TickDuringPause' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_ControlGarbageCollection) == 0x000462, "Member 'AMatineeActor::M_ControlGarbageCollection' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_GarbageCollectionTime) == 0x000464, "Member 'AMatineeActor::M_GarbageCollectionTime' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_Waiting) == 0x000468, "Member 'AMatineeActor::M_Waiting' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_IgnoreDeltaTime) == 0x000469, "Member 'AMatineeActor::M_IgnoreDeltaTime' has a wrong offset!");
static_assert(offsetof(AMatineeActor, M_CooperationOnMovie) == 0x00046A, "Member 'AMatineeActor::M_CooperationOnMovie' has a wrong offset!");
static_assert(offsetof(AMatineeActor, ReplicationForceIsPlaying) == 0x000470, "Member 'AMatineeActor::ReplicationForceIsPlaying' has a wrong offset!");
static_assert(offsetof(AMatineeActor, OnPlay) == 0x000478, "Member 'AMatineeActor::OnPlay' has a wrong offset!");
static_assert(offsetof(AMatineeActor, OnStop) == 0x000488, "Member 'AMatineeActor::OnStop' has a wrong offset!");
static_assert(offsetof(AMatineeActor, OnPause) == 0x000498, "Member 'AMatineeActor::OnPause' has a wrong offset!");
static_assert(offsetof(AMatineeActor, DisableChildrenCollsion_) == 0x0004D0, "Member 'AMatineeActor::DisableChildrenCollsion_' has a wrong offset!");

// Class Engine.MatineeActorCameraAnim
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMatineeActorCameraAnim final : public AMatineeActor
{
public:
	class UCameraAnim*                            CameraAnim;                                        // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatineeActorCameraAnim">();
	}
	static class AMatineeActorCameraAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatineeActorCameraAnim>();
	}
};
static_assert(alignof(AMatineeActorCameraAnim) == 0x1EF72E00, "Wrong alignment on AMatineeActorCameraAnim");
static_assert(sizeof(AMatineeActorCameraAnim) == 0x1EF72E00, "Wrong size on AMatineeActorCameraAnim");
static_assert(offsetof(AMatineeActorCameraAnim, CameraAnim) == 0x0004E8, "Member 'AMatineeActorCameraAnim::CameraAnim' has a wrong offset!");

// Class Engine.MatineeInterface
// 0x0000 (0x0040 - 0x0040)
class IMatineeInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatineeInterface">();
	}
	static class IMatineeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatineeInterface>();
	}
};
static_assert(alignof(IMatineeInterface) == 0x000008, "Wrong alignment on IMatineeInterface");
static_assert(sizeof(IMatineeInterface) == 0x000040, "Wrong size on IMatineeInterface");

// Class Engine.MeshSimplificationSettings
// 0x0008 (0x0058 - 0x0050)
class UMeshSimplificationSettings final : public UDeveloperSettings
{
public:
	class FName                                   MeshReductionModuleName;                           // 0x0050(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSimplificationSettings">();
	}
	static class UMeshSimplificationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSimplificationSettings>();
	}
};
static_assert(alignof(UMeshSimplificationSettings) == 0x000008, "Wrong alignment on UMeshSimplificationSettings");
static_assert(sizeof(UMeshSimplificationSettings) == 0x000058, "Wrong size on UMeshSimplificationSettings");
static_assert(offsetof(UMeshSimplificationSettings, MeshReductionModuleName) == 0x000050, "Member 'UMeshSimplificationSettings::MeshReductionModuleName' has a wrong offset!");

// Class Engine.MeshVertexPainterKismetLibrary
// 0x0000 (0x0040 - 0x0040)
class UMeshVertexPainterKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PaintVerticesLerpAlongAxis(class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& StartColor, const struct FLinearColor& EndColor, EVertexPaintAxis Axis, bool bConvertToSRGB);
	static void PaintVerticesSingleColor(class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& FillColor, bool bConvertToSRGB);
	static void RemovePaintedVertices(class UStaticMeshComponent* StaticMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexPainterKismetLibrary">();
	}
	static class UMeshVertexPainterKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexPainterKismetLibrary>();
	}
};
static_assert(alignof(UMeshVertexPainterKismetLibrary) == 0x000008, "Wrong alignment on UMeshVertexPainterKismetLibrary");
static_assert(sizeof(UMeshVertexPainterKismetLibrary) == 0x000040, "Wrong size on UMeshVertexPainterKismetLibrary");

// Class Engine.MicroTransactionBase
// 0x0030 (0x0080 - 0x0050)
class UMicroTransactionBase final : public UPlatformInterfaceBase
{
public:
	TArray<struct FPurchaseInfo>                  AvailableProducts;                                 // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 LastError;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastErrorSolution;                                 // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MicroTransactionBase">();
	}
	static class UMicroTransactionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMicroTransactionBase>();
	}
};
static_assert(alignof(UMicroTransactionBase) == 0x000008, "Wrong alignment on UMicroTransactionBase");
static_assert(sizeof(UMicroTransactionBase) == 0x000080, "Wrong size on UMicroTransactionBase");
static_assert(offsetof(UMicroTransactionBase, AvailableProducts) == 0x000050, "Member 'UMicroTransactionBase::AvailableProducts' has a wrong offset!");
static_assert(offsetof(UMicroTransactionBase, LastError) == 0x000060, "Member 'UMicroTransactionBase::LastError' has a wrong offset!");
static_assert(offsetof(UMicroTransactionBase, LastErrorSolution) == 0x000070, "Member 'UMicroTransactionBase::LastErrorSolution' has a wrong offset!");

// Class Engine.NavAgentInterface
// 0x0000 (0x0040 - 0x0040)
class INavAgentInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavAgentInterface">();
	}
	static class INavAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavAgentInterface>();
	}
};
static_assert(alignof(INavAgentInterface) == 0x000008, "Wrong alignment on INavAgentInterface");
static_assert(sizeof(INavAgentInterface) == 0x000040, "Wrong size on INavAgentInterface");

// Class Engine.NavArea_Default
// 0x0000 (0x0058 - 0x0058)
class UNavArea_Default final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Default">();
	}
	static class UNavArea_Default* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Default>();
	}
};
static_assert(alignof(UNavArea_Default) == 0x000008, "Wrong alignment on UNavArea_Default");
static_assert(sizeof(UNavArea_Default) == 0x000058, "Wrong size on UNavArea_Default");

// Class Engine.NavArea_Null
// 0x0000 (0x0058 - 0x0058)
class UNavArea_Null final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Null">();
	}
	static class UNavArea_Null* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Null>();
	}
};
static_assert(alignof(UNavArea_Null) == 0x000008, "Wrong alignment on UNavArea_Null");
static_assert(sizeof(UNavArea_Null) == 0x000058, "Wrong size on UNavArea_Null");

// Class Engine.NavArea_Obstacle
// 0x0000 (0x0058 - 0x0058)
class UNavArea_Obstacle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Obstacle">();
	}
	static class UNavArea_Obstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Obstacle>();
	}
};
static_assert(alignof(UNavArea_Obstacle) == 0x000008, "Wrong alignment on UNavArea_Obstacle");
static_assert(sizeof(UNavArea_Obstacle) == 0x000058, "Wrong size on UNavArea_Obstacle");

// Class Engine.NavEdgeProviderInterface
// 0x0000 (0x0040 - 0x0040)
class INavEdgeProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavEdgeProviderInterface">();
	}
	static class INavEdgeProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavEdgeProviderInterface>();
	}
};
static_assert(alignof(INavEdgeProviderInterface) == 0x000008, "Wrong alignment on INavEdgeProviderInterface");
static_assert(sizeof(INavEdgeProviderInterface) == 0x000040, "Wrong size on INavEdgeProviderInterface");

// Class Engine.NavigationGraphNode
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ANavigationGraphNode final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationGraphNode">();
	}
	static class ANavigationGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationGraphNode>();
	}
};
static_assert(alignof(ANavigationGraphNode) == 0x1EF72E00, "Wrong alignment on ANavigationGraphNode");
static_assert(sizeof(ANavigationGraphNode) == 0x1EF72E00, "Wrong size on ANavigationGraphNode");

// Class Engine.NavigationInvokerComponent
// 0x0000 (0xD38D - 0xD38D)
class UNavigationInvokerComponent final : public UActorComponent
{
public:
	float                                         TileGenerationRadius;                              // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TileRemovalRadius;                                 // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationInvokerComponent">();
	}
	static class UNavigationInvokerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationInvokerComponent>();
	}
};
static_assert(alignof(UNavigationInvokerComponent) == 0x00D38D, "Wrong alignment on UNavigationInvokerComponent");
static_assert(sizeof(UNavigationInvokerComponent) == 0x00D38D, "Wrong size on UNavigationInvokerComponent");
static_assert(offsetof(UNavigationInvokerComponent, TileGenerationRadius) == 0x000200, "Member 'UNavigationInvokerComponent::TileGenerationRadius' has a wrong offset!");
static_assert(offsetof(UNavigationInvokerComponent, TileRemovalRadius) == 0x000204, "Member 'UNavigationInvokerComponent::TileRemovalRadius' has a wrong offset!");

// Class Engine.NavigationTestingActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ANavigationTestingActor final : public AActor
{
public:
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavigationInvokerComponent*            InvokerComponent;                                  // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bActAsNavigationInvoker : 1;                       // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavAgentProperties                    NavAgentProps;                                     // 0x0408(0x12A61)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryingExtent;                                    // 0x0428(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        MyNavData;                                         // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectedLocation;                                 // 0x0440(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bProjectedLocationValid : 1;                       // 0x044C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSearchStart : 1;                                  // 0x044C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHierarchicalPathfinding : 1;                   // 0x044C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGatherDetailedInfo : 1;                           // 0x044C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDistanceToWall : 1;                           // 0x044C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowNodePool : 1;                                 // 0x044C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowBestPath : 1;                                 // 0x044C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowDiffWithPreviousStep : 1;                     // 0x044C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShouldBeVisibleInGame : 1;                        // 0x044D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_44E[0x2];                                      // 0x044E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ENavCostDisplay                               CostDisplayMode;                                   // 0x0450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TextCanvasOffset;                                  // 0x0454(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPathExist : 1;                                    // 0x045C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsPartial : 1;                                // 0x045C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathSearchOutOfNodes : 1;                         // 0x045C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45D[0x3];                                      // 0x045D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathfindingTime;                                   // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathCost;                                          // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathfindingSteps;                                  // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationTestingActor*                OtherActor;                                        // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowStepIndex;                                     // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromCornersDistance;                         // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x68];                                     // 0x0488(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationTestingActor">();
	}
	static class ANavigationTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationTestingActor>();
	}
};
static_assert(alignof(ANavigationTestingActor) == 0x1EF72E00, "Wrong alignment on ANavigationTestingActor");
static_assert(sizeof(ANavigationTestingActor) == 0x1EF72E00, "Wrong size on ANavigationTestingActor");
static_assert(offsetof(ANavigationTestingActor, CapsuleComponent) == 0x0003F0, "Member 'ANavigationTestingActor::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, InvokerComponent) == 0x0003F8, "Member 'ANavigationTestingActor::InvokerComponent' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, NavAgentProps) == 0x000408, "Member 'ANavigationTestingActor::NavAgentProps' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, QueryingExtent) == 0x000428, "Member 'ANavigationTestingActor::QueryingExtent' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, MyNavData) == 0x000438, "Member 'ANavigationTestingActor::MyNavData' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, ProjectedLocation) == 0x000440, "Member 'ANavigationTestingActor::ProjectedLocation' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, CostDisplayMode) == 0x000450, "Member 'ANavigationTestingActor::CostDisplayMode' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, TextCanvasOffset) == 0x000454, "Member 'ANavigationTestingActor::TextCanvasOffset' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, PathfindingTime) == 0x000460, "Member 'ANavigationTestingActor::PathfindingTime' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, PathCost) == 0x000464, "Member 'ANavigationTestingActor::PathCost' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, PathfindingSteps) == 0x000468, "Member 'ANavigationTestingActor::PathfindingSteps' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, OtherActor) == 0x000470, "Member 'ANavigationTestingActor::OtherActor' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, FilterClass) == 0x000478, "Member 'ANavigationTestingActor::FilterClass' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, ShowStepIndex) == 0x000480, "Member 'ANavigationTestingActor::ShowStepIndex' has a wrong offset!");
static_assert(offsetof(ANavigationTestingActor, OffsetFromCornersDistance) == 0x000484, "Member 'ANavigationTestingActor::OffsetFromCornersDistance' has a wrong offset!");

// Class Engine.NavigationTypes
// 0x0000 (0x0040 - 0x0040)
class UNavigationTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationTypes">();
	}
	static class UNavigationTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationTypes>();
	}
};
static_assert(alignof(UNavigationTypes) == 0x000008, "Wrong alignment on UNavigationTypes");
static_assert(sizeof(UNavigationTypes) == 0x000040, "Wrong size on UNavigationTypes");

// Class Engine.NavLinkDefinition
// 0x0028 (0x0068 - 0x0040)
class UNavLinkDefinition : public UObject
{
public:
	TArray<struct FNavigationLink>                Links;                                             // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavigationSegmentLink>         SegmentLinks;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkDefinition">();
	}
	static class UNavLinkDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkDefinition>();
	}
};
static_assert(alignof(UNavLinkDefinition) == 0x000008, "Wrong alignment on UNavLinkDefinition");
static_assert(sizeof(UNavLinkDefinition) == 0x000068, "Wrong size on UNavLinkDefinition");
static_assert(offsetof(UNavLinkDefinition, Links) == 0x000040, "Member 'UNavLinkDefinition::Links' has a wrong offset!");
static_assert(offsetof(UNavLinkDefinition, SegmentLinks) == 0x000050, "Member 'UNavLinkDefinition::SegmentLinks' has a wrong offset!");

// Class Engine.NavLinkRenderingComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UNavLinkRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkRenderingComponent">();
	}
	static class UNavLinkRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkRenderingComponent>();
	}
};
static_assert(alignof(UNavLinkRenderingComponent) == 0x112E9AF0, "Wrong alignment on UNavLinkRenderingComponent");
static_assert(sizeof(UNavLinkRenderingComponent) == 0x112E9AF0, "Wrong size on UNavLinkRenderingComponent");

// Class Engine.NavLinkTrivial
// 0x0000 (0x0068 - 0x0068)
class UNavLinkTrivial final : public UNavLinkDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkTrivial">();
	}
	static class UNavLinkTrivial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavLinkTrivial>();
	}
};
static_assert(alignof(UNavLinkTrivial) == 0x000008, "Wrong alignment on UNavLinkTrivial");
static_assert(sizeof(UNavLinkTrivial) == 0x000068, "Wrong size on UNavLinkTrivial");

// Class Engine.NavMeshBoundsVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ANavMeshBoundsVolume final : public AVolume
{
public:
	struct FNavAgentSelector                      SupportedAgents;                                   // 0x0420(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshBoundsVolume">();
	}
	static class ANavMeshBoundsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavMeshBoundsVolume>();
	}
};
static_assert(alignof(ANavMeshBoundsVolume) == 0x1EF72E00, "Wrong alignment on ANavMeshBoundsVolume");
static_assert(sizeof(ANavMeshBoundsVolume) == 0x1EF72E00, "Wrong size on ANavMeshBoundsVolume");
static_assert(offsetof(ANavMeshBoundsVolume, SupportedAgents) == 0x000420, "Member 'ANavMeshBoundsVolume::SupportedAgents' has a wrong offset!");

// Class Engine.NavModifierVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ANavModifierVolume final : public AVolume
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAreaClassToChangeWhenSpawned;                     // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   ChangeAreaClass;                                   // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEditorOnlyForActor;                             // 0x0440(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAreaClass(TSubclassOf<class UNavArea> NewAreaClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavModifierVolume">();
	}
	static class ANavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavModifierVolume>();
	}
};
static_assert(alignof(ANavModifierVolume) == 0x1EF72E00, "Wrong alignment on ANavModifierVolume");
static_assert(sizeof(ANavModifierVolume) == 0x1EF72E00, "Wrong size on ANavModifierVolume");
static_assert(offsetof(ANavModifierVolume, AreaClass) == 0x000428, "Member 'ANavModifierVolume::AreaClass' has a wrong offset!");
static_assert(offsetof(ANavModifierVolume, bAreaClassToChangeWhenSpawned) == 0x000430, "Member 'ANavModifierVolume::bAreaClassToChangeWhenSpawned' has a wrong offset!");
static_assert(offsetof(ANavModifierVolume, ChangeAreaClass) == 0x000438, "Member 'ANavModifierVolume::ChangeAreaClass' has a wrong offset!");
static_assert(offsetof(ANavModifierVolume, bIsEditorOnlyForActor) == 0x000440, "Member 'ANavModifierVolume::bIsEditorOnlyForActor' has a wrong offset!");

// Class Engine.NavPathObserverInterface
// 0x0000 (0x0040 - 0x0040)
class INavPathObserverInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavPathObserverInterface">();
	}
	static class INavPathObserverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INavPathObserverInterface>();
	}
};
static_assert(alignof(INavPathObserverInterface) == 0x000008, "Wrong alignment on INavPathObserverInterface");
static_assert(sizeof(INavPathObserverInterface) == 0x000040, "Wrong size on INavPathObserverInterface");

// Class Engine.NetworkPredictionInterface
// 0x0000 (0x0040 - 0x0040)
class INetworkPredictionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkPredictionInterface">();
	}
	static class INetworkPredictionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INetworkPredictionInterface>();
	}
};
static_assert(alignof(INetworkPredictionInterface) == 0x000008, "Wrong alignment on INetworkPredictionInterface");
static_assert(sizeof(INetworkPredictionInterface) == 0x000040, "Wrong size on INetworkPredictionInterface");

// Class Engine.NodeMappingProviderInterface
// 0x0000 (0x0040 - 0x0040)
class INodeMappingProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodeMappingProviderInterface">();
	}
	static class INodeMappingProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INodeMappingProviderInterface>();
	}
};
static_assert(alignof(INodeMappingProviderInterface) == 0x000008, "Wrong alignment on INodeMappingProviderInterface");
static_assert(sizeof(INodeMappingProviderInterface) == 0x000040, "Wrong size on INodeMappingProviderInterface");

// Class Engine.ObjectLibrary
// 0x0130 (0x0170 - 0x0040)
class UObjectLibrary final : public UObject
{
public:
	class UClass*                                 ObjectBaseClass;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBlueprintClasses;                              // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        Objects;                                           // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UObject>>         WeakObjects;                                       // 0x0060(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bUseWeakReferences;                                // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFullyLoaded;                                    // 0x0071(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72[0xFE];                                      // 0x0072(0x00FE)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectLibrary">();
	}
	static class UObjectLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectLibrary>();
	}
};
static_assert(alignof(UObjectLibrary) == 0x000008, "Wrong alignment on UObjectLibrary");
static_assert(sizeof(UObjectLibrary) == 0x000170, "Wrong size on UObjectLibrary");
static_assert(offsetof(UObjectLibrary, ObjectBaseClass) == 0x000040, "Member 'UObjectLibrary::ObjectBaseClass' has a wrong offset!");
static_assert(offsetof(UObjectLibrary, bHasBlueprintClasses) == 0x000048, "Member 'UObjectLibrary::bHasBlueprintClasses' has a wrong offset!");
static_assert(offsetof(UObjectLibrary, Objects) == 0x000050, "Member 'UObjectLibrary::Objects' has a wrong offset!");
static_assert(offsetof(UObjectLibrary, WeakObjects) == 0x000060, "Member 'UObjectLibrary::WeakObjects' has a wrong offset!");
static_assert(offsetof(UObjectLibrary, bUseWeakReferences) == 0x000070, "Member 'UObjectLibrary::bUseWeakReferences' has a wrong offset!");
static_assert(offsetof(UObjectLibrary, bIsFullyLoaded) == 0x000071, "Member 'UObjectLibrary::bIsFullyLoaded' has a wrong offset!");

// Class Engine.ObjectReferencer
// 0x0010 (0x0050 - 0x0040)
class UObjectReferencer final : public UObject
{
public:
	TArray<class UObject*>                        ReferencedObjects;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReferencer">();
	}
	static class UObjectReferencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReferencer>();
	}
};
static_assert(alignof(UObjectReferencer) == 0x000008, "Wrong alignment on UObjectReferencer");
static_assert(sizeof(UObjectReferencer) == 0x000050, "Wrong size on UObjectReferencer");
static_assert(offsetof(UObjectReferencer, ReferencedObjects) == 0x000040, "Member 'UObjectReferencer::ReferencedObjects' has a wrong offset!");

// Class Engine.OnlineEngineInterface
// 0x0000 (0x0040 - 0x0040)
class UOnlineEngineInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineEngineInterface">();
	}
	static class UOnlineEngineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineEngineInterface>();
	}
};
static_assert(alignof(UOnlineEngineInterface) == 0x000008, "Wrong alignment on UOnlineEngineInterface");
static_assert(sizeof(UOnlineEngineInterface) == 0x000040, "Wrong size on UOnlineEngineInterface");

// Class Engine.OnlineSession
// 0x0000 (0x0040 - 0x0040)
class UOnlineSession : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSession">();
	}
	static class UOnlineSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSession>();
	}
};
static_assert(alignof(UOnlineSession) == 0x000008, "Wrong alignment on UOnlineSession");
static_assert(sizeof(UOnlineSession) == 0x000040, "Wrong size on UOnlineSession");

// Class Engine.PackageMapClient
// 0x0290 (0x0388 - 0x00F8)
class UPackageMapClient final : public UPackageMap
{
public:
	uint8                                         Pad_F8[0x290];                                     // 0x00F8(0x0290)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageMapClient">();
	}
	static class UPackageMapClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackageMapClient>();
	}
};
static_assert(alignof(UPackageMapClient) == 0x000008, "Wrong alignment on UPackageMapClient");
static_assert(sizeof(UPackageMapClient) == 0x000388, "Wrong size on UPackageMapClient");

// Class Engine.ParticleEventManager
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AParticleEventManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleEventManager">();
	}
	static class AParticleEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParticleEventManager>();
	}
};
static_assert(alignof(AParticleEventManager) == 0x1EF72E00, "Wrong alignment on AParticleEventManager");
static_assert(sizeof(AParticleEventManager) == 0x1EF72E00, "Wrong size on AParticleEventManager");

// Class Engine.ParticleLODLevel
// 0x00B0 (0x00F0 - 0x0040)
class UParticleLODLevel final : public UObject
{
public:
	int32                                         Level;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleModuleRequired*                RequiredModule;                                    // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                Modules;                                           // 0x0050(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleModuleTypeDataBase*            TypeDataModule;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleModuleSpawn*                   SpawnModule;                                       // 0x0068(0x0008)(ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleModuleEventGenerator*          EventGenerator;                                    // 0x0070(0x0008)(ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleModuleSpawnBase*>       SpawningModules;                                   // 0x0078(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                SpawnModules;                                      // 0x0088(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                UpdateModules;                                     // 0x0098(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                FinalTickUpdateModules;                            // 0x00A8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                ParticleUpdateMosules;                             // 0x00B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UParticleModuleOrbit*>           OrbitModules;                                      // 0x00C8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UParticleModuleEventReceiverBase*> EventReceiverModules;                              // 0x00D8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	uint8                                         ConvertedModules : 1;                              // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PeakActiveParticles;                               // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleLODLevel">();
	}
	static class UParticleLODLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleLODLevel>();
	}
};
static_assert(alignof(UParticleLODLevel) == 0x000008, "Wrong alignment on UParticleLODLevel");
static_assert(sizeof(UParticleLODLevel) == 0x0000F0, "Wrong size on UParticleLODLevel");
static_assert(offsetof(UParticleLODLevel, Level) == 0x000040, "Member 'UParticleLODLevel::Level' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, RequiredModule) == 0x000048, "Member 'UParticleLODLevel::RequiredModule' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, Modules) == 0x000050, "Member 'UParticleLODLevel::Modules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, TypeDataModule) == 0x000060, "Member 'UParticleLODLevel::TypeDataModule' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, SpawnModule) == 0x000068, "Member 'UParticleLODLevel::SpawnModule' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, EventGenerator) == 0x000070, "Member 'UParticleLODLevel::EventGenerator' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, SpawningModules) == 0x000078, "Member 'UParticleLODLevel::SpawningModules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, SpawnModules) == 0x000088, "Member 'UParticleLODLevel::SpawnModules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, UpdateModules) == 0x000098, "Member 'UParticleLODLevel::UpdateModules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, FinalTickUpdateModules) == 0x0000A8, "Member 'UParticleLODLevel::FinalTickUpdateModules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, ParticleUpdateMosules) == 0x0000B8, "Member 'UParticleLODLevel::ParticleUpdateMosules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, OrbitModules) == 0x0000C8, "Member 'UParticleLODLevel::OrbitModules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, EventReceiverModules) == 0x0000D8, "Member 'UParticleLODLevel::EventReceiverModules' has a wrong offset!");
static_assert(offsetof(UParticleLODLevel, PeakActiveParticles) == 0x0000EC, "Member 'UParticleLODLevel::PeakActiveParticles' has a wrong offset!");

// Class Engine.ParticleModuleAccelerationConstant
// 0x0010 (0x0068 - 0x0058)
class UParticleModuleAccelerationConstant final : public UParticleModuleAccelerationBase
{
public:
	struct FVector                                Acceleration;                                      // 0x0058(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAccelerationConstant">();
	}
	static class UParticleModuleAccelerationConstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAccelerationConstant>();
	}
};
static_assert(alignof(UParticleModuleAccelerationConstant) == 0x000008, "Wrong alignment on UParticleModuleAccelerationConstant");
static_assert(sizeof(UParticleModuleAccelerationConstant) == 0x000068, "Wrong size on UParticleModuleAccelerationConstant");
static_assert(offsetof(UParticleModuleAccelerationConstant, Acceleration) == 0x000058, "Member 'UParticleModuleAccelerationConstant::Acceleration' has a wrong offset!");

// Class Engine.ParticleModuleAccelerationDrag
// 0x0040 (0x0098 - 0x0058)
class UParticleModuleAccelerationDrag final : public UParticleModuleAccelerationBase
{
public:
	class UDistributionFloat*                     DragCoefficient;                                   // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DragCoefficientRaw;                                // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAccelerationDrag">();
	}
	static class UParticleModuleAccelerationDrag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAccelerationDrag>();
	}
};
static_assert(alignof(UParticleModuleAccelerationDrag) == 0x000008, "Wrong alignment on UParticleModuleAccelerationDrag");
static_assert(sizeof(UParticleModuleAccelerationDrag) == 0x000098, "Wrong size on UParticleModuleAccelerationDrag");
static_assert(offsetof(UParticleModuleAccelerationDrag, DragCoefficient) == 0x000058, "Member 'UParticleModuleAccelerationDrag::DragCoefficient' has a wrong offset!");
static_assert(offsetof(UParticleModuleAccelerationDrag, DragCoefficientRaw) == 0x000060, "Member 'UParticleModuleAccelerationDrag::DragCoefficientRaw' has a wrong offset!");

// Class Engine.ParticleModuleAccelerationOverLifetime
// 0x0050 (0x00A8 - 0x0058)
class UParticleModuleAccelerationOverLifetime final : public UParticleModuleAccelerationBase
{
public:
	struct FRawDistributionVector                 AccelOverLife;                                     // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAccelerationOverLifetime">();
	}
	static class UParticleModuleAccelerationOverLifetime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAccelerationOverLifetime>();
	}
};
static_assert(alignof(UParticleModuleAccelerationOverLifetime) == 0x000008, "Wrong alignment on UParticleModuleAccelerationOverLifetime");
static_assert(sizeof(UParticleModuleAccelerationOverLifetime) == 0x0000A8, "Wrong size on UParticleModuleAccelerationOverLifetime");
static_assert(offsetof(UParticleModuleAccelerationOverLifetime, AccelOverLife) == 0x000058, "Member 'UParticleModuleAccelerationOverLifetime::AccelOverLife' has a wrong offset!");

// Class Engine.ParticleModuleAttractorLine
// 0x0088 (0x00D8 - 0x0050)
class UParticleModuleAttractorLine final : public UParticleModuleAttractorBase
{
public:
	struct FVector                                EndPoint0;                                         // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPoint1;                                         // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Range;                                             // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Strength;                                          // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAttractorLine">();
	}
	static class UParticleModuleAttractorLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAttractorLine>();
	}
};
static_assert(alignof(UParticleModuleAttractorLine) == 0x000008, "Wrong alignment on UParticleModuleAttractorLine");
static_assert(sizeof(UParticleModuleAttractorLine) == 0x0000D8, "Wrong size on UParticleModuleAttractorLine");
static_assert(offsetof(UParticleModuleAttractorLine, EndPoint0) == 0x000050, "Member 'UParticleModuleAttractorLine::EndPoint0' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorLine, EndPoint1) == 0x00005C, "Member 'UParticleModuleAttractorLine::EndPoint1' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorLine, Range) == 0x000068, "Member 'UParticleModuleAttractorLine::Range' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorLine, Strength) == 0x0000A0, "Member 'UParticleModuleAttractorLine::Strength' has a wrong offset!");

// Class Engine.ParticleModuleAttractorPoint
// 0x00C8 (0x0118 - 0x0050)
class UParticleModuleAttractorPoint final : public UParticleModuleAttractorBase
{
public:
	struct FRawDistributionVector                 Position;                                          // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Range;                                             // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Strength;                                          // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         StrengthByDistance : 1;                            // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAffectBaseVelocity : 1;                           // 0x0110(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideVelocity : 1;                             // 0x0110(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseWorldSpacePosition : 1;                        // 0x0110(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Positive_X : 1;                                    // 0x0110(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Positive_Y : 1;                                    // 0x0110(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Positive_Z : 1;                                    // 0x0110(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Negative_X : 1;                                    // 0x0110(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Negative_Y : 1;                                    // 0x0111(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Negative_Z : 1;                                    // 0x0111(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleAttractorPoint">();
	}
	static class UParticleModuleAttractorPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleAttractorPoint>();
	}
};
static_assert(alignof(UParticleModuleAttractorPoint) == 0x000008, "Wrong alignment on UParticleModuleAttractorPoint");
static_assert(sizeof(UParticleModuleAttractorPoint) == 0x000118, "Wrong size on UParticleModuleAttractorPoint");
static_assert(offsetof(UParticleModuleAttractorPoint, Position) == 0x000050, "Member 'UParticleModuleAttractorPoint::Position' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorPoint, Range) == 0x0000A0, "Member 'UParticleModuleAttractorPoint::Range' has a wrong offset!");
static_assert(offsetof(UParticleModuleAttractorPoint, Strength) == 0x0000D8, "Member 'UParticleModuleAttractorPoint::Strength' has a wrong offset!");

// Class Engine.VisualLoggerDebugSnapshotInterface
// 0x0000 (0x0040 - 0x0040)
class IVisualLoggerDebugSnapshotInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualLoggerDebugSnapshotInterface">();
	}
	static class IVisualLoggerDebugSnapshotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVisualLoggerDebugSnapshotInterface>();
	}
};
static_assert(alignof(IVisualLoggerDebugSnapshotInterface) == 0x000008, "Wrong alignment on IVisualLoggerDebugSnapshotInterface");
static_assert(sizeof(IVisualLoggerDebugSnapshotInterface) == 0x000040, "Wrong size on IVisualLoggerDebugSnapshotInterface");

// Class Engine.ParticleModuleBeamModifier
// 0x00F0 (0x0140 - 0x0050)
class UParticleModuleBeamModifier final : public UParticleModuleBeamBase
{
public:
	EBeamModifierType                             ModifierType;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBeamModifierOptions                   PositionOptions;                                   // 0x0054(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 Position;                                          // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBeamModifierOptions                   TangentOptions;                                    // 0x00A8(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 Tangent;                                           // 0x00B0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAbsoluteTangent : 1;                              // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBeamModifierOptions                   StrengthOptions;                                   // 0x0104(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Strength;                                          // 0x0108(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBeamModifier">();
	}
	static class UParticleModuleBeamModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBeamModifier>();
	}
};
static_assert(alignof(UParticleModuleBeamModifier) == 0x000008, "Wrong alignment on UParticleModuleBeamModifier");
static_assert(sizeof(UParticleModuleBeamModifier) == 0x000140, "Wrong size on UParticleModuleBeamModifier");
static_assert(offsetof(UParticleModuleBeamModifier, ModifierType) == 0x000050, "Member 'UParticleModuleBeamModifier::ModifierType' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamModifier, PositionOptions) == 0x000054, "Member 'UParticleModuleBeamModifier::PositionOptions' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamModifier, Position) == 0x000058, "Member 'UParticleModuleBeamModifier::Position' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamModifier, TangentOptions) == 0x0000A8, "Member 'UParticleModuleBeamModifier::TangentOptions' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamModifier, Tangent) == 0x0000B0, "Member 'UParticleModuleBeamModifier::Tangent' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamModifier, StrengthOptions) == 0x000104, "Member 'UParticleModuleBeamModifier::StrengthOptions' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamModifier, Strength) == 0x000108, "Member 'UParticleModuleBeamModifier::Strength' has a wrong offset!");

// Class Engine.ParticleModuleBeamNoise
// 0x0188 (0x01D8 - 0x0050)
class UParticleModuleBeamNoise final : public UParticleModuleBeamBase
{
public:
	uint8                                         bLowFreq_Enabled : 1;                              // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Frequency;                                         // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Frequency_LowRange;                                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 NoiseRange;                                        // 0x0060(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  NoiseRangeScale;                                   // 0x00B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bNRScaleEmitterTime : 1;                           // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 NoiseSpeed;                                        // 0x00F0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bSmooth : 1;                                       // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoiseLockRadius;                                   // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoiseLock : 1;                                    // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOscillate : 1;                                    // 0x0148(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoiseLockTime;                                     // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseTension;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseNoiseTangents : 1;                             // 0x0154(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  NoiseTangentStrength;                              // 0x0158(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         NoiseTessellation;                                 // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTargetNoise : 1;                                  // 0x0194(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrequencyDistance;                                 // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyNoiseScale : 1;                              // 0x019C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  NoiseScale;                                        // 0x01A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBeamNoise">();
	}
	static class UParticleModuleBeamNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBeamNoise>();
	}
};
static_assert(alignof(UParticleModuleBeamNoise) == 0x000008, "Wrong alignment on UParticleModuleBeamNoise");
static_assert(sizeof(UParticleModuleBeamNoise) == 0x0001D8, "Wrong size on UParticleModuleBeamNoise");
static_assert(offsetof(UParticleModuleBeamNoise, Frequency) == 0x000054, "Member 'UParticleModuleBeamNoise::Frequency' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, Frequency_LowRange) == 0x000058, "Member 'UParticleModuleBeamNoise::Frequency_LowRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseRange) == 0x000060, "Member 'UParticleModuleBeamNoise::NoiseRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseRangeScale) == 0x0000B0, "Member 'UParticleModuleBeamNoise::NoiseRangeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseSpeed) == 0x0000F0, "Member 'UParticleModuleBeamNoise::NoiseSpeed' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseLockRadius) == 0x000144, "Member 'UParticleModuleBeamNoise::NoiseLockRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseLockTime) == 0x00014C, "Member 'UParticleModuleBeamNoise::NoiseLockTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseTension) == 0x000150, "Member 'UParticleModuleBeamNoise::NoiseTension' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseTangentStrength) == 0x000158, "Member 'UParticleModuleBeamNoise::NoiseTangentStrength' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseTessellation) == 0x000190, "Member 'UParticleModuleBeamNoise::NoiseTessellation' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, FrequencyDistance) == 0x000198, "Member 'UParticleModuleBeamNoise::FrequencyDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamNoise, NoiseScale) == 0x0001A0, "Member 'UParticleModuleBeamNoise::NoiseScale' has a wrong offset!");

// Class Engine.ParticleModuleBeamSource
// 0x0108 (0x0158 - 0x0050)
class UParticleModuleBeamSource final : public UParticleModuleBeamBase
{
public:
	EBeam2SourceTargetMethod                      SourceMethod;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SourceName;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSourceAbsolute : 1;                               // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 Source;                                            // 0x0068(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLockSource : 1;                                   // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBeam2SourceTargetTangentMethod               SourceTangentMethod;                               // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 SourceTangent;                                     // 0x00C0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLockSourceTangent : 1;                            // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SourceStrength;                                    // 0x0118(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bLockSourceStength : 1;                            // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBeamSource">();
	}
	static class UParticleModuleBeamSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBeamSource>();
	}
};
static_assert(alignof(UParticleModuleBeamSource) == 0x000008, "Wrong alignment on UParticleModuleBeamSource");
static_assert(sizeof(UParticleModuleBeamSource) == 0x000158, "Wrong size on UParticleModuleBeamSource");
static_assert(offsetof(UParticleModuleBeamSource, SourceMethod) == 0x000050, "Member 'UParticleModuleBeamSource::SourceMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamSource, SourceName) == 0x000058, "Member 'UParticleModuleBeamSource::SourceName' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamSource, Source) == 0x000068, "Member 'UParticleModuleBeamSource::Source' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamSource, SourceTangentMethod) == 0x0000BC, "Member 'UParticleModuleBeamSource::SourceTangentMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamSource, SourceTangent) == 0x0000C0, "Member 'UParticleModuleBeamSource::SourceTangent' has a wrong offset!");
static_assert(offsetof(UParticleModuleBeamSource, SourceStrength) == 0x000118, "Member 'UParticleModuleBeamSource::SourceStrength' has a wrong offset!");

// Class Engine.ParticleModuleCollisionBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleCollisionBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleCollisionBase">();
	}
	static class UParticleModuleCollisionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleCollisionBase>();
	}
};
static_assert(alignof(UParticleModuleCollisionBase) == 0x000008, "Wrong alignment on UParticleModuleCollisionBase");
static_assert(sizeof(UParticleModuleCollisionBase) == 0x000050, "Wrong size on UParticleModuleCollisionBase");

// Class Engine.ParticleModuleCollision
// 0x01C0 (0x0210 - 0x0050)
class UParticleModuleCollision final : public UParticleModuleCollisionBase
{
public:
	struct FRawDistributionVector                 DampingFactor;                                     // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DampingFactorRotation;                             // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  MaxCollisions;                                     // 0x00F0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EParticleCollisionComplete                    CollisionCompletionOption;                         // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionTypes;                                    // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_CollisionResponseParamsData> SqExCollisionResponseParams;                       // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x20];                                     // 0x0158(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             SqExCollisionChannel;                              // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bApplyPhysics : 1;                                 // 0x017C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreTriggerVolumes : 1;                         // 0x017C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ParticleMass;                                      // 0x0180(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DirScalar;                                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPawnsDoNotDecrementCount : 1;                     // 0x01BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyVerticalNormalsDecrementCount : 1;            // 0x01BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalFudgeFactor;                               // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  DelayAmount;                                       // 0x01C8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bDropDetail : 1;                                   // 0x0200(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCollideOnlyIfVisible : 1;                         // 0x0200(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bE3Debug_NoMeshBoundCollision : 1;                 // 0x0200(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckSizeScale;                                    // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoSetHitLocation : 1;                             // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreSourceActor : 1;                            // 0x0208(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCollisionDistance;                              // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleCollision">();
	}
	static class UParticleModuleCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleCollision>();
	}
};
static_assert(alignof(UParticleModuleCollision) == 0x000008, "Wrong alignment on UParticleModuleCollision");
static_assert(sizeof(UParticleModuleCollision) == 0x000210, "Wrong size on UParticleModuleCollision");
static_assert(offsetof(UParticleModuleCollision, DampingFactor) == 0x000050, "Member 'UParticleModuleCollision::DampingFactor' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, DampingFactorRotation) == 0x0000A0, "Member 'UParticleModuleCollision::DampingFactorRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, MaxCollisions) == 0x0000F0, "Member 'UParticleModuleCollision::MaxCollisions' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, CollisionCompletionOption) == 0x000128, "Member 'UParticleModuleCollision::CollisionCompletionOption' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, CollisionTypes) == 0x000130, "Member 'UParticleModuleCollision::CollisionTypes' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, SqExCollisionResponseParams) == 0x000148, "Member 'UParticleModuleCollision::SqExCollisionResponseParams' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, SqExCollisionChannel) == 0x000178, "Member 'UParticleModuleCollision::SqExCollisionChannel' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, ParticleMass) == 0x000180, "Member 'UParticleModuleCollision::ParticleMass' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, DirScalar) == 0x0001B8, "Member 'UParticleModuleCollision::DirScalar' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, VerticalFudgeFactor) == 0x0001C0, "Member 'UParticleModuleCollision::VerticalFudgeFactor' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, DelayAmount) == 0x0001C8, "Member 'UParticleModuleCollision::DelayAmount' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, CheckSizeScale) == 0x000204, "Member 'UParticleModuleCollision::CheckSizeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollision, MaxCollisionDistance) == 0x00020C, "Member 'UParticleModuleCollision::MaxCollisionDistance' has a wrong offset!");

// Class Engine.ParticleModuleCollisionGPU
// 0x0090 (0x00E0 - 0x0050)
class UParticleModuleCollisionGPU final : public UParticleModuleCollisionBase
{
public:
	uint8                                         bCollitionHitNoWriteNewVelocity : 1;               // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoKillCollitionDepthBack : 1;                     // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Resilience;                                        // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ResilienceScaleOverLife;                           // 0x0090(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSpread;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDistribution;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusScale;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusBias;                                        // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleCollisionResponse                    Response;                                          // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleCollisionMode                        CollisionMode;                                     // 0x00DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleCollisionGPU">();
	}
	static class UParticleModuleCollisionGPU* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleCollisionGPU>();
	}
};
static_assert(alignof(UParticleModuleCollisionGPU) == 0x000008, "Wrong alignment on UParticleModuleCollisionGPU");
static_assert(sizeof(UParticleModuleCollisionGPU) == 0x0000E0, "Wrong size on UParticleModuleCollisionGPU");
static_assert(offsetof(UParticleModuleCollisionGPU, Resilience) == 0x000058, "Member 'UParticleModuleCollisionGPU::Resilience' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, ResilienceScaleOverLife) == 0x000090, "Member 'UParticleModuleCollisionGPU::ResilienceScaleOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, Friction) == 0x0000C8, "Member 'UParticleModuleCollisionGPU::Friction' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, RandomSpread) == 0x0000CC, "Member 'UParticleModuleCollisionGPU::RandomSpread' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, RandomDistribution) == 0x0000D0, "Member 'UParticleModuleCollisionGPU::RandomDistribution' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, RadiusScale) == 0x0000D4, "Member 'UParticleModuleCollisionGPU::RadiusScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, RadiusBias) == 0x0000D8, "Member 'UParticleModuleCollisionGPU::RadiusBias' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, Response) == 0x0000DC, "Member 'UParticleModuleCollisionGPU::Response' has a wrong offset!");
static_assert(offsetof(UParticleModuleCollisionGPU, CollisionMode) == 0x0000DD, "Member 'UParticleModuleCollisionGPU::CollisionMode' has a wrong offset!");

// Class Engine.ParticleModuleColor_Seeded
// 0x0020 (0x0100 - 0x00E0)
class UParticleModuleColor_Seeded final : public UParticleModuleColor
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00E0(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleColor_Seeded">();
	}
	static class UParticleModuleColor_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleColor_Seeded>();
	}
};
static_assert(alignof(UParticleModuleColor_Seeded) == 0x000008, "Wrong alignment on UParticleModuleColor_Seeded");
static_assert(sizeof(UParticleModuleColor_Seeded) == 0x000100, "Wrong size on UParticleModuleColor_Seeded");
static_assert(offsetof(UParticleModuleColor_Seeded, RandomSeedInfo) == 0x0000E0, "Member 'UParticleModuleColor_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleColorScaleOverLife
// 0x0090 (0x00E0 - 0x0050)
class UParticleModuleColorScaleOverLife final : public UParticleModuleColorBase
{
public:
	struct FRawDistributionVector                 ColorScaleOverLife;                                // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AlphaScaleOverLife;                                // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEmitterTime : 1;                                  // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleColorScaleOverLife">();
	}
	static class UParticleModuleColorScaleOverLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleColorScaleOverLife>();
	}
};
static_assert(alignof(UParticleModuleColorScaleOverLife) == 0x000008, "Wrong alignment on UParticleModuleColorScaleOverLife");
static_assert(sizeof(UParticleModuleColorScaleOverLife) == 0x0000E0, "Wrong size on UParticleModuleColorScaleOverLife");
static_assert(offsetof(UParticleModuleColorScaleOverLife, ColorScaleOverLife) == 0x000050, "Member 'UParticleModuleColorScaleOverLife::ColorScaleOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleColorScaleOverLife, AlphaScaleOverLife) == 0x0000A0, "Member 'UParticleModuleColorScaleOverLife::AlphaScaleOverLife' has a wrong offset!");

// Class Engine.ParticleModuleEventBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleEventBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleEventBase">();
	}
	static class UParticleModuleEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleEventBase>();
	}
};
static_assert(alignof(UParticleModuleEventBase) == 0x000008, "Wrong alignment on UParticleModuleEventBase");
static_assert(sizeof(UParticleModuleEventBase) == 0x000050, "Wrong size on UParticleModuleEventBase");

// Class Engine.SQEX_TimelineItem
// 0x0080 (0x00C0 - 0x0040)
class USQEX_TimelineItem : public USQEX_TrackItemBase
{
public:
	class FString                                 TrackItemName;                                     // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USQEX_TimelineItem*>             Children;                                          // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x50];                                      // 0x0070(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TimelineItem">();
	}
	static class USQEX_TimelineItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TimelineItem>();
	}
};
static_assert(alignof(USQEX_TimelineItem) == 0x000008, "Wrong alignment on USQEX_TimelineItem");
static_assert(sizeof(USQEX_TimelineItem) == 0x0000C0, "Wrong size on USQEX_TimelineItem");
static_assert(offsetof(USQEX_TimelineItem, TrackItemName) == 0x000040, "Member 'USQEX_TimelineItem::TrackItemName' has a wrong offset!");
static_assert(offsetof(USQEX_TimelineItem, Time) == 0x000050, "Member 'USQEX_TimelineItem::Time' has a wrong offset!");
static_assert(offsetof(USQEX_TimelineItem, Duration) == 0x000054, "Member 'USQEX_TimelineItem::Duration' has a wrong offset!");
static_assert(offsetof(USQEX_TimelineItem, Delay) == 0x000058, "Member 'USQEX_TimelineItem::Delay' has a wrong offset!");
static_assert(offsetof(USQEX_TimelineItem, Children) == 0x000060, "Member 'USQEX_TimelineItem::Children' has a wrong offset!");

// Class Engine.SQEX_TrackItemFire
// 0x0000 (0x00C0 - 0x00C0)
class USQEX_TrackItemFire final : public USQEX_TimelineItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TrackItemFire">();
	}
	static class USQEX_TrackItemFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TrackItemFire>();
	}
};
static_assert(alignof(USQEX_TrackItemFire) == 0x000008, "Wrong alignment on USQEX_TrackItemFire");
static_assert(sizeof(USQEX_TrackItemFire) == 0x0000C0, "Wrong size on USQEX_TrackItemFire");

// Class Engine.ParticleModuleEventGenerator
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleEventGenerator final : public UParticleModuleEventBase
{
public:
	TArray<struct FParticleEvent_GenerateInfo>    Events;                                            // 0x0050(0x0010)(Edit, ExportObject, ZeroConstructor, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleEventGenerator">();
	}
	static class UParticleModuleEventGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleEventGenerator>();
	}
};
static_assert(alignof(UParticleModuleEventGenerator) == 0x000008, "Wrong alignment on UParticleModuleEventGenerator");
static_assert(sizeof(UParticleModuleEventGenerator) == 0x000060, "Wrong size on UParticleModuleEventGenerator");
static_assert(offsetof(UParticleModuleEventGenerator, Events) == 0x000050, "Member 'UParticleModuleEventGenerator::Events' has a wrong offset!");

// Class Engine.ParticleModuleEventReceiverBase
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
public:
	EParticleEventType                            EventGeneratorType;                                // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventName;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleEventReceiverBase">();
	}
	static class UParticleModuleEventReceiverBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleEventReceiverBase>();
	}
};
static_assert(alignof(UParticleModuleEventReceiverBase) == 0x000008, "Wrong alignment on UParticleModuleEventReceiverBase");
static_assert(sizeof(UParticleModuleEventReceiverBase) == 0x000060, "Wrong size on UParticleModuleEventReceiverBase");
static_assert(offsetof(UParticleModuleEventReceiverBase, EventGeneratorType) == 0x000050, "Member 'UParticleModuleEventReceiverBase::EventGeneratorType' has a wrong offset!");
static_assert(offsetof(UParticleModuleEventReceiverBase, EventName) == 0x000058, "Member 'UParticleModuleEventReceiverBase::EventName' has a wrong offset!");

// Class Engine.ParticleModuleEventReceiverKillParticles
// 0x0008 (0x0068 - 0x0060)
class UParticleModuleEventReceiverKillParticles final : public UParticleModuleEventReceiverBase
{
public:
	uint8                                         bStopSpawning : 1;                                 // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleEventReceiverKillParticles">();
	}
	static class UParticleModuleEventReceiverKillParticles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleEventReceiverKillParticles>();
	}
};
static_assert(alignof(UParticleModuleEventReceiverKillParticles) == 0x000008, "Wrong alignment on UParticleModuleEventReceiverKillParticles");
static_assert(sizeof(UParticleModuleEventReceiverKillParticles) == 0x000068, "Wrong size on UParticleModuleEventReceiverKillParticles");

// Class Engine.ParticleModuleEventReceiverSpawn
// 0x00A8 (0x0108 - 0x0060)
class UParticleModuleEventReceiverSpawn final : public UParticleModuleEventReceiverBase
{
public:
	struct FRawDistributionFloat                  SpawnCount;                                        // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseParticleTime : 1;                              // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsePSysLocation : 1;                              // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritVelocity : 1;                              // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 InheritVelocityScale;                              // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UPhysicalMaterial*>              PhysicalMaterials;                                 // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bBanPhysicalMaterials : 1;                         // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleEventReceiverSpawn">();
	}
	static class UParticleModuleEventReceiverSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleEventReceiverSpawn>();
	}
};
static_assert(alignof(UParticleModuleEventReceiverSpawn) == 0x000008, "Wrong alignment on UParticleModuleEventReceiverSpawn");
static_assert(sizeof(UParticleModuleEventReceiverSpawn) == 0x000108, "Wrong size on UParticleModuleEventReceiverSpawn");
static_assert(offsetof(UParticleModuleEventReceiverSpawn, SpawnCount) == 0x000060, "Member 'UParticleModuleEventReceiverSpawn::SpawnCount' has a wrong offset!");
static_assert(offsetof(UParticleModuleEventReceiverSpawn, InheritVelocityScale) == 0x0000A0, "Member 'UParticleModuleEventReceiverSpawn::InheritVelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleEventReceiverSpawn, PhysicalMaterials) == 0x0000F0, "Member 'UParticleModuleEventReceiverSpawn::PhysicalMaterials' has a wrong offset!");

// Class Engine.ParticleModuleKillBox
// 0x00A8 (0x00F8 - 0x0050)
class UParticleModuleKillBox final : public UParticleModuleKillBase
{
public:
	struct FRawDistributionVector                 LowerLeftCorner;                                   // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 UpperRightCorner;                                  // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAbsolute : 1;                                     // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKillInside : 1;                                   // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAxisAlignedAndFixedSize : 1;                      // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleKillBox">();
	}
	static class UParticleModuleKillBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleKillBox>();
	}
};
static_assert(alignof(UParticleModuleKillBox) == 0x000008, "Wrong alignment on UParticleModuleKillBox");
static_assert(sizeof(UParticleModuleKillBox) == 0x0000F8, "Wrong size on UParticleModuleKillBox");
static_assert(offsetof(UParticleModuleKillBox, LowerLeftCorner) == 0x000050, "Member 'UParticleModuleKillBox::LowerLeftCorner' has a wrong offset!");
static_assert(offsetof(UParticleModuleKillBox, UpperRightCorner) == 0x0000A0, "Member 'UParticleModuleKillBox::UpperRightCorner' has a wrong offset!");

// Class Engine.ParticleModuleKillHeight
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleKillHeight final : public UParticleModuleKillBase
{
public:
	struct FRawDistributionFloat                  Height;                                            // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAbsolute : 1;                                     // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFloor : 1;                                        // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyPSysScale : 1;                               // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleKillHeight">();
	}
	static class UParticleModuleKillHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleKillHeight>();
	}
};
static_assert(alignof(UParticleModuleKillHeight) == 0x000008, "Wrong alignment on UParticleModuleKillHeight");
static_assert(sizeof(UParticleModuleKillHeight) == 0x000090, "Wrong size on UParticleModuleKillHeight");
static_assert(offsetof(UParticleModuleKillHeight, Height) == 0x000050, "Member 'UParticleModuleKillHeight::Height' has a wrong offset!");

// Class Engine.SQEXDistributionVectorGauss
// 0x0030 (0x0080 - 0x0050)
class USQEXDistributionVectorGauss final : public UDistributionVector
{
public:
	struct FVector                                Max;                                               // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deviation;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Average;                                           // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OnlyOnceGetDeviation : 1;                          // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockAxes : 1;                                     // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDistributionVectorLockFlags                  LockedAxes;                                        // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistributionVectorMirrorFlags                MirrorFlags[0x3];                                  // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseExtremes : 1;                                  // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEXDistributionVectorGauss">();
	}
	static class USQEXDistributionVectorGauss* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEXDistributionVectorGauss>();
	}
};
static_assert(alignof(USQEXDistributionVectorGauss) == 0x000008, "Wrong alignment on USQEXDistributionVectorGauss");
static_assert(sizeof(USQEXDistributionVectorGauss) == 0x000080, "Wrong size on USQEXDistributionVectorGauss");
static_assert(offsetof(USQEXDistributionVectorGauss, Max) == 0x000050, "Member 'USQEXDistributionVectorGauss::Max' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorGauss, Min) == 0x00005C, "Member 'USQEXDistributionVectorGauss::Min' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorGauss, Deviation) == 0x000068, "Member 'USQEXDistributionVectorGauss::Deviation' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorGauss, Average) == 0x00006C, "Member 'USQEXDistributionVectorGauss::Average' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorGauss, LockedAxes) == 0x000074, "Member 'USQEXDistributionVectorGauss::LockedAxes' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorGauss, MirrorFlags) == 0x000075, "Member 'USQEXDistributionVectorGauss::MirrorFlags' has a wrong offset!");

// Class Engine.SqExEffectEmitterPresetDataMenu
// 0x0020 (0x0060 - 0x0040)
class USqExEffectEmitterPresetDataMenu final : public USQEX_EffectEmitterPresetDataBase
{
public:
	class FString                                 NemuStr;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USQEX_EffectEmitterPresetDataBase*> SubMenu;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqExEffectEmitterPresetDataMenu">();
	}
	static class USqExEffectEmitterPresetDataMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqExEffectEmitterPresetDataMenu>();
	}
};
static_assert(alignof(USqExEffectEmitterPresetDataMenu) == 0x000008, "Wrong alignment on USqExEffectEmitterPresetDataMenu");
static_assert(sizeof(USqExEffectEmitterPresetDataMenu) == 0x000060, "Wrong size on USqExEffectEmitterPresetDataMenu");
static_assert(offsetof(USqExEffectEmitterPresetDataMenu, NemuStr) == 0x000040, "Member 'USqExEffectEmitterPresetDataMenu::NemuStr' has a wrong offset!");
static_assert(offsetof(USqExEffectEmitterPresetDataMenu, SubMenu) == 0x000050, "Member 'USqExEffectEmitterPresetDataMenu::SubMenu' has a wrong offset!");

// Class Engine.ParticleModuleLocationDirect
// 0x0140 (0x0190 - 0x0050)
class UParticleModuleLocationDirect final : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                 Location;                                          // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 LocationOffset;                                    // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ScaleFactor;                                       // 0x00F0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 Direction;                                         // 0x0140(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationDirect">();
	}
	static class UParticleModuleLocationDirect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationDirect>();
	}
};
static_assert(alignof(UParticleModuleLocationDirect) == 0x000008, "Wrong alignment on UParticleModuleLocationDirect");
static_assert(sizeof(UParticleModuleLocationDirect) == 0x000190, "Wrong size on UParticleModuleLocationDirect");
static_assert(offsetof(UParticleModuleLocationDirect, Location) == 0x000050, "Member 'UParticleModuleLocationDirect::Location' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationDirect, LocationOffset) == 0x0000A0, "Member 'UParticleModuleLocationDirect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationDirect, ScaleFactor) == 0x0000F0, "Member 'UParticleModuleLocationDirect::ScaleFactor' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationDirect, Direction) == 0x000140, "Member 'UParticleModuleLocationDirect::Direction' has a wrong offset!");

// Class Engine.ParticleModuleLocationEmitter
// 0x0020 (0x0070 - 0x0050)
class UParticleModuleLocationEmitter final : public UParticleModuleLocationBase
{
public:
	class FName                                   EmitterName;                                       // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocationEmitterSelectionMethod               SelectionMethod;                                   // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         InheritSourceVelocity : 1;                         // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InheritSourceVelocityScale;                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInheritSourceRotation : 1;                        // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InheritSourceRotationScale;                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationEmitter">();
	}
	static class UParticleModuleLocationEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationEmitter>();
	}
};
static_assert(alignof(UParticleModuleLocationEmitter) == 0x000008, "Wrong alignment on UParticleModuleLocationEmitter");
static_assert(sizeof(UParticleModuleLocationEmitter) == 0x000070, "Wrong size on UParticleModuleLocationEmitter");
static_assert(offsetof(UParticleModuleLocationEmitter, EmitterName) == 0x000050, "Member 'UParticleModuleLocationEmitter::EmitterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationEmitter, SelectionMethod) == 0x000058, "Member 'UParticleModuleLocationEmitter::SelectionMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationEmitter, InheritSourceVelocityScale) == 0x000060, "Member 'UParticleModuleLocationEmitter::InheritSourceVelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationEmitter, InheritSourceRotationScale) == 0x000068, "Member 'UParticleModuleLocationEmitter::InheritSourceRotationScale' has a wrong offset!");

// Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded
// 0x0020 (0x0138 - 0x0118)
class UParticleModuleLocationPrimitiveSphere_Seeded final : public UParticleModuleLocationPrimitiveSphere
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0118(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationPrimitiveSphere_Seeded">();
	}
	static class UParticleModuleLocationPrimitiveSphere_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationPrimitiveSphere_Seeded>();
	}
};
static_assert(alignof(UParticleModuleLocationPrimitiveSphere_Seeded) == 0x000008, "Wrong alignment on UParticleModuleLocationPrimitiveSphere_Seeded");
static_assert(sizeof(UParticleModuleLocationPrimitiveSphere_Seeded) == 0x000138, "Wrong size on UParticleModuleLocationPrimitiveSphere_Seeded");
static_assert(offsetof(UParticleModuleLocationPrimitiveSphere_Seeded, RandomSeedInfo) == 0x000118, "Member 'UParticleModuleLocationPrimitiveSphere_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleLocationSkelVertSurface
// 0x0060 (0x00B0 - 0x0050)
class UParticleModuleLocationSkelVertSurface final : public UParticleModuleLocationBase
{
public:
	ELocationSkelVertSurfaceSource                SourceType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UniversalOffset;                                   // 0x0054(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUpdatePositionEachFrame : 1;                      // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOrientMeshEmitters : 1;                           // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritBoneVelocity : 1;                          // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InheritVelocityScale;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkelMeshActorParamName;                            // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ValidAssociatedBones;                              // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEnforceNormalCheck : 1;                           // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NormalToCompare;                                   // 0x0084(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalCheckToleranceDegrees;                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalCheckTolerance;                              // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ValidMaterialIndices;                              // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bInheritVertexColor : 1;                           // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritUV : 1;                                    // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        InheritUVChannel;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleLocationSkelVertSurface">();
	}
	static class UParticleModuleLocationSkelVertSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleLocationSkelVertSurface>();
	}
};
static_assert(alignof(UParticleModuleLocationSkelVertSurface) == 0x000008, "Wrong alignment on UParticleModuleLocationSkelVertSurface");
static_assert(sizeof(UParticleModuleLocationSkelVertSurface) == 0x0000B0, "Wrong size on UParticleModuleLocationSkelVertSurface");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, SourceType) == 0x000050, "Member 'UParticleModuleLocationSkelVertSurface::SourceType' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, UniversalOffset) == 0x000054, "Member 'UParticleModuleLocationSkelVertSurface::UniversalOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, InheritVelocityScale) == 0x000064, "Member 'UParticleModuleLocationSkelVertSurface::InheritVelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, SkelMeshActorParamName) == 0x000068, "Member 'UParticleModuleLocationSkelVertSurface::SkelMeshActorParamName' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, ValidAssociatedBones) == 0x000070, "Member 'UParticleModuleLocationSkelVertSurface::ValidAssociatedBones' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, NormalToCompare) == 0x000084, "Member 'UParticleModuleLocationSkelVertSurface::NormalToCompare' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, NormalCheckToleranceDegrees) == 0x000090, "Member 'UParticleModuleLocationSkelVertSurface::NormalCheckToleranceDegrees' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, NormalCheckTolerance) == 0x000094, "Member 'UParticleModuleLocationSkelVertSurface::NormalCheckTolerance' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, ValidMaterialIndices) == 0x000098, "Member 'UParticleModuleLocationSkelVertSurface::ValidMaterialIndices' has a wrong offset!");
static_assert(offsetof(UParticleModuleLocationSkelVertSurface, InheritUVChannel) == 0x0000AC, "Member 'UParticleModuleLocationSkelVertSurface::InheritUVChannel' has a wrong offset!");

// Class Engine.SQEX_AutoEffectDebugDataPadData
// 0x0010 (0x0078 - 0x0068)
class USQEX_AutoEffectDebugDataPadData final : public USQEX_AutoEffectDebugDataBase
{
public:
	TArray<struct FSQEX_AutoEffectDebugInputData> InputDatas;                                        // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_AutoEffectDebugDataPadData">();
	}
	static class USQEX_AutoEffectDebugDataPadData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_AutoEffectDebugDataPadData>();
	}
};
static_assert(alignof(USQEX_AutoEffectDebugDataPadData) == 0x000008, "Wrong alignment on USQEX_AutoEffectDebugDataPadData");
static_assert(sizeof(USQEX_AutoEffectDebugDataPadData) == 0x000078, "Wrong size on USQEX_AutoEffectDebugDataPadData");
static_assert(offsetof(USQEX_AutoEffectDebugDataPadData, InputDatas) == 0x000068, "Member 'USQEX_AutoEffectDebugDataPadData::InputDatas' has a wrong offset!");

// Class Engine.ParticleModuleMeshMaterial
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleMeshMaterial final : public UParticleModuleMaterialBase
{
public:
	TArray<class UMaterialInterface*>             MeshMaterials;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshMaterial">();
	}
	static class UParticleModuleMeshMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshMaterial>();
	}
};
static_assert(alignof(UParticleModuleMeshMaterial) == 0x000008, "Wrong alignment on UParticleModuleMeshMaterial");
static_assert(sizeof(UParticleModuleMeshMaterial) == 0x000060, "Wrong size on UParticleModuleMeshMaterial");
static_assert(offsetof(UParticleModuleMeshMaterial, MeshMaterials) == 0x000050, "Member 'UParticleModuleMeshMaterial::MeshMaterials' has a wrong offset!");

// Class Engine.ThumbnailInfo
// 0x0000 (0x0040 - 0x0040)
class UThumbnailInfo final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThumbnailInfo">();
	}
	static class UThumbnailInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThumbnailInfo>();
	}
};
static_assert(alignof(UThumbnailInfo) == 0x000008, "Wrong alignment on UThumbnailInfo");
static_assert(sizeof(UThumbnailInfo) == 0x000040, "Wrong size on UThumbnailInfo");

// Class Engine.ParticleModuleMeshRotation_Seeded
// 0x0020 (0x00C8 - 0x00A8)
class UParticleModuleMeshRotation_Seeded final : public UParticleModuleMeshRotation
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00A8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshRotation_Seeded">();
	}
	static class UParticleModuleMeshRotation_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshRotation_Seeded>();
	}
};
static_assert(alignof(UParticleModuleMeshRotation_Seeded) == 0x000008, "Wrong alignment on UParticleModuleMeshRotation_Seeded");
static_assert(sizeof(UParticleModuleMeshRotation_Seeded) == 0x0000C8, "Wrong size on UParticleModuleMeshRotation_Seeded");
static_assert(offsetof(UParticleModuleMeshRotation_Seeded, RandomSeedInfo) == 0x0000A8, "Member 'UParticleModuleMeshRotation_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleMeshRotationRateMultiplyLife
// 0x0050 (0x00A0 - 0x0050)
class UParticleModuleMeshRotationRateMultiplyLife final : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                 LifeMultiplier;                                    // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshRotationRateMultiplyLife">();
	}
	static class UParticleModuleMeshRotationRateMultiplyLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshRotationRateMultiplyLife>();
	}
};
static_assert(alignof(UParticleModuleMeshRotationRateMultiplyLife) == 0x000008, "Wrong alignment on UParticleModuleMeshRotationRateMultiplyLife");
static_assert(sizeof(UParticleModuleMeshRotationRateMultiplyLife) == 0x0000A0, "Wrong size on UParticleModuleMeshRotationRateMultiplyLife");
static_assert(offsetof(UParticleModuleMeshRotationRateMultiplyLife, LifeMultiplier) == 0x000050, "Member 'UParticleModuleMeshRotationRateMultiplyLife::LifeMultiplier' has a wrong offset!");

// Class Engine.ParticleModuleMeshRotationRateOverLife
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleMeshRotationRateOverLife final : public UParticleModuleRotationRateBase
{
public:
	struct FRawDistributionVector                 RotRate;                                           // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bScaleRotRate : 1;                                 // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleMeshRotationRateOverLife">();
	}
	static class UParticleModuleMeshRotationRateOverLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleMeshRotationRateOverLife>();
	}
};
static_assert(alignof(UParticleModuleMeshRotationRateOverLife) == 0x000008, "Wrong alignment on UParticleModuleMeshRotationRateOverLife");
static_assert(sizeof(UParticleModuleMeshRotationRateOverLife) == 0x0000A8, "Wrong size on UParticleModuleMeshRotationRateOverLife");
static_assert(offsetof(UParticleModuleMeshRotationRateOverLife, RotRate) == 0x000050, "Member 'UParticleModuleMeshRotationRateOverLife::RotRate' has a wrong offset!");

// Class Engine.ParticleModuleOrbit
// 0x0110 (0x0168 - 0x0058)
class UParticleModuleOrbit final : public UParticleModuleOrbitBase
{
public:
	EOrbitChainMode                               ChainMode;                                         // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 OffsetAmount;                                      // 0x0060(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FOrbitOptions                          OffsetOptions;                                     // 0x00B0(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RotationAmount;                                    // 0x00B8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FOrbitOptions                          RotationOptions;                                   // 0x0108(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RotationRateAmount;                                // 0x0110(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FOrbitOptions                          RotationRateOptions;                               // 0x0160(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleOrbit">();
	}
	static class UParticleModuleOrbit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleOrbit>();
	}
};
static_assert(alignof(UParticleModuleOrbit) == 0x000008, "Wrong alignment on UParticleModuleOrbit");
static_assert(sizeof(UParticleModuleOrbit) == 0x000168, "Wrong size on UParticleModuleOrbit");
static_assert(offsetof(UParticleModuleOrbit, ChainMode) == 0x000058, "Member 'UParticleModuleOrbit::ChainMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleOrbit, OffsetAmount) == 0x000060, "Member 'UParticleModuleOrbit::OffsetAmount' has a wrong offset!");
static_assert(offsetof(UParticleModuleOrbit, OffsetOptions) == 0x0000B0, "Member 'UParticleModuleOrbit::OffsetOptions' has a wrong offset!");
static_assert(offsetof(UParticleModuleOrbit, RotationAmount) == 0x0000B8, "Member 'UParticleModuleOrbit::RotationAmount' has a wrong offset!");
static_assert(offsetof(UParticleModuleOrbit, RotationOptions) == 0x000108, "Member 'UParticleModuleOrbit::RotationOptions' has a wrong offset!");
static_assert(offsetof(UParticleModuleOrbit, RotationRateAmount) == 0x000110, "Member 'UParticleModuleOrbit::RotationRateAmount' has a wrong offset!");
static_assert(offsetof(UParticleModuleOrbit, RotationRateOptions) == 0x000160, "Member 'UParticleModuleOrbit::RotationRateOptions' has a wrong offset!");

// Class Engine.ParticleModuleOrientationBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleOrientationBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleOrientationBase">();
	}
	static class UParticleModuleOrientationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleOrientationBase>();
	}
};
static_assert(alignof(UParticleModuleOrientationBase) == 0x000008, "Wrong alignment on UParticleModuleOrientationBase");
static_assert(sizeof(UParticleModuleOrientationBase) == 0x000050, "Wrong size on UParticleModuleOrientationBase");

// Class Engine.ParticleModuleOrientationAxisLock
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleOrientationAxisLock final : public UParticleModuleOrientationBase
{
public:
	EParticleAxisLock                             LockAxisFlags;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleOrientationAxisLock">();
	}
	static class UParticleModuleOrientationAxisLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleOrientationAxisLock>();
	}
};
static_assert(alignof(UParticleModuleOrientationAxisLock) == 0x000008, "Wrong alignment on UParticleModuleOrientationAxisLock");
static_assert(sizeof(UParticleModuleOrientationAxisLock) == 0x000058, "Wrong size on UParticleModuleOrientationAxisLock");
static_assert(offsetof(UParticleModuleOrientationAxisLock, LockAxisFlags) == 0x000050, "Member 'UParticleModuleOrientationAxisLock::LockAxisFlags' has a wrong offset!");

// Class Engine.VectorFieldComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UVectorFieldComponent final : public UPrimitiveComponent
{
public:
	class UVectorField*                           VectorField;                                       // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tightness;                                         // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPreviewVectorField : 1;                           // 0x0878(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_879[0x17];                                     // 0x0879(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIntensity(float NewIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VectorFieldComponent">();
	}
	static class UVectorFieldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVectorFieldComponent>();
	}
};
static_assert(alignof(UVectorFieldComponent) == 0x112E9AF0, "Wrong alignment on UVectorFieldComponent");
static_assert(sizeof(UVectorFieldComponent) == 0x112E9AF0, "Wrong size on UVectorFieldComponent");
static_assert(offsetof(UVectorFieldComponent, VectorField) == 0x000868, "Member 'UVectorFieldComponent::VectorField' has a wrong offset!");
static_assert(offsetof(UVectorFieldComponent, Intensity) == 0x000870, "Member 'UVectorFieldComponent::Intensity' has a wrong offset!");
static_assert(offsetof(UVectorFieldComponent, Tightness) == 0x000874, "Member 'UVectorFieldComponent::Tightness' has a wrong offset!");

// Class Engine.ParticleModulePivotOffset
// 0x112E95A0 (0x112E95F0 - 0x0050)
class UParticleModulePivotOffset final : public UParticleModuleLocationBase
{
public:
	struct FVector2D                              PivotOffset;                                       // 0x0050(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModulePivotOffset">();
	}
	static class UParticleModulePivotOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModulePivotOffset>();
	}
};
static_assert(alignof(UParticleModulePivotOffset) == 0x112E95F0, "Wrong alignment on UParticleModulePivotOffset");
static_assert(sizeof(UParticleModulePivotOffset) == 0x112E95F0, "Wrong size on UParticleModulePivotOffset");
static_assert(offsetof(UParticleModulePivotOffset, PivotOffset) == 0x000050, "Member 'UParticleModulePivotOffset::PivotOffset' has a wrong offset!");

// Class Engine.ParticleModuleRequired
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleRequired final : public UParticleModule
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseDynamicMaterialInstance : 1;                   // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBlendMode                                    EmitterBlendType;                                  // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoAddToComponent : 1;                           // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLeavePlaceInWorld : 1;                            // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EmitterOrigin;                                     // 0x0064(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EmitterRotation;                                   // 0x0070(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EROTATION_PRIORITY                            RotationPriority;                                  // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_EMITTER_SCALE_ORDER_TYPE                ScaleSpaceType;                                    // 0x007D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TexU_Scale;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TexV_Scale;                                        // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleScreenAlignment                      ScreenAlignment;                                   // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFacingCameraBlendDistance;                      // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFacingCameraBlendDistance;                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseLocalSpace : 1;                                // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEmitterLocalSpace : 1;                         // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_LocalSpaceScaleOrder                    LocalSpaceScaleOrder;                              // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bKillOnDeactivate : 1;                             // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKillOnCompleted : 1;                              // 0x009C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleSortMode                             SortMode;                                          // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmitterStartTime;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterLoopTime;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterLoopDuration;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterDurationTime;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoAddRandomTimeToMaterial : 1;                    // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLoopStartAndEnd : 1;                            // 0x00B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopTime;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopDuration;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseLegacyEmitterTime : 1;                         // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRemoveHMDRoll : 1;                                // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmitterDuration;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterDurationLow;                                // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEmitterDurationUseRange : 1;                      // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDurationRecalcEachLoop : 1;                       // 0x00CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EmitterLoops;                                      // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SpawnRate;                                         // 0x00D8(0x0038)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	EParticleBurstMethod                          ParticleBurstMethod;                               // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleBurst>                 BurstList;                                         // 0x0118(0x0010)(ExportObject, ZeroConstructor, NoClear, NativeAccessSpecifierPublic)
	float                                         EmitterDelay;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmitterDelayLow;                                   // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEmitterDelayUseRange : 1;                         // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDelayFirstLoopOnly : 1;                           // 0x0130(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSQEX_ParticleAvoidData                PlayerAvoid;                                       // 0x0134(0x11674580)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FSQEX_ParticleAvoidData                CameraAvoid;                                       // 0x0160(0x11674580)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EParticleSubUVInterpMethod                    InterpolationMethod;                               // 0x018C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubImages_Horizontal;                              // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubImages_Vertical;                                // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bScaleUV : 1;                                      // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomImageTime;                                   // 0x019C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomImageChanges;                                // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSystemMacroUV : 1;                        // 0x01A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MacroUVPosition;                                   // 0x01A8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MacroUVRadius;                                     // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseMaxDrawCount : 1;                              // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDrawCount;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleUVFlipMode                           UVFlippingMode;                                    // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             CutoutTexture;                                     // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubUVBoundingVertexCount                     BoundingMode;                                      // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOpacitySourceMode                            OpacitySourceMode;                                 // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x2];                                      // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlphaThreshold;                                    // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmitterNormalsMode                           EmitterNormalsMode;                                // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NormalsSphereCenter;                               // 0x01DC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalsCylinderDirection;                          // 0x01E8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOrbitModuleAffectsVelocityAlignment : 1;          // 0x01F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NamedMaterialOverrides;                            // 0x01F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bIsUseSqExOcean : 1;                               // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x27];                                     // 0x0209(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRequired">();
	}
	static class UParticleModuleRequired* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRequired>();
	}
};
static_assert(alignof(UParticleModuleRequired) == 0x112E9AF0, "Wrong alignment on UParticleModuleRequired");
static_assert(sizeof(UParticleModuleRequired) == 0x112E9AF0, "Wrong size on UParticleModuleRequired");
static_assert(offsetof(UParticleModuleRequired, Material) == 0x000050, "Member 'UParticleModuleRequired::Material' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterBlendType) == 0x00005C, "Member 'UParticleModuleRequired::EmitterBlendType' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterOrigin) == 0x000064, "Member 'UParticleModuleRequired::EmitterOrigin' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterRotation) == 0x000070, "Member 'UParticleModuleRequired::EmitterRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, RotationPriority) == 0x00007C, "Member 'UParticleModuleRequired::RotationPriority' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, ScaleSpaceType) == 0x00007D, "Member 'UParticleModuleRequired::ScaleSpaceType' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, TexU_Scale) == 0x000080, "Member 'UParticleModuleRequired::TexU_Scale' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, TexV_Scale) == 0x000084, "Member 'UParticleModuleRequired::TexV_Scale' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, ScreenAlignment) == 0x000088, "Member 'UParticleModuleRequired::ScreenAlignment' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, MinFacingCameraBlendDistance) == 0x00008C, "Member 'UParticleModuleRequired::MinFacingCameraBlendDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, MaxFacingCameraBlendDistance) == 0x000090, "Member 'UParticleModuleRequired::MaxFacingCameraBlendDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, LocalSpaceScaleOrder) == 0x000098, "Member 'UParticleModuleRequired::LocalSpaceScaleOrder' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, SortMode) == 0x0000A0, "Member 'UParticleModuleRequired::SortMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterStartTime) == 0x0000A4, "Member 'UParticleModuleRequired::EmitterStartTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterLoopTime) == 0x0000A8, "Member 'UParticleModuleRequired::EmitterLoopTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterLoopDuration) == 0x0000AC, "Member 'UParticleModuleRequired::EmitterLoopDuration' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterDurationTime) == 0x0000B0, "Member 'UParticleModuleRequired::EmitterDurationTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, LoopTime) == 0x0000B8, "Member 'UParticleModuleRequired::LoopTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, LoopDuration) == 0x0000BC, "Member 'UParticleModuleRequired::LoopDuration' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterDuration) == 0x0000C4, "Member 'UParticleModuleRequired::EmitterDuration' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterDurationLow) == 0x0000C8, "Member 'UParticleModuleRequired::EmitterDurationLow' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterLoops) == 0x0000D0, "Member 'UParticleModuleRequired::EmitterLoops' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, SpawnRate) == 0x0000D8, "Member 'UParticleModuleRequired::SpawnRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, ParticleBurstMethod) == 0x000110, "Member 'UParticleModuleRequired::ParticleBurstMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, BurstList) == 0x000118, "Member 'UParticleModuleRequired::BurstList' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterDelay) == 0x000128, "Member 'UParticleModuleRequired::EmitterDelay' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterDelayLow) == 0x00012C, "Member 'UParticleModuleRequired::EmitterDelayLow' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, PlayerAvoid) == 0x000134, "Member 'UParticleModuleRequired::PlayerAvoid' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, CameraAvoid) == 0x000160, "Member 'UParticleModuleRequired::CameraAvoid' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, InterpolationMethod) == 0x00018C, "Member 'UParticleModuleRequired::InterpolationMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, SubImages_Horizontal) == 0x000190, "Member 'UParticleModuleRequired::SubImages_Horizontal' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, SubImages_Vertical) == 0x000194, "Member 'UParticleModuleRequired::SubImages_Vertical' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, RandomImageTime) == 0x00019C, "Member 'UParticleModuleRequired::RandomImageTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, RandomImageChanges) == 0x0001A0, "Member 'UParticleModuleRequired::RandomImageChanges' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, MacroUVPosition) == 0x0001A8, "Member 'UParticleModuleRequired::MacroUVPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, MacroUVRadius) == 0x0001B4, "Member 'UParticleModuleRequired::MacroUVRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, MaxDrawCount) == 0x0001BC, "Member 'UParticleModuleRequired::MaxDrawCount' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, UVFlippingMode) == 0x0001C0, "Member 'UParticleModuleRequired::UVFlippingMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, CutoutTexture) == 0x0001C8, "Member 'UParticleModuleRequired::CutoutTexture' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, BoundingMode) == 0x0001D0, "Member 'UParticleModuleRequired::BoundingMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, OpacitySourceMode) == 0x0001D1, "Member 'UParticleModuleRequired::OpacitySourceMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, AlphaThreshold) == 0x0001D4, "Member 'UParticleModuleRequired::AlphaThreshold' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, EmitterNormalsMode) == 0x0001D8, "Member 'UParticleModuleRequired::EmitterNormalsMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, NormalsSphereCenter) == 0x0001DC, "Member 'UParticleModuleRequired::NormalsSphereCenter' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, NormalsCylinderDirection) == 0x0001E8, "Member 'UParticleModuleRequired::NormalsCylinderDirection' has a wrong offset!");
static_assert(offsetof(UParticleModuleRequired, NamedMaterialOverrides) == 0x0001F8, "Member 'UParticleModuleRequired::NamedMaterialOverrides' has a wrong offset!");

// Class Engine.ParticleModuleRotation_Seeded
// 0x0020 (0x00A8 - 0x0088)
class UParticleModuleRotation_Seeded final : public UParticleModuleRotation
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0088(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotation_Seeded">();
	}
	static class UParticleModuleRotation_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotation_Seeded>();
	}
};
static_assert(alignof(UParticleModuleRotation_Seeded) == 0x000008, "Wrong alignment on UParticleModuleRotation_Seeded");
static_assert(sizeof(UParticleModuleRotation_Seeded) == 0x0000A8, "Wrong size on UParticleModuleRotation_Seeded");
static_assert(offsetof(UParticleModuleRotation_Seeded, RandomSeedInfo) == 0x000088, "Member 'UParticleModuleRotation_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleRotationOverLifetime
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleRotationOverLifetime final : public UParticleModuleRotationBase
{
public:
	struct FRawDistributionFloat                  RotationOverLife;                                  // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Scale : 1;                                         // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleRotationOverLifetime">();
	}
	static class UParticleModuleRotationOverLifetime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleRotationOverLifetime>();
	}
};
static_assert(alignof(UParticleModuleRotationOverLifetime) == 0x000008, "Wrong alignment on UParticleModuleRotationOverLifetime");
static_assert(sizeof(UParticleModuleRotationOverLifetime) == 0x000090, "Wrong size on UParticleModuleRotationOverLifetime");
static_assert(offsetof(UParticleModuleRotationOverLifetime, RotationOverLife) == 0x000050, "Member 'UParticleModuleRotationOverLifetime::RotationOverLife' has a wrong offset!");

// Class Engine.ParticleModuleSizeMultiplyLife
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleSizeMultiplyLife final : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                 LifeMultiplier;                                    // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         MultiplyX : 1;                                     // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MultiplyY : 1;                                     // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MultiplyZ : 1;                                     // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSizeMultiplyLife">();
	}
	static class UParticleModuleSizeMultiplyLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSizeMultiplyLife>();
	}
};
static_assert(alignof(UParticleModuleSizeMultiplyLife) == 0x000008, "Wrong alignment on UParticleModuleSizeMultiplyLife");
static_assert(sizeof(UParticleModuleSizeMultiplyLife) == 0x0000A8, "Wrong size on UParticleModuleSizeMultiplyLife");
static_assert(offsetof(UParticleModuleSizeMultiplyLife, LifeMultiplier) == 0x000050, "Member 'UParticleModuleSizeMultiplyLife::LifeMultiplier' has a wrong offset!");

// Class Engine.ParticleModuleSizeScale
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleSizeScale final : public UParticleModuleSizeBase
{
public:
	struct FRawDistributionVector                 SizeScale;                                         // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         EnableX : 1;                                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnableY : 1;                                       // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnableZ : 1;                                       // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEmitterTime : 1;                               // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSizeScale">();
	}
	static class UParticleModuleSizeScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSizeScale>();
	}
};
static_assert(alignof(UParticleModuleSizeScale) == 0x000008, "Wrong alignment on UParticleModuleSizeScale");
static_assert(sizeof(UParticleModuleSizeScale) == 0x0000A8, "Wrong size on UParticleModuleSizeScale");
static_assert(offsetof(UParticleModuleSizeScale, SizeScale) == 0x000050, "Member 'UParticleModuleSizeScale::SizeScale' has a wrong offset!");

// Class Engine.ParticleModuleSizeScaleBySpeed
// 0x112E95A0 (0x112E95F0 - 0x0050)
class UParticleModuleSizeScaleBySpeed final : public UParticleModuleSizeBase
{
public:
	struct FVector2D                              SpeedScale;                                        // 0x0050(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxScale;                                          // 0x0058(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSizeScaleBySpeed">();
	}
	static class UParticleModuleSizeScaleBySpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSizeScaleBySpeed>();
	}
};
static_assert(alignof(UParticleModuleSizeScaleBySpeed) == 0x112E95F0, "Wrong alignment on UParticleModuleSizeScaleBySpeed");
static_assert(sizeof(UParticleModuleSizeScaleBySpeed) == 0x112E95F0, "Wrong size on UParticleModuleSizeScaleBySpeed");
static_assert(offsetof(UParticleModuleSizeScaleBySpeed, SpeedScale) == 0x000050, "Member 'UParticleModuleSizeScaleBySpeed::SpeedScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSizeScaleBySpeed, MaxScale) == 0x000058, "Member 'UParticleModuleSizeScaleBySpeed::MaxScale' has a wrong offset!");

// Class Engine.ParticleModuleSourceMovement
// 0x0050 (0x00A0 - 0x0050)
class UParticleModuleSourceMovement final : public UParticleModuleLocationBase
{
public:
	struct FRawDistributionVector                 SourceMovementScale;                               // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSourceMovement">();
	}
	static class UParticleModuleSourceMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSourceMovement>();
	}
};
static_assert(alignof(UParticleModuleSourceMovement) == 0x000008, "Wrong alignment on UParticleModuleSourceMovement");
static_assert(sizeof(UParticleModuleSourceMovement) == 0x0000A0, "Wrong size on UParticleModuleSourceMovement");
static_assert(offsetof(UParticleModuleSourceMovement, SourceMovementScale) == 0x000050, "Member 'UParticleModuleSourceMovement::SourceMovementScale' has a wrong offset!");

// Class Engine.ParticleModuleSpawn
// 0x00C8 (0x0120 - 0x0058)
class UParticleModuleSpawn final : public UParticleModuleSpawnBase
{
public:
	struct FRawDistributionFloat                  Rate;                                              // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RateScale;                                         // 0x0090(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EParticleBurstMethod                          ParticleBurstMethod;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllReestBurstList : 1;                            // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetChangeLodLevel : 1;                          // 0x00CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleBurst>                 BurstList;                                         // 0x00D0(0x0010)(Edit, ExportObject, ZeroConstructor, NoClear, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  BurstScale;                                        // 0x00E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bApplyGlobalSpawnRateScale : 1;                    // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSpawn">();
	}
	static class UParticleModuleSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSpawn>();
	}
};
static_assert(alignof(UParticleModuleSpawn) == 0x000008, "Wrong alignment on UParticleModuleSpawn");
static_assert(sizeof(UParticleModuleSpawn) == 0x000120, "Wrong size on UParticleModuleSpawn");
static_assert(offsetof(UParticleModuleSpawn, Rate) == 0x000058, "Member 'UParticleModuleSpawn::Rate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawn, RateScale) == 0x000090, "Member 'UParticleModuleSpawn::RateScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawn, ParticleBurstMethod) == 0x0000C8, "Member 'UParticleModuleSpawn::ParticleBurstMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawn, BurstList) == 0x0000D0, "Member 'UParticleModuleSpawn::BurstList' has a wrong offset!");
static_assert(offsetof(UParticleModuleSpawn, BurstScale) == 0x0000E0, "Member 'UParticleModuleSpawn::BurstScale' has a wrong offset!");

// Class Engine.SCS_Node
// 0x112E8CE0 (0x112E8D20 - 0x0040)
class USCS_Node final : public UObject
{
public:
	class UClass*                                 ComponentClass;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ComponentTemplate;                                 // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlueprintCookedComponentInstancingData CookedComponentInstancingData;                     // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	class FName                                   VariableName;                                      // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachToName;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentComponentOrVariableName;                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentComponentOwnerClassName;                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParentComponentNative;                          // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USCS_Node*>                      ChildNodes;                                        // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBPVariableMetaDataEntry>       MetaDataArray;                                     // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  VariableGuid;                                      // 0x00E8(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalseRoot;                                      // 0x00F8(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNative;                                         // 0x00F9(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NativeComponentName;                               // 0x0100(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVariableNameAutoGenerated;                        // 0x0108(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InternalVariableName;                              // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x48];                                     // 0x0118(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCS_Node">();
	}
	static class USCS_Node* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCS_Node>();
	}
};
static_assert(alignof(USCS_Node) == 0x112E8D20, "Wrong alignment on USCS_Node");
static_assert(sizeof(USCS_Node) == 0x112E8D20, "Wrong size on USCS_Node");
static_assert(offsetof(USCS_Node, ComponentClass) == 0x000040, "Member 'USCS_Node::ComponentClass' has a wrong offset!");
static_assert(offsetof(USCS_Node, ComponentTemplate) == 0x000048, "Member 'USCS_Node::ComponentTemplate' has a wrong offset!");
static_assert(offsetof(USCS_Node, CookedComponentInstancingData) == 0x000050, "Member 'USCS_Node::CookedComponentInstancingData' has a wrong offset!");
static_assert(offsetof(USCS_Node, VariableName) == 0x0000A0, "Member 'USCS_Node::VariableName' has a wrong offset!");
static_assert(offsetof(USCS_Node, AttachToName) == 0x0000A8, "Member 'USCS_Node::AttachToName' has a wrong offset!");
static_assert(offsetof(USCS_Node, ParentComponentOrVariableName) == 0x0000B0, "Member 'USCS_Node::ParentComponentOrVariableName' has a wrong offset!");
static_assert(offsetof(USCS_Node, ParentComponentOwnerClassName) == 0x0000B8, "Member 'USCS_Node::ParentComponentOwnerClassName' has a wrong offset!");
static_assert(offsetof(USCS_Node, bIsParentComponentNative) == 0x0000C0, "Member 'USCS_Node::bIsParentComponentNative' has a wrong offset!");
static_assert(offsetof(USCS_Node, ChildNodes) == 0x0000C8, "Member 'USCS_Node::ChildNodes' has a wrong offset!");
static_assert(offsetof(USCS_Node, MetaDataArray) == 0x0000D8, "Member 'USCS_Node::MetaDataArray' has a wrong offset!");
static_assert(offsetof(USCS_Node, VariableGuid) == 0x0000E8, "Member 'USCS_Node::VariableGuid' has a wrong offset!");
static_assert(offsetof(USCS_Node, bIsFalseRoot) == 0x0000F8, "Member 'USCS_Node::bIsFalseRoot' has a wrong offset!");
static_assert(offsetof(USCS_Node, bIsNative) == 0x0000F9, "Member 'USCS_Node::bIsNative' has a wrong offset!");
static_assert(offsetof(USCS_Node, NativeComponentName) == 0x000100, "Member 'USCS_Node::NativeComponentName' has a wrong offset!");
static_assert(offsetof(USCS_Node, bVariableNameAutoGenerated) == 0x000108, "Member 'USCS_Node::bVariableNameAutoGenerated' has a wrong offset!");
static_assert(offsetof(USCS_Node, InternalVariableName) == 0x000110, "Member 'USCS_Node::InternalVariableName' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_2DFluidInflow
// 0x112E95A0 (0x112E95F0 - 0x0050)
class UParticleModuleSQEX_2DFluidInflow final : public UParticleModuleSQEX_Base
{
public:
	ESQEX_2DFLUID_INFLOW_TYPE                     InflowType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Point;                                             // 0x0054(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  IntensityScale;                                    // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ForceIntensity;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ForceIntensityScale;                               // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ForceRotaion;                                      // 0x00D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BoxSizeMin;                                        // 0x0114(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BoxSizeMax;                                        // 0x011C(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_2DFluidInflow">();
	}
	static class UParticleModuleSQEX_2DFluidInflow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_2DFluidInflow>();
	}
};
static_assert(alignof(UParticleModuleSQEX_2DFluidInflow) == 0x112E95F0, "Wrong alignment on UParticleModuleSQEX_2DFluidInflow");
static_assert(sizeof(UParticleModuleSQEX_2DFluidInflow) == 0x112E95F0, "Wrong size on UParticleModuleSQEX_2DFluidInflow");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, InflowType) == 0x000050, "Member 'UParticleModuleSQEX_2DFluidInflow::InflowType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, Point) == 0x000054, "Member 'UParticleModuleSQEX_2DFluidInflow::Point' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, Intensity) == 0x00005C, "Member 'UParticleModuleSQEX_2DFluidInflow::Intensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, IntensityScale) == 0x000060, "Member 'UParticleModuleSQEX_2DFluidInflow::IntensityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, ForceIntensity) == 0x000098, "Member 'UParticleModuleSQEX_2DFluidInflow::ForceIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, ForceIntensityScale) == 0x0000A0, "Member 'UParticleModuleSQEX_2DFluidInflow::ForceIntensityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, ForceRotaion) == 0x0000D8, "Member 'UParticleModuleSQEX_2DFluidInflow::ForceRotaion' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, Radius) == 0x000110, "Member 'UParticleModuleSQEX_2DFluidInflow::Radius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, BoxSizeMin) == 0x000114, "Member 'UParticleModuleSQEX_2DFluidInflow::BoxSizeMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidInflow, BoxSizeMax) == 0x00011C, "Member 'UParticleModuleSQEX_2DFluidInflow::BoxSizeMax' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_2DFluidParameters
// 0x112E95A0 (0x112E95F0 - 0x0050)
class UParticleModuleSQEX_2DFluidParameters final : public UParticleModuleSQEX_Base
{
public:
	struct FVector2D                              SimulationSize;                                    // 0x0050(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellSize;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeStep;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Viscosity;                                         // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Diffusion;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReductionRate;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorDensityScalar;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 Color;                                             // 0x0078(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Alpha;                                             // 0x00C8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCeilingOpen : 1;                                  // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnVorticity : 1;                                  // 0x0100(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Vorticity;                                         // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnBuoyancy : 1;                                   // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Buoyancy;                                          // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseIntensity;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoisePosScale;                                     // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseSpeedScale;                                   // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseScaleTime;                                    // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NoiseOffset;                                       // 0x0120(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_2DFluidParameters">();
	}
	static class UParticleModuleSQEX_2DFluidParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_2DFluidParameters>();
	}
};
static_assert(alignof(UParticleModuleSQEX_2DFluidParameters) == 0x112E95F0, "Wrong alignment on UParticleModuleSQEX_2DFluidParameters");
static_assert(sizeof(UParticleModuleSQEX_2DFluidParameters) == 0x112E95F0, "Wrong size on UParticleModuleSQEX_2DFluidParameters");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, SimulationSize) == 0x000050, "Member 'UParticleModuleSQEX_2DFluidParameters::SimulationSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, CellSize) == 0x000058, "Member 'UParticleModuleSQEX_2DFluidParameters::CellSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Force) == 0x00005C, "Member 'UParticleModuleSQEX_2DFluidParameters::Force' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, TimeStep) == 0x000060, "Member 'UParticleModuleSQEX_2DFluidParameters::TimeStep' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Viscosity) == 0x000064, "Member 'UParticleModuleSQEX_2DFluidParameters::Viscosity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Diffusion) == 0x000068, "Member 'UParticleModuleSQEX_2DFluidParameters::Diffusion' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, ReductionRate) == 0x00006C, "Member 'UParticleModuleSQEX_2DFluidParameters::ReductionRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, ColorDensityScalar) == 0x000070, "Member 'UParticleModuleSQEX_2DFluidParameters::ColorDensityScalar' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Color) == 0x000078, "Member 'UParticleModuleSQEX_2DFluidParameters::Color' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Alpha) == 0x0000C8, "Member 'UParticleModuleSQEX_2DFluidParameters::Alpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Vorticity) == 0x000104, "Member 'UParticleModuleSQEX_2DFluidParameters::Vorticity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, Buoyancy) == 0x00010C, "Member 'UParticleModuleSQEX_2DFluidParameters::Buoyancy' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, NoiseIntensity) == 0x000110, "Member 'UParticleModuleSQEX_2DFluidParameters::NoiseIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, NoisePosScale) == 0x000114, "Member 'UParticleModuleSQEX_2DFluidParameters::NoisePosScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, NoiseSpeedScale) == 0x000118, "Member 'UParticleModuleSQEX_2DFluidParameters::NoiseSpeedScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, NoiseScaleTime) == 0x00011C, "Member 'UParticleModuleSQEX_2DFluidParameters::NoiseScaleTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_2DFluidParameters, NoiseOffset) == 0x000120, "Member 'UParticleModuleSQEX_2DFluidParameters::NoiseOffset' has a wrong offset!");

// Class Engine.SkeletalMeshReductionSettings
// 0x0018 (0x0058 - 0x0040)
class USkeletalMeshReductionSettings final : public UObject
{
public:
	TArray<struct FSkeletalMeshLODGroupSettings>  Settings;                                          // 0x0040(0x0010)(ZeroConstructor, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshReductionSettings">();
	}
	static class USkeletalMeshReductionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalMeshReductionSettings>();
	}
};
static_assert(alignof(USkeletalMeshReductionSettings) == 0x000008, "Wrong alignment on USkeletalMeshReductionSettings");
static_assert(sizeof(USkeletalMeshReductionSettings) == 0x000058, "Wrong size on USkeletalMeshReductionSettings");
static_assert(offsetof(USkeletalMeshReductionSettings, Settings) == 0x000040, "Member 'USkeletalMeshReductionSettings::Settings' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_AllEmitterFade
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleSQEX_AllEmitterFade final : public UParticleModuleSQEX_Base
{
public:
	float                                         FadeInStartTime;                                   // 0x0050(0x0004)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0054(0x0004)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutStartTime;                                  // 0x0058(0x0004)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x005C(0x0004)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_AllEmitterFade">();
	}
	static class UParticleModuleSQEX_AllEmitterFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_AllEmitterFade>();
	}
};
static_assert(alignof(UParticleModuleSQEX_AllEmitterFade) == 0x000008, "Wrong alignment on UParticleModuleSQEX_AllEmitterFade");
static_assert(sizeof(UParticleModuleSQEX_AllEmitterFade) == 0x000060, "Wrong size on UParticleModuleSQEX_AllEmitterFade");
static_assert(offsetof(UParticleModuleSQEX_AllEmitterFade, FadeInStartTime) == 0x000050, "Member 'UParticleModuleSQEX_AllEmitterFade::FadeInStartTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AllEmitterFade, FadeInTime) == 0x000054, "Member 'UParticleModuleSQEX_AllEmitterFade::FadeInTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AllEmitterFade, FadeOutStartTime) == 0x000058, "Member 'UParticleModuleSQEX_AllEmitterFade::FadeOutStartTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AllEmitterFade, FadeOutTime) == 0x00005C, "Member 'UParticleModuleSQEX_AllEmitterFade::FadeOutTime' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_AllParticleKill
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSQEX_AllParticleKill final : public UParticleModuleSQEX_Base
{
public:
	float                                         KillEmitterTime;                                   // 0x0050(0x0004)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_AllParticleKill">();
	}
	static class UParticleModuleSQEX_AllParticleKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_AllParticleKill>();
	}
};
static_assert(alignof(UParticleModuleSQEX_AllParticleKill) == 0x000008, "Wrong alignment on UParticleModuleSQEX_AllParticleKill");
static_assert(sizeof(UParticleModuleSQEX_AllParticleKill) == 0x000058, "Wrong size on UParticleModuleSQEX_AllParticleKill");
static_assert(offsetof(UParticleModuleSQEX_AllParticleKill, KillEmitterTime) == 0x000050, "Member 'UParticleModuleSQEX_AllParticleKill::KillEmitterTime' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_AnyVertexSpawn
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleSQEX_AnyVertexSpawn : public UParticleModuleSQEX_LocationBase
{
public:
	ESQEX_ANY_VERTEX_SHAPE_TYPE                   ShapeType;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VERTEX_UV_SPAWN_TYPE                    SpawnUVType;                                       // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxSpawnNumber;                                    // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WNumber;                                           // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HNumber;                                           // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RangeRadius;                                       // 0x0108(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RangeRadiusTwo;                                    // 0x0140(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DirectionAngle;                                    // 0x0178(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EVARTEX_ODER_TYPE                             VartexGenerateType;                                // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Interval;                                          // 0x01B8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bTowRadiusSameHeightOneRadius : 1;                 // 0x01F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoTopAndFinalPoint : 1;                           // 0x01F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F1[0x3];                                      // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxSideNumber;                                     // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  VertexHorizontalScale;                             // 0x01F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 OffsetPosition;                                    // 0x0230(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 OffsetRotation;                                    // 0x0280(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 OffsetScale;                                       // 0x02D0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_AnyVertexSpawn">();
	}
	static class UParticleModuleSQEX_AnyVertexSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_AnyVertexSpawn>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleSQEX_AnyVertexSpawn) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_AnyVertexSpawn");
static_assert(sizeof(UParticleModuleSQEX_AnyVertexSpawn) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_AnyVertexSpawn");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, ShapeType) == 0x0000F8, "Member 'UParticleModuleSQEX_AnyVertexSpawn::ShapeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, SpawnUVType) == 0x0000F9, "Member 'UParticleModuleSQEX_AnyVertexSpawn::SpawnUVType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, MaxSpawnNumber) == 0x0000FC, "Member 'UParticleModuleSQEX_AnyVertexSpawn::MaxSpawnNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, WNumber) == 0x000100, "Member 'UParticleModuleSQEX_AnyVertexSpawn::WNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, HNumber) == 0x000104, "Member 'UParticleModuleSQEX_AnyVertexSpawn::HNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, RangeRadius) == 0x000108, "Member 'UParticleModuleSQEX_AnyVertexSpawn::RangeRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, RangeRadiusTwo) == 0x000140, "Member 'UParticleModuleSQEX_AnyVertexSpawn::RangeRadiusTwo' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, DirectionAngle) == 0x000178, "Member 'UParticleModuleSQEX_AnyVertexSpawn::DirectionAngle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, VartexGenerateType) == 0x0001B0, "Member 'UParticleModuleSQEX_AnyVertexSpawn::VartexGenerateType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, Interval) == 0x0001B8, "Member 'UParticleModuleSQEX_AnyVertexSpawn::Interval' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, MaxSideNumber) == 0x0001F4, "Member 'UParticleModuleSQEX_AnyVertexSpawn::MaxSideNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, VertexHorizontalScale) == 0x0001F8, "Member 'UParticleModuleSQEX_AnyVertexSpawn::VertexHorizontalScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, OffsetPosition) == 0x000230, "Member 'UParticleModuleSQEX_AnyVertexSpawn::OffsetPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, OffsetRotation) == 0x000280, "Member 'UParticleModuleSQEX_AnyVertexSpawn::OffsetRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn, OffsetScale) == 0x0002D0, "Member 'UParticleModuleSQEX_AnyVertexSpawn::OffsetScale' has a wrong offset!");

// Class Engine.SlateBrushAsset
// 0x0090 (0x00D0 - 0x0040)
class USlateBrushAsset final : public UObject
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0040(0x1145C4E0)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlateBrushAsset">();
	}
	static class USlateBrushAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlateBrushAsset>();
	}
};
static_assert(alignof(USlateBrushAsset) == 0x000008, "Wrong alignment on USlateBrushAsset");
static_assert(sizeof(USlateBrushAsset) == 0x0000D0, "Wrong size on USlateBrushAsset");
static_assert(offsetof(USlateBrushAsset, Brush) == 0x000040, "Member 'USlateBrushAsset::Brush' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_AnyVertexSpawn_Seeded
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_AnyVertexSpawn_Seeded final : public UParticleModuleSQEX_AnyVertexSpawn
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0320(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_AnyVertexSpawn_Seeded">();
	}
	static class UParticleModuleSQEX_AnyVertexSpawn_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_AnyVertexSpawn_Seeded>();
	}
};
static_assert(alignof(UParticleModuleSQEX_AnyVertexSpawn_Seeded) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_AnyVertexSpawn_Seeded");
static_assert(sizeof(UParticleModuleSQEX_AnyVertexSpawn_Seeded) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_AnyVertexSpawn_Seeded");
static_assert(offsetof(UParticleModuleSQEX_AnyVertexSpawn_Seeded, RandomSeedInfo) == 0x000320, "Member 'UParticleModuleSQEX_AnyVertexSpawn_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_AttachParticle
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSQEX_AttachParticle final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bIsAttachPosition : 1;                             // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsAttachRotation : 1;                             // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_AttachParticle">();
	}
	static class UParticleModuleSQEX_AttachParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_AttachParticle>();
	}
};
static_assert(alignof(UParticleModuleSQEX_AttachParticle) == 0x000008, "Wrong alignment on UParticleModuleSQEX_AttachParticle");
static_assert(sizeof(UParticleModuleSQEX_AttachParticle) == 0x000058, "Wrong size on UParticleModuleSQEX_AttachParticle");

// Class Engine.ParticleModuleSQEX_BloomRadialBlur
// 0x0248 (0x02B8 - 0x0070)
class UParticleModuleSQEX_BloomRadialBlur final : public UParticleModuleSQEX_BlurBase
{
public:
	ESqexRadialBlurMode                           Mode;                                              // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Power;                                             // 0x0078(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Angle;                                             // 0x00B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Alpha;                                             // 0x00E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseScreenPos : 1;                                 // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  PosX;                                              // 0x0128(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  PosY;                                              // 0x0160(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Range;                                             // 0x0198(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  HoleSize;                                          // 0x01D0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AttenuationDistanceOutside;                        // 0x0208(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AttenuationDistanceInside;                         // 0x0240(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  LuminanceThreshold;                                // 0x0278(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCharaMask : 1;                                    // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_BloomRadialBlur">();
	}
	static class UParticleModuleSQEX_BloomRadialBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_BloomRadialBlur>();
	}
};
static_assert(alignof(UParticleModuleSQEX_BloomRadialBlur) == 0x000008, "Wrong alignment on UParticleModuleSQEX_BloomRadialBlur");
static_assert(sizeof(UParticleModuleSQEX_BloomRadialBlur) == 0x0002B8, "Wrong size on UParticleModuleSQEX_BloomRadialBlur");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, Mode) == 0x000070, "Member 'UParticleModuleSQEX_BloomRadialBlur::Mode' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, Power) == 0x000078, "Member 'UParticleModuleSQEX_BloomRadialBlur::Power' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, Angle) == 0x0000B0, "Member 'UParticleModuleSQEX_BloomRadialBlur::Angle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, Alpha) == 0x0000E8, "Member 'UParticleModuleSQEX_BloomRadialBlur::Alpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, PosX) == 0x000128, "Member 'UParticleModuleSQEX_BloomRadialBlur::PosX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, PosY) == 0x000160, "Member 'UParticleModuleSQEX_BloomRadialBlur::PosY' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, Range) == 0x000198, "Member 'UParticleModuleSQEX_BloomRadialBlur::Range' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, HoleSize) == 0x0001D0, "Member 'UParticleModuleSQEX_BloomRadialBlur::HoleSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, AttenuationDistanceOutside) == 0x000208, "Member 'UParticleModuleSQEX_BloomRadialBlur::AttenuationDistanceOutside' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, AttenuationDistanceInside) == 0x000240, "Member 'UParticleModuleSQEX_BloomRadialBlur::AttenuationDistanceInside' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BloomRadialBlur, LuminanceThreshold) == 0x000278, "Member 'UParticleModuleSQEX_BloomRadialBlur::LuminanceThreshold' has a wrong offset!");

// Class Engine.SoundClass
// 0x0058 (0x0098 - 0x0040)
class USoundClass final : public UObject
{
public:
	struct FSoundClassProperties                  Properties;                                        // 0x0040(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundClass*>                    ChildClasses;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPassiveSoundMixModifier>       PassiveSoundMixModifiers;                          // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundClass*                            ParentClass;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundClass">();
	}
	static class USoundClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundClass>();
	}
};
static_assert(alignof(USoundClass) == 0x000008, "Wrong alignment on USoundClass");
static_assert(sizeof(USoundClass) == 0x000098, "Wrong size on USoundClass");
static_assert(offsetof(USoundClass, Properties) == 0x000040, "Member 'USoundClass::Properties' has a wrong offset!");
static_assert(offsetof(USoundClass, ChildClasses) == 0x000070, "Member 'USoundClass::ChildClasses' has a wrong offset!");
static_assert(offsetof(USoundClass, PassiveSoundMixModifiers) == 0x000080, "Member 'USoundClass::PassiveSoundMixModifiers' has a wrong offset!");
static_assert(offsetof(USoundClass, ParentClass) == 0x000090, "Member 'USoundClass::ParentClass' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_BoneAttach
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleSQEX_BoneAttach final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bNoUpdateParticleLocation : 1;                     // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxParticleNumber;                                 // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_BoneAttachData>           AttachData;                                        // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, NoClear, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_BoneAttach">();
	}
	static class UParticleModuleSQEX_BoneAttach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_BoneAttach>();
	}
};
static_assert(alignof(UParticleModuleSQEX_BoneAttach) == 0x000008, "Wrong alignment on UParticleModuleSQEX_BoneAttach");
static_assert(sizeof(UParticleModuleSQEX_BoneAttach) == 0x000068, "Wrong size on UParticleModuleSQEX_BoneAttach");
static_assert(offsetof(UParticleModuleSQEX_BoneAttach, MaxParticleNumber) == 0x000054, "Member 'UParticleModuleSQEX_BoneAttach::MaxParticleNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BoneAttach, AttachData) == 0x000058, "Member 'UParticleModuleSQEX_BoneAttach::AttachData' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_BoxForce
// 0x0078 (0x00C8 - 0x0050)
class UParticleModuleSQEX_BoxForce final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionVector                 CollPos;                                           // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x00A0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitParticleSizeScale;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSQEX_ReactionObjectData               ReactionObject;                                    // 0x00B0(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_BoxForce">();
	}
	static class UParticleModuleSQEX_BoxForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_BoxForce>();
	}
};
static_assert(alignof(UParticleModuleSQEX_BoxForce) == 0x000008, "Wrong alignment on UParticleModuleSQEX_BoxForce");
static_assert(sizeof(UParticleModuleSQEX_BoxForce) == 0x0000C8, "Wrong size on UParticleModuleSQEX_BoxForce");
static_assert(offsetof(UParticleModuleSQEX_BoxForce, CollPos) == 0x000050, "Member 'UParticleModuleSQEX_BoxForce::CollPos' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BoxForce, BoxSize) == 0x0000A0, "Member 'UParticleModuleSQEX_BoxForce::BoxSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BoxForce, HitParticleSizeScale) == 0x0000AC, "Member 'UParticleModuleSQEX_BoxForce::HitParticleSizeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_BoxForce, ReactionObject) == 0x0000B0, "Member 'UParticleModuleSQEX_BoxForce::ReactionObject' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_CameraShake
// 0x0060 (0x00B0 - 0x0050)
class UParticleModuleSQEX_CameraShake final : public UParticleModuleCameraBase
{
public:
	uint8                                         bReestPlayList : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakePlayTime;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OverrideOscillationDuration : 1;                   // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OscillationDuration;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  CameraShakeScale;                                  // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ShakeScaleDistance;                                // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScaleDistanceOffset;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScaleDistanceMin;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_CameraShake">();
	}
	static class UParticleModuleSQEX_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_CameraShake>();
	}
};
static_assert(alignof(UParticleModuleSQEX_CameraShake) == 0x000008, "Wrong alignment on UParticleModuleSQEX_CameraShake");
static_assert(sizeof(UParticleModuleSQEX_CameraShake) == 0x0000B0, "Wrong size on UParticleModuleSQEX_CameraShake");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, ShakePlayTime) == 0x000054, "Member 'UParticleModuleSQEX_CameraShake::ShakePlayTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, Shake) == 0x000058, "Member 'UParticleModuleSQEX_CameraShake::Shake' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, OscillationDuration) == 0x000064, "Member 'UParticleModuleSQEX_CameraShake::OscillationDuration' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, CameraShakeScale) == 0x000068, "Member 'UParticleModuleSQEX_CameraShake::CameraShakeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, ShakeScaleDistance) == 0x0000A0, "Member 'UParticleModuleSQEX_CameraShake::ShakeScaleDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, ShakeScaleDistanceOffset) == 0x0000A4, "Member 'UParticleModuleSQEX_CameraShake::ShakeScaleDistanceOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CameraShake, ShakeScaleDistanceMin) == 0x0000A8, "Member 'UParticleModuleSQEX_CameraShake::ShakeScaleDistanceMin' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_CapsuleForce
// 0x0088 (0x00D8 - 0x0050)
class UParticleModuleSQEX_CapsuleForce final : public UParticleModuleSQEX_Base
{
public:
	struct FVector                                CapsulePos0;                                       // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsulePos1;                                       // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 CollPos;                                           // 0x0068(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CapsuleSize;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitParticleSizeScale;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSQEX_ReactionObjectData               ReactionObject;                                    // 0x00C0(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_CapsuleForce">();
	}
	static class UParticleModuleSQEX_CapsuleForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_CapsuleForce>();
	}
};
static_assert(alignof(UParticleModuleSQEX_CapsuleForce) == 0x000008, "Wrong alignment on UParticleModuleSQEX_CapsuleForce");
static_assert(sizeof(UParticleModuleSQEX_CapsuleForce) == 0x0000D8, "Wrong size on UParticleModuleSQEX_CapsuleForce");
static_assert(offsetof(UParticleModuleSQEX_CapsuleForce, CapsulePos0) == 0x000050, "Member 'UParticleModuleSQEX_CapsuleForce::CapsulePos0' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CapsuleForce, CapsulePos1) == 0x00005C, "Member 'UParticleModuleSQEX_CapsuleForce::CapsulePos1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CapsuleForce, CollPos) == 0x000068, "Member 'UParticleModuleSQEX_CapsuleForce::CollPos' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CapsuleForce, CapsuleSize) == 0x0000B8, "Member 'UParticleModuleSQEX_CapsuleForce::CapsuleSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CapsuleForce, HitParticleSizeScale) == 0x0000BC, "Member 'UParticleModuleSQEX_CapsuleForce::HitParticleSizeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CapsuleForce, ReactionObject) == 0x0000C0, "Member 'UParticleModuleSQEX_CapsuleForce::ReactionObject' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ComponentCutoff
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSQEX_ComponentCutoff final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bFadeTakeoverType : 1;                             // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_TAKEOVER_TYPE                           ComponentRotationTakeoverType;                     // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ComponentScaleTakeoverType;                        // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ComponentCutoff">();
	}
	static class UParticleModuleSQEX_ComponentCutoff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ComponentCutoff>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ComponentCutoff) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ComponentCutoff");
static_assert(sizeof(UParticleModuleSQEX_ComponentCutoff) == 0x000058, "Wrong size on UParticleModuleSQEX_ComponentCutoff");
static_assert(offsetof(UParticleModuleSQEX_ComponentCutoff, ComponentRotationTakeoverType) == 0x000054, "Member 'UParticleModuleSQEX_ComponentCutoff::ComponentRotationTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ComponentCutoff, ComponentScaleTakeoverType) == 0x000055, "Member 'UParticleModuleSQEX_ComponentCutoff::ComponentScaleTakeoverType' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_CurlNoise
// 0x0370 (0x03C0 - 0x0050)
class UParticleModuleSQEX_CurlNoise final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         UseEmitterMove : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseEmitterMoveOffset : 1;                          // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         NoAutoCurl : 1;                                    // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoiseToVelocityTransition;                         // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_CURLNOISE_TIME_SCALE_TYPE               TimeType;                                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Intensity;                                         // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  PositionScale;                                     // 0x0098(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TimeScale;                                         // 0x00D0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 CurlNoiseScale;                                    // 0x0108(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         NoRandomPositionOffset : 1;                        // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NoiseStartPositionOffset;                          // 0x015C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseDirectPosition : 1;                             // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseDirectPosition_LengScale : 1;                   // 0x0168(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseDirectPosition_3DScale : 1;                     // 0x0168(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseTimeNoiseScale : 1;                             // 0x0168(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 CurlNoiseTimeScale;                                // 0x0170(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseNoiseBeColorScale;                              // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ColorIntensity;                                    // 0x01C8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AlphaIntensity;                                    // 0x0200(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseColorScaleAnotherNoise;                         // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ColorScaleTimeScale;                               // 0x0240(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ColorScaleNoiseScale;                              // 0x0278(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseNoiseBeSizeScale;                               // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SizeIntensity;                                     // 0x02D0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseSizeScaleAnotherNoise;                          // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SizeScaleTimeScale;                                // 0x0310(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 SizeScaleNoiseScale;                               // 0x0348(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESQEX_CURLE_NOISE_TIME_SCALE_AXIS_TYPE        TimeScaleAxisType;                                 // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DebugBoxSize;                                      // 0x039C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DebugBoxGrid;                                      // 0x03A8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugPointSize;                                    // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawNoiseColor : 1;                               // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_CurlNoise">();
	}
	static class UParticleModuleSQEX_CurlNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_CurlNoise>();
	}
};
static_assert(alignof(UParticleModuleSQEX_CurlNoise) == 0x000008, "Wrong alignment on UParticleModuleSQEX_CurlNoise");
static_assert(sizeof(UParticleModuleSQEX_CurlNoise) == 0x0003C0, "Wrong size on UParticleModuleSQEX_CurlNoise");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, NoiseToVelocityTransition) == 0x000054, "Member 'UParticleModuleSQEX_CurlNoise::NoiseToVelocityTransition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, TimeType) == 0x000058, "Member 'UParticleModuleSQEX_CurlNoise::TimeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, Intensity) == 0x000060, "Member 'UParticleModuleSQEX_CurlNoise::Intensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, PositionScale) == 0x000098, "Member 'UParticleModuleSQEX_CurlNoise::PositionScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, TimeScale) == 0x0000D0, "Member 'UParticleModuleSQEX_CurlNoise::TimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, CurlNoiseScale) == 0x000108, "Member 'UParticleModuleSQEX_CurlNoise::CurlNoiseScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, NoiseStartPositionOffset) == 0x00015C, "Member 'UParticleModuleSQEX_CurlNoise::NoiseStartPositionOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, CurlNoiseTimeScale) == 0x000170, "Member 'UParticleModuleSQEX_CurlNoise::CurlNoiseTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, UseNoiseBeColorScale) == 0x0001C0, "Member 'UParticleModuleSQEX_CurlNoise::UseNoiseBeColorScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, ColorIntensity) == 0x0001C8, "Member 'UParticleModuleSQEX_CurlNoise::ColorIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, AlphaIntensity) == 0x000200, "Member 'UParticleModuleSQEX_CurlNoise::AlphaIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, UseColorScaleAnotherNoise) == 0x000238, "Member 'UParticleModuleSQEX_CurlNoise::UseColorScaleAnotherNoise' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, ColorScaleTimeScale) == 0x000240, "Member 'UParticleModuleSQEX_CurlNoise::ColorScaleTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, ColorScaleNoiseScale) == 0x000278, "Member 'UParticleModuleSQEX_CurlNoise::ColorScaleNoiseScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, UseNoiseBeSizeScale) == 0x0002C8, "Member 'UParticleModuleSQEX_CurlNoise::UseNoiseBeSizeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, SizeIntensity) == 0x0002D0, "Member 'UParticleModuleSQEX_CurlNoise::SizeIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, UseSizeScaleAnotherNoise) == 0x000308, "Member 'UParticleModuleSQEX_CurlNoise::UseSizeScaleAnotherNoise' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, SizeScaleTimeScale) == 0x000310, "Member 'UParticleModuleSQEX_CurlNoise::SizeScaleTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, SizeScaleNoiseScale) == 0x000348, "Member 'UParticleModuleSQEX_CurlNoise::SizeScaleNoiseScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, TimeScaleAxisType) == 0x000398, "Member 'UParticleModuleSQEX_CurlNoise::TimeScaleAxisType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, DebugBoxSize) == 0x00039C, "Member 'UParticleModuleSQEX_CurlNoise::DebugBoxSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, DebugBoxGrid) == 0x0003A8, "Member 'UParticleModuleSQEX_CurlNoise::DebugBoxGrid' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_CurlNoise, DebugPointSize) == 0x0003B4, "Member 'UParticleModuleSQEX_CurlNoise::DebugPointSize' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_DepthOffset
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSQEX_DepthOffset final : public UParticleModuleSQEX_Base
{
public:
	float                                         DepthOffset;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_DepthOffset">();
	}
	static class UParticleModuleSQEX_DepthOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_DepthOffset>();
	}
};
static_assert(alignof(UParticleModuleSQEX_DepthOffset) == 0x000008, "Wrong alignment on UParticleModuleSQEX_DepthOffset");
static_assert(sizeof(UParticleModuleSQEX_DepthOffset) == 0x000058, "Wrong size on UParticleModuleSQEX_DepthOffset");
static_assert(offsetof(UParticleModuleSQEX_DepthOffset, DepthOffset) == 0x000050, "Member 'UParticleModuleSQEX_DepthOffset::DepthOffset' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_EmitterInitializeTransforms
// 0x0108 (0x0158 - 0x0050)
class UParticleModuleSQEX_EmitterInitializeTransforms final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionVector                 InitPosition;                                      // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bRestInitEmitLocation : 1;                         // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 InitRotation;                                      // 0x00A8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bRestInitEmitRotation : 1;                         // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 InitScale;                                         // 0x0100(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bRestInitEmitScale : 1;                            // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_EmitterInitializeTransforms">();
	}
	static class UParticleModuleSQEX_EmitterInitializeTransforms* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_EmitterInitializeTransforms>();
	}
};
static_assert(alignof(UParticleModuleSQEX_EmitterInitializeTransforms) == 0x000008, "Wrong alignment on UParticleModuleSQEX_EmitterInitializeTransforms");
static_assert(sizeof(UParticleModuleSQEX_EmitterInitializeTransforms) == 0x000158, "Wrong size on UParticleModuleSQEX_EmitterInitializeTransforms");
static_assert(offsetof(UParticleModuleSQEX_EmitterInitializeTransforms, InitPosition) == 0x000050, "Member 'UParticleModuleSQEX_EmitterInitializeTransforms::InitPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterInitializeTransforms, InitRotation) == 0x0000A8, "Member 'UParticleModuleSQEX_EmitterInitializeTransforms::InitRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterInitializeTransforms, InitScale) == 0x000100, "Member 'UParticleModuleSQEX_EmitterInitializeTransforms::InitScale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_EmitterTakeover
// 0x0028 (0x0078 - 0x0050)
class UParticleModuleSQEX_EmitterTakeover final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bFadeTakeoverType : 1;                             // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConvertLeavePlaceInWorld : 1;                     // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLeavePlaceInWorld : 1;                            // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_TAKEOVER_TYPE                           ComponentPositionTakeoverType;                     // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ComponentRotationTakeoverType;                     // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ComponentScaleTakeoverType;                        // 0x0056(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParentPositionTakeoverType;                        // 0x0057(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParentRotationTakeoverType;                        // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParentScaleTakeoverType;                           // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParentParticleColorTakeoverType;                   // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParentParticleAlphaTakeoverType;                   // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParentParticleSizeScaleTakeoverType;               // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bParentLocalRotationTakeoverType : 1;              // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_TAKEOVER_TYPE                           ParticleColorTakeoverType;                         // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParticleAlphaTakeoverType;                         // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParticleSizeScaleTakeoverType;                     // 0x0066(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bNoParticleRotation : 1;                           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_TAKEOVER_TYPE                           ParentLocalRotationTakeoverType;                   // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           Position_TakeoverType;                             // 0x006D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           Rotation_TakeoverType;                             // 0x006E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           LocalRotation_TakeoverType;                        // 0x006F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           Scale_TakeoverType;                                // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParticleColor_TakeoverType;                        // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParticleAlpha_TakeoverType;                        // 0x0072(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAKEOVER_TYPE                           ParticleSizeScale_TakeoverType;                    // 0x0073(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFade_TakeoverType : 1;                            // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_EmitterTakeover">();
	}
	static class UParticleModuleSQEX_EmitterTakeover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_EmitterTakeover>();
	}
};
static_assert(alignof(UParticleModuleSQEX_EmitterTakeover) == 0x000008, "Wrong alignment on UParticleModuleSQEX_EmitterTakeover");
static_assert(sizeof(UParticleModuleSQEX_EmitterTakeover) == 0x000078, "Wrong size on UParticleModuleSQEX_EmitterTakeover");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ComponentPositionTakeoverType) == 0x000054, "Member 'UParticleModuleSQEX_EmitterTakeover::ComponentPositionTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ComponentRotationTakeoverType) == 0x000055, "Member 'UParticleModuleSQEX_EmitterTakeover::ComponentRotationTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ComponentScaleTakeoverType) == 0x000056, "Member 'UParticleModuleSQEX_EmitterTakeover::ComponentScaleTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentPositionTakeoverType) == 0x000057, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentPositionTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentRotationTakeoverType) == 0x000058, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentRotationTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentScaleTakeoverType) == 0x000059, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentScaleTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentParticleColorTakeoverType) == 0x00005A, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentParticleColorTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentParticleAlphaTakeoverType) == 0x00005B, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentParticleAlphaTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentParticleSizeScaleTakeoverType) == 0x00005C, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentParticleSizeScaleTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParticleColorTakeoverType) == 0x000064, "Member 'UParticleModuleSQEX_EmitterTakeover::ParticleColorTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParticleAlphaTakeoverType) == 0x000065, "Member 'UParticleModuleSQEX_EmitterTakeover::ParticleAlphaTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParticleSizeScaleTakeoverType) == 0x000066, "Member 'UParticleModuleSQEX_EmitterTakeover::ParticleSizeScaleTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParentLocalRotationTakeoverType) == 0x00006C, "Member 'UParticleModuleSQEX_EmitterTakeover::ParentLocalRotationTakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, Position_TakeoverType) == 0x00006D, "Member 'UParticleModuleSQEX_EmitterTakeover::Position_TakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, Rotation_TakeoverType) == 0x00006E, "Member 'UParticleModuleSQEX_EmitterTakeover::Rotation_TakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, LocalRotation_TakeoverType) == 0x00006F, "Member 'UParticleModuleSQEX_EmitterTakeover::LocalRotation_TakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, Scale_TakeoverType) == 0x000070, "Member 'UParticleModuleSQEX_EmitterTakeover::Scale_TakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParticleColor_TakeoverType) == 0x000071, "Member 'UParticleModuleSQEX_EmitterTakeover::ParticleColor_TakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParticleAlpha_TakeoverType) == 0x000072, "Member 'UParticleModuleSQEX_EmitterTakeover::ParticleAlpha_TakeoverType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTakeover, ParticleSizeScale_TakeoverType) == 0x000073, "Member 'UParticleModuleSQEX_EmitterTakeover::ParticleSizeScale_TakeoverType' has a wrong offset!");

// Class Engine.TailShape_ExtensionData_Base
// 0x0000 (0x0040 - 0x0040)
class UTailShape_ExtensionData_Base : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TailShape_ExtensionData_Base">();
	}
	static class UTailShape_ExtensionData_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTailShape_ExtensionData_Base>();
	}
};
static_assert(alignof(UTailShape_ExtensionData_Base) == 0x000008, "Wrong alignment on UTailShape_ExtensionData_Base");
static_assert(sizeof(UTailShape_ExtensionData_Base) == 0x000040, "Wrong size on UTailShape_ExtensionData_Base");

// Class Engine.TailShape_ExtensionData_Inertia
// 0x0038 (0x0078 - 0x0040)
class UTailShape_ExtensionData_Inertia final : public UTailShape_ExtensionData_Base
{
public:
	struct FRawDistributionFloat                  TailInertia;                                       // 0x0040(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TailShape_ExtensionData_Inertia">();
	}
	static class UTailShape_ExtensionData_Inertia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTailShape_ExtensionData_Inertia>();
	}
};
static_assert(alignof(UTailShape_ExtensionData_Inertia) == 0x000008, "Wrong alignment on UTailShape_ExtensionData_Inertia");
static_assert(sizeof(UTailShape_ExtensionData_Inertia) == 0x000078, "Wrong size on UTailShape_ExtensionData_Inertia");
static_assert(offsetof(UTailShape_ExtensionData_Inertia, TailInertia) == 0x000040, "Member 'UTailShape_ExtensionData_Inertia::TailInertia' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_EmitterTransforms
// 0x01A0 (0x01F0 - 0x0050)
class UParticleModuleSQEX_EmitterTransforms final : public UParticleModuleSQEX_Base
{
public:
	EDISPLAY_TYPE                                 DisplayType;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 LocalAddPosition;                                  // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectPosition : 1;                 // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitializeCurvePositionParameterUseOnly : 1;      // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 LocalAddRotation;                                  // 0x00B0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectRotation : 1;                 // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitializeCurveRotationParameterUseOnly : 1;      // 0x0100(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 LocalAddScale;                                     // 0x0108(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectScale : 1;                    // 0x0158(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitializeCurveScaleParameterUseOnly : 1;         // 0x0158(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsUseTransformScale : 1;                          // 0x0158(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 Velocity;                                          // 0x0160(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectVelocity : 1;                 // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitializeCurveVelocityParameterUseOnly : 1;      // 0x01B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Gravity;                                           // 0x01B8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_EmitterTransforms">();
	}
	static class UParticleModuleSQEX_EmitterTransforms* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_EmitterTransforms>();
	}
};
static_assert(alignof(UParticleModuleSQEX_EmitterTransforms) == 0x000008, "Wrong alignment on UParticleModuleSQEX_EmitterTransforms");
static_assert(sizeof(UParticleModuleSQEX_EmitterTransforms) == 0x0001F0, "Wrong size on UParticleModuleSQEX_EmitterTransforms");
static_assert(offsetof(UParticleModuleSQEX_EmitterTransforms, DisplayType) == 0x000050, "Member 'UParticleModuleSQEX_EmitterTransforms::DisplayType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTransforms, LocalAddPosition) == 0x000058, "Member 'UParticleModuleSQEX_EmitterTransforms::LocalAddPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTransforms, LocalAddRotation) == 0x0000B0, "Member 'UParticleModuleSQEX_EmitterTransforms::LocalAddRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTransforms, LocalAddScale) == 0x000108, "Member 'UParticleModuleSQEX_EmitterTransforms::LocalAddScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTransforms, Velocity) == 0x000160, "Member 'UParticleModuleSQEX_EmitterTransforms::Velocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_EmitterTransforms, Gravity) == 0x0001B8, "Member 'UParticleModuleSQEX_EmitterTransforms::Gravity' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_EmitterTransformsBase
// 0x0000 (0x0040 - 0x0040)
class UParticleModuleSQEX_EmitterTransformsBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_EmitterTransformsBase">();
	}
	static class UParticleModuleSQEX_EmitterTransformsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_EmitterTransformsBase>();
	}
};
static_assert(alignof(UParticleModuleSQEX_EmitterTransformsBase) == 0x000008, "Wrong alignment on UParticleModuleSQEX_EmitterTransformsBase");
static_assert(sizeof(UParticleModuleSQEX_EmitterTransformsBase) == 0x000040, "Wrong size on UParticleModuleSQEX_EmitterTransformsBase");

// Class Engine.ParticleModuleSQEX_ExternalVertexSpawn
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_ExternalVertexSpawn final : public UParticleModuleSQEX_LocationBase
{
public:
	ESQEX_ExternalVertexSpawnType                 ExternalVertexSpawnType;                           // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ExternalVertexSpawn">();
	}
	static class UParticleModuleSQEX_ExternalVertexSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ExternalVertexSpawn>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ExternalVertexSpawn) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_ExternalVertexSpawn");
static_assert(sizeof(UParticleModuleSQEX_ExternalVertexSpawn) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_ExternalVertexSpawn");
static_assert(offsetof(UParticleModuleSQEX_ExternalVertexSpawn, ExternalVertexSpawnType) == 0x0000F8, "Member 'UParticleModuleSQEX_ExternalVertexSpawn::ExternalVertexSpawnType' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Filter
// 0x00A8 (0x00F8 - 0x0050)
class UParticleModuleSQEX_Filter final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         UseAlphaFilterAtHDR : 1;                           // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FilterColorScaleAtHDR;                             // 0x0054(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterAlphaScaleAtHDR;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_FILTER_TYPE                             FildterType;                                       // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 FilterColor;                                       // 0x0068(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  FilterAlpha;                                       // 0x00B8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UTexture2D*                             FilterTexture;                                     // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Filter">();
	}
	static class UParticleModuleSQEX_Filter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Filter>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Filter) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Filter");
static_assert(sizeof(UParticleModuleSQEX_Filter) == 0x0000F8, "Wrong size on UParticleModuleSQEX_Filter");
static_assert(offsetof(UParticleModuleSQEX_Filter, FilterColorScaleAtHDR) == 0x000054, "Member 'UParticleModuleSQEX_Filter::FilterColorScaleAtHDR' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Filter, FilterAlphaScaleAtHDR) == 0x000060, "Member 'UParticleModuleSQEX_Filter::FilterAlphaScaleAtHDR' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Filter, FildterType) == 0x000064, "Member 'UParticleModuleSQEX_Filter::FildterType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Filter, FilterColor) == 0x000068, "Member 'UParticleModuleSQEX_Filter::FilterColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Filter, FilterAlpha) == 0x0000B8, "Member 'UParticleModuleSQEX_Filter::FilterAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Filter, FilterTexture) == 0x0000F0, "Member 'UParticleModuleSQEX_Filter::FilterTexture' has a wrong offset!");

// Class Engine.Texture2DDynamic
// 0x0000 (0x112E8D20 - 0x112E8D20)
class UTexture2DDynamic final : public UTexture
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPixelFormat                                  Format;                                            // 0x0100(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0xF];                                      // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Texture2DDynamic">();
	}
	static class UTexture2DDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTexture2DDynamic>();
	}
};
static_assert(alignof(UTexture2DDynamic) == 0x112E8D20, "Wrong alignment on UTexture2DDynamic");
static_assert(sizeof(UTexture2DDynamic) == 0x112E8D20, "Wrong size on UTexture2DDynamic");
static_assert(offsetof(UTexture2DDynamic, Format) == 0x000100, "Member 'UTexture2DDynamic::Format' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_FloatParameter
// 0x0048 (0x0098 - 0x0050)
class UParticleModuleSQEX_FloatParameter : public UParticleModuleSQEX_Base
{
public:
	class FString                                 ParameterName;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  FloatParameter;                                    // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_FloatParameter">();
	}
	static class UParticleModuleSQEX_FloatParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_FloatParameter>();
	}
};
static_assert(alignof(UParticleModuleSQEX_FloatParameter) == 0x000008, "Wrong alignment on UParticleModuleSQEX_FloatParameter");
static_assert(sizeof(UParticleModuleSQEX_FloatParameter) == 0x000098, "Wrong size on UParticleModuleSQEX_FloatParameter");
static_assert(offsetof(UParticleModuleSQEX_FloatParameter, ParameterName) == 0x000050, "Member 'UParticleModuleSQEX_FloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_FloatParameter, FloatParameter) == 0x000060, "Member 'UParticleModuleSQEX_FloatParameter::FloatParameter' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_FloatParameterEx
// 0x0010 (0x00A8 - 0x0098)
class UParticleModuleSQEX_FloatParameterEx final : public UParticleModuleSQEX_FloatParameter
{
public:
	class FString                                 CheckRowName;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_FloatParameterEx">();
	}
	static class UParticleModuleSQEX_FloatParameterEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_FloatParameterEx>();
	}
};
static_assert(alignof(UParticleModuleSQEX_FloatParameterEx) == 0x000008, "Wrong alignment on UParticleModuleSQEX_FloatParameterEx");
static_assert(sizeof(UParticleModuleSQEX_FloatParameterEx) == 0x0000A8, "Wrong size on UParticleModuleSQEX_FloatParameterEx");
static_assert(offsetof(UParticleModuleSQEX_FloatParameterEx, CheckRowName) == 0x000098, "Member 'UParticleModuleSQEX_FloatParameterEx::CheckRowName' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Fluid
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleSQEX_Fluid final : public UParticleModuleSQEX_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Fluid">();
	}
	static class UParticleModuleSQEX_Fluid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Fluid>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Fluid) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Fluid");
static_assert(sizeof(UParticleModuleSQEX_Fluid) == 0x000050, "Wrong size on UParticleModuleSQEX_Fluid");

// Class Engine.ParticleModuleSQEX_GaussBlur
// 0x0070 (0x00E0 - 0x0070)
class UParticleModuleSQEX_GaussBlur final : public UParticleModuleSQEX_BlurBase
{
public:
	struct FRawDistributionFloat                  Intensity;                                         // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Size;                                              // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_GaussBlur">();
	}
	static class UParticleModuleSQEX_GaussBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_GaussBlur>();
	}
};
static_assert(alignof(UParticleModuleSQEX_GaussBlur) == 0x000008, "Wrong alignment on UParticleModuleSQEX_GaussBlur");
static_assert(sizeof(UParticleModuleSQEX_GaussBlur) == 0x0000E0, "Wrong size on UParticleModuleSQEX_GaussBlur");
static_assert(offsetof(UParticleModuleSQEX_GaussBlur, Intensity) == 0x000070, "Member 'UParticleModuleSQEX_GaussBlur::Intensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_GaussBlur, Size) == 0x0000A8, "Member 'UParticleModuleSQEX_GaussBlur::Size' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Gravity
// 0x02E0 (0x0338 - 0x0058)
class UParticleModuleSQEX_Gravity final : public UParticleModuleVelocityBase
{
public:
	uint8                                         bUseEmitterTime : 1;                               // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Gravity;                                           // 0x0060(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GravityInfluenceScale;                             // 0x0098(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GravityHeightt;                                    // 0x00D0(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GravityHeighttAddRandom;                           // 0x0108(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bMoveCalumToTime : 1;                              // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  OnGravity;                                         // 0x0148(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  BaseHeight;                                        // 0x0180(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GravityMoveTime;                                   // 0x01B8(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         EndSpeedScale;                                     // 0x01F0(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCheckRadius : 1;                                  // 0x01F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CheckRadius;                                       // 0x01F8(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bRadiusReflectionRate : 1;                         // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadiusReflectionRate;                              // 0x0234(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGroundCheck : 1;                                  // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  GroundHeight;                                      // 0x0240(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GroundCheckRadius;                                 // 0x0278(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCanFloorReflection : 1;                           // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloorReflectionRate;                               // 0x02B4(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectionZVelocity;                               // 0x02B8(0x0004)(Edit, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Drag;                                              // 0x02C0(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableDragX : 1;                                  // 0x02F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDragY : 1;                                  // 0x02F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDragZ : 1;                                  // 0x02F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDragZ : 1;                                     // 0x02F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  DragZ;                                             // 0x0300(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Gravity">();
	}
	static class UParticleModuleSQEX_Gravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Gravity>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Gravity) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Gravity");
static_assert(sizeof(UParticleModuleSQEX_Gravity) == 0x000338, "Wrong size on UParticleModuleSQEX_Gravity");
static_assert(offsetof(UParticleModuleSQEX_Gravity, Gravity) == 0x000060, "Member 'UParticleModuleSQEX_Gravity::Gravity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, GravityInfluenceScale) == 0x000098, "Member 'UParticleModuleSQEX_Gravity::GravityInfluenceScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, GravityHeightt) == 0x0000D0, "Member 'UParticleModuleSQEX_Gravity::GravityHeightt' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, GravityHeighttAddRandom) == 0x000108, "Member 'UParticleModuleSQEX_Gravity::GravityHeighttAddRandom' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, OnGravity) == 0x000148, "Member 'UParticleModuleSQEX_Gravity::OnGravity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, BaseHeight) == 0x000180, "Member 'UParticleModuleSQEX_Gravity::BaseHeight' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, GravityMoveTime) == 0x0001B8, "Member 'UParticleModuleSQEX_Gravity::GravityMoveTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, EndSpeedScale) == 0x0001F0, "Member 'UParticleModuleSQEX_Gravity::EndSpeedScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, CheckRadius) == 0x0001F8, "Member 'UParticleModuleSQEX_Gravity::CheckRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, RadiusReflectionRate) == 0x000234, "Member 'UParticleModuleSQEX_Gravity::RadiusReflectionRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, GroundHeight) == 0x000240, "Member 'UParticleModuleSQEX_Gravity::GroundHeight' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, GroundCheckRadius) == 0x000278, "Member 'UParticleModuleSQEX_Gravity::GroundCheckRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, FloorReflectionRate) == 0x0002B4, "Member 'UParticleModuleSQEX_Gravity::FloorReflectionRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, ReflectionZVelocity) == 0x0002B8, "Member 'UParticleModuleSQEX_Gravity::ReflectionZVelocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, Drag) == 0x0002C0, "Member 'UParticleModuleSQEX_Gravity::Drag' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Gravity, DragZ) == 0x000300, "Member 'UParticleModuleSQEX_Gravity::DragZ' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_InitSizeScale
// 0x0058 (0x00A8 - 0x0050)
class UParticleModuleSQEX_InitSizeScale final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bIsScale : 1;                                      // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 ParticleSizeScale;                                 // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_InitSizeScale">();
	}
	static class UParticleModuleSQEX_InitSizeScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_InitSizeScale>();
	}
};
static_assert(alignof(UParticleModuleSQEX_InitSizeScale) == 0x000008, "Wrong alignment on UParticleModuleSQEX_InitSizeScale");
static_assert(sizeof(UParticleModuleSQEX_InitSizeScale) == 0x0000A8, "Wrong size on UParticleModuleSQEX_InitSizeScale");
static_assert(offsetof(UParticleModuleSQEX_InitSizeScale, ParticleSizeScale) == 0x000058, "Member 'UParticleModuleSQEX_InitSizeScale::ParticleSizeScale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_LocalParticle
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleSQEX_LocalParticle final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bIsPosition : 1;                                   // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRotation : 1;                                   // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLocalRotation : 1;                              // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_LocalParticle">();
	}
	static class UParticleModuleSQEX_LocalParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_LocalParticle>();
	}
};
static_assert(alignof(UParticleModuleSQEX_LocalParticle) == 0x000008, "Wrong alignment on UParticleModuleSQEX_LocalParticle");
static_assert(sizeof(UParticleModuleSQEX_LocalParticle) == 0x000058, "Wrong size on UParticleModuleSQEX_LocalParticle");

// Class Engine.ParticleModuleSQEX_LocalTakeover
// 0x0008 (0x0048 - 0x0040)
class UParticleModuleSQEX_LocalTakeover final : public UObject
{
public:
	uint8                                         bIsPosition : 1;                                   // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRotation : 1;                                   // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsScale : 1;                                      // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_LocalTakeover">();
	}
	static class UParticleModuleSQEX_LocalTakeover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_LocalTakeover>();
	}
};
static_assert(alignof(UParticleModuleSQEX_LocalTakeover) == 0x000008, "Wrong alignment on UParticleModuleSQEX_LocalTakeover");
static_assert(sizeof(UParticleModuleSQEX_LocalTakeover) == 0x000048, "Wrong size on UParticleModuleSQEX_LocalTakeover");

// Class Engine.ParticleModuleSQEX_Material
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleSQEX_Material : public UParticleModule
{
public:
	class FName                                   ParamName;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NoSetUseLastParameter : 1;                         // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Material">();
	}
	static class UParticleModuleSQEX_Material* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Material>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Material) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Material");
static_assert(sizeof(UParticleModuleSQEX_Material) == 0x000060, "Wrong size on UParticleModuleSQEX_Material");
static_assert(offsetof(UParticleModuleSQEX_Material, ParamName) == 0x000050, "Member 'UParticleModuleSQEX_Material::ParamName' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Material_Aura
// 0x00D8 (0x0138 - 0x0060)
class UParticleModuleSQEX_Material_Aura final : public UParticleModuleSQEX_Material
{
public:
	struct FRawDistributionFloat                  Aura;                                              // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 AuraColor;                                         // 0x0098(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 AuraOutColor;                                      // 0x00E8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Material_Aura">();
	}
	static class UParticleModuleSQEX_Material_Aura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Material_Aura>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Material_Aura) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Material_Aura");
static_assert(sizeof(UParticleModuleSQEX_Material_Aura) == 0x000138, "Wrong size on UParticleModuleSQEX_Material_Aura");
static_assert(offsetof(UParticleModuleSQEX_Material_Aura, Aura) == 0x000060, "Member 'UParticleModuleSQEX_Material_Aura::Aura' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_Aura, AuraColor) == 0x000098, "Member 'UParticleModuleSQEX_Material_Aura::AuraColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_Aura, AuraOutColor) == 0x0000E8, "Member 'UParticleModuleSQEX_Material_Aura::AuraOutColor' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Material_InLight
// 0x01F8 (0x0258 - 0x0060)
class UParticleModuleSQEX_Material_InLight final : public UParticleModuleSQEX_Material
{
public:
	ESQEX_IN_LIGHT_TYPE                           ParamType;                                         // 0x0060(0x0001)(Edit, ExportObject, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  InLightParam;                                      // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 InLightColor;                                      // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 InLightOutColor;                                   // 0x00F0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  InLightCenterBounds;                               // 0x0140(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  InLightCenterBoundsBlur;                           // 0x0178(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  InLightOutBounds;                                  // 0x01B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  InLightOutBoundsBlur;                              // 0x01E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  InLightCameraOffset;                               // 0x0220(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Material_InLight">();
	}
	static class UParticleModuleSQEX_Material_InLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Material_InLight>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Material_InLight) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Material_InLight");
static_assert(sizeof(UParticleModuleSQEX_Material_InLight) == 0x000258, "Wrong size on UParticleModuleSQEX_Material_InLight");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, ParamType) == 0x000060, "Member 'UParticleModuleSQEX_Material_InLight::ParamType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightParam) == 0x000068, "Member 'UParticleModuleSQEX_Material_InLight::InLightParam' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightColor) == 0x0000A0, "Member 'UParticleModuleSQEX_Material_InLight::InLightColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightOutColor) == 0x0000F0, "Member 'UParticleModuleSQEX_Material_InLight::InLightOutColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightCenterBounds) == 0x000140, "Member 'UParticleModuleSQEX_Material_InLight::InLightCenterBounds' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightCenterBoundsBlur) == 0x000178, "Member 'UParticleModuleSQEX_Material_InLight::InLightCenterBoundsBlur' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightOutBounds) == 0x0001B0, "Member 'UParticleModuleSQEX_Material_InLight::InLightOutBounds' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightOutBoundsBlur) == 0x0001E8, "Member 'UParticleModuleSQEX_Material_InLight::InLightOutBoundsBlur' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_InLight, InLightCameraOffset) == 0x000220, "Member 'UParticleModuleSQEX_Material_InLight::InLightCameraOffset' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Material_Scalar
// 0x0038 (0x0098 - 0x0060)
class UParticleModuleSQEX_Material_Scalar : public UParticleModuleSQEX_Material
{
public:
	struct FRawDistributionFloat                  MaterialScalarParam;                               // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Material_Scalar">();
	}
	static class UParticleModuleSQEX_Material_Scalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Material_Scalar>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Material_Scalar) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Material_Scalar");
static_assert(sizeof(UParticleModuleSQEX_Material_Scalar) == 0x000098, "Wrong size on UParticleModuleSQEX_Material_Scalar");
static_assert(offsetof(UParticleModuleSQEX_Material_Scalar, MaterialScalarParam) == 0x000060, "Member 'UParticleModuleSQEX_Material_Scalar::MaterialScalarParam' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_If_Material_Scalar
// 0x0010 (0x00A8 - 0x0098)
class UParticleModuleSQEX_If_Material_Scalar final : public UParticleModuleSQEX_Material_Scalar
{
public:
	class FName                                   IfParamName;                                       // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IfValue;                                           // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_If_Material_Scalar">();
	}
	static class UParticleModuleSQEX_If_Material_Scalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_If_Material_Scalar>();
	}
};
static_assert(alignof(UParticleModuleSQEX_If_Material_Scalar) == 0x000008, "Wrong alignment on UParticleModuleSQEX_If_Material_Scalar");
static_assert(sizeof(UParticleModuleSQEX_If_Material_Scalar) == 0x0000A8, "Wrong size on UParticleModuleSQEX_If_Material_Scalar");
static_assert(offsetof(UParticleModuleSQEX_If_Material_Scalar, IfParamName) == 0x000098, "Member 'UParticleModuleSQEX_If_Material_Scalar::IfParamName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_If_Material_Scalar, IfValue) == 0x0000A0, "Member 'UParticleModuleSQEX_If_Material_Scalar::IfValue' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Material_SendParticlePosToMaterial
// 0x0048 (0x00A8 - 0x0060)
class UParticleModuleSQEX_Material_SendParticlePosToMaterial final : public UParticleModuleSQEX_Material
{
public:
	bool                                          GetOwnerEmitterParticle;                           // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SendParticleNumber;                                // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetParticlePosAtRenderTarget;                     // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RTTexture;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 ClipTexture;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FieldMax;                                          // 0x0084(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FieldMin;                                          // 0x0090(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Simscale;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Material_SendParticlePosToMaterial">();
	}
	static class UParticleModuleSQEX_Material_SendParticlePosToMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Material_SendParticlePosToMaterial>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Material_SendParticlePosToMaterial) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Material_SendParticlePosToMaterial");
static_assert(sizeof(UParticleModuleSQEX_Material_SendParticlePosToMaterial) == 0x0000A8, "Wrong size on UParticleModuleSQEX_Material_SendParticlePosToMaterial");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, GetOwnerEmitterParticle) == 0x000060, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::GetOwnerEmitterParticle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, SendParticleNumber) == 0x000064, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::SendParticleNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, bSetParticlePosAtRenderTarget) == 0x000068, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::bSetParticlePosAtRenderTarget' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, RTTexture) == 0x000070, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::RTTexture' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, ClipTexture) == 0x000078, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::ClipTexture' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, BlendMode) == 0x000080, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::BlendMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, FieldMax) == 0x000084, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::FieldMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, FieldMin) == 0x000090, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::FieldMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, Height) == 0x00009C, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::Height' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_SendParticlePosToMaterial, Simscale) == 0x0000A0, "Member 'UParticleModuleSQEX_Material_SendParticlePosToMaterial::Simscale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Material_Vector
// 0x0098 (0x00F8 - 0x0060)
class UParticleModuleSQEX_Material_Vector final : public UParticleModuleSQEX_Material
{
public:
	class FName                                   BoneOrSocketName;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseMyCurrentMaterial : 1;                         // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 MaterialVectorParam;                               // 0x0070(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  MaterialAlphaParam;                                // 0x00C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Material_Vector">();
	}
	static class UParticleModuleSQEX_Material_Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Material_Vector>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Material_Vector) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Material_Vector");
static_assert(sizeof(UParticleModuleSQEX_Material_Vector) == 0x0000F8, "Wrong size on UParticleModuleSQEX_Material_Vector");
static_assert(offsetof(UParticleModuleSQEX_Material_Vector, BoneOrSocketName) == 0x000060, "Member 'UParticleModuleSQEX_Material_Vector::BoneOrSocketName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_Vector, MaterialVectorParam) == 0x000070, "Member 'UParticleModuleSQEX_Material_Vector::MaterialVectorParam' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Material_Vector, MaterialAlphaParam) == 0x0000C0, "Member 'UParticleModuleSQEX_Material_Vector::MaterialAlphaParam' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_MeshPivotOffset
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleSQEX_MeshPivotOffset final : public UParticleModuleLocationBase
{
public:
	struct FVector                                PivotOffset;                                       // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_MeshPivotOffset">();
	}
	static class UParticleModuleSQEX_MeshPivotOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_MeshPivotOffset>();
	}
};
static_assert(alignof(UParticleModuleSQEX_MeshPivotOffset) == 0x000008, "Wrong alignment on UParticleModuleSQEX_MeshPivotOffset");
static_assert(sizeof(UParticleModuleSQEX_MeshPivotOffset) == 0x000060, "Wrong size on UParticleModuleSQEX_MeshPivotOffset");
static_assert(offsetof(UParticleModuleSQEX_MeshPivotOffset, PivotOffset) == 0x000050, "Member 'UParticleModuleSQEX_MeshPivotOffset::PivotOffset' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_OverrideParPostion
// 0x0178 (0x01C8 - 0x0050)
class UParticleModuleSQEX_OverrideParPostion final : public UParticleModuleLocationBase
{
public:
	ESQEX_OVERRIDE_PARTICLE_POS_TYPE              OverridePosType;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GetOwnerEmitterParticle;                           // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParticleNumber;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingNumber;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingPointNumber;                                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RingRadiusBase;                                    // 0x0060(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         RingRadius;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  AddStartIndex;                                     // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 InitRingRot;                                       // 0x00D8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 UpdateBaseRingRot;                                 // 0x0128(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 UpdateRingRot;                                     // 0x0178(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_OverrideParPostion">();
	}
	static class UParticleModuleSQEX_OverrideParPostion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_OverrideParPostion>();
	}
};
static_assert(alignof(UParticleModuleSQEX_OverrideParPostion) == 0x000008, "Wrong alignment on UParticleModuleSQEX_OverrideParPostion");
static_assert(sizeof(UParticleModuleSQEX_OverrideParPostion) == 0x0001C8, "Wrong size on UParticleModuleSQEX_OverrideParPostion");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, OverridePosType) == 0x000050, "Member 'UParticleModuleSQEX_OverrideParPostion::OverridePosType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, GetOwnerEmitterParticle) == 0x000051, "Member 'UParticleModuleSQEX_OverrideParPostion::GetOwnerEmitterParticle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, ParticleNumber) == 0x000054, "Member 'UParticleModuleSQEX_OverrideParPostion::ParticleNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, RingNumber) == 0x000058, "Member 'UParticleModuleSQEX_OverrideParPostion::RingNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, RingPointNumber) == 0x00005C, "Member 'UParticleModuleSQEX_OverrideParPostion::RingPointNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, RingRadiusBase) == 0x000060, "Member 'UParticleModuleSQEX_OverrideParPostion::RingRadiusBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, RingRadius) == 0x000098, "Member 'UParticleModuleSQEX_OverrideParPostion::RingRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, AddStartIndex) == 0x0000A0, "Member 'UParticleModuleSQEX_OverrideParPostion::AddStartIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, InitRingRot) == 0x0000D8, "Member 'UParticleModuleSQEX_OverrideParPostion::InitRingRot' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, UpdateBaseRingRot) == 0x000128, "Member 'UParticleModuleSQEX_OverrideParPostion::UpdateBaseRingRot' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_OverrideParPostion, UpdateRingRot) == 0x000178, "Member 'UParticleModuleSQEX_OverrideParPostion::UpdateRingRot' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParameterCollection
// 0x0020 (0x0070 - 0x0050)
class UParticleModuleSQEX_ParameterCollection final : public UParticleModuleSQEX_Base
{
public:
	int32                                         Priority;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           ParamCollection;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_EmitterParameterCollection> ParameterCollection;                               // 0x0060(0x0010)(Edit, EditFixedSize, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParameterCollection">();
	}
	static class UParticleModuleSQEX_ParameterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParameterCollection>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParameterCollection) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParameterCollection");
static_assert(sizeof(UParticleModuleSQEX_ParameterCollection) == 0x000070, "Wrong size on UParticleModuleSQEX_ParameterCollection");
static_assert(offsetof(UParticleModuleSQEX_ParameterCollection, Priority) == 0x000050, "Member 'UParticleModuleSQEX_ParameterCollection::Priority' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParameterCollection, ParamCollection) == 0x000058, "Member 'UParticleModuleSQEX_ParameterCollection::ParamCollection' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParameterCollection, ParameterCollection) == 0x000060, "Member 'UParticleModuleSQEX_ParameterCollection::ParameterCollection' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Parent
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleSQEX_Parent final : public UParticleModuleSQEX_Base
{
public:
	float                                         AllLoopEndTime;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGrandsonLoopEnd : 1;                              // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_ParticleChildData>        ChildrenData;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Parent">();
	}
	static class UParticleModuleSQEX_Parent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Parent>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Parent) == 0x000008, "Wrong alignment on UParticleModuleSQEX_Parent");
static_assert(sizeof(UParticleModuleSQEX_Parent) == 0x000068, "Wrong size on UParticleModuleSQEX_Parent");
static_assert(offsetof(UParticleModuleSQEX_Parent, AllLoopEndTime) == 0x000050, "Member 'UParticleModuleSQEX_Parent::AllLoopEndTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Parent, ChildrenData) == 0x000058, "Member 'UParticleModuleSQEX_Parent::ChildrenData' has a wrong offset!");

// Class Engine.RadialForceComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class URadialForceComponent final : public USceneComponent
{
public:
	float                                         Radius;                                            // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERadialImpulseFalloff                         Falloff;                                           // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseStrength;                                   // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bImpulseVelChange : 1;                             // 0x0424(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreOwningActor : 1;                            // 0x0424(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceStrength;                                     // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructibleDamage;                                // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypesToAffect;                               // 0x0430(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjectTypeToAffect(EObjectTypeQuery ObjectType);
	void FireImpulse();
	void RemoveObjectTypeToAffect(EObjectTypeQuery ObjectType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialForceComponent">();
	}
	static class URadialForceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialForceComponent>();
	}
};
static_assert(alignof(URadialForceComponent) == 0x112E9AF0, "Wrong alignment on URadialForceComponent");
static_assert(sizeof(URadialForceComponent) == 0x112E9AF0, "Wrong size on URadialForceComponent");
static_assert(offsetof(URadialForceComponent, Radius) == 0x000418, "Member 'URadialForceComponent::Radius' has a wrong offset!");
static_assert(offsetof(URadialForceComponent, Falloff) == 0x00041C, "Member 'URadialForceComponent::Falloff' has a wrong offset!");
static_assert(offsetof(URadialForceComponent, ImpulseStrength) == 0x000420, "Member 'URadialForceComponent::ImpulseStrength' has a wrong offset!");
static_assert(offsetof(URadialForceComponent, ForceStrength) == 0x000428, "Member 'URadialForceComponent::ForceStrength' has a wrong offset!");
static_assert(offsetof(URadialForceComponent, DestructibleDamage) == 0x00042C, "Member 'URadialForceComponent::DestructibleDamage' has a wrong offset!");
static_assert(offsetof(URadialForceComponent, ObjectTypesToAffect) == 0x000430, "Member 'URadialForceComponent::ObjectTypesToAffect' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParticleAround
// 0x02B0 (0x0300 - 0x0050)
class UParticleModuleSQEX_ParticleAround final : public UParticleModuleSQEX_Base
{
public:
	ESQEX_AROUND_TYPE                             AroundType;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AroundPostion;                                     // 0x0054(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundRadius;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AroundSpeedBase;                                   // 0x0064(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AroundRadiusScale;                                 // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AroundRadiusRandom;                                // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 AroundVelocityScale;                               // 0x00E0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 AroundVelocityRandom;                              // 0x0130(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAroundDirRandom : 1;                              // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttachInHomingEndRadius;                           // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingMaxAngle;                                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  HomingTurnMax;                                     // 0x0190(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bHomingTurnByDistance : 1;                         // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Strength;                                          // 0x01D0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bStrengthByDistance : 1;                           // 0x0208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 ClampAroundSpeed;                                  // 0x0210(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 AddContactRotaion;                                 // 0x0260(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ContactDirTime;                                    // 0x02B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                AroundMeshRotaionOffset;                           // 0x02E8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseTestMode : 1;                                  // 0x02F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeModeTime;                                    // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleAround">();
	}
	static class UParticleModuleSQEX_ParticleAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleAround>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleAround) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParticleAround");
static_assert(sizeof(UParticleModuleSQEX_ParticleAround) == 0x000300, "Wrong size on UParticleModuleSQEX_ParticleAround");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundType) == 0x000050, "Member 'UParticleModuleSQEX_ParticleAround::AroundType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundPostion) == 0x000054, "Member 'UParticleModuleSQEX_ParticleAround::AroundPostion' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundRadius) == 0x000060, "Member 'UParticleModuleSQEX_ParticleAround::AroundRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundSpeedBase) == 0x000064, "Member 'UParticleModuleSQEX_ParticleAround::AroundSpeedBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundRadiusScale) == 0x000070, "Member 'UParticleModuleSQEX_ParticleAround::AroundRadiusScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundRadiusRandom) == 0x0000A8, "Member 'UParticleModuleSQEX_ParticleAround::AroundRadiusRandom' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundVelocityScale) == 0x0000E0, "Member 'UParticleModuleSQEX_ParticleAround::AroundVelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundVelocityRandom) == 0x000130, "Member 'UParticleModuleSQEX_ParticleAround::AroundVelocityRandom' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AttachInHomingEndRadius) == 0x000184, "Member 'UParticleModuleSQEX_ParticleAround::AttachInHomingEndRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, HomingMaxAngle) == 0x000188, "Member 'UParticleModuleSQEX_ParticleAround::HomingMaxAngle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, HomingTurnMax) == 0x000190, "Member 'UParticleModuleSQEX_ParticleAround::HomingTurnMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, Strength) == 0x0001D0, "Member 'UParticleModuleSQEX_ParticleAround::Strength' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, ClampAroundSpeed) == 0x000210, "Member 'UParticleModuleSQEX_ParticleAround::ClampAroundSpeed' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AddContactRotaion) == 0x000260, "Member 'UParticleModuleSQEX_ParticleAround::AddContactRotaion' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, ContactDirTime) == 0x0002B0, "Member 'UParticleModuleSQEX_ParticleAround::ContactDirTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, AroundMeshRotaionOffset) == 0x0002E8, "Member 'UParticleModuleSQEX_ParticleAround::AroundMeshRotaionOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleAround, ChangeModeTime) == 0x0002F8, "Member 'UParticleModuleSQEX_ParticleAround::ChangeModeTime' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParticleColor
// 0x01A0 (0x01F0 - 0x0050)
class UParticleModuleSQEX_ParticleColor final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionVector                 StartParticleColor;                                // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StartParticleAlpha;                                // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleColor;                                     // 0x00D8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ParticleAlpha;                                     // 0x0128(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleColorScale;                                // 0x0160(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ParticleAlphaScale;                                // 0x01B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectColor : 1;                    // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEmitterTime : 1;                                  // 0x01E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleColor">();
	}
	static class UParticleModuleSQEX_ParticleColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleColor>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleColor) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParticleColor");
static_assert(sizeof(UParticleModuleSQEX_ParticleColor) == 0x0001F0, "Wrong size on UParticleModuleSQEX_ParticleColor");
static_assert(offsetof(UParticleModuleSQEX_ParticleColor, StartParticleColor) == 0x000050, "Member 'UParticleModuleSQEX_ParticleColor::StartParticleColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleColor, StartParticleAlpha) == 0x0000A0, "Member 'UParticleModuleSQEX_ParticleColor::StartParticleAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleColor, ParticleColor) == 0x0000D8, "Member 'UParticleModuleSQEX_ParticleColor::ParticleColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleColor, ParticleAlpha) == 0x000128, "Member 'UParticleModuleSQEX_ParticleColor::ParticleAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleColor, ParticleColorScale) == 0x000160, "Member 'UParticleModuleSQEX_ParticleColor::ParticleColorScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleColor, ParticleAlphaScale) == 0x0001B0, "Member 'UParticleModuleSQEX_ParticleColor::ParticleAlphaScale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParticleLocation
// 0x00A8 (0x00F8 - 0x0050)
class UParticleModuleSQEX_ParticleLocation final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionVector                 StartScale;                                        // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 Location;                                          // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         EnableX : 1;                                       // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnableY : 1;                                       // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnableZ : 1;                                       // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseMeshParticleRotaion : 1;                        // 0x00F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInWorldSpace : 1;                                 // 0x00F0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyOwnerScale : 1;                              // 0x00F0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleLocation">();
	}
	static class UParticleModuleSQEX_ParticleLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleLocation>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleLocation) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParticleLocation");
static_assert(sizeof(UParticleModuleSQEX_ParticleLocation) == 0x0000F8, "Wrong size on UParticleModuleSQEX_ParticleLocation");
static_assert(offsetof(UParticleModuleSQEX_ParticleLocation, StartScale) == 0x000050, "Member 'UParticleModuleSQEX_ParticleLocation::StartScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleLocation, Location) == 0x0000A0, "Member 'UParticleModuleSQEX_ParticleLocation::Location' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParticleRotation
// 0x00F8 (0x0148 - 0x0050)
class UParticleModuleSQEX_ParticleRotation final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionVector                 StartParticleRotation;                             // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleRotation;                                  // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleRotationScale;                             // 0x00F0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectRotation : 1;                 // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bParticleRotationSpawnTimeOnly : 1;                // 0x0140(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMeshRotAdjustEmitterRot : 1;                      // 0x0140(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEmitterTime : 1;                                  // 0x0140(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseParticleModuleTime : 1;                        // 0x0140(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseCalcMeshRotMat : 1;                            // 0x0140(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleRotation">();
	}
	static class UParticleModuleSQEX_ParticleRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleRotation>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleRotation) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParticleRotation");
static_assert(sizeof(UParticleModuleSQEX_ParticleRotation) == 0x000148, "Wrong size on UParticleModuleSQEX_ParticleRotation");
static_assert(offsetof(UParticleModuleSQEX_ParticleRotation, StartParticleRotation) == 0x000050, "Member 'UParticleModuleSQEX_ParticleRotation::StartParticleRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleRotation, ParticleRotation) == 0x0000A0, "Member 'UParticleModuleSQEX_ParticleRotation::ParticleRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleRotation, ParticleRotationScale) == 0x0000F0, "Member 'UParticleModuleSQEX_ParticleRotation::ParticleRotationScale' has a wrong offset!");

// Class Engine.RendererSettings
// 0x0088 (0x00D8 - 0x0050)
class URendererSettings final : public UDeveloperSettings
{
public:
	uint8                                         bMobileHDR : 1;                                    // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMobileDisableVertexFog : 1;                       // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxMobileCascades;                                 // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMobileMSAASampleCount                        MobileMSAASampleCount;                             // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDiscardUnusedQualityLevels : 1;                   // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOcclusionCulling : 1;                             // 0x005C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinScreenRadiusForLights;                          // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScreenRadiusForEarlyZPass;                      // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScreenRadiusForCSMdepth;                        // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPrecomputedVisibilityWarning : 1;                 // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTextureStreaming : 1;                             // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDXT5NormalMaps : 1;                            // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClearCoatEnableSecondNormal : 1;                  // 0x006C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReflectionCaptureResolution;                       // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReflectionEnvironmentLightmapMixBasedOnRoughness : 1; // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForwardShading : 1;                               // 0x0074(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVertexFoggingForOpaque : 1;                       // 0x0074(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowStaticLighting : 1;                          // 0x0074(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseNormalMapsForStaticLighting : 1;               // 0x0074(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateMeshDistanceFields : 1;                   // 0x0074(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEightBitMeshDistanceFields : 1;                   // 0x0074(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGenerateLandscapeGIData : 1;                      // 0x0074(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompressMeshDistanceFields : 1;                   // 0x0075(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TessellationAdaptivePixelsPerTriangle;             // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSeparateTranslucency : 1;                         // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETranslucentSortPolicy                        TranslucentSortPolicy;                             // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TranslucentSortAxis;                               // 0x0084(0x000C)(Edit, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomDepthStencil                           CustomDepthStencil;                                // 0x0090(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCustomDepthTaaJitter : 1;                         // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableAlphaChannelInPostProcessing : 1;           // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultFeatureBloom : 1;                          // 0x0094(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultFeatureAmbientOcclusion : 1;               // 0x0094(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultFeatureAmbientOcclusionStaticFraction : 1; // 0x0094(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultFeatureAutoExposure : 1;                   // 0x0094(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAutoExposureMethodUI                         DefaultFeatureAutoExposure;                        // 0x0098(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDefaultFeatureMotionBlur : 1;                     // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultFeatureLensFlare : 1;                      // 0x009C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAntiAliasingMethod                           DefaultFeatureAntiAliasing;                        // 0x00A0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bStencilForLODDither : 1;                          // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EEarlyZPass                                   EarlyZPass;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEarlyZPassMovable : 1;                            // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEarlyZPassOnlyMaterialMasking : 1;                // 0x00AC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDBuffer : 1;                                      // 0x00AC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EClearSceneOptions                            ClearSceneMethod;                                  // 0x00B0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBasePassOutputsVelocity : 1;                      // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSelectiveBasePassOutputs : 1;                     // 0x00B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultParticleCutouts : 1;                       // 0x00B4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGlobalClipPlane : 1;                              // 0x00B4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EGBufferFormat                                GBufferFormat;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseGPUMorphTargets : 1;                           // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNvidiaAftermathEnabled : 1;                       // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstancedStereo : 1;                              // 0x00BC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMultiView : 1;                                    // 0x00BC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMobileMultiView : 1;                              // 0x00BC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMobileMultiViewDirect : 1;                        // 0x00BC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMonoscopicFarField : 1;                           // 0x00BC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WireframeCullThreshold;                            // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSupportStationarySkylight : 1;                    // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportLowQualityLightmaps : 1;                   // 0x00C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportPointLightWholeSceneShadows : 1;           // 0x00C4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportAtmosphericFog : 1;                        // 0x00C4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportSkinCacheShaders : 1;                      // 0x00C4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMobileEnableStaticAndCSMShadowReceivers : 1;      // 0x00C4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMobileAllowDistanceFieldShadows : 1;              // 0x00C4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMobileAllowMovableDirectionalLights : 1;          // 0x00C4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MobileNumDynamicPointLights;                       // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMobileDynamicPointLightsUseStaticBranch : 1;      // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkinCacheSceneMemoryLimitInMB;                     // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGPUSkinLimit2BoneInfluences : 1;                  // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RendererSettings">();
	}
	static class URendererSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URendererSettings>();
	}
};
static_assert(alignof(URendererSettings) == 0x000008, "Wrong alignment on URendererSettings");
static_assert(sizeof(URendererSettings) == 0x0000D8, "Wrong size on URendererSettings");
static_assert(offsetof(URendererSettings, MaxMobileCascades) == 0x000054, "Member 'URendererSettings::MaxMobileCascades' has a wrong offset!");
static_assert(offsetof(URendererSettings, MobileMSAASampleCount) == 0x000058, "Member 'URendererSettings::MobileMSAASampleCount' has a wrong offset!");
static_assert(offsetof(URendererSettings, MinScreenRadiusForLights) == 0x000060, "Member 'URendererSettings::MinScreenRadiusForLights' has a wrong offset!");
static_assert(offsetof(URendererSettings, MinScreenRadiusForEarlyZPass) == 0x000064, "Member 'URendererSettings::MinScreenRadiusForEarlyZPass' has a wrong offset!");
static_assert(offsetof(URendererSettings, MinScreenRadiusForCSMdepth) == 0x000068, "Member 'URendererSettings::MinScreenRadiusForCSMdepth' has a wrong offset!");
static_assert(offsetof(URendererSettings, ReflectionCaptureResolution) == 0x000070, "Member 'URendererSettings::ReflectionCaptureResolution' has a wrong offset!");
static_assert(offsetof(URendererSettings, TessellationAdaptivePixelsPerTriangle) == 0x000078, "Member 'URendererSettings::TessellationAdaptivePixelsPerTriangle' has a wrong offset!");
static_assert(offsetof(URendererSettings, TranslucentSortPolicy) == 0x000080, "Member 'URendererSettings::TranslucentSortPolicy' has a wrong offset!");
static_assert(offsetof(URendererSettings, TranslucentSortAxis) == 0x000084, "Member 'URendererSettings::TranslucentSortAxis' has a wrong offset!");
static_assert(offsetof(URendererSettings, CustomDepthStencil) == 0x000090, "Member 'URendererSettings::CustomDepthStencil' has a wrong offset!");
static_assert(offsetof(URendererSettings, DefaultFeatureAutoExposure) == 0x000098, "Member 'URendererSettings::DefaultFeatureAutoExposure' has a wrong offset!");
static_assert(offsetof(URendererSettings, DefaultFeatureAntiAliasing) == 0x0000A0, "Member 'URendererSettings::DefaultFeatureAntiAliasing' has a wrong offset!");
static_assert(offsetof(URendererSettings, EarlyZPass) == 0x0000A8, "Member 'URendererSettings::EarlyZPass' has a wrong offset!");
static_assert(offsetof(URendererSettings, ClearSceneMethod) == 0x0000B0, "Member 'URendererSettings::ClearSceneMethod' has a wrong offset!");
static_assert(offsetof(URendererSettings, GBufferFormat) == 0x0000B8, "Member 'URendererSettings::GBufferFormat' has a wrong offset!");
static_assert(offsetof(URendererSettings, WireframeCullThreshold) == 0x0000C0, "Member 'URendererSettings::WireframeCullThreshold' has a wrong offset!");
static_assert(offsetof(URendererSettings, MobileNumDynamicPointLights) == 0x0000C8, "Member 'URendererSettings::MobileNumDynamicPointLights' has a wrong offset!");
static_assert(offsetof(URendererSettings, SkinCacheSceneMemoryLimitInMB) == 0x0000D0, "Member 'URendererSettings::SkinCacheSceneMemoryLimitInMB' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParticleRotationZ
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleSQEX_ParticleRotationZ final : public UParticleModuleSQEX_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleRotationZ">();
	}
	static class UParticleModuleSQEX_ParticleRotationZ* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleRotationZ>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleRotationZ) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParticleRotationZ");
static_assert(sizeof(UParticleModuleSQEX_ParticleRotationZ) == 0x000050, "Wrong size on UParticleModuleSQEX_ParticleRotationZ");

// Class Engine.ParticleModuleSQEX_ParticleScale
// 0x00F8 (0x0148 - 0x0050)
class UParticleModuleSQEX_ParticleScale final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionVector                 StartParticleScale;                                // 0x0050(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleScale;                                     // 0x00A0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleScaleScale;                                // 0x00F0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bCurveParameterDirectScale : 1;                    // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEmitterTime : 1;                                  // 0x0140(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleScale">();
	}
	static class UParticleModuleSQEX_ParticleScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleScale>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleScale) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ParticleScale");
static_assert(sizeof(UParticleModuleSQEX_ParticleScale) == 0x000148, "Wrong size on UParticleModuleSQEX_ParticleScale");
static_assert(offsetof(UParticleModuleSQEX_ParticleScale, StartParticleScale) == 0x000050, "Member 'UParticleModuleSQEX_ParticleScale::StartParticleScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleScale, ParticleScale) == 0x0000A0, "Member 'UParticleModuleSQEX_ParticleScale::ParticleScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleScale, ParticleScaleScale) == 0x0000F0, "Member 'UParticleModuleSQEX_ParticleScale::ParticleScaleScale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ParticleState
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleSQEX_ParticleState final : public UParticleModuleSQEX_Base
{
public:
	struct FRotator                               RotA;                                              // 0x0050(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotB;                                              // 0x005C(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Diff;                                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ParticleState">();
	}
	static class UParticleModuleSQEX_ParticleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ParticleState>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ParticleState) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_ParticleState");
static_assert(sizeof(UParticleModuleSQEX_ParticleState) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_ParticleState");
static_assert(offsetof(UParticleModuleSQEX_ParticleState, RotA) == 0x000050, "Member 'UParticleModuleSQEX_ParticleState::RotA' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleState, RotB) == 0x00005C, "Member 'UParticleModuleSQEX_ParticleState::RotB' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ParticleState, Diff) == 0x000068, "Member 'UParticleModuleSQEX_ParticleState::Diff' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_PlayerWearColor
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleSQEX_PlayerWearColor final : public UParticleModuleColorBase
{
public:
	TArray<struct FSQEX_Eff_PlayerWearColorData>  ColorData;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_PlayerWearColor">();
	}
	static class UParticleModuleSQEX_PlayerWearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_PlayerWearColor>();
	}
};
static_assert(alignof(UParticleModuleSQEX_PlayerWearColor) == 0x000008, "Wrong alignment on UParticleModuleSQEX_PlayerWearColor");
static_assert(sizeof(UParticleModuleSQEX_PlayerWearColor) == 0x000060, "Wrong size on UParticleModuleSQEX_PlayerWearColor");
static_assert(offsetof(UParticleModuleSQEX_PlayerWearColor, ColorData) == 0x000050, "Member 'UParticleModuleSQEX_PlayerWearColor::ColorData' has a wrong offset!");

// Class Engine.ReverbEffect
// 0x0030 (0x0070 - 0x0040)
class UReverbEffect final : public UObject
{
public:
	float                                         Density;                                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Diffusion;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gain;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GainHF;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayTime;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayHFRatio;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectionsGain;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectionsDelay;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateGain;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateDelay;                                         // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirAbsorptionGainHF;                               // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoomRolloffFactor;                                 // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverbEffect">();
	}
	static class UReverbEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReverbEffect>();
	}
};
static_assert(alignof(UReverbEffect) == 0x000008, "Wrong alignment on UReverbEffect");
static_assert(sizeof(UReverbEffect) == 0x000070, "Wrong size on UReverbEffect");
static_assert(offsetof(UReverbEffect, Density) == 0x000040, "Member 'UReverbEffect::Density' has a wrong offset!");
static_assert(offsetof(UReverbEffect, Diffusion) == 0x000044, "Member 'UReverbEffect::Diffusion' has a wrong offset!");
static_assert(offsetof(UReverbEffect, Gain) == 0x000048, "Member 'UReverbEffect::Gain' has a wrong offset!");
static_assert(offsetof(UReverbEffect, GainHF) == 0x00004C, "Member 'UReverbEffect::GainHF' has a wrong offset!");
static_assert(offsetof(UReverbEffect, DecayTime) == 0x000050, "Member 'UReverbEffect::DecayTime' has a wrong offset!");
static_assert(offsetof(UReverbEffect, DecayHFRatio) == 0x000054, "Member 'UReverbEffect::DecayHFRatio' has a wrong offset!");
static_assert(offsetof(UReverbEffect, ReflectionsGain) == 0x000058, "Member 'UReverbEffect::ReflectionsGain' has a wrong offset!");
static_assert(offsetof(UReverbEffect, ReflectionsDelay) == 0x00005C, "Member 'UReverbEffect::ReflectionsDelay' has a wrong offset!");
static_assert(offsetof(UReverbEffect, LateGain) == 0x000060, "Member 'UReverbEffect::LateGain' has a wrong offset!");
static_assert(offsetof(UReverbEffect, LateDelay) == 0x000064, "Member 'UReverbEffect::LateDelay' has a wrong offset!");
static_assert(offsetof(UReverbEffect, AirAbsorptionGainHF) == 0x000068, "Member 'UReverbEffect::AirAbsorptionGainHF' has a wrong offset!");
static_assert(offsetof(UReverbEffect, RoomRolloffFactor) == 0x00006C, "Member 'UReverbEffect::RoomRolloffFactor' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_PostprocessAura
// 0x00C8 (0x0118 - 0x0050)
class UParticleModuleSQEX_PostprocessAura final : public UParticleModuleSQEX_Base
{
public:
	ESQEX_AURA_ID                                 AuraID;                                            // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Size;                                              // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 Color;                                             // 0x0090(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Alpha;                                             // 0x00E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_PostprocessAura">();
	}
	static class UParticleModuleSQEX_PostprocessAura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_PostprocessAura>();
	}
};
static_assert(alignof(UParticleModuleSQEX_PostprocessAura) == 0x000008, "Wrong alignment on UParticleModuleSQEX_PostprocessAura");
static_assert(sizeof(UParticleModuleSQEX_PostprocessAura) == 0x000118, "Wrong size on UParticleModuleSQEX_PostprocessAura");
static_assert(offsetof(UParticleModuleSQEX_PostprocessAura, AuraID) == 0x000050, "Member 'UParticleModuleSQEX_PostprocessAura::AuraID' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_PostprocessAura, Size) == 0x000058, "Member 'UParticleModuleSQEX_PostprocessAura::Size' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_PostprocessAura, Color) == 0x000090, "Member 'UParticleModuleSQEX_PostprocessAura::Color' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_PostprocessAura, Alpha) == 0x0000E0, "Member 'UParticleModuleSQEX_PostprocessAura::Alpha' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_PostprocessFringe
// 0x0040 (0x0090 - 0x0050)
class UParticleModuleSQEX_PostprocessFringe final : public UParticleModuleSQEX_Base
{
public:
	struct FRawDistributionFloat                  Intensity;                                         // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ETresScreenEffectPriority                     EffectPriority;                                    // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_PostprocessFringe">();
	}
	static class UParticleModuleSQEX_PostprocessFringe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_PostprocessFringe>();
	}
};
static_assert(alignof(UParticleModuleSQEX_PostprocessFringe) == 0x000008, "Wrong alignment on UParticleModuleSQEX_PostprocessFringe");
static_assert(sizeof(UParticleModuleSQEX_PostprocessFringe) == 0x000090, "Wrong size on UParticleModuleSQEX_PostprocessFringe");
static_assert(offsetof(UParticleModuleSQEX_PostprocessFringe, Intensity) == 0x000050, "Member 'UParticleModuleSQEX_PostprocessFringe::Intensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_PostprocessFringe, EffectPriority) == 0x000088, "Member 'UParticleModuleSQEX_PostprocessFringe::EffectPriority' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Quadrangle_Seeded
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_Quadrangle_Seeded final : public UParticleModuleSQEX_Quadrangle
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x01C8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Quadrangle_Seeded">();
	}
	static class UParticleModuleSQEX_Quadrangle_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Quadrangle_Seeded>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Quadrangle_Seeded) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Quadrangle_Seeded");
static_assert(sizeof(UParticleModuleSQEX_Quadrangle_Seeded) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Quadrangle_Seeded");
static_assert(offsetof(UParticleModuleSQEX_Quadrangle_Seeded, RandomSeedInfo) == 0x0001C8, "Member 'UParticleModuleSQEX_Quadrangle_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_QuaternionTest
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleSQEX_QuaternionTest final : public UParticleModuleSQEX_Base
{
public:
	struct FVector                                A;                                                 // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_QuaternionTest">();
	}
	static class UParticleModuleSQEX_QuaternionTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_QuaternionTest>();
	}
};
static_assert(alignof(UParticleModuleSQEX_QuaternionTest) == 0x000008, "Wrong alignment on UParticleModuleSQEX_QuaternionTest");
static_assert(sizeof(UParticleModuleSQEX_QuaternionTest) == 0x000068, "Wrong size on UParticleModuleSQEX_QuaternionTest");
static_assert(offsetof(UParticleModuleSQEX_QuaternionTest, A) == 0x000050, "Member 'UParticleModuleSQEX_QuaternionTest::A' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_QuaternionTest, B) == 0x00005C, "Member 'UParticleModuleSQEX_QuaternionTest::B' has a wrong offset!");

// Class Engine.SQEX_DrawFrustumComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USQEX_DrawFrustumComponent final : public UDrawFrustumComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_DrawFrustumComponent">();
	}
	static class USQEX_DrawFrustumComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_DrawFrustumComponent>();
	}
};
static_assert(alignof(USQEX_DrawFrustumComponent) == 0x112E9AF0, "Wrong alignment on USQEX_DrawFrustumComponent");
static_assert(sizeof(USQEX_DrawFrustumComponent) == 0x112E9AF0, "Wrong size on USQEX_DrawFrustumComponent");

// Class Engine.ParticleModuleSQEX_RandomTestModule
// 0x0140 (0x0190 - 0x0050)
class UParticleModuleSQEX_RandomTestModule final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         bUseGaussFloat : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  RandomGaussFloat;                                  // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseGaussVector : 1;                               // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RandomGaussVector;                                 // 0x0098(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseRandomFloat : 1;                               // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  RandomFloat;                                       // 0x00F0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseRandomVector : 1;                              // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RandomVector;                                      // 0x0130(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseEase : 1;                                      // 0x0180(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpSinIn : 1;                               // 0x0180(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpSinOut : 1;                              // 0x0180(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpSinInOut : 1;                            // 0x0180(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpExpoIn : 1;                              // 0x0180(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpExpoOut : 1;                             // 0x0180(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpExpoInOut : 1;                           // 0x0180(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpCircularIn : 1;                          // 0x0180(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpCircularOut : 1;                         // 0x0181(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterpCircularInOut : 1;                       // 0x0181(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FStart;                                            // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnd;                                              // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_RandomTestModule">();
	}
	static class UParticleModuleSQEX_RandomTestModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_RandomTestModule>();
	}
};
static_assert(alignof(UParticleModuleSQEX_RandomTestModule) == 0x000008, "Wrong alignment on UParticleModuleSQEX_RandomTestModule");
static_assert(sizeof(UParticleModuleSQEX_RandomTestModule) == 0x000190, "Wrong size on UParticleModuleSQEX_RandomTestModule");
static_assert(offsetof(UParticleModuleSQEX_RandomTestModule, RandomGaussFloat) == 0x000058, "Member 'UParticleModuleSQEX_RandomTestModule::RandomGaussFloat' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RandomTestModule, RandomGaussVector) == 0x000098, "Member 'UParticleModuleSQEX_RandomTestModule::RandomGaussVector' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RandomTestModule, RandomFloat) == 0x0000F0, "Member 'UParticleModuleSQEX_RandomTestModule::RandomFloat' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RandomTestModule, RandomVector) == 0x000130, "Member 'UParticleModuleSQEX_RandomTestModule::RandomVector' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RandomTestModule, FStart) == 0x000184, "Member 'UParticleModuleSQEX_RandomTestModule::FStart' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_RandomTestModule, FEnd) == 0x000188, "Member 'UParticleModuleSQEX_RandomTestModule::FEnd' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Range
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleSQEX_Range : public UParticleModuleSQEX_LocationBase
{
public:
	struct FRawDistributionFloat                  RangeRadius;                                       // 0x00F8(0x0038)(Edit, ExportObject, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 RangeScale;                                        // 0x0130(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Deviation;                                         // 0x0180(0x0038)(Edit, ExportObject, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DirectionAngle;                                    // 0x01B8(0x0038)(Edit, ExportObject, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Range">();
	}
	static class UParticleModuleSQEX_Range* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Range>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleSQEX_Range) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Range");
static_assert(sizeof(UParticleModuleSQEX_Range) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Range");
static_assert(offsetof(UParticleModuleSQEX_Range, RangeRadius) == 0x0000F8, "Member 'UParticleModuleSQEX_Range::RangeRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Range, RangeScale) == 0x000130, "Member 'UParticleModuleSQEX_Range::RangeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Range, Deviation) == 0x000180, "Member 'UParticleModuleSQEX_Range::Deviation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Range, DirectionAngle) == 0x0001B8, "Member 'UParticleModuleSQEX_Range::DirectionAngle' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Range_Seeded
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_Range_Seeded final : public UParticleModuleSQEX_Range
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x01F0(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Range_Seeded">();
	}
	static class UParticleModuleSQEX_Range_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Range_Seeded>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Range_Seeded) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Range_Seeded");
static_assert(sizeof(UParticleModuleSQEX_Range_Seeded) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Range_Seeded");
static_assert(offsetof(UParticleModuleSQEX_Range_Seeded, RandomSeedInfo) == 0x0001F0, "Member 'UParticleModuleSQEX_Range_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Raycast
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_Raycast final : public UParticleModuleSQEX_LocationBase
{
public:
	struct FVector                                RayEndOffset;                                      // 0x00F8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInWorldSpace : 1;                                 // 0x0104(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RaycastSize;                                       // 0x0108(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_RAYCAST_SPAWN_THEME                     SpawnTheme;                                        // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsHitOnlySpawn : 1;                               // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsNoHitSetLocation : 1;                           // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhysicalSurface>                      CheckPhysicalSurface;                              // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bCheckPhysicalSurfaceEqual : 1;                    // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsHitNormalInfluenced : 1;                        // 0x0130(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionTypes;                                    // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_CollisionResponseParamsData> SqExCollisionResponseParams;                       // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x20];                                     // 0x0158(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             SqExCollisionChannel;                              // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCollideOnlyIfVisible : 1;                         // 0x017C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocationOffset;                               // 0x0180(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreSourceActor : 1;                            // 0x018C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPawnsDoNotDecrementCount : 1;                     // 0x018C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreTriggerVolumes : 1;                         // 0x018C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_18D[0xB];                                      // 0x018D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Raycast">();
	}
	static class UParticleModuleSQEX_Raycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Raycast>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Raycast) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Raycast");
static_assert(sizeof(UParticleModuleSQEX_Raycast) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Raycast");
static_assert(offsetof(UParticleModuleSQEX_Raycast, RayEndOffset) == 0x0000F8, "Member 'UParticleModuleSQEX_Raycast::RayEndOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, RaycastSize) == 0x000108, "Member 'UParticleModuleSQEX_Raycast::RaycastSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, SpawnTheme) == 0x000114, "Member 'UParticleModuleSQEX_Raycast::SpawnTheme' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, CheckPhysicalSurface) == 0x000120, "Member 'UParticleModuleSQEX_Raycast::CheckPhysicalSurface' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, CollisionTypes) == 0x000138, "Member 'UParticleModuleSQEX_Raycast::CollisionTypes' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, SqExCollisionResponseParams) == 0x000148, "Member 'UParticleModuleSQEX_Raycast::SqExCollisionResponseParams' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, SqExCollisionChannel) == 0x000178, "Member 'UParticleModuleSQEX_Raycast::SqExCollisionChannel' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Raycast, SpawnLocationOffset) == 0x000180, "Member 'UParticleModuleSQEX_Raycast::SpawnLocationOffset' has a wrong offset!");

// Class Engine.SQEX_EffectSeAttachDataBase
// 0x0000 (0x0040 - 0x0040)
class USQEX_EffectSeAttachDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_EffectSeAttachDataBase">();
	}
	static class USQEX_EffectSeAttachDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_EffectSeAttachDataBase>();
	}
};
static_assert(alignof(USQEX_EffectSeAttachDataBase) == 0x000008, "Wrong alignment on USQEX_EffectSeAttachDataBase");
static_assert(sizeof(USQEX_EffectSeAttachDataBase) == 0x000040, "Wrong size on USQEX_EffectSeAttachDataBase");

// Class Engine.ParticleModuleSQEX_Ring
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
#pragma pack(push, 0x1)
class alignas(0x112E9AF0) UParticleModuleSQEX_Ring : public UParticleModuleSQEX_LocationBase
{
public:
	struct FRawDistributionFloat                  VertexNumber;                                      // 0x00F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RangeRadius;                                       // 0x0130(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RangeRadiusTwo;                                    // 0x0168(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DirectionAngle;                                    // 0x01A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EVARTEX_ODER_TYPE                             VartexGenerateType;                                // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Interval;                                          // 0x01E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bAttachParticle : 1;                               // 0x0218(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RingOffsetPosition;                                // 0x0220(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 RingOffsetRotation;                                // 0x0270(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 RingOffsetScale;                                   // 0x02C0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 RingOffsetPositionTow;                             // 0x0310(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Ring">();
	}
	static class UParticleModuleSQEX_Ring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Ring>();
	}
};
#pragma pack(pop)
static_assert(alignof(UParticleModuleSQEX_Ring) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Ring");
static_assert(sizeof(UParticleModuleSQEX_Ring) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Ring");
static_assert(offsetof(UParticleModuleSQEX_Ring, VertexNumber) == 0x0000F8, "Member 'UParticleModuleSQEX_Ring::VertexNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, RangeRadius) == 0x000130, "Member 'UParticleModuleSQEX_Ring::RangeRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, RangeRadiusTwo) == 0x000168, "Member 'UParticleModuleSQEX_Ring::RangeRadiusTwo' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, DirectionAngle) == 0x0001A0, "Member 'UParticleModuleSQEX_Ring::DirectionAngle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, VartexGenerateType) == 0x0001D8, "Member 'UParticleModuleSQEX_Ring::VartexGenerateType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, Interval) == 0x0001E0, "Member 'UParticleModuleSQEX_Ring::Interval' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, RingOffsetPosition) == 0x000220, "Member 'UParticleModuleSQEX_Ring::RingOffsetPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, RingOffsetRotation) == 0x000270, "Member 'UParticleModuleSQEX_Ring::RingOffsetRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, RingOffsetScale) == 0x0002C0, "Member 'UParticleModuleSQEX_Ring::RingOffsetScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_Ring, RingOffsetPositionTow) == 0x000310, "Member 'UParticleModuleSQEX_Ring::RingOffsetPositionTow' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_Ring_Seeded
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_Ring_Seeded final : public UParticleModuleSQEX_Ring
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x0360(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_Ring_Seeded">();
	}
	static class UParticleModuleSQEX_Ring_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_Ring_Seeded>();
	}
};
static_assert(alignof(UParticleModuleSQEX_Ring_Seeded) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_Ring_Seeded");
static_assert(sizeof(UParticleModuleSQEX_Ring_Seeded) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_Ring_Seeded");
static_assert(offsetof(UParticleModuleSQEX_Ring_Seeded, RandomSeedInfo) == 0x000360, "Member 'UParticleModuleSQEX_Ring_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ScreenBlur
// 0x02E8 (0x0358 - 0x0070)
class UParticleModuleSQEX_ScreenBlur final : public UParticleModuleSQEX_BlurBase
{
public:
	struct FRawDistributionFloat                  ScreenBlurIntensity;                               // 0x0070(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseScreenPos : 1;                                 // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ScreenBlurRange;                                   // 0x00B0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurPosX;                                    // 0x00E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurPosY;                                    // 0x0120(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurOffsetX;                                 // 0x0158(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurOffsetY;                                 // 0x0190(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurCenterOffset;                            // 0x01C8(0x0038)(Deprecated, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurHoleSize;                                // 0x0200(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurAngle;                                   // 0x0238(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseAttenuation : 1;                               // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ScreenBlurAttenuationOffset;                       // 0x0278(0x0038)(Deprecated, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurAttenuationDistance;                     // 0x02B0(0x0038)(Deprecated, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurAttenuationDistanceOutside;              // 0x02E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScreenBlurAttenuationDistanceInside;               // 0x0320(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ScreenBlur">();
	}
	static class UParticleModuleSQEX_ScreenBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ScreenBlur>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ScreenBlur) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ScreenBlur");
static_assert(sizeof(UParticleModuleSQEX_ScreenBlur) == 0x000358, "Wrong size on UParticleModuleSQEX_ScreenBlur");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurIntensity) == 0x000070, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurIntensity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurRange) == 0x0000B0, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurPosX) == 0x0000E8, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurPosX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurPosY) == 0x000120, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurPosY' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurOffsetX) == 0x000158, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurOffsetX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurOffsetY) == 0x000190, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurOffsetY' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurCenterOffset) == 0x0001C8, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurCenterOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurHoleSize) == 0x000200, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurHoleSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurAngle) == 0x000238, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurAngle' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurAttenuationOffset) == 0x000278, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurAttenuationOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurAttenuationDistance) == 0x0002B0, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurAttenuationDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurAttenuationDistanceOutside) == 0x0002E8, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurAttenuationDistanceOutside' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ScreenBlur, ScreenBlurAttenuationDistanceInside) == 0x000320, "Member 'UParticleModuleSQEX_ScreenBlur::ScreenBlurAttenuationDistanceInside' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_SpawnActor
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleSQEX_SpawnActor final : public UParticleModuleSQEX_Base
{
public:
	float                                         SpawnTime;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ChildActorClass;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReestSpawnList : 1;                               // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnActor">();
	}
	static class UParticleModuleSQEX_SpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnActor>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnActor) == 0x000008, "Wrong alignment on UParticleModuleSQEX_SpawnActor");
static_assert(sizeof(UParticleModuleSQEX_SpawnActor) == 0x000068, "Wrong size on UParticleModuleSQEX_SpawnActor");
static_assert(offsetof(UParticleModuleSQEX_SpawnActor, SpawnTime) == 0x000050, "Member 'UParticleModuleSQEX_SpawnActor::SpawnTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnActor, ChildActorClass) == 0x000058, "Member 'UParticleModuleSQEX_SpawnActor::ChildActorClass' has a wrong offset!");

// Class Engine.SqEx_EffectShaderParameter
// 0x0000 (0x0040 - 0x0040)
class USqEx_EffectShaderParameter final : public USqEx_EffectShaderParameter_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqEx_EffectShaderParameter">();
	}
	static class USqEx_EffectShaderParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqEx_EffectShaderParameter>();
	}
};
static_assert(alignof(USqEx_EffectShaderParameter) == 0x000008, "Wrong alignment on USqEx_EffectShaderParameter");
static_assert(sizeof(USqEx_EffectShaderParameter) == 0x000040, "Wrong size on USqEx_EffectShaderParameter");

// Class Engine.ParticleModuleSQEX_SpawnFluidParticle
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_SpawnFluidParticle final : public UParticleModuleSQEX_LocationBase
{
public:
	ESQEX_FluidSpawnType                          SpawnType;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SpawnNumber;                                       // 0x0100(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SpawnTime;                                         // 0x0138(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SpawnIntervalTime;                                 // 0x0170(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                SpawnGridSizeMax;                                  // 0x01A8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnGridSizeMin;                                  // 0x01B4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x01C0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 PositionOffset;                                    // 0x01D0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Radius;                                            // 0x0220(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DiskSize;                                          // 0x0258(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 InitVelocity;                                      // 0x02A8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 VelocityRadiusScale;                               // 0x02F8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnFluidParticle">();
	}
	static class UParticleModuleSQEX_SpawnFluidParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnFluidParticle>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnFluidParticle) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_SpawnFluidParticle");
static_assert(sizeof(UParticleModuleSQEX_SpawnFluidParticle) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_SpawnFluidParticle");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, SpawnType) == 0x0000F8, "Member 'UParticleModuleSQEX_SpawnFluidParticle::SpawnType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, SpawnNumber) == 0x000100, "Member 'UParticleModuleSQEX_SpawnFluidParticle::SpawnNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, SpawnTime) == 0x000138, "Member 'UParticleModuleSQEX_SpawnFluidParticle::SpawnTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, SpawnIntervalTime) == 0x000170, "Member 'UParticleModuleSQEX_SpawnFluidParticle::SpawnIntervalTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, SpawnGridSizeMax) == 0x0001A8, "Member 'UParticleModuleSQEX_SpawnFluidParticle::SpawnGridSizeMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, SpawnGridSizeMin) == 0x0001B4, "Member 'UParticleModuleSQEX_SpawnFluidParticle::SpawnGridSizeMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, Rotation) == 0x0001C0, "Member 'UParticleModuleSQEX_SpawnFluidParticle::Rotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, PositionOffset) == 0x0001D0, "Member 'UParticleModuleSQEX_SpawnFluidParticle::PositionOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, Radius) == 0x000220, "Member 'UParticleModuleSQEX_SpawnFluidParticle::Radius' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, DiskSize) == 0x000258, "Member 'UParticleModuleSQEX_SpawnFluidParticle::DiskSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, InitVelocity) == 0x0002A8, "Member 'UParticleModuleSQEX_SpawnFluidParticle::InitVelocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnFluidParticle, VelocityRadiusScale) == 0x0002F8, "Member 'UParticleModuleSQEX_SpawnFluidParticle::VelocityRadiusScale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_SpawnParentHistoryPos
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_SpawnParentHistoryPos final : public UParticleModuleSQEX_LocationBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnParentHistoryPos">();
	}
	static class UParticleModuleSQEX_SpawnParentHistoryPos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnParentHistoryPos>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnParentHistoryPos) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_SpawnParentHistoryPos");
static_assert(sizeof(UParticleModuleSQEX_SpawnParentHistoryPos) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_SpawnParentHistoryPos");

// Class Engine.ParticleModuleSQEX_SpawnParentHistoryPosEx
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_SpawnParentHistoryPosEx final : public UParticleModuleSQEX_LocationBase
{
public:
	uint8                                         bIsCurrentLength : 1;                              // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SpawnPosToTailHistoryRate;                         // 0x0100(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnParentHistoryPosEx">();
	}
	static class UParticleModuleSQEX_SpawnParentHistoryPosEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnParentHistoryPosEx>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnParentHistoryPosEx) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_SpawnParentHistoryPosEx");
static_assert(sizeof(UParticleModuleSQEX_SpawnParentHistoryPosEx) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_SpawnParentHistoryPosEx");
static_assert(offsetof(UParticleModuleSQEX_SpawnParentHistoryPosEx, SpawnPosToTailHistoryRate) == 0x000100, "Member 'UParticleModuleSQEX_SpawnParentHistoryPosEx::SpawnPosToTailHistoryRate' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_SpawnParentParticlePos
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_SpawnParentParticlePos final : public UParticleModuleSQEX_LocationBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnParentParticlePos">();
	}
	static class UParticleModuleSQEX_SpawnParentParticlePos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnParentParticlePos>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnParentParticlePos) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_SpawnParentParticlePos");
static_assert(sizeof(UParticleModuleSQEX_SpawnParentParticlePos) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_SpawnParentParticlePos");

// Class Engine.SQEX_InterpTrackColorFade
// 0x0000 (0x112EE8B0 - 0x112EE8B0)
class USQEX_InterpTrackColorFade final : public UInterpTrackLinearColorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_InterpTrackColorFade">();
	}
	static class USQEX_InterpTrackColorFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_InterpTrackColorFade>();
	}
};
static_assert(alignof(USQEX_InterpTrackColorFade) == 0x112EE8B0, "Wrong alignment on USQEX_InterpTrackColorFade");
static_assert(sizeof(USQEX_InterpTrackColorFade) == 0x112EE8B0, "Wrong size on USQEX_InterpTrackColorFade");

// Class Engine.ParticleModuleSQEX_SpawnParticleSystem
// 0x0020 (0x0070 - 0x0050)
class UParticleModuleSQEX_SpawnParticleSystem final : public UParticleModuleSQEX_Base
{
public:
	class UParticleSystem*                        ParticleSystemAsset;                               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnTime;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopEndTime;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGiveLocation : 1;                                 // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGiveRotation : 1;                                 // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGiveScale : 1;                                    // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGiveColor : 1;                                    // 0x0060(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGiveAlpha : 1;                                    // 0x0060(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarmupTime;                                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseWarmupTime : 1;                                // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnParticleSystem">();
	}
	static class UParticleModuleSQEX_SpawnParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnParticleSystem>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnParticleSystem) == 0x000008, "Wrong alignment on UParticleModuleSQEX_SpawnParticleSystem");
static_assert(sizeof(UParticleModuleSQEX_SpawnParticleSystem) == 0x000070, "Wrong size on UParticleModuleSQEX_SpawnParticleSystem");
static_assert(offsetof(UParticleModuleSQEX_SpawnParticleSystem, ParticleSystemAsset) == 0x000050, "Member 'UParticleModuleSQEX_SpawnParticleSystem::ParticleSystemAsset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnParticleSystem, SpawnTime) == 0x000058, "Member 'UParticleModuleSQEX_SpawnParticleSystem::SpawnTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnParticleSystem, LoopEndTime) == 0x00005C, "Member 'UParticleModuleSQEX_SpawnParticleSystem::LoopEndTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnParticleSystem, WarmupTime) == 0x000064, "Member 'UParticleModuleSQEX_SpawnParticleSystem::WarmupTime' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_SpawnSeaSurface
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_SpawnSeaSurface final : public UParticleModuleSQEX_LocationBase
{
public:
	ESQEX_SeaSurfaceSpawnMode                     SeaSurfaceSpawnMode;                               // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_SeaSurfaceData>           Datas;                                             // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SpawnScale;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnSuppressScale;                                // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  EntryAndExitScale;                                 // 0x0118(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         TesMode : 1;                                       // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 TestZ;                                             // 0x0158(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SpawnSeaSurface">();
	}
	static class UParticleModuleSQEX_SpawnSeaSurface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SpawnSeaSurface>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SpawnSeaSurface) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_SpawnSeaSurface");
static_assert(sizeof(UParticleModuleSQEX_SpawnSeaSurface) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_SpawnSeaSurface");
static_assert(offsetof(UParticleModuleSQEX_SpawnSeaSurface, SeaSurfaceSpawnMode) == 0x0000F8, "Member 'UParticleModuleSQEX_SpawnSeaSurface::SeaSurfaceSpawnMode' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnSeaSurface, Datas) == 0x000100, "Member 'UParticleModuleSQEX_SpawnSeaSurface::Datas' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnSeaSurface, SpawnScale) == 0x000110, "Member 'UParticleModuleSQEX_SpawnSeaSurface::SpawnScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnSeaSurface, SpawnSuppressScale) == 0x000114, "Member 'UParticleModuleSQEX_SpawnSeaSurface::SpawnSuppressScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnSeaSurface, EntryAndExitScale) == 0x000118, "Member 'UParticleModuleSQEX_SpawnSeaSurface::EntryAndExitScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SpawnSeaSurface, TestZ) == 0x000158, "Member 'UParticleModuleSQEX_SpawnSeaSurface::TestZ' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_SphereForce
// 0x11673680 (0x116736D0 - 0x0050)
class UParticleModuleSQEX_SphereForce final : public UParticleModuleSQEX_Base
{
public:
	uint8                                         Pad_50[0x4];                                       // 0x0050(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsUseForceInGame : 1;                             // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLocalCollision : 1;                             // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 CollPos;                                           // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSQEX_PARTICLE_SPHERE_FORCE            ForceData;                                         // 0x00A8(0x116736D0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RadiusScale;                                       // 0x00E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  HitMovePowScale;                                   // 0x0118(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  HitRotMovePowScale;                                // 0x0150(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSQEX_ReactionObjectData               ReactionObject;                                    // 0x0188(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                TestPos1;                                          // 0x01A0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestPos2;                                          // 0x01AC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestVec1;                                          // 0x01B8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestVec2;                                          // 0x01C4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestVec3;                                          // 0x01D0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x01DC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriPos0;                                           // 0x01E8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriPos1;                                           // 0x01F4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriPos2;                                           // 0x0200(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Area;                                              // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deg;                                               // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotAndLine;                                        // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_SphereForce">();
	}
	static class UParticleModuleSQEX_SphereForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_SphereForce>();
	}
};
static_assert(alignof(UParticleModuleSQEX_SphereForce) == 0x116736D0, "Wrong alignment on UParticleModuleSQEX_SphereForce");
static_assert(sizeof(UParticleModuleSQEX_SphereForce) == 0x116736D0, "Wrong size on UParticleModuleSQEX_SphereForce");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, CollPos) == 0x000058, "Member 'UParticleModuleSQEX_SphereForce::CollPos' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, ForceData) == 0x0000A8, "Member 'UParticleModuleSQEX_SphereForce::ForceData' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, RadiusScale) == 0x0000E0, "Member 'UParticleModuleSQEX_SphereForce::RadiusScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, HitMovePowScale) == 0x000118, "Member 'UParticleModuleSQEX_SphereForce::HitMovePowScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, HitRotMovePowScale) == 0x000150, "Member 'UParticleModuleSQEX_SphereForce::HitRotMovePowScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, ReactionObject) == 0x000188, "Member 'UParticleModuleSQEX_SphereForce::ReactionObject' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TestPos1) == 0x0001A0, "Member 'UParticleModuleSQEX_SphereForce::TestPos1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TestPos2) == 0x0001AC, "Member 'UParticleModuleSQEX_SphereForce::TestPos2' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TestVec1) == 0x0001B8, "Member 'UParticleModuleSQEX_SphereForce::TestVec1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TestVec2) == 0x0001C4, "Member 'UParticleModuleSQEX_SphereForce::TestVec2' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TestVec3) == 0x0001D0, "Member 'UParticleModuleSQEX_SphereForce::TestVec3' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, BoxSize) == 0x0001DC, "Member 'UParticleModuleSQEX_SphereForce::BoxSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TriPos0) == 0x0001E8, "Member 'UParticleModuleSQEX_SphereForce::TriPos0' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TriPos1) == 0x0001F4, "Member 'UParticleModuleSQEX_SphereForce::TriPos1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, TriPos2) == 0x000200, "Member 'UParticleModuleSQEX_SphereForce::TriPos2' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, Area) == 0x00020C, "Member 'UParticleModuleSQEX_SphereForce::Area' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, Height) == 0x000210, "Member 'UParticleModuleSQEX_SphereForce::Height' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, Deg) == 0x000214, "Member 'UParticleModuleSQEX_SphereForce::Deg' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_SphereForce, DotAndLine) == 0x000218, "Member 'UParticleModuleSQEX_SphereForce::DotAndLine' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TailShape
// 0x02E0 (0x0330 - 0x0050)
class UParticleModuleSQEX_TailShape final : public UParticleModuleSQEX_TailShape_Base
{
public:
	struct FVector                                HistoryPositionOffset;                             // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETAIL_SHAPE_INTERP_TYPE                       TailShapeInterpType;                               // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         UseMatrixOfOwner : 1;                              // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetHistoryInLoop : 1;                           // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HistoryMaxDataNumber;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailNumber;                                        // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailInterval;                                      // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bTailIntervalNoUseEmitterLocation : 1;             // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  TailScale;                                         // 0x00E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 TailColor;                                         // 0x0118(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailAlpha;                                         // 0x0168(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseTailTwist : 1;                                 // 0x01A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  TailRotation;                                      // 0x01A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailTwistRate;                                     // 0x01E0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESQEX_TAIL_TWIST_MESH_AXIS_TYPE               MeshTwistAxisType;                                 // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseTailScroll : 1;                                // 0x021C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21D[0x3];                                      // 0x021D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TailScrollTimeScale;                               // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 TailScrollScale;                                   // 0x0228(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 TailScrollColor;                                   // 0x0278(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailScrollAlpha;                                   // 0x02C8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ETAIL_HISTORY_TYPE                            TailHistoryType;                                   // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseBoneList : 1;                                  // 0x0304(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoneList;                                          // 0x0308(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSetReverse : 1;                                   // 0x0318(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTracingHistory : 1;                            // 0x0318(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_HISTORY_TRACING_START_TYPE              HistoryTracingStartType;                           // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TracingHistoryRate;                                // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bForceReactionHistory : 1;                         // 0x0324(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoForceReactionParticle : 1;                      // 0x0324(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceHitAlphaScaleParam;                           // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceHitFadeTime;                                  // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TailShape">();
	}
	static class UParticleModuleSQEX_TailShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TailShape>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TailShape) == 0x000008, "Wrong alignment on UParticleModuleSQEX_TailShape");
static_assert(sizeof(UParticleModuleSQEX_TailShape) == 0x000330, "Wrong size on UParticleModuleSQEX_TailShape");
static_assert(offsetof(UParticleModuleSQEX_TailShape, HistoryPositionOffset) == 0x000050, "Member 'UParticleModuleSQEX_TailShape::HistoryPositionOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailShapeInterpType) == 0x00005C, "Member 'UParticleModuleSQEX_TailShape::TailShapeInterpType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, HistoryMaxDataNumber) == 0x000064, "Member 'UParticleModuleSQEX_TailShape::HistoryMaxDataNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailNumber) == 0x000068, "Member 'UParticleModuleSQEX_TailShape::TailNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailInterval) == 0x0000A0, "Member 'UParticleModuleSQEX_TailShape::TailInterval' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailScale) == 0x0000E0, "Member 'UParticleModuleSQEX_TailShape::TailScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailColor) == 0x000118, "Member 'UParticleModuleSQEX_TailShape::TailColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailAlpha) == 0x000168, "Member 'UParticleModuleSQEX_TailShape::TailAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailRotation) == 0x0001A8, "Member 'UParticleModuleSQEX_TailShape::TailRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailTwistRate) == 0x0001E0, "Member 'UParticleModuleSQEX_TailShape::TailTwistRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, MeshTwistAxisType) == 0x000218, "Member 'UParticleModuleSQEX_TailShape::MeshTwistAxisType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailScrollTimeScale) == 0x000220, "Member 'UParticleModuleSQEX_TailShape::TailScrollTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailScrollScale) == 0x000228, "Member 'UParticleModuleSQEX_TailShape::TailScrollScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailScrollColor) == 0x000278, "Member 'UParticleModuleSQEX_TailShape::TailScrollColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailScrollAlpha) == 0x0002C8, "Member 'UParticleModuleSQEX_TailShape::TailScrollAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TailHistoryType) == 0x000300, "Member 'UParticleModuleSQEX_TailShape::TailHistoryType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, BoneList) == 0x000308, "Member 'UParticleModuleSQEX_TailShape::BoneList' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, HistoryTracingStartType) == 0x00031C, "Member 'UParticleModuleSQEX_TailShape::HistoryTracingStartType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, TracingHistoryRate) == 0x000320, "Member 'UParticleModuleSQEX_TailShape::TracingHistoryRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, ForceHitAlphaScaleParam) == 0x000328, "Member 'UParticleModuleSQEX_TailShape::ForceHitAlphaScaleParam' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TailShape, ForceHitFadeTime) == 0x00032C, "Member 'UParticleModuleSQEX_TailShape::ForceHitFadeTime' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TailShapeExData_Inertia
// 0x0038 (0x0088 - 0x0050)
class UParticleModuleSQEX_TailShapeExData_Inertia final : public UParticleModuleSQEX_TailShape_Base
{
public:
	struct FRawDistributionFloat                  TailInertia;                                       // 0x0050(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TailShapeExData_Inertia">();
	}
	static class UParticleModuleSQEX_TailShapeExData_Inertia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TailShapeExData_Inertia>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TailShapeExData_Inertia) == 0x000008, "Wrong alignment on UParticleModuleSQEX_TailShapeExData_Inertia");
static_assert(sizeof(UParticleModuleSQEX_TailShapeExData_Inertia) == 0x000088, "Wrong size on UParticleModuleSQEX_TailShapeExData_Inertia");
static_assert(offsetof(UParticleModuleSQEX_TailShapeExData_Inertia, TailInertia) == 0x000050, "Member 'UParticleModuleSQEX_TailShapeExData_Inertia::TailInertia' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TargetVelocity
// 0x0140 (0x0198 - 0x0058)
class UParticleModuleSQEX_TargetVelocity final : public UParticleModuleVelocityBase
{
public:
	uint8                                         bLockTargetToEmitter : 1;                          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 Velocity;                                          // 0x0060(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                EmitterOffsetRotation;                             // 0x00B0(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZAxis;                                            // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 TargetPostion;                                     // 0x00C0(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SpeedScale;                                        // 0x0110(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CheckMiniDistance;                                 // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckMiniDistanceOffset;                           // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  CheckMiniSpeedScale;                               // 0x0150(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseSpawnModuleTarget : 1;                         // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetEmitterName;                                 // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TargetVelocity">();
	}
	static class UParticleModuleSQEX_TargetVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TargetVelocity>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TargetVelocity) == 0x000008, "Wrong alignment on UParticleModuleSQEX_TargetVelocity");
static_assert(sizeof(UParticleModuleSQEX_TargetVelocity) == 0x000198, "Wrong size on UParticleModuleSQEX_TargetVelocity");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, Velocity) == 0x000060, "Member 'UParticleModuleSQEX_TargetVelocity::Velocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, EmitterOffsetRotation) == 0x0000B0, "Member 'UParticleModuleSQEX_TargetVelocity::EmitterOffsetRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, bZAxis) == 0x0000BC, "Member 'UParticleModuleSQEX_TargetVelocity::bZAxis' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, TargetPostion) == 0x0000C0, "Member 'UParticleModuleSQEX_TargetVelocity::TargetPostion' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, SpeedScale) == 0x000110, "Member 'UParticleModuleSQEX_TargetVelocity::SpeedScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, CheckMiniDistance) == 0x000148, "Member 'UParticleModuleSQEX_TargetVelocity::CheckMiniDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, CheckMiniDistanceOffset) == 0x00014C, "Member 'UParticleModuleSQEX_TargetVelocity::CheckMiniDistanceOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, CheckMiniSpeedScale) == 0x000150, "Member 'UParticleModuleSQEX_TargetVelocity::CheckMiniSpeedScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TargetVelocity, TargetEmitterName) == 0x000190, "Member 'UParticleModuleSQEX_TargetVelocity::TargetEmitterName' has a wrong offset!");

// Class Engine.SoundMix
// 0x1166D5D0 (0x1166D610 - 0x0040)
class USoundMix final : public UObject
{
public:
	uint8                                         bApplyEQ : 1;                                      // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EQPriority;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAudioEQEffect                         EQSettings;                                        // 0x0048(0x1166D610)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSoundClassAdjuster>            SoundClassEffects;                                 // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InitialDelay;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundMix">();
	}
	static class USoundMix* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundMix>();
	}
};
static_assert(alignof(USoundMix) == 0x1166D610, "Wrong alignment on USoundMix");
static_assert(sizeof(USoundMix) == 0x1166D610, "Wrong size on USoundMix");
static_assert(offsetof(USoundMix, EQPriority) == 0x000044, "Member 'USoundMix::EQPriority' has a wrong offset!");
static_assert(offsetof(USoundMix, EQSettings) == 0x000048, "Member 'USoundMix::EQSettings' has a wrong offset!");
static_assert(offsetof(USoundMix, SoundClassEffects) == 0x000080, "Member 'USoundMix::SoundClassEffects' has a wrong offset!");
static_assert(offsetof(USoundMix, InitialDelay) == 0x000090, "Member 'USoundMix::InitialDelay' has a wrong offset!");
static_assert(offsetof(USoundMix, FadeInTime) == 0x000094, "Member 'USoundMix::FadeInTime' has a wrong offset!");
static_assert(offsetof(USoundMix, Duration) == 0x000098, "Member 'USoundMix::Duration' has a wrong offset!");
static_assert(offsetof(USoundMix, FadeOutTime) == 0x00009C, "Member 'USoundMix::FadeOutTime' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TestModule
// 0x0028 (0x0078 - 0x0050)
class UParticleModuleSQEX_TestModule final : public UParticleModuleSQEX_Base
{
public:
	struct FVector                                A;                                                 // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                C;                                                 // 0x0068(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TestModule">();
	}
	static class UParticleModuleSQEX_TestModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TestModule>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TestModule) == 0x000008, "Wrong alignment on UParticleModuleSQEX_TestModule");
static_assert(sizeof(UParticleModuleSQEX_TestModule) == 0x000078, "Wrong size on UParticleModuleSQEX_TestModule");
static_assert(offsetof(UParticleModuleSQEX_TestModule, A) == 0x000050, "Member 'UParticleModuleSQEX_TestModule::A' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TestModule, B) == 0x00005C, "Member 'UParticleModuleSQEX_TestModule::B' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TestModule, C) == 0x000068, "Member 'UParticleModuleSQEX_TestModule::C' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_TexSpawn
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_TexSpawn final : public UParticleModuleSQEX_LocationBase
{
public:
	class UTexture*                               SpawnTextrue;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               NormalTextrue;                                     // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseOtherSpawnModuleLocation : 1;                   // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         OnCenterTextrue : 1;                               // 0x0108(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x010C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotatorOffset;                                     // 0x0118(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SpawnMaxSizeX;                                     // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnMaxSizeY;                                     // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TexScaleU;                                         // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TexScaleV;                                         // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sub_Horizontal;                                    // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sub_Vertical;                                      // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SubIndex;                                          // 0x0140(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                OffsetInterpolationScale;                          // 0x0178(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 LocationScale;                                     // 0x0188(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         UseColorLocationOffsetX : 1;                       // 0x01D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorLocationOffsetY : 1;                       // 0x01D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorLocationOffsetZ : 1;                       // 0x01D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 NormalVecScale;                                    // 0x01E0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bInWorldSpace : 1;                                 // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 VelocityScale;                                     // 0x0238(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         UseColorVelocityOffsetX : 1;                       // 0x0288(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorVelocityOffsetY : 1;                       // 0x0288(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorVelocityOffsetZ : 1;                       // 0x0288(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EmitterNormalVelocity : 1;                         // 0x0288(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  NormalScale;                                       // 0x0290(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         UseColorR : 1;                                     // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorG : 1;                                     // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorB : 1;                                     // 0x02C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseColorA : 1;                                     // 0x02C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextureSizeX;                                      // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureSizeY;                                      // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_TexNomalData>             NormalList;                                        // 0x02D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         NormalTextureSizeX;                                // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalTextureSizeY;                                // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_TexSpawn">();
	}
	static class UParticleModuleSQEX_TexSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_TexSpawn>();
	}
};
static_assert(alignof(UParticleModuleSQEX_TexSpawn) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_TexSpawn");
static_assert(sizeof(UParticleModuleSQEX_TexSpawn) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_TexSpawn");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, SpawnTextrue) == 0x0000F8, "Member 'UParticleModuleSQEX_TexSpawn::SpawnTextrue' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, NormalTextrue) == 0x000100, "Member 'UParticleModuleSQEX_TexSpawn::NormalTextrue' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, LocationOffset) == 0x00010C, "Member 'UParticleModuleSQEX_TexSpawn::LocationOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, RotatorOffset) == 0x000118, "Member 'UParticleModuleSQEX_TexSpawn::RotatorOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, SpawnMaxSizeX) == 0x000124, "Member 'UParticleModuleSQEX_TexSpawn::SpawnMaxSizeX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, SpawnMaxSizeY) == 0x000128, "Member 'UParticleModuleSQEX_TexSpawn::SpawnMaxSizeY' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, TexScaleU) == 0x00012C, "Member 'UParticleModuleSQEX_TexSpawn::TexScaleU' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, TexScaleV) == 0x000130, "Member 'UParticleModuleSQEX_TexSpawn::TexScaleV' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, Sub_Horizontal) == 0x000134, "Member 'UParticleModuleSQEX_TexSpawn::Sub_Horizontal' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, Sub_Vertical) == 0x000138, "Member 'UParticleModuleSQEX_TexSpawn::Sub_Vertical' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, SubIndex) == 0x000140, "Member 'UParticleModuleSQEX_TexSpawn::SubIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, OffsetInterpolationScale) == 0x000178, "Member 'UParticleModuleSQEX_TexSpawn::OffsetInterpolationScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, LocationScale) == 0x000188, "Member 'UParticleModuleSQEX_TexSpawn::LocationScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, NormalVecScale) == 0x0001E0, "Member 'UParticleModuleSQEX_TexSpawn::NormalVecScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, VelocityScale) == 0x000238, "Member 'UParticleModuleSQEX_TexSpawn::VelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, NormalScale) == 0x000290, "Member 'UParticleModuleSQEX_TexSpawn::NormalScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, TextureSizeX) == 0x0002CC, "Member 'UParticleModuleSQEX_TexSpawn::TextureSizeX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, TextureSizeY) == 0x0002D0, "Member 'UParticleModuleSQEX_TexSpawn::TextureSizeY' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, NormalList) == 0x0002D8, "Member 'UParticleModuleSQEX_TexSpawn::NormalList' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, NormalTextureSizeX) == 0x0002E8, "Member 'UParticleModuleSQEX_TexSpawn::NormalTextureSizeX' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_TexSpawn, NormalTextureSizeY) == 0x0002EC, "Member 'UParticleModuleSQEX_TexSpawn::NormalTextureSizeY' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_ValuePerUnit
// 0x0028 (0x0078 - 0x0050)
class UParticleModuleSQEX_ValuePerUnit final : public UParticleModuleSQEX_Base
{
public:
	class FName                                   InsPrameterName;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountMovement;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountMovementScale;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationRate;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementTolerance;                                 // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreMovementAlongX : 1;                         // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreMovementAlongY : 1;                         // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreMovementAlongZ : 1;                         // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_ValuePerUnit">();
	}
	static class UParticleModuleSQEX_ValuePerUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_ValuePerUnit>();
	}
};
static_assert(alignof(UParticleModuleSQEX_ValuePerUnit) == 0x000008, "Wrong alignment on UParticleModuleSQEX_ValuePerUnit");
static_assert(sizeof(UParticleModuleSQEX_ValuePerUnit) == 0x000078, "Wrong size on UParticleModuleSQEX_ValuePerUnit");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, InsPrameterName) == 0x000050, "Member 'UParticleModuleSQEX_ValuePerUnit::InsPrameterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, MinValue) == 0x000058, "Member 'UParticleModuleSQEX_ValuePerUnit::MinValue' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, MaxValue) == 0x00005C, "Member 'UParticleModuleSQEX_ValuePerUnit::MaxValue' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, AmountMovement) == 0x000060, "Member 'UParticleModuleSQEX_ValuePerUnit::AmountMovement' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, AmountMovementScale) == 0x000064, "Member 'UParticleModuleSQEX_ValuePerUnit::AmountMovementScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, AttenuationRate) == 0x000068, "Member 'UParticleModuleSQEX_ValuePerUnit::AttenuationRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_ValuePerUnit, MovementTolerance) == 0x00006C, "Member 'UParticleModuleSQEX_ValuePerUnit::MovementTolerance' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_VectorParameter
// 0x0060 (0x00B0 - 0x0050)
class UParticleModuleSQEX_VectorParameter final : public UParticleModuleSQEX_Base
{
public:
	class FString                                 ParameterName;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 VectorParameter;                                   // 0x0060(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_VectorParameter">();
	}
	static class UParticleModuleSQEX_VectorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_VectorParameter>();
	}
};
static_assert(alignof(UParticleModuleSQEX_VectorParameter) == 0x000008, "Wrong alignment on UParticleModuleSQEX_VectorParameter");
static_assert(sizeof(UParticleModuleSQEX_VectorParameter) == 0x0000B0, "Wrong size on UParticleModuleSQEX_VectorParameter");
static_assert(offsetof(UParticleModuleSQEX_VectorParameter, ParameterName) == 0x000050, "Member 'UParticleModuleSQEX_VectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VectorParameter, VectorParameter) == 0x000060, "Member 'UParticleModuleSQEX_VectorParameter::VectorParameter' has a wrong offset!");

// Class Engine.SoundNodeBranch
// 0x0008 (0x0058 - 0x0050)
class USoundNodeBranch final : public USoundNode
{
public:
	class FName                                   BoolParameterName;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeBranch">();
	}
	static class USoundNodeBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeBranch>();
	}
};
static_assert(alignof(USoundNodeBranch) == 0x000008, "Wrong alignment on USoundNodeBranch");
static_assert(sizeof(USoundNodeBranch) == 0x000058, "Wrong size on USoundNodeBranch");
static_assert(offsetof(USoundNodeBranch, BoolParameterName) == 0x000050, "Member 'USoundNodeBranch::BoolParameterName' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_VertexSpawn
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleSQEX_VertexSpawn final : public UParticleModuleSQEX_LocationBase
{
public:
	class USQEX_ParticleSpawnVertexDataAsset*     VertexData;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAttachMeshVertex : 1;                          // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EVARTEX_ODER_TYPE                             VartexGenerateType;                                // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_SPAWN_SOURCE_TYPE                       SourceType;                                        // 0x0105(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106[0x2];                                      // 0x0106(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bVertexColor : 1;                                  // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockIndexAtLoopReset : 1;                         // 0x0108(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoSameVertexIndex : 1;                            // 0x0108(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ExclusionSpawnElemetnIndexs;                       // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_VertexSpawn">();
	}
	static class UParticleModuleSQEX_VertexSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_VertexSpawn>();
	}
};
static_assert(alignof(UParticleModuleSQEX_VertexSpawn) == 0x112E9AF0, "Wrong alignment on UParticleModuleSQEX_VertexSpawn");
static_assert(sizeof(UParticleModuleSQEX_VertexSpawn) == 0x112E9AF0, "Wrong size on UParticleModuleSQEX_VertexSpawn");
static_assert(offsetof(UParticleModuleSQEX_VertexSpawn, VertexData) == 0x0000F8, "Member 'UParticleModuleSQEX_VertexSpawn::VertexData' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexSpawn, VartexGenerateType) == 0x000104, "Member 'UParticleModuleSQEX_VertexSpawn::VartexGenerateType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexSpawn, SourceType) == 0x000105, "Member 'UParticleModuleSQEX_VertexSpawn::SourceType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexSpawn, ExclusionSpawnElemetnIndexs) == 0x000110, "Member 'UParticleModuleSQEX_VertexSpawn::ExclusionSpawnElemetnIndexs' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_VertexSpawnBase
// 0x0000 (0x0040 - 0x0040)
class UParticleModuleSQEX_VertexSpawnBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_VertexSpawnBase">();
	}
	static class UParticleModuleSQEX_VertexSpawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_VertexSpawnBase>();
	}
};
static_assert(alignof(UParticleModuleSQEX_VertexSpawnBase) == 0x000008, "Wrong alignment on UParticleModuleSQEX_VertexSpawnBase");
static_assert(sizeof(UParticleModuleSQEX_VertexSpawnBase) == 0x000040, "Wrong size on UParticleModuleSQEX_VertexSpawnBase");

// Class Engine.SoundNodeDistanceCrossFade
// 0x0010 (0x0060 - 0x0050)
class USoundNodeDistanceCrossFade : public USoundNode
{
public:
	TArray<struct FDistanceDatum>                 CrossFadeInput;                                    // 0x0050(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeDistanceCrossFade">();
	}
	static class USoundNodeDistanceCrossFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeDistanceCrossFade>();
	}
};
static_assert(alignof(USoundNodeDistanceCrossFade) == 0x000008, "Wrong alignment on USoundNodeDistanceCrossFade");
static_assert(sizeof(USoundNodeDistanceCrossFade) == 0x000060, "Wrong size on USoundNodeDistanceCrossFade");
static_assert(offsetof(USoundNodeDistanceCrossFade, CrossFadeInput) == 0x000050, "Member 'USoundNodeDistanceCrossFade::CrossFadeInput' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_VertexTarget
// 0x0160 (0x01B0 - 0x0050)
class UParticleModuleSQEX_VertexTarget final : public UParticleModuleSQEX_Base
{
public:
	class UStaticMesh*                            TargetMesh;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TargetSkeletalMesh;                                // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSpawnModuleTarget : 1;                         // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetEmitterName;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseEmitterRotMat : 1;                             // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVertexColor : 1;                                  // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsWorldLocation : 1;                              // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkipTime;                                          // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Speed;                                             // 0x0078(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PolygonAreaBlockNumber;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_SPAWN_SOURCE_TYPE                       SourceType;                                        // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bResetVertexNumberList : 1;                        // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 OffsetPosition;                                    // 0x00C0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 OffsetRotation;                                    // 0x0110(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 OffsetScale;                                       // 0x0160(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_VertexTarget">();
	}
	static class UParticleModuleSQEX_VertexTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_VertexTarget>();
	}
};
static_assert(alignof(UParticleModuleSQEX_VertexTarget) == 0x000008, "Wrong alignment on UParticleModuleSQEX_VertexTarget");
static_assert(sizeof(UParticleModuleSQEX_VertexTarget) == 0x0001B0, "Wrong size on UParticleModuleSQEX_VertexTarget");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, TargetMesh) == 0x000050, "Member 'UParticleModuleSQEX_VertexTarget::TargetMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, TargetSkeletalMesh) == 0x000058, "Member 'UParticleModuleSQEX_VertexTarget::TargetSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, TargetEmitterName) == 0x000068, "Member 'UParticleModuleSQEX_VertexTarget::TargetEmitterName' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, SkipTime) == 0x000074, "Member 'UParticleModuleSQEX_VertexTarget::SkipTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, Speed) == 0x000078, "Member 'UParticleModuleSQEX_VertexTarget::Speed' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, PolygonAreaBlockNumber) == 0x0000B0, "Member 'UParticleModuleSQEX_VertexTarget::PolygonAreaBlockNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, SourceType) == 0x0000B4, "Member 'UParticleModuleSQEX_VertexTarget::SourceType' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, OffsetPosition) == 0x0000C0, "Member 'UParticleModuleSQEX_VertexTarget::OffsetPosition' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, OffsetRotation) == 0x000110, "Member 'UParticleModuleSQEX_VertexTarget::OffsetRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VertexTarget, OffsetScale) == 0x000160, "Member 'UParticleModuleSQEX_VertexTarget::OffsetScale' has a wrong offset!");

// Class Engine.ParticleModuleSQEX_VoxelVertexIndex
// 0x0088 (0x00E0 - 0x0058)
class UParticleModuleSQEX_VoxelVertexIndex final : public UParticleModuleSpawnBase
{
public:
	struct FVector                                FieldSizeMax;                                      // 0x0058(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FieldSizeMin;                                      // 0x0064(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USQEX_ParticleVoxelDataAsset*           VoxelData;                                         // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxcelHeight;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TestVec1;                                          // 0x0080(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestVec2;                                          // 0x008C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestVec3;                                          // 0x0098(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriPos0;                                           // 0x00A4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriPos1;                                           // 0x00B0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriPos2;                                           // 0x00BC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Area;                                              // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deg;                                               // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotAndLine;                                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawVoxelIndex : 1;                               // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSQEX_VoxelVertexIndex">();
	}
	static class UParticleModuleSQEX_VoxelVertexIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSQEX_VoxelVertexIndex>();
	}
};
static_assert(alignof(UParticleModuleSQEX_VoxelVertexIndex) == 0x000008, "Wrong alignment on UParticleModuleSQEX_VoxelVertexIndex");
static_assert(sizeof(UParticleModuleSQEX_VoxelVertexIndex) == 0x0000E0, "Wrong size on UParticleModuleSQEX_VoxelVertexIndex");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, FieldSizeMax) == 0x000058, "Member 'UParticleModuleSQEX_VoxelVertexIndex::FieldSizeMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, FieldSizeMin) == 0x000064, "Member 'UParticleModuleSQEX_VoxelVertexIndex::FieldSizeMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, VoxelData) == 0x000070, "Member 'UParticleModuleSQEX_VoxelVertexIndex::VoxelData' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, VoxcelHeight) == 0x000078, "Member 'UParticleModuleSQEX_VoxelVertexIndex::VoxcelHeight' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, TestVec1) == 0x000080, "Member 'UParticleModuleSQEX_VoxelVertexIndex::TestVec1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, TestVec2) == 0x00008C, "Member 'UParticleModuleSQEX_VoxelVertexIndex::TestVec2' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, TestVec3) == 0x000098, "Member 'UParticleModuleSQEX_VoxelVertexIndex::TestVec3' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, TriPos0) == 0x0000A4, "Member 'UParticleModuleSQEX_VoxelVertexIndex::TriPos0' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, TriPos1) == 0x0000B0, "Member 'UParticleModuleSQEX_VoxelVertexIndex::TriPos1' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, TriPos2) == 0x0000BC, "Member 'UParticleModuleSQEX_VoxelVertexIndex::TriPos2' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, Area) == 0x0000C8, "Member 'UParticleModuleSQEX_VoxelVertexIndex::Area' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, Height) == 0x0000CC, "Member 'UParticleModuleSQEX_VoxelVertexIndex::Height' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, Deg) == 0x0000D0, "Member 'UParticleModuleSQEX_VoxelVertexIndex::Deg' has a wrong offset!");
static_assert(offsetof(UParticleModuleSQEX_VoxelVertexIndex, DotAndLine) == 0x0000D4, "Member 'UParticleModuleSQEX_VoxelVertexIndex::DotAndLine' has a wrong offset!");

// Class Engine.ParticleModuleSubUVBase
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleSubUVBase : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSubUVBase">();
	}
	static class UParticleModuleSubUVBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSubUVBase>();
	}
};
static_assert(alignof(UParticleModuleSubUVBase) == 0x000008, "Wrong alignment on UParticleModuleSubUVBase");
static_assert(sizeof(UParticleModuleSubUVBase) == 0x000050, "Wrong size on UParticleModuleSubUVBase");

// Class Engine.ParticleModuleSubUV
// 0x0048 (0x0098 - 0x0050)
class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
public:
	class USubUVAnimation*                        Animation;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SubImageIndex;                                     // 0x0058(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseRealTime : 1;                                  // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSubUV">();
	}
	static class UParticleModuleSubUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSubUV>();
	}
};
static_assert(alignof(UParticleModuleSubUV) == 0x000008, "Wrong alignment on UParticleModuleSubUV");
static_assert(sizeof(UParticleModuleSubUV) == 0x000098, "Wrong size on UParticleModuleSubUV");
static_assert(offsetof(UParticleModuleSubUV, Animation) == 0x000050, "Member 'UParticleModuleSubUV::Animation' has a wrong offset!");
static_assert(offsetof(UParticleModuleSubUV, SubImageIndex) == 0x000058, "Member 'UParticleModuleSubUV::SubImageIndex' has a wrong offset!");

// Class Engine.PlayerInput
// 0x0370 (0x03B0 - 0x0040)
class UPlayerInput final : public UObject
{
public:
	uint8                                         Pad_40[0xF8];                                      // 0x0040(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKeyBind>                       DebugExecBindings;                                 // 0x0138(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x30];                                     // 0x0148(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InvertedAxis;                                      // 0x0178(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x228];                                    // 0x0188(0x0228)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSmoothing();
	void InvertAxis(const class FName AxisName);
	void InvertAxisKey(const struct FKey& AxisKey);
	void SetBind(class FName BindName, const class FString& Command);
	void SetMouseSensitivity(const float Sensitivity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInput">();
	}
	static class UPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInput>();
	}
};
static_assert(alignof(UPlayerInput) == 0x000008, "Wrong alignment on UPlayerInput");
static_assert(sizeof(UPlayerInput) == 0x0003B0, "Wrong size on UPlayerInput");
static_assert(offsetof(UPlayerInput, DebugExecBindings) == 0x000138, "Member 'UPlayerInput::DebugExecBindings' has a wrong offset!");
static_assert(offsetof(UPlayerInput, InvertedAxis) == 0x000178, "Member 'UPlayerInput::InvertedAxis' has a wrong offset!");

// Class Engine.ParticleModuleSubUVMovie
// 0x0048 (0x00E0 - 0x0098)
class UParticleModuleSubUVMovie final : public UParticleModuleSubUV
{
public:
	uint8                                         bUseEmitterTime : 1;                               // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  FrameRate;                                         // 0x00A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         StartingFrame;                                     // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleSubUVMovie">();
	}
	static class UParticleModuleSubUVMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleSubUVMovie>();
	}
};
static_assert(alignof(UParticleModuleSubUVMovie) == 0x000008, "Wrong alignment on UParticleModuleSubUVMovie");
static_assert(sizeof(UParticleModuleSubUVMovie) == 0x0000E0, "Wrong size on UParticleModuleSubUVMovie");
static_assert(offsetof(UParticleModuleSubUVMovie, FrameRate) == 0x0000A0, "Member 'UParticleModuleSubUVMovie::FrameRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleSubUVMovie, StartingFrame) == 0x0000D8, "Member 'UParticleModuleSubUVMovie::StartingFrame' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataAnimTrail
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleTypeDataAnimTrail final : public UParticleModuleTypeDataBase
{
public:
	uint8                                         bDeadTrailsOnDeactivate : 1;                       // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePreviousTangentRecalculation : 1;           // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTangentRecalculationEveryFrame : 1;               // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TilingDistance;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTessellationStepSize;                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TangentTessellationStepSize;                       // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthTessellationStepSize;                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataAnimTrail">();
	}
	static class UParticleModuleTypeDataAnimTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataAnimTrail>();
	}
};
static_assert(alignof(UParticleModuleTypeDataAnimTrail) == 0x000008, "Wrong alignment on UParticleModuleTypeDataAnimTrail");
static_assert(sizeof(UParticleModuleTypeDataAnimTrail) == 0x000068, "Wrong size on UParticleModuleTypeDataAnimTrail");
static_assert(offsetof(UParticleModuleTypeDataAnimTrail, TilingDistance) == 0x000054, "Member 'UParticleModuleTypeDataAnimTrail::TilingDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataAnimTrail, DistanceTessellationStepSize) == 0x000058, "Member 'UParticleModuleTypeDataAnimTrail::DistanceTessellationStepSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataAnimTrail, TangentTessellationStepSize) == 0x00005C, "Member 'UParticleModuleTypeDataAnimTrail::TangentTessellationStepSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataAnimTrail, WidthTessellationStepSize) == 0x000060, "Member 'UParticleModuleTypeDataAnimTrail::WidthTessellationStepSize' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataBeam2
// 0x0138 (0x0188 - 0x0050)
class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
public:
	EBeam2Method                                  BeamMethod;                                        // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TextureTile;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureTileDistance;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sheets;                                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBeamCount;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationPoints;                               // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysOn : 1;                                     // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpVectorStepSize;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BranchParentName;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  Distance;                                          // 0x0080(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EBeamTaperMethod                              TaperMethod;                                       // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  TaperFactor;                                       // 0x00C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TaperScale;                                        // 0x00F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         RenderGeometry : 1;                                // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RenderDirectLine : 1;                              // 0x0130(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RenderLines : 1;                                   // 0x0130(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RenderTessellation : 1;                            // 0x0130(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x57];                                     // 0x0131(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataBeam2">();
	}
	static class UParticleModuleTypeDataBeam2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataBeam2>();
	}
};
static_assert(alignof(UParticleModuleTypeDataBeam2) == 0x000008, "Wrong alignment on UParticleModuleTypeDataBeam2");
static_assert(sizeof(UParticleModuleTypeDataBeam2) == 0x000188, "Wrong size on UParticleModuleTypeDataBeam2");
static_assert(offsetof(UParticleModuleTypeDataBeam2, BeamMethod) == 0x000050, "Member 'UParticleModuleTypeDataBeam2::BeamMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, TextureTile) == 0x000054, "Member 'UParticleModuleTypeDataBeam2::TextureTile' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, TextureTileDistance) == 0x000058, "Member 'UParticleModuleTypeDataBeam2::TextureTileDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, Sheets) == 0x00005C, "Member 'UParticleModuleTypeDataBeam2::Sheets' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, MaxBeamCount) == 0x000060, "Member 'UParticleModuleTypeDataBeam2::MaxBeamCount' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, Speed) == 0x000064, "Member 'UParticleModuleTypeDataBeam2::Speed' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, InterpolationPoints) == 0x000068, "Member 'UParticleModuleTypeDataBeam2::InterpolationPoints' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, UpVectorStepSize) == 0x000070, "Member 'UParticleModuleTypeDataBeam2::UpVectorStepSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, BranchParentName) == 0x000078, "Member 'UParticleModuleTypeDataBeam2::BranchParentName' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, Distance) == 0x000080, "Member 'UParticleModuleTypeDataBeam2::Distance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, TaperMethod) == 0x0000B8, "Member 'UParticleModuleTypeDataBeam2::TaperMethod' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, TaperFactor) == 0x0000C0, "Member 'UParticleModuleTypeDataBeam2::TaperFactor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataBeam2, TaperScale) == 0x0000F8, "Member 'UParticleModuleTypeDataBeam2::TaperScale' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataGpu
// 0x04B0 (0x0500 - 0x0050)
class UParticleModuleTypeDataGpu final : public UParticleModuleTypeDataBase
{
public:
	struct FGPUSpriteEmitterInfo                  EmitterInfo;                                       // 0x0050(0x112E95F0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGPUSpriteResourceData                 ResourceData;                                      // 0x0310(0x116537E0)(NativeAccessSpecifierPublic)
	float                                         CameraMotionBlurAmount;                            // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bClearExistingParticlesOnInit : 1;                 // 0x04F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         OnWindReaction : 1;                                // 0x04F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4F5[0x3];                                      // 0x04F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindForceScale;                                    // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoResetNewParticles : 1;                          // 0x04FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataGpu">();
	}
	static class UParticleModuleTypeDataGpu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataGpu>();
	}
};
static_assert(alignof(UParticleModuleTypeDataGpu) == 0x000008, "Wrong alignment on UParticleModuleTypeDataGpu");
static_assert(sizeof(UParticleModuleTypeDataGpu) == 0x000500, "Wrong size on UParticleModuleTypeDataGpu");
static_assert(offsetof(UParticleModuleTypeDataGpu, EmitterInfo) == 0x000050, "Member 'UParticleModuleTypeDataGpu::EmitterInfo' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataGpu, ResourceData) == 0x000310, "Member 'UParticleModuleTypeDataGpu::ResourceData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataGpu, CameraMotionBlurAmount) == 0x0004F0, "Member 'UParticleModuleTypeDataGpu::CameraMotionBlurAmount' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataGpu, WindForceScale) == 0x0004F8, "Member 'UParticleModuleTypeDataGpu::WindForceScale' has a wrong offset!");

// Class Engine.PoseWatch
// 0x0010 (0x0050 - 0x0040)
class UPoseWatch final : public UObject
{
public:
	class UEdGraphNode*                           Node;                                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PoseWatchColour;                                   // 0x0048(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseWatch">();
	}
	static class UPoseWatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoseWatch>();
	}
};
static_assert(alignof(UPoseWatch) == 0x000008, "Wrong alignment on UPoseWatch");
static_assert(sizeof(UPoseWatch) == 0x000050, "Wrong size on UPoseWatch");
static_assert(offsetof(UPoseWatch, Node) == 0x000040, "Member 'UPoseWatch::Node' has a wrong offset!");
static_assert(offsetof(UPoseWatch, PoseWatchColour) == 0x000048, "Member 'UPoseWatch::PoseWatchColour' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataRibbon
// 0x0030 (0x0080 - 0x0050)
class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase
{
public:
	int32                                         MaxTessellationBetweenParticles;                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SheetsPerTrail;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTrailCount;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxParticleInTrailCount;                           // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDeadTrailsOnDeactivate : 1;                       // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDeadTrailsOnSourceLoss : 1;                       // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClipSourceSegement : 1;                           // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnablePreviousTangentRecalculation : 1;           // 0x0060(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTangentRecalculationEveryFrame : 1;               // 0x0060(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpawnInitialParticle : 1;                         // 0x0060(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETrailsRenderAxisOption                       RenderAxis;                                        // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TangentSpawningScalar;                             // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRenderGeometry : 1;                               // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderSpawnPoints : 1;                            // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderTangents : 1;                               // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRenderTessellation : 1;                           // 0x006C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TilingDistance;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTessellationStepSize;                      // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableTangentDiffInterpScale : 1;                 // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TangentTessellationScalar;                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataRibbon">();
	}
	static class UParticleModuleTypeDataRibbon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataRibbon>();
	}
};
static_assert(alignof(UParticleModuleTypeDataRibbon) == 0x000008, "Wrong alignment on UParticleModuleTypeDataRibbon");
static_assert(sizeof(UParticleModuleTypeDataRibbon) == 0x000080, "Wrong size on UParticleModuleTypeDataRibbon");
static_assert(offsetof(UParticleModuleTypeDataRibbon, MaxTessellationBetweenParticles) == 0x000050, "Member 'UParticleModuleTypeDataRibbon::MaxTessellationBetweenParticles' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, SheetsPerTrail) == 0x000054, "Member 'UParticleModuleTypeDataRibbon::SheetsPerTrail' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, MaxTrailCount) == 0x000058, "Member 'UParticleModuleTypeDataRibbon::MaxTrailCount' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, MaxParticleInTrailCount) == 0x00005C, "Member 'UParticleModuleTypeDataRibbon::MaxParticleInTrailCount' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, RenderAxis) == 0x000064, "Member 'UParticleModuleTypeDataRibbon::RenderAxis' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, TangentSpawningScalar) == 0x000068, "Member 'UParticleModuleTypeDataRibbon::TangentSpawningScalar' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, TilingDistance) == 0x000070, "Member 'UParticleModuleTypeDataRibbon::TilingDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, DistanceTessellationStepSize) == 0x000074, "Member 'UParticleModuleTypeDataRibbon::DistanceTessellationStepSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataRibbon, TangentTessellationScalar) == 0x00007C, "Member 'UParticleModuleTypeDataRibbon::TangentTessellationScalar' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_2DFluid
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleTypeDataSQEX_2DFluid final : public UParticleModuleTypeDataBase
{
public:
	struct FSQEX2DFluidInfo                       FluidInfo;                                         // 0x0050(0x0098)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSQEX2DFluidResourceData               ResourceData;                                      // 0x00F0(0x112E9300)(Transient, NativeAccessSpecifierPublic)
	ESQEX_2D_FLUID_COMPUTE_TYPE                   ComputeType;                                       // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SimulationSize;                                    // 0x0144(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellSize;                                          // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_2D_FLUID_CAMERA_FACING_TYPE             CameraFacing;                                      // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BillboardRotaionOffset;                            // 0x0154(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bDrawPoint : 1;                                    // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawForce : 1;                                    // 0x0160(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawGrid : 1;                                     // 0x0160(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_2DFluid">();
	}
	static class UParticleModuleTypeDataSQEX_2DFluid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_2DFluid>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_2DFluid) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_2DFluid");
static_assert(sizeof(UParticleModuleTypeDataSQEX_2DFluid) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_2DFluid");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, FluidInfo) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_2DFluid::FluidInfo' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, ResourceData) == 0x0000F0, "Member 'UParticleModuleTypeDataSQEX_2DFluid::ResourceData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, ComputeType) == 0x000140, "Member 'UParticleModuleTypeDataSQEX_2DFluid::ComputeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, SimulationSize) == 0x000144, "Member 'UParticleModuleTypeDataSQEX_2DFluid::SimulationSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, CellSize) == 0x00014C, "Member 'UParticleModuleTypeDataSQEX_2DFluid::CellSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, CameraFacing) == 0x000150, "Member 'UParticleModuleTypeDataSQEX_2DFluid::CameraFacing' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_2DFluid, BillboardRotaionOffset) == 0x000154, "Member 'UParticleModuleTypeDataSQEX_2DFluid::BillboardRotaionOffset' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_ConnectParticle
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_ConnectParticle final : public UParticleModuleTypeDataMesh
{
public:
	bool                                          GetOwnerEmitterParticle;                           // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 Scale;                                             // 0x01C8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CheckLength;                                       // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerceptionLength;                                  // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoonectRate;                                       // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSetParticleAlpha : 1;                             // 0x0224(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckParticleSizeRate : 1;                        // 0x0224(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleBase;                                         // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaleDir;                                          // 0x022C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLenghtScaleX;                                // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLenghtScaleY;                                // 0x0239(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLenghtScaleZ;                                // 0x023A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B[0x1];                                      // 0x023B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FieldMax;                                          // 0x023C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FieldMin;                                          // 0x0248(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Simscale;                                          // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bConnectLine : 1;                                  // 0x025C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_ConnectParticle">();
	}
	static class UParticleModuleTypeDataSQEX_ConnectParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_ConnectParticle>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_ConnectParticle) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_ConnectParticle");
static_assert(sizeof(UParticleModuleTypeDataSQEX_ConnectParticle) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_ConnectParticle");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, GetOwnerEmitterParticle) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::GetOwnerEmitterParticle' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, Scale) == 0x0001C8, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::Scale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, CheckLength) == 0x000218, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::CheckLength' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, PerceptionLength) == 0x00021C, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::PerceptionLength' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, CoonectRate) == 0x000220, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::CoonectRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, ScaleBase) == 0x000228, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::ScaleBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, ScaleDir) == 0x00022C, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::ScaleDir' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, EnableLenghtScaleX) == 0x000238, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::EnableLenghtScaleX' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, EnableLenghtScaleY) == 0x000239, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::EnableLenghtScaleY' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, EnableLenghtScaleZ) == 0x00023A, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::EnableLenghtScaleZ' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, FieldMax) == 0x00023C, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::FieldMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, FieldMin) == 0x000248, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::FieldMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, Height) == 0x000254, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::Height' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_ConnectParticle, Simscale) == 0x000258, "Member 'UParticleModuleTypeDataSQEX_ConnectParticle::Simscale' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_Contin
// 0x01B8 (0x0208 - 0x0050)
class UParticleModuleTypeDataSQEX_Contin final : public UParticleModuleTypeDataBase
{
public:
	class UParticleSystem*                        ParticleSystemAsset;                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWaite;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRndWaite;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleBase;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaleDir;                                          // 0x0064(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDistance;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddRndDistance;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  BaseRange;                                         // 0x0078(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AddRndRange;                                       // 0x00B0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  ScaleRate;                                         // 0x00E8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DirectionAngle;                                    // 0x0120(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  AddDirectionAngle;                                 // 0x0158(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         CheckIndex;                                        // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartRandom;                                     // 0x0194(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstPointToStartLot;                              // 0x0195(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EndPointToEndLot;                                  // 0x0196(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_197[0x1];                                      // 0x0197(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 EndLocation;                                       // 0x0198(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsEndPosRelative;                                  // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetTargetPoint;                                  // 0x01E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA[0x2];                                      // 0x01EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TestAng0;                                          // 0x01EC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestAng1;                                          // 0x01F8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_Contin">();
	}
	static class UParticleModuleTypeDataSQEX_Contin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_Contin>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_Contin) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_Contin");
static_assert(sizeof(UParticleModuleTypeDataSQEX_Contin) == 0x000208, "Wrong size on UParticleModuleTypeDataSQEX_Contin");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, ParticleSystemAsset) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_Contin::ParticleSystemAsset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, SpawnWaite) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_Contin::SpawnWaite' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, SpawnRndWaite) == 0x00005C, "Member 'UParticleModuleTypeDataSQEX_Contin::SpawnRndWaite' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, ScaleBase) == 0x000060, "Member 'UParticleModuleTypeDataSQEX_Contin::ScaleBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, ScaleDir) == 0x000064, "Member 'UParticleModuleTypeDataSQEX_Contin::ScaleDir' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, BaseDistance) == 0x000070, "Member 'UParticleModuleTypeDataSQEX_Contin::BaseDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, AddRndDistance) == 0x000074, "Member 'UParticleModuleTypeDataSQEX_Contin::AddRndDistance' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, BaseRange) == 0x000078, "Member 'UParticleModuleTypeDataSQEX_Contin::BaseRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, AddRndRange) == 0x0000B0, "Member 'UParticleModuleTypeDataSQEX_Contin::AddRndRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, ScaleRate) == 0x0000E8, "Member 'UParticleModuleTypeDataSQEX_Contin::ScaleRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, DirectionAngle) == 0x000120, "Member 'UParticleModuleTypeDataSQEX_Contin::DirectionAngle' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, AddDirectionAngle) == 0x000158, "Member 'UParticleModuleTypeDataSQEX_Contin::AddDirectionAngle' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, CheckIndex) == 0x000190, "Member 'UParticleModuleTypeDataSQEX_Contin::CheckIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, IsStartRandom) == 0x000194, "Member 'UParticleModuleTypeDataSQEX_Contin::IsStartRandom' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, FirstPointToStartLot) == 0x000195, "Member 'UParticleModuleTypeDataSQEX_Contin::FirstPointToStartLot' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, EndPointToEndLot) == 0x000196, "Member 'UParticleModuleTypeDataSQEX_Contin::EndPointToEndLot' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, EndLocation) == 0x000198, "Member 'UParticleModuleTypeDataSQEX_Contin::EndLocation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, IsEndPosRelative) == 0x0001E8, "Member 'UParticleModuleTypeDataSQEX_Contin::IsEndPosRelative' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, ResetTargetPoint) == 0x0001E9, "Member 'UParticleModuleTypeDataSQEX_Contin::ResetTargetPoint' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, TestAng0) == 0x0001EC, "Member 'UParticleModuleTypeDataSQEX_Contin::TestAng0' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Contin, TestAng1) == 0x0001F8, "Member 'UParticleModuleTypeDataSQEX_Contin::TestAng1' has a wrong offset!");

// Class Engine.PreviewCollectionInterface
// 0x0000 (0x0040 - 0x0040)
class IPreviewCollectionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewCollectionInterface">();
	}
	static class IPreviewCollectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPreviewCollectionInterface>();
	}
};
static_assert(alignof(IPreviewCollectionInterface) == 0x000008, "Wrong alignment on IPreviewCollectionInterface");
static_assert(sizeof(IPreviewCollectionInterface) == 0x000040, "Wrong size on IPreviewCollectionInterface");

// Class Engine.ParticleModuleTypeDataSQEX_Control
// 0x0000 (0x0050 - 0x0050)
class UParticleModuleTypeDataSQEX_Control final : public UParticleModuleTypeDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_Control">();
	}
	static class UParticleModuleTypeDataSQEX_Control* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_Control>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_Control) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_Control");
static_assert(sizeof(UParticleModuleTypeDataSQEX_Control) == 0x000050, "Wrong size on UParticleModuleTypeDataSQEX_Control");

// Class Engine.ParticleModuleTypeDataSQEX_CPUFluid
// 0x0088 (0x00D8 - 0x0050)
class UParticleModuleTypeDataSQEX_CPUFluid final : public UParticleModuleTypeDataBase
{
public:
	struct FSQEX_SPHParticleParameterDatas        SPHParameterData;                                  // 0x0050(0x0080)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         DebugCheckStartIndex;                              // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_CPUFluid">();
	}
	static class UParticleModuleTypeDataSQEX_CPUFluid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_CPUFluid>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_CPUFluid) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_CPUFluid");
static_assert(sizeof(UParticleModuleTypeDataSQEX_CPUFluid) == 0x0000D8, "Wrong size on UParticleModuleTypeDataSQEX_CPUFluid");
static_assert(offsetof(UParticleModuleTypeDataSQEX_CPUFluid, SPHParameterData) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_CPUFluid::SPHParameterData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_CPUFluid, DebugCheckStartIndex) == 0x0000D0, "Member 'UParticleModuleTypeDataSQEX_CPUFluid::DebugCheckStartIndex' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_Decal
// 0x0208 (0x0258 - 0x0050)
class UParticleModuleTypeDataSQEX_Decal final : public UParticleModuleTypeDataBase
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableForceRecive : 1;                             // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bItUseScaleRotMatrixTransfrom : 1;                 // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 DecalSize;                                         // 0x0068(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DecalRotation;                                     // 0x00B8(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DecalColor;                                        // 0x0108(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DecalOpacity;                                      // 0x0158(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam0SpawnTime : 1;                     // 0x0190(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam0;                                      // 0x0198(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam1SpawnTime : 1;                     // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam1;                                      // 0x01D8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam2SpawnTime : 1;                     // 0x0210(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam2;                                      // 0x0218(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ZFadeSegment;                                      // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZFadePow;                                          // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_Decal">();
	}
	static class UParticleModuleTypeDataSQEX_Decal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_Decal>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_Decal) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_Decal");
static_assert(sizeof(UParticleModuleTypeDataSQEX_Decal) == 0x000258, "Wrong size on UParticleModuleTypeDataSQEX_Decal");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, DecalMaterial) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_Decal::DecalMaterial' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, FadeScreenSize) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_Decal::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, SortOrder) == 0x00005C, "Member 'UParticleModuleTypeDataSQEX_Decal::SortOrder' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, DecalSize) == 0x000068, "Member 'UParticleModuleTypeDataSQEX_Decal::DecalSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, DecalRotation) == 0x0000B8, "Member 'UParticleModuleTypeDataSQEX_Decal::DecalRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, DecalColor) == 0x000108, "Member 'UParticleModuleTypeDataSQEX_Decal::DecalColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, DecalOpacity) == 0x000158, "Member 'UParticleModuleTypeDataSQEX_Decal::DecalOpacity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, CustomParam0) == 0x000198, "Member 'UParticleModuleTypeDataSQEX_Decal::CustomParam0' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, CustomParam1) == 0x0001D8, "Member 'UParticleModuleTypeDataSQEX_Decal::CustomParam1' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, CustomParam2) == 0x000218, "Member 'UParticleModuleTypeDataSQEX_Decal::CustomParam2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, ZFadeSegment) == 0x000250, "Member 'UParticleModuleTypeDataSQEX_Decal::ZFadeSegment' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Decal, ZFadePow) == 0x000254, "Member 'UParticleModuleTypeDataSQEX_Decal::ZFadePow' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_DynamicShape
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleTypeDataSQEX_DynamicShape final : public UParticleModuleTypeDataBase
{
public:
	ESQEX_DYNAMIC_SHAPE_TYPE                      DynamicShapeType;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PolygonNumber;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PolygonRotation;                                   // 0x0058(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RadiusScale;                                       // 0x0068(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  SizeScale;                                         // 0x00A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  HeightScale;                                       // 0x00E8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Spin;                                              // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 PolygonColor;                                      // 0x0128(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  PolygonAlpha;                                      // 0x0178(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bIsCrossPolygon : 1;                               // 0x01B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrossPolygonRotation;                              // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsUseCustomPolygon : 1;                           // 0x01B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PolygonSplit;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 SplitColor;                                        // 0x01C0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SplitAlpha;                                        // 0x0210(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bIsUseCustomUV : 1;                                // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_PARTICLE_UV_ROT_TYPE                    UVType;                                            // 0x024C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTexUReverse : 1;                                  // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTexVReverse : 1;                                  // 0x0250(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              UVTiling;                                          // 0x0254(0x112E95F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  UTilingScale;                                      // 0x0260(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  VTilingScale;                                      // 0x0298(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_DynamicShape">();
	}
	static class UParticleModuleTypeDataSQEX_DynamicShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_DynamicShape>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_DynamicShape) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_DynamicShape");
static_assert(sizeof(UParticleModuleTypeDataSQEX_DynamicShape) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_DynamicShape");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, DynamicShapeType) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::DynamicShapeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, PolygonNumber) == 0x000054, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::PolygonNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, PolygonRotation) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::PolygonRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, Radius) == 0x000064, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::Radius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, RadiusScale) == 0x000068, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::RadiusScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, Size) == 0x0000A0, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::Size' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, SizeScale) == 0x0000A8, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::SizeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, Height) == 0x0000E0, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::Height' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, HeightScale) == 0x0000E8, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::HeightScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, Spin) == 0x000120, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::Spin' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, PolygonColor) == 0x000128, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::PolygonColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, PolygonAlpha) == 0x000178, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::PolygonAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, CrossPolygonRotation) == 0x0001B4, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::CrossPolygonRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, PolygonSplit) == 0x0001BC, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::PolygonSplit' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, SplitColor) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::SplitColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, SplitAlpha) == 0x000210, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::SplitAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, UVType) == 0x00024C, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::UVType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, UVTiling) == 0x000254, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::UVTiling' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, UTilingScale) == 0x000260, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::UTilingScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_DynamicShape, VTilingScale) == 0x000298, "Member 'UParticleModuleTypeDataSQEX_DynamicShape::VTilingScale' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_FragmentMesh
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_FragmentMesh final : public UParticleModuleTypeDataMesh
{
public:
	struct FRawDistributionFloat                  LocationOffsetScale;                               // 0x01C0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  RandomLocationOffsetScale;                         // 0x01F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ImpactTime;                                        // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactPower;                                       // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomImpactPower;                                 // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactLocationOffset;                              // 0x023C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPowerVecotr;                                 // 0x0248(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomImpactPowerVecotr;                           // 0x0254(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bImpactPowerVecotrWorldSpace : 1;                  // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RandomImpactRotation;                              // 0x0268(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bExternalRotRate : 1;                              // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gravity;                                           // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x02C0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysInWorldSpace : 1;                           // 0x02CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_FragmentMesh">();
	}
	static class UParticleModuleTypeDataSQEX_FragmentMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_FragmentMesh>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_FragmentMesh) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_FragmentMesh");
static_assert(sizeof(UParticleModuleTypeDataSQEX_FragmentMesh) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_FragmentMesh");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, LocationOffsetScale) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::LocationOffsetScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, RandomLocationOffsetScale) == 0x0001F8, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::RandomLocationOffsetScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, ImpactTime) == 0x000230, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::ImpactTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, ImpactPower) == 0x000234, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::ImpactPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, RandomImpactPower) == 0x000238, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::RandomImpactPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, ImpactLocationOffset) == 0x00023C, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::ImpactLocationOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, ImpactPowerVecotr) == 0x000248, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::ImpactPowerVecotr' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, RandomImpactPowerVecotr) == 0x000254, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::RandomImpactPowerVecotr' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, RandomImpactRotation) == 0x000268, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::RandomImpactRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, Gravity) == 0x0002BC, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::Gravity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_FragmentMesh, Force) == 0x0002C0, "Member 'UParticleModuleTypeDataSQEX_FragmentMesh::Force' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_GatherAfterBurst
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_GatherAfterBurst final : public UParticleModuleTypeDataMesh
{
public:
	float                                         GroundZ;                                           // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x01C4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddSpeed;                                          // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundTime;                                         // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterOutTime;                                     // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterOutTimeAddRand;                              // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRotPower;                                    // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetRot;                                      // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHitRadius;                                   // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshRotOffset;                                     // 0x01F4(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetPointOffset;                                 // 0x0200(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAbsolutelyAreaIn : 1;                             // 0x020C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAreaOutDropDown : 1;                              // 0x020C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AreaCenterPoint;                                   // 0x0210(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AreaRadius;                                        // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEndScale : 1;                                     // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndScaleTime;                                      // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableX : 1;                                      // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableY : 1;                                      // 0x0228(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableZ : 1;                                      // 0x0228(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_GatherAfterBurst">();
	}
	static class UParticleModuleTypeDataSQEX_GatherAfterBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_GatherAfterBurst>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_GatherAfterBurst) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_GatherAfterBurst");
static_assert(sizeof(UParticleModuleTypeDataSQEX_GatherAfterBurst) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_GatherAfterBurst");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, GroundZ) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::GroundZ' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, Gravity) == 0x0001C4, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::Gravity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, Speed) == 0x0001D0, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::Speed' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, AddSpeed) == 0x0001D4, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::AddSpeed' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, MaxSpeed) == 0x0001D8, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, BoundTime) == 0x0001DC, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::BoundTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, CenterOutTime) == 0x0001E0, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::CenterOutTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, CenterOutTimeAddRand) == 0x0001E4, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::CenterOutTimeAddRand' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, TargetRotPower) == 0x0001E8, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::TargetRotPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, MaxTargetRot) == 0x0001EC, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::MaxTargetRot' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, TargetHitRadius) == 0x0001F0, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::TargetHitRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, MeshRotOffset) == 0x0001F4, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::MeshRotOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, TargetPointOffset) == 0x000200, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::TargetPointOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, AreaCenterPoint) == 0x000210, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::AreaCenterPoint' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, AreaRadius) == 0x00021C, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::AreaRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GatherAfterBurst, EndScaleTime) == 0x000224, "Member 'UParticleModuleTypeDataSQEX_GatherAfterBurst::EndScaleTime' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_GPUFluid
// 0x00A8 (0x00F8 - 0x0050)
class UParticleModuleTypeDataSQEX_GPUFluid final : public UParticleModuleTypeDataBase
{
public:
	struct FSQEX_SPHParticleParameterDatas        SPHParameterData;                                  // 0x0050(0x0080)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         TypeGas : 1;                                       // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxParticleNumber;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugCheckStartIndex;                              // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DebugPressureColor : 1;                            // 0x00DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugPressureColorScale;                           // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DebugRhoColor : 1;                                 // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugRhoColorScale;                                // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DebugForColor : 1;                                 // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugForColorScale;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_GPUFluid">();
	}
	static class UParticleModuleTypeDataSQEX_GPUFluid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_GPUFluid>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_GPUFluid) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_GPUFluid");
static_assert(sizeof(UParticleModuleTypeDataSQEX_GPUFluid) == 0x0000F8, "Wrong size on UParticleModuleTypeDataSQEX_GPUFluid");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUFluid, SPHParameterData) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_GPUFluid::SPHParameterData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUFluid, MaxParticleNumber) == 0x0000D4, "Member 'UParticleModuleTypeDataSQEX_GPUFluid::MaxParticleNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUFluid, DebugCheckStartIndex) == 0x0000D8, "Member 'UParticleModuleTypeDataSQEX_GPUFluid::DebugCheckStartIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUFluid, DebugPressureColorScale) == 0x0000E0, "Member 'UParticleModuleTypeDataSQEX_GPUFluid::DebugPressureColorScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUFluid, DebugRhoColorScale) == 0x0000E8, "Member 'UParticleModuleTypeDataSQEX_GPUFluid::DebugRhoColorScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUFluid, DebugForColorScale) == 0x0000F0, "Member 'UParticleModuleTypeDataSQEX_GPUFluid::DebugForColorScale' has a wrong offset!");

// Class Engine.SplineMeshActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASplineMeshActor final : public AActor
{
public:
	class USplineMeshComponent*                   SplineMeshComponent;                               // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineMeshActor">();
	}
	static class ASplineMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineMeshActor>();
	}
};
static_assert(alignof(ASplineMeshActor) == 0x1EF72E00, "Wrong alignment on ASplineMeshActor");
static_assert(sizeof(ASplineMeshActor) == 0x1EF72E00, "Wrong size on ASplineMeshActor");
static_assert(offsetof(ASplineMeshActor, SplineMeshComponent) == 0x0003E0, "Member 'ASplineMeshActor::SplineMeshComponent' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_GPUParticle
// 0x0258 (0x02A8 - 0x0050)
class UParticleModuleTypeDataSQEX_GPUParticle final : public UParticleModuleTypeDataBase
{
public:
	ESQEX_GPU_PARTICLE_TYPE                       ParticleType;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxParticleNumber;                                 // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestSpawnWaitParticle;                             // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckReactionNumberWait;                           // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CheckReactionNumber : 1;                           // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AfterSpawnNoStateCheck : 1;                        // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoCulling : 1;                                    // 0x0060(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideMaterial : 1;                             // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMesh*>                    Meshs;                                             // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bUseSubMeshs : 1;                                  // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_GPUParticleMeshsListData> MeshLists;                                         // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpawnMeshDataIndex;                                // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SpawnMeshIndexImportant;                           // 0x00B8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 CheckCenterPos;                                    // 0x00F0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 ParticleLockDir;                                   // 0x0140(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  CheckRange;                                        // 0x0190(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  CheckRange2;                                       // 0x01C8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 SpawnAddVelocity;                                  // 0x0200(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SpawnGravity;                                      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               HeightmapTexture;                                  // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HeightTexCenterLocation;                           // 0x0260(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightCheckSize;                                   // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckHeight;                                       // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReSpawn : 1;                                      // 0x0274(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReSpawnNumberRate;                                 // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReSpawnTimer;                                      // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnStopTimer;                                    // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterInsideNumber;                                 // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterInsideRate;                                   // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckPlayerRadius;                                 // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitEffectOffset;                                   // 0x0290(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        HitEffect;                                         // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_GPUParticle">();
	}
	static class UParticleModuleTypeDataSQEX_GPUParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_GPUParticle>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_GPUParticle) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_GPUParticle");
static_assert(sizeof(UParticleModuleTypeDataSQEX_GPUParticle) == 0x0002A8, "Wrong size on UParticleModuleTypeDataSQEX_GPUParticle");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, ParticleType) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::ParticleType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, MaxParticleNumber) == 0x000054, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::MaxParticleNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, RestSpawnWaitParticle) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::RestSpawnWaitParticle' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, CheckReactionNumberWait) == 0x00005C, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::CheckReactionNumberWait' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, Mesh) == 0x000068, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::Mesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, Meshs) == 0x000078, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::Meshs' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, MeshLists) == 0x000090, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::MeshLists' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, IntervalTime) == 0x0000A0, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::IntervalTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, SpawnMeshDataIndex) == 0x0000A8, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::SpawnMeshDataIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, SpawnMeshIndexImportant) == 0x0000B8, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::SpawnMeshIndexImportant' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, CheckCenterPos) == 0x0000F0, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::CheckCenterPos' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, ParticleLockDir) == 0x000140, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::ParticleLockDir' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, CheckRange) == 0x000190, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::CheckRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, CheckRange2) == 0x0001C8, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::CheckRange2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, SpawnAddVelocity) == 0x000200, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::SpawnAddVelocity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, SpawnGravity) == 0x000250, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::SpawnGravity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, MoveSpeed) == 0x000254, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, HeightmapTexture) == 0x000258, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::HeightmapTexture' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, HeightTexCenterLocation) == 0x000260, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::HeightTexCenterLocation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, HeightCheckSize) == 0x00026C, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::HeightCheckSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, CheckHeight) == 0x000270, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::CheckHeight' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, ReSpawnNumberRate) == 0x000278, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::ReSpawnNumberRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, ReSpawnTimer) == 0x00027C, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::ReSpawnTimer' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, SpawnStopTimer) == 0x000280, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::SpawnStopTimer' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, EnterInsideNumber) == 0x000284, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::EnterInsideNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, EnterInsideRate) == 0x000288, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::EnterInsideRate' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, CheckPlayerRadius) == 0x00028C, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::CheckPlayerRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, HitEffectOffset) == 0x000290, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::HitEffectOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GPUParticle, HitEffect) == 0x0002A0, "Member 'UParticleModuleTypeDataSQEX_GPUParticle::HitEffect' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_GrassForce
// 0x00B8 (0x0108 - 0x0050)
class UParticleModuleTypeDataSQEX_GrassForce final : public UParticleModuleTypeDataBase
{
public:
	int32                                         GrassForcePriority;                                // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  GrassForceRange;                                   // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GrassForcePower;                                   // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  GrassForceDetailPower;                             // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESQEXGrassForceType                           GrassForceForceType;                               // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_GrassForce">();
	}
	static class UParticleModuleTypeDataSQEX_GrassForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_GrassForce>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_GrassForce) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_GrassForce");
static_assert(sizeof(UParticleModuleTypeDataSQEX_GrassForce) == 0x000108, "Wrong size on UParticleModuleTypeDataSQEX_GrassForce");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GrassForce, GrassForcePriority) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_GrassForce::GrassForcePriority' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GrassForce, GrassForceRange) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_GrassForce::GrassForceRange' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GrassForce, GrassForcePower) == 0x000090, "Member 'UParticleModuleTypeDataSQEX_GrassForce::GrassForcePower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GrassForce, GrassForceDetailPower) == 0x0000C8, "Member 'UParticleModuleTypeDataSQEX_GrassForce::GrassForceDetailPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_GrassForce, GrassForceForceType) == 0x000100, "Member 'UParticleModuleTypeDataSQEX_GrassForce::GrassForceForceType' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_LineRoad
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleTypeDataSQEX_LineRoad final : public UParticleModuleTypeDataBase
{
public:
	ESQEX_LINE_ROAD_HISTORY_TYPE                  HistoryDataType;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_LineRoad">();
	}
	static class UParticleModuleTypeDataSQEX_LineRoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_LineRoad>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_LineRoad) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_LineRoad");
static_assert(sizeof(UParticleModuleTypeDataSQEX_LineRoad) == 0x000058, "Wrong size on UParticleModuleTypeDataSQEX_LineRoad");
static_assert(offsetof(UParticleModuleTypeDataSQEX_LineRoad, HistoryDataType) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_LineRoad::HistoryDataType' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_OmnidLaser
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_OmnidLaser final : public UParticleModuleTypeDataMesh
{
public:
	ESQEX_OMNID_LASER_SHAPE_TYPE                  OmidLaserShapeType;                                // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxSpawnNumber;                                    // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WNumber;                                           // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HNumber;                                           // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubNum;                                            // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Radius;                                            // 0x01D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StepNum;                                           // 0x0210(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 LaserParticleScale;                                // 0x0248(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseLeaserShake;                                    // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeWaitBase;                                     // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeWaitRndom;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  LaserShakePower;                                   // 0x02A8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ResetBaseTime;                                     // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetRandomAddTime;                                // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestCheck;                                         // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestCheckListReset;                                // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x2];                                      // 0x02EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TestCheckListResetTime;                            // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestCheckListNumber;                               // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckRadius;                                       // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckIndexNum;                                     // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestAutoShot;                                      // 0x02FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TestShotSpeed;                                     // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_OmnidLaser">();
	}
	static class UParticleModuleTypeDataSQEX_OmnidLaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_OmnidLaser>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_OmnidLaser) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_OmnidLaser");
static_assert(sizeof(UParticleModuleTypeDataSQEX_OmnidLaser) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_OmnidLaser");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, OmidLaserShapeType) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::OmidLaserShapeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, MaxSpawnNumber) == 0x0001C4, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::MaxSpawnNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, WNumber) == 0x0001C8, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::WNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, HNumber) == 0x0001CC, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::HNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, SubNum) == 0x0001D0, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::SubNum' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, Radius) == 0x0001D8, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::Radius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, StepNum) == 0x000210, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::StepNum' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, LaserParticleScale) == 0x000248, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::LaserParticleScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, UseLeaserShake) == 0x000298, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::UseLeaserShake' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, ShakeWaitBase) == 0x00029C, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::ShakeWaitBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, ShakeWaitRndom) == 0x0002A0, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::ShakeWaitRndom' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, LaserShakePower) == 0x0002A8, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::LaserShakePower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, ResetBaseTime) == 0x0002E0, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::ResetBaseTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, ResetRandomAddTime) == 0x0002E4, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::ResetRandomAddTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, TestCheck) == 0x0002E8, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::TestCheck' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, TestCheckListReset) == 0x0002E9, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::TestCheckListReset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, TestCheckListResetTime) == 0x0002EC, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::TestCheckListResetTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, TestCheckListNumber) == 0x0002F0, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::TestCheckListNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, CheckRadius) == 0x0002F4, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::CheckRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, CheckIndexNum) == 0x0002F8, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::CheckIndexNum' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, TestAutoShot) == 0x0002FC, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::TestAutoShot' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_OmnidLaser, TestShotSpeed) == 0x000300, "Member 'UParticleModuleTypeDataSQEX_OmnidLaser::TestShotSpeed' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TriangleParticle
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleTypeDataSQEX_TriangleParticle : public UParticleModuleTypeDataBase
{
public:
	int32                                         VertexIntervalNumber;                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        TriangleData;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TriangleParticle">();
	}
	static class UParticleModuleTypeDataSQEX_TriangleParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TriangleParticle>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TriangleParticle) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_TriangleParticle");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TriangleParticle) == 0x000068, "Wrong size on UParticleModuleTypeDataSQEX_TriangleParticle");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TriangleParticle, VertexIntervalNumber) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_TriangleParticle::VertexIntervalNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TriangleParticle, TriangleData) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_TriangleParticle::TriangleData' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_PolygonMaker
// 0x0060 (0x00C8 - 0x0068)
class UParticleModuleTypeDataSQEX_PolygonMaker final : public UParticleModuleTypeDataSQEX_TriangleParticle
{
public:
	class UParticleSystem*                        VertexPointAsset;                                  // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystemAsset;                               // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleBase;                                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaleDir;                                          // 0x007C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_PolygonMakerVertexPointData> CreateSideData;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDynamicVertex;                                    // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusCheckSacle;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x00A4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffseScale;                                        // 0x00B0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCheckGround : 1;                                  // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFixShape : 1;                                     // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConnectVertex;                                    // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestStep;                                         // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeStepWait;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_PolygonMaker">();
	}
	static class UParticleModuleTypeDataSQEX_PolygonMaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_PolygonMaker>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_PolygonMaker) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_PolygonMaker");
static_assert(sizeof(UParticleModuleTypeDataSQEX_PolygonMaker) == 0x0000C8, "Wrong size on UParticleModuleTypeDataSQEX_PolygonMaker");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, VertexPointAsset) == 0x000068, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::VertexPointAsset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, ParticleSystemAsset) == 0x000070, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::ParticleSystemAsset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, ScaleBase) == 0x000078, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::ScaleBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, ScaleDir) == 0x00007C, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::ScaleDir' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, CreateSideData) == 0x000088, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::CreateSideData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, bDynamicVertex) == 0x000098, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::bDynamicVertex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, Radius) == 0x00009C, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::Radius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, RadiusCheckSacle) == 0x0000A0, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::RadiusCheckSacle' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, OffsetLocation) == 0x0000A4, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::OffsetLocation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, OffseScale) == 0x0000B0, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::OffseScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, bConnectVertex) == 0x0000C0, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::bConnectVertex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, bTestStep) == 0x0000C1, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::bTestStep' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_PolygonMaker, ChangeStepWait) == 0x0000C4, "Member 'UParticleModuleTypeDataSQEX_PolygonMaker::ChangeStepWait' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_StaticMesh
// 0x112E9AA0 (0x112E9AF0 - 0x0050)
class UParticleModuleTypeDataSQEX_StaticMesh final : public UParticleModuleTypeDataBase
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideMaterial : 1;                             // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 StaticMeshColor;                                   // 0x0060(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  StaticMeshOpacity;                                 // 0x00B0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam0SpawnTime : 1;                     // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam0;                                      // 0x00F0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam1SpawnTime : 1;                     // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam1;                                      // 0x0130(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam2SpawnTime : 1;                     // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam2;                                      // 0x0170(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESQEX_OBJECT_TYPE_TRANSLUCENCYSORTPRIORITY    SQEXTranslucencySortPriorityCategory;              // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCastCapsuleDirectShadow : 1;                      // 0x01AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadow : 1;                                   // 0x01AC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SQEX_bOverrideTranslucencySortPriority : 1;        // 0x01AC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotaionOffset;                                     // 0x01B0(0x112E9AF0)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_StaticMesh">();
	}
	static class UParticleModuleTypeDataSQEX_StaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_StaticMesh>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_StaticMesh) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_StaticMesh");
static_assert(sizeof(UParticleModuleTypeDataSQEX_StaticMesh) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_StaticMesh");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, StaticMesh) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, StaticMeshColor) == 0x000060, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::StaticMeshColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, StaticMeshOpacity) == 0x0000B0, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::StaticMeshOpacity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, CustomParam0) == 0x0000F0, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::CustomParam0' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, CustomParam1) == 0x000130, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::CustomParam1' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, CustomParam2) == 0x000170, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::CustomParam2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, SQEXTranslucencySortPriorityCategory) == 0x0001A8, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::SQEXTranslucencySortPriorityCategory' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_StaticMesh, RotaionOffset) == 0x0001B0, "Member 'UParticleModuleTypeDataSQEX_StaticMesh::RotaionOffset' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TailDecal
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_TailDecal final : public UParticleModuleTypeDataMesh
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortOrder;                                         // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableForceRecive : 1;                             // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 DecalSize;                                         // 0x01D8(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DecalRotation;                                     // 0x0228(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DecalColor;                                        // 0x0278(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DecalOpacity;                                      // 0x02C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam0SpawnTime : 1;                     // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam0;                                      // 0x0308(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam1SpawnTime : 1;                     // 0x0340(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam1;                                      // 0x0348(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseCustomParam2SpawnTime : 1;                     // 0x0380(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  CustomParam2;                                      // 0x0388(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ZFadeSegment;                                      // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZFadePow;                                          // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailDecal">();
	}
	static class UParticleModuleTypeDataSQEX_TailDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailDecal>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailDecal) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_TailDecal");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailDecal) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_TailDecal");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, DecalMaterial) == 0x0001C0, "Member 'UParticleModuleTypeDataSQEX_TailDecal::DecalMaterial' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, FadeScreenSize) == 0x0001C8, "Member 'UParticleModuleTypeDataSQEX_TailDecal::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, SortOrder) == 0x0001CC, "Member 'UParticleModuleTypeDataSQEX_TailDecal::SortOrder' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, DecalSize) == 0x0001D8, "Member 'UParticleModuleTypeDataSQEX_TailDecal::DecalSize' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, DecalRotation) == 0x000228, "Member 'UParticleModuleTypeDataSQEX_TailDecal::DecalRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, DecalColor) == 0x000278, "Member 'UParticleModuleTypeDataSQEX_TailDecal::DecalColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, DecalOpacity) == 0x0002C8, "Member 'UParticleModuleTypeDataSQEX_TailDecal::DecalOpacity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, CustomParam0) == 0x000308, "Member 'UParticleModuleTypeDataSQEX_TailDecal::CustomParam0' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, CustomParam1) == 0x000348, "Member 'UParticleModuleTypeDataSQEX_TailDecal::CustomParam1' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, CustomParam2) == 0x000388, "Member 'UParticleModuleTypeDataSQEX_TailDecal::CustomParam2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, ZFadeSegment) == 0x0003C0, "Member 'UParticleModuleTypeDataSQEX_TailDecal::ZFadeSegment' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailDecal, ZFadePow) == 0x0003C4, "Member 'UParticleModuleTypeDataSQEX_TailDecal::ZFadePow' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TailPolygon
// 0x00F8 (0x0178 - 0x0080)
class UParticleModuleTypeDataSQEX_TailPolygon final : public UParticleModuleTypeDataRibbon
{
public:
	struct FVector                                UpVector;                                          // 0x0080(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TangentVector;                                     // 0x008C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TailPolygonSplitNumber;                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_TAILPOL_UV_ROT_TYPE                     TailUVType;                                        // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTailTexUReverse : 1;                              // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTailTexVReverse : 1;                              // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 TailPolygonColor;                                  // 0x00A8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailPolygonAlpha;                                  // 0x00F8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  TailPoygonUPitch;                                  // 0x0130(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TextureUScale;                                     // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureVScale;                                     // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTextureUTypeParticleDistance : 1;                 // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUVLockMode : 1;                                   // 0x0170(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailPolygon">();
	}
	static class UParticleModuleTypeDataSQEX_TailPolygon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailPolygon>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailPolygon) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_TailPolygon");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailPolygon) == 0x000178, "Wrong size on UParticleModuleTypeDataSQEX_TailPolygon");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, UpVector) == 0x000080, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::UpVector' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TangentVector) == 0x00008C, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TangentVector' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TailPolygonSplitNumber) == 0x000098, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TailPolygonSplitNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TailUVType) == 0x00009C, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TailUVType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TailPolygonColor) == 0x0000A8, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TailPolygonColor' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TailPolygonAlpha) == 0x0000F8, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TailPolygonAlpha' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TailPoygonUPitch) == 0x000130, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TailPoygonUPitch' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TextureUScale) == 0x000168, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TextureUScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailPolygon, TextureVScale) == 0x00016C, "Member 'UParticleModuleTypeDataSQEX_TailPolygon::TextureVScale' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TailShape
// 0x0018 (0x0068 - 0x0050)
class UParticleModuleTypeDataSQEX_TailShape : public UParticleModuleTypeDataBase
{
public:
	uint8                                         bIsOwnerCompletedPos : 1;                          // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NoHistoryOfTheMatrixLocalList;                     // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailShape">();
	}
	static class UParticleModuleTypeDataSQEX_TailShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailShape>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailShape) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_TailShape");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailShape) == 0x000068, "Wrong size on UParticleModuleTypeDataSQEX_TailShape");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailShape, NoHistoryOfTheMatrixLocalList) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_TailShape::NoHistoryOfTheMatrixLocalList' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_TailShapeEx
// 0x0008 (0x0070 - 0x0068)
class UParticleModuleTypeDataSQEX_TailShapeEx final : public UParticleModuleTypeDataSQEX_TailShape
{
public:
	uint8                                         bIsLocalHistory : 1;                               // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSameLocationNoParticleMove : 1;                 // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailShapeEx">();
	}
	static class UParticleModuleTypeDataSQEX_TailShapeEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailShapeEx>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailShapeEx) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_TailShapeEx");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailShapeEx) == 0x000070, "Wrong size on UParticleModuleTypeDataSQEX_TailShapeEx");

// Class Engine.TraceSplineInstancedStaticMeshComponent
// 0x0000 (0x11635BE0 - 0x11635BE0)
class UTraceSplineInstancedStaticMeshComponent final : public UInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceSplineInstancedStaticMeshComponent">();
	}
	static class UTraceSplineInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceSplineInstancedStaticMeshComponent>();
	}
};
static_assert(alignof(UTraceSplineInstancedStaticMeshComponent) == 0x11635BE0, "Wrong alignment on UTraceSplineInstancedStaticMeshComponent");
static_assert(sizeof(UTraceSplineInstancedStaticMeshComponent) == 0x11635BE0, "Wrong size on UTraceSplineInstancedStaticMeshComponent");

// Class Engine.ParticleModuleTypeDataSQEX_TailShapeTypeMesh
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleModuleTypeDataSQEX_TailShapeTypeMesh final : public UParticleModuleTypeDataMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailShapeTypeMesh">();
	}
	static class UParticleModuleTypeDataSQEX_TailShapeTypeMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailShapeTypeMesh>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailShapeTypeMesh) == 0x112E9AF0, "Wrong alignment on UParticleModuleTypeDataSQEX_TailShapeTypeMesh");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailShapeTypeMesh) == 0x112E9AF0, "Wrong size on UParticleModuleTypeDataSQEX_TailShapeTypeMesh");

// Class Engine.ParticleModuleTypeDataSQEX_TailTube
// 0x0008 (0x0058 - 0x0050)
class UParticleModuleTypeDataSQEX_TailTube final : public UParticleModuleTypeDataBase
{
public:
	int32                                         WNumber;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OnTrubeScale : 1;                                  // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnReversePolygon : 1;                             // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_TailTube">();
	}
	static class UParticleModuleTypeDataSQEX_TailTube* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_TailTube>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_TailTube) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_TailTube");
static_assert(sizeof(UParticleModuleTypeDataSQEX_TailTube) == 0x000058, "Wrong size on UParticleModuleTypeDataSQEX_TailTube");
static_assert(offsetof(UParticleModuleTypeDataSQEX_TailTube, WNumber) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_TailTube::WNumber' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_Thunder
// 0x0020 (0x01A8 - 0x0188)
class UParticleModuleTypeDataSQEX_Thunder final : public UParticleModuleTypeDataBeam2
{
public:
	float                                         UpdateTime;                                        // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_THUNDER_GET_TYPE                        SetStartPointType;                                 // 0x018C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_THUNDER_GET_TYPE                        SetEndPointType;                                   // 0x018D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bConnectingVertexAndNextVertex : 1;                // 0x0190(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckCollision : 1;                               // 0x0190(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseBoneList : 1;                                  // 0x0190(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BoneList;                                          // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_Thunder">();
	}
	static class UParticleModuleTypeDataSQEX_Thunder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_Thunder>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_Thunder) == 0x000008, "Wrong alignment on UParticleModuleTypeDataSQEX_Thunder");
static_assert(sizeof(UParticleModuleTypeDataSQEX_Thunder) == 0x0001A8, "Wrong size on UParticleModuleTypeDataSQEX_Thunder");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Thunder, UpdateTime) == 0x000188, "Member 'UParticleModuleTypeDataSQEX_Thunder::UpdateTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Thunder, SetStartPointType) == 0x00018C, "Member 'UParticleModuleTypeDataSQEX_Thunder::SetStartPointType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Thunder, SetEndPointType) == 0x00018D, "Member 'UParticleModuleTypeDataSQEX_Thunder::SetEndPointType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_Thunder, BoneList) == 0x000198, "Member 'UParticleModuleTypeDataSQEX_Thunder::BoneList' has a wrong offset!");

// Class Engine.UserInterfaceSettings
// 0x01F4 (0x0244 - 0x0050)
class UUserInterfaceSettings final : public UDeveloperSettings
{
public:
	ERenderFocusRule                              RenderFocusRule;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMouseCursor, struct FHardwareCursorReference> HardwareCursors;                                   // 0x0058(0x0050)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<EMouseCursor, struct FStringClassReference> SoftwareCursors;                                   // 0x00A8(0x0050)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FStringClassReference                  DefaultCursor;                                     // 0x00F8(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FStringClassReference                  TextEditBeamCursor;                                // 0x0108(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FStringClassReference                  CrosshairsCursor;                                  // 0x0118(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FStringClassReference                  HandCursor;                                        // 0x0128(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FStringClassReference                  GrabHandCursor;                                    // 0x0138(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FStringClassReference                  GrabHandClosedCursor;                              // 0x0148(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FStringClassReference                  SlashedCircleCursor;                               // 0x0158(0x003A)(Config, Deprecated, NativeAccessSpecifierPublic)
	float                                         ApplicationScale;                                  // 0x0168(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIScalingRule                                UIScaleRule;                                       // 0x016C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStringClassReference                  CustomScalingRuleClass;                            // 0x0170(0x003A)(Edit, Config, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     UIScaleCurve;                                      // 0x0180(0x11102)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bLoadWidgetsOnDedicatedServer;                     // 0x01F8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        CursorClasses;                                     // 0x0200(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UClass*                                 CustomScalingRuleClassInstance;                    // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDPICustomScalingRule*                  CustomScalingRule;                                 // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserInterfaceSettings">();
	}
	static class UUserInterfaceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserInterfaceSettings>();
	}
};
static_assert(alignof(UUserInterfaceSettings) == 0x00003A, "Wrong alignment on UUserInterfaceSettings");
static_assert(sizeof(UUserInterfaceSettings) == 0x000244, "Wrong size on UUserInterfaceSettings");
static_assert(offsetof(UUserInterfaceSettings, RenderFocusRule) == 0x000050, "Member 'UUserInterfaceSettings::RenderFocusRule' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, HardwareCursors) == 0x000058, "Member 'UUserInterfaceSettings::HardwareCursors' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, SoftwareCursors) == 0x0000A8, "Member 'UUserInterfaceSettings::SoftwareCursors' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, DefaultCursor) == 0x0000F8, "Member 'UUserInterfaceSettings::DefaultCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, TextEditBeamCursor) == 0x000108, "Member 'UUserInterfaceSettings::TextEditBeamCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, CrosshairsCursor) == 0x000118, "Member 'UUserInterfaceSettings::CrosshairsCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, HandCursor) == 0x000128, "Member 'UUserInterfaceSettings::HandCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, GrabHandCursor) == 0x000138, "Member 'UUserInterfaceSettings::GrabHandCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, GrabHandClosedCursor) == 0x000148, "Member 'UUserInterfaceSettings::GrabHandClosedCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, SlashedCircleCursor) == 0x000158, "Member 'UUserInterfaceSettings::SlashedCircleCursor' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, ApplicationScale) == 0x000168, "Member 'UUserInterfaceSettings::ApplicationScale' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, UIScaleRule) == 0x00016C, "Member 'UUserInterfaceSettings::UIScaleRule' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, CustomScalingRuleClass) == 0x000170, "Member 'UUserInterfaceSettings::CustomScalingRuleClass' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, UIScaleCurve) == 0x000180, "Member 'UUserInterfaceSettings::UIScaleCurve' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, bLoadWidgetsOnDedicatedServer) == 0x0001F8, "Member 'UUserInterfaceSettings::bLoadWidgetsOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, CursorClasses) == 0x000200, "Member 'UUserInterfaceSettings::CursorClasses' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, CustomScalingRuleClassInstance) == 0x000210, "Member 'UUserInterfaceSettings::CustomScalingRuleClassInstance' has a wrong offset!");
static_assert(offsetof(UUserInterfaceSettings, CustomScalingRule) == 0x000218, "Member 'UUserInterfaceSettings::CustomScalingRule' has a wrong offset!");

// Class Engine.ParticleModuleTypeDataSQEX_VoxelMesh
// 0x112EA8A0 (0x112EA8F0 - 0x0050)
class UParticleModuleTypeDataSQEX_VoxelMesh final : public UParticleModuleTypeDataBase
{
public:
	ESQEX_VOXEL_COMPUTE_TYPE                      ComputeType;                                       // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VOXEL_RENDER_TYPE                       RenderType;                                        // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideMaterial : 1;                             // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               HeightmapTexture;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FieldSizeMin;                                      // 0x0070(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FieldSizeMax;                                      // 0x007C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelScale;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             VoxelNumber;                                       // 0x008C(0x112EA8F0)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsScaleInterpolation : 1;                         // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPosUpdateInEffectArea : 1;                      // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_VOXEL_INTERPOLATION_TYPE                InterpolationType;                                 // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideInterpolation : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GatherVoxelTime;                                   // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatherMoveRot;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GatherStartRadius;                                 // 0x00AC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseVoxelScale;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VoxelTimeRandom;                                   // 0x00BC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseVoxelTimeScale;                            // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseVoxelTimeScale;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveVoxelTime;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveStartRadius;                                  // 0x00D4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveGravity;                                      // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveImpactPower;                                  // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveRandomImpactPower;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubImpacPower;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveFriction;                                     // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomImpactRotation;                              // 0x00F4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundZOffset;                                     // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 ImpactAddForce;                                    // 0x0108(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CheckPlayerRadius;                                 // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckPlayerImpactPower;                            // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckPlayerAddZForce;                              // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  NoiseIntensityBase;                                // 0x0168(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  NoiseIntensityScale;                               // 0x01A0(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  NoiseIntensityFixScale;                            // 0x01D8(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  FixNoiseFromHighOverrideNoise;                     // 0x0210(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DecreaseVoxelScaleParam;                           // 0x0248(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  IncreaseVoxelTimeScaleParam;                       // 0x0280(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 LeaveImpactPowerScale;                             // 0x02B8(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SimpleShapeRadius;                                 // 0x0308(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  SimpleShapeScale;                                  // 0x0340(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_VoxelCheckSpatialPartitioning> SpatialPartitioningData;                           // 0x0378(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UseSpatialPartitioningLevel;                       // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SetSpatialPartitioningThredNumber;                 // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellCheckSpatialPartitioningIndex;                 // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckBoneRadiusScale;                              // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideCheckType : 1;                            // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_VOXEL_CHECK_TYPE                        OverrideCheckType;                                 // 0x039C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEX_VoxelMeshBoneDataAsset*           BoneListAsset;                                     // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_VoxelCheckBoneData>       CheckBoneList;                                     // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bCreateBoneListData : 1;                           // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BoneNameBase;                                      // 0x03C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelThredNumber;                                  // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelRenderThredNumber;                            // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsTestCheckPostion : 1;                           // 0x03D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPoint1_2ConnectCheck : 1;                       // 0x03D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_VOXEL_CHECK_TYPE                        RenderType1;                                       // 0x03DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 CheckPoint;                                        // 0x03E0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               CheckPointRot1;                                    // 0x0430(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CheckPointScale1;                                  // 0x043C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VOXEL_CHECK_TYPE                        RenderType2;                                       // 0x0448(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 CheckPoint2;                                       // 0x0450(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               CheckPointRot2;                                    // 0x04A0(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CheckPointScale2;                                  // 0x04AC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VOXEL_CHECK_TYPE                        RenderType3;                                       // 0x04B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 CheckPoint3;                                       // 0x04C0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               CheckPointRot3;                                    // 0x0510(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CheckPointScale3;                                  // 0x051C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  CheckTime;                                         // 0x0528(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  CheckRadius;                                       // 0x0560(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ShinePostion;                                      // 0x0598(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShineRadius;                                       // 0x05A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsBreakTest : 1;                                  // 0x05A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_VOXEL_CELL_CHANGE_CONDITIONS            ConditionChangeType;                               // 0x05AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VOXEL_CELL_TYPE                         BeforeCellType;                                    // 0x05AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VOXEL_CELL_TYPE                         AfterCellType;                                     // 0x05AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_VOXEL_CELL_CHANGE_CHECK_TYPE            CheckType;                                         // 0x05AF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 BreakTestCheckPoint;                               // 0x05B0(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  BreakTestCheckRadius;                              // 0x0600(0x0038)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DebugPointSize;                                    // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleTypeDataSQEX_VoxelMesh">();
	}
	static class UParticleModuleTypeDataSQEX_VoxelMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleTypeDataSQEX_VoxelMesh>();
	}
};
static_assert(alignof(UParticleModuleTypeDataSQEX_VoxelMesh) == 0x112EA8F0, "Wrong alignment on UParticleModuleTypeDataSQEX_VoxelMesh");
static_assert(sizeof(UParticleModuleTypeDataSQEX_VoxelMesh) == 0x112EA8F0, "Wrong size on UParticleModuleTypeDataSQEX_VoxelMesh");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, ComputeType) == 0x000050, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::ComputeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, RenderType) == 0x000051, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::RenderType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, Mesh) == 0x000058, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::Mesh' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, HeightmapTexture) == 0x000068, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::HeightmapTexture' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, FieldSizeMin) == 0x000070, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::FieldSizeMin' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, FieldSizeMax) == 0x00007C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::FieldSizeMax' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, VoxelScale) == 0x000088, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::VoxelScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, VoxelNumber) == 0x00008C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::VoxelNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, InterpolationType) == 0x00009C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::InterpolationType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, GatherVoxelTime) == 0x0000A4, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::GatherVoxelTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, GatherMoveRot) == 0x0000A8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::GatherMoveRot' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, GatherStartRadius) == 0x0000AC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::GatherStartRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, DecreaseVoxelScale) == 0x0000B8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::DecreaseVoxelScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, VoxelTimeRandom) == 0x0000BC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::VoxelTimeRandom' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, IncreaseVoxelTimeScale) == 0x0000C8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::IncreaseVoxelTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, DecreaseVoxelTimeScale) == 0x0000CC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::DecreaseVoxelTimeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveVoxelTime) == 0x0000D0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveVoxelTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveStartRadius) == 0x0000D4, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveStartRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveGravity) == 0x0000E0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveGravity' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveImpactPower) == 0x0000E4, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveImpactPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveRandomImpactPower) == 0x0000E8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveRandomImpactPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, SubImpacPower) == 0x0000EC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::SubImpacPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveFriction) == 0x0000F0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveFriction' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, RandomImpactRotation) == 0x0000F4, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::RandomImpactRotation' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, GroundZOffset) == 0x000100, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::GroundZOffset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, ImpactAddForce) == 0x000108, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::ImpactAddForce' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPlayerRadius) == 0x000158, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPlayerRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPlayerImpactPower) == 0x00015C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPlayerImpactPower' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPlayerAddZForce) == 0x000160, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPlayerAddZForce' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, NoiseIntensityBase) == 0x000168, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::NoiseIntensityBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, NoiseIntensityScale) == 0x0001A0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::NoiseIntensityScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, NoiseIntensityFixScale) == 0x0001D8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::NoiseIntensityFixScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, FixNoiseFromHighOverrideNoise) == 0x000210, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::FixNoiseFromHighOverrideNoise' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, DecreaseVoxelScaleParam) == 0x000248, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::DecreaseVoxelScaleParam' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, IncreaseVoxelTimeScaleParam) == 0x000280, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::IncreaseVoxelTimeScaleParam' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, LeaveImpactPowerScale) == 0x0002B8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::LeaveImpactPowerScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, SimpleShapeRadius) == 0x000308, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::SimpleShapeRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, SimpleShapeScale) == 0x000340, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::SimpleShapeScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, SpatialPartitioningData) == 0x000378, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::SpatialPartitioningData' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, UseSpatialPartitioningLevel) == 0x000388, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::UseSpatialPartitioningLevel' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, SetSpatialPartitioningThredNumber) == 0x00038C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::SetSpatialPartitioningThredNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CellCheckSpatialPartitioningIndex) == 0x000390, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CellCheckSpatialPartitioningIndex' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckBoneRadiusScale) == 0x000394, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckBoneRadiusScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, OverrideCheckType) == 0x00039C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::OverrideCheckType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, BoneListAsset) == 0x0003A0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::BoneListAsset' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckBoneList) == 0x0003A8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckBoneList' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, BoneNameBase) == 0x0003C0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::BoneNameBase' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, VoxelThredNumber) == 0x0003D0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::VoxelThredNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, VoxelRenderThredNumber) == 0x0003D4, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::VoxelRenderThredNumber' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, RenderType1) == 0x0003DC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::RenderType1' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPoint) == 0x0003E0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPoint' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPointRot1) == 0x000430, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPointRot1' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPointScale1) == 0x00043C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPointScale1' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, RenderType2) == 0x000448, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::RenderType2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPoint2) == 0x000450, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPoint2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPointRot2) == 0x0004A0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPointRot2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPointScale2) == 0x0004AC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPointScale2' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, RenderType3) == 0x0004B8, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::RenderType3' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPoint3) == 0x0004C0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPoint3' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPointRot3) == 0x000510, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPointRot3' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckPointScale3) == 0x00051C, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckPointScale3' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckTime) == 0x000528, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckTime' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckRadius) == 0x000560, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, ShinePostion) == 0x000598, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::ShinePostion' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, ShineRadius) == 0x0005A4, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::ShineRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, ConditionChangeType) == 0x0005AC, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::ConditionChangeType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, BeforeCellType) == 0x0005AD, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::BeforeCellType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, AfterCellType) == 0x0005AE, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::AfterCellType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, CheckType) == 0x0005AF, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::CheckType' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, BreakTestCheckPoint) == 0x0005B0, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::BreakTestCheckPoint' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, BreakTestCheckRadius) == 0x000600, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::BreakTestCheckRadius' has a wrong offset!");
static_assert(offsetof(UParticleModuleTypeDataSQEX_VoxelMesh, DebugPointSize) == 0x000638, "Member 'UParticleModuleTypeDataSQEX_VoxelMesh::DebugPointSize' has a wrong offset!");

// Class Engine.ParticleModuleVectorFieldGlobal
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleVectorFieldGlobal final : public UParticleModuleVectorFieldBase
{
public:
	uint8                                         bOverrideGlobalVectorFieldTightness : 1;           // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalVectorFieldScale;                            // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalVectorFieldTightness;                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldGlobal">();
	}
	static class UParticleModuleVectorFieldGlobal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldGlobal>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldGlobal) == 0x000008, "Wrong alignment on UParticleModuleVectorFieldGlobal");
static_assert(sizeof(UParticleModuleVectorFieldGlobal) == 0x000060, "Wrong size on UParticleModuleVectorFieldGlobal");
static_assert(offsetof(UParticleModuleVectorFieldGlobal, GlobalVectorFieldScale) == 0x000054, "Member 'UParticleModuleVectorFieldGlobal::GlobalVectorFieldScale' has a wrong offset!");
static_assert(offsetof(UParticleModuleVectorFieldGlobal, GlobalVectorFieldTightness) == 0x000058, "Member 'UParticleModuleVectorFieldGlobal::GlobalVectorFieldTightness' has a wrong offset!");

// Class Engine.ParticleModuleVectorFieldRotationRate
// 0x0010 (0x0060 - 0x0050)
class UParticleModuleVectorFieldRotationRate final : public UParticleModuleVectorFieldBase
{
public:
	struct FVector                                RotationRate;                                      // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVectorFieldRotationRate">();
	}
	static class UParticleModuleVectorFieldRotationRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVectorFieldRotationRate>();
	}
};
static_assert(alignof(UParticleModuleVectorFieldRotationRate) == 0x000008, "Wrong alignment on UParticleModuleVectorFieldRotationRate");
static_assert(sizeof(UParticleModuleVectorFieldRotationRate) == 0x000060, "Wrong size on UParticleModuleVectorFieldRotationRate");
static_assert(offsetof(UParticleModuleVectorFieldRotationRate, RotationRate) == 0x000050, "Member 'UParticleModuleVectorFieldRotationRate::RotationRate' has a wrong offset!");

// Class Engine.ParticleModuleVelocity_Seeded
// 0x0020 (0x0100 - 0x00E0)
class UParticleModuleVelocity_Seeded final : public UParticleModuleVelocity
{
public:
	struct FParticleRandomSeedInfo                RandomSeedInfo;                                    // 0x00E0(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVelocity_Seeded">();
	}
	static class UParticleModuleVelocity_Seeded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVelocity_Seeded>();
	}
};
static_assert(alignof(UParticleModuleVelocity_Seeded) == 0x000008, "Wrong alignment on UParticleModuleVelocity_Seeded");
static_assert(sizeof(UParticleModuleVelocity_Seeded) == 0x000100, "Wrong size on UParticleModuleVelocity_Seeded");
static_assert(offsetof(UParticleModuleVelocity_Seeded, RandomSeedInfo) == 0x0000E0, "Member 'UParticleModuleVelocity_Seeded::RandomSeedInfo' has a wrong offset!");

// Class Engine.ParticleModuleVelocityInheritParent
// 0x0050 (0x00A8 - 0x0058)
class UParticleModuleVelocityInheritParent final : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                 Scale;                                             // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVelocityInheritParent">();
	}
	static class UParticleModuleVelocityInheritParent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVelocityInheritParent>();
	}
};
static_assert(alignof(UParticleModuleVelocityInheritParent) == 0x000008, "Wrong alignment on UParticleModuleVelocityInheritParent");
static_assert(sizeof(UParticleModuleVelocityInheritParent) == 0x0000A8, "Wrong size on UParticleModuleVelocityInheritParent");
static_assert(offsetof(UParticleModuleVelocityInheritParent, Scale) == 0x000058, "Member 'UParticleModuleVelocityInheritParent::Scale' has a wrong offset!");

// Class Engine.SQEX_SplineComponent
// 0x3920 (0x112ED410 - 0x112E9AF0)
class USQEX_SplineComponent final : public UPrimitiveComponent
{
public:
	struct FInterpCurveVector                     SplineInfo;                                        // 0x0868(0x112ED410)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SplineColor;                                       // 0x0880(0x0004)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineDrawRes;                                     // 0x0884(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineArrowSize;                                   // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSplineDisabled : 1;                               // 0x088C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_88D[0x3];                                      // 0x088D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInterpCurveFloat                      SplineReparamTable;                                // 0x0890(0x112EC5B0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      M_SplineReparamRateToDistance;                     // 0x08A8(0x112EC5B0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReparamStepsPerSegment;                            // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosedLoop;                                       // 0x08C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C5[0xB];                                      // 0x08C5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  M_qBaseQuat;                                       // 0x08D0(0x112E9D50)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  M_qNextQuat;                                       // 0x08E0(0x112E9D50)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_SplineComponent">();
	}
	static class USQEX_SplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_SplineComponent>();
	}
};
static_assert(alignof(USQEX_SplineComponent) == 0x112ED410, "Wrong alignment on USQEX_SplineComponent");
static_assert(sizeof(USQEX_SplineComponent) == 0x112ED410, "Wrong size on USQEX_SplineComponent");
static_assert(offsetof(USQEX_SplineComponent, SplineInfo) == 0x000868, "Member 'USQEX_SplineComponent::SplineInfo' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, SplineColor) == 0x000880, "Member 'USQEX_SplineComponent::SplineColor' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, SplineDrawRes) == 0x000884, "Member 'USQEX_SplineComponent::SplineDrawRes' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, SplineArrowSize) == 0x000888, "Member 'USQEX_SplineComponent::SplineArrowSize' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, SplineReparamTable) == 0x000890, "Member 'USQEX_SplineComponent::SplineReparamTable' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, M_SplineReparamRateToDistance) == 0x0008A8, "Member 'USQEX_SplineComponent::M_SplineReparamRateToDistance' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, ReparamStepsPerSegment) == 0x0008C0, "Member 'USQEX_SplineComponent::ReparamStepsPerSegment' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, bClosedLoop) == 0x0008C4, "Member 'USQEX_SplineComponent::bClosedLoop' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, M_qBaseQuat) == 0x0008D0, "Member 'USQEX_SplineComponent::M_qBaseQuat' has a wrong offset!");
static_assert(offsetof(USQEX_SplineComponent, M_qNextQuat) == 0x0008E0, "Member 'USQEX_SplineComponent::M_qNextQuat' has a wrong offset!");

// Class Engine.ParticleModuleVelocityOverLifetime
// 0x0090 (0x00E8 - 0x0058)
class UParticleModuleVelocityOverLifetime final : public UParticleModuleVelocityBase
{
public:
	struct FRawDistributionVector                 VelOverLife;                                       // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Absolute : 1;                                      // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsGravity : 1;                                     // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, ExportObject, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  Gravity;                                           // 0x00B0(0x0038)(Edit, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleVelocityOverLifetime">();
	}
	static class UParticleModuleVelocityOverLifetime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleVelocityOverLifetime>();
	}
};
static_assert(alignof(UParticleModuleVelocityOverLifetime) == 0x000008, "Wrong alignment on UParticleModuleVelocityOverLifetime");
static_assert(sizeof(UParticleModuleVelocityOverLifetime) == 0x0000E8, "Wrong size on UParticleModuleVelocityOverLifetime");
static_assert(offsetof(UParticleModuleVelocityOverLifetime, VelOverLife) == 0x000058, "Member 'UParticleModuleVelocityOverLifetime::VelOverLife' has a wrong offset!");
static_assert(offsetof(UParticleModuleVelocityOverLifetime, Gravity) == 0x0000B0, "Member 'UParticleModuleVelocityOverLifetime::Gravity' has a wrong offset!");

// Class Engine.ParticleSpriteEmitter
// 0x0000 (0x0230 - 0x0230)
class UParticleSpriteEmitter final : public UParticleEmitter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSpriteEmitter">();
	}
	static class UParticleSpriteEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSpriteEmitter>();
	}
};
static_assert(alignof(UParticleSpriteEmitter) == 0x000008, "Wrong alignment on UParticleSpriteEmitter");
static_assert(sizeof(UParticleSpriteEmitter) == 0x000230, "Wrong size on UParticleSpriteEmitter");

// Class Engine.ParticleSystem
// 0x112EAE40 (0x112EAE80 - 0x0040)
class UParticleSystem final : public UObject
{
public:
	int32                                         SqExParticleFlag;                                  // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsAsyncMode : 1;                                  // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsGPUParticleSpawnAsyncMode : 1;                  // 0x0044(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMarchComputeAsyncMode : 1;                      // 0x0044(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AsyncThredNumber;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsAsyncTickMode : 1;                              // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsOriginalAsyncTickMode : 1;                      // 0x004C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleSystemUpdateMode                     SystemUpdateMode;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateTime_FPS;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTime_Delta;                                  // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupTime;                                        // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupTickRate;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSystemTimeType                       ParticleSystemTimeType;                            // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bLoopDurationEmitterStartRelativeTime : 1;         // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bConvertLeavePlaceInWorld : 1;                     // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoopDurationTest : 1;                             // 0x0068(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTimelineTestFlag : 1;                             // 0x0068(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SQEXBaseColor;                                     // 0x006C(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SQEXBaseScale;                                     // 0x007C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseBaseScaleBugFix : 1;                           // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXReceivesDecals : 1;                           // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXCastShadow : 1;                               // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSQEXTranslucentGhostDraw : 1;                     // 0x0088(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbsoluteRotation : 1;                             // 0x0088(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbsoluteScale : 1;                                // 0x0088(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseOwnerRotaion : 1;                              // 0x0088(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLastUpdateTickGroup : 1;                          // 0x0088(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsCinematographyModeOffVisible : 1;               // 0x0089(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideTranslucencySortPriority : 1;             // 0x0089(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         bSQEXTranslucencySortPriority;                     // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SQEXTranslucencySortOffset;                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoopEndAtComplete : 1;                            // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_GPUParticleReactionType                 SqExGPUParticleReactionType;                       // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionPower;                                     // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bForceReactionSet : 1;                             // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoScaleReaction : 1;                              // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckReactionEnableEmitter : 1;                   // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UseReactionEnableEmitterName;                      // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseEmitterPosToReaction : 1;                      // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bItLodMaxDistanceToStopComponent : 1;              // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         NoUseSpawnRateScaleToCameraDistance : 1;           // 0x00B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SpawnRateScaleToPlayerDistance : 1;                // 0x00B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetParentVelocity : 1;                            // 0x00B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGetParentSpeed : 1;                               // 0x00B8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ParentVelocityScale;                               // 0x00BC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCheckPlayerCollision : 1;                         // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsNearCameraDistnceSpawnNumberLoss : 1;           // 0x00C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearCameraRange;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearCameraRangeOffset;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOvrrideIndirectLightingCacheQuality : 1;          // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EIndirectLightingCacheQuality                 IndirectLightingCacheQuality;                      // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleEmitter*>               Emitters;                                          // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USQEX_EffectSeAttachDataAsset*>  ParticleSeAssets;                                  // 0x00F0(0x0010)(Edit, ZeroConstructor, DuplicateTransient, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               PreviewComponent;                                  // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpCurveEdSetup*                    CurveEdSetup;                                      // 0x0108(0x0008)(ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOrientZAxisTowardCamera : 1;                      // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LODDistanceCheckTime;                              // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSystemLODMethod                      LODMethod;                                         // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 LODDistances;                                      // 0x0120(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bRegenerateLODDuplicate : 1;                       // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleSystemLOD>             LODSettings;                                       // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bUseFixedRelativeBoundingBox : 1;                  // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSqExUsetXYZAllSetValue : 1;                       // 0x0148(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SqExSetBoundSize;                                  // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   FixedRelativeBoundingBox;                          // 0x0150(0x001C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SecondsBeforeInactive;                             // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShouldResetPeakCounts : 1;                        // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasPhysics : 1;                                   // 0x0170(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseRealtimeThumbnail : 1;                         // 0x0170(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ThumbnailImageOutOfDate : 1;                       // 0x0170(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delay;                                             // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayLow;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseDelayRange : 1;                                // 0x017C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoDeactivate;                                   // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MinTimeBetweenTicks;                               // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSystemInsignificanceReaction         InsignificantReaction;                             // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InsignificanceDelay;                               // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSignificanceLevel                    MaxSignificanceLevel;                              // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxPoolSize;                                       // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MacroUVPosition;                                   // 0x0198(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MacroUVRadius;                                     // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSystemOcclusionBoundsMethod          OcclusionBoundsMethod;                             // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   CustomOcclusionBounds;                             // 0x01AC(0x001C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLODSoloTrack>                  SoloTracking;                                      // 0x01C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FNamedEmitterMaterial>          NamedMaterialSlots;                                // 0x01D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ContainsEmitterType(class UClass* TypeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystem">();
	}
	static class UParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystem>();
	}
};
static_assert(alignof(UParticleSystem) == 0x112EAE80, "Wrong alignment on UParticleSystem");
static_assert(sizeof(UParticleSystem) == 0x112EAE80, "Wrong size on UParticleSystem");
static_assert(offsetof(UParticleSystem, SqExParticleFlag) == 0x000040, "Member 'UParticleSystem::SqExParticleFlag' has a wrong offset!");
static_assert(offsetof(UParticleSystem, AsyncThredNumber) == 0x000048, "Member 'UParticleSystem::AsyncThredNumber' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SystemUpdateMode) == 0x000050, "Member 'UParticleSystem::SystemUpdateMode' has a wrong offset!");
static_assert(offsetof(UParticleSystem, UpdateTime_FPS) == 0x000054, "Member 'UParticleSystem::UpdateTime_FPS' has a wrong offset!");
static_assert(offsetof(UParticleSystem, UpdateTime_Delta) == 0x000058, "Member 'UParticleSystem::UpdateTime_Delta' has a wrong offset!");
static_assert(offsetof(UParticleSystem, WarmupTime) == 0x00005C, "Member 'UParticleSystem::WarmupTime' has a wrong offset!");
static_assert(offsetof(UParticleSystem, WarmupTickRate) == 0x000060, "Member 'UParticleSystem::WarmupTickRate' has a wrong offset!");
static_assert(offsetof(UParticleSystem, ParticleSystemTimeType) == 0x000064, "Member 'UParticleSystem::ParticleSystemTimeType' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SQEXBaseColor) == 0x00006C, "Member 'UParticleSystem::SQEXBaseColor' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SQEXBaseScale) == 0x00007C, "Member 'UParticleSystem::SQEXBaseScale' has a wrong offset!");
static_assert(offsetof(UParticleSystem, bSQEXTranslucencySortPriority) == 0x00008C, "Member 'UParticleSystem::bSQEXTranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SQEXTranslucencySortOffset) == 0x000090, "Member 'UParticleSystem::SQEXTranslucencySortOffset' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SqExGPUParticleReactionType) == 0x000098, "Member 'UParticleSystem::SqExGPUParticleReactionType' has a wrong offset!");
static_assert(offsetof(UParticleSystem, ReactionPower) == 0x00009C, "Member 'UParticleSystem::ReactionPower' has a wrong offset!");
static_assert(offsetof(UParticleSystem, UseReactionEnableEmitterName) == 0x0000A8, "Member 'UParticleSystem::UseReactionEnableEmitterName' has a wrong offset!");
static_assert(offsetof(UParticleSystem, ParentVelocityScale) == 0x0000BC, "Member 'UParticleSystem::ParentVelocityScale' has a wrong offset!");
static_assert(offsetof(UParticleSystem, NearCameraRange) == 0x0000CC, "Member 'UParticleSystem::NearCameraRange' has a wrong offset!");
static_assert(offsetof(UParticleSystem, NearCameraRangeOffset) == 0x0000D0, "Member 'UParticleSystem::NearCameraRangeOffset' has a wrong offset!");
static_assert(offsetof(UParticleSystem, MinScale) == 0x0000D4, "Member 'UParticleSystem::MinScale' has a wrong offset!");
static_assert(offsetof(UParticleSystem, IndirectLightingCacheQuality) == 0x0000DC, "Member 'UParticleSystem::IndirectLightingCacheQuality' has a wrong offset!");
static_assert(offsetof(UParticleSystem, Emitters) == 0x0000E0, "Member 'UParticleSystem::Emitters' has a wrong offset!");
static_assert(offsetof(UParticleSystem, ParticleSeAssets) == 0x0000F0, "Member 'UParticleSystem::ParticleSeAssets' has a wrong offset!");
static_assert(offsetof(UParticleSystem, PreviewComponent) == 0x000100, "Member 'UParticleSystem::PreviewComponent' has a wrong offset!");
static_assert(offsetof(UParticleSystem, CurveEdSetup) == 0x000108, "Member 'UParticleSystem::CurveEdSetup' has a wrong offset!");
static_assert(offsetof(UParticleSystem, LODDistanceCheckTime) == 0x000114, "Member 'UParticleSystem::LODDistanceCheckTime' has a wrong offset!");
static_assert(offsetof(UParticleSystem, LODMethod) == 0x000118, "Member 'UParticleSystem::LODMethod' has a wrong offset!");
static_assert(offsetof(UParticleSystem, LODDistances) == 0x000120, "Member 'UParticleSystem::LODDistances' has a wrong offset!");
static_assert(offsetof(UParticleSystem, LODSettings) == 0x000138, "Member 'UParticleSystem::LODSettings' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SqExSetBoundSize) == 0x00014C, "Member 'UParticleSystem::SqExSetBoundSize' has a wrong offset!");
static_assert(offsetof(UParticleSystem, FixedRelativeBoundingBox) == 0x000150, "Member 'UParticleSystem::FixedRelativeBoundingBox' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SecondsBeforeInactive) == 0x00016C, "Member 'UParticleSystem::SecondsBeforeInactive' has a wrong offset!");
static_assert(offsetof(UParticleSystem, Delay) == 0x000174, "Member 'UParticleSystem::Delay' has a wrong offset!");
static_assert(offsetof(UParticleSystem, DelayLow) == 0x000178, "Member 'UParticleSystem::DelayLow' has a wrong offset!");
static_assert(offsetof(UParticleSystem, bAutoDeactivate) == 0x000180, "Member 'UParticleSystem::bAutoDeactivate' has a wrong offset!");
static_assert(offsetof(UParticleSystem, MinTimeBetweenTicks) == 0x000184, "Member 'UParticleSystem::MinTimeBetweenTicks' has a wrong offset!");
static_assert(offsetof(UParticleSystem, InsignificantReaction) == 0x000188, "Member 'UParticleSystem::InsignificantReaction' has a wrong offset!");
static_assert(offsetof(UParticleSystem, InsignificanceDelay) == 0x00018C, "Member 'UParticleSystem::InsignificanceDelay' has a wrong offset!");
static_assert(offsetof(UParticleSystem, MaxSignificanceLevel) == 0x000190, "Member 'UParticleSystem::MaxSignificanceLevel' has a wrong offset!");
static_assert(offsetof(UParticleSystem, MaxPoolSize) == 0x000194, "Member 'UParticleSystem::MaxPoolSize' has a wrong offset!");
static_assert(offsetof(UParticleSystem, MacroUVPosition) == 0x000198, "Member 'UParticleSystem::MacroUVPosition' has a wrong offset!");
static_assert(offsetof(UParticleSystem, MacroUVRadius) == 0x0001A4, "Member 'UParticleSystem::MacroUVRadius' has a wrong offset!");
static_assert(offsetof(UParticleSystem, OcclusionBoundsMethod) == 0x0001A8, "Member 'UParticleSystem::OcclusionBoundsMethod' has a wrong offset!");
static_assert(offsetof(UParticleSystem, CustomOcclusionBounds) == 0x0001AC, "Member 'UParticleSystem::CustomOcclusionBounds' has a wrong offset!");
static_assert(offsetof(UParticleSystem, SoloTracking) == 0x0001C8, "Member 'UParticleSystem::SoloTracking' has a wrong offset!");
static_assert(offsetof(UParticleSystem, NamedMaterialSlots) == 0x0001D8, "Member 'UParticleSystem::NamedMaterialSlots' has a wrong offset!");

// Class Engine.ParticleSystemComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UParticleSystemComponent final : public UPrimitiveComponent
{
public:
	class UParticleSystem*                        Template;                                          // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bItLodMaxDistanceToStopComponent : 1;              // 0x0870(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         NoUseSpawnRateScaleToCameraDistance : 1;           // 0x0870(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_871[0x7];                                      // 0x0871(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             EmitterMaterials;                                  // 0x0878(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             DynamicMaterialls;                                 // 0x0888(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             ExtensionMaterialls;                               // 0x0898(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    ExtensionMeshs;                                    // 0x08A8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UTextureRenderTarget2D*>         RenderTargets;                                     // 0x08B8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         SkelMeshComponents;                                // 0x08C8(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         BitPad_8D8_0 : 7;                                  // 0x08D8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bResetOnDetach : 1;                                // 0x08D8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateOnDedicatedServer : 1;                      // 0x08D9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8D9_1 : 2;                                  // 0x08D9(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bAllowRecycling : 1;                               // 0x08D9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoManageAttachment : 1;                         // 0x08D9(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8DA[0x2];                                      // 0x08DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleSignificanceLevel                    RequiredSignificance;                              // 0x08DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DD[0x13];                                     // 0x08DD(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleSysParam>              InstanceParameters;                                // 0x08F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleSpawn;                                   // 0x0900(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleBurst;                                   // 0x0910(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleDeath;                                   // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnParticleCollide;                                 // 0x0930(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                OldPosition;                                       // 0x0940(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PartSysVelocity;                                   // 0x094C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupTime;                                        // 0x0958(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupTickRate;                                    // 0x095C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWarmingUp : 1;                                    // 0x0960(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWarmingUpFirstTick : 1;                           // 0x0960(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_961[0xB];                                      // 0x0961(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsBeforeInactive;                             // 0x096C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_970[0x8];                                      // 0x0970(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeBeforeForceUpdateTransform;                 // 0x0978(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97C[0x4];                                      // 0x097C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideLODMethod : 1;                            // 0x0980(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_981[0x3];                                      // 0x0981(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleSystemLODMethod                      LODMethod;                                         // 0x0984(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_985[0x3];                                      // 0x0985(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSkipUpdateDynamicDataDuringTick : 1;              // 0x0988(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_989[0x1F];                                     // 0x0989(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystemReplay*>          ReplayClips;                                       // 0x09A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B8[0x60];                                     // 0x09B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomTimeDilation;                                // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1C[0x4];                                      // 0x0A1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnSystemFinished;                                  // 0x0A20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         AutoAttachParent;                                  // 0x0A30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AutoAttachSocketName;                              // 0x0A38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AutoAttachLocationType;                            // 0x0A40(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachLocationRule;                            // 0x0A41(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachRotationRule;                            // 0x0A42(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachScaleRule;                               // 0x0A43(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0xE0];                                     // 0x0A44(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHiddenDuringUpdate : 1;                           // 0x0B24(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B25[0x3];                                      // 0x0B25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSqExParticleSeAttachData>      SeAttachDatas;                                     // 0x0B28(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B38[0x9C];                                     // 0x0B38(0x009C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_GroupID;                                         // 0x0BD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD8[0x18];                                     // 0x0BD8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSystem(bool bFlagAsJustAttached);
	int32 AddChangeVoxelCellBoneList(class FName In_EmitterName, ESQEX_VOXEL_CELL_CHANGE_CONDITIONS In_ConditionChangeType, ESQEX_VOXEL_CELL_TYPE In_BeforeCellType, ESQEX_VOXEL_CELL_TYPE In_AfterCellType, const TArray<class FString>& In_BoneNames);
	int32 AddChangeVoxelCellPostionData(class FName In_EmitterName, ESQEX_VOXEL_CELL_CHANGE_CONDITIONS In_ConditionChangeType, ESQEX_VOXEL_CELL_TYPE In_BeforeCellType, ESQEX_VOXEL_CELL_TYPE In_AfterCellType, ESQEX_VOXEL_CELL_CHANGE_CHECK_TYPE In_CheckType, const struct FVector& In_Postion, float In_Radius);
	void AddExternalActorLocationList(const TArray<class AActor*>& In_ActorList, int32 In_VertexNumber);
	void AddExternalVertexList(const TArray<struct FVector>& In_VertexList, int32 In_VertexNumber);
	void AddLineRoadVertexs(const TArray<struct FVector>& In_VertexList);
	int32 AddVoxelShineBoneList(class FName In_EmitterName, const TArray<class FString>& In_BoneNames, const struct FVector& In_Color);
	int32 AddVoxelShinePostion(class FName In_EmitterName, const struct FVector& In_Postion, float In_Radius, const struct FVector& In_Color);
	void AllDeleteChangeVoxelCellData(class FName In_EmitterName);
	void AllDeleteShineData(class FName In_EmitterName);
	void BeginTrails(class FName InFirstSocketName, class FName InSecondSocketName, ETrailWidthMode InWidthMode, float InWidth);
	void CopyExternalVertexList(class UParticleSystemComponent* In_Component);
	class UMaterialInstanceDynamic* CreateNamedDynamicMaterialInstance(class FName InName, class UMaterialInterface* SourceMaterial);
	void DeleteChangeVoxelCellData(class FName In_EmitterName, int32 In_Hash);
	void DeleteShineData(class FName In_EmitterName, int32 In_Hash);
	void EnableLoopEnd();
	void EndTrails();
	void FadeIn(float In_Frame);
	void FadeOut(float In_Frame);
	void GenerateParticleEvent(const class FName InEventName, const float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity);
	void GenerateParticleTrigger(const class FName InEventName, const float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity);
	int32 GetActiveParticleNumber(class FName In_CheckEmitterName);
	bool GetHistoryLocation(class FName In_CheckEmitterName, float In_Rate, struct FVector* Out_HistoryRageLocation, bool In_IsCurrentLength);
	void GetLaserList(class FName In_EmitterName, const TArray<struct FVector>& In_CheckList, TArray<struct FVector>* Out_List, bool In_AutoOff);
	float GetMeshAnimTime(class FName In_CheckEmitterName, int32 In_ParticleIndex);
	bool GetNearHistoryLocation(class FName In_CheckEmitterName, const struct FVector& In_CheckLocation, struct FVector* Out_HistoryNearLocation, float In_Accuracy);
	bool IsEnd();
	void NewChangeVoxelCellPostionAndRadius(class FName In_EmitterName, int32 In_Hash, const struct FVector& In_NewPostion, float In_NewRadius);
	void NewShineColor(class FName In_EmitterName, int32 In_Hash, const struct FVector& In_NewColor);
	void NewShinePostionAndRadius(class FName In_EmitterName, int32 In_Hash, const struct FVector& In_NewPostion, float In_NewRadius);
	void ReleaseToPool();
	void ResetEffect();
	void ResetExternalVertexList();
	void SetActorParameter(class FName ParameterName, class AActor* Param);
	void SetAroundLocation(const struct FVector& In_Location);
	void SetAroundMode(ESQEX_PARTICLE_AROUND_MODE In_NewMode);
	void SetAutoAttachmentParameters(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule);
	void SetAutoAttachParams(class USceneComponent* Parent, class FName SocketName, EAttachLocation LocationType);
	void SetBeamEndPoint(int32 EmitterIndex, const struct FVector& NewEndPoint);
	void SetBeamSourcePoint(int32 EmitterIndex, const struct FVector& NewSourcePoint, int32 SourceIndex);
	void SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex);
	void SetBeamSourceTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 SourceIndex);
	void SetBeamTargetPoint(int32 EmitterIndex, const struct FVector& NewTargetPoint, int32 TargetIndex);
	void SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex);
	void SetBeamTargetTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 TargetIndex);
	void SetCellGather(bool In_Switch);
	void SetCellLeave(bool In_Switch);
	void SetCellPowerValueDecrease(class FName In_EmitterName, float In_NewValue);
	int32 SetChangeVoxelCellBoneList(class FName In_EmitterName, ESQEX_VOXEL_CELL_CHANGE_CONDITIONS In_ConditionChangeType, ESQEX_VOXEL_CELL_TYPE In_BeforeCellType, ESQEX_VOXEL_CELL_TYPE In_AfterCellType, const TArray<class FString>& In_BoneNames);
	int32 SetChangeVoxelCellPostionData(class FName In_EmitterName, ESQEX_VOXEL_CELL_CHANGE_CONDITIONS In_ConditionChangeType, ESQEX_VOXEL_CELL_TYPE In_BeforeCellType, ESQEX_VOXEL_CELL_TYPE In_AfterCellType, ESQEX_VOXEL_CELL_CHANGE_CHECK_TYPE In_CheckType, const struct FVector& In_Postion, float In_Radius);
	void SetColorParameter(class FName ParameterName, const struct FLinearColor& Param);
	void SetEffectSphereArea(const struct FVector& In_AreaPoint, float In_Radius);
	void SetEmitterEnable(class FName EmitterName, bool bNewEnableState);
	void SetExtensionMesh(const class FString& In_Key, class UStaticMesh* In_NewMesh);
	void SetExtensionMeshs(const TMap<class FString, class UStaticMesh*>& In_NewMeshs);
	void SetExternalActorLocationList(const TArray<class AActor*>& In_ActorList, int32 In_VertexNumber);
	void SetExternalPostionHistory(const TArray<struct FVector>& In_VectorList, bool In_OnReset);
	void SetExternalVertexList(const TArray<struct FVector>& In_VertexList, int32 In_VertexNumber);
	void SetFloatParameter(class FName ParameterName, float Param);
	void SetFloatParameterExtention(class FName ParameterName, float Param, bool In_IsSetChildrenParticle);
	void SetFloatRandParameter(class FName ParameterName, float Param, float ParamLow);
	void SetForceOffAvoid(class FName In_CheckEmitterName, bool In_NewFlag);
	void SetGorundZ(float In_GroundZ);
	void SetHeightMapData(class FName In_EmitterName, const struct FVector& In_CenterLocation, float In_HeightCheckSize, float In_Height, class UTexture* In_HeightTexture);
	void SetImpactScroll(bool In_Switch);
	void SetImpactScrollTime(float In_NewTime);
	void SetInstanceStaticMesh(class UInstancedStaticMeshComponent* In_InstanceStaticMesh, int32 In_Index);
	void SetMaterialParameter(class FName ParameterName, class UMaterialInterface* Param);
	void SetMeshAnimSetIndex(int32 In_AnimSetIndex, bool In_IsResetMethAnimTime, bool In_IsNoLoop);
	void SetNoCheckHeidht(class FName In_EmitterName, bool In_NewFlag);
	void SetObjectParameter(class FName ParameterName, class UObject* Param);
	void SetOmnidLaserCheckSetting(class FName In_EmitterName, float In_CheckRadius, int32 In_CheckIndexNum);
	void SetOrAddExclusionParticleDrawCount(int32 In_Number, bool In_IsAdd);
	void SetOverrideSQEXBillboardType(ESQEX_MESH_PAR_BILLBORAD_TYPE In_NewBillboardType);
	void SetSkeletalEmitterAnimSequence(class UAnimSequence* In_AnimSequence, bool In_AnimationStop, float In_AnimationStopTime);
	void SetSkeletalEmitterAnimSequenceNameDesignation(class FName In_EmitterName, class UAnimSequence* In_AnimSequence, bool In_AnimationStop, float In_AnimationStopTime);
	void SetSkeletalEmitterMesh(class USkeletalMeshComponent* In_SkeletalMeshComponent);
	void SetSkeletalEmitterMeshEmitterNameDesignation(class FName In_EmitterName, class USkeletalMeshComponent* In_SkeletalMeshComponent);
	void SetTailMeshMarchParticleWHInterval(float In_WidthInterval, float In_HeightInterval);
	void SetTailMeshMarchParticleWHNumber(int32 In_WidthNumber, int32 In_HeightNumber);
	void SetTargetPoint(const struct FVector& In_TargetPoint);
	void SetTemplate(class UParticleSystem* NewTemplate);
	void SetThunderAttachBones(class FName In_StartSocketName, class FName In_EndSocketName);
	void SetThunderEndPoint(const struct FVector& In_NewEndPoint);
	void SetThunderStartPoint(const struct FVector& In_NewStartPoint);
	void SetTrailSourceData(class FName InFirstSocketName, class FName InSecondSocketName, ETrailWidthMode InWidthMode, float InWidth);
	void SetVectorParameter(class FName ParameterName, const struct FVector& Param);
	void SetVectorParameterExtention(class FName ParameterName, const struct FVector& Param, bool In_IsSetChildrenParticle);
	void SetVectorRandParameter(class FName ParameterName, const struct FVector& Param, const struct FVector& ParamLow);
	int32 SetVoxelShineBoneList(class FName In_EmitterName, const TArray<class FString>& In_BoneNames, const struct FVector& In_Color);
	int32 SetVoxelShinePostion(class FName In_EmitterName, const struct FVector& In_Postion, float In_Radius, const struct FVector& In_Color);
	void StartLineRoadData();

	bool GetBeamEndPoint(int32 EmitterIndex, struct FVector* OutEndPoint) const;
	bool GetBeamSourcePoint(int32 EmitterIndex, int32 SourceIndex, struct FVector* OutSourcePoint) const;
	bool GetBeamSourceStrength(int32 EmitterIndex, int32 SourceIndex, float* OutSourceStrength) const;
	bool GetBeamSourceTangent(int32 EmitterIndex, int32 SourceIndex, struct FVector* OutTangentPoint) const;
	bool GetBeamTargetPoint(int32 EmitterIndex, int32 TargetIndex, struct FVector* OutTargetPoint) const;
	bool GetBeamTargetStrength(int32 EmitterIndex, int32 TargetIndex, float* OutTargetStrength) const;
	bool GetBeamTargetTangent(int32 EmitterIndex, int32 TargetIndex, struct FVector* OutTangentPoint) const;
	class UMaterialInterface* GetNamedMaterial(class FName InName) const;
	int32 GetNumActiveParticles() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemComponent">();
	}
	static class UParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemComponent>();
	}
};
static_assert(alignof(UParticleSystemComponent) == 0x112E9AF0, "Wrong alignment on UParticleSystemComponent");
static_assert(sizeof(UParticleSystemComponent) == 0x112E9AF0, "Wrong size on UParticleSystemComponent");
static_assert(offsetof(UParticleSystemComponent, Template) == 0x000868, "Member 'UParticleSystemComponent::Template' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, EmitterMaterials) == 0x000878, "Member 'UParticleSystemComponent::EmitterMaterials' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, DynamicMaterialls) == 0x000888, "Member 'UParticleSystemComponent::DynamicMaterialls' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, ExtensionMaterialls) == 0x000898, "Member 'UParticleSystemComponent::ExtensionMaterialls' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, ExtensionMeshs) == 0x0008A8, "Member 'UParticleSystemComponent::ExtensionMeshs' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, RenderTargets) == 0x0008B8, "Member 'UParticleSystemComponent::RenderTargets' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, SkelMeshComponents) == 0x0008C8, "Member 'UParticleSystemComponent::SkelMeshComponents' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, RequiredSignificance) == 0x0008DC, "Member 'UParticleSystemComponent::RequiredSignificance' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, InstanceParameters) == 0x0008F0, "Member 'UParticleSystemComponent::InstanceParameters' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, OnParticleSpawn) == 0x000900, "Member 'UParticleSystemComponent::OnParticleSpawn' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, OnParticleBurst) == 0x000910, "Member 'UParticleSystemComponent::OnParticleBurst' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, OnParticleDeath) == 0x000920, "Member 'UParticleSystemComponent::OnParticleDeath' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, OnParticleCollide) == 0x000930, "Member 'UParticleSystemComponent::OnParticleCollide' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, OldPosition) == 0x000940, "Member 'UParticleSystemComponent::OldPosition' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, PartSysVelocity) == 0x00094C, "Member 'UParticleSystemComponent::PartSysVelocity' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, WarmupTime) == 0x000958, "Member 'UParticleSystemComponent::WarmupTime' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, WarmupTickRate) == 0x00095C, "Member 'UParticleSystemComponent::WarmupTickRate' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, SecondsBeforeInactive) == 0x00096C, "Member 'UParticleSystemComponent::SecondsBeforeInactive' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, MaxTimeBeforeForceUpdateTransform) == 0x000978, "Member 'UParticleSystemComponent::MaxTimeBeforeForceUpdateTransform' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, LODMethod) == 0x000984, "Member 'UParticleSystemComponent::LODMethod' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, ReplayClips) == 0x0009A8, "Member 'UParticleSystemComponent::ReplayClips' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, CustomTimeDilation) == 0x000A18, "Member 'UParticleSystemComponent::CustomTimeDilation' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, OnSystemFinished) == 0x000A20, "Member 'UParticleSystemComponent::OnSystemFinished' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, AutoAttachParent) == 0x000A30, "Member 'UParticleSystemComponent::AutoAttachParent' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, AutoAttachSocketName) == 0x000A38, "Member 'UParticleSystemComponent::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, AutoAttachLocationType) == 0x000A40, "Member 'UParticleSystemComponent::AutoAttachLocationType' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, AutoAttachLocationRule) == 0x000A41, "Member 'UParticleSystemComponent::AutoAttachLocationRule' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, AutoAttachRotationRule) == 0x000A42, "Member 'UParticleSystemComponent::AutoAttachRotationRule' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, AutoAttachScaleRule) == 0x000A43, "Member 'UParticleSystemComponent::AutoAttachScaleRule' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, SeAttachDatas) == 0x000B28, "Member 'UParticleSystemComponent::SeAttachDatas' has a wrong offset!");
static_assert(offsetof(UParticleSystemComponent, M_GroupID) == 0x000BD4, "Member 'UParticleSystemComponent::M_GroupID' has a wrong offset!");

// Class Engine.ParticleSystemReplay
// 0x0018 (0x0058 - 0x0040)
class UParticleSystemReplay final : public UObject
{
public:
	int32                                         ClipIDNumber;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x14];                                      // 0x0044(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemReplay">();
	}
	static class UParticleSystemReplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemReplay>();
	}
};
static_assert(alignof(UParticleSystemReplay) == 0x000008, "Wrong alignment on UParticleSystemReplay");
static_assert(sizeof(UParticleSystemReplay) == 0x000058, "Wrong size on UParticleSystemReplay");
static_assert(offsetof(UParticleSystemReplay, ClipIDNumber) == 0x000040, "Member 'UParticleSystemReplay::ClipIDNumber' has a wrong offset!");

// Class Engine.PawnNoiseEmitterComponent
// 0x0000 (0xD38D - 0xD38D)
class UPawnNoiseEmitterComponent final : public UActorComponent
{
public:
	uint8                                         bAIPerceptionSystemCompatibilityMode : 1;          // 0x0200(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastRemoteNoisePosition;                           // 0x0204(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseLifetime;                                     // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRemoteNoiseVolume;                             // 0x0214(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastRemoteNoiseTime;                               // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastLocalNoiseVolume;                              // 0x021C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastLocalNoiseTime;                                // 0x0220(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0xC];                                      // 0x0224(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MakeNoise(class AActor* NoiseMaker, float Loudness, const struct FVector& NoiseLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnNoiseEmitterComponent">();
	}
	static class UPawnNoiseEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnNoiseEmitterComponent>();
	}
};
static_assert(alignof(UPawnNoiseEmitterComponent) == 0x00D38D, "Wrong alignment on UPawnNoiseEmitterComponent");
static_assert(sizeof(UPawnNoiseEmitterComponent) == 0x00D38D, "Wrong size on UPawnNoiseEmitterComponent");
static_assert(offsetof(UPawnNoiseEmitterComponent, LastRemoteNoisePosition) == 0x000204, "Member 'UPawnNoiseEmitterComponent::LastRemoteNoisePosition' has a wrong offset!");
static_assert(offsetof(UPawnNoiseEmitterComponent, NoiseLifetime) == 0x000210, "Member 'UPawnNoiseEmitterComponent::NoiseLifetime' has a wrong offset!");
static_assert(offsetof(UPawnNoiseEmitterComponent, LastRemoteNoiseVolume) == 0x000214, "Member 'UPawnNoiseEmitterComponent::LastRemoteNoiseVolume' has a wrong offset!");
static_assert(offsetof(UPawnNoiseEmitterComponent, LastRemoteNoiseTime) == 0x000218, "Member 'UPawnNoiseEmitterComponent::LastRemoteNoiseTime' has a wrong offset!");
static_assert(offsetof(UPawnNoiseEmitterComponent, LastLocalNoiseVolume) == 0x00021C, "Member 'UPawnNoiseEmitterComponent::LastLocalNoiseVolume' has a wrong offset!");
static_assert(offsetof(UPawnNoiseEmitterComponent, LastLocalNoiseTime) == 0x000220, "Member 'UPawnNoiseEmitterComponent::LastLocalNoiseTime' has a wrong offset!");

// Class Engine.PhysicalAnimationComponent
// 0x0000 (0xD38D - 0xD38D)
class UPhysicalAnimationComponent final : public UActorComponent
{
public:
	float                                         StrengthMultiplyer;                                // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x30];                                     // 0x0210(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPhysicalAnimationProfileBelow(class FName BodyName, class FName ProfileName, bool bIncludeSelf, bool bClearNotFound);
	void ApplyPhysicalAnimationSettings(class FName BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData);
	void ApplyPhysicalAnimationSettingsBelow(class FName BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf);
	void SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent);
	void SetStrengthMultiplyer(float InStrengthMultiplyer);

	struct FTransform GetBodyTargetTransform(class FName BodyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalAnimationComponent">();
	}
	static class UPhysicalAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalAnimationComponent>();
	}
};
static_assert(alignof(UPhysicalAnimationComponent) == 0x00D38D, "Wrong alignment on UPhysicalAnimationComponent");
static_assert(sizeof(UPhysicalAnimationComponent) == 0x00D38D, "Wrong size on UPhysicalAnimationComponent");
static_assert(offsetof(UPhysicalAnimationComponent, StrengthMultiplyer) == 0x000200, "Member 'UPhysicalAnimationComponent::StrengthMultiplyer' has a wrong offset!");
static_assert(offsetof(UPhysicalAnimationComponent, SkeletalMeshComponent) == 0x000208, "Member 'UPhysicalAnimationComponent::SkeletalMeshComponent' has a wrong offset!");

// Class Engine.PhysicalMaterial
// 0x0058 (0x0098 - 0x0040)
class UPhysicalMaterial final : public UObject
{
public:
	float                                         Friction;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFrictionCombineMode                          FrictionCombineMode;                               // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFrictionCombineMode;                      // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Restitution;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFrictionCombineMode                          RestitutionCombineMode;                            // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRestitutionCombineMode;                   // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Density;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaiseMassToPower;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructibleDamageThresholdScale;                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterialPropertyBase*          PhysicalMaterialProperty;                          // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              SurfaceType;                                       // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TireFrictionScale;                                 // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTireFrictionScalePair>         TireFrictionScales;                                // 0x0070(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalMaterial">();
	}
	static class UPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalMaterial>();
	}
};
static_assert(alignof(UPhysicalMaterial) == 0x000008, "Wrong alignment on UPhysicalMaterial");
static_assert(sizeof(UPhysicalMaterial) == 0x000098, "Wrong size on UPhysicalMaterial");
static_assert(offsetof(UPhysicalMaterial, Friction) == 0x000040, "Member 'UPhysicalMaterial::Friction' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, FrictionCombineMode) == 0x000044, "Member 'UPhysicalMaterial::FrictionCombineMode' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, bOverrideFrictionCombineMode) == 0x000045, "Member 'UPhysicalMaterial::bOverrideFrictionCombineMode' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, Restitution) == 0x000048, "Member 'UPhysicalMaterial::Restitution' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, RestitutionCombineMode) == 0x00004C, "Member 'UPhysicalMaterial::RestitutionCombineMode' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, bOverrideRestitutionCombineMode) == 0x00004D, "Member 'UPhysicalMaterial::bOverrideRestitutionCombineMode' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, Density) == 0x000050, "Member 'UPhysicalMaterial::Density' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, RaiseMassToPower) == 0x000054, "Member 'UPhysicalMaterial::RaiseMassToPower' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, DestructibleDamageThresholdScale) == 0x000058, "Member 'UPhysicalMaterial::DestructibleDamageThresholdScale' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, PhysicalMaterialProperty) == 0x000060, "Member 'UPhysicalMaterial::PhysicalMaterialProperty' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, SurfaceType) == 0x000068, "Member 'UPhysicalMaterial::SurfaceType' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, TireFrictionScale) == 0x00006C, "Member 'UPhysicalMaterial::TireFrictionScale' has a wrong offset!");
static_assert(offsetof(UPhysicalMaterial, TireFrictionScales) == 0x000070, "Member 'UPhysicalMaterial::TireFrictionScales' has a wrong offset!");

// Class Engine.SQEX_TimelineTrackPropertyBind
// 0x0018 (0x0058 - 0x0040)
class USQEX_TimelineTrackPropertyBind final : public UObject
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TimelineTrackPropertyBind">();
	}
	static class USQEX_TimelineTrackPropertyBind* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TimelineTrackPropertyBind>();
	}
};
static_assert(alignof(USQEX_TimelineTrackPropertyBind) == 0x000008, "Wrong alignment on USQEX_TimelineTrackPropertyBind");
static_assert(sizeof(USQEX_TimelineTrackPropertyBind) == 0x000058, "Wrong size on USQEX_TimelineTrackPropertyBind");

// Class Engine.PhysicalMaterialPropertyBase
// 0x0000 (0x0040 - 0x0040)
class UPhysicalMaterialPropertyBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalMaterialPropertyBase">();
	}
	static class UPhysicalMaterialPropertyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalMaterialPropertyBase>();
	}
};
static_assert(alignof(UPhysicalMaterialPropertyBase) == 0x000008, "Wrong alignment on UPhysicalMaterialPropertyBase");
static_assert(sizeof(UPhysicalMaterialPropertyBase) == 0x000040, "Wrong size on UPhysicalMaterialPropertyBase");

// Class Engine.PhysicsAsset
// 0x00E8 (0x0128 - 0x0040)
class UPhysicsAsset final : public UObject
{
public:
	TArray<int32>                                 BoundsBodies;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalBodySetup*>             SkeletalBodySetups;                                // 0x0050(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UPhysicsConstraintTemplate*>     ConstraintSetup;                                   // 0x0060(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseAsyncScene : 1;                                // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0xA7];                                      // 0x0071(0x00A7)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBodySetup*>                     BodySetup;                                         // 0x0118(0x0010)(ExportObject, ZeroConstructor, Deprecated, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsAsset">();
	}
	static class UPhysicsAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsAsset>();
	}
};
static_assert(alignof(UPhysicsAsset) == 0x000008, "Wrong alignment on UPhysicsAsset");
static_assert(sizeof(UPhysicsAsset) == 0x000128, "Wrong size on UPhysicsAsset");
static_assert(offsetof(UPhysicsAsset, BoundsBodies) == 0x000040, "Member 'UPhysicsAsset::BoundsBodies' has a wrong offset!");
static_assert(offsetof(UPhysicsAsset, SkeletalBodySetups) == 0x000050, "Member 'UPhysicsAsset::SkeletalBodySetups' has a wrong offset!");
static_assert(offsetof(UPhysicsAsset, ConstraintSetup) == 0x000060, "Member 'UPhysicsAsset::ConstraintSetup' has a wrong offset!");
static_assert(offsetof(UPhysicsAsset, BodySetup) == 0x000118, "Member 'UPhysicsAsset::BodySetup' has a wrong offset!");

// Class Engine.SkeletalBodySetup
// 0x0000 (0x11389E60 - 0x11389E60)
class USkeletalBodySetup final : public UBodySetup
{
public:
	TArray<struct FPhysicalAnimationProfile>      PhysicalAnimationData;                             // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalBodySetup">();
	}
	static class USkeletalBodySetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkeletalBodySetup>();
	}
};
static_assert(alignof(USkeletalBodySetup) == 0x11389E60, "Wrong alignment on USkeletalBodySetup");
static_assert(sizeof(USkeletalBodySetup) == 0x11389E60, "Wrong size on USkeletalBodySetup");
static_assert(offsetof(USkeletalBodySetup, PhysicalAnimationData) == 0x0003B8, "Member 'USkeletalBodySetup::PhysicalAnimationData' has a wrong offset!");

// Class Engine.PhysicsConstraintActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APhysicsConstraintActor final : public ARigidBodyBase
{
public:
	class UPhysicsConstraintComponent*            ConstraintComp;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 ConstraintActor1;                                  // 0x03E8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ConstraintActor2;                                  // 0x03F0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableCollision : 1;                             // 0x03F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsConstraintActor">();
	}
	static class APhysicsConstraintActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsConstraintActor>();
	}
};
static_assert(alignof(APhysicsConstraintActor) == 0x1EF72E00, "Wrong alignment on APhysicsConstraintActor");
static_assert(sizeof(APhysicsConstraintActor) == 0x1EF72E00, "Wrong size on APhysicsConstraintActor");
static_assert(offsetof(APhysicsConstraintActor, ConstraintComp) == 0x0003E0, "Member 'APhysicsConstraintActor::ConstraintComp' has a wrong offset!");
static_assert(offsetof(APhysicsConstraintActor, ConstraintActor1) == 0x0003E8, "Member 'APhysicsConstraintActor::ConstraintActor1' has a wrong offset!");
static_assert(offsetof(APhysicsConstraintActor, ConstraintActor2) == 0x0003F0, "Member 'APhysicsConstraintActor::ConstraintActor2' has a wrong offset!");

// Class Engine.PhysicsConstraintComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UPhysicsConstraintComponent final : public USceneComponent
{
public:
	class AActor*                                 ConstraintActor1;                                  // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstrainComponentPropName            ComponentName1;                                    // 0x0420(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ConstraintActor2;                                  // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConstrainComponentPropName            ComponentName2;                                    // 0x0430(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsConstraintTemplate*             ConstraintSetup;                                   // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnConstraintBroken;                                // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FConstraintInstance                    ConstraintInstance;                                // 0x0460(0x112E9AF0)(Edit, NativeAccessSpecifierPublic)

public:
	void BreakConstraint();
	void GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce);
	bool IsBroken();
	void SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold);
	void SetAngularDriveMode(EAngularDriveMode DriveMode);
	void SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
	void SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
	void SetAngularOrientationTarget(const struct FRotator& InPosTarget);
	void SetAngularSwing1Limit(EAngularConstraintMotion MotionType, float Swing1LimitAngle);
	void SetAngularSwing2Limit(EAngularConstraintMotion MotionType, float Swing2LimitAngle);
	void SetAngularTwistLimit(EAngularConstraintMotion ConstraintType, float TwistLimitAngle);
	void SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
	void SetAngularVelocityDriveSLERP(bool bEnableSLERP);
	void SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
	void SetAngularVelocityTarget(const struct FVector& InVelTarget);
	void SetConstrainedComponents(class UPrimitiveComponent* Component1, class FName BoneName1, class UPrimitiveComponent* Component2, class FName BoneName2);
	void SetConstraintReferenceFrame(EConstraintFrame Frame, const struct FTransform& RefFrame);
	void SetConstraintReferenceOrientation(EConstraintFrame Frame, const struct FVector& PriAxis, const struct FVector& SecAxis);
	void SetConstraintReferencePosition(EConstraintFrame Frame, const struct FVector& RefPosition);
	void SetDisableCollision(bool bDisableCollision);
	void SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold);
	void SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
	void SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
	void SetLinearPositionTarget(const struct FVector& InPosTarget);
	void SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
	void SetLinearVelocityTarget(const struct FVector& InVelTarget);
	void SetLinearXLimit(ELinearConstraintMotion ConstraintType, float LimitSize);
	void SetLinearYLimit(ELinearConstraintMotion ConstraintType, float LimitSize);
	void SetLinearZLimit(ELinearConstraintMotion ConstraintType, float LimitSize);
	void SetOrientationDriveSLERP(bool bEnableSLERP);
	void SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);

	float GetCurrentSwing1() const;
	float GetCurrentSwing2() const;
	float GetCurrentTwist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsConstraintComponent">();
	}
	static class UPhysicsConstraintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsConstraintComponent>();
	}
};
static_assert(alignof(UPhysicsConstraintComponent) == 0x112E9AF0, "Wrong alignment on UPhysicsConstraintComponent");
static_assert(sizeof(UPhysicsConstraintComponent) == 0x112E9AF0, "Wrong size on UPhysicsConstraintComponent");
static_assert(offsetof(UPhysicsConstraintComponent, ConstraintActor1) == 0x000418, "Member 'UPhysicsConstraintComponent::ConstraintActor1' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintComponent, ComponentName1) == 0x000420, "Member 'UPhysicsConstraintComponent::ComponentName1' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintComponent, ConstraintActor2) == 0x000428, "Member 'UPhysicsConstraintComponent::ConstraintActor2' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintComponent, ComponentName2) == 0x000430, "Member 'UPhysicsConstraintComponent::ComponentName2' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintComponent, ConstraintSetup) == 0x000448, "Member 'UPhysicsConstraintComponent::ConstraintSetup' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintComponent, OnConstraintBroken) == 0x000450, "Member 'UPhysicsConstraintComponent::OnConstraintBroken' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintComponent, ConstraintInstance) == 0x000460, "Member 'UPhysicsConstraintComponent::ConstraintInstance' has a wrong offset!");

// Class Engine.PhysicsConstraintTemplate
// 0x0310 (0x0350 - 0x0040)
class UPhysicsConstraintTemplate final : public UObject
{
public:
	struct FConstraintInstance                    DefaultInstance;                                   // 0x0040(0x112E9AF0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsConstraintProfileHandle> ProfileHandles;                                    // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FConstraintProfileProperties           DefaultProfile;                                    // 0x0240(0x12842)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsConstraintTemplate">();
	}
	static class UPhysicsConstraintTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsConstraintTemplate>();
	}
};
static_assert(alignof(UPhysicsConstraintTemplate) == 0x000008, "Wrong alignment on UPhysicsConstraintTemplate");
static_assert(sizeof(UPhysicsConstraintTemplate) == 0x000350, "Wrong size on UPhysicsConstraintTemplate");
static_assert(offsetof(UPhysicsConstraintTemplate, DefaultInstance) == 0x000040, "Member 'UPhysicsConstraintTemplate::DefaultInstance' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintTemplate, ProfileHandles) == 0x000230, "Member 'UPhysicsConstraintTemplate::ProfileHandles' has a wrong offset!");
static_assert(offsetof(UPhysicsConstraintTemplate, DefaultProfile) == 0x000240, "Member 'UPhysicsConstraintTemplate::DefaultProfile' has a wrong offset!");

// Class Engine.PhysicsHandleComponent
// 0x0000 (0xD38D - 0xD38D)
class UPhysicsHandleComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    GrabbedComponent;                                  // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0xC];                                      // 0x0208(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_214_0 : 1;                                  // 0x0214(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSoftAngularConstraint : 1;                        // 0x0214(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSoftLinearConstraint : 1;                         // 0x0214(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterpolateTarget : 1;                            // 0x0214(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearDamping;                                     // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearStiffness;                                   // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularStiffness;                                  // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x68];                                     // 0x0228(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationSpeed;                                // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x1C];                                     // 0x0294(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GrabComponent(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation);
	void GrabComponentAtLocation(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& GrabLocation);
	void GrabComponentAtLocationWithRotation(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& Location, const struct FRotator& Rotation);
	void ReleaseComponent();
	void SetAngularDamping(float NewAngularDamping);
	void SetAngularStiffness(float NewAngularStiffness);
	void SetInterpolationSpeed(float NewInterpolationSpeed);
	void SetLinearDamping(float NewLinearDamping);
	void SetLinearStiffness(float NewLinearStiffness);
	void SetTargetLocation(const struct FVector& NewLocation);
	void SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void SetTargetRotation(const struct FRotator& NewRotation);

	class UPrimitiveComponent* GetGrabbedComponent() const;
	void GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsHandleComponent">();
	}
	static class UPhysicsHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsHandleComponent>();
	}
};
static_assert(alignof(UPhysicsHandleComponent) == 0x00D38D, "Wrong alignment on UPhysicsHandleComponent");
static_assert(sizeof(UPhysicsHandleComponent) == 0x00D38D, "Wrong size on UPhysicsHandleComponent");
static_assert(offsetof(UPhysicsHandleComponent, GrabbedComponent) == 0x000200, "Member 'UPhysicsHandleComponent::GrabbedComponent' has a wrong offset!");
static_assert(offsetof(UPhysicsHandleComponent, LinearDamping) == 0x000218, "Member 'UPhysicsHandleComponent::LinearDamping' has a wrong offset!");
static_assert(offsetof(UPhysicsHandleComponent, LinearStiffness) == 0x00021C, "Member 'UPhysicsHandleComponent::LinearStiffness' has a wrong offset!");
static_assert(offsetof(UPhysicsHandleComponent, AngularDamping) == 0x000220, "Member 'UPhysicsHandleComponent::AngularDamping' has a wrong offset!");
static_assert(offsetof(UPhysicsHandleComponent, AngularStiffness) == 0x000224, "Member 'UPhysicsHandleComponent::AngularStiffness' has a wrong offset!");
static_assert(offsetof(UPhysicsHandleComponent, InterpolationSpeed) == 0x000290, "Member 'UPhysicsHandleComponent::InterpolationSpeed' has a wrong offset!");

// Class Engine.SoundNodeModulatorContinuous
// 0x0040 (0x0090 - 0x0050)
class USoundNodeModulatorContinuous final : public USoundNode
{
public:
	struct FModulatorContinuousParams             PitchModulationParams;                             // 0x0050(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FModulatorContinuousParams             VolumeModulationParams;                            // 0x0070(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeModulatorContinuous">();
	}
	static class USoundNodeModulatorContinuous* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeModulatorContinuous>();
	}
};
static_assert(alignof(USoundNodeModulatorContinuous) == 0x000008, "Wrong alignment on USoundNodeModulatorContinuous");
static_assert(sizeof(USoundNodeModulatorContinuous) == 0x000090, "Wrong size on USoundNodeModulatorContinuous");
static_assert(offsetof(USoundNodeModulatorContinuous, PitchModulationParams) == 0x000050, "Member 'USoundNodeModulatorContinuous::PitchModulationParams' has a wrong offset!");
static_assert(offsetof(USoundNodeModulatorContinuous, VolumeModulationParams) == 0x000070, "Member 'USoundNodeModulatorContinuous::VolumeModulationParams' has a wrong offset!");

// Class Engine.PhysicsSerializer
// 0x00A8 (0x00E8 - 0x0040)
class UPhysicsSerializer final : public UObject
{
public:
	uint8                                         Pad_40[0xA8];                                      // 0x0040(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsSerializer">();
	}
	static class UPhysicsSerializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsSerializer>();
	}
};
static_assert(alignof(UPhysicsSerializer) == 0x000008, "Wrong alignment on UPhysicsSerializer");
static_assert(sizeof(UPhysicsSerializer) == 0x0000E8, "Wrong size on UPhysicsSerializer");

// Class Engine.PhysicsSettings
// 0x0078 (0x00C8 - 0x0050)
class UPhysicsSettings final : public UDeveloperSettings
{
public:
	float                                         DefaultGravityZ;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultTerminalVelocity;                           // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFluidFriction;                              // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimulateScratchMemorySize;                         // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RagdollAggregateThreshold;                         // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriangleMeshTriangleMinAreaThreshold;              // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAsyncScene;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableShapeSharing;                               // 0x0069(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePCM;                                        // 0x006A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStabilization;                              // 0x006B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnMissingLocks;                                 // 0x006C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable2DPhysics;                                  // 0x006D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingsLockedAxis                           LockedAxis;                                        // 0x006E(0x0001)(ZeroConstructor, Config, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESettingsDOF                                  DefaultDegreesOfFreedom;                           // 0x006F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceThresholdVelocity;                           // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFrictionCombineMode                          FrictionCombineMode;                               // 0x0074(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFrictionCombineMode                          RestitutionCombineMode;                            // 0x0075(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngularVelocity;                                // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDepenetrationVelocity;                          // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactOffsetMultiplier;                           // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinContactOffset;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxContactOffset;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateSkeletalMeshOnDedicatedServer;            // 0x008C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           DefaultShapeComplexity;                            // 0x008D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultHasComplexCollision;                       // 0x008E(0x0001)(ZeroConstructor, Config, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressFaceRemapTable;                           // 0x008F(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportUVFromHitResults;                          // 0x0090(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableActiveActors;                              // 0x0091(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCCD;                                       // 0x0092(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEnhancedDeterminism;                        // 0x0093(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPhysicsDeltaTime;                               // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubstepping;                                      // 0x0098(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubsteppingAsync;                                 // 0x0099(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSubstepDeltaTime;                               // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSubsteps;                                       // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncSceneSmoothingFactor;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncSceneSmoothingFactor;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAverageFrameRate;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysXTreeRebuildRate;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPhysicalSurfaceName>           PhysicalSurfaces;                                  // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsSettings">();
	}
	static class UPhysicsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsSettings>();
	}
};
static_assert(alignof(UPhysicsSettings) == 0x000008, "Wrong alignment on UPhysicsSettings");
static_assert(sizeof(UPhysicsSettings) == 0x0000C8, "Wrong size on UPhysicsSettings");
static_assert(offsetof(UPhysicsSettings, DefaultGravityZ) == 0x000050, "Member 'UPhysicsSettings::DefaultGravityZ' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, DefaultTerminalVelocity) == 0x000054, "Member 'UPhysicsSettings::DefaultTerminalVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, DefaultFluidFriction) == 0x000058, "Member 'UPhysicsSettings::DefaultFluidFriction' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, SimulateScratchMemorySize) == 0x00005C, "Member 'UPhysicsSettings::SimulateScratchMemorySize' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, RagdollAggregateThreshold) == 0x000060, "Member 'UPhysicsSettings::RagdollAggregateThreshold' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, TriangleMeshTriangleMinAreaThreshold) == 0x000064, "Member 'UPhysicsSettings::TriangleMeshTriangleMinAreaThreshold' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bEnableAsyncScene) == 0x000068, "Member 'UPhysicsSettings::bEnableAsyncScene' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bEnableShapeSharing) == 0x000069, "Member 'UPhysicsSettings::bEnableShapeSharing' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bEnablePCM) == 0x00006A, "Member 'UPhysicsSettings::bEnablePCM' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bEnableStabilization) == 0x00006B, "Member 'UPhysicsSettings::bEnableStabilization' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bWarnMissingLocks) == 0x00006C, "Member 'UPhysicsSettings::bWarnMissingLocks' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bEnable2DPhysics) == 0x00006D, "Member 'UPhysicsSettings::bEnable2DPhysics' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, LockedAxis) == 0x00006E, "Member 'UPhysicsSettings::LockedAxis' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, DefaultDegreesOfFreedom) == 0x00006F, "Member 'UPhysicsSettings::DefaultDegreesOfFreedom' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, BounceThresholdVelocity) == 0x000070, "Member 'UPhysicsSettings::BounceThresholdVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, FrictionCombineMode) == 0x000074, "Member 'UPhysicsSettings::FrictionCombineMode' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, RestitutionCombineMode) == 0x000075, "Member 'UPhysicsSettings::RestitutionCombineMode' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MaxAngularVelocity) == 0x000078, "Member 'UPhysicsSettings::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MaxDepenetrationVelocity) == 0x00007C, "Member 'UPhysicsSettings::MaxDepenetrationVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, ContactOffsetMultiplier) == 0x000080, "Member 'UPhysicsSettings::ContactOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MinContactOffset) == 0x000084, "Member 'UPhysicsSettings::MinContactOffset' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MaxContactOffset) == 0x000088, "Member 'UPhysicsSettings::MaxContactOffset' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bSimulateSkeletalMeshOnDedicatedServer) == 0x00008C, "Member 'UPhysicsSettings::bSimulateSkeletalMeshOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, DefaultShapeComplexity) == 0x00008D, "Member 'UPhysicsSettings::DefaultShapeComplexity' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bDefaultHasComplexCollision) == 0x00008E, "Member 'UPhysicsSettings::bDefaultHasComplexCollision' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bSuppressFaceRemapTable) == 0x00008F, "Member 'UPhysicsSettings::bSuppressFaceRemapTable' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bSupportUVFromHitResults) == 0x000090, "Member 'UPhysicsSettings::bSupportUVFromHitResults' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bDisableActiveActors) == 0x000091, "Member 'UPhysicsSettings::bDisableActiveActors' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bDisableCCD) == 0x000092, "Member 'UPhysicsSettings::bDisableCCD' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bEnableEnhancedDeterminism) == 0x000093, "Member 'UPhysicsSettings::bEnableEnhancedDeterminism' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MaxPhysicsDeltaTime) == 0x000094, "Member 'UPhysicsSettings::MaxPhysicsDeltaTime' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bSubstepping) == 0x000098, "Member 'UPhysicsSettings::bSubstepping' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, bSubsteppingAsync) == 0x000099, "Member 'UPhysicsSettings::bSubsteppingAsync' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MaxSubstepDeltaTime) == 0x00009C, "Member 'UPhysicsSettings::MaxSubstepDeltaTime' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, MaxSubsteps) == 0x0000A0, "Member 'UPhysicsSettings::MaxSubsteps' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, SyncSceneSmoothingFactor) == 0x0000A4, "Member 'UPhysicsSettings::SyncSceneSmoothingFactor' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, AsyncSceneSmoothingFactor) == 0x0000A8, "Member 'UPhysicsSettings::AsyncSceneSmoothingFactor' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, InitialAverageFrameRate) == 0x0000AC, "Member 'UPhysicsSettings::InitialAverageFrameRate' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, PhysXTreeRebuildRate) == 0x0000B0, "Member 'UPhysicsSettings::PhysXTreeRebuildRate' has a wrong offset!");
static_assert(offsetof(UPhysicsSettings, PhysicalSurfaces) == 0x0000B8, "Member 'UPhysicsSettings::PhysicalSurfaces' has a wrong offset!");

// Class Engine.PhysicsThruster
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APhysicsThruster final : public ARigidBodyBase
{
public:
	class UPhysicsThrusterComponent*              ThrusterComponent;                                 // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsThruster">();
	}
	static class APhysicsThruster* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsThruster>();
	}
};
static_assert(alignof(APhysicsThruster) == 0x1EF72E00, "Wrong alignment on APhysicsThruster");
static_assert(sizeof(APhysicsThruster) == 0x1EF72E00, "Wrong size on APhysicsThruster");
static_assert(offsetof(APhysicsThruster, ThrusterComponent) == 0x0003E0, "Member 'APhysicsThruster::ThrusterComponent' has a wrong offset!");

// Class Engine.SoundNodeRandom
// 0x0030 (0x0080 - 0x0050)
class USoundNodeRandom final : public USoundNode
{
public:
	TArray<float>                                 Weights;                                           // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PreselectAtLevelLoad;                              // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRandomizeWithoutReplacement : 1;                  // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  HasBeenUsed;                                       // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         NumRandomUsed;                                     // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeRandom">();
	}
	static class USoundNodeRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeRandom>();
	}
};
static_assert(alignof(USoundNodeRandom) == 0x000008, "Wrong alignment on USoundNodeRandom");
static_assert(sizeof(USoundNodeRandom) == 0x000080, "Wrong size on USoundNodeRandom");
static_assert(offsetof(USoundNodeRandom, Weights) == 0x000050, "Member 'USoundNodeRandom::Weights' has a wrong offset!");
static_assert(offsetof(USoundNodeRandom, PreselectAtLevelLoad) == 0x000060, "Member 'USoundNodeRandom::PreselectAtLevelLoad' has a wrong offset!");
static_assert(offsetof(USoundNodeRandom, HasBeenUsed) == 0x000068, "Member 'USoundNodeRandom::HasBeenUsed' has a wrong offset!");
static_assert(offsetof(USoundNodeRandom, NumRandomUsed) == 0x000078, "Member 'USoundNodeRandom::NumRandomUsed' has a wrong offset!");

// Class Engine.PhysicsThrusterComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UPhysicsThrusterComponent final : public USceneComponent
{
public:
	float                                         ThrustStrength;                                    // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsThrusterComponent">();
	}
	static class UPhysicsThrusterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsThrusterComponent>();
	}
};
static_assert(alignof(UPhysicsThrusterComponent) == 0x112E9AF0, "Wrong alignment on UPhysicsThrusterComponent");
static_assert(sizeof(UPhysicsThrusterComponent) == 0x112E9AF0, "Wrong size on UPhysicsThrusterComponent");
static_assert(offsetof(UPhysicsThrusterComponent, ThrustStrength) == 0x000418, "Member 'UPhysicsThrusterComponent::ThrustStrength' has a wrong offset!");

// Class Engine.PlanarReflection
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APlanarReflection final : public ASceneCapture
{
public:
	class UPlanarReflectionComponent*             PlanarReflectionComponent;                         // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowPreviewPlane;                                 // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInterpToggle(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanarReflection">();
	}
	static class APlanarReflection* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlanarReflection>();
	}
};
static_assert(alignof(APlanarReflection) == 0x1EF72E00, "Wrong alignment on APlanarReflection");
static_assert(sizeof(APlanarReflection) == 0x1EF72E00, "Wrong size on APlanarReflection");
static_assert(offsetof(APlanarReflection, PlanarReflectionComponent) == 0x0003E8, "Member 'APlanarReflection::PlanarReflectionComponent' has a wrong offset!");
static_assert(offsetof(APlanarReflection, bShowPreviewPlane) == 0x0003F0, "Member 'APlanarReflection::bShowPreviewPlane' has a wrong offset!");

// Class Engine.PlanarReflectionComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UPlanarReflectionComponent final : public USceneCaptureComponent
{
public:
	class UBoxComponent*                          PreviewBox;                                        // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalDistortionStrength;                          // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrefilterRoughness;                                // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrefilterRoughnessDistance;                        // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenPercentage;                                  // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraFOV;                                          // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromPlaneFadeStart;                        // 0x04D4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromPlaneFadeEnd;                          // 0x04D8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromPlaneFadeoutStart;                     // 0x04DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromPlaneFadeoutEnd;                       // 0x04E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleFromPlaneFadeStart;                           // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleFromPlaneFadeEnd;                             // 0x04E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderSceneTwoSided;                              // 0x04EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4ED[0xD3];                                     // 0x04ED(0x00D3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanarReflectionComponent">();
	}
	static class UPlanarReflectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanarReflectionComponent>();
	}
};
static_assert(alignof(UPlanarReflectionComponent) == 0x112E9AF0, "Wrong alignment on UPlanarReflectionComponent");
static_assert(sizeof(UPlanarReflectionComponent) == 0x112E9AF0, "Wrong size on UPlanarReflectionComponent");
static_assert(offsetof(UPlanarReflectionComponent, PreviewBox) == 0x0004B8, "Member 'UPlanarReflectionComponent::PreviewBox' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, NormalDistortionStrength) == 0x0004C0, "Member 'UPlanarReflectionComponent::NormalDistortionStrength' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, PrefilterRoughness) == 0x0004C4, "Member 'UPlanarReflectionComponent::PrefilterRoughness' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, PrefilterRoughnessDistance) == 0x0004C8, "Member 'UPlanarReflectionComponent::PrefilterRoughnessDistance' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, ScreenPercentage) == 0x0004CC, "Member 'UPlanarReflectionComponent::ScreenPercentage' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, ExtraFOV) == 0x0004D0, "Member 'UPlanarReflectionComponent::ExtraFOV' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, DistanceFromPlaneFadeStart) == 0x0004D4, "Member 'UPlanarReflectionComponent::DistanceFromPlaneFadeStart' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, DistanceFromPlaneFadeEnd) == 0x0004D8, "Member 'UPlanarReflectionComponent::DistanceFromPlaneFadeEnd' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, DistanceFromPlaneFadeoutStart) == 0x0004DC, "Member 'UPlanarReflectionComponent::DistanceFromPlaneFadeoutStart' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, DistanceFromPlaneFadeoutEnd) == 0x0004E0, "Member 'UPlanarReflectionComponent::DistanceFromPlaneFadeoutEnd' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, AngleFromPlaneFadeStart) == 0x0004E4, "Member 'UPlanarReflectionComponent::AngleFromPlaneFadeStart' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, AngleFromPlaneFadeEnd) == 0x0004E8, "Member 'UPlanarReflectionComponent::AngleFromPlaneFadeEnd' has a wrong offset!");
static_assert(offsetof(UPlanarReflectionComponent, bRenderSceneTwoSided) == 0x0004EC, "Member 'UPlanarReflectionComponent::bRenderSceneTwoSided' has a wrong offset!");

// Class Engine.SoundNodeWavePlayer
// 0x0030 (0x0080 - 0x0050)
class USoundNodeWavePlayer final : public USoundNodeAssetReferencer
{
public:
	TSoftObjectPtr<class USoundWave>              SoundWaveAssetPtr;                                 // 0x0050(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundWave*                             SoundWave;                                         // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         BitPad_78_0 : 1;                                   // 0x0078(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bLooping : 1;                                      // 0x0078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeWavePlayer">();
	}
	static class USoundNodeWavePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeWavePlayer>();
	}
};
static_assert(alignof(USoundNodeWavePlayer) == 0x000008, "Wrong alignment on USoundNodeWavePlayer");
static_assert(sizeof(USoundNodeWavePlayer) == 0x000080, "Wrong size on USoundNodeWavePlayer");
static_assert(offsetof(USoundNodeWavePlayer, SoundWaveAssetPtr) == 0x000050, "Member 'USoundNodeWavePlayer::SoundWaveAssetPtr' has a wrong offset!");
static_assert(offsetof(USoundNodeWavePlayer, SoundWave) == 0x000070, "Member 'USoundNodeWavePlayer::SoundWave' has a wrong offset!");

// Class Engine.PlaneReflectionCapture
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APlaneReflectionCapture final : public AReflectionCapture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneReflectionCapture">();
	}
	static class APlaneReflectionCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlaneReflectionCapture>();
	}
};
static_assert(alignof(APlaneReflectionCapture) == 0x1EF72E00, "Wrong alignment on APlaneReflectionCapture");
static_assert(sizeof(APlaneReflectionCapture) == 0x1EF72E00, "Wrong size on APlaneReflectionCapture");

// Class Engine.PlaneReflectionCaptureComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UPlaneReflectionCaptureComponent final : public UReflectionCaptureComponent
{
public:
	float                                         InfluenceRadiusScale;                              // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDrawSphereComponent*                   PreviewInfluenceRadius;                            // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PreviewCaptureBox;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneReflectionCaptureComponent">();
	}
	static class UPlaneReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneReflectionCaptureComponent>();
	}
};
static_assert(alignof(UPlaneReflectionCaptureComponent) == 0x112E9AF0, "Wrong alignment on UPlaneReflectionCaptureComponent");
static_assert(sizeof(UPlaneReflectionCaptureComponent) == 0x112E9AF0, "Wrong size on UPlaneReflectionCaptureComponent");
static_assert(offsetof(UPlaneReflectionCaptureComponent, InfluenceRadiusScale) == 0x000488, "Member 'UPlaneReflectionCaptureComponent::InfluenceRadiusScale' has a wrong offset!");
static_assert(offsetof(UPlaneReflectionCaptureComponent, PreviewInfluenceRadius) == 0x000490, "Member 'UPlaneReflectionCaptureComponent::PreviewInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UPlaneReflectionCaptureComponent, PreviewCaptureBox) == 0x000498, "Member 'UPlaneReflectionCaptureComponent::PreviewCaptureBox' has a wrong offset!");

// Class Engine.PluginCommandlet
// 0x0020 (0x00B8 - 0x0098)
class UPluginCommandlet final : public UCommandlet
{
public:
	uint8                                         Pad_98[0x20];                                      // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PluginCommandlet">();
	}
	static class UPluginCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPluginCommandlet>();
	}
};
static_assert(alignof(UPluginCommandlet) == 0x000008, "Wrong alignment on UPluginCommandlet");
static_assert(sizeof(UPluginCommandlet) == 0x0000B8, "Wrong size on UPluginCommandlet");

// Class Engine.PoseableMeshComponent
// 0x0000 (0x112EB690 - 0x112EB690)
class UPoseableMeshComponent final : public USkinnedMeshComponent
{
public:
	void CopyPoseFromSkeletalComponent(const class USkeletalMeshComponent* InComponentToCopy);
	struct FVector GetBoneLocationByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FRotator GetBoneRotationByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FVector GetBoneScaleByName(class FName BoneName, EBoneSpaces BoneSpace);
	struct FTransform GetBoneTransformByName(class FName BoneName, EBoneSpaces BoneSpace);
	void ResetBoneTransformByName(class FName BoneName);
	void SetBoneLocationByName(class FName BoneName, const struct FVector& InLocation, EBoneSpaces BoneSpace);
	void SetBoneRotationByName(class FName BoneName, const struct FRotator& InRotation, EBoneSpaces BoneSpace);
	void SetBoneScaleByName(class FName BoneName, const struct FVector& InScale3D, EBoneSpaces BoneSpace);
	void SetBoneTransformByName(class FName BoneName, const struct FTransform& InTransform, EBoneSpaces BoneSpace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseableMeshComponent">();
	}
	static class UPoseableMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoseableMeshComponent>();
	}
};
static_assert(alignof(UPoseableMeshComponent) == 0x112EB690, "Wrong alignment on UPoseableMeshComponent");
static_assert(sizeof(UPoseableMeshComponent) == 0x112EB690, "Wrong size on UPoseableMeshComponent");

// Class Engine.PrecomputedVisibilityOverrideVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class APrecomputedVisibilityOverrideVolume final : public AVolume
{
public:
	TArray<class AActor*>                         OverrideVisibleActors;                             // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OverrideInvisibleActors;                           // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           OverrideInvisibleLevels;                           // 0x0440(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrecomputedVisibilityOverrideVolume">();
	}
	static class APrecomputedVisibilityOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrecomputedVisibilityOverrideVolume>();
	}
};
static_assert(alignof(APrecomputedVisibilityOverrideVolume) == 0x1EF72E00, "Wrong alignment on APrecomputedVisibilityOverrideVolume");
static_assert(sizeof(APrecomputedVisibilityOverrideVolume) == 0x1EF72E00, "Wrong size on APrecomputedVisibilityOverrideVolume");
static_assert(offsetof(APrecomputedVisibilityOverrideVolume, OverrideVisibleActors) == 0x000420, "Member 'APrecomputedVisibilityOverrideVolume::OverrideVisibleActors' has a wrong offset!");
static_assert(offsetof(APrecomputedVisibilityOverrideVolume, OverrideInvisibleActors) == 0x000430, "Member 'APrecomputedVisibilityOverrideVolume::OverrideInvisibleActors' has a wrong offset!");
static_assert(offsetof(APrecomputedVisibilityOverrideVolume, OverrideInvisibleLevels) == 0x000440, "Member 'APrecomputedVisibilityOverrideVolume::OverrideInvisibleLevels' has a wrong offset!");

// Class Engine.PrimaryAssetLabel
// 0x0038 (0x0080 - 0x0048)
class UPrimaryAssetLabel final : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetRules                     Rules;                                             // 0x0048(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bLabelAssetsInMyDirectory : 1;                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRuntimeLabel : 1;                               // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UObject>>         ExplicitAssets;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ExplicitBlueprints;                                // 0x0070(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryAssetLabel">();
	}
	static class UPrimaryAssetLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrimaryAssetLabel>();
	}
};
static_assert(alignof(UPrimaryAssetLabel) == 0x000008, "Wrong alignment on UPrimaryAssetLabel");
static_assert(sizeof(UPrimaryAssetLabel) == 0x000080, "Wrong size on UPrimaryAssetLabel");
static_assert(offsetof(UPrimaryAssetLabel, Rules) == 0x000048, "Member 'UPrimaryAssetLabel::Rules' has a wrong offset!");
static_assert(offsetof(UPrimaryAssetLabel, ExplicitAssets) == 0x000060, "Member 'UPrimaryAssetLabel::ExplicitAssets' has a wrong offset!");
static_assert(offsetof(UPrimaryAssetLabel, ExplicitBlueprints) == 0x000070, "Member 'UPrimaryAssetLabel::ExplicitBlueprints' has a wrong offset!");

// Class Engine.RecastNavMesh
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ARecastNavMesh final : public ANavigationData
{
public:
	uint8                                         bDrawTriangleEdges : 1;                            // 0x0580(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPolyEdges : 1;                                // 0x0580(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFilledPolys : 1;                              // 0x0580(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawNavMeshEdges : 1;                             // 0x0580(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawTileBounds : 1;                               // 0x0580(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPathCollidingGeometry : 1;                    // 0x0580(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawTileLabels : 1;                               // 0x0580(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPolygonLabels : 1;                            // 0x0580(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDefaultPolygonCost : 1;                       // 0x0581(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawLabelsOnPathNodes : 1;                        // 0x0581(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawNavLinks : 1;                                 // 0x0581(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFailedNavLinks : 1;                           // 0x0581(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawClusters : 1;                                 // 0x0581(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawOctree : 1;                                   // 0x0581(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDistinctlyDrawTilesBeingBuilt : 1;                // 0x0581(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawNavMesh : 1;                                  // 0x0581(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_582[0x2];                                      // 0x0582(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawOffset;                                        // 0x0584(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFixedTilePoolSize : 1;                            // 0x0588(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TilePoolSize;                                      // 0x058C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileSizeUU;                                        // 0x0590(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CellSize;                                          // 0x0594(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CellHeight;                                        // 0x0598(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentRadius;                                       // 0x059C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentHeight;                                       // 0x05A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentMaxHeight;                                    // 0x05A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentMaxSlope;                                     // 0x05A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentMaxStepHeight;                                // 0x05AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRegionArea;                                     // 0x05B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MergeRegionSize;                                   // 0x05B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimplificationError;                            // 0x05B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimultaneousTileGenerationJobsCount;            // 0x05BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileNumberHardLimit;                               // 0x05C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolyRefTileBits;                                   // 0x05C4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolyRefNavPolyBits;                                // 0x05C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolyRefSaltBits;                                   // 0x05CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDrawDistance;                               // 0x05D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxSearchNodes;                             // 0x05D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxHierarchicalSearchNodes;                 // 0x05D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecastPartitioning                           RegionPartitioning;                                // 0x05DC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecastPartitioning                           LayerPartitioning;                                 // 0x05DD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DE[0x2];                                      // 0x05DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RegionChunkSplits;                                 // 0x05E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerChunkSplits;                                  // 0x05E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSortNavigationAreasByCost : 1;                    // 0x05E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPerformVoxelFiltering : 1;                        // 0x05E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMarkLowHeightAreas : 1;                           // 0x05E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoFullyAsyncNavDataGathering : 1;                 // 0x05E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Config, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseBetterOffsetsFromCorners : 1;                  // 0x05E8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStoreEmptyTileLayers : 1;                         // 0x05E8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseVirtualFilters : 1;                            // 0x05E8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowNavLinkAsPathEnd : 1;                        // 0x05E8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseVoxelCache : 1;                                // 0x05E9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_5EA[0x2];                                      // 0x05EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TileSetUpdateInterval;                             // 0x05EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeuristicScale;                                    // 0x05F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalDeviationFromGroundCompensation;           // 0x05F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x98];                                     // 0x05F8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecastNavMesh">();
	}
	static class ARecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARecastNavMesh>();
	}
};
static_assert(alignof(ARecastNavMesh) == 0x1EF72E00, "Wrong alignment on ARecastNavMesh");
static_assert(sizeof(ARecastNavMesh) == 0x1EF72E00, "Wrong size on ARecastNavMesh");
static_assert(offsetof(ARecastNavMesh, DrawOffset) == 0x000584, "Member 'ARecastNavMesh::DrawOffset' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, TilePoolSize) == 0x00058C, "Member 'ARecastNavMesh::TilePoolSize' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, TileSizeUU) == 0x000590, "Member 'ARecastNavMesh::TileSizeUU' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, CellSize) == 0x000594, "Member 'ARecastNavMesh::CellSize' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, CellHeight) == 0x000598, "Member 'ARecastNavMesh::CellHeight' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, AgentRadius) == 0x00059C, "Member 'ARecastNavMesh::AgentRadius' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, AgentHeight) == 0x0005A0, "Member 'ARecastNavMesh::AgentHeight' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, AgentMaxHeight) == 0x0005A4, "Member 'ARecastNavMesh::AgentMaxHeight' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, AgentMaxSlope) == 0x0005A8, "Member 'ARecastNavMesh::AgentMaxSlope' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, AgentMaxStepHeight) == 0x0005AC, "Member 'ARecastNavMesh::AgentMaxStepHeight' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, MinRegionArea) == 0x0005B0, "Member 'ARecastNavMesh::MinRegionArea' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, MergeRegionSize) == 0x0005B4, "Member 'ARecastNavMesh::MergeRegionSize' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, MaxSimplificationError) == 0x0005B8, "Member 'ARecastNavMesh::MaxSimplificationError' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, MaxSimultaneousTileGenerationJobsCount) == 0x0005BC, "Member 'ARecastNavMesh::MaxSimultaneousTileGenerationJobsCount' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, TileNumberHardLimit) == 0x0005C0, "Member 'ARecastNavMesh::TileNumberHardLimit' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, PolyRefTileBits) == 0x0005C4, "Member 'ARecastNavMesh::PolyRefTileBits' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, PolyRefNavPolyBits) == 0x0005C8, "Member 'ARecastNavMesh::PolyRefNavPolyBits' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, PolyRefSaltBits) == 0x0005CC, "Member 'ARecastNavMesh::PolyRefSaltBits' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, DefaultDrawDistance) == 0x0005D0, "Member 'ARecastNavMesh::DefaultDrawDistance' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, DefaultMaxSearchNodes) == 0x0005D4, "Member 'ARecastNavMesh::DefaultMaxSearchNodes' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, DefaultMaxHierarchicalSearchNodes) == 0x0005D8, "Member 'ARecastNavMesh::DefaultMaxHierarchicalSearchNodes' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, RegionPartitioning) == 0x0005DC, "Member 'ARecastNavMesh::RegionPartitioning' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, LayerPartitioning) == 0x0005DD, "Member 'ARecastNavMesh::LayerPartitioning' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, RegionChunkSplits) == 0x0005E0, "Member 'ARecastNavMesh::RegionChunkSplits' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, LayerChunkSplits) == 0x0005E4, "Member 'ARecastNavMesh::LayerChunkSplits' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, TileSetUpdateInterval) == 0x0005EC, "Member 'ARecastNavMesh::TileSetUpdateInterval' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, HeuristicScale) == 0x0005F0, "Member 'ARecastNavMesh::HeuristicScale' has a wrong offset!");
static_assert(offsetof(ARecastNavMesh, VerticalDeviationFromGroundCompensation) == 0x0005F4, "Member 'ARecastNavMesh::VerticalDeviationFromGroundCompensation' has a wrong offset!");

// Class Engine.Rig
// 0x0020 (0x0060 - 0x0040)
class URig final : public UObject
{
public:
	TArray<struct FTransformBase>                 TransformBases;                                    // 0x0040(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FNode>                          Nodes;                                             // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Rig">();
	}
	static class URig* GetDefaultObj()
	{
		return GetDefaultObjImpl<URig>();
	}
};
static_assert(alignof(URig) == 0x000008, "Wrong alignment on URig");
static_assert(sizeof(URig) == 0x000060, "Wrong size on URig");
static_assert(offsetof(URig, TransformBases) == 0x000040, "Member 'URig::TransformBases' has a wrong offset!");
static_assert(offsetof(URig, Nodes) == 0x000050, "Member 'URig::Nodes' has a wrong offset!");

// Class Engine.RotatingMovementComponent
// 0x112DC763 (0x112E9AF0 - 0xD38D)
class URotatingMovementComponent final : public UMovementComponent
{
public:
	struct FRotator                               RotationRate;                                      // 0x0248(0x112E9AF0)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PivotTranslation;                                  // 0x0254(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRotationInLocalSpace : 1;                         // 0x0260(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_261[0xF];                                      // 0x0261(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotatingMovementComponent">();
	}
	static class URotatingMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URotatingMovementComponent>();
	}
};
static_assert(alignof(URotatingMovementComponent) == 0x112E9AF0, "Wrong alignment on URotatingMovementComponent");
static_assert(sizeof(URotatingMovementComponent) == 0x112E9AF0, "Wrong size on URotatingMovementComponent");
static_assert(offsetof(URotatingMovementComponent, RotationRate) == 0x000248, "Member 'URotatingMovementComponent::RotationRate' has a wrong offset!");
static_assert(offsetof(URotatingMovementComponent, PivotTranslation) == 0x000254, "Member 'URotatingMovementComponent::PivotTranslation' has a wrong offset!");

// Class Engine.SceneCaptureComponentCube
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USceneCaptureComponentCube final : public USceneCaptureComponent
{
public:
	class UTextureRenderTargetCube*               TextureTarget;                                     // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CaptureScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureComponentCube">();
	}
	static class USceneCaptureComponentCube* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCaptureComponentCube>();
	}
};
static_assert(alignof(USceneCaptureComponentCube) == 0x112E9AF0, "Wrong alignment on USceneCaptureComponentCube");
static_assert(sizeof(USceneCaptureComponentCube) == 0x112E9AF0, "Wrong size on USceneCaptureComponentCube");
static_assert(offsetof(USceneCaptureComponentCube, TextureTarget) == 0x0004B8, "Member 'USceneCaptureComponentCube::TextureTarget' has a wrong offset!");

// Class Engine.ShadowMapTexture2D
// 0x0000 (0x112EA720 - 0x112EA720)
class UShadowMapTexture2D final : public UTexture2D
{
public:
	EShadowMapFlags                               ShadowmapFlags;                                    // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShadowMapTexture2D">();
	}
	static class UShadowMapTexture2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShadowMapTexture2D>();
	}
};
static_assert(alignof(UShadowMapTexture2D) == 0x112EA720, "Wrong alignment on UShadowMapTexture2D");
static_assert(sizeof(UShadowMapTexture2D) == 0x112EA720, "Wrong size on UShadowMapTexture2D");
static_assert(offsetof(UShadowMapTexture2D, ShadowmapFlags) == 0x000150, "Member 'UShadowMapTexture2D::ShadowmapFlags' has a wrong offset!");

// Class Engine.SkyLight
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASkyLight final : public AInfo
{
public:
	class USkyLightComponent*                     LightComponent;                                    // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnabled : 1;                                      // 0x03E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkyLight">();
	}
	static class ASkyLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkyLight>();
	}
};
static_assert(alignof(ASkyLight) == 0x1EF72E00, "Wrong alignment on ASkyLight");
static_assert(sizeof(ASkyLight) == 0x1EF72E00, "Wrong size on ASkyLight");
static_assert(offsetof(ASkyLight, LightComponent) == 0x0003E0, "Member 'ASkyLight::LightComponent' has a wrong offset!");

// Class Engine.SmokeTestCommandlet
// 0x0000 (0x0098 - 0x0098)
class USmokeTestCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmokeTestCommandlet">();
	}
	static class USmokeTestCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmokeTestCommandlet>();
	}
};
static_assert(alignof(USmokeTestCommandlet) == 0x000008, "Wrong alignment on USmokeTestCommandlet");
static_assert(sizeof(USmokeTestCommandlet) == 0x000098, "Wrong size on USmokeTestCommandlet");

// Class Engine.SoundEffectSubmixPreset
// 0x0000 (0x0058 - 0x0058)
class USoundEffectSubmixPreset : public USoundEffectPreset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundEffectSubmixPreset">();
	}
	static class USoundEffectSubmixPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundEffectSubmixPreset>();
	}
};
static_assert(alignof(USoundEffectSubmixPreset) == 0x000008, "Wrong alignment on USoundEffectSubmixPreset");
static_assert(sizeof(USoundEffectSubmixPreset) == 0x000058, "Wrong size on USoundEffectSubmixPreset");

// Class Engine.SoundNodeEnveloper
// 0x0128 (0x0178 - 0x0050)
class USoundNodeEnveloper final : public USoundNode
{
public:
	float                                         LoopStart;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopEnd;                                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationAfterLoop;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoopIndefinitely : 1;                             // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoop : 1;                                         // 0x0060(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDistributionFloatConstantCurve*        VolumeInterpCurve;                                 // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDistributionFloatConstantCurve*        PitchInterpCurve;                                  // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VolumeCurve;                                       // 0x0078(0x11102)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     PitchCurve;                                        // 0x00F0(0x11102)(Edit, NativeAccessSpecifierPublic)
	float                                         PitchMin;                                          // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMin;                                         // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMax;                                         // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeEnveloper">();
	}
	static class USoundNodeEnveloper* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeEnveloper>();
	}
};
static_assert(alignof(USoundNodeEnveloper) == 0x000008, "Wrong alignment on USoundNodeEnveloper");
static_assert(sizeof(USoundNodeEnveloper) == 0x000178, "Wrong size on USoundNodeEnveloper");
static_assert(offsetof(USoundNodeEnveloper, LoopStart) == 0x000050, "Member 'USoundNodeEnveloper::LoopStart' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, LoopEnd) == 0x000054, "Member 'USoundNodeEnveloper::LoopEnd' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, DurationAfterLoop) == 0x000058, "Member 'USoundNodeEnveloper::DurationAfterLoop' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, LoopCount) == 0x00005C, "Member 'USoundNodeEnveloper::LoopCount' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, VolumeInterpCurve) == 0x000068, "Member 'USoundNodeEnveloper::VolumeInterpCurve' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, PitchInterpCurve) == 0x000070, "Member 'USoundNodeEnveloper::PitchInterpCurve' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, VolumeCurve) == 0x000078, "Member 'USoundNodeEnveloper::VolumeCurve' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, PitchCurve) == 0x0000F0, "Member 'USoundNodeEnveloper::PitchCurve' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, PitchMin) == 0x000168, "Member 'USoundNodeEnveloper::PitchMin' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, PitchMax) == 0x00016C, "Member 'USoundNodeEnveloper::PitchMax' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, VolumeMin) == 0x000170, "Member 'USoundNodeEnveloper::VolumeMin' has a wrong offset!");
static_assert(offsetof(USoundNodeEnveloper, VolumeMax) == 0x000174, "Member 'USoundNodeEnveloper::VolumeMax' has a wrong offset!");

// Class Engine.SoundNodeGroupControl
// 0x0010 (0x0060 - 0x0050)
class USoundNodeGroupControl final : public USoundNode
{
public:
	TArray<int32>                                 GroupSizes;                                        // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeGroupControl">();
	}
	static class USoundNodeGroupControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeGroupControl>();
	}
};
static_assert(alignof(USoundNodeGroupControl) == 0x000008, "Wrong alignment on USoundNodeGroupControl");
static_assert(sizeof(USoundNodeGroupControl) == 0x000060, "Wrong size on USoundNodeGroupControl");
static_assert(offsetof(USoundNodeGroupControl, GroupSizes) == 0x000050, "Member 'USoundNodeGroupControl::GroupSizes' has a wrong offset!");

// Class Engine.SoundNodeMixer
// 0x0010 (0x0060 - 0x0050)
class USoundNodeMixer final : public USoundNode
{
public:
	TArray<float>                                 InputVolume;                                       // 0x0050(0x0010)(Edit, ExportObject, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeMixer">();
	}
	static class USoundNodeMixer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeMixer>();
	}
};
static_assert(alignof(USoundNodeMixer) == 0x000008, "Wrong alignment on USoundNodeMixer");
static_assert(sizeof(USoundNodeMixer) == 0x000060, "Wrong size on USoundNodeMixer");
static_assert(offsetof(USoundNodeMixer, InputVolume) == 0x000050, "Member 'USoundNodeMixer::InputVolume' has a wrong offset!");

// Class Engine.SoundNodeParamCrossFade
// 0x0008 (0x0068 - 0x0060)
class USoundNodeParamCrossFade final : public USoundNodeDistanceCrossFade
{
public:
	class FName                                   ParamName;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeParamCrossFade">();
	}
	static class USoundNodeParamCrossFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeParamCrossFade>();
	}
};
static_assert(alignof(USoundNodeParamCrossFade) == 0x000008, "Wrong alignment on USoundNodeParamCrossFade");
static_assert(sizeof(USoundNodeParamCrossFade) == 0x000068, "Wrong size on USoundNodeParamCrossFade");
static_assert(offsetof(USoundNodeParamCrossFade, ParamName) == 0x000060, "Member 'USoundNodeParamCrossFade::ParamName' has a wrong offset!");

// Class Engine.SoundNodeSoundClass
// 0x0008 (0x0058 - 0x0050)
class USoundNodeSoundClass final : public USoundNode
{
public:
	class USoundClass*                            SoundClassOverride;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeSoundClass">();
	}
	static class USoundNodeSoundClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeSoundClass>();
	}
};
static_assert(alignof(USoundNodeSoundClass) == 0x000008, "Wrong alignment on USoundNodeSoundClass");
static_assert(sizeof(USoundNodeSoundClass) == 0x000058, "Wrong size on USoundNodeSoundClass");
static_assert(offsetof(USoundNodeSoundClass, SoundClassOverride) == 0x000050, "Member 'USoundNodeSoundClass::SoundClassOverride' has a wrong offset!");

// Class Engine.SoundNodeSwitch
// 0x0008 (0x0058 - 0x0050)
class USoundNodeSwitch final : public USoundNode
{
public:
	class FName                                   IntParameterName;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeSwitch">();
	}
	static class USoundNodeSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeSwitch>();
	}
};
static_assert(alignof(USoundNodeSwitch) == 0x000008, "Wrong alignment on USoundNodeSwitch");
static_assert(sizeof(USoundNodeSwitch) == 0x000058, "Wrong size on USoundNodeSwitch");
static_assert(offsetof(USoundNodeSwitch, IntParameterName) == 0x000050, "Member 'USoundNodeSwitch::IntParameterName' has a wrong offset!");

// Class Engine.SoundNodeWaveParam
// 0x0008 (0x0058 - 0x0050)
class USoundNodeWaveParam final : public USoundNode
{
public:
	class FName                                   WaveParameterName;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeWaveParam">();
	}
	static class USoundNodeWaveParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeWaveParam>();
	}
};
static_assert(alignof(USoundNodeWaveParam) == 0x000008, "Wrong alignment on USoundNodeWaveParam");
static_assert(sizeof(USoundNodeWaveParam) == 0x000058, "Wrong size on USoundNodeWaveParam");
static_assert(offsetof(USoundNodeWaveParam, WaveParameterName) == 0x000050, "Member 'USoundNodeWaveParam::WaveParameterName' has a wrong offset!");

// Class Engine.SphereReflectionCapture
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASphereReflectionCapture final : public AReflectionCapture
{
public:
	class UDrawSphereComponent*                   DrawCaptureRadius;                                 // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereReflectionCapture">();
	}
	static class ASphereReflectionCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASphereReflectionCapture>();
	}
};
static_assert(alignof(ASphereReflectionCapture) == 0x1EF72E00, "Wrong alignment on ASphereReflectionCapture");
static_assert(sizeof(ASphereReflectionCapture) == 0x1EF72E00, "Wrong size on ASphereReflectionCapture");
static_assert(offsetof(ASphereReflectionCapture, DrawCaptureRadius) == 0x0003E8, "Member 'ASphereReflectionCapture::DrawCaptureRadius' has a wrong offset!");

// Class Engine.SplineMeshComponent
// 0x0000 (0x11635BE0 - 0x11635BE0)
class USplineMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_A20[0x8];                                      // 0x0A20(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineMeshParams                      SplineParams;                                      // 0x0A28(0x112E95F0)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SplineUpDir;                                       // 0x0A80(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowSplineEditingPerInstance : 1;                // 0x0A8C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSmoothInterpRollScale : 1;                        // 0x0A8C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A8D[0x3];                                      // 0x0A8D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESplineMeshAxis                               ForwardAxis;                                       // 0x0A90(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A91[0x3];                                      // 0x0A91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineBoundaryMin;                                 // 0x0A94(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineBoundaryMax;                                 // 0x0A98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9C[0x4];                                      // 0x0A9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0AA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  CachedMeshBodySetupGuid;                           // 0x0AA8(0x112E8D20)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMeshDirty : 1;                                    // 0x0AB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AB9[0x7];                                      // 0x0AB9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh);
	void SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh);
	void SetEndOffset(const struct FVector2D& EndOffset, bool bUpdateMesh);
	void SetEndPosition(const struct FVector& EndPos, bool bUpdateMesh);
	void SetEndRoll(float EndRoll, bool bUpdateMesh);
	void SetEndScale(const struct FVector2D& EndScale, bool bUpdateMesh);
	void SetEndTangent(const struct FVector& EndTangent, bool bUpdateMesh);
	void SetForwardAxis(ESplineMeshAxis InForwardAxis, bool bUpdateMesh);
	void SetSplineUpDir(const struct FVector& InSplineUpDir, bool bUpdateMesh);
	void SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, bool bUpdateMesh);
	void SetStartOffset(const struct FVector2D& StartOffset, bool bUpdateMesh);
	void SetStartPosition(const struct FVector& StartPos, bool bUpdateMesh);
	void SetStartRoll(float StartRoll, bool bUpdateMesh);
	void SetStartScale(const struct FVector2D& StartScale, bool bUpdateMesh);
	void SetStartTangent(const struct FVector& StartTangent, bool bUpdateMesh);
	void UpdateMesh();

	float GetBoundaryMax() const;
	float GetBoundaryMin() const;
	struct FVector2D GetEndOffset() const;
	struct FVector GetEndPosition() const;
	float GetEndRoll() const;
	struct FVector2D GetEndScale() const;
	struct FVector GetEndTangent() const;
	ESplineMeshAxis GetForwardAxis() const;
	struct FVector GetSplineUpDir() const;
	struct FVector2D GetStartOffset() const;
	struct FVector GetStartPosition() const;
	float GetStartRoll() const;
	struct FVector2D GetStartScale() const;
	struct FVector GetStartTangent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineMeshComponent">();
	}
	static class USplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplineMeshComponent>();
	}
};
static_assert(alignof(USplineMeshComponent) == 0x11635BE0, "Wrong alignment on USplineMeshComponent");
static_assert(sizeof(USplineMeshComponent) == 0x11635BE0, "Wrong size on USplineMeshComponent");
static_assert(offsetof(USplineMeshComponent, SplineParams) == 0x000A28, "Member 'USplineMeshComponent::SplineParams' has a wrong offset!");
static_assert(offsetof(USplineMeshComponent, SplineUpDir) == 0x000A80, "Member 'USplineMeshComponent::SplineUpDir' has a wrong offset!");
static_assert(offsetof(USplineMeshComponent, ForwardAxis) == 0x000A90, "Member 'USplineMeshComponent::ForwardAxis' has a wrong offset!");
static_assert(offsetof(USplineMeshComponent, SplineBoundaryMin) == 0x000A94, "Member 'USplineMeshComponent::SplineBoundaryMin' has a wrong offset!");
static_assert(offsetof(USplineMeshComponent, SplineBoundaryMax) == 0x000A98, "Member 'USplineMeshComponent::SplineBoundaryMax' has a wrong offset!");
static_assert(offsetof(USplineMeshComponent, BodySetup) == 0x000AA0, "Member 'USplineMeshComponent::BodySetup' has a wrong offset!");
static_assert(offsetof(USplineMeshComponent, CachedMeshBodySetupGuid) == 0x000AA8, "Member 'USplineMeshComponent::CachedMeshBodySetupGuid' has a wrong offset!");

// Class Engine.SpotLightComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USpotLightComponent final : public UPointLightComponent
{
public:
	float                                         InnerConeAngle;                                    // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterConeAngle;                                    // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightShaftConeAngle;                               // 0x0590(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_594[0xC];                                      // 0x0594(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInnerConeAngle(float NewInnerConeAngle);
	void SetOuterConeAngle(float NewOuterConeAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotLightComponent">();
	}
	static class USpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpotLightComponent>();
	}
};
static_assert(alignof(USpotLightComponent) == 0x112E9AF0, "Wrong alignment on USpotLightComponent");
static_assert(sizeof(USpotLightComponent) == 0x112E9AF0, "Wrong size on USpotLightComponent");
static_assert(offsetof(USpotLightComponent, InnerConeAngle) == 0x000588, "Member 'USpotLightComponent::InnerConeAngle' has a wrong offset!");
static_assert(offsetof(USpotLightComponent, OuterConeAngle) == 0x00058C, "Member 'USpotLightComponent::OuterConeAngle' has a wrong offset!");
static_assert(offsetof(USpotLightComponent, LightShaftConeAngle) == 0x000590, "Member 'USpotLightComponent::LightShaftConeAngle' has a wrong offset!");

// Class Engine.SQEX_AutoEffectDebugDataCommandData
// 0x0000 (0x0068 - 0x0068)
class USQEX_AutoEffectDebugDataCommandData final : public USQEX_AutoEffectDebugDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_AutoEffectDebugDataCommandData">();
	}
	static class USQEX_AutoEffectDebugDataCommandData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_AutoEffectDebugDataCommandData>();
	}
};
static_assert(alignof(USQEX_AutoEffectDebugDataCommandData) == 0x000008, "Wrong alignment on USQEX_AutoEffectDebugDataCommandData");
static_assert(sizeof(USQEX_AutoEffectDebugDataCommandData) == 0x000068, "Wrong size on USQEX_AutoEffectDebugDataCommandData");

// Class Engine.SQEX_CapsuleIndirectShadowComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USQEX_CapsuleIndirectShadowComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_CapsuleIndirectShadowComponent">();
	}
	static class USQEX_CapsuleIndirectShadowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_CapsuleIndirectShadowComponent>();
	}
};
static_assert(alignof(USQEX_CapsuleIndirectShadowComponent) == 0x112E9AF0, "Wrong alignment on USQEX_CapsuleIndirectShadowComponent");
static_assert(sizeof(USQEX_CapsuleIndirectShadowComponent) == 0x112E9AF0, "Wrong size on USQEX_CapsuleIndirectShadowComponent");

// Class Engine.SQEX_EffectAssetList
// 0x0010 (0x0058 - 0x0048)
class USQEX_EffectAssetList final : public UDataAsset
{
public:
	TArray<struct FSQEX_EffectAssetListData>      AssetList;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_EffectAssetList">();
	}
	static class USQEX_EffectAssetList* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_EffectAssetList>();
	}
};
static_assert(alignof(USQEX_EffectAssetList) == 0x000008, "Wrong alignment on USQEX_EffectAssetList");
static_assert(sizeof(USQEX_EffectAssetList) == 0x000058, "Wrong size on USQEX_EffectAssetList");
static_assert(offsetof(USQEX_EffectAssetList, AssetList) == 0x000048, "Member 'USQEX_EffectAssetList::AssetList' has a wrong offset!");

// Class Engine.SQEX_EffectEditorSceneViewParameterAsset
// 0x0748 (0x0790 - 0x0048)
class USQEX_EffectEditorSceneViewParameterAsset final : public UDataAsset
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0050(0x112EAE80)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_EffectEditorSceneViewParameterAsset">();
	}
	static class USQEX_EffectEditorSceneViewParameterAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_EffectEditorSceneViewParameterAsset>();
	}
};
static_assert(alignof(USQEX_EffectEditorSceneViewParameterAsset) == 0x000008, "Wrong alignment on USQEX_EffectEditorSceneViewParameterAsset");
static_assert(sizeof(USQEX_EffectEditorSceneViewParameterAsset) == 0x000790, "Wrong size on USQEX_EffectEditorSceneViewParameterAsset");
static_assert(offsetof(USQEX_EffectEditorSceneViewParameterAsset, PostProcessSettings) == 0x000050, "Member 'USQEX_EffectEditorSceneViewParameterAsset::PostProcessSettings' has a wrong offset!");

// Class Engine.SQEX_EffectSeAttachData
// 0x0028 (0x0068 - 0x0040)
class USQEX_EffectSeAttachData final : public USQEX_EffectSeAttachDataBase
{
public:
	uint8                                         bAttach : 1;                                       // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupID;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             Sound;                                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayAtEnd : 1;                                    // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoSeFadeAtTheEffectEnd : 1;                       // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEmitterAttach : 1;                                // 0x0054(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachEmitterName;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachHistoryRate;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_EffectSeAttachData">();
	}
	static class USQEX_EffectSeAttachData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_EffectSeAttachData>();
	}
};
static_assert(alignof(USQEX_EffectSeAttachData) == 0x000008, "Wrong alignment on USQEX_EffectSeAttachData");
static_assert(sizeof(USQEX_EffectSeAttachData) == 0x000068, "Wrong size on USQEX_EffectSeAttachData");
static_assert(offsetof(USQEX_EffectSeAttachData, GroupID) == 0x000044, "Member 'USQEX_EffectSeAttachData::GroupID' has a wrong offset!");
static_assert(offsetof(USQEX_EffectSeAttachData, Sound) == 0x000048, "Member 'USQEX_EffectSeAttachData::Sound' has a wrong offset!");
static_assert(offsetof(USQEX_EffectSeAttachData, FadeOutTime) == 0x000050, "Member 'USQEX_EffectSeAttachData::FadeOutTime' has a wrong offset!");
static_assert(offsetof(USQEX_EffectSeAttachData, AttachEmitterName) == 0x000058, "Member 'USQEX_EffectSeAttachData::AttachEmitterName' has a wrong offset!");
static_assert(offsetof(USQEX_EffectSeAttachData, AttachHistoryRate) == 0x000060, "Member 'USQEX_EffectSeAttachData::AttachHistoryRate' has a wrong offset!");

// Class Engine.SQEX_EffectSeAttachDataAsset
// 0x0010 (0x0058 - 0x0048)
class USQEX_EffectSeAttachDataAsset final : public UDataAsset
{
public:
	TArray<class USQEX_EffectSeAttachData*>       SEDatas;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_EffectSeAttachDataAsset">();
	}
	static class USQEX_EffectSeAttachDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_EffectSeAttachDataAsset>();
	}
};
static_assert(alignof(USQEX_EffectSeAttachDataAsset) == 0x000008, "Wrong alignment on USQEX_EffectSeAttachDataAsset");
static_assert(sizeof(USQEX_EffectSeAttachDataAsset) == 0x000058, "Wrong size on USQEX_EffectSeAttachDataAsset");
static_assert(offsetof(USQEX_EffectSeAttachDataAsset, SEDatas) == 0x000048, "Member 'USQEX_EffectSeAttachDataAsset::SEDatas' has a wrong offset!");

// Class Engine.SqEx_EffectShaderParameter_BasicMaterialParam
// 0x0030 (0x0070 - 0x0040)
class USqEx_EffectShaderParameter_BasicMaterialParam : public USqEx_EffectShaderParameter_Base
{
public:
	float                                         BrightAddEmissive;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightMultiEmissive;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EmissiveTexture;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTilingEmissive;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VTilingEmissive;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightAddOpacity;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightMultiOpacity;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             OpacityTexture;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTilingOpacity;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VTilingOpacity;                                    // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqEx_EffectShaderParameter_BasicMaterialParam">();
	}
	static class USqEx_EffectShaderParameter_BasicMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqEx_EffectShaderParameter_BasicMaterialParam>();
	}
};
static_assert(alignof(USqEx_EffectShaderParameter_BasicMaterialParam) == 0x000008, "Wrong alignment on USqEx_EffectShaderParameter_BasicMaterialParam");
static_assert(sizeof(USqEx_EffectShaderParameter_BasicMaterialParam) == 0x000070, "Wrong size on USqEx_EffectShaderParameter_BasicMaterialParam");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, BrightAddEmissive) == 0x000040, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::BrightAddEmissive' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, BrightMultiEmissive) == 0x000044, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::BrightMultiEmissive' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, EmissiveTexture) == 0x000048, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::EmissiveTexture' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, UTilingEmissive) == 0x000050, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::UTilingEmissive' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, VTilingEmissive) == 0x000054, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::VTilingEmissive' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, BrightAddOpacity) == 0x000058, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::BrightAddOpacity' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, BrightMultiOpacity) == 0x00005C, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::BrightMultiOpacity' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, OpacityTexture) == 0x000060, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::OpacityTexture' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, UTilingOpacity) == 0x000068, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::UTilingOpacity' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicMaterialParam, VTilingOpacity) == 0x00006C, "Member 'USqEx_EffectShaderParameter_BasicMaterialParam::VTilingOpacity' has a wrong offset!");

// Class Engine.SqEx_EffectShaderParameter_BasicColorMaterialParam
// 0x112EAE10 (0x112EAE80 - 0x0070)
class USqEx_EffectShaderParameter_BasicColorMaterialParam final : public USqEx_EffectShaderParameter_BasicMaterialParam
{
public:
	struct FLinearColor                           BlackColor;                                        // 0x0070(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WhiteColor;                                        // 0x0080(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqEx_EffectShaderParameter_BasicColorMaterialParam">();
	}
	static class USqEx_EffectShaderParameter_BasicColorMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqEx_EffectShaderParameter_BasicColorMaterialParam>();
	}
};
static_assert(alignof(USqEx_EffectShaderParameter_BasicColorMaterialParam) == 0x112EAE80, "Wrong alignment on USqEx_EffectShaderParameter_BasicColorMaterialParam");
static_assert(sizeof(USqEx_EffectShaderParameter_BasicColorMaterialParam) == 0x112EAE80, "Wrong size on USqEx_EffectShaderParameter_BasicColorMaterialParam");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicColorMaterialParam, BlackColor) == 0x000070, "Member 'USqEx_EffectShaderParameter_BasicColorMaterialParam::BlackColor' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicColorMaterialParam, WhiteColor) == 0x000080, "Member 'USqEx_EffectShaderParameter_BasicColorMaterialParam::WhiteColor' has a wrong offset!");

// Class Engine.SqEx_EffectShaderParameter_BasicGlowMaterialParam
// 0x112EAE10 (0x112EAE80 - 0x0070)
class USqEx_EffectShaderParameter_BasicGlowMaterialParam final : public USqEx_EffectShaderParameter_BasicMaterialParam
{
public:
	struct FLinearColor                           GlowColor;                                         // 0x0070(0x112EAE80)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlowOpacity;                                       // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             GlowTexture;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTilingGlow;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VTilingGlow;                                       // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqEx_EffectShaderParameter_BasicGlowMaterialParam">();
	}
	static class USqEx_EffectShaderParameter_BasicGlowMaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqEx_EffectShaderParameter_BasicGlowMaterialParam>();
	}
};
static_assert(alignof(USqEx_EffectShaderParameter_BasicGlowMaterialParam) == 0x112EAE80, "Wrong alignment on USqEx_EffectShaderParameter_BasicGlowMaterialParam");
static_assert(sizeof(USqEx_EffectShaderParameter_BasicGlowMaterialParam) == 0x112EAE80, "Wrong size on USqEx_EffectShaderParameter_BasicGlowMaterialParam");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicGlowMaterialParam, GlowColor) == 0x000070, "Member 'USqEx_EffectShaderParameter_BasicGlowMaterialParam::GlowColor' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicGlowMaterialParam, GlowOpacity) == 0x000080, "Member 'USqEx_EffectShaderParameter_BasicGlowMaterialParam::GlowOpacity' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicGlowMaterialParam, GlowTexture) == 0x000088, "Member 'USqEx_EffectShaderParameter_BasicGlowMaterialParam::GlowTexture' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicGlowMaterialParam, UTilingGlow) == 0x000090, "Member 'USqEx_EffectShaderParameter_BasicGlowMaterialParam::UTilingGlow' has a wrong offset!");
static_assert(offsetof(USqEx_EffectShaderParameter_BasicGlowMaterialParam, VTilingGlow) == 0x000094, "Member 'USqEx_EffectShaderParameter_BasicGlowMaterialParam::VTilingGlow' has a wrong offset!");

// Class Engine.SQEX_ParticleAttachDataBase
// 0x0000 (0x0040 - 0x0040)
class USQEX_ParticleAttachDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_ParticleAttachDataBase">();
	}
	static class USQEX_ParticleAttachDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_ParticleAttachDataBase>();
	}
};
static_assert(alignof(USQEX_ParticleAttachDataBase) == 0x000008, "Wrong alignment on USQEX_ParticleAttachDataBase");
static_assert(sizeof(USQEX_ParticleAttachDataBase) == 0x000040, "Wrong size on USQEX_ParticleAttachDataBase");

// Class Engine.SQEX_ParticleAttachData
// 0x112E9AB0 (0x112E9AF0 - 0x0040)
class USQEX_ParticleAttachData final : public USQEX_ParticleAttachDataBase
{
public:
	class FString                                 Description;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCommonEffect : 1;                              // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_AttachEffectData>         EffectDataList;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlayNumber;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_CHANGE_ANIMATION_TYPE                   WhenChangeAnimationType;                           // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESQEX_ATTACH_EFFECT_END_TYPE                  AttachEffectEndType;                               // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeIn;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOut;                                           // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelayTime;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDelayTime;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ToAttach : 1;                                      // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DetachAtEnd : 1;                                   // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbsoluteLocation : 1;                             // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbsoluteRotation : 1;                             // 0x0088(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbsoluteScale : 1;                                // 0x0088(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSocketName;                                     // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x00A0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x00AC(0x112E9AF0)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleOffset;                                       // 0x00B8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParticleColor;                                     // 0x00C4(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleAlpha;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnCastShadow : 1;                                 // 0x00D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_ParticleAttachData">();
	}
	static class USQEX_ParticleAttachData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_ParticleAttachData>();
	}
};
static_assert(alignof(USQEX_ParticleAttachData) == 0x112E9AF0, "Wrong alignment on USQEX_ParticleAttachData");
static_assert(sizeof(USQEX_ParticleAttachData) == 0x112E9AF0, "Wrong size on USQEX_ParticleAttachData");
static_assert(offsetof(USQEX_ParticleAttachData, Description) == 0x000040, "Member 'USQEX_ParticleAttachData::Description' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, AttachName) == 0x000050, "Member 'USQEX_ParticleAttachData::AttachName' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, EffectDataList) == 0x000060, "Member 'USQEX_ParticleAttachData::EffectDataList' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, PlayNumber) == 0x000070, "Member 'USQEX_ParticleAttachData::PlayNumber' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, WhenChangeAnimationType) == 0x000074, "Member 'USQEX_ParticleAttachData::WhenChangeAnimationType' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, AttachEffectEndType) == 0x000075, "Member 'USQEX_ParticleAttachData::AttachEffectEndType' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, FadeIn) == 0x000078, "Member 'USQEX_ParticleAttachData::FadeIn' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, FadeOut) == 0x00007C, "Member 'USQEX_ParticleAttachData::FadeOut' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, StartDelayTime) == 0x000080, "Member 'USQEX_ParticleAttachData::StartDelayTime' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, EndDelayTime) == 0x000084, "Member 'USQEX_ParticleAttachData::EndDelayTime' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, SocketName) == 0x000090, "Member 'USQEX_ParticleAttachData::SocketName' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, EndSocketName) == 0x000098, "Member 'USQEX_ParticleAttachData::EndSocketName' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, LocationOffset) == 0x0000A0, "Member 'USQEX_ParticleAttachData::LocationOffset' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, RotationOffset) == 0x0000AC, "Member 'USQEX_ParticleAttachData::RotationOffset' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, ScaleOffset) == 0x0000B8, "Member 'USQEX_ParticleAttachData::ScaleOffset' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, ParticleColor) == 0x0000C4, "Member 'USQEX_ParticleAttachData::ParticleColor' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachData, ParticleAlpha) == 0x0000D0, "Member 'USQEX_ParticleAttachData::ParticleAlpha' has a wrong offset!");

// Class Engine.SQEX_ParticleAttachDataAsset
// 0x0020 (0x0068 - 0x0048)
class USQEX_ParticleAttachDataAsset final : public UDataAsset
{
public:
	TArray<class USQEX_ParticleAttachDataBase*>   EffectDatas;                                       // 0x0048(0x0010)(ExportObject, ZeroConstructor, Deprecated, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSQEX_StructParticleAttachData> EffectDataList;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_ParticleAttachDataAsset">();
	}
	static class USQEX_ParticleAttachDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_ParticleAttachDataAsset>();
	}
};
static_assert(alignof(USQEX_ParticleAttachDataAsset) == 0x000008, "Wrong alignment on USQEX_ParticleAttachDataAsset");
static_assert(sizeof(USQEX_ParticleAttachDataAsset) == 0x000068, "Wrong size on USQEX_ParticleAttachDataAsset");
static_assert(offsetof(USQEX_ParticleAttachDataAsset, EffectDatas) == 0x000048, "Member 'USQEX_ParticleAttachDataAsset::EffectDatas' has a wrong offset!");
static_assert(offsetof(USQEX_ParticleAttachDataAsset, EffectDataList) == 0x000058, "Member 'USQEX_ParticleAttachDataAsset::EffectDataList' has a wrong offset!");

// Class Engine.SQEX_ParticleVoxelDataAsset
// 0x0010 (0x0058 - 0x0048)
class USQEX_ParticleVoxelDataAsset final : public UDataAsset
{
public:
	TArray<struct FSQEX_PARTICLE_VOXEL_VERTEX_INDEX_DATA> VoxelVertex;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_ParticleVoxelDataAsset">();
	}
	static class USQEX_ParticleVoxelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_ParticleVoxelDataAsset>();
	}
};
static_assert(alignof(USQEX_ParticleVoxelDataAsset) == 0x000008, "Wrong alignment on USQEX_ParticleVoxelDataAsset");
static_assert(sizeof(USQEX_ParticleVoxelDataAsset) == 0x000058, "Wrong size on USQEX_ParticleVoxelDataAsset");
static_assert(offsetof(USQEX_ParticleVoxelDataAsset, VoxelVertex) == 0x000048, "Member 'USQEX_ParticleVoxelDataAsset::VoxelVertex' has a wrong offset!");

// Class Engine.SQEX_SplineRootComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class USQEX_SplineRootComponent final : public USceneComponent
{
public:
	class ASQEX_SplineActor*                      M_pOwnerSplineActor;                               // 0x0418(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_SplineRootComponent">();
	}
	static class USQEX_SplineRootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_SplineRootComponent>();
	}
};
static_assert(alignof(USQEX_SplineRootComponent) == 0x112E9AF0, "Wrong alignment on USQEX_SplineRootComponent");
static_assert(sizeof(USQEX_SplineRootComponent) == 0x112E9AF0, "Wrong size on USQEX_SplineRootComponent");
static_assert(offsetof(USQEX_SplineRootComponent, M_pOwnerSplineActor) == 0x000418, "Member 'USQEX_SplineRootComponent::M_pOwnerSplineActor' has a wrong offset!");

// Class Engine.SQEX_Timeline
// 0x0010 (0x0050 - 0x0040)
class USQEX_Timeline final : public UObject
{
public:
	TArray<class USQEX_TimelineTrackBase*>        Tracks;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_Timeline">();
	}
	static class USQEX_Timeline* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_Timeline>();
	}
};
static_assert(alignof(USQEX_Timeline) == 0x000008, "Wrong alignment on USQEX_Timeline");
static_assert(sizeof(USQEX_Timeline) == 0x000050, "Wrong size on USQEX_Timeline");
static_assert(offsetof(USQEX_Timeline, Tracks) == 0x000040, "Member 'USQEX_Timeline::Tracks' has a wrong offset!");

// Class Engine.SQEX_TimelineHolder
// 0x0008 (0x0048 - 0x0040)
class USQEX_TimelineHolder final : public UObject
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TimelineHolder">();
	}
	static class USQEX_TimelineHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TimelineHolder>();
	}
};
static_assert(alignof(USQEX_TimelineHolder) == 0x000008, "Wrong alignment on USQEX_TimelineHolder");
static_assert(sizeof(USQEX_TimelineHolder) == 0x000048, "Wrong size on USQEX_TimelineHolder");

// Class Engine.SQEX_TimelineTrackBase
// 0x0060 (0x00A0 - 0x0040)
class USQEX_TimelineTrackBase : public UObject
{
public:
	class FString                                 TrackName;                                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USQEX_TimelineTrackBase*>        Children;                                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x38];                                      // 0x0068(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwitchExpanded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TimelineTrackBase">();
	}
	static class USQEX_TimelineTrackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TimelineTrackBase>();
	}
};
static_assert(alignof(USQEX_TimelineTrackBase) == 0x000008, "Wrong alignment on USQEX_TimelineTrackBase");
static_assert(sizeof(USQEX_TimelineTrackBase) == 0x0000A0, "Wrong size on USQEX_TimelineTrackBase");
static_assert(offsetof(USQEX_TimelineTrackBase, TrackName) == 0x000040, "Member 'USQEX_TimelineTrackBase::TrackName' has a wrong offset!");
static_assert(offsetof(USQEX_TimelineTrackBase, Children) == 0x000058, "Member 'USQEX_TimelineTrackBase::Children' has a wrong offset!");

// Class Engine.SQEX_TimelineTrack
// 0x0020 (0x00C0 - 0x00A0)
class USQEX_TimelineTrack final : public USQEX_TimelineTrackBase
{
public:
	TArray<class USQEX_TimelineItem*>             Items;                                             // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USQEX_TimelineTrackPropertyBind*> BindDatas;                                         // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TimelineTrack">();
	}
	static class USQEX_TimelineTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TimelineTrack>();
	}
};
static_assert(alignof(USQEX_TimelineTrack) == 0x000008, "Wrong alignment on USQEX_TimelineTrack");
static_assert(sizeof(USQEX_TimelineTrack) == 0x0000C0, "Wrong size on USQEX_TimelineTrack");
static_assert(offsetof(USQEX_TimelineTrack, Items) == 0x0000A0, "Member 'USQEX_TimelineTrack::Items' has a wrong offset!");
static_assert(offsetof(USQEX_TimelineTrack, BindDatas) == 0x0000B0, "Member 'USQEX_TimelineTrack::BindDatas' has a wrong offset!");

// Class Engine.SQEX_TimelineTrackFolder
// 0x0000 (0x00A0 - 0x00A0)
class USQEX_TimelineTrackFolder final : public USQEX_TimelineTrackBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TimelineTrackFolder">();
	}
	static class USQEX_TimelineTrackFolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TimelineTrackFolder>();
	}
};
static_assert(alignof(USQEX_TimelineTrackFolder) == 0x000008, "Wrong alignment on USQEX_TimelineTrackFolder");
static_assert(sizeof(USQEX_TimelineTrackFolder) == 0x0000A0, "Wrong size on USQEX_TimelineTrackFolder");

// Class Engine.SQEX_TrackItemCell
// 0x0000 (0x00C0 - 0x00C0)
class USQEX_TrackItemCell final : public USQEX_TimelineItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TrackItemCell">();
	}
	static class USQEX_TrackItemCell* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TrackItemCell>();
	}
};
static_assert(alignof(USQEX_TrackItemCell) == 0x000008, "Wrong alignment on USQEX_TrackItemCell");
static_assert(sizeof(USQEX_TrackItemCell) == 0x0000C0, "Wrong size on USQEX_TrackItemCell");

// Class Engine.SQEX_TrackItemClip
// 0x0000 (0x00C0 - 0x00C0)
class USQEX_TrackItemClip final : public USQEX_TimelineItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_TrackItemClip">();
	}
	static class USQEX_TrackItemClip* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_TrackItemClip>();
	}
};
static_assert(alignof(USQEX_TrackItemClip) == 0x000008, "Wrong alignment on USQEX_TrackItemClip");
static_assert(sizeof(USQEX_TrackItemClip) == 0x0000C0, "Wrong size on USQEX_TrackItemClip");

// Class Engine.SQEX_VertexModelAseetUserData
// 0x0020 (0x0060 - 0x0040)
class USQEX_VertexModelAseetUserData final : public UAssetUserData
{
public:
	TArray<struct FSQEX_VertexModule_VertexData>  SpawnVertexList;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 SpawnVertexIndexList;                              // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VertexModelAseetUserData">();
	}
	static class USQEX_VertexModelAseetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_VertexModelAseetUserData>();
	}
};
static_assert(alignof(USQEX_VertexModelAseetUserData) == 0x000008, "Wrong alignment on USQEX_VertexModelAseetUserData");
static_assert(sizeof(USQEX_VertexModelAseetUserData) == 0x000060, "Wrong size on USQEX_VertexModelAseetUserData");
static_assert(offsetof(USQEX_VertexModelAseetUserData, SpawnVertexList) == 0x000040, "Member 'USQEX_VertexModelAseetUserData::SpawnVertexList' has a wrong offset!");
static_assert(offsetof(USQEX_VertexModelAseetUserData, SpawnVertexIndexList) == 0x000050, "Member 'USQEX_VertexModelAseetUserData::SpawnVertexIndexList' has a wrong offset!");

// Class Engine.SQEX_VideoComponentTexture
// 0x0000 (0x112E8D20 - 0x112E8D20)
class USQEX_VideoComponentTexture final : public UTexture
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VideoComponentTexture">();
	}
	static class USQEX_VideoComponentTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_VideoComponentTexture>();
	}
};
static_assert(alignof(USQEX_VideoComponentTexture) == 0x112E8D20, "Wrong alignment on USQEX_VideoComponentTexture");
static_assert(sizeof(USQEX_VideoComponentTexture) == 0x112E8D20, "Wrong size on USQEX_VideoComponentTexture");

// Class Engine.SQEX_VoxelMeshBoneDataAsset
// 0x0010 (0x0058 - 0x0048)
class USQEX_VoxelMeshBoneDataAsset final : public UDataAsset
{
public:
	TArray<class USQEX_VoxelMeshBoneDataBase*>    List;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEX_VoxelMeshBoneDataAsset">();
	}
	static class USQEX_VoxelMeshBoneDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEX_VoxelMeshBoneDataAsset>();
	}
};
static_assert(alignof(USQEX_VoxelMeshBoneDataAsset) == 0x000008, "Wrong alignment on USQEX_VoxelMeshBoneDataAsset");
static_assert(sizeof(USQEX_VoxelMeshBoneDataAsset) == 0x000058, "Wrong size on USQEX_VoxelMeshBoneDataAsset");
static_assert(offsetof(USQEX_VoxelMeshBoneDataAsset, List) == 0x000048, "Member 'USQEX_VoxelMeshBoneDataAsset::List' has a wrong offset!");

// Class Engine.SQEXDistributionFloatGauss
// 0x0010 (0x0060 - 0x0050)
class USQEXDistributionFloatGauss final : public UDistributionFloat
{
public:
	float                                         Min;                                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deviation;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Average;                                           // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEXDistributionFloatGauss">();
	}
	static class USQEXDistributionFloatGauss* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEXDistributionFloatGauss>();
	}
};
static_assert(alignof(USQEXDistributionFloatGauss) == 0x000008, "Wrong alignment on USQEXDistributionFloatGauss");
static_assert(sizeof(USQEXDistributionFloatGauss) == 0x000060, "Wrong size on USQEXDistributionFloatGauss");
static_assert(offsetof(USQEXDistributionFloatGauss, Min) == 0x000050, "Member 'USQEXDistributionFloatGauss::Min' has a wrong offset!");
static_assert(offsetof(USQEXDistributionFloatGauss, Max) == 0x000054, "Member 'USQEXDistributionFloatGauss::Max' has a wrong offset!");
static_assert(offsetof(USQEXDistributionFloatGauss, Deviation) == 0x000058, "Member 'USQEXDistributionFloatGauss::Deviation' has a wrong offset!");
static_assert(offsetof(USQEXDistributionFloatGauss, Average) == 0x00005C, "Member 'USQEXDistributionFloatGauss::Average' has a wrong offset!");

// Class Engine.SQEXDistributionFloatUniform
// 0x0010 (0x0060 - 0x0050)
class USQEXDistributionFloatUniform final : public UDistributionFloat
{
public:
	float                                         Min;                                               // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deviation;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEXDistributionFloatUniform">();
	}
	static class USQEXDistributionFloatUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEXDistributionFloatUniform>();
	}
};
static_assert(alignof(USQEXDistributionFloatUniform) == 0x000008, "Wrong alignment on USQEXDistributionFloatUniform");
static_assert(sizeof(USQEXDistributionFloatUniform) == 0x000060, "Wrong size on USQEXDistributionFloatUniform");
static_assert(offsetof(USQEXDistributionFloatUniform, Min) == 0x000050, "Member 'USQEXDistributionFloatUniform::Min' has a wrong offset!");
static_assert(offsetof(USQEXDistributionFloatUniform, Max) == 0x000054, "Member 'USQEXDistributionFloatUniform::Max' has a wrong offset!");
static_assert(offsetof(USQEXDistributionFloatUniform, Deviation) == 0x000058, "Member 'USQEXDistributionFloatUniform::Deviation' has a wrong offset!");

// Class Engine.SQEXDistributionVectorUniform
// 0x0028 (0x0078 - 0x0050)
class USQEXDistributionVectorUniform final : public UDistributionVector
{
public:
	struct FVector                                Max;                                               // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x005C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deviation;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockAxes : 1;                                     // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDistributionVectorLockFlags                  LockedAxes;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistributionVectorMirrorFlags                MirrorFlags[0x3];                                  // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseExtremes : 1;                                  // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SQEXDistributionVectorUniform">();
	}
	static class USQEXDistributionVectorUniform* GetDefaultObj()
	{
		return GetDefaultObjImpl<USQEXDistributionVectorUniform>();
	}
};
static_assert(alignof(USQEXDistributionVectorUniform) == 0x000008, "Wrong alignment on USQEXDistributionVectorUniform");
static_assert(sizeof(USQEXDistributionVectorUniform) == 0x000078, "Wrong size on USQEXDistributionVectorUniform");
static_assert(offsetof(USQEXDistributionVectorUniform, Max) == 0x000050, "Member 'USQEXDistributionVectorUniform::Max' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorUniform, Min) == 0x00005C, "Member 'USQEXDistributionVectorUniform::Min' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorUniform, Deviation) == 0x000068, "Member 'USQEXDistributionVectorUniform::Deviation' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorUniform, LockedAxes) == 0x000070, "Member 'USQEXDistributionVectorUniform::LockedAxes' has a wrong offset!");
static_assert(offsetof(USQEXDistributionVectorUniform, MirrorFlags) == 0x000071, "Member 'USQEXDistributionVectorUniform::MirrorFlags' has a wrong offset!");

// Class Engine.SqExEffectEmitterPresetDataAsset
// 0x0010 (0x0058 - 0x0048)
class USqExEffectEmitterPresetDataAsset final : public UDataAsset
{
public:
	TArray<class USQEX_EffectEmitterPresetDataBase*> Menu;                                              // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqExEffectEmitterPresetDataAsset">();
	}
	static class USqExEffectEmitterPresetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USqExEffectEmitterPresetDataAsset>();
	}
};
static_assert(alignof(USqExEffectEmitterPresetDataAsset) == 0x000008, "Wrong alignment on USqExEffectEmitterPresetDataAsset");
static_assert(sizeof(USqExEffectEmitterPresetDataAsset) == 0x000058, "Wrong size on USqExEffectEmitterPresetDataAsset");
static_assert(offsetof(USqExEffectEmitterPresetDataAsset, Menu) == 0x000048, "Member 'USqExEffectEmitterPresetDataAsset::Menu' has a wrong offset!");

// Class Engine.SqexLightmassRemoveVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class ASqexLightmassRemoveVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SqexLightmassRemoveVolume">();
	}
	static class ASqexLightmassRemoveVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASqexLightmassRemoveVolume>();
	}
};
static_assert(alignof(ASqexLightmassRemoveVolume) == 0x1EF72E00, "Wrong alignment on ASqexLightmassRemoveVolume");
static_assert(sizeof(ASqexLightmassRemoveVolume) == 0x1EF72E00, "Wrong size on ASqexLightmassRemoveVolume");

// Class Engine.StaticMesh
// 0x112EB650 (0x112EB690 - 0x0040)
class UStaticMesh final : public UObject
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLOD;                                            // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0060(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FStaticMaterial>                StaticMaterials;                                   // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LightmapUVDensity;                                 // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMapResolution;                                // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMapCoordinateIndex;                           // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldSelfShadowBias;                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGenerateMeshDistanceField : 1;                    // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0098(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODForCollision;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bStripComplexCollisionForConsole : 1;              // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasNavigationData : 1;                            // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportUniformlyDistributedSampling : 1;          // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LpvBiasMultiplier;                                 // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCPUAccess;                                   // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x33];                                      // 0x00AD(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshSocket*>              Sockets;                                           // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PositiveBoundsExtension;                           // 0x0100(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NegativeBoundsExtension;                           // 0x010C(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       ExtendedBounds;                                    // 0x0118(0x112EB690)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ElementToIgnoreForTexFactor;                       // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x0138(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UNavCollision*                          NavCollision;                                      // 0x0148(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SQEX_bOverrideTranslucencySortPriority : 1;        // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESQEX_OBJECT_TYPE_TRANSLUCENCYSORTPRIORITY    SQEXInitialTranslucencySortPriorityCategory;       // 0x0154(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SQEX_InitialTranslucencySortPriority;              // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSQEX_SMCapsuleShadowElem>      SQEX_CapsuleShadowSettings;                        // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FBox GetBoundingBox() const;
	struct FBoxSphereBounds GetBounds() const;
	class UMaterialInterface* GetMaterial(int32 MaterialIndex) const;
	int32 GetMaterialIndex(class FName MaterialSlotName) const;
	int32 GetNumLODs() const;
	int32 GetNumSections(int32 InLOD) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMesh">();
	}
	static class UStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticMesh>();
	}
};
static_assert(alignof(UStaticMesh) == 0x112EB690, "Wrong alignment on UStaticMesh");
static_assert(sizeof(UStaticMesh) == 0x112EB690, "Wrong size on UStaticMesh");
static_assert(offsetof(UStaticMesh, MinLOD) == 0x000058, "Member 'UStaticMesh::MinLOD' has a wrong offset!");
static_assert(offsetof(UStaticMesh, Materials) == 0x000060, "Member 'UStaticMesh::Materials' has a wrong offset!");
static_assert(offsetof(UStaticMesh, StaticMaterials) == 0x000070, "Member 'UStaticMesh::StaticMaterials' has a wrong offset!");
static_assert(offsetof(UStaticMesh, LightmapUVDensity) == 0x000080, "Member 'UStaticMesh::LightmapUVDensity' has a wrong offset!");
static_assert(offsetof(UStaticMesh, LightMapResolution) == 0x000084, "Member 'UStaticMesh::LightMapResolution' has a wrong offset!");
static_assert(offsetof(UStaticMesh, LightMapCoordinateIndex) == 0x000088, "Member 'UStaticMesh::LightMapCoordinateIndex' has a wrong offset!");
static_assert(offsetof(UStaticMesh, DistanceFieldSelfShadowBias) == 0x00008C, "Member 'UStaticMesh::DistanceFieldSelfShadowBias' has a wrong offset!");
static_assert(offsetof(UStaticMesh, BodySetup) == 0x000098, "Member 'UStaticMesh::BodySetup' has a wrong offset!");
static_assert(offsetof(UStaticMesh, LODForCollision) == 0x0000A0, "Member 'UStaticMesh::LODForCollision' has a wrong offset!");
static_assert(offsetof(UStaticMesh, LpvBiasMultiplier) == 0x0000A8, "Member 'UStaticMesh::LpvBiasMultiplier' has a wrong offset!");
static_assert(offsetof(UStaticMesh, bAllowCPUAccess) == 0x0000AC, "Member 'UStaticMesh::bAllowCPUAccess' has a wrong offset!");
static_assert(offsetof(UStaticMesh, Sockets) == 0x0000E0, "Member 'UStaticMesh::Sockets' has a wrong offset!");
static_assert(offsetof(UStaticMesh, PositiveBoundsExtension) == 0x000100, "Member 'UStaticMesh::PositiveBoundsExtension' has a wrong offset!");
static_assert(offsetof(UStaticMesh, NegativeBoundsExtension) == 0x00010C, "Member 'UStaticMesh::NegativeBoundsExtension' has a wrong offset!");
static_assert(offsetof(UStaticMesh, ExtendedBounds) == 0x000118, "Member 'UStaticMesh::ExtendedBounds' has a wrong offset!");
static_assert(offsetof(UStaticMesh, ElementToIgnoreForTexFactor) == 0x000134, "Member 'UStaticMesh::ElementToIgnoreForTexFactor' has a wrong offset!");
static_assert(offsetof(UStaticMesh, AssetUserData) == 0x000138, "Member 'UStaticMesh::AssetUserData' has a wrong offset!");
static_assert(offsetof(UStaticMesh, NavCollision) == 0x000148, "Member 'UStaticMesh::NavCollision' has a wrong offset!");
static_assert(offsetof(UStaticMesh, SQEXInitialTranslucencySortPriorityCategory) == 0x000154, "Member 'UStaticMesh::SQEXInitialTranslucencySortPriorityCategory' has a wrong offset!");
static_assert(offsetof(UStaticMesh, SQEX_InitialTranslucencySortPriority) == 0x000158, "Member 'UStaticMesh::SQEX_InitialTranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UStaticMesh, SQEX_CapsuleShadowSettings) == 0x000160, "Member 'UStaticMesh::SQEX_CapsuleShadowSettings' has a wrong offset!");

// Class Engine.StereoLayerComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UStereoLayerComponent final : public USceneComponent
{
public:
	uint8                                         bLiveTexture : 1;                                  // 0x0418(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSupportsDepth : 1;                                // 0x0418(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoAlphaChannel : 1;                               // 0x0418(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Texture;                                           // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               LeftTexture;                                       // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bQuadPreserveTextureRatio : 1;                     // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              QuadSize;                                          // 0x0434(0x112E95F0)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox2D                                 UVRect;                                            // 0x043C(0x112E95F0)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CylinderRadius;                                    // 0x0450(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CylinderOverlayArc;                                // 0x0454(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CylinderHeight;                                    // 0x0458(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStereoLayerType                              StereoLayerType;                                   // 0x045C(0x0001)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStereoLayerShape                             StereoLayerShape;                                  // 0x045D(0x0001)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45E[0x2];                                      // 0x045E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0460(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4C];                                     // 0x0464(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkTextureForUpdate();
	void SetPriority(int32 InPriority);
	void SetQuadSize(const struct FVector2D& InQuadSize);
	void SetTexture(class UTexture* InTexture);
	void SetUVRect(const struct FBox2D& InUVRect);

	int32 GetPriority() const;
	struct FVector2D GetQuadSize() const;
	class UTexture* GetTexture() const;
	struct FBox2D GetUVRect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StereoLayerComponent">();
	}
	static class UStereoLayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStereoLayerComponent>();
	}
};
static_assert(alignof(UStereoLayerComponent) == 0x112E9AF0, "Wrong alignment on UStereoLayerComponent");
static_assert(sizeof(UStereoLayerComponent) == 0x112E9AF0, "Wrong size on UStereoLayerComponent");
static_assert(offsetof(UStereoLayerComponent, Texture) == 0x000420, "Member 'UStereoLayerComponent::Texture' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, LeftTexture) == 0x000428, "Member 'UStereoLayerComponent::LeftTexture' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, QuadSize) == 0x000434, "Member 'UStereoLayerComponent::QuadSize' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, UVRect) == 0x00043C, "Member 'UStereoLayerComponent::UVRect' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, CylinderRadius) == 0x000450, "Member 'UStereoLayerComponent::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, CylinderOverlayArc) == 0x000454, "Member 'UStereoLayerComponent::CylinderOverlayArc' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, CylinderHeight) == 0x000458, "Member 'UStereoLayerComponent::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, StereoLayerType) == 0x00045C, "Member 'UStereoLayerComponent::StereoLayerType' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, StereoLayerShape) == 0x00045D, "Member 'UStereoLayerComponent::StereoLayerShape' has a wrong offset!");
static_assert(offsetof(UStereoLayerComponent, Priority) == 0x000460, "Member 'UStereoLayerComponent::Priority' has a wrong offset!");

// Class Engine.StereoLayerFunctionLibrary
// 0x0000 (0x0040 - 0x0040)
class UStereoLayerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EnableAutoLoadingSplashScreen(bool InAutoShowEnabled);
	static void HideSplashScreen();
	static void SetSplashScreen(class UTexture* Texture, const struct FVector2D& Scale, const struct FVector2D& Offset, bool bShowLoadingMovie, bool bShowOnSet);
	static void ShowSplashScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StereoLayerFunctionLibrary">();
	}
	static class UStereoLayerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStereoLayerFunctionLibrary>();
	}
};
static_assert(alignof(UStereoLayerFunctionLibrary) == 0x000008, "Wrong alignment on UStereoLayerFunctionLibrary");
static_assert(sizeof(UStereoLayerFunctionLibrary) == 0x000040, "Wrong size on UStereoLayerFunctionLibrary");

// Class Engine.StringTable
// 0x0018 (0x0058 - 0x0040)
class UStringTable final : public UObject
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StringTable">();
	}
	static class UStringTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStringTable>();
	}
};
static_assert(alignof(UStringTable) == 0x000008, "Wrong alignment on UStringTable");
static_assert(sizeof(UStringTable) == 0x000058, "Wrong size on UStringTable");

// Class Engine.SubUVAnimation
// 0x0038 (0x0078 - 0x0040)
class USubUVAnimation final : public UObject
{
public:
	class UTexture2D*                             SubUVTexture;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubImages_Horizontal;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubImages_Vertical;                                // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubUVBoundingVertexCount                     BoundingMode;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOpacitySourceMode                            OpacitySourceMode;                                 // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlphaThreshold;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubUVAnimation">();
	}
	static class USubUVAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubUVAnimation>();
	}
};
static_assert(alignof(USubUVAnimation) == 0x000008, "Wrong alignment on USubUVAnimation");
static_assert(sizeof(USubUVAnimation) == 0x000078, "Wrong size on USubUVAnimation");
static_assert(offsetof(USubUVAnimation, SubUVTexture) == 0x000040, "Member 'USubUVAnimation::SubUVTexture' has a wrong offset!");
static_assert(offsetof(USubUVAnimation, SubImages_Horizontal) == 0x000048, "Member 'USubUVAnimation::SubImages_Horizontal' has a wrong offset!");
static_assert(offsetof(USubUVAnimation, SubImages_Vertical) == 0x00004C, "Member 'USubUVAnimation::SubImages_Vertical' has a wrong offset!");
static_assert(offsetof(USubUVAnimation, BoundingMode) == 0x000050, "Member 'USubUVAnimation::BoundingMode' has a wrong offset!");
static_assert(offsetof(USubUVAnimation, OpacitySourceMode) == 0x000051, "Member 'USubUVAnimation::OpacitySourceMode' has a wrong offset!");
static_assert(offsetof(USubUVAnimation, AlphaThreshold) == 0x000054, "Member 'USubUVAnimation::AlphaThreshold' has a wrong offset!");

// Class Engine.TailShape_ExtensionData
// 0x0000 (0x0040 - 0x0040)
class UTailShape_ExtensionData final : public UTailShape_ExtensionData_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TailShape_ExtensionData">();
	}
	static class UTailShape_ExtensionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTailShape_ExtensionData>();
	}
};
static_assert(alignof(UTailShape_ExtensionData) == 0x000008, "Wrong alignment on UTailShape_ExtensionData");
static_assert(sizeof(UTailShape_ExtensionData) == 0x000040, "Wrong size on UTailShape_ExtensionData");

// Class Engine.TailShape_ExtensionData_Wave
// 0x0068 (0x00A8 - 0x0040)
class UTailShape_ExtensionData_Wave final : public UTailShape_ExtensionData_Base
{
public:
	uint8                                         IsWaveTakeOverEmitterTransform : 1;                // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveVector;                                        // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInterval;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 RandomMoveVector;                                  // 0x0058(0x0050)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TailShape_ExtensionData_Wave">();
	}
	static class UTailShape_ExtensionData_Wave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTailShape_ExtensionData_Wave>();
	}
};
static_assert(alignof(UTailShape_ExtensionData_Wave) == 0x000008, "Wrong alignment on UTailShape_ExtensionData_Wave");
static_assert(sizeof(UTailShape_ExtensionData_Wave) == 0x0000A8, "Wrong size on UTailShape_ExtensionData_Wave");
static_assert(offsetof(UTailShape_ExtensionData_Wave, MoveVector) == 0x000044, "Member 'UTailShape_ExtensionData_Wave::MoveVector' has a wrong offset!");
static_assert(offsetof(UTailShape_ExtensionData_Wave, RandomInterval) == 0x000050, "Member 'UTailShape_ExtensionData_Wave::RandomInterval' has a wrong offset!");
static_assert(offsetof(UTailShape_ExtensionData_Wave, RandomMoveVector) == 0x000058, "Member 'UTailShape_ExtensionData_Wave::RandomMoveVector' has a wrong offset!");

// Class Engine.TextPropertyTestObject
// 0x0048 (0x0088 - 0x0040)
class UTextPropertyTestObject final : public UObject
{
public:
	class FText                                   DefaultedText;                                     // 0x0040(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   UndefaultedText;                                   // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   TransientText;                                     // 0x0070(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextPropertyTestObject">();
	}
	static class UTextPropertyTestObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextPropertyTestObject>();
	}
};
static_assert(alignof(UTextPropertyTestObject) == 0x000008, "Wrong alignment on UTextPropertyTestObject");
static_assert(sizeof(UTextPropertyTestObject) == 0x000088, "Wrong size on UTextPropertyTestObject");
static_assert(offsetof(UTextPropertyTestObject, DefaultedText) == 0x000040, "Member 'UTextPropertyTestObject::DefaultedText' has a wrong offset!");
static_assert(offsetof(UTextPropertyTestObject, UndefaultedText) == 0x000058, "Member 'UTextPropertyTestObject::UndefaultedText' has a wrong offset!");
static_assert(offsetof(UTextPropertyTestObject, TransientText) == 0x000070, "Member 'UTextPropertyTestObject::TransientText' has a wrong offset!");

// Class Engine.TextureLightProfile
// 0x0000 (0x112EA720 - 0x112EA720)
class UTextureLightProfile final : public UTexture2D
{
public:
	float                                         Brightness;                                        // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureMultiplier;                                 // 0x0154(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureLightProfile">();
	}
	static class UTextureLightProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureLightProfile>();
	}
};
static_assert(alignof(UTextureLightProfile) == 0x112EA720, "Wrong alignment on UTextureLightProfile");
static_assert(sizeof(UTextureLightProfile) == 0x112EA720, "Wrong size on UTextureLightProfile");
static_assert(offsetof(UTextureLightProfile, Brightness) == 0x000150, "Member 'UTextureLightProfile::Brightness' has a wrong offset!");
static_assert(offsetof(UTextureLightProfile, TextureMultiplier) == 0x000154, "Member 'UTextureLightProfile::TextureMultiplier' has a wrong offset!");

// Class Engine.TextureRenderTargetCube
// 0x2160 (0x112EAE80 - 0x112E8D20)
class UTextureRenderTargetCube final : public UTextureRenderTarget
{
public:
	int32                                         SizeX;                                             // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ClearColor;                                        // 0x0104(0x112EAE80)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPixelFormat                                  OverrideFormat;                                    // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHDR : 1;                                          // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceLinearGamma : 1;                             // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureRenderTargetCube">();
	}
	static class UTextureRenderTargetCube* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureRenderTargetCube>();
	}
};
static_assert(alignof(UTextureRenderTargetCube) == 0x112EAE80, "Wrong alignment on UTextureRenderTargetCube");
static_assert(sizeof(UTextureRenderTargetCube) == 0x112EAE80, "Wrong size on UTextureRenderTargetCube");
static_assert(offsetof(UTextureRenderTargetCube, SizeX) == 0x000100, "Member 'UTextureRenderTargetCube::SizeX' has a wrong offset!");
static_assert(offsetof(UTextureRenderTargetCube, ClearColor) == 0x000104, "Member 'UTextureRenderTargetCube::ClearColor' has a wrong offset!");
static_assert(offsetof(UTextureRenderTargetCube, OverrideFormat) == 0x000114, "Member 'UTextureRenderTargetCube::OverrideFormat' has a wrong offset!");

// Class Engine.TireType
// 0x0008 (0x0050 - 0x0048)
class UTireType final : public UDataAsset
{
public:
	float                                         FrictionScale;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TireType">();
	}
	static class UTireType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTireType>();
	}
};
static_assert(alignof(UTireType) == 0x000008, "Wrong alignment on UTireType");
static_assert(sizeof(UTireType) == 0x000050, "Wrong size on UTireType");
static_assert(offsetof(UTireType, FrictionScale) == 0x000048, "Member 'UTireType::FrictionScale' has a wrong offset!");

// Class Engine.TraceSplineInstanceMeshComponent
// 0x0000 (0xD38D - 0xD38D)
class UTraceSplineInstanceMeshComponent final : public UActorComponent
{
public:
	TArray<class UStaticMesh*>                    Meshes;                                            // 0x0200(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EInstanceMode                                 InstanceMode;                                      // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstancingRandomSeed;                              // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInstanceAlignment                            InstanceAlignment;                                 // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstanceAlignmentRandomSeed;                       // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInstancePattern                              InstancePattern;                                   // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstancePatternRandomSeed;                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SplitCount;                                        // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceCount;                                     // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       RepetitiveMotions;                                 // 0x0238(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RepetitiveMotionTime;                              // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstanceCanEverAffectNavigation;                  // 0x024C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x024D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x024E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F[0x61];                                     // 0x024F(0x0061)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Setup(class USplineComponent* SplineComponent, class UStaticMesh* StaticMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceSplineInstanceMeshComponent">();
	}
	static class UTraceSplineInstanceMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceSplineInstanceMeshComponent>();
	}
};
static_assert(alignof(UTraceSplineInstanceMeshComponent) == 0x00D38D, "Wrong alignment on UTraceSplineInstanceMeshComponent");
static_assert(sizeof(UTraceSplineInstanceMeshComponent) == 0x00D38D, "Wrong size on UTraceSplineInstanceMeshComponent");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, Meshes) == 0x000200, "Member 'UTraceSplineInstanceMeshComponent::Meshes' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstanceMode) == 0x000210, "Member 'UTraceSplineInstanceMeshComponent::InstanceMode' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstancingRandomSeed) == 0x000214, "Member 'UTraceSplineInstanceMeshComponent::InstancingRandomSeed' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstanceAlignment) == 0x000218, "Member 'UTraceSplineInstanceMeshComponent::InstanceAlignment' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstanceAlignmentRandomSeed) == 0x00021C, "Member 'UTraceSplineInstanceMeshComponent::InstanceAlignmentRandomSeed' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstancePattern) == 0x000220, "Member 'UTraceSplineInstanceMeshComponent::InstancePattern' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstancePatternRandomSeed) == 0x000224, "Member 'UTraceSplineInstanceMeshComponent::InstancePatternRandomSeed' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, SplitCount) == 0x000228, "Member 'UTraceSplineInstanceMeshComponent::SplitCount' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, InstanceCount) == 0x00022C, "Member 'UTraceSplineInstanceMeshComponent::InstanceCount' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, Scale) == 0x000230, "Member 'UTraceSplineInstanceMeshComponent::Scale' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, Speed) == 0x000234, "Member 'UTraceSplineInstanceMeshComponent::Speed' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, RepetitiveMotions) == 0x000238, "Member 'UTraceSplineInstanceMeshComponent::RepetitiveMotions' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, RepetitiveMotionTime) == 0x000248, "Member 'UTraceSplineInstanceMeshComponent::RepetitiveMotionTime' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, bInstanceCanEverAffectNavigation) == 0x00024C, "Member 'UTraceSplineInstanceMeshComponent::bInstanceCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, CollisionEnabled) == 0x00024D, "Member 'UTraceSplineInstanceMeshComponent::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(UTraceSplineInstanceMeshComponent, CastShadow) == 0x00024E, "Member 'UTraceSplineInstanceMeshComponent::CastShadow' has a wrong offset!");

// Class Engine.TwitterIntegrationBase
// 0x0000 (0x0050 - 0x0050)
class UTwitterIntegrationBase final : public UPlatformInterfaceBase
{
public:
	bool AuthorizeAccounts();
	bool CanShowTweetUI();
	class FString GetAccountName(int32 AccountIndex);
	int32 GetNumAccounts();
	void Init();
	bool ShowTweetUI(const class FString& InitialMessage, const class FString& URL, const class FString& Picture);
	bool TwitterRequest(const class FString& URL, const TArray<class FString>& ParamKeysAndValues, ETwitterRequestMethod RequestMethod, int32 AccountIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwitterIntegrationBase">();
	}
	static class UTwitterIntegrationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwitterIntegrationBase>();
	}
};
static_assert(alignof(UTwitterIntegrationBase) == 0x000008, "Wrong alignment on UTwitterIntegrationBase");
static_assert(sizeof(UTwitterIntegrationBase) == 0x000050, "Wrong size on UTwitterIntegrationBase");

// Class Engine.VectorFieldVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AVectorFieldVolume final : public AActor
{
public:
	class UVectorFieldComponent*                  VectorFieldComponent;                              // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VectorFieldVolume">();
	}
	static class AVectorFieldVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVectorFieldVolume>();
	}
};
static_assert(alignof(AVectorFieldVolume) == 0x1EF72E00, "Wrong alignment on AVectorFieldVolume");
static_assert(sizeof(AVectorFieldVolume) == 0x1EF72E00, "Wrong size on AVectorFieldVolume");
static_assert(offsetof(AVectorFieldVolume, VectorFieldComponent) == 0x0003E0, "Member 'AVectorFieldVolume::VectorFieldComponent' has a wrong offset!");

// Class Engine.VoiceChannel
// 0x0010 (0x0090 - 0x0080)
class UVoiceChannel final : public UChannel
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceChannel">();
	}
	static class UVoiceChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceChannel>();
	}
};
static_assert(alignof(UVoiceChannel) == 0x000008, "Wrong alignment on UVoiceChannel");
static_assert(sizeof(UVoiceChannel) == 0x000090, "Wrong size on UVoiceChannel");

// Class Engine.WindDirectionalSource
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AWindDirectionalSource final : public AInfo
{
public:
	class UWindDirectionalSourceComponent*        Component;                                         // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindDirectionalSource">();
	}
	static class AWindDirectionalSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindDirectionalSource>();
	}
};
static_assert(alignof(AWindDirectionalSource) == 0x1EF72E00, "Wrong alignment on AWindDirectionalSource");
static_assert(sizeof(AWindDirectionalSource) == 0x1EF72E00, "Wrong size on AWindDirectionalSource");
static_assert(offsetof(AWindDirectionalSource, Component) == 0x0003E0, "Member 'AWindDirectionalSource::Component' has a wrong offset!");

// Class Engine.WorldComposition
// 0x0040 (0x0080 - 0x0040)
class UWorldComposition final : public UObject
{
public:
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevelStreaming*>                TilesStreaming;                                    // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	double                                        TilesStreamingTimeThreshold;                       // 0x0070(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadAllTilesDuringCinematic;                      // 0x0078(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRebaseOriginIn3DSpace;                            // 0x0079(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RebaseOriginDistance;                              // 0x007C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldComposition">();
	}
	static class UWorldComposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldComposition>();
	}
};
static_assert(alignof(UWorldComposition) == 0x000008, "Wrong alignment on UWorldComposition");
static_assert(sizeof(UWorldComposition) == 0x000080, "Wrong size on UWorldComposition");
static_assert(offsetof(UWorldComposition, TilesStreaming) == 0x000060, "Member 'UWorldComposition::TilesStreaming' has a wrong offset!");
static_assert(offsetof(UWorldComposition, TilesStreamingTimeThreshold) == 0x000070, "Member 'UWorldComposition::TilesStreamingTimeThreshold' has a wrong offset!");
static_assert(offsetof(UWorldComposition, bLoadAllTilesDuringCinematic) == 0x000078, "Member 'UWorldComposition::bLoadAllTilesDuringCinematic' has a wrong offset!");
static_assert(offsetof(UWorldComposition, bRebaseOriginIn3DSpace) == 0x000079, "Member 'UWorldComposition::bRebaseOriginIn3DSpace' has a wrong offset!");
static_assert(offsetof(UWorldComposition, RebaseOriginDistance) == 0x00007C, "Member 'UWorldComposition::RebaseOriginDistance' has a wrong offset!");

}

