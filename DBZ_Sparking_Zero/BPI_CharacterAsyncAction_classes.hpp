#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_CharacterAsyncAction

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BPI_CharacterAsyncAction.BPI_CharacterAsyncAction_C
// 0x0000 (0x0028 - 0x0028)
class IBPI_CharacterAsyncAction_C final : public IInterface
{
public:
	void NotifyTransitionFlowAerialRush();
	void NotifyTransitionFlowAscertain();
	void NotifyTransitionFlowAttackOfDragonDashCounter();
	void NotifyTransitionFlowBaseReaction();
	void NotifyTransitionFlowBlast(const struct FKoratReplaceAnimationDataList& RequestAnimData);
	void NotifyTransitionFlowBlown();
	void NotifyTransitionFlowBlownBrakeOfDragonDashCounter();
	void NotifyTransitionFlowCannon();
	void NotifyTransitionFlowCannonAttack1();
	void NotifyTransitionFlowCannonAttack2();
	void NotifyTransitionFlowCannonAttack3();
	void NotifyTransitionFlowCannonSmash();
	void NotifyTransitionFlowCharge();
	void NotifyTransitionFlowDashBlow();
	void NotifyTransitionFlowDashOfDragonDashCounter();
	void NotifyTransitionFlowDashRising();
	void NotifyTransitionFlowDemo();
	void NotifyTransitionFlowDragonDash();
	void NotifyTransitionFlowDragonHoming();
	void NotifyTransitionFlowFastAvoidance();
	void NotifyTransitionFlowGrandSlash();
	void NotifyTransitionFlowGuard();
	void NotifyTransitionFlowGuardClear();
	void NotifyTransitionFlowHeavyCrush1();
	void NotifyTransitionFlowHeavyCrush2();
	void NotifyTransitionFlowHeavyCrush3();
	void NotifyTransitionFlowHeavyFinish();
	void NotifyTransitionFlowIdle();
	void NotifyTransitionFlowKidan();
	void NotifyTransitionFlowLiftStrike();
	void NotifyTransitionFlowLocomotion();
	void NotifyTransitionFlowMidAirKick();
	void NotifyTransitionFlowNoContinuation();
	void NotifyTransitionFlowParry();
	void NotifyTransitionFlowParrySmash();
	void NotifyTransitionFlowPlayAction(const struct FKoratActionDataList& InAction);
	void NotifyTransitionFlowRevengeCounter(const struct FKoratReplaceAnimationDataList& InReplaceAnim);
	void NotifyTransitionFlowRollingHammer(bool IsPreviousUseLeft);
	void NotifyTransitionFlowRollingHurricane1(bool IsLeft);
	void NotifyTransitionFlowRollingHurricane2();
	void NotifyTransitionFlowRollingPress1();
	void NotifyTransitionFlowRollingPress2();
	void NotifyTransitionFlowRush(int32 RushType);
	void NotifyTransitionFlowShortDash();
	void NotifyTransitionFlowStepAvoidance();
	void NotifyTransitionFlowStepIn();
	void NotifyTransitionFlowSuperZCounterCatch();
	void NotifyTransitionFlowSuperZCounterPosture();
	void NotifyTransitionFlowSuperZCounterShakeOff();
	void NotifyTransitionFlowSuperZCounterSmash();
	void NotifyTransitionFlowTeleportationCounter();
	void NotifyTransitionFlowThrow();
	void NotifyTransitionFlowUltimateBlast();
	void NotifyTransitionFlowVanishingAssault();
	void NotifyTransitionFlowVanishingAttack(const struct FKoratReplaceAnimationDataList& InReplaceAnim);
	void NotifyTransitionFlowWaitMontageEnd();
	void NotifyTransitionFlowZCounter();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BPI_CharacterAsyncAction_C">();
	}
	static class IBPI_CharacterAsyncAction_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_CharacterAsyncAction_C>();
	}
};
static_assert(alignof(IBPI_CharacterAsyncAction_C) == 0x000008, "Wrong alignment on IBPI_CharacterAsyncAction_C");
static_assert(sizeof(IBPI_CharacterAsyncAction_C) == 0x000028, "Wrong size on IBPI_CharacterAsyncAction_C");

}

