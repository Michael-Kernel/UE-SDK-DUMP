#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Character

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "SS_structs.hpp"
#include "SS_classes.hpp"
#include "EKoratCharacterEffectColorSetDataEnum_structs.hpp"
#include "EBattleKey_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_Character.BP_Character_C
// 0x0980 (0x3D30 - 0x33B0)
#pragma pack(push, 0x1)
class alignas(0x10) ABP_Character_C : public ASSCharacter
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x33B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UBP_CharacterBattleAssistComponent_C*   BP_CharacterBattleAssistComponent;                 // 0x33B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterThrowSafeMoveComponent_C*  BP_CharacterThrowSafeMoveComponent;                // 0x33C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USSAiCharacterStatusComponent*          SSAiCharacterStatus;                               // 0x33C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SSCharacterStencilComponent_C*      BP_SSCharacterStencilComponent;                    // 0x33D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterOutlineColorComponent_C*   BP_CharacterOutlineColorComponent;                 // 0x33D8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterKawaiiPhysicsComponent_C*  BP_CharacterKawaiiPhysicsComponent;                // 0x33E0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterSplineComponent_C*         BP_CharacterLocomotionSplineComponent;             // 0x33E8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterUIActionComponent_C*       BP_CharacterUIActionComponent;                     // 0x33F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UChildActorComponent*                   VirtualTargetPawn;                                 // 0x33F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        VirtualTargetOffsfset;                             // 0x3400(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_TriggerImpactGameComponent_C*       BP_TriggerImpactGameComponent;                     // 0x3408(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SSEffectHighSpeedMoveComponent_C*   BP_SSEffectHighSpeedMoveComponent;                 // 0x3410(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USSCharacterAntiBulletComponent*        SSCharacterAntiBullet;                             // 0x3418(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SSCharacterDitherComponent_C*       BP_SSCharacterDitherComponent;                     // 0x3420(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SSCharacterAfterImageComponent_C*   BP_SSCharacterAfterImageComponent;                 // 0x3428(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterBlastBulletComponent_C*    BP_CharacterBlastBulletComponent;                  // 0x3430(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_HitCollisionComponent_C*            BP_HitCollisionComponent;                          // 0x3438(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_TransitionFlowComponent_C*          BP_TransitionFlowComponent;                        // 0x3440(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterGrappleComponent_C*        BP_CharacterGrappleComponent;                      // 0x3448(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SplineMeshTrailComponent_C*         BP_SplineMeshTrailComponent1;                      // 0x3450(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AppendentDrawComponent_C*           BP_AppendentDrawComponent;                         // 0x3458(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterSoundEffectComponent_C*    BP_CharacterSoundEffectComponent;                  // 0x3460(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SplineMeshTrailComponent_C*         BP_SplineMeshTrailComponent;                       // 0x3468(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterMontageComponent_C*        BP_CharacterMontageComponent;                      // 0x3470(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CharacterLocomotionComponent_C*     BP_CharacterLocomotionComponent;                   // 0x3478(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	EKoratCharacterEffectColorSetDataEnum         OutlineColorEnum;                                  // 0x3480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3481[0x7];                                     // 0x3481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DeltaSeconds;                                      // 0x3488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 VirtualTargetActor;                                // 0x3490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FVector                                VirtualTargetLocation;                             // 0x3498(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                KnockBackVector;                                   // 0x34B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FKoratHitBackMovementData              HitBackData;                                       // 0x34C8(0x02E0)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          IsKnockBackStart;                                  // 0x37A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsKnockBack;                                       // 0x37A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_37AA[0x6];                                     // 0x37AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StepHoldTimer;                                     // 0x37B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        StepMaxHoldTime;                                   // 0x37B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsVirtualTargetActorUseBattleTargetPawn;           // 0x37C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_37C1[0x7];                                     // 0x37C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKoratActionDataList>           RunningActionList;                                 // 0x37C8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	double                                        HitStop;                                           // 0x37D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        HitStopDelay;                                      // 0x37E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        HitTimeDilation;                                   // 0x37E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHitStop;                                         // 0x37F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_37F1[0xF];                                     // 0x37F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKoratHitEffectAfterHitStop            HitEffectAfterHitStop;                             // 0x3800(0x00A0)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	class UAnimInstance*                          SubActionAnimInstance;                             // 0x38A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	ECollisionEnabled                             CapsuleCollisionEnabled;                           // 0x38A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ECollisionEnabled                             MeshCollisionEnabled;                              // 0x38A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x38AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_38AB[0x1];                                     // 0x38AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CollisionDisableCount;                             // 0x38AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ASSCharacter*                           SSCharacter;                                       // 0x38B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStopCustomTimeDilationDemo;                      // 0x38B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_38B9[0x7];                                     // 0x38B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        EvacuationCustomTimeDilation;                      // 0x38C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsCannotOverwriteHitStop;                          // 0x38C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ECollisionResponse                            CharacterPushCollisionResponse;                    // 0x38C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_38CA[0x2];                                     // 0x38CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterPushDisableCount;                         // 0x38CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSpeedReset;                                      // 0x38D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_38D1[0x3];                                     // 0x38D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           BPCHRLocationColor;                                // 0x38D4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           BPCHRRotationColor;                                // 0x38E4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SetVisibleCharacterEffects;                        // 0x38F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseCharacterRotationPitch;                         // 0x38F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseCharacterRotationPitchLimit;                    // 0x38F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseCharacterRotationPitchInterp;                   // 0x38F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        CharacterRotationPitchMin;                         // 0x38F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        CharacterRotationPitchMax;                         // 0x3900(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        PitchInterpSpeed;                                  // 0x3908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UChildActorComponent*                   ChildDashRouteComponent;                           // 0x3910(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TArray<class FString>                         TransitionActionName;                              // 0x3918(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	double                                        TransitionActionDrawResetCount;                    // 0x3928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsDrawTransitionAction;                            // 0x3930(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3931[0x7];                                     // 0x3931(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UABP_Sub_Action_C*                      ABPSubAction;                                      // 0x3938(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         StartPlayerControllerID;                           // 0x3940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ___________;                                       // 0x3944(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EKoratDirection                               AttackHitAreaHorizontal;                           // 0x3945(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EKoratDirection                               AttackHitAreaVertical;                             // 0x3946(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsDebugDrawSmashLevel;                             // 0x3947(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WalkingMinus_8k__;                                 // 0x3948(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3949[0x3];                                     // 0x3949(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKoratDamageReactionDataList           Z_Bn___;                                           // 0x394C(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3954[0x4];                                     // 0x3954(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKoratHitBackMovementData              Z_Bn______;                                        // 0x3958(0x02E0)(Edit, BlueprintVisible)
	struct FKoratHitStopData                      Z_Bn_______;                                       // 0x3C38(0x0014)(Edit, BlueprintVisible, NoDestructor)
	ECollisionResponse                            MapHitCollisionResponse;                           // 0x3C4C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C4D[0x3];                                     // 0x3C4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapHitDisableCount;                                // 0x3C50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C54[0x4];                                     // 0x3C54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKoratSequencePlayInfo>         SequencePlayInfo;                                  // 0x3C58(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          IsSetVanishingHiddenSwitching;                     // 0x3C68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C69[0x7];                                     // 0x3C69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        VanishingPreAppearEffectTime;                      // 0x3C70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        VanishingPostAppearEffectTime;                     // 0x3C78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        VanishingMoveTime;                                 // 0x3C80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        VanishingDisappearEffectTime;                      // 0x3C88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EKoratCharacterEffectColorSetDataEnum         AuraColorEnum;                                     // 0x3C90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C91[0x7];                                     // 0x3C91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        HitStopDeltaSeconds;                               // 0x3C98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        HitStopWorldDeltaSeconds;                          // 0x3CA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CenterLocation;                                    // 0x3CA8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        RotateToCenterRemainingTime;                       // 0x3CC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsKnockBackDeceleration;                           // 0x3CC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3CC9[0x7];                                     // 0x3CC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        KnockBackDecelerationTime;                         // 0x3CD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsRequestTransitionBlastHitDemo;                   // 0x3CD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EKoratMapChangeType                           Map_Change_Type;                                   // 0x3CD9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EKoratMapChangeStartTiming                    In_Start_Timing;                                   // 0x3CDA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3CDB[0x5];                                     // 0x3CDB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CurrentActionElapsedTime;                          // 0x3CE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsResetHitStopOnDamage;                            // 0x3CE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3CE9[0x7];                                     // 0x3CE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        InputFreeCameraLastReleaseTime;                    // 0x3CF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        InputFreeCameraLastPressTime;                      // 0x3CF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              InputFreeCameraLastVector;                         // 0x3D00(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsEndHitStopDown;                                  // 0x3D10(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStopRotateToCenterRemaining;                     // 0x3D11(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3D12[0x6];                                     // 0x3D12(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        AddDownToRevivalTime;                              // 0x3D18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsDebugDrawDownValue;                              // 0x3D20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          RunningForceFinichVanishing;                       // 0x3D21(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void Add_Debug_Draw_Blow_Param(const struct FVector& InLocation, int32 InDrawType, double InHitTime, double InDrawDuration);
	void AddCharacterMovementInput(const struct FVector& WorldDirection, double Value);
	void AddChildDashRoute(class AActor** DashRouteActor);
	void AddCurrentActionElapsedTime(double InElapsedTime);
	bool AddHitBack(const struct FRotator& InHitBackRotation, const struct FKoratHitBackMovementData& InHitBackMovementData, const struct FKoratActionDataList& InAction);
	bool AddHitStop(const struct FKoratHitStopData& InHitStopData, const struct FKoratHitEffectAfterHitStop& InHitEffectAfterHitStop);
	void AnimNotifyInputParam(bool Enable);
	void AutoSetCharacterMovementModeToIdle(bool InIsValidSetWalking, bool* IsSet, EMovementMode* SetMovementMode_0);
	void BattleKeyHold(EKoratBattleKey InBattleKey, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyPush(EKoratBattleKey InBattleKey, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyRelease(EKoratBattleKey InBattleKey, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyTimeSincePush(EKoratBattleKey InBattleKey, float InTime, EKoratInequalitySignType InInequalitySign, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyTimeSincePushInAction(EKoratBattleKey InBattleKey, float InTime, EKoratInequalitySignType InInequalitySign, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyTimeSincePushInSection(EKoratBattleKey InBattleKey, float InTime, EKoratInequalitySignType InInequalitySign, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyTimeSinceRelease(EKoratBattleKey InBattleKey, float InTime, EKoratInequalitySignType InInequalitySign, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyTimeSinceReleaseInAction(EKoratBattleKey InBattleKey, float InTime, EKoratInequalitySignType InInequalitySign, ESSFlowConditionsJudgmentType* OutJudgment);
	void BattleKeyTimeSinceReleaseInSection(EKoratBattleKey InBattleKey, float InTime, EKoratInequalitySignType InInequalitySign, ESSFlowConditionsJudgmentType* OutJudgment);
	void BeginRotateToCenter(double TotalDuration);
	void BlowChangeDown();
	void CalcKnockBackVector(double VerticalAngle, double HorizontalAngle, double AngleToReduceTilt);
	void ChangedSectionCharacterActionSequenceActor(const struct FKoratActionDataList& InAction, const class FName InSectionName, const float InPlayRatio);
	bool ChangeReaction(const struct FKoratActionDataList& InAction);
	bool CheckBlastDemoBranchSpDeriveType(const struct FSSBlastDemoBranchCondition& InCondition);
	void CheckValidSetWalking(EMovementMode InMovementMode, bool InIsValidSetWalking, bool* IsValid);
	void ClearCharacterRotationPitch(bool InTeleportPhysics, bool* IsSuccessfully);
	void DebugDrawText(class UCanvas* Canvas, class APlayerController* PlayerController, float DPIScale);
	void DebugPrint();
	void DisableCharacterPush();
	void DisableCollision();
	void DisableMapHit();
	void DrawTransitionActionName(class UCanvas* InCanvas, double DPIScale);
	void EnableCharacterPush();
	void EnableCollision();
	void EnableMapHit();
	void EndRotateToCenter();
	void ExecForceFinishVanishing();
	void ExecResetHitStop();
	void ExecToonShadingEachCharacter(bool bConstruct);
	void ExecuteUbergraph_BP_Character(int32 EntryPoint);
	void FreeCameraTargetRotate(const struct FVector2D& InputVector);
	void FromBP_DestoryComponent(class UActorComponent* InDestoryComp);
	void GetAttackRotation(class AActor* InActor, struct FRotator* OutRotation);
	void GetBlowHitForecast(struct FVector* OutLocation, float* OutHitTime, struct FKoratMapAttributeDataList* OutMapAttribute, struct FVector* OutHitNormal);
	void GetBPCharacterLocomotionComponent(class UBP_CharacterLocomotionComponent_C** LocomotionComponent);
	void GetBPCharacterMontageComponent(class UBP_CharacterMontageComponent_C** Component);
	void GetCameraVirtualTargetLocation(struct FVector* Location);
	EMovementMode GetCharacterMovementModePrioritizeSaveFromBP();
	struct FKoratBlowReactionBrakeParameter GetCurrentHitBackBlowBrakeParameter();
	void GetDownValueLimitReactionParameter(struct FKoratDamageReactionDataList* OutDamageReactionDataList, struct FKoratHitBackMovementData* OutHitBackData, struct FKoratHitStopData* OutHitStopData);
	struct FKoratActionDataList GetGuardClearReaction(const struct FKoratActionDataList& InActionDataList);
	bool GetHighSpeedMovementForecast(struct FVector* OutLocation, struct FRotator* OutRotator, float* OutRemainingTime);
	void GetHitBackData(struct FKoratHitBackMovementData* HitBackData_0);
	void GetKnockBackVector(struct FVector* KnockBackVector_0);
	void GetKnockDownReactionParameter(struct FKoratDamageReactionDataList* OutDamageReactionDataList, struct FKoratHitBackMovementData* OutHitBackData, struct FKoratHitStopData* OutHitStopData);
	void GetLocomotionComponent(class UActorComponent** ActorComponent);
	void GetLocomotionSplineComponent(class UActorComponent** ActorComponent);
	void GetMontageComponent(class UActorComponent** ActorComponent);
	void GetReplaceSubInstance(class FName SubInstanceName, class FName* SubInstanceTagName, class UClass** SubInstanceClass);
	void GetRequestAnim(struct FFRequestAnimData* RequestAnimData);
	void GetSSCharacter(class ASSCharacter** SSCharacter_0);
	bool GetSuperHighSpeedMovementForecast(struct FVector* OutLocation, struct FRotator* OutRotator, float* OutRemainingTime);
	void GetUseCharacterRotationPitchDetail(bool* UsePitchLimit, bool* UsePitchInterp);
	bool GetVanishingTeleportForecast(struct FVector* OutLocation, struct FRotator* OutRotator, float* OutRemainingTime);
	class USSCharacterSwitchVisibilityAnimInstance* GetViewSwitchAnimInstance();
	void GetVirtualTargetLocation(struct FVector* Location);
	void GiantCharaBPCollisionPussingOverlapTestFuncImpl();
	void HighSpeedMovementAppear(class USSActionCameraDataAsset* InActionCamera, class USSActionCameraDataAsset* InOpponentActionCamera);
	void HighSpeedMovementDisappear(const EKoratFreeTimelineType TimeLineType, class USSActionCameraDataAsset* InActionCamera, class USSActionCameraDataAsset* InOpponentActionCamera);
	void HighSpeedMovementOmenToAppear(const EKoratFreeTimelineType TimeLineType);
	void Input_Free_Camera();
	void InputBattleKeyJustPressed(EBattleKey BattleKey);
	void InputBattleKeyJustReleased(EBattleKey BattleKey);
	void InputFreeCamera();
	void InputFreeCameraVector(const struct FVector2D& InputVector);
	void InputKoratBattleKeyDown(EKoratBattleKey BattleKey);
	void InputKoratBattleKeyJustPressed(EKoratBattleKey BattleKey);
	void InputKoratBattleKeyJustReleased(EKoratBattleKey BattleKey);
	void InputKoratBattleKeyUp(EKoratBattleKey BattleKey);
	bool IsCollisionEnable();
	void IsInputRestrictedToTargetRevengeSmash(EKoratBattleKey Key, double SincePressTime, bool* Restricted);
	bool IsMetBulletBlastHitDemoCondition();
	void IsNeedTurn(bool* IsNeedTurn_0);
	void IToonShading(bool Construction, class ABP_ToonScene_C* Scane);
	void JumpSectionOfPlayAction(const class FName InSectionName);
	void LatentEventPreBattleProduction(class USSCharacterLatentHelper* InLatentHelper);
	void NotifyPlayMontageLength(double MontageLength);
	void NotifyStartRevengeCounter();
	void NotifyTransitionFlowAerialRush();
	void NotifyTransitionFlowAscertain();
	void NotifyTransitionFlowAttackOfDragonDashCounter();
	void NotifyTransitionFlowBaseReaction();
	void NotifyTransitionFlowBlast(const struct FKoratReplaceAnimationDataList& RequestAnimData);
	void NotifyTransitionFlowBlown();
	void NotifyTransitionFlowBlownBrakeOfDragonDashCounter();
	void NotifyTransitionFlowCannon();
	void NotifyTransitionFlowCannonAttack1();
	void NotifyTransitionFlowCannonAttack2();
	void NotifyTransitionFlowCannonAttack3();
	void NotifyTransitionFlowCannonSmash();
	void NotifyTransitionFlowCharge();
	void NotifyTransitionFlowDashBlow();
	void NotifyTransitionFlowDashOfDragonDashCounter();
	void NotifyTransitionFlowDashRising();
	void NotifyTransitionFlowDemo();
	void NotifyTransitionFlowDragonDash();
	void NotifyTransitionFlowDragonHoming();
	void NotifyTransitionFlowFastAvoidance();
	void NotifyTransitionFlowGrandSlash();
	void NotifyTransitionFlowGuard();
	void NotifyTransitionFlowGuardClear();
	void NotifyTransitionFlowHeavyCrush1();
	void NotifyTransitionFlowHeavyCrush2();
	void NotifyTransitionFlowHeavyCrush3();
	void NotifyTransitionFlowHeavyFinish();
	void NotifyTransitionFlowIdle();
	void NotifyTransitionFlowKidan();
	void NotifyTransitionFlowLiftStrike();
	void NotifyTransitionFlowLocomotion();
	void NotifyTransitionFlowMidAirKick();
	void NotifyTransitionFlowNoContinuation();
	void NotifyTransitionFlowParry();
	void NotifyTransitionFlowParrySmash();
	void NotifyTransitionFlowPlayAction(const struct FKoratActionDataList& InAction);
	void NotifyTransitionFlowRevengeCounter(const struct FKoratReplaceAnimationDataList& InReplaceAnim);
	void NotifyTransitionFlowRollingHammer(bool IsPreviousUseLeft);
	void NotifyTransitionFlowRollingHurricane1(bool IsLeft);
	void NotifyTransitionFlowRollingHurricane2();
	void NotifyTransitionFlowRollingPress1();
	void NotifyTransitionFlowRollingPress2();
	void NotifyTransitionFlowRush(int32 RushType);
	void NotifyTransitionFlowShortDash();
	void NotifyTransitionFlowStepAvoidance();
	void NotifyTransitionFlowStepIn();
	void NotifyTransitionFlowSuperZCounterCatch();
	void NotifyTransitionFlowSuperZCounterPosture();
	void NotifyTransitionFlowSuperZCounterShakeOff();
	void NotifyTransitionFlowSuperZCounterSmash();
	void NotifyTransitionFlowTeleportationCounter();
	void NotifyTransitionFlowThrow();
	void NotifyTransitionFlowUltimateBlast();
	void NotifyTransitionFlowVanishingAssault();
	void NotifyTransitionFlowVanishingAttack(const struct FKoratReplaceAnimationDataList& InReplaceAnim);
	void NotifyTransitionFlowWaitMontageEnd();
	void NotifyTransitionFlowZCounter();
	void OnBeginMontageLevelSequence(const struct FKoratActionDataList& InAction);
	void OnCharacterGaveDamage(EKoratCharacterMovementTransition InMovementTransition, const bool bInHoming, const struct FKoratHitStopData& InHitStopData, const struct FKoratHitEffectAfterHitStop& InHitEffectAfterHitStop, const bool bInBlownAttack, const EKoratActionAttackType InAttackType, const ESituationOfOpponentWhenAttackHit InOpponentHitSituation, const struct FKoratActionDataList& InAttackAction);
	void OnCharacterGaveOffset(const struct FKoratHitStopData& InHitStopData, const struct FKoratHitEffectAfterHitStop& InHitEffectAfterHitStop, const ESituationOfOpponentWhenAttackHit InOpponentHitSituation);
	void OnCharacterReceivedOffset(const struct FRotator& InRotation, const struct FKoratHitBackMovementData& InHitBackData, const struct FKoratHitStopData& InHitStopData);
	void OnCharacterTookDamage(const struct FKoratActionDataList& InReactionAction, EKoratReactionDirection InReactionDirection, const struct FKoratAddtiveReactionParameter& InAddtiveReactionParameter);
	void OnCloseTimer();
	void OnEndDemo();
	void OnEndMapChange();
	void OnEndMontageLevelSequence(const struct FKoratActionDataList& InAction, EKoratCharacterActionFinishReason InActionFinishReason);
	void OnEndRequestAllAnim();
	void OnFinishImpact();
	void OnHitObjectCollisionOccured(const struct FKoratActionDataList& InAction);
	void OnHitObjectStopped(const struct FKoratActionDataList& InAction);
	void OnInputKoratBattleKeyDown(EKoratBattleKey InBattleKey);
	void OnInputKoratBattleKeyJustPressed(EKoratBattleKey InBattleKey);
	void OnInputKoratBattleKeyJustReleased(EKoratBattleKey InBattleKey);
	void OnInputKoratBattleKeyUp(EKoratBattleKey InBattleKey);
	void OnKoratCharacterDebug(const TArray<class FString>& InDebugCommand);
	void OnKoratCharacterDebugCommandDraw();
	void OnLanded(const struct FHitResult& Hit);
	void OnPlayAnim();
	void OnReturnToInGameFromDemo();
	void OnStartImpact();
	void OnStartMapChange(const EKoratMapChangeType InMapChangeType, const EKoratMapChangeStartTiming InStartTiming);
	void OnTransitActionByAnimationBlueprint(const struct FKoratActionDataList& InAction);
	void OnTransitActionByLocomotion(const struct FKoratActionDataList& InAction);
	void PlayKnockBack(const struct FKoratHitBackMovementData& InHitBackData);
	void ReceiveBeginPlay();
	void ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ReceivePossessed(class AController* NewController);
	void ReceiveTick(float DeltaSeconds_0);
	void ReflectRequestReactionDirection();
	void ReleasePlayAction();
	void RequestJumpSectionOfFlowAction(const struct FKoratActionDataList& InAction, const class FName InSectionName);
	void RequestTransitAction(const struct FKoratActionDataList& InAction);
	void RequestTransitionBlastHitDemo();
	void RequestTransitionOfFlowAction(const struct FKoratActionDataList& InBeforeAction, const struct FKoratActionDataList& InAfterAction);
	void ResetCurrentActionElapsedTime();
	void ResetHitStop();
	void Set_Hit_Stop(const struct FKoratHitStopDataList& InHitStopData, bool InResetOnDamage, bool InEndHitStopDown);
	void SetAttackHitArea(EKoratDirection InAttackHitAreaHorizontal, EKoratDirection InAttackHitAreaVertical);
	void SetAuraColorEnum(EKoratCharacterEffectColorSetDataEnum InNewColor);
	void SetBranchSection(const class FName& InSection);
	void SetCharacterMovementMode(EMovementMode InMovementMode);
	void SetCharacterRotation(const struct FRotator& InNewRotation, bool InTeleportPhysics, bool* IsSuccessfully);
	void SetEnableDrawTransitionAction(bool IsEnable);
	void SetHitStopOpponent(const struct FKoratHitStopData& InHitStopData, bool InResetOnDamage, bool InEndHitStopDown, bool* SetHitStop);
	void SetHitStopOwn(const struct FKoratHitStopData& InHitStopData, bool InResetOnDamage, bool InEndHitStopDown, bool* SetHitStop);
	void SetKnockBack(const struct FRotator& InRotation, const struct FKoratHitBackMovementData& InHitBackData);
	void SetOutlineColorEnum(EKoratCharacterEffectColorSetDataEnum InNewColorType);
	void SetupTickOrderDependsOnPlayerController();
	void SetUseCharacterRotationPitch(bool InUsePitch, bool* UsePitch);
	void SetUseCharacterRotationPitchDetail(bool InUsePitchLimit, bool InUsePitchInterp, bool* UsePitchLimit, bool* UsePitchInterp);
	void SetVanishingHiddenSwitchingTime_(double InDisappearTime, double InAppearTime);
	void SetVirtualTarget(class AActor* InActor, const struct FVector& InLocation, bool InUseBattleTargetPawn);
	void StartVanishing(const float InDisappearTime, const float InAppearTime, const struct FVector& InAppearPosition, const struct FRotator& InAppearDirection, const struct FKoratActionDataList& InAppearAction, const bool InTraining, const bool InDramaticWarp);
	void StopActionByChangeCharacter();
	void StopAllAction();
	void StopKnockBack();
	void StopPlayAction();
	void StopRotateToCenter();
	void SuccessRepelAction();
	bool TraceNearPhysicalAssetsCollition(const struct FVector& InStart, const struct FVector& InEnd, const float InRadius, const class AActor* InGaveDamageActor, const class AActor* InReceivedDamageActor, const class AActor* InRotateActor, struct FTransform* OutHitTransform, class FName* OutHitBoneName, const TArray<EObjectTypeQuery>& ObjectTypes, const ETraceTypeQuery TraceType);
	bool TraceNearPhysicalAssetsCollitionByBox(const struct FVector& InStart, const struct FVector& InEnd, const struct FVector& InHalfSize, const struct FRotator& InOrientation, const class AActor* InGaveDamageActor, const class AActor* InReceivedDamageActor, const class AActor* InRotateActor, struct FTransform* OutHitTransform, class FName* OutHitBoneName, const TArray<EObjectTypeQuery>& ObjectTypes);
	float TransitAction(const struct FKoratActionDataList& InAction);
	float TransitActionFromSection(const struct FKoratActionDataList& InAction, class FName InJumpSectionName);
	void TransitionAscertain_254B687548ED1A43B215459291C501AA();
	void TransitionBlast_B0EB4F39407C5C0D6888C494C00D2709();
	void TransitionBurstSmash_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionBurstSmashDown_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionBurstSmashLeft_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionBurstSmashRight_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionBurstSmashUp_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionCannonAttack_388B9AE142B072AAF0D80FA5E9BEF139();
	void TransitionCannonAttack_E842F8FD40E51FAD00DA8CB0CEF5D58D();
	void TransitionCannonAttack_F1BD20AE4B63558A26345B87CA535025();
	void TransitionCannonSmash_388B9AE142B072AAF0D80FA5E9BEF139();
	void TransitionCatch_CBCC57694C1B36202F8BE88662BB9DD8(const struct FKoratReplaceAnimationDataList& OutAnimDataList);
	void TransitionDashAttack_5FE2682B4EC156B63CF1D8876153BA1D();
	void TransitionDashBlow_2AB11A7941A895F93D4343AB3488B382();
	void TransitionDashDragon_B0EB4F39407C5C0D6888C494C00D2709();
	void TransitionDashRising_2AB11A7941A895F93D4343AB3488B382();
	void TransitionDragonDashAttack_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionDragonDashAttackDown_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionDragonDashAttackLeft_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionDragonDashAttackRight_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionDragonDashAttackUp_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionDragonSmash_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionDragonSmashDown_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionDragonSmashLeft_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionDragonSmashRight_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionDragonSmashUp_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionEnd_3CC26A4F45171230A00C6A9C274FEDD9();
	void TransitionEnd_E1E814A54A0E3FFEDB2EEF945EC120F9();
	void TransitionEnergyBulletRepel_254B687548ED1A43B215459291C501AA();
	void TransitionFastAvoidance_254B687548ED1A43B215459291C501AA();
	void TransitionGuard_6988BB3344CF3DF7A9E3D7AC2DF2AC63();
	void TransitionHeavyCrush_03275ED54B81638A3DF7099A29AE6BD6();
	void TransitionHeavyCrush_7AC370CA44CD9C44513F8B821231DE7C();
	void TransitionHeavyCrush_F42B88F7480DF500E48A8DB4206E0C54();
	void TransitionHomingJump_85F09CE34E7A0A65788E76A9A685A818();
	void TransitionNone_03275ED54B81638A3DF7099A29AE6BD6();
	void TransitionNone_04D348C841DCE3D0F950179A7C65A51E();
	void TransitionNone_071FBF3F44013C6A2BFACAAB8CB72D3B();
	void TransitionNone_0F5119A048B79D8214092D8460AFEB2F();
	void TransitionNone_12E5A0FC4C1598A4759FF2B31C6C36CE();
	void TransitionNone_1CFA30FF4B42C4256AD1E48D166666CB();
	void TransitionNone_254B687548ED1A43B215459291C501AA();
	void TransitionNone_2AB11A7941A895F93D4343AB3488B382();
	void TransitionNone_303F61EF474A64D4D300D3818BE9C55A();
	void TransitionNone_333FAF1B48CD20D132E53C8BA9BBA2E2();
	void TransitionNone_388B9AE142B072AAF0D80FA5E9BEF139();
	void TransitionNone_41FAAFD44DDBA982DF12688169A70D88();
	void TransitionNone_42F3D29645DFB64B0E78C78BDDA70BF0();
	void TransitionNone_43D19F5E4047C6794427FAA36432DFC0();
	void TransitionNone_48E10D1E437F71053B9AA686CBBFBE0C();
	void TransitionNone_48FF52D442A542190BC8B9A65EA7E141();
	void TransitionNone_495C4AF242B8B7682C886A9E047A6EBA();
	void TransitionNone_4C94A6BD4C6F775AD3A7BC9A4E82EBB0();
	void TransitionNone_503FD95B4EA5CAC6BE89218EEAA4AAA8();
	void TransitionNone_50D4DECE4DCDD7C61369028D47509D51();
	void TransitionNone_5517D8534FA76330609FEE87A5138F0E();
	void TransitionNone_558C133A48D45FF5464878BE624259BB();
	void TransitionNone_5FE2682B4EC156B63CF1D8876153BA1D();
	void TransitionNone_60FD665940DDA18CB065239EC38AE090();
	void TransitionNone_663C481D4233D0ED5D7259B0F45D482B();
	void TransitionNone_6988BB3344CF3DF7A9E3D7AC2DF2AC63();
	void TransitionNone_6E5157DA4CEAAEC7F5160AB16437F8AC();
	void TransitionNone_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionNone_7A0735F84F6E0715A2FE4E94B4F5224F();
	void TransitionNone_7AC370CA44CD9C44513F8B821231DE7C();
	void TransitionNone_81A64D43466AC942858887B79205688F();
	void TransitionNone_85F09CE34E7A0A65788E76A9A685A818();
	void TransitionNone_8C46AFEE4CFF99CFCD9247BD2E30A82E();
	void TransitionNone_94E8FB094FDEA3B471FC43895F89E13A();
	void TransitionNone_962DFCA04ACD95A24114F7BA68B5B08B();
	void TransitionNone_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionNone_A21D327B4A1B1E35BE80F696FC215EE9();
	void TransitionNone_A8A53AE2431CC23EE304FD82AC664727();
	void TransitionNone_B0EB4F39407C5C0D6888C494C00D2709();
	void TransitionNone_B47C7C0C45D6159A9255B899C2F3AB28();
	void TransitionNone_BFAD0FF4457BEB9914F785920E8BAD92();
	void TransitionNone_C46B6CA2445F54C259DAB5882478BD79();
	void TransitionNone_CBCC57694C1B36202F8BE88662BB9DD8(const struct FKoratReplaceAnimationDataList& OutAnimDataList);
	void TransitionNone_D3E15A18479B45452774B68ECF576F30();
	void TransitionNone_E2170F9F4032446BE3D679A93194A7FC();
	void TransitionNone_E4D793DA4A13B21EECFA0499E73CC831();
	void TransitionNone_E842F8FD40E51FAD00DA8CB0CEF5D58D();
	void TransitionNone_EB1D5ABE4C9B60566419E2B9492CA683();
	void TransitionNone_F0DD079841DD68440795F6ABEA85FD0F();
	void TransitionNone_F1BD20AE4B63558A26345B87CA535025();
	void TransitionNone_F42B88F7480DF500E48A8DB4206E0C54();
	void TransitionNone_FF3C7EB54091ABEECA3567B0BB0BE4D5();
	void TransitionParry_BFAD0FF4457BEB9914F785920E8BAD92();
	void TransitionParrySmash_50D4DECE4DCDD7C61369028D47509D51();
	void TransitionReaction_03275ED54B81638A3DF7099A29AE6BD6();
	void TransitionReaction_04D348C841DCE3D0F950179A7C65A51E();
	void TransitionReaction_071FBF3F44013C6A2BFACAAB8CB72D3B();
	void TransitionReaction_0F5119A048B79D8214092D8460AFEB2F();
	void TransitionReaction_12E5A0FC4C1598A4759FF2B31C6C36CE();
	void TransitionReaction_1CFA30FF4B42C4256AD1E48D166666CB();
	void TransitionReaction_254B687548ED1A43B215459291C501AA();
	void TransitionReaction_2AB11A7941A895F93D4343AB3488B382();
	void TransitionReaction_303F61EF474A64D4D300D3818BE9C55A();
	void TransitionReaction_333FAF1B48CD20D132E53C8BA9BBA2E2();
	void TransitionReaction_388B9AE142B072AAF0D80FA5E9BEF139();
	void TransitionReaction_41FAAFD44DDBA982DF12688169A70D88();
	void TransitionReaction_42F3D29645DFB64B0E78C78BDDA70BF0();
	void TransitionReaction_43D19F5E4047C6794427FAA36432DFC0();
	void TransitionReaction_48E10D1E437F71053B9AA686CBBFBE0C();
	void TransitionReaction_48FF52D442A542190BC8B9A65EA7E141();
	void TransitionReaction_495C4AF242B8B7682C886A9E047A6EBA();
	void TransitionReaction_4C94A6BD4C6F775AD3A7BC9A4E82EBB0();
	void TransitionReaction_503FD95B4EA5CAC6BE89218EEAA4AAA8();
	void TransitionReaction_50D4DECE4DCDD7C61369028D47509D51();
	void TransitionReaction_5517D8534FA76330609FEE87A5138F0E();
	void TransitionReaction_558C133A48D45FF5464878BE624259BB();
	void TransitionReaction_5FE2682B4EC156B63CF1D8876153BA1D();
	void TransitionReaction_60FD665940DDA18CB065239EC38AE090();
	void TransitionReaction_663C481D4233D0ED5D7259B0F45D482B();
	void TransitionReaction_6988BB3344CF3DF7A9E3D7AC2DF2AC63();
	void TransitionReaction_6E5157DA4CEAAEC7F5160AB16437F8AC();
	void TransitionReaction_79B5EE4542D9F939C8B5C48FE58AC647();
	void TransitionReaction_7A0735F84F6E0715A2FE4E94B4F5224F();
	void TransitionReaction_7AC370CA44CD9C44513F8B821231DE7C();
	void TransitionReaction_81A64D43466AC942858887B79205688F();
	void TransitionReaction_85F09CE34E7A0A65788E76A9A685A818();
	void TransitionReaction_8C46AFEE4CFF99CFCD9247BD2E30A82E();
	void TransitionReaction_94E8FB094FDEA3B471FC43895F89E13A();
	void TransitionReaction_962DFCA04ACD95A24114F7BA68B5B08B();
	void TransitionReaction_9F6A90CA4282CD9B3E105F98DC36DBE2();
	void TransitionReaction_A21D327B4A1B1E35BE80F696FC215EE9();
	void TransitionReaction_A8A53AE2431CC23EE304FD82AC664727();
	void TransitionReaction_B0EB4F39407C5C0D6888C494C00D2709();
	void TransitionReaction_B47C7C0C45D6159A9255B899C2F3AB28();
	void TransitionReaction_BFAD0FF4457BEB9914F785920E8BAD92();
	void TransitionReaction_C46B6CA2445F54C259DAB5882478BD79();
	void TransitionReaction_CBCC57694C1B36202F8BE88662BB9DD8();
	void TransitionReaction_D3E15A18479B45452774B68ECF576F30();
	void TransitionReaction_E2170F9F4032446BE3D679A93194A7FC();
	void TransitionReaction_E4D793DA4A13B21EECFA0499E73CC831();
	void TransitionReaction_E842F8FD40E51FAD00DA8CB0CEF5D58D();
	void TransitionReaction_EB1D5ABE4C9B60566419E2B9492CA683();
	void TransitionReaction_F0DD079841DD68440795F6ABEA85FD0F();
	void TransitionReaction_F1BD20AE4B63558A26345B87CA535025();
	void TransitionReaction_F42B88F7480DF500E48A8DB4206E0C54();
	void TransitionReaction_FF3C7EB54091ABEECA3567B0BB0BE4D5();
	void TransitionRollingHurricane_962DFCA04ACD95A24114F7BA68B5B08B();
	void TransitionRollingHurricane_A21D327B4A1B1E35BE80F696FC215EE9();
	void TransitionRollingHurricane_A8A53AE2431CC23EE304FD82AC664727();
	void TransitionRollingHurricane_E4D793DA4A13B21EECFA0499E73CC831();
	void TransitionRollingPress_81A64D43466AC942858887B79205688F();
	void TransitionRollingPress_962DFCA04ACD95A24114F7BA68B5B08B();
	void TransitionRollingPress_A21D327B4A1B1E35BE80F696FC215EE9();
	void TransitionRush_04D348C841DCE3D0F950179A7C65A51E();
	void TransitionRush_12E5A0FC4C1598A4759FF2B31C6C36CE();
	void TransitionRush_1CFA30FF4B42C4256AD1E48D166666CB();
	void TransitionRush_2AB11A7941A895F93D4343AB3488B382();
	void TransitionRush_333FAF1B48CD20D132E53C8BA9BBA2E2();
	void TransitionRush_388B9AE142B072AAF0D80FA5E9BEF139();
	void TransitionRush_43D19F5E4047C6794427FAA36432DFC0();
	void TransitionRush_48FF52D442A542190BC8B9A65EA7E141();
	void TransitionRush_4C94A6BD4C6F775AD3A7BC9A4E82EBB0();
	void TransitionRush_558C133A48D45FF5464878BE624259BB();
	void TransitionRush_60FD665940DDA18CB065239EC38AE090();
	void TransitionRush_7A0735F84F6E0715A2FE4E94B4F5224F();
	void TransitionRush_962DFCA04ACD95A24114F7BA68B5B08B();
	void TransitionRush_A21D327B4A1B1E35BE80F696FC215EE9();
	void TransitionRush_B47C7C0C45D6159A9255B899C2F3AB28();
	void TransitionRush_C46B6CA2445F54C259DAB5882478BD79();
	void TransitionRush_E2170F9F4032446BE3D679A93194A7FC();
	void TransitionRush_F42B88F7480DF500E48A8DB4206E0C54();
	void TransitionShakeOff_495C4AF242B8B7682C886A9E047A6EBA();
	void TransitionSkill_B0EB4F39407C5C0D6888C494C00D2709();
	void TransitionSmash_48E10D1E437F71053B9AA686CBBFBE0C();
	void TransitionSonicSway_BFAD0FF4457BEB9914F785920E8BAD92();
	void TransitionStep_254B687548ED1A43B215459291C501AA();
	void TransitionSuperZCounter_254B687548ED1A43B215459291C501AA();
	void TransitionThrow_254B687548ED1A43B215459291C501AA();
	void TransitionVanishingAssault_254B687548ED1A43B215459291C501AA();
	void UpdateChche();
	void UpdateFreeCameraTarget(const struct FVector2D& InputVector);
	void UpdateGiantCharaTargetTransformNearestTargetTestOverride(bool bInForceSearchNearParts);
	void UpdateGiantCharaTargetTransformNearestTargetTestOverrideImpl(bool InForceSearchNearParts);
	void UpdateInput();
	void UpdateRotateToCenter();
	void UpdateVanishingHiddenSwitching();
	void VanishingFinish();
	void VanishingPlayEffect();
	void VanishingTransport();

	void CalcCorrectionTowardCenterYaw(const struct FVector& InVector, const struct FVector& InRotationPosition, double InCorrectionTowardCenter, double* OutYaw) const;
	struct FRotator CalcHitBackRotation(const struct FRotator& InHitRotation, const struct FKoratHitBackMovementData& InHitBackData) const;
	void DebugDrawHitArea(float InHitHeightRate, const struct FVector& InCharacterUpVector, const struct FVector& InHitLocation) const;
	struct FKoratDamageReactionDataList DecideDamageReactionByActionCategory(const struct FKoratDamageReactionDataList& InDamageReactionDataList) const;
	struct FKoratActionDataList GetBlastDefaultDemoAction(EKoratBlastSlotType InBlastSlot) const;
	struct FKoratActionDataList GetBlastSIAction(const ESSBlastDemoBranchType InBranchType, const EKoratBlastSlotType InBlastSlot) const;
	void GetCharacterMovementMode(EMovementMode* MovementMode) const;
	void GetCharacterRotation(struct FRotator* Rotation) const;
	void GetCorrectionTowardCenterDirection(const struct FVector& InVector, double InCorrectionTowardCenter, EKoratDirection* CenterDirection) const;
	float GetCurrentActionElapsedTime() const;
	double GetDebugDrawHitAreaTime() const;
	void GetFindFloor(struct FFindFloorResult* FloorResult) const;
	TArray<struct FVector> GetGiantCharaTargetLocations() const;
	class APawn* GetHomingLocationPawn() const;
	class UKoratKawaiiPhysicsComponent* GetKawaiiPhysicsComponent() const;
	struct FKoratActionDataList GetRequestTransitAction() const;
	void GetRunningActionList(TArray<struct FKoratActionDataList>* OutActionList, EKoratCharacterLocomotionDetailStatus* OutLocomotionDetailStatus) const;
	void GetUseCharacterRotationPitch(bool* UsePitch) const;
	int32 GetViewSwitchFaceMeshVisibilityValue() const;
	bool IsActionStandby() const;
	bool IsDebugDrawHitArea() const;
	bool IsDisableLipSync() const;
	bool IsGuardSuccessByParameter(const struct FKoratCharacterCombativesParameter& InParameter, bool* OutIsGuardBreak, bool* OutIsAttackBreak, bool* OutIsImpossibleGuard) const;
	void IsUseHitStop(bool* IsUseHitStop_0) const;
	bool IsVanishing() const;
	bool IsWaitRequestTransitAction() const;
	void SetChartsVariable(const float InValueA, const float InValueB, const float InLogVolume) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_Character_C">();
	}
	static class ABP_Character_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_Character_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABP_Character_C) == 0x000010, "Wrong alignment on ABP_Character_C");
static_assert(sizeof(ABP_Character_C) == 0x003D30, "Wrong size on ABP_Character_C");
static_assert(offsetof(ABP_Character_C, UberGraphFrame) == 0x0033B0, "Member 'ABP_Character_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterBattleAssistComponent) == 0x0033B8, "Member 'ABP_Character_C::BP_CharacterBattleAssistComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterThrowSafeMoveComponent) == 0x0033C0, "Member 'ABP_Character_C::BP_CharacterThrowSafeMoveComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, SSAiCharacterStatus) == 0x0033C8, "Member 'ABP_Character_C::SSAiCharacterStatus' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_SSCharacterStencilComponent) == 0x0033D0, "Member 'ABP_Character_C::BP_SSCharacterStencilComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterOutlineColorComponent) == 0x0033D8, "Member 'ABP_Character_C::BP_CharacterOutlineColorComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterKawaiiPhysicsComponent) == 0x0033E0, "Member 'ABP_Character_C::BP_CharacterKawaiiPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterLocomotionSplineComponent) == 0x0033E8, "Member 'ABP_Character_C::BP_CharacterLocomotionSplineComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterUIActionComponent) == 0x0033F0, "Member 'ABP_Character_C::BP_CharacterUIActionComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VirtualTargetPawn) == 0x0033F8, "Member 'ABP_Character_C::VirtualTargetPawn' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VirtualTargetOffsfset) == 0x003400, "Member 'ABP_Character_C::VirtualTargetOffsfset' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_TriggerImpactGameComponent) == 0x003408, "Member 'ABP_Character_C::BP_TriggerImpactGameComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_SSEffectHighSpeedMoveComponent) == 0x003410, "Member 'ABP_Character_C::BP_SSEffectHighSpeedMoveComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, SSCharacterAntiBullet) == 0x003418, "Member 'ABP_Character_C::SSCharacterAntiBullet' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_SSCharacterDitherComponent) == 0x003420, "Member 'ABP_Character_C::BP_SSCharacterDitherComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_SSCharacterAfterImageComponent) == 0x003428, "Member 'ABP_Character_C::BP_SSCharacterAfterImageComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterBlastBulletComponent) == 0x003430, "Member 'ABP_Character_C::BP_CharacterBlastBulletComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_HitCollisionComponent) == 0x003438, "Member 'ABP_Character_C::BP_HitCollisionComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_TransitionFlowComponent) == 0x003440, "Member 'ABP_Character_C::BP_TransitionFlowComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterGrappleComponent) == 0x003448, "Member 'ABP_Character_C::BP_CharacterGrappleComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_SplineMeshTrailComponent1) == 0x003450, "Member 'ABP_Character_C::BP_SplineMeshTrailComponent1' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_AppendentDrawComponent) == 0x003458, "Member 'ABP_Character_C::BP_AppendentDrawComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterSoundEffectComponent) == 0x003460, "Member 'ABP_Character_C::BP_CharacterSoundEffectComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_SplineMeshTrailComponent) == 0x003468, "Member 'ABP_Character_C::BP_SplineMeshTrailComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterMontageComponent) == 0x003470, "Member 'ABP_Character_C::BP_CharacterMontageComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BP_CharacterLocomotionComponent) == 0x003478, "Member 'ABP_Character_C::BP_CharacterLocomotionComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, OutlineColorEnum) == 0x003480, "Member 'ABP_Character_C::OutlineColorEnum' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, DeltaSeconds) == 0x003488, "Member 'ABP_Character_C::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VirtualTargetActor) == 0x003490, "Member 'ABP_Character_C::VirtualTargetActor' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VirtualTargetLocation) == 0x003498, "Member 'ABP_Character_C::VirtualTargetLocation' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, KnockBackVector) == 0x0034B0, "Member 'ABP_Character_C::KnockBackVector' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitBackData) == 0x0034C8, "Member 'ABP_Character_C::HitBackData' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsKnockBackStart) == 0x0037A8, "Member 'ABP_Character_C::IsKnockBackStart' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsKnockBack) == 0x0037A9, "Member 'ABP_Character_C::IsKnockBack' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, StepHoldTimer) == 0x0037B0, "Member 'ABP_Character_C::StepHoldTimer' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, StepMaxHoldTime) == 0x0037B8, "Member 'ABP_Character_C::StepMaxHoldTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsVirtualTargetActorUseBattleTargetPawn) == 0x0037C0, "Member 'ABP_Character_C::IsVirtualTargetActorUseBattleTargetPawn' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, RunningActionList) == 0x0037C8, "Member 'ABP_Character_C::RunningActionList' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitStop) == 0x0037D8, "Member 'ABP_Character_C::HitStop' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitStopDelay) == 0x0037E0, "Member 'ABP_Character_C::HitStopDelay' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitTimeDilation) == 0x0037E8, "Member 'ABP_Character_C::HitTimeDilation' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsHitStop) == 0x0037F0, "Member 'ABP_Character_C::IsHitStop' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitEffectAfterHitStop) == 0x003800, "Member 'ABP_Character_C::HitEffectAfterHitStop' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, SubActionAnimInstance) == 0x0038A0, "Member 'ABP_Character_C::SubActionAnimInstance' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CapsuleCollisionEnabled) == 0x0038A8, "Member 'ABP_Character_C::CapsuleCollisionEnabled' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, MeshCollisionEnabled) == 0x0038A9, "Member 'ABP_Character_C::MeshCollisionEnabled' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CollisionEnabled) == 0x0038AA, "Member 'ABP_Character_C::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CollisionDisableCount) == 0x0038AC, "Member 'ABP_Character_C::CollisionDisableCount' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, SSCharacter) == 0x0038B0, "Member 'ABP_Character_C::SSCharacter' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsStopCustomTimeDilationDemo) == 0x0038B8, "Member 'ABP_Character_C::IsStopCustomTimeDilationDemo' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, EvacuationCustomTimeDilation) == 0x0038C0, "Member 'ABP_Character_C::EvacuationCustomTimeDilation' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsCannotOverwriteHitStop) == 0x0038C8, "Member 'ABP_Character_C::IsCannotOverwriteHitStop' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CharacterPushCollisionResponse) == 0x0038C9, "Member 'ABP_Character_C::CharacterPushCollisionResponse' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CharacterPushDisableCount) == 0x0038CC, "Member 'ABP_Character_C::CharacterPushDisableCount' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsSpeedReset) == 0x0038D0, "Member 'ABP_Character_C::IsSpeedReset' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BPCHRLocationColor) == 0x0038D4, "Member 'ABP_Character_C::BPCHRLocationColor' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, BPCHRRotationColor) == 0x0038E4, "Member 'ABP_Character_C::BPCHRRotationColor' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, SetVisibleCharacterEffects) == 0x0038F4, "Member 'ABP_Character_C::SetVisibleCharacterEffects' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, UseCharacterRotationPitch) == 0x0038F5, "Member 'ABP_Character_C::UseCharacterRotationPitch' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, UseCharacterRotationPitchLimit) == 0x0038F6, "Member 'ABP_Character_C::UseCharacterRotationPitchLimit' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, UseCharacterRotationPitchInterp) == 0x0038F7, "Member 'ABP_Character_C::UseCharacterRotationPitchInterp' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CharacterRotationPitchMin) == 0x0038F8, "Member 'ABP_Character_C::CharacterRotationPitchMin' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CharacterRotationPitchMax) == 0x003900, "Member 'ABP_Character_C::CharacterRotationPitchMax' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, PitchInterpSpeed) == 0x003908, "Member 'ABP_Character_C::PitchInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, ChildDashRouteComponent) == 0x003910, "Member 'ABP_Character_C::ChildDashRouteComponent' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, TransitionActionName) == 0x003918, "Member 'ABP_Character_C::TransitionActionName' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, TransitionActionDrawResetCount) == 0x003928, "Member 'ABP_Character_C::TransitionActionDrawResetCount' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsDrawTransitionAction) == 0x003930, "Member 'ABP_Character_C::IsDrawTransitionAction' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, ABPSubAction) == 0x003938, "Member 'ABP_Character_C::ABPSubAction' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, StartPlayerControllerID) == 0x003940, "Member 'ABP_Character_C::StartPlayerControllerID' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, ___________) == 0x003944, "Member 'ABP_Character_C::___________' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, AttackHitAreaHorizontal) == 0x003945, "Member 'ABP_Character_C::AttackHitAreaHorizontal' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, AttackHitAreaVertical) == 0x003946, "Member 'ABP_Character_C::AttackHitAreaVertical' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsDebugDrawSmashLevel) == 0x003947, "Member 'ABP_Character_C::IsDebugDrawSmashLevel' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, WalkingMinus_8k__) == 0x003948, "Member 'ABP_Character_C::WalkingMinus_8k__' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, Z_Bn___) == 0x00394C, "Member 'ABP_Character_C::Z_Bn___' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, Z_Bn______) == 0x003958, "Member 'ABP_Character_C::Z_Bn______' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, Z_Bn_______) == 0x003C38, "Member 'ABP_Character_C::Z_Bn_______' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, MapHitCollisionResponse) == 0x003C4C, "Member 'ABP_Character_C::MapHitCollisionResponse' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, MapHitDisableCount) == 0x003C50, "Member 'ABP_Character_C::MapHitDisableCount' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, SequencePlayInfo) == 0x003C58, "Member 'ABP_Character_C::SequencePlayInfo' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsSetVanishingHiddenSwitching) == 0x003C68, "Member 'ABP_Character_C::IsSetVanishingHiddenSwitching' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VanishingPreAppearEffectTime) == 0x003C70, "Member 'ABP_Character_C::VanishingPreAppearEffectTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VanishingPostAppearEffectTime) == 0x003C78, "Member 'ABP_Character_C::VanishingPostAppearEffectTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VanishingMoveTime) == 0x003C80, "Member 'ABP_Character_C::VanishingMoveTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, VanishingDisappearEffectTime) == 0x003C88, "Member 'ABP_Character_C::VanishingDisappearEffectTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, AuraColorEnum) == 0x003C90, "Member 'ABP_Character_C::AuraColorEnum' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitStopDeltaSeconds) == 0x003C98, "Member 'ABP_Character_C::HitStopDeltaSeconds' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, HitStopWorldDeltaSeconds) == 0x003CA0, "Member 'ABP_Character_C::HitStopWorldDeltaSeconds' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CenterLocation) == 0x003CA8, "Member 'ABP_Character_C::CenterLocation' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, RotateToCenterRemainingTime) == 0x003CC0, "Member 'ABP_Character_C::RotateToCenterRemainingTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsKnockBackDeceleration) == 0x003CC8, "Member 'ABP_Character_C::IsKnockBackDeceleration' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, KnockBackDecelerationTime) == 0x003CD0, "Member 'ABP_Character_C::KnockBackDecelerationTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsRequestTransitionBlastHitDemo) == 0x003CD8, "Member 'ABP_Character_C::IsRequestTransitionBlastHitDemo' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, Map_Change_Type) == 0x003CD9, "Member 'ABP_Character_C::Map_Change_Type' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, In_Start_Timing) == 0x003CDA, "Member 'ABP_Character_C::In_Start_Timing' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, CurrentActionElapsedTime) == 0x003CE0, "Member 'ABP_Character_C::CurrentActionElapsedTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsResetHitStopOnDamage) == 0x003CE8, "Member 'ABP_Character_C::IsResetHitStopOnDamage' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, InputFreeCameraLastReleaseTime) == 0x003CF0, "Member 'ABP_Character_C::InputFreeCameraLastReleaseTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, InputFreeCameraLastPressTime) == 0x003CF8, "Member 'ABP_Character_C::InputFreeCameraLastPressTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, InputFreeCameraLastVector) == 0x003D00, "Member 'ABP_Character_C::InputFreeCameraLastVector' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsEndHitStopDown) == 0x003D10, "Member 'ABP_Character_C::IsEndHitStopDown' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsStopRotateToCenterRemaining) == 0x003D11, "Member 'ABP_Character_C::IsStopRotateToCenterRemaining' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, AddDownToRevivalTime) == 0x003D18, "Member 'ABP_Character_C::AddDownToRevivalTime' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, IsDebugDrawDownValue) == 0x003D20, "Member 'ABP_Character_C::IsDebugDrawDownValue' has a wrong offset!");
static_assert(offsetof(ABP_Character_C, RunningForceFinichVanishing) == 0x003D21, "Member 'ABP_Character_C::RunningForceFinichVanishing' has a wrong offset!");

}

