#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_CharacterLocomotionSubHighSpeedMove

#include "Basic.hpp"

#include "ECharacterLocomotionEventType_structs.hpp"
#include "SS_structs.hpp"
#include "BP_CharacterLocomotionSubShortDash_classes.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_CharacterLocomotionSubHighSpeedMove.BP_CharacterLocomotionSubHighSpeedMove_C
// 0x0010 (0x00C0 - 0x00B0)
class UBP_CharacterLocomotionSubHighSpeedMove_C : public UBP_CharacterLocomotionSubShortDash_C
{
public:
	EKoratHighSpeedMoveState                      HighSpeedMoveStatus;                               // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsOmenToAppearDone;                                // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        OmenToAppearTimer;                                 // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void Check(class UBP_CharacterLocomotionComponent_C* InLocomotionComponent, bool* CanStart);
	void CheckEnable(bool* IsEnable);
	void CheckInput(bool* IsOK);
	void CheckSPCosumable(bool* IsOK);
	void ClearStatus();
	void ConsumeSPHighSpeedMoveIN();
	void GetHighSpeedMoveForecast(bool* IsDetermined, struct FVector* Location, struct FRotator* Rotation, double* RemainingTime);
	void GetHighSpeedMoveParameter(bool* ______K, double* ________________, double* ____B__INK_LPxw__, double* ____B__LPK_OTxw__, class UCurveFloat** _______IN, class UCurveFloat** _______LP, class UCurveFloat** _______OT, double* ________, double* _____, double* ___, EKoratFreeTimelineType* __Bn____________, class USSActionCameraDataAsset** __Bn___________, class USSActionCameraDataAsset** __Bn_Kn___________, double* B_Bn____________Y_OTw_K_nB______, EKoratFreeTimelineType* B_Bn____________, class USSActionCameraDataAsset** B_Bn___________, class USSActionCameraDataAsset** B_Bn_Kn___________);
	void GetHighSpeedMoveParameterInternal(bool* ______K, double* ________________, double* ____B__INK_LPxw__, double* ____B__LPK_OTxw__, class UCurveFloat** _______IN, class UCurveFloat** _______LP, class UCurveFloat** _______OT, double* ________, double* _____, double* ___, EKoratFreeTimelineType* __Bn____________, class USSActionCameraDataAsset** __Bn___________, class USSActionCameraDataAsset** __Bn_Kn___________, double* B_Bn____________Y_OTw_K_nB______, EKoratFreeTimelineType* B_Bn____________, class USSActionCameraDataAsset** B_Bn___________, class USSActionCameraDataAsset** B_Bn_Kn___________);
	void GetLocomotionDetailStatus(EKoratCharacterLocomotionDetailStatus* LocomotionDetailStatus);
	void GetRunningAction(struct FKoratActionDataList* RunningAction);
	void GetRunningSection(class FName* RunningSection);
	void GetShortDashParameter(class UCurveFloat** ___________, double* ________, double* _____, double* ___, double* OTxw_Y_LNB_, double* __B_, bool* Minus_Bk______Y_K, double* Minus_Bn___, double* ______0);
	void HighSpeedMoveIdleMove();
	void HighSpeedMoveIN();
	void HighSpeedMoveINStop();
	void HighSpeedMoveINUpdate();
	void HighSpeedMoveLP();
	void HighSpeedMoveLPStop();
	void HighSpeedMoveLPUpdate();
	void HighSpeedMoveOT();
	void HighSpeedMoveOTStop();
	void HighSpeedMoveOTUpdate();
	void InitializeOmenToAppear();
	void IsEnableAction(bool* IsEnable);
	void IsUpdateSpeed(bool* IsUpdate);
	void PlayOmenToAppear();
	void SetHighSpeedMoveStatus(EKoratHighSpeedMoveState InHighSpeedMoveStatus, EKoratCharacterActionFinishReason InActionFinishReason);
	void SetUpHighSpeedMove();
	void Start(class UBP_CharacterLocomotionComponent_C* InLocomotionComponent, bool InInSkip, bool* NewParam);
	void Update(class UBP_CharacterLocomotionComponent_C* InLocomotionComponent, ECharacterLocomotionEventType InEventType, double InDeltaSeconds, bool* NewParam);
	void UpdateHighSpeedMoveAlways(double InDeltaSeconds);
	void UpdateOmenToAppear(double InDeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_CharacterLocomotionSubHighSpeedMove_C">();
	}
	static class UBP_CharacterLocomotionSubHighSpeedMove_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_CharacterLocomotionSubHighSpeedMove_C>();
	}
};
static_assert(alignof(UBP_CharacterLocomotionSubHighSpeedMove_C) == 0x000008, "Wrong alignment on UBP_CharacterLocomotionSubHighSpeedMove_C");
static_assert(sizeof(UBP_CharacterLocomotionSubHighSpeedMove_C) == 0x0000C0, "Wrong size on UBP_CharacterLocomotionSubHighSpeedMove_C");
static_assert(offsetof(UBP_CharacterLocomotionSubHighSpeedMove_C, HighSpeedMoveStatus) == 0x0000B0, "Member 'UBP_CharacterLocomotionSubHighSpeedMove_C::HighSpeedMoveStatus' has a wrong offset!");
static_assert(offsetof(UBP_CharacterLocomotionSubHighSpeedMove_C, IsOmenToAppearDone) == 0x0000B1, "Member 'UBP_CharacterLocomotionSubHighSpeedMove_C::IsOmenToAppearDone' has a wrong offset!");
static_assert(offsetof(UBP_CharacterLocomotionSubHighSpeedMove_C, OmenToAppearTimer) == 0x0000B8, "Member 'UBP_CharacterLocomotionSubHighSpeedMove_C::OmenToAppearTimer' has a wrong offset!");

}

