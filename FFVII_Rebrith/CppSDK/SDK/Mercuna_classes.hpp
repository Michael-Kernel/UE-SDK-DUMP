#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Mercuna_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Mercuna.BTDecorator_Mercuna_Reachable
// 0x0058 (0x00E0 - 0x0088)
class UBTDecorator_Mercuna_Reachable final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 Source;                                            // 0x0088(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 Destination;                                       // 0x00B0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MaxPathLength;                                     // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Mercuna_Reachable">();
	}
	static class UBTDecorator_Mercuna_Reachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Mercuna_Reachable>();
	}
};
static_assert(alignof(UBTDecorator_Mercuna_Reachable) == 0x000008, "Wrong alignment on UBTDecorator_Mercuna_Reachable");
static_assert(sizeof(UBTDecorator_Mercuna_Reachable) == 0x0000E0, "Wrong size on UBTDecorator_Mercuna_Reachable");
static_assert(offsetof(UBTDecorator_Mercuna_Reachable, Source) == 0x000088, "Member 'UBTDecorator_Mercuna_Reachable::Source' has a wrong offset!");
static_assert(offsetof(UBTDecorator_Mercuna_Reachable, Destination) == 0x0000B0, "Member 'UBTDecorator_Mercuna_Reachable::Destination' has a wrong offset!");
static_assert(offsetof(UBTDecorator_Mercuna_Reachable, MaxPathLength) == 0x0000D8, "Member 'UBTDecorator_Mercuna_Reachable::MaxPathLength' has a wrong offset!");

// Class Mercuna.BTTask_Mercuna_MoveTo
// 0x0010 (0x00C0 - 0x00B0)
class UBTTask_Mercuna_MoveTo final : public UBTTask_BlackboardBase
{
public:
	float                                         Speed;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bObserveBlackboardValue : 1;                       // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialPath : 1;                             // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Mercuna_MoveTo">();
	}
	static class UBTTask_Mercuna_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Mercuna_MoveTo>();
	}
};
static_assert(alignof(UBTTask_Mercuna_MoveTo) == 0x000008, "Wrong alignment on UBTTask_Mercuna_MoveTo");
static_assert(sizeof(UBTTask_Mercuna_MoveTo) == 0x0000C0, "Wrong size on UBTTask_Mercuna_MoveTo");
static_assert(offsetof(UBTTask_Mercuna_MoveTo, Speed) == 0x0000B0, "Member 'UBTTask_Mercuna_MoveTo::Speed' has a wrong offset!");
static_assert(offsetof(UBTTask_Mercuna_MoveTo, EndDistance) == 0x0000B4, "Member 'UBTTask_Mercuna_MoveTo::EndDistance' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_Sphere
// 0x00D0 (0x0138 - 0x0068)
class UEnvQueryGenerator_Mercuna_Sphere final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0068(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0098(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfShells;                                    // 0x00C8(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                PointsPerShell;                                    // 0x00F8(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMercunaPointDistribution                     Distribution;                                      // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_Sphere">();
	}
	static class UEnvQueryGenerator_Mercuna_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_Sphere>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_Sphere) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_Sphere");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_Sphere) == 0x000138, "Wrong size on UEnvQueryGenerator_Mercuna_Sphere");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, InnerRadius) == 0x000068, "Member 'UEnvQueryGenerator_Mercuna_Sphere::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, OuterRadius) == 0x000098, "Member 'UEnvQueryGenerator_Mercuna_Sphere::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, NumberOfShells) == 0x0000C8, "Member 'UEnvQueryGenerator_Mercuna_Sphere::NumberOfShells' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, PointsPerShell) == 0x0000F8, "Member 'UEnvQueryGenerator_Mercuna_Sphere::PointsPerShell' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, Distribution) == 0x000128, "Member 'UEnvQueryGenerator_Mercuna_Sphere::Distribution' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, Center) == 0x000130, "Member 'UEnvQueryGenerator_Mercuna_Sphere::Center' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_3DRing
// 0x0158 (0x01C0 - 0x0068)
class UEnvQueryGenerator_Mercuna_3DRing final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0068(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0098(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfRings;                                     // 0x00C8(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                PointsPerRing;                                     // 0x00F8(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MinHeight;                                         // 0x0128(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxHeight;                                         // 0x0158(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfLayers;                                    // 0x0188(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_3DRing">();
	}
	static class UEnvQueryGenerator_Mercuna_3DRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_3DRing>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_3DRing) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_3DRing");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_3DRing) == 0x0001C0, "Wrong size on UEnvQueryGenerator_Mercuna_3DRing");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, InnerRadius) == 0x000068, "Member 'UEnvQueryGenerator_Mercuna_3DRing::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, OuterRadius) == 0x000098, "Member 'UEnvQueryGenerator_Mercuna_3DRing::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, NumberOfRings) == 0x0000C8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::NumberOfRings' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, PointsPerRing) == 0x0000F8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::PointsPerRing' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, MinHeight) == 0x000128, "Member 'UEnvQueryGenerator_Mercuna_3DRing::MinHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, MaxHeight) == 0x000158, "Member 'UEnvQueryGenerator_Mercuna_3DRing::MaxHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, NumberOfLayers) == 0x000188, "Member 'UEnvQueryGenerator_Mercuna_3DRing::NumberOfLayers' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, Center) == 0x0001B8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::Center' has a wrong offset!");

// Class Mercuna.MercunaQueryTest
// 0x0000 (0x66FD - 0x66FD)
#pragma pack(push, 0x1)
class alignas(0x66FD) UMercunaQueryTest : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaQueryTest">();
	}
	static class UMercunaQueryTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaQueryTest>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMercunaQueryTest) == 0x0066FD, "Wrong alignment on UMercunaQueryTest");
static_assert(sizeof(UMercunaQueryTest) == 0x0066FD, "Wrong size on UMercunaQueryTest");

// Class Mercuna.EnvQueryTest_Mercuna_NavigableVolume
// 0x0000 (0x66FD - 0x66FD)
class UEnvQueryTest_Mercuna_NavigableVolume final : public UMercunaQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna_NavigableVolume">();
	}
	static class UEnvQueryTest_Mercuna_NavigableVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna_NavigableVolume>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna_NavigableVolume) == 0x0066FD, "Wrong alignment on UEnvQueryTest_Mercuna_NavigableVolume");
static_assert(sizeof(UEnvQueryTest_Mercuna_NavigableVolume) == 0x0066FD, "Wrong size on UEnvQueryTest_Mercuna_NavigableVolume");
static_assert(offsetof(UEnvQueryTest_Mercuna_NavigableVolume, Context) == 0x0001D8, "Member 'UEnvQueryTest_Mercuna_NavigableVolume::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna_Reachable
// 0x0000 (0x66FD - 0x66FD)
class UEnvQueryTest_Mercuna_Reachable final : public UMercunaQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxPathLength;                                     // 0x01D8(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna_Reachable">();
	}
	static class UEnvQueryTest_Mercuna_Reachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna_Reachable) == 0x0066FD, "Wrong alignment on UEnvQueryTest_Mercuna_Reachable");
static_assert(sizeof(UEnvQueryTest_Mercuna_Reachable) == 0x0066FD, "Wrong size on UEnvQueryTest_Mercuna_Reachable");
static_assert(offsetof(UEnvQueryTest_Mercuna_Reachable, MaxPathLength) == 0x0001D8, "Member 'UEnvQueryTest_Mercuna_Reachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna_Reachable, Context) == 0x000208, "Member 'UEnvQueryTest_Mercuna_Reachable::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna_NavRaycast
// 0x0000 (0x66FD - 0x66FD)
class UEnvQueryTest_Mercuna_NavRaycast final : public UMercunaQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna_NavRaycast">();
	}
	static class UEnvQueryTest_Mercuna_NavRaycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna_NavRaycast) == 0x0066FD, "Wrong alignment on UEnvQueryTest_Mercuna_NavRaycast");
static_assert(sizeof(UEnvQueryTest_Mercuna_NavRaycast) == 0x0066FD, "Wrong size on UEnvQueryTest_Mercuna_NavRaycast");
static_assert(offsetof(UEnvQueryTest_Mercuna_NavRaycast, Context) == 0x0001D8, "Member 'UEnvQueryTest_Mercuna_NavRaycast::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna_Project
// 0x0000 (0x66FD - 0x66FD)
class UEnvQueryTest_Mercuna_Project final : public UMercunaQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxSearchRadius;                                   // 0x01D8(0x115E68C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna_Project">();
	}
	static class UEnvQueryTest_Mercuna_Project* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna_Project) == 0x0066FD, "Wrong alignment on UEnvQueryTest_Mercuna_Project");
static_assert(sizeof(UEnvQueryTest_Mercuna_Project) == 0x0066FD, "Wrong size on UEnvQueryTest_Mercuna_Project");
static_assert(offsetof(UEnvQueryTest_Mercuna_Project, MaxSearchRadius) == 0x0001D8, "Member 'UEnvQueryTest_Mercuna_Project::MaxSearchRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna_Project, Context) == 0x000208, "Member 'UEnvQueryTest_Mercuna_Project::Context' has a wrong offset!");

// Class Mercuna.MercunaNavExclusionComponent
// 0x0000 (0xD38D - 0xD38D)
class UMercunaNavExclusionComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavExclusionComponent">();
	}
	static class UMercunaNavExclusionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavExclusionComponent>();
	}
};
static_assert(alignof(UMercunaNavExclusionComponent) == 0x00D38D, "Wrong alignment on UMercunaNavExclusionComponent");
static_assert(sizeof(UMercunaNavExclusionComponent) == 0x00D38D, "Wrong size on UMercunaNavExclusionComponent");

// Class Mercuna.MercunaNavigationComponent
// 0x0000 (0xD38D - 0xD38D)
class UMercunaNavigationComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnMoveCompleted;                                   // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FMercunaNavigationConfiguration        Configuration;                                     // 0x0210(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          Pathfinding;                                       // 0x021C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DynamicAvoidance;                                  // 0x021D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E[0x32];                                     // 0x021E(0x0032)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelLookAt();
	void CancelMovement();
	void CheckReachable(const struct FVector& Point, bool* Success, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void ClearAvoidanceExclusions();
	void Configure(const struct FMercunaNavigationConfiguration& NewConfiguration);
	void ConfigureMovement(bool bUsePathfinding, bool bUseDynamicAvoidance);
	void GetPathInfo(bool* Valid, float* DistanceToEnd, struct FVector* NextPathPoint, bool* bIsFinalPoint);
	void LookAt(class AActor* Actor, float MaxPitch);
	void MercunaMoveComplete__DelegateSignature(const struct FAIRequestID& RequestID, const EMercunaMoveResult Result);
	void MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath);
	void MoveToLocation(const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath);
	void SetAvoidanceAgainst(class AActor* Actor, bool Enable);
	void Stop();
	void TrackActor(class AActor* Actor, float Distance, float Speed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavigationComponent">();
	}
	static class UMercunaNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavigationComponent>();
	}
};
static_assert(alignof(UMercunaNavigationComponent) == 0x00D38D, "Wrong alignment on UMercunaNavigationComponent");
static_assert(sizeof(UMercunaNavigationComponent) == 0x00D38D, "Wrong size on UMercunaNavigationComponent");
static_assert(offsetof(UMercunaNavigationComponent, OnMoveCompleted) == 0x000200, "Member 'UMercunaNavigationComponent::OnMoveCompleted' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, Configuration) == 0x000210, "Member 'UMercunaNavigationComponent::Configuration' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, Pathfinding) == 0x00021C, "Member 'UMercunaNavigationComponent::Pathfinding' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, DynamicAvoidance) == 0x00021D, "Member 'UMercunaNavigationComponent::DynamicAvoidance' has a wrong offset!");

// Class Mercuna.MercunaMoveToProxy
// 0x0050 (0x0090 - 0x0040)
class UMercunaMoveToProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x30];                                      // 0x0060(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaMoveToProxy* MercunaMoveToActor(class UObject* WorldContextObject, class APawn* Pawn, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath);
	static class UMercunaMoveToProxy* MercunaMoveToLocation(class UObject* WorldContextObject, class APawn* Pawn, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaMoveToProxy">();
	}
	static class UMercunaMoveToProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaMoveToProxy>();
	}
};
static_assert(alignof(UMercunaMoveToProxy) == 0x000008, "Wrong alignment on UMercunaMoveToProxy");
static_assert(sizeof(UMercunaMoveToProxy) == 0x000090, "Wrong size on UMercunaMoveToProxy");
static_assert(offsetof(UMercunaMoveToProxy, OnSuccess) == 0x000040, "Member 'UMercunaMoveToProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaMoveToProxy, OnFailure) == 0x000050, "Member 'UMercunaMoveToProxy::OnFailure' has a wrong offset!");

// Class Mercuna.MercunaTrackActorProxy
// 0x0030 (0x0070 - 0x0040)
class UMercunaTrackActorProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaTrackActorProxy* MercunaTrackActor(class UObject* WorldContextObject, class APawn* Pawn, class AActor* Actor, float Distance, float Speed);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaTrackActorProxy">();
	}
	static class UMercunaTrackActorProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaTrackActorProxy>();
	}
};
static_assert(alignof(UMercunaTrackActorProxy) == 0x000008, "Wrong alignment on UMercunaTrackActorProxy");
static_assert(sizeof(UMercunaTrackActorProxy) == 0x000070, "Wrong size on UMercunaTrackActorProxy");
static_assert(offsetof(UMercunaTrackActorProxy, OnFailure) == 0x000040, "Member 'UMercunaTrackActorProxy::OnFailure' has a wrong offset!");

// Class Mercuna.MercunaNavInclusionComponent
// 0x0000 (0xD38D - 0xD38D)
class UMercunaNavInclusionComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavInclusionComponent">();
	}
	static class UMercunaNavInclusionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavInclusionComponent>();
	}
};
static_assert(alignof(UMercunaNavInclusionComponent) == 0x00D38D, "Wrong alignment on UMercunaNavInclusionComponent");
static_assert(sizeof(UMercunaNavInclusionComponent) == 0x00D38D, "Wrong size on UMercunaNavInclusionComponent");

// Class Mercuna.MercunaNavOctree
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMercunaNavOctree final : public AActor
{
public:
	float                                         CellSize;                                          // 0x03E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPawnRadius;                                     // 0x03E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPawnRadius;                                     // 0x03E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0xC];                                      // 0x03EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EMerOctreeDebugDrawMode                       DebugDrawMode;                                     // 0x03F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMerNavOctreeRenderingComponent*        MerNavOctreeRenderingComponent;                    // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBuildAsSublevel;                                  // 0x0408(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNeedsRebuild;                                     // 0x0409(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40A[0x2];                                      // 0x040A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_origin;                                          // 0x040C(0x000C)(IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckReachable(const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxPathLength, bool* Result);
	void ClampToNavigable(const struct FVector& Position, float NavigationRadius, float SearchRadius, struct FVector* ClampedPosition, bool* Result);
	class UMercunaPath* FindPathToActor(const struct FVector& Start, class AActor* GoalActor, float NavigationRadius, bool AllowPartial, float MaxPathLength);
	class UMercunaPath* FindPathToLocation(const struct FVector& Start, const struct FVector& End, float NavigationRadius, bool AllowPartial, float MaxPathLength);
	void IsNavigable(const struct FVector& Position, float NavigationRadius, bool* Result);
	void IsNavigableMulti(const TArray<struct FVector>& Positions, float NavigationRadius, TArray<bool>* Results);
	void Raycast(const struct FVector& Start, const struct FVector& End, float NavigationRadius, struct FVector* HitPosition, bool* RayHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavOctree">();
	}
	static class AMercunaNavOctree* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavOctree>();
	}
};
static_assert(alignof(AMercunaNavOctree) == 0x1EF72E00, "Wrong alignment on AMercunaNavOctree");
static_assert(sizeof(AMercunaNavOctree) == 0x1EF72E00, "Wrong size on AMercunaNavOctree");
static_assert(offsetof(AMercunaNavOctree, CellSize) == 0x0003E0, "Member 'AMercunaNavOctree::CellSize' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, MinPawnRadius) == 0x0003E4, "Member 'AMercunaNavOctree::MinPawnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, MaxPawnRadius) == 0x0003E8, "Member 'AMercunaNavOctree::MaxPawnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, DebugDrawMode) == 0x0003F8, "Member 'AMercunaNavOctree::DebugDrawMode' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, MerNavOctreeRenderingComponent) == 0x000400, "Member 'AMercunaNavOctree::MerNavOctreeRenderingComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, bBuildAsSublevel) == 0x000408, "Member 'AMercunaNavOctree::bBuildAsSublevel' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, bNeedsRebuild) == 0x000409, "Member 'AMercunaNavOctree::bNeedsRebuild' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, M_origin) == 0x00040C, "Member 'AMercunaNavOctree::M_origin' has a wrong offset!");

// Class Mercuna.MercunaNavSeed
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMercunaNavSeed final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavSeed">();
	}
	static class AMercunaNavSeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavSeed>();
	}
};
static_assert(alignof(AMercunaNavSeed) == 0x1EF72E00, "Wrong alignment on AMercunaNavSeed");
static_assert(sizeof(AMercunaNavSeed) == 0x1EF72E00, "Wrong size on AMercunaNavSeed");

// Class Mercuna.MercunaNavSeedComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UMercunaNavSeedComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavSeedComponent">();
	}
	static class UMercunaNavSeedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavSeedComponent>();
	}
};
static_assert(alignof(UMercunaNavSeedComponent) == 0x112E9AF0, "Wrong alignment on UMercunaNavSeedComponent");
static_assert(sizeof(UMercunaNavSeedComponent) == 0x112E9AF0, "Wrong size on UMercunaNavSeedComponent");

// Class Mercuna.MercunaNavTestingActor
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMercunaNavTestingActor final : public AActor
{
public:
	float                                         Radius;                                            // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSearchStart : 1;                                  // 0x03E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavTestingActor*                OtherActor;                                        // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPathExist : 1;                                    // 0x03F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsPartial : 1;                                // 0x03F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsOutOfNodes : 1;                             // 0x03F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathLength;                                        // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathSteps;                                         // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathFindTime;                                      // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathNodesUsed;                                     // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMercunaPath*                           Path;                                              // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPathUpdate(EMercunaPathEvent PathEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavTestingActor">();
	}
	static class AMercunaNavTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavTestingActor>();
	}
};
static_assert(alignof(AMercunaNavTestingActor) == 0x1EF72E00, "Wrong alignment on AMercunaNavTestingActor");
static_assert(sizeof(AMercunaNavTestingActor) == 0x1EF72E00, "Wrong size on AMercunaNavTestingActor");
static_assert(offsetof(AMercunaNavTestingActor, Radius) == 0x0003E0, "Member 'AMercunaNavTestingActor::Radius' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, OtherActor) == 0x0003E8, "Member 'AMercunaNavTestingActor::OtherActor' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathLength) == 0x0003F4, "Member 'AMercunaNavTestingActor::PathLength' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathSteps) == 0x0003F8, "Member 'AMercunaNavTestingActor::PathSteps' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathFindTime) == 0x0003FC, "Member 'AMercunaNavTestingActor::PathFindTime' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathNodesUsed) == 0x000400, "Member 'AMercunaNavTestingActor::PathNodesUsed' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, SphereComponent) == 0x000408, "Member 'AMercunaNavTestingActor::SphereComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, Path) == 0x000410, "Member 'AMercunaNavTestingActor::Path' has a wrong offset!");

// Class Mercuna.MercunaNavVolume
// 0x0000 (0x1EF72E00 - 0x1EF72E00)
class AMercunaNavVolume final : public AVolume
{
public:
	class AMercunaNavOctree*                      NavOctree;                                         // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavVolume">();
	}
	static class AMercunaNavVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavVolume>();
	}
};
static_assert(alignof(AMercunaNavVolume) == 0x1EF72E00, "Wrong alignment on AMercunaNavVolume");
static_assert(sizeof(AMercunaNavVolume) == 0x1EF72E00, "Wrong size on AMercunaNavVolume");
static_assert(offsetof(AMercunaNavVolume, NavOctree) == 0x000420, "Member 'AMercunaNavVolume::NavOctree' has a wrong offset!");

// Class Mercuna.MercunaObstacleComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UMercunaObstacleComponent final : public USceneComponent
{
public:
	EMerObstacleType                              Type;                                              // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x3];                                      // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaObstacleComponent">();
	}
	static class UMercunaObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaObstacleComponent>();
	}
};
static_assert(alignof(UMercunaObstacleComponent) == 0x112E9AF0, "Wrong alignment on UMercunaObstacleComponent");
static_assert(sizeof(UMercunaObstacleComponent) == 0x112E9AF0, "Wrong size on UMercunaObstacleComponent");
static_assert(offsetof(UMercunaObstacleComponent, Type) == 0x000418, "Member 'UMercunaObstacleComponent::Type' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, Radius) == 0x00041C, "Member 'UMercunaObstacleComponent::Radius' has a wrong offset!");

// Class Mercuna.MercunaClampToNavigableProxy
// 0x0040 (0x0080 - 0x0040)
class UMercunaClampToNavigableProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaClampToNavigableProxy* MercunaClampToNavigable(class UObject* WorldContextObject, const struct FVector& Position, float NavigationRadius, float SearchRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaClampToNavigableProxy">();
	}
	static class UMercunaClampToNavigableProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaClampToNavigableProxy>();
	}
};
static_assert(alignof(UMercunaClampToNavigableProxy) == 0x000008, "Wrong alignment on UMercunaClampToNavigableProxy");
static_assert(sizeof(UMercunaClampToNavigableProxy) == 0x000080, "Wrong size on UMercunaClampToNavigableProxy");
static_assert(offsetof(UMercunaClampToNavigableProxy, OnSuccess) == 0x000040, "Member 'UMercunaClampToNavigableProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaClampToNavigableProxy, OnFailure) == 0x000050, "Member 'UMercunaClampToNavigableProxy::OnFailure' has a wrong offset!");

// Class Mercuna.MercunaRaycastProxy
// 0x0048 (0x0088 - 0x0040)
class UMercunaRaycastProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnHit;                                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNoHit;                                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaRaycastProxy* MercunaRaycast(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float NavigationRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaRaycastProxy">();
	}
	static class UMercunaRaycastProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaRaycastProxy>();
	}
};
static_assert(alignof(UMercunaRaycastProxy) == 0x000008, "Wrong alignment on UMercunaRaycastProxy");
static_assert(sizeof(UMercunaRaycastProxy) == 0x000088, "Wrong size on UMercunaRaycastProxy");
static_assert(offsetof(UMercunaRaycastProxy, OnHit) == 0x000040, "Member 'UMercunaRaycastProxy::OnHit' has a wrong offset!");
static_assert(offsetof(UMercunaRaycastProxy, OnNoHit) == 0x000050, "Member 'UMercunaRaycastProxy::OnNoHit' has a wrong offset!");

// Class Mercuna.MercunaPath
// 0x0018 (0x0058 - 0x0040)
class UMercunaPath final : public UObject
{
public:
	UMulticastDelegateProperty_                   PathUpdated;                                       // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumPoints() const;
	float GetPathLength() const;
	struct FVector GetPoint(int32 I) const;
	bool IsPartial() const;
	bool IsReady() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaPath">();
	}
	static class UMercunaPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaPath>();
	}
};
static_assert(alignof(UMercunaPath) == 0x000008, "Wrong alignment on UMercunaPath");
static_assert(sizeof(UMercunaPath) == 0x000058, "Wrong size on UMercunaPath");
static_assert(offsetof(UMercunaPath, PathUpdated) == 0x000040, "Member 'UMercunaPath::PathUpdated' has a wrong offset!");

// Class Mercuna.MercunaTask_MoveTo
// 0x0060 (0x00E8 - 0x0088)
class UMercunaTask_MoveTo final : public UAITask
{
public:
	UMulticastDelegateProperty_                   OnRequestFailed;                                   // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnMoveFinished;                                    // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x40];                                      // 0x00A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaTask_MoveTo* MercunaMoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaTask_MoveTo">();
	}
	static class UMercunaTask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaTask_MoveTo>();
	}
};
static_assert(alignof(UMercunaTask_MoveTo) == 0x000008, "Wrong alignment on UMercunaTask_MoveTo");
static_assert(sizeof(UMercunaTask_MoveTo) == 0x0000E8, "Wrong size on UMercunaTask_MoveTo");
static_assert(offsetof(UMercunaTask_MoveTo, OnRequestFailed) == 0x000088, "Member 'UMercunaTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UMercunaTask_MoveTo, OnMoveFinished) == 0x000098, "Member 'UMercunaTask_MoveTo::OnMoveFinished' has a wrong offset!");

// Class Mercuna.MerNavOctreeRenderingComponent
// 0x0000 (0x112E9AF0 - 0x112E9AF0)
class UMerNavOctreeRenderingComponent final : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0868(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SelectionMaterial;                                 // 0x0870(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_878[0x28];                                     // 0x0878(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerNavOctreeRenderingComponent">();
	}
	static class UMerNavOctreeRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerNavOctreeRenderingComponent>();
	}
};
static_assert(alignof(UMerNavOctreeRenderingComponent) == 0x112E9AF0, "Wrong alignment on UMerNavOctreeRenderingComponent");
static_assert(sizeof(UMerNavOctreeRenderingComponent) == 0x112E9AF0, "Wrong size on UMerNavOctreeRenderingComponent");
static_assert(offsetof(UMerNavOctreeRenderingComponent, Material) == 0x000868, "Member 'UMerNavOctreeRenderingComponent::Material' has a wrong offset!");
static_assert(offsetof(UMerNavOctreeRenderingComponent, SelectionMaterial) == 0x000870, "Member 'UMerNavOctreeRenderingComponent::SelectionMaterial' has a wrong offset!");

// Class Mercuna.MerSettings
// 0x0018 (0x0058 - 0x0040)
class UMerSettings final : public UObject
{
public:
	float                                         DebugLengthScale;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowErrors;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CellSize;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPawnRadius;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPawnRadius;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerSettings">();
	}
	static class UMerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerSettings>();
	}
};
static_assert(alignof(UMerSettings) == 0x000008, "Wrong alignment on UMerSettings");
static_assert(sizeof(UMerSettings) == 0x000058, "Wrong size on UMerSettings");
static_assert(offsetof(UMerSettings, DebugLengthScale) == 0x000040, "Member 'UMerSettings::DebugLengthScale' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAlwaysShowErrors) == 0x000044, "Member 'UMerSettings::bAlwaysShowErrors' has a wrong offset!");
static_assert(offsetof(UMerSettings, CellSize) == 0x000048, "Member 'UMerSettings::CellSize' has a wrong offset!");
static_assert(offsetof(UMerSettings, MinPawnRadius) == 0x00004C, "Member 'UMerSettings::MinPawnRadius' has a wrong offset!");
static_assert(offsetof(UMerSettings, MaxPawnRadius) == 0x000050, "Member 'UMerSettings::MaxPawnRadius' has a wrong offset!");

}

